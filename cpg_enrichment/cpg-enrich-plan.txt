CPG Graph Data Enrichment Stage

1. Extend enrichment to new node types:
• [x] METHOD_PARAMETER_IN / OUT: Classify parameters by role (e.g., MVCC snapshot, transaction context, page, lock mode) and assign param-role, domain-concept, validation-required tags for each input/output parameter. This will enable finding functions that accept specific entities (snapshot, context) or require parameter validation.
• [x] METHOD_RETURN: Assign semantics to return value tags, e.g., return-kind (boolean, pointer, structure, list), error-code, optional, allocates-memory. This reflects what the function returns (success flag, error code, data pointer, etc.) and how to interpret the result.
• [x] IDENTIFIER: Mark variable usage nodes with tags like variable-role (iterator, flag, counter), data-kind (transaction ID, snapshot, query string), security-sensitivity, is-lock, is-pointer-to-struct. Perform classification based on variable name, type, usage context, and comments.
• [x] LOCAL: Enrich local variable declarations similarly to IDENTIFIER (assign role and data type tags), and add tags for lifetime (auto/static), init-value (initialization value), and mutability (mutable/immutable variable).
• [x] FIELD_IDENTIFIER: Add field-semantic tags for key PostgreSQL structure fields. For example, mark t_infomask as "visibility bit mask", xmin as "creating transaction ID". This will facilitate searching by structure field semantics.
• [x] LITERAL: Classify literal nodes (numeric and string constants) by domain. Assign tags constant-kind (e.g., error code, special value, bit mask), domain-constant (domain constant), is-null-constant (whether the literal is null/0). This will help distinguish, e.g., InvalidBlockNumber or error codes from regular numbers.
• [x] MODIFIER: Annotate modifier nodes (e.g., public, static, volatile) for semantic classification of visibility and concurrency. Add visibility and concurrency-safety tags – e.g., mark STATIC+VOLATILE combination as "global variable requiring synchronization".
• [x] TYPE_DECL: Extend type declaration enrichment – assign data-structure (e.g., list, tree, hash table), domain-entity (table, index, buffer) or concurrency-primitive (mutex, spinlock) tags to each type. This will provide quick semantic separation of data structures and synchronization mechanisms.
• [x] TYPE / TYPE_ARGUMENT / TYPE_PARAMETER: Enrich type nodes (including template parameters and type arguments) with tags reflecting their category: generic-instantiation (e.g., List<HeapTuple> template), type-category (primitive, pointer, custom type) and ownership (whether it owns a resource).
• [x] MEMBER: Mark structure field nodes (MEMBER) with member-role tags (field role: data, reference, state), as well as flags is-pointer (pointer field), is-length-field (array/buffer size field) or unit (if applicable).
• [x] METHOD_REF: Add tags for method reference nodes to distinguish callbacks and function pointers. For example, assign callback or function-pointer-target tags where a function is used as a pointer (passed as an argument).
• [x] NAMESPACE / NAMESPACE_BLOCK: Enrich namespaces with subsystem-name (subsystem name), module-layer (module layer in architecture), library-kind (component type: core, extension, test, etc.). This will introduce subsystem/module context into the graph.
• [x] JUMP_LABEL / JUMP_TARGET: Mark jump label nodes (e.g., goto labels, break/continue targets) with tags like loop-break-target, error-handler-target. This will enable detecting loop exit patterns or error handling points.
• [x] RETURN: In addition to existing RETURN node processing, add semantic tags returns-error (error return) and returns-null (null/0 return) to explicitly mark places where a function terminates with an error result or empty value.

2. Annotate existing relationships (edges) with semantic attributes:
• [ ] AST edges: On AST and CONDITION edges, introduce child-role attribute specifying the child node's role in the structure (e.g., condition, then-branch, else-branch, loop-body, initializer, return-value, operand). Determine the value based on the parent node type (IF, WHILE, RETURN, etc.) and child position (ORDER).
• [ ] ARGUMENT edges: Annotate edges between calls and their arguments, adding parameter name and role. Use correspondence by ARGUMENT_INDEX and method signature to record param-name (function parameter name) and param-role (argument semantic role) attributes on the edge. This will immediately show the argument's meaning at the call site.
• [ ] CALL edges (call graph): Enrich edges from call node to method node with additional semantics of the called action. Save attributes like action-kind (action type: e.g., "creates object", "locks resource", "checks visibility") and side-effect-level (side effect level: none, local, global). These values can be derived based on tags of the called method (e.g., if method is tagged allocates-memory, then for call action-kind = allocate-memory).
• [ ] RECEIVER edges: Mark edges linking a call with the receiver object (for class methods or pointers) with an indication of the object's role. For example, mark receiver as this (if class method call), or as specific entity – tuple, buffer – based on object type/name. This will add context that the method is called on a specific resource.
• [ ] CFG edges: Add branch-kind tag on control flow graph edges to denote CFG transition type. For example, mark transitions as true-path or false-path from conditional operator, loop-back for loop start transition, exception-path for exception handling branches. Branch type is determined by analyzing CONTROL_STRUCTURE node (IF/LOOP/TRY type) and transition condition.
• [ ] Data dependency edges (DDG): For REACHING_DEF edges (and related), preserve information about transmitted data. Include variable name and its data-kind (e.g., "snapshot", "transaction-id", "buffer-pointer") in edge attributes so the semantic entity flowing through the link is visible at the edge level. This will enhance data flow analysis considering the domain.
• [ ] Control dependency edges (CDG): Mark control flow graph edges with control-reason attribute explaining the control flow reason. For example, mark dependency as null-check (transition due to NULL check), bounds-check (bounds check), lock-acquired (after lock acquisition), visibility-check (record visibility check). This allows understanding which check predetermines further code execution.
• [ ] Other edges: Extend enrichment of service edges. For EVAL_TYPE (node and type correspondence) add type-category tag similar to TYPE node classification (primitive, custom, etc.). For PARAMETER_LINK edges (between parameter and method return value) introduce tags indicating data flow nature between them, e.g., in-out-flow (data type or state flowing from input parameter to output). These attributes will make implicit relationships more expressive.

3. Introduce new semantic enrichment layers:
• [ ] Parameter and variable roles: Create param-variable-role layer where each parameter or variable node is assigned tags describing its role and domain entity. For example, mark parameters/variables as snapshot, lock-mode, heap-tuple, page-offset, memory-context based on their purpose. This will enable directly finding functions by participation of specific concepts (e.g., all functions accepting snapshot).
• [ ] Literal semantics: Implement constant classification by their domain meaning. Add tag layer for literals, categorizing them into: error-code (error codes), flag-mask (bit flags), relation-kind (table/relation types), system-catalog-id, etc. This layer will facilitate interpretation of conditional expressions and checks containing "magic" values.
• [ ] Type and structure semantics: Extend existing type-semantic enrichment for TYPE_DECL, TYPE and MEMBER nodes. Add tags reflecting domain meaning of structures and types: e.g., mark type as page structure, index block, MVCC record (refined domain-entity), or as synchronization primitive (mutex, latch). This will enhance understanding of which class the type belongs to (data container, synchronization mechanism, etc.).
• [ ] Jump labels and control paths: Add control-flow-semantic layer marking control nodes and corresponding CFG edges with flags like error-path (error branch), cleanup-path (cleanup/release path), commit-path (successful transaction commit), abort-path (transaction abort). This layer will enable explicit identification of code fragments related to error handling and operation completion.
• [ ] Call semantics (function actions): Create call-action layer for classifying each call by its action. Assign call tag based on effect: acquire-lock, release-lock, check-visibility, start-transaction, commit-transaction, allocate-memory, free-memory, etc. Base classification on existing patterns (e.g., from security_patterns.sc or performance_hotspots.sc scripts) and new rules for recognizing such patterns. This layer will enable queries like "find all places where X happens (locking, memory allocation, etc.)".
• [ ] Domain object flows: Reflect transfer of key entities (snapshots, transactions, buffers, etc.) through functions. Introduce virtual domain-flow edges (or similar tags on existing DDG edges) that link where a specific object moves from and to. For example, trace that Snapshot type object exits function A and is used in function B. These markings will provide an abstraction layer over data flow specific to PostgreSQL domain.

4. Implement enrichment extensions with appropriate methods:
• [ ] Signature and name parsing: Use name and type analysis via regex patterns and dictionaries. Utilize existing semantic classification script (e.g., extend semantic_classification.sc) to detect new patterns in parameter/variable names indicating their role (by prefixes, suffixes, substrings like xmin, buf, ctx, etc.). Build rule dictionary based on this to automatically assign corresponding tags.
• [ ] Comment analysis: Extract additional information from COMMENT nodes associated with functions and structures. Implement parser that searches comments for parameter role indications, algorithm descriptions, invariants. Use this information to assign tags (e.g., if function comment mentions "visibility map" – mark relevant parameters/fields with visibility-related tag).
• [ ] Control structure interpretation: Automatically determine branching context based on CONTROL_STRUCTURE nodes and their properties. Implement logic that deduces branch or loop semantics from construct type (IF, SWITCH, LOOP) and internal condition (NULL check, error code check, collection loop, etc.). Use these deductions immediately to set branch-kind attributes and related tags on CFG edges.
• [ ] PDG utilization: Use program dependency graph (both control and data) for enrichment. Utilize existing Joern relationships: reachingDef, dominate, postDominate, etc. Automate PDG traversal to identify where important variables are defined and used (e.g., find all functions where snapshot "flows" through data). Based on this, enrich CDG/DDG edges with required labels (control-reason, data-kind), and add new domain-flow relationships if necessary.
• [ ] Tag systematization and confidence: Document each new tag/pattern as thoroughly as existing ones. Update enrichment layer documentation describing origin of each new tag (which rule or analysis it comes from) and confidence/priority level. This is needed for quality maintenance: e.g., so test_cpg_quality.sc accounts for new tags and verifies they are applied correctly.

5. Supplement or create Joern scripts for new enrichments:
• [ ] Update existing enrichment scripts extending them for new requirements. Modify existing .sc scripts if necessary (e.g., add parsing of additional name patterns in semantic_classification.sc; adjust or supplement classification for new tags and patterns in security_patterns.sc and performance_hotspots.sc).
• [ ] Develop new enrich_* scripts from scratch for layers not covered by current set. For example, create enrich_execution_patterns.sc to identify and tag CFG patterns (lock/unlock, error-handling), enrich_data_flow.sc to mark critical data flow chains, enrich_param_roles.sc to assign roles to parameters and variables. Ensure these scripts integrate into existing pipeline (enrich_all.sc) and don't duplicate functionality.

6. QA follow-ups from test_cpg_quality.sc run:
• [ ] Filter analytics output to remove synthetic `<operator>` entries and deduplicate duplicates (e.g., repeated `palloc`, `<global>` results) before reporting.
• [ ] Investigate why `extension_points.sc` currently yields zero hooks/callbacks and restore tagging coverage.
• [ ] Extend dependency graph enrichment so module-layer tagging stops reporting all files as `unknown`.
