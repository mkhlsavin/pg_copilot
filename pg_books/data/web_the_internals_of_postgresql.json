[
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "A database cluster is a collection of databases managed by a PostgreSQL server.\nIf you are hearing this definition for the first time, you might be wondering what it means.\nThe term ‘database cluster’ in PostgreSQL does not mean ‘a group of database servers’.\nA PostgreSQL server runs on a single host and manages a single database cluster.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.009244"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "Figure 1.1 shows the logical structure of a database cluster.\nA database is a collection of database objects.\nIn the relational database theory, a database object is a data structure used to store or reference data.\nA (heap) table is a typical example, and there are many others, such as indexes, sequences, views, functions.\nIn PostgreSQL, databases themselves are also database objects and are logically separated from each other.\nAll other database objects (e.g., tables, indexes, etc) belong to their respective databases.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.009244"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "All the database objects in PostgreSQL are internally managed by respective object identifiers (OIDs), which are unsigned 4-byte integers.\nThe relations between database objects and their respective OIDs are stored in appropriate system catalogs, depending on the type of objects.\nFor example, OIDs of databases and heap tables are stored in pg_database and pg_class, respectively.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.009244"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "To find the desired OIDs, execute the following queries:",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.009244"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "[CODE BLOCK]\nsampledb=# SELECT datname, oid FROM pg_database WHERE datname = 'sampledb';\n datname  |  oid\n----------+-------\n sampledb | 16384\n(1 row)\n\nsampledb=# SELECT relname, oid FROM pg_class WHERE relname = 'sampletbl';\n  relname  |  oid\n-----------+-------\n sampletbl | 18740\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.009768"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "A database cluster is basically a single directory, referred to as base directory.\nIt contains some subdirectories and many files.\nWhen you execute the initdb utility to initialize a new database cluster,\na base directory will be created under the specified directory.\nThe path of the base directory is usually set to the environment variable PGDATA.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.869845"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "Figure 1.2 shows an example of database cluster in PostgreSQL.\nA database is a subdirectory under the base subdirectory,\nand each of the tables and indexes is (at least) one file stored under the subdirectory of the database to which it belongs.\nThere are several subdirectories containing particular data and configuration files.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.869845"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "While PostgreSQL supports tablespaces, the meaning of the term is different from other RDBMSs.\nA tablespace in PostgreSQL is a single directory that contains some data outside of the base directory.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.869845"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "In the following subsections, the layout of a database cluster, databases,\nfiles associated with tables and indexes, and tablespaces in PostgreSQL are described.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.869845"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 1: ",
    "section": "1.2.1. Layout of a Database Cluster",
    "text": "The layout of database cluster has been described in the official document.\nMain files and subdirectories in a part of the document have been listed in Table 1.1:",
    "tables": [
      {
        "table_index": 0,
        "content": "files | description\nPG_VERSION | A file containing the major version number of PostgreSQL.\ncurrent_logfiles | A file recording the log file(s) currently written to by the logging collector.\npg_hba.conf | A file to control PostgreSQL's client authentication.\npg_ident.conf | A file to control PostgreSQL's user name mapping.\npostgresql.conf | A file to set configuration parameters.\npostgresql.auto.conf | A file used for storing configuration parameters that are set in ALTER SYSTEM. (versions 9.4 or later)\npostmaster.opts | A file recording the command line options the server was last started with.\nsubdirectories | description\nbase/ | Subdirectory containing per-database subdirectories.\nglobal/ | Subdirectory containing cluster-wide tables, such as pg_database and pg_control.\npg_commit_ts/ | Subdirectory containing transaction commit timestamp data. (versions 9.5 or later)\npg_clog/ (versions 9.6 or earlier) | Subdirectory containing transaction commit state data. It is renamed to pg_xact in version 10.\npg_dynshmem/ | Subdirectory containing files used by the dynamic shared memory subsystem. (versions 9.4 or later)\npg_logical/ | Subdirectory containing status data for logical decoding. (versions 9.4 or later)\npg_multixact/ | Subdirectory containing multitransaction status data. (used for shared row locks)\npg_notify/ | Subdirectory containing LISTEN/NOTIFY status data.\npg_repslot/ | Subdirectory containing replication slot data. Replication Slots will be described in Section 11.4. (versions 9.4 or later)\npg_serial/ | Subdirectory containing information about committed serializable transactions. (versions 9.1 or later)\npg_snapshots/ | Subdirectory containing exported snapshots.\nThe PostgreSQL's function pg_export_snapshot creates a snapshot information file in this subdirectory.\n (versions 9.2 or later)\npg_stat/ | Subdirectory containing permanent files for the statistics subsystem.\npg_stat_tmp/ | Subdirectory containing temporary files for the statistics subsystem.\npg_subtrans/ | Subdirectory containing subtransaction status data.\npg_tblspc/ | Subdirectory containing symbolic links to tablespaces.\npg_twophase/ | Subdirectory containing state files for prepared transactions.\npg_wal/ (versions 10 or later) | Subdirectory containing WAL (Write Ahead Logging) segment files. It is renamed from pg_xlog in Version 10. WAL will be described in Chapter 9.\npg_xact/ (versions 10 or later) | Subdirectory containing transaction commit state data. It is renamed from pg_clog in Version 10.\nCLOG will be described in Section 5.4.\npg_xlog/ (versions 9.6 or earlier) | Subdirectory containing WAL (Write Ahead Logging) segment files. It is renamed to pg_wal in Version 10."
      }
    ],
    "extracted_at": "2025-10-03T12:31:58.869845"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 1: ",
    "section": "1.2.1. Layout of a Database Cluster",
    "text": "In version 10, the subdirectories pg_xlog and pg_clog were renamed to pg_wal and pg_xact, respectively.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 1: ",
    "section": "1.2.1. Layout of a Database Cluster",
    "text": "This change was made because there had been occasional reports of users unfamiliar with PostgreSQL mistakenly deleting these directories,\nthinking they were regular log storage folders.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 1: ",
    "section": "1.2.2. Layout of Databases",
    "text": "A database is a subdirectory under the base subdirectory.\nThe database directory names are identical to the respective OIDs.\nFor example, when the OID of the database ‘sampledb’ is 16384, its subdirectory name is 16384.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 1: ",
    "section": "1.2.2. Layout of Databases",
    "text": "[CODE BLOCK]\n$ cd $PGDATA\n$ ls -ld base/16384\ndrwx------  213 postgres postgres  7242  8 26 16:33 16384",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 1: ",
    "section": "1.2.3. Layout of Files Associated with Tables and Indexes",
    "text": "Each table or index whose size is less than 1GB is stored in a single file under the database directory to which it belongs.\nTables and indexes are internally managed by individual OIDs, while their data files are managed by the variable, relfilenode.\nThe relfilenode values of tables and indexes basically but not always match the respective OIDs, the details are described below.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 1: ",
    "section": "1.2.3. Layout of Files Associated with Tables and Indexes",
    "text": "For example, let’s show the OID and relfilenode of the table ‘sampletbl’:",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 1: ",
    "section": "1.2.3. Layout of Files Associated with Tables and Indexes",
    "text": "[CODE BLOCK]\nsampledb=# SELECT relname, oid, relfilenode FROM pg_class WHERE relname = 'sampletbl';\n  relname  |  oid  | relfilenode\n-----------+-------+-------------\n sampletbl | 18740 |       18740\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 1: ",
    "section": "1.2.3. Layout of Files Associated with Tables and Indexes",
    "text": "The oid and relfilenode values are equal in this case.\nAdditionally, the data file path of the table ‘sampletbl’ is ‘base/16384/18740’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 1: ",
    "section": "1.2.3. Layout of Files Associated with Tables and Indexes",
    "text": "[CODE BLOCK]\n$ cd $PGDATA\n$ ls -la base/16384/18740\n-rw------- 1 postgres postgres 8192 Apr 21 10:21 base/16384/18740",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 1: ",
    "section": "1.2.3. Layout of Files Associated with Tables and Indexes",
    "text": "The relfilenode values of tables and indexes can be changed by issuing certain commands, such as TRUNCATE, REINDEX, CLUSTER.\nFor example, if we truncate the table ‘sampletbl’, PostgreSQL will assign a new relfilenode (18812) to the table, removes the old data file (18740), and creates a new one (18812).",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 1: ",
    "section": "1.2.3. Layout of Files Associated with Tables and Indexes",
    "text": "[CODE BLOCK]\nsampledb=# TRUNCATE sampletbl;\nTRUNCATE TABLE\n\nsampledb=# SELECT relname, oid, relfilenode FROM pg_class WHERE relname = 'sampletbl';\n  relname  |  oid  | relfilenode\n-----------+-------+-------------\n sampletbl | 18740 |       18812\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 1: ",
    "section": "1.2.3. Layout of Files Associated with Tables and Indexes",
    "text": "In versions 9.0 or later, the built-in function pg_relation_filepath() is useful as this function returns the file path name of the relation with the specified OID or name.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 1: ",
    "section": "1.2.3. Layout of Files Associated with Tables and Indexes",
    "text": "[CODE BLOCK]\nsampledb=# SELECT pg_relation_filepath('sampletbl');\n pg_relation_filepath\n----------------------\n base/16384/18812\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 1: ",
    "section": "1.2.3. Layout of Files Associated with Tables and Indexes",
    "text": "When the file size of tables and indexes exceeds 1GB, PostgreSQL creates a new file named like relfilenode.1 and uses it.\nIf the new file is filled up, PostgreSQL will create another new file named like relfilenode.2 and so on.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 1: ",
    "section": "1.2.3. Layout of Files Associated with Tables and Indexes",
    "text": "[CODE BLOCK]\n$ cd $PGDATA\n$ ls -la -h base/16384/19427*\n-rw------- 1 postgres postgres 1.0G  Apr  21 11:16 data/base/16384/19427\n-rw------- 1 postgres postgres  45M  Apr  21 11:20 data/base/16384/19427.1",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 1: ",
    "section": "1.2.3. Layout of Files Associated with Tables and Indexes",
    "text": "The maximum file size of tables and indexes can be changed using the configuration, option “–with-segsize” when building PostgreSQL.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 1: ",
    "section": "1.2.3. Layout of Files Associated with Tables and Indexes",
    "text": "By examining the database subdirectories,\nit becomes apparent that each table has two associated files, suffixed with ‘_fsm’ and ‘_vm’.\nThese are referred to as the free space map and visibility map, respectively.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 1: ",
    "section": "1.2.3. Layout of Files Associated with Tables and Indexes",
    "text": "The free space map stores information about the free space capacity on each page within the table file,\nand the visibility map stores information about the visibility of each page within the table file.\n(More details can be found in Sections 5.3.4 and 6.2.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 1: ",
    "section": "1.2.3. Layout of Files Associated with Tables and Indexes",
    "text": "Indexes only have individual free space maps and do not have visibility map.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 1: ",
    "section": "1.2.3. Layout of Files Associated with Tables and Indexes",
    "text": "[CODE BLOCK]\n$ cd $PGDATA\n$ ls -la base/16384/18751*\n-rw------- 1 postgres postgres  8192 Apr 21 10:21 base/16384/18751\n-rw------- 1 postgres postgres 24576 Apr 21 10:18 base/16384/18751_fsm\n-rw------- 1 postgres postgres  8192 Apr 21 10:18 base/16384/18751_vm",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 1: ",
    "section": "1.2.3. Layout of Files Associated with Tables and Indexes",
    "text": "The free space map and visibility map may also be internally referred to as the forks of each relation.\nthe free space map is the first fork of the table/index data file (the fork number is 1),\nthe visibility map the second fork of the table’s data file (the fork number is 2).\nThe fork number of the data file is 0.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 1: ",
    "section": "1.2.4. Tablespaces",
    "text": "A tablespace in PostgreSQL is an additional data area outside the base directory.\nThis functionality was implemented in version 8.0.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 1: ",
    "section": "1.2.4. Tablespaces",
    "text": "Figure 1.3 shows the internal layout of a tablespace and its relationship with the main data area.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 1: ",
    "section": "1.2.4. Tablespaces",
    "text": "A tablespace is created within the directory specified during the execution of the CREATE TABLESPACE statement.\nUnder that directory, a version-specific subdirectory (e.g., PG_14_202011044) will be created.\nThe naming convention for the version-specific subdirectory is shown below.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 1: ",
    "section": "1.2.4. Tablespaces",
    "text": "For example,\ncreating a tablespace named ’new_tblspc’ at ‘/home/postgres/tblspc’, with an OID of 16386,\na subdirectory named ‘PG_14_202011044’ will be created under the tablespace.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 31,
    "chapter": "Chapter 1: ",
    "section": "1.2.4. Tablespaces",
    "text": "[CODE BLOCK]\n$ ls -l /home/postgres/tblspc/\ntotal 4\ndrwx------ 2 postgres postgres 4096 Apr 21 10:08 PG_14_202011044",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 32,
    "chapter": "Chapter 1: ",
    "section": "1.2.4. Tablespaces",
    "text": "The tablespace directory is addressed by a symbolic link from the pg_tblspc subdirectory.\nThe link name is the same as the OID value of tablespace.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 33,
    "chapter": "Chapter 1: ",
    "section": "1.2.4. Tablespaces",
    "text": "[CODE BLOCK]\n$ ls -l $PGDATA/pg_tblspc/\ntotal 0\nlrwxrwxrwx 1 postgres postgres 21 Apr 21 10:08 16386 -> /home/postgres/tblspc",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 34,
    "chapter": "Chapter 1: ",
    "section": "1.2.4. Tablespaces",
    "text": "When a new database (OID 16387) is created within the tablespace, its directory is placed under the version-specific subdirectory:",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 35,
    "chapter": "Chapter 1: ",
    "section": "1.2.4. Tablespaces",
    "text": "[CODE BLOCK]\n$ ls -l /home/postgres/tblspc/PG_14_202011044/\ntotal 4\ndrwx------ 2 postgres postgres 4096 Apr 21 10:10 16387",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 36,
    "chapter": "Chapter 1: ",
    "section": "1.2.4. Tablespaces",
    "text": "If a new table is created within a database located in the base directory,\na new directory is first created under the version-specific subdirectory, named according to the OID of the database.\nThe new table file is then placed in this newly created directory.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 37,
    "chapter": "Chapter 1: ",
    "section": "1.2.4. Tablespaces",
    "text": "[CODE BLOCK]\nsampledb=# CREATE TABLE newtbl (.....) TABLESPACE new_tblspc;\n\nsampledb=# SELECT pg_relation_filepath('newtbl');\n             pg_relation_filepath\n---------------------------------------------\n pg_tblspc/16386/PG_14_202011044/16384/18894",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:58.870350"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "Inside a data file (heap table, index, free space map, and visibility map),\nit is divided into pages (or blocks) of fixed length, which is 8192 bytes (8 KB) by default.\nThe pages within each file are numbered sequentially from 0, and these numbers are called block numbers.\nIf the file is full, PostgreSQL adds a new empty page to the end of the file to increase the file size.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:59.723345"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "The internal layout of pages depends on the data file type.\nIn this section, the table layout is described, as this information will be required in the following chapters.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:59.723345"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "A page within a table contains three kinds of data:",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:59.723345"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "heap tuple(s) â\nA heap tuple is a record data itself.\nHeap tuples are stacked in order from the bottom of the page.\n\nThe internal structure of tuple is described in Section 5.2 and Chapter 9,\nas it requires knowledge of both concurrency control (CC) and write-ahead logging (WAL) in PostgreSQL.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:59.723345"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "line pointer(s) â\nA line pointer is 4 bytes long and holds a pointer to each heap tuple. It is also called an item pointer.\n\nLine pointers form a simple array that plays the role of an index to the tuples.\nEach index is numbered sequentially from 1, and called offset number.\nWhen a new tuple is added to the page, a new line pointer is also pushed onto the array to point to the new tuple.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:59.723345"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "header data â\nA header data defined by the structure PageHeaderData is allocated in the beginning of the page.\nIt is 24 byte long and contains general information about the page.\n\nThe major variables of the structure are described below:\n\n\n\n\n\n\n        PageHeaderData\n    \n\ntypedef struct PageHeaderData @src/include/storage/bufpage.h\n{\n  /* XXX LSN is member of *any* block, not only page-organized ones */\n  PageXLogRecPtr       pd_lsn;      /* LSN: next byte after last byte of xlog\n  \t\t       \t\t     * record for last change to this page */\n  uint16        \tpd_checksum; /* checksum */\n  uint16        \tpd_flags;    /* flag bits, see below */\n  LocationIndex \tpd_lower;    /* offset to start of free space */\n  LocationIndex \tpd_upper;    /* offset to end of free space */\n  LocationIndex \tpd_special;  /* offset to start of special space */\n  uint16        \tpd_pagesize_version;\n  TransactionId \tpd_prune_xid;/* oldest prunable XID, or zero if none */\n  ItemIdData    \tpd_linp[1];  /* beginning of line pointer array */\n} PageHeaderData;\n\ntypedef PageHeaderData *PageHeader;\n\ntypedef uint64 XLogRecPtr;\n(",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:59.723345"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "[CODE BLOCK]\ntypedef struct PageHeaderData @src/include/storage/bufpage.h\n{\n  /* XXX LSN is member of *any* block, not only page-organized ones */\n  PageXLogRecPtr       pd_lsn;      /* LSN: next byte after last byte of xlog\n  \t\t       \t\t     * record for last change to this page */\n  uint16        \tpd_checksum; /* checksum */\n  uint16        \tpd_flags;    /* flag bits, see below */\n  LocationIndex \tpd_lower;    /* offset to start of free space */\n  LocationIndex \tpd_upper;    /* offset to end of free space */\n  LocationIndex \tpd_special;  /* offset to start of special space */\n  uint16        \tpd_pagesize_version;\n  TransactionId \tpd_prune_xid;/* oldest prunable XID, or zero if none */\n  ItemIdData    \tpd_linp[1];  /* beginning of line pointer array */\n} PageHeaderData;\n\ntypedef PageHeaderData *PageHeader;\n\ntypedef uint64 XLogRecPtr;",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:59.723345"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "pd_lsn â This variable stores the LSN of XLOG record written by the last change of this page.\nIt is an 8-byte unsigned integer, and is related to the WAL (Write-Ahead Logging) mechanism.\nThe details are described in Section 9.1.2.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:59.723345"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "pd_checksum â\nThis variable stores the checksum value of this page. (Note that this variable is supported in versions 9.3 or later; in earlier versions, this part had stored pd_tli, which is the timelineId of the page.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:59.723345"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "pd_lower, pd_upper â\npd_lower points to the end of line pointers, and pd_upper to the beginning of the newest heap tuple.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:59.723345"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "pd_special â\nThis variable is for indexes. In the page within tables, it points to the end of the page.\n(In the page within indexes, it points to the beginning of special space, which is the data area held only by indexes and contains the particular data according to the kind of index types such as B-tree, GiST, GiN, etc.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:59.723345"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "An empty space between the end of line pointers and the beginning of the newest tuple is referred to as free space or hole.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:59.723345"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "To identify a tuple within the table, a tuple identifier (TID) is used internally.\nA TID comprises a pair of values: the block number of the page that contains the tuple,\nand the offset number of the line pointer that points to the tuple.\nA typical example of its usage is index. See more detail in Section 1.4.2.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:59.723345"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "The structure PageHeaderData is defined in src/include/storage/bufpage.h.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:59.723345"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "In the field of computer science, this type of page is called a slotted page,\nand the line pointers correspond to a slot array.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:59.723345"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "In addition, heap tuple whose size is greater than about 2 KB (about 1/4 of 8 KB) is stored and managed using a method called TOAST (The Oversized-Attribute Storage Technique).\nRefer PostgreSQL documentation for details.",
    "tables": [],
    "extracted_at": "2025-10-03T12:31:59.723345"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 1: ",
    "section": null,
    "text": "In the end of this chapter, the methods of writing and reading heap tuples are described.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:00.578294"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 1: ",
    "section": "1.4.1. Writing Heap Tuples",
    "text": "Suppose a table composed of one page that contains just one heap tuple.\nThe pd_lower of this page points to the first line pointer, and both the line pointer and the pd_upper point to the first heap tuple.\nSee Figure 1.5(a).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:00.578294"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 1: ",
    "section": "1.4.1. Writing Heap Tuples",
    "text": "When the second tuple is inserted, it is placed after the first one.\nThe second line pointer is appended to the first one, and it points to the second tuple.\nThe pd_lower changes to point to the second line pointer, and the pd_upper to the second heap tuple.\nSee Figure 1.5(b).\nOther header data within this page (e.g., pd_lsn, pg_checksum, pg_flag) are also updated to appropriate values; more details are described in Section 5.3 and Section 9.4.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:00.578294"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 1: ",
    "section": "1.4.2. Reading Heap Tuples",
    "text": "Two typical access methods, sequential scan and B-tree index scan, are outlined here:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:00.578294"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 1: ",
    "section": "1.4.2. Reading Heap Tuples",
    "text": "Sequential scan â\nIt reads all tuples in all pages sequentially by scanning all line pointers in each page. See Figure 1.6(a).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:00.578294"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 1: ",
    "section": "1.4.2. Reading Heap Tuples",
    "text": "B-tree index scan  â\nIt reads an index file that contains index tuples, each of which is composed of an index key and a TID that points to the target heap tuple.\n\nIf the index tuple with the key that you are looking for has been found1,\nPostgreSQL reads the desired heap tuple using the obtained TID value.\n\nFor example, in Figure 1.6(b), the TID value of the obtained index tuple is ‘(block = 7, Offset = 2)’.\nThis means that the target heap tuple is the 2nd tuple in the 7th page within the table, so PostgreSQL can read the desired heap tuple without unnecessary scanning in the pages.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:00.578294"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 1: ",
    "section": "1.4.2. Reading Heap Tuples",
    "text": "This document does not explain indexes in details. To understand them, I recommend to read the valuable posts shown below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:00.578294"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 1: ",
    "section": "1.4.2. Reading Heap Tuples",
    "text": "PostgreSQL also supports TID-Scan, Bitmap-Scan, and Index-Only-Scan.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:00.578294"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 1: ",
    "section": "1.4.2. Reading Heap Tuples",
    "text": "TID-Scan is a method that accesses a tuple directly by using TID of the desired tuple.\nFor example, to find the 1st tuple in the 0-th page within the table, issue the following query:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:00.578294"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 1: ",
    "section": "1.4.2. Reading Heap Tuples",
    "text": "[CODE BLOCK]\nsampledb=# SELECT ctid, data FROM sampletbl WHERE ctid = '(0,1)';\n ctid  |   data\n-------+-----------\n (0,1) | AAAAAAAAA\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:00.578294"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 1: ",
    "section": "1.4.2. Reading Heap Tuples",
    "text": "Index-Only-Scan will be described in details in Section 7.2.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:00.578294"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql01/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 1: ",
    "section": "1.4.2. Reading Heap Tuples",
    "text": "The description of how to find the index tuples in a B-tree index is not explained here, as it is very common and the space here is limited. See the relevant materials. ↩︎",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:00.578294"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": null,
    "text": "PostgreSQL is a client/server type relational database management system with a multi-process architecture that runs on a single host.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:02.281623"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": null,
    "text": "A collection of multiple processes that cooperatively manage a database cluster is usually referred to as a ‘PostgreSQL server’.\nIt contains the following types of processes:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:02.281623"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": null,
    "text": "In the following subsections describe the details of the first three types of processes.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:02.281623"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": null,
    "text": "This figure shows processes of a PostgreSQL server: a postgres server process, two backend processes, seven background processes, and two client processes. The database cluster, the shared memory, and two client processes are also illustrated.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:02.281623"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": "2.1.1. Postgres Server Process",
    "text": "As mentioned earlier, the postgres server process is the parent of all processes within a PostgreSQL server.\nIn earlier versions, it was referred to as postmaster.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:02.281623"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": "2.1.1. Postgres Server Process",
    "text": "When the pg_ctl utility is executed with the start option,\nthe postgres server process starts.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:02.281623"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": "2.1.1. Postgres Server Process",
    "text": "It then allocates a shared memory area, initiates various background processes, starts replication-related processes and background worker processes as needed, and waits for connection requests from clients.\nWhen a connection request is received, it spawns a backend process to handle the client session.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:02.281623"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": "2.1.1. Postgres Server Process",
    "text": "A postgres server process listens to one network port, the default port is 5432. Although more than one PostgreSQL server can be run on the same host, each server must be set to listen to different port number, such as 5432, 5433, and so on.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:02.281623"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": "2.1.2. Backend Processes",
    "text": "A backend process, also called a postgres process, is started by the postgres server process and handles all queries issued by one connected client.\nIt communicates with the client using a single TCP connection and terminates when the client disconnects.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:02.281623"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": "2.1.2. Backend Processes",
    "text": "Each backend process can only operate on one database at a time, requiring explicit database selection during connection.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:02.281623"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": "2.1.2. Backend Processes",
    "text": "PostgreSQL supports concurrent connections from multiple clients,\nwith the maximum number controlled by the max_connections configuration parameter (default: 100).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:02.281623"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": "2.1.2. Backend Processes",
    "text": "If many clients, such as WEB applications, frequently connect and disconnect from a PostgreSQL server, it can increase the cost of establishing connections and creating backend processes, as PostgreSQL does not have a native connection pooling feature.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:02.282128"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": "2.1.2. Backend Processes",
    "text": "This can have a negative impact on the performance of the database server.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:02.282128"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": "2.1.2. Backend Processes",
    "text": "To deal with such a case, a connection pooling middleware such as pgbouncer or pgpool-II is usually used.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:02.282128"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": "2.1.3. Background Processes",
    "text": "In contrast to the postgres server process and the backend process, it is impossible to explain each of the functions simply.\nThis is because these functions depend on the individual specific features and PostgreSQL internals.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:02.282128"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": "2.1.3. Background Processes",
    "text": "Therefore, in this chapter, only introductions are made.\nDetails will be described in the following chapters.",
    "tables": [
      {
        "table_index": 0,
        "content": "process | description | reference\nbackground writer | This process writes dirty pages on the shared buffer pool to a persistent storage (e.g., HDD, SSD) on a regular basis gradually. (In versions 9.1 or earlier, it was also responsible for the checkpoint process.) | Section 8.6\ncheckpointer | This process performs the checkpoint process in versions 9.2 or later. | Section 8.6, Section 9.7\nautovacuum launcher | This process periodically invokes the autovacuum-worker processes for the vacuum process. (More precisely, it requests the postgres server to create the autovacuum workers.) | Section 6.5\nWAL writer | This process writes and flushes the WAL data on the WAL buffer to persistent storage periodically. | Section 9.6.1\nWAL Summarizer | This process tracks changes to all database blocks and writes these modifications to WAL summary files. Introduced in version 17. | Section 9.6.2\nstatistics collector | This process collects statistics information such as for pg_stat_activity and pg_stat_database, etc. | \nlogging collector (logger) | This process writes error messages into log files. | \nio worker | These processes handle read operations asynchronously, offloading I/O tasks from regular backend processes.\n(Asynchronous I/O has been introduced since version 18 to improve I/O performance.) | \narchiver | This process executes archiving logging. | Section 9.10"
      }
    ],
    "extracted_at": "2025-10-03T12:32:02.282128"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": "2.1.3. Background Processes",
    "text": "The actual processes of a PostgreSQL server are shown below.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:02.282128"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": "2.1.3. Background Processes",
    "text": "In the following example, there is one postgres server process (pid is 6541),\ntwo backend processes (pids are 8412 and 8482), and several background processes listed in Table 2.1. See also Figure 2.1.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:02.282128"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": "2.1.3. Background Processes",
    "text": "[CODE BLOCK]\n$ pstree -p 6541\n-+= 00001 root /sbin/launchd\n \\-+= 06541 postgres /usr/local/pgsql/bin/postgres -D data\n   |--= 06542 postgres postgres: io worker 0\n   |--= 06543 postgres postgres: io worker 1\n   |--= 06544 postgres postgres: io worker 2\n   |--= 06545 postgres postgres: checkpointer\n   |--= 06546 postgres postgres: background writer\n   |--= 06548 postgres postgres: walwriter\n   |--= 06549 postgres postgres: autovacuum launcher\n   |--= 06550 postgres postgres: walsummarizer\n   |--= 06551 postgres postgres: logical replication launcher\n   |--= 08412 postgres postgres: postgres testdb [local] idle\n   \\--= 08482 postgres postgres: postgres testdb [local] idle in transaction",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:02.282128"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": null,
    "text": "Memory architecture in PostgreSQL can be classified into two broad categories:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:03.131537"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": null,
    "text": "In the following subsections, those are briefly described.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:03.131537"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": "2.2.1. Local Memory Area",
    "text": "Each backend process allocates a local memory area for query processing.\nThe area is divided into several sub-areas, whose sizes are either fixed or variable.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:03.131537"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": "2.2.1. Local Memory Area",
    "text": "Table 2.2 shows a list of the major sub-areas.\nThe details of each sub-area will be described in the following chapters.",
    "tables": [
      {
        "table_index": 0,
        "content": "sub-area | description | reference\nwork_mem | The executor uses this area for sorting tuples by ORDER BY and DISTINCT operations, and for joining tables by merge-join and hash-join operations. | Chapter 3\nmaintenance_work_mem | Some kinds of maintenance operations (e.g., VACUUM, REINDEX) use this area. | Section 6.1\ntemp_buffers | The executor uses this area for storing temporary tables. | "
      }
    ],
    "extracted_at": "2025-10-03T12:32:03.131537"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": "2.2.1. Local Memory Area",
    "text": "In addition,\nDynamic Shared Memory (DSM) was implemented in version 9.4 for Parallel Query.\nIt is an on-demand memory space (i.e., it can be allocated as needed and released when no longer required) used for inter-process communication between PostgreSQL processes.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:03.131537"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": "2.2.1. Local Memory Area",
    "text": "DSM is an independent feature that can be used by users to send and receive data between PostgreSQL processes when developing extension modules.\nFor example, Logical replication relies on DSM.\nthe pg_prewarm contribution module also utilizes DSM.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:03.131537"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": "2.2.2. Shared Memory Area",
    "text": "A shared memory area is allocated by a PostgreSQL server when it starts up.\nThis area is also divided into several fixed-sized sub-areas.\nTable 2.3 shows a list of the major sub-areas.\nThe details will be described in the following chapters.",
    "tables": [
      {
        "table_index": 0,
        "content": "sub-area | description | reference\nshared buffer pool | PostgreSQL loads pages within tables and indexes from a persistent storage to this area, and operates them directly. | Chapter 8\nWAL buffer | To ensure that no data has been lost by server failures, PostgreSQL supports the WAL mechanism. WAL data (also referred to as XLOG records) are the transaction log in PostgreSQL. The WAL buffer is a buffering area of the WAL data before writing to a persistent storage. | Chapter 9\ncommit log | The commit log (CLOG) keeps the states of all transactions (e.g., in_progress, committed, aborted) for the concurrency control (CC) mechanism. | Section 5.4"
      }
    ],
    "extracted_at": "2025-10-03T12:32:03.131537"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql02/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 2: Process and Memory Arch.",
    "section": "2.2.2. Shared Memory Area",
    "text": "In addition to the shared buffer pool, WAL buffer, and commit log, PostgreSQL allocates several other areas, as shown below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:03.132051"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "In PostgreSQL, although the parallel query implemented in version 9.6 uses multiple background worker processes,\na backend process basically handles all queries issued by the connected client.\nThis backend consists of five subsystems:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.858947"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "In this section, an overview of these subsystems is provided.\nDue to the fact that the planner and the executor are very complicated, a detailed explanation for these functions will be provided in the following sections.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.858947"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "PostgreSQL’s query processing is described in the official document in detail.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.858947"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.1. Parser",
    "text": "The parser generates a parse tree that can be read by subsequent subsystems from an SQL statement in plain text.\nHere is a specific example, without a detailed description.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.858947"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.1. Parser",
    "text": "[CODE BLOCK]\ntestdb=# SELECT id, data FROM tbl_a WHERE id < 300 ORDER BY data;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.858947"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.1. Parser",
    "text": "A parse tree is a tree whose root node is the SelectStmt structure defined in parsenodes.h.\nFigure 3.2(b) illustrates the parse tree of the query shown in Figure 3.2(a).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.858947"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.1. Parser",
    "text": "[CODE BLOCK]\ntypedef struct SelectStmt\n{\n        NodeTag         type;\n\n        /*\n         * These fields are used only in \"leaf\" SelectStmts.\n         */\n        List       *distinctClause;     /* NULL, list of DISTINCT ON exprs, or\n                                         * lcons(NIL,NIL) for all (SELECT DISTINCT) */\n        IntoClause *intoClause;         /* target for SELECT INTO */\n        List       *targetList;         /* the target list (of ResTarget) */\n        List       *fromClause;         /* the FROM clause */\n        Node       *whereClause;        /* WHERE qualification */\n        List       *groupClause;        /* GROUP BY clauses */\n        Node       *havingClause;       /* HAVING conditional-expression */\n        List       *windowClause;       /* WINDOW window_name AS (...), ... */\n\n        /*\n         * In a \"leaf\" node representing a VALUES list, the above fields are all\n         * null, and instead this field is set.  Note that the elements of the\n         * sublists are just expressions, without ResTarget decoration. Also note\n         * that a list element can be DEFAULT (represented as a SetToDefault\n         * node), regardless of the context of the VALUES list. It's up to parse\n         * analysis to reject that where not valid.\n         */\n        List       *valuesLists;        /* untransformed list of expression lists */\n\n        /*\n         * These fields are used in both \"leaf\" SelectStmts and upper-level\n         * SelectStmts.\n         */\n        List       *sortClause;         /* sort clause (a list of SortBy's) */\n        Node       *limitOffset;        /* # of result tuples to skip */\n        Node       *limitCount;         /* # of result tuples to return */\n        List       *lockingClause;      /* FOR UPDATE (list of LockingClause's) */\n        WithClause *withClause;         /* WITH clause */\n\n        /*\n         * These fields are used only in upper-level SelectStmts.\n         */\n        SetOperation op;                /* type of set op */\n        bool            all;            /* ALL specified? */\n        struct SelectStmt *larg;        /* left child */\n        struct SelectStmt *rarg;        /* right child */\n        /* Eventually add fields for CORRESPONDING spec here */\n} SelectStmt;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.858947"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.1. Parser",
    "text": "The elements of the SELECT query and the corresponding elements of the parse tree are numbered the same.\nFor example, (1) is an item of the first target list, and it is the column ‘id’ of the table;\n(4) is a WHERE clause; and so on.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.858947"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.1. Parser",
    "text": "The parser only checks the syntax of an input when generating a parse tree.\nTherefore, it only returns an error if there is a syntax error in the query.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.858947"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.1. Parser",
    "text": "The parser does not check the semantics of an input query.\nFor example, even if the query contains a table name that does not exist, the parser does not return an error.\nSemantic checks are done by the analyzer/analyser.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.858947"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.2. Analyzer/Analyser",
    "text": "The analyzer/analyser runs a semantic analysis of a parse tree generated by the parser and generates a query tree.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.2. Analyzer/Analyser",
    "text": "The root of a query tree is the Query structure defined in parsenodes.h.\nThis structure contains metadata of its corresponding query, such as the type of the command (SELECT, INSERT, or others), and several leaves.\nEach leaf forms a list or a tree and holds data for the individual particular clause.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.2. Analyzer/Analyser",
    "text": "[CODE BLOCK]\n/*\n * Query -\n *\t  Parse analysis turns all statements into a Query tree\n *\t  for further processing by the rewriter and planner.\n *\n *\t  Utility statements (i.e. non-optimizable statements) have the\n *\t  utilityStmt field set, and the Query itself is mostly dummy.\n *\t  DECLARE CURSOR is a special case: it is represented like a SELECT,\n *\t  but the original DeclareCursorStmt is stored in utilityStmt.\n *\n *\t  Planning converts a Query tree into a Plan tree headed by a PlannedStmt\n *\t  node --- the Query structure is not used by the executor.\n */\ntypedef struct Query\n{\n\tNodeTag\t\ttype;\n\n\tCmdType\t\tcommandType;\t/* select|insert|update|delete|merge|utility */\n\n\t/* where did I come from? */\n\tQuerySource querySource pg_node_attr(query_jumble_ignore);\n\n\t/*\n\t * query identifier (can be set by plugins); ignored for equal, as it\n\t * might not be set; also not stored.  This is the result of the query\n\t * jumble, hence ignored.\n\t */\n\tuint64\t\tqueryId pg_node_attr(equal_ignore, query_jumble_ignore, read_write_ignore, read_as(0));\n\n\t/* do I set the command result tag? */\n\tbool\t\tcanSetTag pg_node_attr(query_jumble_ignore);\n\n\tNode\t   *utilityStmt;\t/* non-null if commandType == CMD_UTILITY */\n\n\t/*\n\t * rtable index of target relation for INSERT/UPDATE/DELETE/MERGE; 0 for\n\t * SELECT.  This is ignored in the query jumble as unrelated to the\n\t * compilation of the query ID.\n\t */\n\tint\t\t\tresultRelation pg_node_attr(query_jumble_ignore);\n\n\t/* has aggregates in tlist or havingQual */\n\tbool\t\thasAggs pg_node_attr(query_jumble_ignore);\n\t/* has window functions in tlist */\n\tbool\t\thasWindowFuncs pg_node_attr(query_jumble_ignore);\n\t/* has set-returning functions in tlist */\n\tbool\t\thasTargetSRFs pg_node_attr(query_jumble_ignore);\n\t/* has subquery SubLink */\n\tbool\t\thasSubLinks pg_node_attr(query_jumble_ignore);\n\t/* distinctClause is from DISTINCT ON */\n\tbool\t\thasDistinctOn pg_node_attr(query_jumble_ignore);\n\t/* WITH RECURSIVE was specified */\n\tbool\t\thasRecursive pg_node_attr(query_jumble_ignore);\n\t/* has INSERT/UPDATE/DELETE in WITH */\n\tbool\t\thasModifyingCTE pg_node_attr(query_jumble_ignore);\n\t/* FOR [KEY] UPDATE/SHARE was specified */\n\tbool\t\thasForUpdate pg_node_attr(query_jumble_ignore);\n\t/* rewriter has applied some RLS policy */\n\tbool\t\thasRowSecurity pg_node_attr(query_jumble_ignore);\n\t/* is a RETURN statement */\n\tbool\t\tisReturn pg_node_attr(query_jumble_ignore);\n\n\tList\t   *cteList;\t\t/* WITH list (of CommonTableExpr's) */\n\n\tList\t   *rtable;\t\t\t/* list of range table entries */\n\n\t/*\n\t * list of RTEPermissionInfo nodes for the rtable entries having\n\t * perminfoindex > 0\n\t */\n\tList\t   *rteperminfos pg_node_attr(query_jumble_ignore);\n\tFromExpr   *jointree;\t\t/* table join tree (FROM and WHERE clauses);\n\t\t\t\t\t\t\t\t * also USING clause for MERGE */\n\n\tList\t   *mergeActionList;\t/* list of actions for MERGE (only) */\n\t/* whether to use outer join */\n\tbool\t\tmergeUseOuterJoin pg_node_attr(query_jumble_ignore);\n\n\tList\t   *targetList;\t\t/* target list (of TargetEntry) */\n\n\t/* OVERRIDING clause */\n\tOverridingKind override pg_node_attr(query_jumble_ignore);\n\n\tOnConflictExpr *onConflict; /* ON CONFLICT DO [NOTHING | UPDATE] */\n\n\tList\t   *returningList;\t/* return-values list (of TargetEntry) */\n\n\tList\t   *groupClause;\t/* a list of SortGroupClause's */\n\tbool\t\tgroupDistinct;\t/* is the group by clause distinct? */\n\n\tList\t   *groupingSets;\t/* a list of GroupingSet's if present */\n\n\tNode\t   *havingQual;\t\t/* qualifications applied to groups */\n\n\tList\t   *windowClause;\t/* a list of WindowClause's */\n\n\tList\t   *distinctClause; /* a list of SortGroupClause's */\n\n\tList\t   *sortClause;\t\t/* a list of SortGroupClause's */\n\n\tNode\t   *limitOffset;\t/* # of result tuples to skip (int8 expr) */\n\tNode\t   *limitCount;\t\t/* # of result tuples to return (int8 expr) */\n\tLimitOption limitOption;\t/* limit type */\n\n\tList\t   *rowMarks;\t\t/* a list of RowMarkClause's */\n\n\tNode\t   *setOperations;\t/* set-operation tree if this is top level of\n\t\t\t\t\t\t\t\t * a UNION/INTERSECT/EXCEPT query */\n\n\t/*\n\t * A list of pg_constraint OIDs that the query depends on to be\n\t * semantically valid\n\t */\n\tList\t   *constraintDeps pg_node_attr(query_jumble_ignore);\n\n\t/* a list of WithCheckOption's (added during rewrite) */\n\tList\t   *withCheckOptions pg_node_attr(query_jumble_ignore);\n\n\t/*\n\t * The following two fields identify the portion of the source text string\n\t * containing this query.  They are typically only populated in top-level\n\t * Queries, not in sub-queries.  When not set, they might both be zero, or\n\t * both be -1 meaning \"unknown\".\n\t */\n\t/* start location, or -1 if unknown */\n\tint\t\t\tstmt_location;\n\t/* length in bytes; 0 means \"rest of string\" */\n\tint\t\t\tstmt_len pg_node_attr(query_jumble_ignore);\n} Query;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.2. Analyzer/Analyser",
    "text": "Figure 3.3 illustrates the query tree of the query shown in Figure 3.2(a) in the previous subsection.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.2. Analyzer/Analyser",
    "text": "The above query tree is briefly described as follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.2. Analyzer/Analyser",
    "text": "The targetlist is a list of columns that are the result of this query.\nIn this example, the list is composed of two columns: ‘id’ and ‘data’.\nIf the input query tree uses ‘$ \\ast $’ (asterisk), the analyzer/analyser will explicitly replace it with all of the columns.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.2. Analyzer/Analyser",
    "text": "The range table is a list of relations that are used in this query.\nIn this example, the list holds the information of the table ’tbl_a’, such as the OID of the table and the name of the table.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.2. Analyzer/Analyser",
    "text": "The join tree stores the FROM clause and the WHERE clauses.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.2. Analyzer/Analyser",
    "text": "The details of the query tree are described in the official document.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.3. Rewriter",
    "text": "The rewriter is the system that realizes the rule system.\nIt transforms a query tree according to the rules stored in the pg_rules system catalog, if necessary.\nThe rule system is an interesting system in itself,\nbut the descriptions of the rule system and the rewriter have been omitted to prevent this chapter from becoming too long.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.3. Rewriter",
    "text": "Views in PostgreSQL are implemented by using the rule system.\nWhen a view is defined by the CREATE VIEW command,\nthe corresponding rule is automatically generated and stored in the catalog.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.3. Rewriter",
    "text": "Assume that the following view is already defined and the corresponding rule is stored in the pg_rules system catalog:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.3. Rewriter",
    "text": "[CODE BLOCK]\nsampledb=# CREATE VIEW employees_list\nsampledb-#      AS SELECT e.id, e.name, d.name AS department\nsampledb-#            FROM employees AS e, departments AS d WHERE e.department_id = d.id;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.3. Rewriter",
    "text": "When a query that contains a view shown below is issued, the parser creates the parse tree as shown in Figure 3.4(a).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.3. Rewriter",
    "text": "At this stage, the rewriter processes the range table node to a parse tree of the subquery, which is the corresponding view, stored in pg_rules.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.3. Rewriter",
    "text": "Since PostgreSQL realizes views using such a mechanism, views could not be updated until version 9.2.\nHowever, views can be updated from version 9.3 onwards; nonetheless, there are many limitations in updating the view.\nThese details are described in the official document.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.4. Planner and Executor",
    "text": "The planner receives a query tree from the rewriter and generates a (query) plan tree that can be processed by the executor most effectively.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.4. Planner and Executor",
    "text": "The planner in PostgreSQL is based on pure cost-based optimization. It does not support rule-based optimization or hints.\nThis planner is the most complex subsystem in PostgreSQL.\nTherefore, an overview of the planner will be provided in the subsequent sections of this chapter.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.4. Planner and Executor",
    "text": "PostgreSQL does not support planner hints in SQL, and it will not be supported forever.\nTo use hints in queries, consider installing the pg_hint_plan extension.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.4. Planner and Executor",
    "text": "As in other RDBMS,\nthe EXPLAIN command in PostgreSQL displays the plan tree itself.\nA specific example is shown below:",
    "tables": [
      {
        "table_index": 0,
        "content": "1\n2\n3\n4\n5\n6\n7\n8 | testdb=# EXPLAIN SELECT * FROM tbl_a WHERE id < 300 ORDER BY data;\n                          QUERY PLAN\n---------------------------------------------------------------\n Sort  (cost=182.34..183.09 rows=300 width=8)\n   Sort Key: data\n   ->  Seq Scan on tbl_a  (cost=0.00..170.00 rows=300 width=8)\n         Filter: (id < 300)\n(4 rows)"
      }
    ],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 31,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.4. Planner and Executor",
    "text": "[CODE BLOCK]\ntestdb=# EXPLAIN SELECT * FROM tbl_a WHERE id < 300 ORDER BY data;\n                          QUERY PLAN\n---------------------------------------------------------------\n Sort  (cost=182.34..183.09 rows=300 width=8)\n   Sort Key: data\n   ->  Seq Scan on tbl_a  (cost=0.00..170.00 rows=300 width=8)\n         Filter: (id < 300)\n(4 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 32,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.4. Planner and Executor",
    "text": "This result shows the plan tree shown in Figure 3.5.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 33,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.4. Planner and Executor",
    "text": "A plan tree is composed of elements called plan nodes,\nand it is connected to the plantree list of the PlannedStmt structure.\nThese elements are defined in plannodes.h.\nDetails will be explained in Section 3.3.3 (and Section 3.5.4.2).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 34,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.4. Planner and Executor",
    "text": "Each plan node has information that the executor requires for processing.\nIn the case of a single-table query, the executor processes from the end of the plan tree to the root.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 35,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.4. Planner and Executor",
    "text": "For example, the plan tree shown in Figure 3.5 is a list of a sort node and a sequential scan node.\nTherefore, the executor scans the table tbl_a by a sequential scan and then sorts the obtained result.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 36,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.4. Planner and Executor",
    "text": "The executor reads and writes tables and indexes in the database cluster via the buffer manager described in Chapter 8.\nWhen processing a query, the executor uses some memory areas, such as temp_buffers and work_mem, allocated in advance and creates temporary files if necessary.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 37,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.1.4. Planner and Executor",
    "text": "In addition, when accessing tuples, PostgreSQL uses the concurrency control mechanism to maintain consistency and isolation of the running transactions.\nThe concurrency control mechanism is described in Chapter 5.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:04.859951"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "PostgreSQL’s query optimization is based on cost. Costs are dimensionless values, and they are not absolute performance indicators, but rather indicators to compare the relative performance of operations.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "Costs are estimated by the functions defined in costsize.c.\nAll operations executed by the executor have corresponding cost functions.\nFor example,\nthe costs of sequential scans and index scans are estimated by cost_seqscan() and cost_index(), respectively.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "In PostgreSQL,\nthere are three kinds of costs: start-up, run and total.\nThe total cost is the sum of the start-up and run costs, so only the start-up and run costs are independently estimated.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "The EXPLAIN command shows both of start-up and total costs in each operation.\nThe simplest example is shown below:",
    "tables": [
      {
        "table_index": 0,
        "content": "1\n2\n3\n4\n5 | testdb=# EXPLAIN SELECT * FROM tbl;\n                       QUERY PLAN\n---------------------------------------------------------\n Seq Scan on tbl  (cost=0.00..145.00 rows=10000 width=8)\n(1 row)"
      }
    ],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "[CODE BLOCK]\ntestdb=# EXPLAIN SELECT * FROM tbl;\n                       QUERY PLAN\n---------------------------------------------------------\n Seq Scan on tbl  (cost=0.00..145.00 rows=10000 width=8)\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "In Line 4, the command shows information about the sequential scan.\nIn the cost section, there are two values; 0.00 and 145.00.\nIn this case, the start-up and total costs are 0.00 and 145.00, respectively.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "In this section,\nwe will explore how to estimate the sequential scan, index scan, and sort operation in detail.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "In the following explanations, we will use a specific table and an index that are shown below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "[CODE BLOCK]\ntestdb=# CREATE TABLE tbl (id int PRIMARY KEY, data int);\ntestdb=# CREATE INDEX tbl_data_idx ON tbl (data);\ntestdb=# INSERT INTO tbl SELECT generate_series(1,10000),generate_series(1,10000);\ntestdb=# ANALYZE;\ntestdb=# \\d tbl\n      Table \"public.tbl\"\n Column |  Type   | Modifiers\n--------+---------+-----------\n id     | integer | not null\n data   | integer |\nIndexes:\n    \"tbl_pkey\" PRIMARY KEY, btree (id)\n    \"tbl_data_idx\" btree (data)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.1. Sequential Scan",
    "text": "The cost of the sequential scan is estimated by the cost_seqscan() function.\nIn this subsection, we will explore how to estimate the sequential scan cost of the following query:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.1. Sequential Scan",
    "text": "In the sequential scan, the start-up cost is equal to 0,\nand the run cost is defined by the following equation:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.1. Sequential Scan",
    "text": "where\nseq_page_cost,\ncpu_tuple_cost\nand\ncpu_operator_cost\nare set in the postgresql.conf file,\nand the default values are 1.0, 0.01, and 0.0025, respectively.\n$ N_{tuple} $ and $ N_{page} $ are the numbers of all tuples and all pages of this table, respectively.\nThese numbers can be shown using the following query:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.1. Sequential Scan",
    "text": "[CODE BLOCK]\ntestdb=# SELECT relpages, reltuples FROM pg_class WHERE relname = 'tbl';\n relpages | reltuples\n----------+-----------\n       45 |     10000\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.1. Sequential Scan",
    "text": "For confirmation, the result of the EXPLAIN command of the above query is shown below:",
    "tables": [
      {
        "table_index": 0,
        "content": "1\n2\n3\n4\n5\n6 | testdb=# EXPLAIN SELECT * FROM tbl WHERE id <= 8000;\n                       QUERY PLAN\n--------------------------------------------------------\n Seq Scan on tbl  (cost=0.00..170.00 rows=8000 width=8)\n   Filter: (id <= 8000)\n(2 rows)"
      }
    ],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.1. Sequential Scan",
    "text": "[CODE BLOCK]\ntestdb=# EXPLAIN SELECT * FROM tbl WHERE id <= 8000;\n                       QUERY PLAN\n--------------------------------------------------------\n Seq Scan on tbl  (cost=0.00..170.00 rows=8000 width=8)\n   Filter: (id <= 8000)\n(2 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.1. Sequential Scan",
    "text": "In Line 4,\nwe can see that the start-up and total costs are 0.00 and 170.00, respectively.\nIt is also estimated that 8000 rows (tuples) will be selected by scanning all rows.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.1. Sequential Scan",
    "text": "In line 5, a filter ‘$\\text{Filter}:(\\text{id} \\lt= 8000)$’ of the sequential scan is shown.\nMore precisely, it is called a table level filter predicate.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.1. Sequential Scan",
    "text": "Note that this type of filter is used when reading all the tuples in the table, and it does not narrow the scanned range of table pages.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.1. Sequential Scan",
    "text": "As understood from the run-cost estimation,\nPostgreSQL assumes that all pages will be read from storage.\nIn other words,\nPostgreSQL does not consider whether the scanned page is in the shared buffers or not.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "Although PostgreSQL supports some index methods,\nsuch as BTree,\nGiST,\nGIN and\nBRIN,\nthe cost of the index scan is estimated using the common cost function cost_index().",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "In this subsection, we explore how to estimate the index scan cost of the following query:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "[CODE BLOCK]\ntestdb=# SELECT id, data FROM tbl WHERE data <= 240;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "Before estimating the cost, the numbers of the index pages and index tuples, $ N_{index,page} $ and $ N_{index,tuple} $, are shown below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "[CODE BLOCK]\ntestdb=# SELECT relpages, reltuples FROM pg_class WHERE relname = 'tbl_data_idx';\n relpages | reltuples\n----------+-----------\n       30 |     10000\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "The start-up cost of the index scan is the cost of reading the index pages to access the first tuple in the target table.\nIt is defined by the following equation:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "where $ H_{index} $ is the height of the index tree.\nThe detail of this calculation is explained in the comments of btcostestimate().",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "In this case, according to (3), $ N_{index,tuple} $ is 10000,\n$ H_{index} $ is 1;\n$ \\text{cpu_operator_cost} $ is $0.0025$ (by default).\nTherefore,",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "The run cost of the index scan is the sum of the CPU costs and the I/O (input/output) costs of both the table and the index:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "If the Index-Only Scans, which is described in Section 7.2, can be applied,\n$ \\text{’table cpu cost’} $ and $ \\text{’table IO cost’} $ are not estimated.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "The first three costs (i.e., index CPU cost, table CPU cost, and index I/O cost) are shown below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 31,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "The selectivity of query predicates is estimated using either the histogram_bounds or the MCV (Most Common Value),\nboth of which are stored in the statistics information in the pg_stats.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 32,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "Here, the calculation of the selectivity is briefly described using specific examples.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 33,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "More details are provided in the official document.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 34,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "The MCV of each column of a table is stored in the pg_stats view as a pair of columns named ‘most_common_vals’ and ‘most_common_freqs’:",
    "tables": [
      {
        "table_index": 0,
        "content": "1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243 | --\n-- PostgreSQL database dump\n--\n\n-- Dumped from database version 9.6.0\n-- Dumped by pg_dump version 9.6.0\n\nSET statement_timeout = 0;\nSET lock_timeout = 0;\nSET idle_in_transaction_session_timeout = 0;\nSET client_encoding = 'UTF8';\nSET standard_conforming_strings = on;\nSET check_function_bodies = false;\nSET client_min_messages = warning;\nSET row_security = off;\n\nSET search_path = public, pg_catalog;\n\nSET default_tablespace = '';\n\nSET default_with_oids = false;\n\n--\n-- Name: countries; Type: TABLE; Schema: public; Owner: postgres\n--\n\nCREATE TABLE countries (\n    continent text,\n    country text\n);\n\n\nALTER TABLE countries OWNER TO postgres;\n\n--\n-- Data for Name: countries; Type: TABLE DATA; Schema: public; Owner: postgres\n--\n\nCOPY countries (continent, country) FROM stdin;\nAfrica\tAlgeria\nAfrica\tAngola\nAfrica\tBenin\nAfrica\tBotswana\nAfrica\tBurkina\nAfrica\tBurundi\nAfrica\tCameroon\nAfrica\tCape Verde\nAfrica\tCentral African Republic\nAfrica\tChad\nAfrica\tComoros\nAfrica\tCongo\nAfrica\tDjibouti\nAfrica\tEgypt\nAfrica\tEquatorial Guinea\nAfrica\tEritrea\nAfrica\tEthiopia\nAfrica\tGabon\nAfrica\tGambia\nAfrica\tGhana\nAfrica\tGuinea\nAfrica\tGuinea-Bissau\nAfrica\tIvory Coast\nAfrica\tKenya\nAfrica\tLesotho\nAfrica\tLiberia\nAfrica\tLibya\nAfrica\tMadagascar\nAfrica\tMalawi\nAfrica\tMali\nAfrica\tMauritania\nAfrica\tMauritius\nAfrica\tMorocco\nAfrica\tMozambique\nAfrica\tNamibia\nAfrica\tNiger\nAfrica\tNigeria\nAfrica\tRwanda\nAfrica\tSao Tome and Principe\nAfrica\tSenegal\nAfrica\tSeychelles\nAfrica\tSierra Leone\nAfrica\tSomalia\nAfrica\tSouth Africa\nAfrica\tSouth Sudan\nAfrica\tSudan\nAfrica\tSwaziland\nAfrica\tTanzania\nAfrica\tTogo\nAfrica\tTunisia\nAfrica\tUganda\nAfrica\tZambia\nAfrica\tZimbabwe\nAsia\tAfghanistan\nAsia\tBahrain\nAsia\tBangladesh\nAsia\tBhutan\nAsia\tBrunei\nAsia\tBurma (Myanmar)\nAsia\tCambodia\nAsia\tChina\nAsia\tEast Timor\nAsia\tIndia\nAsia\tIndonesia\nAsia\tIran\nAsia\tIraq\nAsia\tIsrael\nAsia\tJapan\nAsia\tJordan\nAsia\tKazakhstan\nAsia\tNorth Korea\nAsia\tSouth Korea\nAsia\tKuwait\nAsia\tKyrgyzstan\nAsia\tLaos\nAsia\tLebanon\nAsia\tMalaysia\nAsia\tMaldives\nAsia\tMongolia\nAsia\tNepal\nAsia\tOman\nAsia\tPakistan\nAsia\tPhilippines\nAsia\tQatar\nAsia\tRussian Federation\nAsia\tSaudi Arabia\nAsia\tSingapore\nAsia\tSri Lanka\nAsia\tSyria\nAsia\tTajikistan\nAsia\tThailand\nAsia\tTurkey\nAsia\tTurkmenistan\nAsia\tUnited Arab Emirates\nAsia\tUzbekistan\nAsia\tVietnam\nAsia\tYemen\nEurope\tAlbania\nEurope\tAndorra\nEurope\tArmenia\nEurope\tAustria\nEurope\tAzerbaijan\nEurope\tBelarus\nEurope\tBelgium\nEurope\tBosnia and Herzegovina\nEurope\tBulgaria\nEurope\tCroatia\nEurope\tCyprus\nEurope\tCzech Republic\nEurope\tDenmark\nEurope\tEstonia\nEurope\tFinland\nEurope\tFrance\nEurope\tGeorgia\nEurope\tGermany\nEurope\tGreece\nEurope\tHungary\nEurope\tIceland\nEurope\tIreland\nEurope\tItaly\nEurope\tLatvia\nEurope\tLiechtenstein\nEurope\tLithuania\nEurope\tLuxembourg\nEurope\tMacedonia\nEurope\tMalta\nEurope\tMoldova\nEurope\tMonaco\nEurope\tMontenegro\nEurope\tNetherlands\nEurope\tNorway\nEurope\tPoland\nEurope\tPortugal\nEurope\tRomania\nEurope\tSan Marino\nEurope\tSerbia\nEurope\tSlovakia\nEurope\tSlovenia\nEurope\tSpain\nEurope\tSweden\nEurope\tSwitzerland\nEurope\tUkraine\nEurope\tUnited Kingdom\nEurope\tVatican City\nNorth America\tAntigua and Barbuda\nNorth America\tBahamas\nNorth America\tBarbados\nNorth America\tBelize\nNorth America\tCanada\nNorth America\tCosta Rica\nNorth America\tCuba\nNorth America\tDominica\nNorth America\tDominican Republic\nNorth America\tEl Salvador\nNorth America\tGrenada\nNorth America\tGuatemala\nNorth America\tHaiti\nNorth America\tHonduras\nNorth America\tJamaica\nNorth America\tMexico\nNorth America\tNicaragua\nNorth America\tPanama\nNorth America\tSaint Kitts and Nevis\nNorth America\tSaint Lucia\nNorth America\tSaint Vincent and the Grenadines\nNorth America\tTrinidad and Tobago\nNorth America\tUnited States\nOceania\tAustralia\nOceania\tFiji\nOceania\tKiribati\nOceania\tMarshall Islands\nOceania\tMicronesia\nOceania\tNauru\nOceania\tNew Zealand\nOceania\tPalau\nOceania\tPapua New Guinea\nOceania\tSamoa\nOceania\tSolomon Islands\nOceania\tTonga\nOceania\tTuvalu\nOceania\tVanuatu\nSouth America\tArgentina\nSouth America\tBolivia\nSouth America\tBrazil\nSouth America\tChile\nSouth America\tColombia\nSouth America\tEcuador\nSouth America\tGuyana\nSouth America\tParaguay\nSouth America\tPeru\nSouth America\tSuriname\nSouth America\tUruguay\nSouth America\tVenezuela\n\\.\n\n--\n-- Name: idx_continent; Type: INDEX; Schema: public; Owner: postgres\n--\n\nCREATE INDEX idx_continent ON countries USING btree (continent);\n\n--\n-- PostgreSQL database dump complete\n--"
      }
    ],
    "extracted_at": "2025-10-03T12:32:06.002336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 35,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "[CODE BLOCK]\n1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n 10\n 11\n 12\n 13\n 14\n 15\n 16\n 17\n 18\n 19\n 20\n 21\n 22\n 23\n 24\n 25\n 26\n 27\n 28\n 29\n 30\n 31\n 32\n 33\n 34\n 35\n 36\n 37\n 38\n 39\n 40\n 41\n 42\n 43\n 44\n 45\n 46\n 47\n 48\n 49\n 50\n 51\n 52\n 53\n 54\n 55\n 56\n 57\n 58\n 59\n 60\n 61\n 62\n 63\n 64\n 65\n 66\n 67\n 68\n 69\n 70\n 71\n 72\n 73\n 74\n 75\n 76\n 77\n 78\n 79\n 80\n 81\n 82\n 83\n 84\n 85\n 86\n 87\n 88\n 89\n 90\n 91\n 92\n 93\n 94\n 95\n 96\n 97\n 98\n 99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 36,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "[CODE BLOCK]\n--\n-- PostgreSQL database dump\n--\n\n-- Dumped from database version 9.6.0\n-- Dumped by pg_dump version 9.6.0\n\nSET statement_timeout = 0;\nSET lock_timeout = 0;\nSET idle_in_transaction_session_timeout = 0;\nSET client_encoding = 'UTF8';\nSET standard_conforming_strings = on;\nSET check_function_bodies = false;\nSET client_min_messages = warning;\nSET row_security = off;\n\nSET search_path = public, pg_catalog;\n\nSET default_tablespace = '';\n\nSET default_with_oids = false;\n\n--\n-- Name: countries; Type: TABLE; Schema: public; Owner: postgres\n--\n\nCREATE TABLE countries (\n    continent text,\n    country text\n);\n\n\nALTER TABLE countries OWNER TO postgres;\n\n--\n-- Data for Name: countries; Type: TABLE DATA; Schema: public; Owner: postgres\n--\n\nCOPY countries (continent, country) FROM stdin;\nAfrica\tAlgeria\nAfrica\tAngola\nAfrica\tBenin\nAfrica\tBotswana\nAfrica\tBurkina\nAfrica\tBurundi\nAfrica\tCameroon\nAfrica\tCape Verde\nAfrica\tCentral African Republic\nAfrica\tChad\nAfrica\tComoros\nAfrica\tCongo\nAfrica\tDjibouti\nAfrica\tEgypt\nAfrica\tEquatorial Guinea\nAfrica\tEritrea\nAfrica\tEthiopia\nAfrica\tGabon\nAfrica\tGambia\nAfrica\tGhana\nAfrica\tGuinea\nAfrica\tGuinea-Bissau\nAfrica\tIvory Coast\nAfrica\tKenya\nAfrica\tLesotho\nAfrica\tLiberia\nAfrica\tLibya\nAfrica\tMadagascar\nAfrica\tMalawi\nAfrica\tMali\nAfrica\tMauritania\nAfrica\tMauritius\nAfrica\tMorocco\nAfrica\tMozambique\nAfrica\tNamibia\nAfrica\tNiger\nAfrica\tNigeria\nAfrica\tRwanda\nAfrica\tSao Tome and Principe\nAfrica\tSenegal\nAfrica\tSeychelles\nAfrica\tSierra Leone\nAfrica\tSomalia\nAfrica\tSouth Africa\nAfrica\tSouth Sudan\nAfrica\tSudan\nAfrica\tSwaziland\nAfrica\tTanzania\nAfrica\tTogo\nAfrica\tTunisia\nAfrica\tUganda\nAfrica\tZambia\nAfrica\tZimbabwe\nAsia\tAfghanistan\nAsia\tBahrain\nAsia\tBangladesh\nAsia\tBhutan\nAsia\tBrunei\nAsia\tBurma (Myanmar)\nAsia\tCambodia\nAsia\tChina\nAsia\tEast Timor\nAsia\tIndia\nAsia\tIndonesia\nAsia\tIran\nAsia\tIraq\nAsia\tIsrael\nAsia\tJapan\nAsia\tJordan\nAsia\tKazakhstan\nAsia\tNorth Korea\nAsia\tSouth Korea\nAsia\tKuwait\nAsia\tKyrgyzstan\nAsia\tLaos\nAsia\tLebanon\nAsia\tMalaysia\nAsia\tMaldives\nAsia\tMongolia\nAsia\tNepal\nAsia\tOman\nAsia\tPakistan\nAsia\tPhilippines\nAsia\tQatar\nAsia\tRussian Federation\nAsia\tSaudi Arabia\nAsia\tSingapore\nAsia\tSri Lanka\nAsia\tSyria\nAsia\tTajikistan\nAsia\tThailand\nAsia\tTurkey\nAsia\tTurkmenistan\nAsia\tUnited Arab Emirates\nAsia\tUzbekistan\nAsia\tVietnam\nAsia\tYemen\nEurope\tAlbania\nEurope\tAndorra\nEurope\tArmenia\nEurope\tAustria\nEurope\tAzerbaijan\nEurope\tBelarus\nEurope\tBelgium\nEurope\tBosnia and Herzegovina\nEurope\tBulgaria\nEurope\tCroatia\nEurope\tCyprus\nEurope\tCzech Republic\nEurope\tDenmark\nEurope\tEstonia\nEurope\tFinland\nEurope\tFrance\nEurope\tGeorgia\nEurope\tGermany\nEurope\tGreece\nEurope\tHungary\nEurope\tIceland\nEurope\tIreland\nEurope\tItaly\nEurope\tLatvia\nEurope\tLiechtenstein\nEurope\tLithuania\nEurope\tLuxembourg\nEurope\tMacedonia\nEurope\tMalta\nEurope\tMoldova\nEurope\tMonaco\nEurope\tMontenegro\nEurope\tNetherlands\nEurope\tNorway\nEurope\tPoland\nEurope\tPortugal\nEurope\tRomania\nEurope\tSan Marino\nEurope\tSerbia\nEurope\tSlovakia\nEurope\tSlovenia\nEurope\tSpain\nEurope\tSweden\nEurope\tSwitzerland\nEurope\tUkraine\nEurope\tUnited Kingdom\nEurope\tVatican City\nNorth America\tAntigua and Barbuda\nNorth America\tBahamas\nNorth America\tBarbados\nNorth America\tBelize\nNorth America\tCanada\nNorth America\tCosta Rica\nNorth America\tCuba\nNorth America\tDominica\nNorth America\tDominican Republic\nNorth America\tEl Salvador\nNorth America\tGrenada\nNorth America\tGuatemala\nNorth America\tHaiti\nNorth America\tHonduras\nNorth America\tJamaica\nNorth America\tMexico\nNorth America\tNicaragua\nNorth America\tPanama\nNorth America\tSaint Kitts and Nevis\nNorth America\tSaint Lucia\nNorth America\tSaint Vincent and the Grenadines\nNorth America\tTrinidad and Tobago\nNorth America\tUnited States\nOceania\tAustralia\nOceania\tFiji\nOceania\tKiribati\nOceania\tMarshall Islands\nOceania\tMicronesia\nOceania\tNauru\nOceania\tNew Zealand\nOceania\tPalau\nOceania\tPapua New Guinea\nOceania\tSamoa\nOceania\tSolomon Islands\nOceania\tTonga\nOceania\tTuvalu\nOceania\tVanuatu\nSouth America\tArgentina\nSouth America\tBolivia\nSouth America\tBrazil\nSouth America\tChile\nSouth America\tColombia\nSouth America\tEcuador\nSouth America\tGuyana\nSouth America\tParaguay\nSouth America\tPeru\nSouth America\tSuriname\nSouth America\tUruguay\nSouth America\tVenezuela\n\\.\n\n--\n-- Name: idx_continent; Type: INDEX; Schema: public; Owner: postgres\n--\n\nCREATE INDEX idx_continent ON countries USING btree (continent);\n\n--\n-- PostgreSQL database dump complete\n--",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 37,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "[CODE BLOCK]\ntestdb=# \\d countries\n   Table \"public.countries\"\n  Column   | Type | Modifiers\n-----------+------+-----------\n country   | text |\n continent | text |\nIndexes:\n    \"continent_idx\" btree (continent)\n\ntestdb=# SELECT continent, count(*) AS \"number of countries\",\ntestdb-#     (count(*)/(SELECT count(*) FROM countries)::real) AS \"number of countries / all countries\"\ntestdb-#       FROM countries GROUP BY continent ORDER BY \"number of countries\" DESC;\n   continent   | number of countries | number of countries / all countries\n---------------+---------------------+-------------------------------------\n Africa        |                  53 |                   0.274611398963731\n Europe        |                  47 |                   0.243523316062176\n Asia          |                  44 |                   0.227979274611399\n North America |                  23 |                   0.119170984455959\n Oceania       |                  14 |                  0.0725388601036269\n South America |                  12 |                  0.0621761658031088\n(6 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 38,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "Consider the following query, which has a WHERE clause, ‘continent = ‘Asia’’:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 39,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "[CODE BLOCK]\ntestdb=# SELECT * FROM countries WHERE continent = 'Asia';",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 40,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "In this case, the planner estimates the index scan cost using the MCV of the ‘continent’ column.\nThe ‘most_common_vals’ and ‘most_common_freqs’ of this column are shown below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 41,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "[CODE BLOCK]\ntestdb=# \\x\nExpanded display is on.\ntestdb=# SELECT most_common_vals, most_common_freqs FROM pg_stats\ntestdb-#                  WHERE tablename = 'countries' AND attname='continent';\n-[ RECORD 1 ]-----+-------------------------------------------------------------\nmost_common_vals  | {Africa,Europe,Asia,\"North America\",Oceania,\"South America\"}\nmost_common_freqs | {0.274611,0.243523,0.227979,0.119171,0.0725389,0.0621762}",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 42,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "The value of most_common_freqs corresponding to ‘Asia’ of the most_common_vals is 0.227979.\nTherefore, 0.227979 is used as the selectivity in this estimation.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 43,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "If the MCV cannot be used, e.g., the target column type is integer or double precision,\nthen the value of the histogram_bounds of the target column is used to estimate the cost.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 44,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "A specific example is shown.\nThis is the value of the histogram_bounds of the column ‘data’ in the table ’tbl’:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 45,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "[CODE BLOCK]\ntestdb=# SELECT histogram_bounds FROM pg_stats WHERE tablename = 'tbl' AND attname = 'data';\n        \t\t\t     \t      histogram_bounds\n---------------------------------------------------------------------------------------------------\n {1,100,200,300,400,500,600,700,800,900,1000,1100,1200,1300,1400,1500,1600,1700,1800,1900,2000,2100,\n2200,2300,2400,2500,2600,2700,2800,2900,3000,3100,3200,3300,3400,3500,3600,3700,3800,3900,4000,4100,\n4200,4300,4400,4500,4600,4700,4800,4900,5000,5100,5200,5300,5400,5500,5600,5700,5800,5900,6000,6100,\n6200,6300,6400,6500,6600,6700,6800,6900,7000,7100,7200,7300,7400,7500,7600,7700,7800,7900,8000,8100,\n8200,8300,8400,8500,8600,8700,8800,8900,9000,9100,9200,9300,9400,9500,9600,9700,9800,9900,10000}\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 46,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "By default, the histogram_bounds is divided into 100 buckets.\nFigure 3.7 illustrates the buckets and the corresponding histogram_bounds in this example.\nBuckets are numbered starting from 0, and every bucket stores (approximately) the same number of tuples.\nThe values of histogram_bounds are the bounds of the corresponding buckets.\nFor example, the 0th value of the histogram bounds is 1, which means that it is the minimum value of the tuples stored in bucket 0.\nThe 1st value is 100 and this is the minimum value of the tuples stored in bucket 1, and so on.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 47,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "Next, the calculation of the selectivity will be shown using the example in this subsection.\nThe query has a WHERE clause ‘$\\text{data} \\lt= 240$’ and the value 240 is in the second bucket.\nIn this case, the selectivity can be derived by applying linear interpolation. Thus, the selectivity of the column ‘data’ in this query is calculated using the following equation:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 48,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "$ \\text{’table IO cost’} $ is defined by the following equation:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 49,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "$ \\text{max_IO_cost} $ is the worst case of the IO cost, that is, the cost of randomly scanning all table pages;\nthis cost is defined by the following equation:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 50,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "In this case, according to (2), $ N_{page} = 45 $, and thus",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 51,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "$ \\text{min_IO_cost} $ is the best case of the IO cost, that is, the cost of sequentially scanning the selected table pages;\nthis cost is defined by the following equation:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 52,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "$ \\text{indexCorrelation} $ is described in detail in  below,\nand in this example,",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 53,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "Index correlation is a statistical correlation between the physical row ordering and the logical ordering of the column values (cited from the official document).\nThis ranges from -1 to +1.\nTo understand the relation between the index scan and the index correlation,\na specific example is shown below.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 54,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "The table ’tbl_corr’ has five columns: two columns are text type and three columns are integer type.\nThe three integer columns store numbers from 1 to 12.\nPhysically, tbl_corr is composed of three pages, and each page has four tuples.\nEach integer type column has an index with a name such as index_col_asc and so on.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 55,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "[CODE BLOCK]\ntestdb=# \\d tbl_corr\n    Table \"public.tbl_corr\"\n  Column  |  Type   | Modifiers\n----------+---------+-----------\n col      | text    |\n col_asc  | integer |\n col_desc | integer |\n col_rand | integer |\n data     | text    |\nIndexes:\n    \"tbl_corr_asc_idx\" btree (col_asc)\n    \"tbl_corr_desc_idx\" btree (col_desc)\n    \"tbl_corr_rand_idx\" btree (col_rand)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 56,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "[CODE BLOCK]\ntestdb=# SELECT col,col_asc,col_desc,col_rand\ntestdb-#                         FROM tbl_corr;\n   col    | col_asc | col_desc | col_rand\n----------+---------+----------+----------\n Tuple_1  |       1 |       12 |        3\n Tuple_2  |       2 |       11 |        8\n Tuple_3  |       3 |       10 |        5\n Tuple_4  |       4 |        9 |        9\n Tuple_5  |       5 |        8 |        7\n Tuple_6  |       6 |        7 |        2\n Tuple_7  |       7 |        6 |       10\n Tuple_8  |       8 |        5 |       11\n Tuple_9  |       9 |        4 |        4\n Tuple_10 |      10 |        3 |        1\n Tuple_11 |      11 |        2 |       12\n Tuple_12 |      12 |        1 |        6\n(12 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 57,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "The index correlations of these columns are shown below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 58,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "[CODE BLOCK]\ntestdb=# SELECT tablename,attname, correlation FROM pg_stats WHERE tablename = 'tbl_corr';\n tablename | attname  | correlation\n-----------+----------+-------------\n tbl_corr  | col_asc  |           1\n tbl_corr  | col_desc |          -1\n tbl_corr  | col_rand |    0.125874\n(3 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 59,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "When the following query is executed,\nPostgreSQL reads only the first page because all of the target tuples are stored in the first page.\nSee Figure 3.8(a).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 60,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "[CODE BLOCK]\ntestdb=# SELECT * FROM tbl_corr WHERE col_asc BETWEEN 2 AND 4;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 61,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "On the other hand, when the following query is executed, PostgreSQL has to read all pages.\nSee Figure 3.8(b).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 62,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "[CODE BLOCK]\ntestdb=# SELECT * FROM tbl_corr WHERE col_rand BETWEEN 2 AND 4;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 63,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "In this way,\nthe index correlation is a statistical correlation that reflects the impact of random access caused by the discrepancy between the index ordering and the physical tuple ordering in the table when estimating the index scan cost.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 64,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "For confirmation, the result of the EXPLAIN command of the above SELECT query is shown below:",
    "tables": [
      {
        "table_index": 0,
        "content": "1\n2\n3\n4\n5\n6 | testdb=# EXPLAIN SELECT id, data FROM tbl WHERE data <= 240;\n                                QUERY PLAN\n---------------------------------------------------------------------------\n Index Scan using tbl_data_idx on tbl  (cost=0.29..13.49 rows=240 width=8)\n   Index Cond: (data <= 240)\n(2 rows)"
      }
    ],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 65,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "[CODE BLOCK]\ntestdb=# EXPLAIN SELECT id, data FROM tbl WHERE data <= 240;\n                                QUERY PLAN\n---------------------------------------------------------------------------\n Index Scan using tbl_data_idx on tbl  (cost=0.29..13.49 rows=240 width=8)\n   Index Cond: (data <= 240)\n(2 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 66,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "In Line 4, we can find that the start-up and total costs are 0.29 and 13.49, respectively,\nand it is estimated that 240 rows (tuples) will be scanned.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 67,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "In Line 5,\nan index condition ‘$\\text{Index} \\text{Cond}:(\\text{data} \\lt= 240)$’ of the index scan is shown.\nMore precisely, this condition is called an access predicate, and it expresses the start and stop conditions of the index scan.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 68,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "According to this post,\nEXPLAIN command in PostgreSQL does not distinguish between the access predicate and index filter predicate.\nTherefore, when analyzing the output of EXPLAIN, it is important to consider both the index conditions and the estimated value of rows.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 69,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "The default values of seq_page_cost and random_page_cost are 1.0 and 4.0, respectively.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 70,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "This means that PostgreSQL assumes that the random scan is four times slower than the sequential scan.\nIn other words, the default value of PostgreSQL is based on using HDDs.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 71,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "On the other hand, in recent days, the default value of random_page_cost is too large because SSDs are mostly used.\nIf the default value of random_page_cost is used despite using an SSD, the planner may select ineffective plans.\nTherefore, when using an SSD, it is better to change the value of random_page_cost to 1.0.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 72,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.2. Index Scan",
    "text": "This blog reported the problem when using the default value of random_page_cost.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 73,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.3. Sort",
    "text": "The sort path is used for sorting operations, such as ORDER BY, the preprocessing of merge join operations, and other functions.\nThe cost of sorting is estimated using the cost_sort() function.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 74,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.3. Sort",
    "text": "In the sorting operation,\nif all tuples to be sorted can be stored in work_mem, the quicksort algorithm is used.\nOtherwise, a temporary file is created and the file merge sort algorithm is used.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 75,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.3. Sort",
    "text": "The start-up cost of the sort path is the cost of sorting the target tuples.\nTherefore,\nthe cost is $ O(N_{sort} \\times \\log_2(N_{sort})) $, where $ N_{sort} $ is the number of the tuples to be sorted.\nThe run cost of the sort path is the cost of reading the sorted tuples.\nTherefore the cost is $ O(N_{sort}) $.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 76,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.3. Sort",
    "text": "In this subsection, we explore how to estimate the sorting cost of the following query.\nAssume that this query will be sorted in work_mem, without using temporary files.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 77,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.3. Sort",
    "text": "[CODE BLOCK]\ntestdb=# SELECT id, data FROM tbl WHERE data <= 240 ORDER BY id;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 78,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.3. Sort",
    "text": "In this case, the start-up cost is defined in the following equation:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 79,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.3. Sort",
    "text": "Therefore, the $ \\text{start-up cost} $ is calculated as follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 80,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.3. Sort",
    "text": "The $ \\text{run cost} $ is the cost of reading sorted tuples in the memory.\nTherefore,",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 81,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.3. Sort",
    "text": "For confirmation, the result of the EXPLAIN command of the above SELECT query is shown below:",
    "tables": [
      {
        "table_index": 0,
        "content": "1\n2\n3\n4\n5\n6\n7\n8 | testdb=# EXPLAIN SELECT id, data FROM tbl WHERE data <= 240 ORDER BY id;\n                                   QUERY PLAN\n---------------------------------------------------------------------------------\n Sort  (cost=22.97..23.57 rows=240 width=8)\n   Sort Key: id\n   ->  Index Scan using tbl_data_idx on tbl  (cost=0.29..13.49 rows=240 width=8)\n         Index Cond: (data <= 240)\n(4 rows)"
      }
    ],
    "extracted_at": "2025-10-03T12:32:06.005336"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 82,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.3. Sort",
    "text": "[CODE BLOCK]\ntestdb=# EXPLAIN SELECT id, data FROM tbl WHERE data <= 240 ORDER BY id;\n                                   QUERY PLAN\n---------------------------------------------------------------------------------\n Sort  (cost=22.97..23.57 rows=240 width=8)\n   Sort Key: id\n   ->  Index Scan using tbl_data_idx on tbl  (cost=0.29..13.49 rows=240 width=8)\n         Index Cond: (data <= 240)\n(4 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.006335"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 83,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.2.3. Sort",
    "text": "In line 4, we can find that the start-up cost and total cost are 22.97 and 23.57, respectively.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:06.006335"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "As the processing of the planner is very complicated,\nthis section describes the simplest process, namely, how a plan tree of a single-table query is created.\nMore complex processing, namely, how a plan tree of a multi-table query is created, is described in Section 3.6.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.165609"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "The planner in PostgreSQL performs three steps, as shown below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.165609"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "An access path is a unit of processing for estimating the cost.\nFor example, the sequential scan, index scan, sort, and various join operations have their corresponding paths.\nAccess paths are used only inside the planner to create the plan tree.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.165609"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "The most fundamental data structure of access paths is the Path structure defined in pathnodes.h, and it corresponds to the sequential scan.\nAll other access paths are based on it.\nDetails will be described in the following explanations.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.165609"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "[CODE BLOCK]\ntypedef struct PathKey\n{\n\tpg_node_attr(no_read, no_query_jumble)\n\tNodeTag\t\ttype;\n\n\t/* the value that is ordered */\n\tEquivalenceClass *pk_eclass pg_node_attr(copy_as_scalar, equal_as_scalar);\n\tOid\t\tpk_opfamily;\t/* btree opfamily defining the ordering */\n\tint\t\tpk_strategy;\t/* sort direction (ASC or DESC) */\n\tbool\t\tpk_nulls_first; /* do NULLs come before normal values? */\n} PathKey;\n\ntypedef struct Path\n{\n\tpg_node_attr(no_copy_equal, no_read, no_query_jumble)\n\n\tNodeTag\t\ttype;\n\n\t/* tag identifying scan/join method */\n\tNodeTag\t\tpathtype;\n\n\t/*\n\t * the relation this path can build\n\t *\n\t * We do NOT print the parent, else we'd be in infinite recursion.  We can\n\t * print the parent's relids for identification purposes, though.\n\t */\n\tRelOptInfo *parent pg_node_attr(write_only_relids);\n\n\t/*\n\t * list of Vars/Exprs, cost, width\n\t *\n\t * We print the pathtarget only if it's not the default one for the rel.\n\t */\n\tPathTarget *pathtarget pg_node_attr(write_only_nondefault_pathtarget);\n\n\t/*\n\t * parameterization info, or NULL if none\n\t *\n\t * We do not print the whole of param_info, since it's printed via\n\t * RelOptInfo; it's sufficient and less cluttering to print just the\n\t * required outer relids.\n\t */\n\tParamPathInfo *param_info pg_node_attr(write_only_req_outer);\n\n\t/* engage parallel-aware logic? */\n\tbool\t\tparallel_aware;\n\t/* OK to use as part of parallel plan? */\n\tbool\t\tparallel_safe;\n\t/* desired # of workers; 0 = not parallel */\n\tint\t\t\tparallel_workers;\n\n\t/* estimated size/costs for path (see costsize.c for more info) */\n\tCardinality rows;\t\t\t/* estimated number of result tuples */\n\tCost\t\tstartup_cost;\t/* cost expended before fetching any tuples */\n\tCost\t\ttotal_cost;\t\t/* total cost (assuming all tuples fetched) */\n\n\t/* sort ordering of path's output; a List of PathKey nodes; see above */\n\tList\t   *pathkeys;\n} Path;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166134"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "To process the above steps,\nthe planner internally creates a PlannerInfo structure,\nand holds the query tree, the information about the relations contained in the query,\nthe access paths, and so on.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166134"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "[CODE BLOCK]\n/*----------\n * PlannerInfo\n *\t\tPer-query information for planning/optimization\n *\n * This struct is conventionally called \"root\" in all the planner routines.\n * It holds links to all of the planner's working state, in addition to the\n * original Query.  Note that at present the planner extensively modifies\n * the passed-in Query data structure; someday that should stop.\n *\n * For reasons explained in optimizer/optimizer.h, we define the typedef\n * either here or in that header, whichever is read first.\n *\n * Not all fields are printed.  (In some cases, there is no print support for\n * the field type; in others, doing so would lead to infinite recursion or\n * bloat dump output more than seems useful.)\n *----------\n */\n#ifndef HAVE_PLANNERINFO_TYPEDEF\ntypedef struct PlannerInfo PlannerInfo;\n#define HAVE_PLANNERINFO_TYPEDEF 1\n#endif\n\nstruct PlannerInfo\n{\n\tpg_node_attr(no_copy_equal, no_read, no_query_jumble)\n\n\tNodeTag\t\ttype;\n\n\t/* the Query being planned */\n\tQuery\t   *parse;\n\n\t/* global info for current planner run */\n\tPlannerGlobal *glob;\n\n\t/* 1 at the outermost Query */\n\tIndex\t\tquery_level;\n\n\t/* NULL at outermost Query */\n\tPlannerInfo *parent_root pg_node_attr(read_write_ignore);\n\n\t/*\n\t * plan_params contains the expressions that this query level needs to\n\t * make available to a lower query level that is currently being planned.\n\t * outer_params contains the paramIds of PARAM_EXEC Params that outer\n\t * query levels will make available to this query level.\n\t */\n\t/* list of PlannerParamItems, see below */\n\tList\t   *plan_params;\n\tBitmapset  *outer_params;\n\n\t/*\n\t * simple_rel_array holds pointers to \"base rels\" and \"other rels\" (see\n\t * comments for RelOptInfo for more info).  It is indexed by rangetable\n\t * index (so entry 0 is always wasted).  Entries can be NULL when an RTE\n\t * does not correspond to a base relation, such as a join RTE or an\n\t * unreferenced view RTE; or if the RelOptInfo hasn't been made yet.\n\t */\n\tstruct RelOptInfo **simple_rel_array pg_node_attr(array_size(simple_rel_array_size));\n\t/* allocated size of array */\n\tint\t\t\tsimple_rel_array_size;\n\n\t/*\n\t * simple_rte_array is the same length as simple_rel_array and holds\n\t * pointers to the associated rangetable entries.  Using this is a shade\n\t * faster than using rt_fetch(), mostly due to fewer indirections.  (Not\n\t * printed because it'd be redundant with parse->rtable.)\n\t */\n\tRangeTblEntry **simple_rte_array pg_node_attr(read_write_ignore);\n\n\t/*\n\t * append_rel_array is the same length as the above arrays, and holds\n\t * pointers to the corresponding AppendRelInfo entry indexed by\n\t * child_relid, or NULL if the rel is not an appendrel child.  The array\n\t * itself is not allocated if append_rel_list is empty.  (Not printed\n\t * because it'd be redundant with append_rel_list.)\n\t */\n\tstruct AppendRelInfo **append_rel_array pg_node_attr(read_write_ignore);\n\n\t/*\n\t * all_baserels is a Relids set of all base relids (but not joins or\n\t * \"other\" rels) in the query.  This is computed in deconstruct_jointree.\n\t */\n\tRelids\t\tall_baserels;\n\n\t/*\n\t * outer_join_rels is a Relids set of all outer-join relids in the query.\n\t * This is computed in deconstruct_jointree.\n\t */\n\tRelids\t\touter_join_rels;\n\n\t/*\n\t * all_query_rels is a Relids set of all base relids and outer join relids\n\t * (but not \"other\" relids) in the query.  This is the Relids identifier\n\t * of the final join we need to form.  This is computed in\n\t * deconstruct_jointree.\n\t */\n\tRelids\t\tall_query_rels;\n\n\t/*\n\t * join_rel_list is a list of all join-relation RelOptInfos we have\n\t * considered in this planning run.  For small problems we just scan the\n\t * list to do lookups, but when there are many join relations we build a\n\t * hash table for faster lookups.  The hash table is present and valid\n\t * when join_rel_hash is not NULL.  Note that we still maintain the list\n\t * even when using the hash table for lookups; this simplifies life for\n\t * GEQO.\n\t */\n\tList\t   *join_rel_list;\n\tstruct HTAB *join_rel_hash pg_node_attr(read_write_ignore);\n\n\t/*\n\t * When doing a dynamic-programming-style join search, join_rel_level[k]\n\t * is a list of all join-relation RelOptInfos of level k, and\n\t * join_cur_level is the current level.  New join-relation RelOptInfos are\n\t * automatically added to the join_rel_level[join_cur_level] list.\n\t * join_rel_level is NULL if not in use.\n\t *\n\t * Note: we've already printed all baserel and joinrel RelOptInfos above,\n\t * so we don't dump join_rel_level or other lists of RelOptInfos.\n\t */\n\t/* lists of join-relation RelOptInfos */\n\tList\t  **join_rel_level pg_node_attr(read_write_ignore);\n\t/* index of list being extended */\n\tint\t\t\tjoin_cur_level;\n\n\t/* init SubPlans for query */\n\tList\t   *init_plans;\n\n\t/*\n\t * per-CTE-item list of subplan IDs (or -1 if no subplan was made for that\n\t * CTE)\n\t */\n\tList\t   *cte_plan_ids;\n\n\t/* List of Lists of Params for MULTIEXPR subquery outputs */\n\tList\t   *multiexpr_params;\n\n\t/* list of JoinDomains used in the query (higher ones first) */\n\tList\t   *join_domains;\n\n\t/* list of active EquivalenceClasses */\n\tList\t   *eq_classes;\n\n\t/* set true once ECs are canonical */\n\tbool\t\tec_merging_done;\n\n\t/* list of \"canonical\" PathKeys */\n\tList\t   *canon_pathkeys;\n\n\t/*\n\t * list of OuterJoinClauseInfos for mergejoinable outer join clauses\n\t * w/nonnullable var on left\n\t */\n\tList\t   *left_join_clauses;\n\n\t/*\n\t * list of OuterJoinClauseInfos for mergejoinable outer join clauses\n\t * w/nonnullable var on right\n\t */\n\tList\t   *right_join_clauses;\n\n\t/*\n\t * list of OuterJoinClauseInfos for mergejoinable full join clauses\n\t */\n\tList\t   *full_join_clauses;\n\n\t/* list of SpecialJoinInfos */\n\tList\t   *join_info_list;\n\n\t/* counter for assigning RestrictInfo serial numbers */\n\tint\t\t\tlast_rinfo_serial;\n\n\t/*\n\t * all_result_relids is empty for SELECT, otherwise it contains at least\n\t * parse->resultRelation.  For UPDATE/DELETE/MERGE across an inheritance\n\t * or partitioning tree, the result rel's child relids are added.  When\n\t * using multi-level partitioning, intermediate partitioned rels are\n\t * included. leaf_result_relids is similar except that only actual result\n\t * tables, not partitioned tables, are included in it.\n\t */\n\t/* set of all result relids */\n\tRelids\t\tall_result_relids;\n\t/* set of all leaf relids */\n\tRelids\t\tleaf_result_relids;\n\n\t/*\n\t * list of AppendRelInfos\n\t *\n\t * Note: for AppendRelInfos describing partitions of a partitioned table,\n\t * we guarantee that partitions that come earlier in the partitioned\n\t * table's PartitionDesc will appear earlier in append_rel_list.\n\t */\n\tList\t   *append_rel_list;\n\n\t/* list of RowIdentityVarInfos */\n\tList\t   *row_identity_vars;\n\n\t/* list of PlanRowMarks */\n\tList\t   *rowMarks;\n\n\t/* list of PlaceHolderInfos */\n\tList\t   *placeholder_list;\n\n\t/* array of PlaceHolderInfos indexed by phid */\n\tstruct PlaceHolderInfo **placeholder_array pg_node_attr(read_write_ignore, array_size(placeholder_array_size));\n\t/* allocated size of array */\n\tint\t\t\tplaceholder_array_size pg_node_attr(read_write_ignore);\n\n\t/* list of ForeignKeyOptInfos */\n\tList\t   *fkey_list;\n\n\t/* desired pathkeys for query_planner() */\n\tList\t   *query_pathkeys;\n\n\t/* groupClause pathkeys, if any */\n\tList\t   *group_pathkeys;\n\n\t/*\n\t * The number of elements in the group_pathkeys list which belong to the\n\t * GROUP BY clause.  Additional ones belong to ORDER BY / DISTINCT\n\t * aggregates.\n\t */\n\tint\t\t\tnum_groupby_pathkeys;\n\n\t/* pathkeys of bottom window, if any */\n\tList\t   *window_pathkeys;\n\t/* distinctClause pathkeys, if any */\n\tList\t   *distinct_pathkeys;\n\t/* sortClause pathkeys, if any */\n\tList\t   *sort_pathkeys;\n\n\t/* Canonicalised partition schemes used in the query. */\n\tList\t   *part_schemes pg_node_attr(read_write_ignore);\n\n\t/* RelOptInfos we are now trying to join */\n\tList\t   *initial_rels pg_node_attr(read_write_ignore);\n\n\t/*\n\t * Upper-rel RelOptInfos. Use fetch_upper_rel() to get any particular\n\t * upper rel.\n\t */\n\tList\t   *upper_rels[UPPERREL_FINAL + 1] pg_node_attr(read_write_ignore);\n\n\t/* Result tlists chosen by grouping_planner for upper-stage processing */\n\tstruct PathTarget *upper_targets[UPPERREL_FINAL + 1] pg_node_attr(read_write_ignore);\n\n\t/*\n\t * The fully-processed groupClause is kept here.  It differs from\n\t * parse->groupClause in that we remove any items that we can prove\n\t * redundant, so that only the columns named here actually need to be\n\t * compared to determine grouping.  Note that it's possible for *all* the\n\t * items to be proven redundant, implying that there is only one group\n\t * containing all the query's rows.  Hence, if you want to check whether\n\t * GROUP BY was specified, test for nonempty parse->groupClause, not for\n\t * nonempty processed_groupClause.\n\t *\n\t * Currently, when grouping sets are specified we do not attempt to\n\t * optimize the groupClause, so that processed_groupClause will be\n\t * identical to parse->groupClause.\n\t */\n\tList\t   *processed_groupClause;\n\n\t/*\n\t * The fully-processed distinctClause is kept here.  It differs from\n\t * parse->distinctClause in that we remove any items that we can prove\n\t * redundant, so that only the columns named here actually need to be\n\t * compared to determine uniqueness.  Note that it's possible for *all*\n\t * the items to be proven redundant, implying that there should be only\n\t * one output row.  Hence, if you want to check whether DISTINCT was\n\t * specified, test for nonempty parse->distinctClause, not for nonempty\n\t * processed_distinctClause.\n\t */\n\tList\t   *processed_distinctClause;\n\n\t/*\n\t * The fully-processed targetlist is kept here.  It differs from\n\t * parse->targetList in that (for INSERT) it's been reordered to match the\n\t * target table, and defaults have been filled in.  Also, additional\n\t * resjunk targets may be present.  preprocess_targetlist() does most of\n\t * that work, but note that more resjunk targets can get added during\n\t * appendrel expansion.  (Hence, upper_targets mustn't get set up till\n\t * after that.)\n\t */\n\tList\t   *processed_tlist;\n\n\t/*\n\t * For UPDATE, this list contains the target table's attribute numbers to\n\t * which the first N entries of processed_tlist are to be assigned.  (Any\n\t * additional entries in processed_tlist must be resjunk.)  DO NOT use the\n\t * resnos in processed_tlist to identify the UPDATE target columns.\n\t */\n\tList\t   *update_colnos;\n\n\t/*\n\t * Fields filled during create_plan() for use in setrefs.c\n\t */\n\t/* for GroupingFunc fixup (can't print: array length not known here) */\n\tAttrNumber *grouping_map pg_node_attr(read_write_ignore);\n\t/* List of MinMaxAggInfos */\n\tList\t   *minmax_aggs;\n\n\t/* context holding PlannerInfo */\n\tMemoryContext planner_cxt pg_node_attr(read_write_ignore);\n\n\t/* # of pages in all non-dummy tables of query */\n\tCardinality total_table_pages;\n\n\t/* tuple_fraction passed to query_planner */\n\tSelectivity tuple_fraction;\n\t/* limit_tuples passed to query_planner */\n\tCardinality limit_tuples;\n\n\t/*\n\t * Minimum security_level for quals. Note: qual_security_level is zero if\n\t * there are no securityQuals.\n\t */\n\tIndex\t\tqual_security_level;\n\n\t/* true if any RTEs are RTE_JOIN kind */\n\tbool\t\thasJoinRTEs;\n\t/* true if any RTEs are marked LATERAL */\n\tbool\t\thasLateralRTEs;\n\t/* true if havingQual was non-null */\n\tbool\t\thasHavingQual;\n\t/* true if any RestrictInfo has pseudoconstant = true */\n\tbool\t\thasPseudoConstantQuals;\n\t/* true if we've made any of those */\n\tbool\t\thasAlternativeSubPlans;\n\t/* true once we're no longer allowed to add PlaceHolderInfos */\n\tbool\t\tplaceholdersFrozen;\n\t/* true if planning a recursive WITH item */\n\tbool\t\thasRecursion;\n\n\t/*\n\t * Information about aggregates. Filled by preprocess_aggrefs().\n\t */\n\t/* AggInfo structs */\n\tList\t   *agginfos;\n\t/* AggTransInfo structs */\n\tList\t   *aggtransinfos;\n\t/* number of aggs with DISTINCT/ORDER BY/WITHIN GROUP */\n\tint\t\t\tnumOrderedAggs;\n\t/* does any agg not support partial mode? */\n\tbool\t\thasNonPartialAggs;\n\t/* is any partial agg non-serializable? */\n\tbool\t\thasNonSerialAggs;\n\n\t/*\n\t * These fields are used only when hasRecursion is true:\n\t */\n\t/* PARAM_EXEC ID for the work table */\n\tint\t\t\twt_param_id;\n\t/* a path for non-recursive term */\n\tstruct Path *non_recursive_path;\n\n\t/*\n\t * These fields are workspace for createplan.c\n\t */\n\t/* outer rels above current node */\n\tRelids\t\tcurOuterRels;\n\t/* not-yet-assigned NestLoopParams */\n\tList\t   *curOuterParams;\n\n\t/*\n\t * These fields are workspace for setrefs.c.  Each is an array\n\t * corresponding to glob->subplans.  (We could probably teach\n\t * gen_node_support.pl how to determine the array length, but it doesn't\n\t * seem worth the trouble, so just mark them read_write_ignore.)\n\t */\n\tbool\t   *isAltSubplan pg_node_attr(read_write_ignore);\n\tbool\t   *isUsedSubplan pg_node_attr(read_write_ignore);\n\n\t/* optional private data for join_search_hook, e.g., GEQO */\n\tvoid\t   *join_search_private pg_node_attr(read_write_ignore);\n\n\t/* Does this query modify any partition key columns? */\n\tbool\t\tpartColsUpdated;\n};",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166134"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "In this section, how plan trees are created from query trees is described using specific examples.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166134"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.1. Preprocessing",
    "text": "Before creating a plan tree, the planner carries out some preprocessing of the query tree stored in the PlannerInfo structure.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166134"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.1. Preprocessing",
    "text": "Although preprocessing involves many steps,\nwe only discuss the main preprocessing for the single-table query in this subsection.\nThe other preprocessing operations are described in Section 3.6.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166134"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.1. Preprocessing",
    "text": "Simplifying target lists, limit clauses, and so on.\nFor example, the eval_const_expressions() function defined in clauses.c rewrites ‘2 + 2’ to ‘4’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166134"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.1. Preprocessing",
    "text": "Normalizing Boolean expressions.\nFor example, ‘NOT (NOT a)’ is rewritten to ‘a’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166134"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.1. Preprocessing",
    "text": "Flattening AND/OR expressions.\nAND and OR in the SQL standard are binary operators,\nbut in PostgreSQL internals,\nthey are n-ary operators and the planner always assumes that all nested AND and OR expressions are to be flattened.\nA specific example is shown.\nConsider a Boolean expression ‘(id = 1) OR (id = 2) OR (id = 3)’.\nFigure 3.9(a) shows part of the query tree when using the binary operator.\nThe planner simplified this tree by flattening using a ternary operator.\nSee Figure 3.9(b).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166134"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "To get the cheapest access path,\nthe planner estimates the costs of all possible access paths and chooses the cheapest one.\nMore specifically, the planner performs the following operations:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166134"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "[CODE BLOCK]\ntypedef enum RelOptKind\n{\n\tRELOPT_BASEREL,\n\tRELOPT_JOINREL,\n\tRELOPT_OTHER_MEMBER_REL,\n\tRELOPT_OTHER_JOINREL,\n\tRELOPT_UPPER_REL,\n\tRELOPT_OTHER_UPPER_REL\n} RelOptKind;\n\n/*\n * Is the given relation a simple relation i.e a base or \"other\" member\n * relation?\n */\n#define IS_SIMPLE_REL(rel) \\\n\t((rel)->reloptkind == RELOPT_BASEREL || \\\n\t (rel)->reloptkind == RELOPT_OTHER_MEMBER_REL)\n\n/* Is the given relation a join relation? */\n#define IS_JOIN_REL(rel)\t\\\n\t((rel)->reloptkind == RELOPT_JOINREL || \\\n\t (rel)->reloptkind == RELOPT_OTHER_JOINREL)\n\n/* Is the given relation an upper relation? */\n#define IS_UPPER_REL(rel)\t\\\n\t((rel)->reloptkind == RELOPT_UPPER_REL || \\\n\t (rel)->reloptkind == RELOPT_OTHER_UPPER_REL)\n\n/* Is the given relation an \"other\" relation? */\n#define IS_OTHER_REL(rel) \\\n\t((rel)->reloptkind == RELOPT_OTHER_MEMBER_REL || \\\n\t (rel)->reloptkind == RELOPT_OTHER_JOINREL || \\\n\t (rel)->reloptkind == RELOPT_OTHER_UPPER_REL)\n\ntypedef struct RelOptInfo\n{\n\tpg_node_attr(no_copy_equal, no_read, no_query_jumble)\n\n\tNodeTag\t\ttype;\n\n\tRelOptKind\treloptkind;\n\n\t/*\n\t * all relations included in this RelOptInfo; set of base + OJ relids\n\t * (rangetable indexes)\n\t */\n\tRelids\t\trelids;\n\n\t/*\n\t * size estimates generated by planner\n\t */\n\t/* estimated number of result tuples */\n\tCardinality rows;\n\n\t/*\n\t * per-relation planner control flags\n\t */\n\t/* keep cheap-startup-cost paths? */\n\tbool\t\tconsider_startup;\n\t/* ditto, for parameterized paths? */\n\tbool\t\tconsider_param_startup;\n\t/* consider parallel paths? */\n\tbool\t\tconsider_parallel;\n\n\t/*\n\t * default result targetlist for Paths scanning this relation; list of\n\t * Vars/Exprs, cost, width\n\t */\n\tstruct PathTarget *reltarget;\n\n\t/*\n\t * materialization information\n\t */\n\tList\t   *pathlist;\t\t/* Path structures */\n\tList\t   *ppilist;\t\t/* ParamPathInfos used in pathlist */\n\tList\t   *partial_pathlist;\t/* partial Paths */\n\tstruct Path *cheapest_startup_path;\n\tstruct Path *cheapest_total_path;\n\tstruct Path *cheapest_unique_path;\n\tList\t   *cheapest_parameterized_paths;\n\n\t/*\n\t * parameterization information needed for both base rels and join rels\n\t * (see also lateral_vars and lateral_referencers)\n\t */\n\t/* rels directly laterally referenced */\n\tRelids\t\tdirect_lateral_relids;\n\t/* minimum parameterization of rel */\n\tRelids\t\tlateral_relids;\n\n\t/*\n\t * information about a base rel (not set for join rels!)\n\t */\n\tIndex\t\trelid;\n\t/* containing tablespace */\n\tOid\t\t\treltablespace;\n\t/* RELATION, SUBQUERY, FUNCTION, etc */\n\tRTEKind\t\trtekind;\n\t/* smallest attrno of rel (often <0) */\n\tAttrNumber\tmin_attr;\n\t/* largest attrno of rel */\n\tAttrNumber\tmax_attr;\n\t/* array indexed [min_attr .. max_attr] */\n\tRelids\t   *attr_needed pg_node_attr(read_write_ignore);\n\t/* array indexed [min_attr .. max_attr] */\n\tint32\t   *attr_widths pg_node_attr(read_write_ignore);\n\t/* relids of outer joins that can null this baserel */\n\tRelids\t\tnulling_relids;\n\t/* LATERAL Vars and PHVs referenced by rel */\n\tList\t   *lateral_vars;\n\t/* rels that reference this baserel laterally */\n\tRelids\t\tlateral_referencers;\n\t/* list of IndexOptInfo */\n\tList\t   *indexlist;\n\t/* list of StatisticExtInfo */\n\tList\t   *statlist;\n\t/* size estimates derived from pg_class */\n\tBlockNumber pages;\n\tCardinality tuples;\n\tdouble\t\tallvisfrac;\n\t/* indexes in PlannerInfo's eq_classes list of ECs that mention this rel */\n\tBitmapset  *eclass_indexes;\n\tPlannerInfo *subroot;\t\t/* if subquery */\n\tList\t   *subplan_params; /* if subquery */\n\t/* wanted number of parallel workers */\n\tint\t\t\trel_parallel_workers;\n\t/* Bitmask of optional features supported by the table AM */\n\tuint32\t\tamflags;\n\n\t/*\n\t * Information about foreign tables and foreign joins\n\t */\n\t/* identifies server for the table or join */\n\tOid\t\t\tserverid;\n\t/* identifies user to check access as; 0 means to check as current user */\n\tOid\t\t\tuserid;\n\t/* join is only valid for current user */\n\tbool\t\tuseridiscurrent;\n\t/* use \"struct FdwRoutine\" to avoid including fdwapi.h here */\n\tstruct FdwRoutine *fdwroutine pg_node_attr(read_write_ignore);\n\tvoid\t   *fdw_private pg_node_attr(read_write_ignore);\n\n\t/*\n\t * cache space for remembering if we have proven this relation unique\n\t */\n\t/* known unique for these other relid set(s) */\n\tList\t   *unique_for_rels;\n\t/* known not unique for these set(s) */\n\tList\t   *non_unique_for_rels;\n\n\t/*\n\t * used by various scans and joins:\n\t */\n\t/* RestrictInfo structures (if base rel) */\n\tList\t   *baserestrictinfo;\n\t/* cost of evaluating the above */\n\tQualCost\tbaserestrictcost;\n\t/* min security_level found in baserestrictinfo */\n\tIndex\t\tbaserestrict_min_security;\n\t/* RestrictInfo structures for join clauses involving this rel */\n\tList\t   *joininfo;\n\t/* T means joininfo is incomplete */\n\tbool\t\thas_eclass_joins;\n\n\t/*\n\t * used by partitionwise joins:\n\t */\n\t/* consider partitionwise join paths? (if partitioned rel) */\n\tbool\t\tconsider_partitionwise_join;\n\n\t/*\n\t * inheritance links, if this is an otherrel (otherwise NULL):\n\t */\n\t/* Immediate parent relation (dumping it would be too verbose) */\n\tstruct RelOptInfo *parent pg_node_attr(read_write_ignore);\n\t/* Topmost parent relation (dumping it would be too verbose) */\n\tstruct RelOptInfo *top_parent pg_node_attr(read_write_ignore);\n\t/* Relids of topmost parent (redundant, but handy) */\n\tRelids\t\ttop_parent_relids;\n\n\t/*\n\t * used for partitioned relations:\n\t */\n\t/* Partitioning scheme */\n\tPartitionScheme part_scheme pg_node_attr(read_write_ignore);\n\n\t/*\n\t * Number of partitions; -1 if not yet set; in case of a join relation 0\n\t * means it's considered unpartitioned\n\t */\n\tint\t\t\tnparts;\n\t/* Partition bounds */\n\tstruct PartitionBoundInfoData *boundinfo pg_node_attr(read_write_ignore);\n\t/* True if partition bounds were created by partition_bounds_merge() */\n\tbool\t\tpartbounds_merged;\n\t/* Partition constraint, if not the root */\n\tList\t   *partition_qual;\n\n\t/*\n\t * Array of RelOptInfos of partitions, stored in the same order as bounds\n\t * (don't print, too bulky and duplicative)\n\t */\n\tstruct RelOptInfo **part_rels pg_node_attr(read_write_ignore);\n\n\t/*\n\t * Bitmap with members acting as indexes into the part_rels[] array to\n\t * indicate which partitions survived partition pruning.\n\t */\n\tBitmapset  *live_parts;\n\t/* Relids set of all partition relids */\n\tRelids\t\tall_partrels;\n\n\t/*\n\t * These arrays are of length partkey->partnatts, which we don't have at\n\t * hand, so don't try to print\n\t */\n\n\t/* Non-nullable partition key expressions */\n\tList\t  **partexprs pg_node_attr(read_write_ignore);\n\t/* Nullable partition key expressions */\n\tList\t  **nullable_partexprs pg_node_attr(read_write_ignore);\n} RelOptInfo;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "Estimate the costs of all possible access paths, and add the access paths to the RelOptInfo structure.\n\nDetails of this processing are as follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "A path is created, the cost of the sequential scan is estimated, and the estimated costs are written to the path.\nThen, the path is added to the pathlist of the RelOptInfo structure.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "If indexes related to the target table exist, index access paths are created, all index scan costs are estimated, and the estimated costs are written to the path.\nThen, the index paths are added to the pathlist.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "If the bitmap scan can be done, bitmap scan paths are created, all bitmap scan costs are estimated, and the estimated costs are written to the path.\nThen, the bitmap scan paths are added to the pathlist.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "Get the cheapest access path in the pathlist of the RelOptInfo structure.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "Estimate LIMIT, ORDER BY and ARREGISFDD costs if necessary.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "To understand how the planner performs clearly, two specific examples are shown below.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "First, we explore a simple-single table query without indexes; this query contains both WHERE and ORDER BY clauses.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "[CODE BLOCK]\ntestdb=# \\d tbl_1\n     Table \"public.tbl_1\"\n Column |  Type   | Modifiers\n--------+---------+-----------\n id     | integer |\n data   | integer |\n\ntestdb=# SELECT * FROM tbl_1 WHERE id < 300 ORDER BY data;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "Figures 3.10 and 3.11 depict how the planner performs in this example.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "Create a RelOptInfo structure and store it in the simple_rel_array of the PlannerInfo.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "Add a WHERE clause to the baserestrictinfo of the RelOptInfo.\n\nA WHERE clause ‘$id \\lt 300$’ is added to the baserestrictinfo by the distribute_restrictinfo_to_rels() function defined in initsplan.c.\nIn addition, the indexlist of the RelOptInfo is NULL because there are no related indexes of the target table.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "Add the pathkey for sorting to the sort_pathkeys of the PlannerInfo\nby the standard_qp_callback() function defined in planner.c.\n\nPathkey is a data structure representing the sort ordering for the path.\nIn this example, the column ‘data’ is added to the sort_pathkeys as a pathkey because this query contains an ORDER BY clause and its column is ‘data’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "Create a path structure and estimate the cost of the sequential scan using the cost_seqscan function and write the estimated costs into the path.\nThen, add the path to the RelOptInfo by the add_path() function defined in pathnode.c.\n\nAs mentioned before, the Path structure contains both of the start-up and the total costs which are estimated by the cost_seqscan function, and so on.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "In this example, the planner only estimates the sequential scan cost because there are no indexes of the target table.\nTherefore, the cheapest access path is automatically determined.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 31,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "Create a new RelOptInfo structure to process the ORDER BY procedure.\n\nNote that the new RelOptInfo does not have the baserestrictinfo, that is, the information of the WHERE clause.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 32,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "Create a sort path and add it to the new RelOptInfo; then, link the sequential scan path to the subpath of the sort path.\n\nThe SortPath structure is composed of two path structures: path and subpath; the path stores information about the sort operation itself,\nand the subpath stores the cheapest path.\n\nNote that the item ‘parent’ of the sequential scan path holds the link to the old RelOptInfo which stores the WHERE clause in its baserestrictinfo.\nTherefore,\nin the next stage,\nthat is,\ncreating a plan tree,\nthe planner can create a sequential scan node that contains the WHERE clause as the ‘Filter’,\neven though the new RelOptInfo does not have the baserestrictinfo.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 33,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "[CODE BLOCK]\ntypedef struct SortPath\n{\n\tPath\tpath;\n\tPath\t*subpath;\t\t/* path representing input source */\n} SortPath;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 34,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "Based on the cheapest access path obtained here, a plan tree is generated. Details are described in Section 3.3.3.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 35,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "Next, we explore another single-table query with two indexes; this query contains a WHERE clause.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 36,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "[CODE BLOCK]\ntestdb=# \\d tbl_2\n     Table \"public.tbl_2\"\n Column |  Type   | Modifiers\n--------+---------+-----------\n id     | integer | not null\n data   | integer |\nIndexes:\n    \"tbl_2_pkey\" PRIMARY KEY, btree (id)\n    \"tbl_2_data_idx\" btree (data)\n\ntestdb=# SELECT * FROM tbl_2 WHERE id < 240;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 37,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "Figures 3.12 to 3.14 depict how the planner performs in this example.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 38,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "Add the WHERE clause to the baserestrictinfo, and add the indexes of the target table to the indexlist.\n\nIn this example, a WHERE clause ‘$\\text{id} \\lt 240$’ is added to the baserestrictinfo,\nand two indexes, tbl_2_pkey and tbl_2_data_idx, are added to the indexlist of the RelOptInfo.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 39,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "Create a path, estimate the cost of the sequential scan, and add the path to the pathlist of the RelOptInfo.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 40,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "[CODE BLOCK]\ntypedef struct IndexPath\n{\n\tPath\t\tpath;\n\tIndexOptInfo *indexinfo;\n\tList\t   *indexclauses;\n\tList\t   *indexorderbys;\n\tList\t   *indexorderbycols;\n\tScanDirection indexscandir;\n\tCost\t\tindextotalcost;\n\tSelectivity indexselectivity;\n} IndexPath;\n\n/*\n * IndexOptInfo\n *\t\tPer-index information for planning/optimization\n *\n *\t\tindexkeys[], indexcollations[] each have ncolumns entries.\n *\t\topfamily[], and opcintype[]\teach have nkeycolumns entries. They do\n *\t\tnot contain any information about included attributes.\n *\n *\t\tsortopfamily[], reverse_sort[], and nulls_first[] have\n *\t\tnkeycolumns entries, if the index is ordered; but if it is unordered,\n *\t\tthose pointers are NULL.\n *\n *\t\tZeroes in the indexkeys[] array indicate index columns that are\n *\t\texpressions; there is one element in indexprs for each such column.\n *\n *\t\tFor an ordered index, reverse_sort[] and nulls_first[] describe the\n *\t\tsort ordering of a forward indexscan; we can also consider a backward\n *\t\tindexscan, which will generate the reverse ordering.\n *\n *\t\tThe indexprs and indpred expressions have been run through\n *\t\tprepqual.c and eval_const_expressions() for ease of matching to\n *\t\tWHERE clauses. indpred is in implicit-AND form.\n *\n *\t\tindextlist is a TargetEntry list representing the index columns.\n *\t\tIt provides an equivalent base-relation Var for each simple column,\n *\t\tand links to the matching indexprs element for each expression column.\n *\n *\t\tWhile most of these fields are filled when the IndexOptInfo is created\n *\t\t(by plancat.c), indrestrictinfo and predOK are set later, in\n *\t\tcheck_index_predicates().\n */\n#ifndef HAVE_INDEXOPTINFO_TYPEDEF\ntypedef struct IndexOptInfo IndexOptInfo;\n#define HAVE_INDEXOPTINFO_TYPEDEF 1\n#endif\n\nstruct IndexOptInfo\n{\n\tpg_node_attr(no_copy_equal, no_read, no_query_jumble)\n\n\tNodeTag\t\ttype;\n\n\t/* OID of the index relation */\n\tOid\t\t\tindexoid;\n\t/* tablespace of index (not table) */\n\tOid\t\t\treltablespace;\n\t/* back-link to index's table; don't print, else infinite recursion */\n\tRelOptInfo *rel pg_node_attr(read_write_ignore);\n\n\t/*\n\t * index-size statistics (from pg_class and elsewhere)\n\t */\n\t/* number of disk pages in index */\n\tBlockNumber pages;\n\t/* number of index tuples in index */\n\tCardinality tuples;\n\t/* index tree height, or -1 if unknown */\n\tint\t\t\ttree_height;\n\n\t/*\n\t * index descriptor information\n\t */\n\t/* number of columns in index */\n\tint\t\t\tncolumns;\n\t/* number of key columns in index */\n\tint\t\t\tnkeycolumns;\n\n\t/*\n\t * table column numbers of index's columns (both key and included\n\t * columns), or 0 for expression columns\n\t */\n\tint\t\t   *indexkeys pg_node_attr(array_size(ncolumns));\n\t/* OIDs of collations of index columns */\n\tOid\t\t   *indexcollations pg_node_attr(array_size(nkeycolumns));\n\t/* OIDs of operator families for columns */\n\tOid\t\t   *opfamily pg_node_attr(array_size(nkeycolumns));\n\t/* OIDs of opclass declared input data types */\n\tOid\t\t   *opcintype pg_node_attr(array_size(nkeycolumns));\n\t/* OIDs of btree opfamilies, if orderable.  NULL if partitioned index */\n\tOid\t\t   *sortopfamily pg_node_attr(array_size(nkeycolumns));\n\t/* is sort order descending? or NULL if partitioned index */\n\tbool\t   *reverse_sort pg_node_attr(array_size(nkeycolumns));\n\t/* do NULLs come first in the sort order? or NULL if partitioned index */\n\tbool\t   *nulls_first pg_node_attr(array_size(nkeycolumns));\n\t/* opclass-specific options for columns */\n\tbytea\t  **opclassoptions pg_node_attr(read_write_ignore);\n\t/* which index cols can be returned in an index-only scan? */\n\tbool\t   *canreturn pg_node_attr(array_size(ncolumns));\n\t/* OID of the access method (in pg_am) */\n\tOid\t\t\trelam;\n\n\t/*\n\t * expressions for non-simple index columns; redundant to print since we\n\t * print indextlist\n\t */\n\tList\t   *indexprs pg_node_attr(read_write_ignore);\n\t/* predicate if a partial index, else NIL */\n\tList\t   *indpred;\n\n\t/* targetlist representing index columns */\n\tList\t   *indextlist;\n\n\t/*\n\t * parent relation's baserestrictinfo list, less any conditions implied by\n\t * the index's predicate (unless it's a target rel, see comments in\n\t * check_index_predicates())\n\t */\n\tList\t   *indrestrictinfo;\n\n\t/* true if index predicate matches query */\n\tbool\t\tpredOK;\n\t/* true if a unique index */\n\tbool\t\tunique;\n\t/* is uniqueness enforced immediately? */\n\tbool\t\timmediate;\n\t/* true if index doesn't really exist */\n\tbool\t\thypothetical;\n\n\t/*\n\t * Remaining fields are copied from the index AM's API struct\n\t * (IndexAmRoutine).  These fields are not set for partitioned indexes.\n\t */\n\tbool\t\tamcanorderbyop;\n\tbool\t\tamoptionalkey;\n\tbool\t\tamsearcharray;\n\tbool\t\tamsearchnulls;\n\t/* does AM have amgettuple interface? */\n\tbool\t\tamhasgettuple;\n\t/* does AM have amgetbitmap interface? */\n\tbool\t\tamhasgetbitmap;\n\tbool\t\tamcanparallel;\n\t/* does AM have ammarkpos interface? */\n\tbool\t\tamcanmarkpos;\n\t/* AM's cost estimator */\n\t/* Rather than include amapi.h here, we declare amcostestimate like this */\n\tvoid\t\t(*amcostestimate) () pg_node_attr(read_write_ignore);\n};",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 41,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "The add_path() function does not always add the path.\nThe details are omitted because of the complicated nature of this operation.\nFor details, refer to the comment of the add_path() function.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 42,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.2. Getting the Cheapest Access Path",
    "text": "Add the cheapest path to the pathlist of the new RelOptInfo.\n\nIn this example, the cheapest path is the index path using the index tbl_2_pkey;\nthus, its path is added to the pathlist of the new RelOptInfo.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 43,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.3. Creating a Plan Tree",
    "text": "At the last stage, the planner generates a plan tree from the cheapest path.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.166652"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 44,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.3. Creating a Plan Tree",
    "text": "The root of the plan tree is a PlannedStmt structure defined in plannodes.h.\nIt contains nineteen fields, but here are four representative fields:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.167171"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 45,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.3. Creating a Plan Tree",
    "text": "[CODE BLOCK]\ntypedef struct PlannedStmt\n{\n\tpg_node_attr(no_equal, no_query_jumble)\n\n\tNodeTag\t\ttype;\n\n\tCmdType\t\tcommandType;\t/* select|insert|update|delete|merge|utility */\n\n\tuint64\t\tqueryId;\t\t/* query identifier (copied from Query) */\n\n\tbool\t\thasReturning;\t/* is it insert|update|delete RETURNING? */\n\n\tbool\t\thasModifyingCTE;\t/* has insert|update|delete in WITH? */\n\n\tbool\t\tcanSetTag;\t\t/* do I set the command result tag? */\n\n\tbool\t\ttransientPlan;\t/* redo plan when TransactionXmin changes? */\n\n\tbool\t\tdependsOnRole;\t/* is plan specific to current role? */\n\n\tbool\t\tparallelModeNeeded; /* parallel mode required to execute? */\n\n\tint\t\t\tjitFlags;\t\t/* which forms of JIT should be performed */\n\n\tstruct Plan *planTree;\t\t/* tree of Plan nodes */\n\n\tList\t   *rtable;\t\t\t/* list of RangeTblEntry nodes */\n\n\tList\t   *permInfos;\t\t/* list of RTEPermissionInfo nodes for rtable\n\t\t\t\t\t\t\t\t * entries needing one */\n\n\t/* rtable indexes of target relations for INSERT/UPDATE/DELETE/MERGE */\n\tList\t   *resultRelations;\t/* integer list of RT indexes, or NIL */\n\n\tList\t   *appendRelations;\t/* list of AppendRelInfo nodes */\n\n\tList\t   *subplans;\t\t/* Plan trees for SubPlan expressions; note\n\t\t\t\t\t\t\t\t * that some could be NULL */\n\n\tBitmapset  *rewindPlanIDs;\t/* indices of subplans that require REWIND */\n\n\tList\t   *rowMarks;\t\t/* a list of PlanRowMark's */\n\n\tList\t   *relationOids;\t/* OIDs of relations the plan depends on */\n\n\tList\t   *invalItems;\t\t/* other dependencies, as PlanInvalItems */\n\n\tList\t   *paramExecTypes; /* type OIDs for PARAM_EXEC Params */\n\n\tNode\t   *utilityStmt;\t/* non-null if this is utility stmt */\n\n\t/* statement location in source string (copied from Query) */\n\tint\t\t\tstmt_location;\t/* start location, or -1 if unknown */\n\tint\t\t\tstmt_len;\t\t/* length in bytes; 0 means \"rest of string\" */\n} PlannedStmt;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.167171"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 46,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.3. Creating a Plan Tree",
    "text": "As mentioned above, a plan tree is composed of various plan nodes.\nThe PlanNode structure is the base node,\nand other nodes always contain it.\nFor example,\nSeqScanNode, which is for sequential scanning, is composed of a PlanNode and an integer variable ‘scanrelid’.\nA PlanNode contains fourteen fields.\nThe following are seven representative fields.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.167171"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 47,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.3. Creating a Plan Tree",
    "text": "[CODE BLOCK]\n/* ----------------\n *\t\tPlan node\n *\n * All plan nodes \"derive\" from the Plan structure by having the\n * Plan structure as the first field.  This ensures that everything works\n * when nodes are cast to Plan's.  (node pointers are frequently cast to Plan*\n * when passed around generically in the executor)\n *\n * We never actually instantiate any Plan nodes; this is just the common\n * abstract superclass for all Plan-type nodes.\n * ----------------\n */\ntypedef struct Plan\n{\n\tpg_node_attr(abstract, no_equal, no_query_jumble)\n\n\tNodeTag\t\ttype;\n\n\t/*\n\t * estimated execution costs for plan (see costsize.c for more info)\n\t */\n\tCost\t\tstartup_cost;\t/* cost expended before fetching any tuples */\n\tCost\t\ttotal_cost;\t\t/* total cost (assuming all tuples fetched) */\n\n\t/*\n\t * planner's estimate of result size of this plan step\n\t */\n\tCardinality plan_rows;\t\t/* number of rows plan is expected to emit */\n\tint\t\t\tplan_width;\t\t/* average row width in bytes */\n\n\t/*\n\t * information needed for parallel query\n\t */\n\tbool\t\tparallel_aware; /* engage parallel-aware logic? */\n\tbool\t\tparallel_safe;\t/* OK to use as part of parallel plan? */\n\n\t/*\n\t * information needed for asynchronous execution\n\t */\n\tbool\t\tasync_capable;\t/* engage asynchronous-capable logic? */\n\n\t/*\n\t * Common structural data for all Plan types.\n\t */\n\tint\t\t\tplan_node_id;\t/* unique across entire final plan tree */\n\tList\t   *targetlist;\t\t/* target list to be computed at this node */\n\tList\t   *qual;\t\t\t/* implicitly-ANDed qual conditions */\n\tstruct Plan *lefttree;\t\t/* input plan tree(s) */\n\tstruct Plan *righttree;\n\tList\t   *initPlan;\t\t/* Init Plan nodes (un-correlated expr\n\t\t\t\t\t\t\t\t * subselects) */\n\n\t/*\n\t * Information for management of parameter-change-driven rescanning\n\t *\n\t * extParam includes the paramIDs of all external PARAM_EXEC params\n\t * affecting this plan node or its children.  setParam params from the\n\t * node's initPlans are not included, but their extParams are.\n\t *\n\t * allParam includes all the extParam paramIDs, plus the IDs of local\n\t * params that affect the node (i.e., the setParams of its initplans).\n\t * These are _all_ the PARAM_EXEC params that affect this node.\n\t */\n\tBitmapset  *extParam;\n\tBitmapset  *allParam;\n} Plan;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.167171"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 48,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.3. Creating a Plan Tree",
    "text": "[CODE BLOCK]\n/*\n * ==========\n * Scan nodes\n *\n * Scan is an abstract type that all relation scan plan types inherit from.\n * ==========\n */\ntypedef struct Scan\n{\n\tpg_node_attr(abstract)\n\n\tPlan\t\tplan;\n\tIndex\t\tscanrelid;\t\t/* relid is index into the range table */\n} Scan;\n\n/* ----------------\n *\t\tsequential scan node\n * ----------------\n */\ntypedef struct SeqScan\n{\n\tScan\t\tscan;\n} SeqScan;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.167171"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 49,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.3. Creating a Plan Tree",
    "text": "In the following, two plan trees, which will be generated from the cheapest paths shown in the examples in the previous subsection, are described.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.167171"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 50,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.3. Creating a Plan Tree",
    "text": "The first example is the plan tree of the example in Section 3.3.2.1.\nThe cheapest path shown in Figure 3.11 is a tree composed of a sort path and a sequential scan path.\nThe root path is the sort path, and the child path is the sequential scan path.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.167171"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 51,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.3. Creating a Plan Tree",
    "text": "Although detailed explanations are omitted,\nit will be easy to understand that the plan tree can be almost trivially generated from the cheapest path.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.167171"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 52,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.3. Creating a Plan Tree",
    "text": "In this example,\na SortNode is added to the plantree of the PlannedStmt structure, and a SeqScanNode is added to the lefttree of the SortNode.\nSee Figure 3.15(a).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.167171"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 53,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.3. Creating a Plan Tree",
    "text": "[CODE BLOCK]\n/* ----------------\n *\t\tsort node\n * ----------------\n */\ntypedef struct Sort\n{\n\tPlan\t\tplan;\n\n\t/* number of sort-key columns */\n\tint\t\t\tnumCols;\n\n\t/* their indexes in the target list */\n\tAttrNumber *sortColIdx pg_node_attr(array_size(numCols));\n\n\t/* OIDs of operators to sort them by */\n\tOid\t\t   *sortOperators pg_node_attr(array_size(numCols));\n\n\t/* OIDs of collations */\n\tOid\t\t   *collations pg_node_attr(array_size(numCols));\n\n\t/* NULLS FIRST/LAST directions */\n\tbool\t   *nullsFirst pg_node_attr(array_size(numCols));\n} Sort;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.167171"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 54,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.3. Creating a Plan Tree",
    "text": "In the SortNode, the lefttree points to the SeqScanNode.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.167171"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 55,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.3. Creating a Plan Tree",
    "text": "In the SeqScanNode, the qual holds the WHERE clause ‘$\\text{id} \\lt 300$’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.167171"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 56,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.3. Creating a Plan Tree",
    "text": "The second example is the plan tree of the example in Section 3.3.2.2.\nThe cheapest path shown in Figure 3.14 is the index scan path,\nso the plan tree is composed of an IndexScanNode structure alone.\nSee Figure 3.15(b).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.167171"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 57,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.3. Creating a Plan Tree",
    "text": "[CODE BLOCK]\n/* ----------------\n *\t\tindex scan node\n *\n * indexqualorig is an implicitly-ANDed list of index qual expressions, each\n * in the same form it appeared in the query WHERE condition.  Each should\n * be of the form (indexkey OP comparisonval) or (comparisonval OP indexkey).\n * The indexkey is a Var or expression referencing column(s) of the index's\n * base table.  The comparisonval might be any expression, but it won't use\n * any columns of the base table.  The expressions are ordered by index\n * column position (but items referencing the same index column can appear\n * in any order).  indexqualorig is used at runtime only if we have to recheck\n * a lossy indexqual.\n *\n * indexqual has the same form, but the expressions have been commuted if\n * necessary to put the indexkeys on the left, and the indexkeys are replaced\n * by Var nodes identifying the index columns (their varno is INDEX_VAR and\n * their varattno is the index column number).\n *\n * indexorderbyorig is similarly the original form of any ORDER BY expressions\n * that are being implemented by the index, while indexorderby is modified to\n * have index column Vars on the left-hand side.  Here, multiple expressions\n * must appear in exactly the ORDER BY order, and this is not necessarily the\n * index column order.  Only the expressions are provided, not the auxiliary\n * sort-order information from the ORDER BY SortGroupClauses; it's assumed\n * that the sort ordering is fully determinable from the top-level operators.\n * indexorderbyorig is used at runtime to recheck the ordering, if the index\n * cannot calculate an accurate ordering.  It is also needed for EXPLAIN.\n *\n * indexorderbyops is a list of the OIDs of the operators used to sort the\n * ORDER BY expressions.  This is used together with indexorderbyorig to\n * recheck ordering at run time.  (Note that indexorderby, indexorderbyorig,\n * and indexorderbyops are used for amcanorderbyop cases, not amcanorder.)\n *\n * indexorderdir specifies the scan ordering, for indexscans on amcanorder\n * indexes (for other indexes it should be \"don't care\").\n * ----------------\n */\ntypedef struct Scan\n{\n\tpg_node_attr(abstract)\n\n\tPlan\t\tplan;\n\tIndex\t\tscanrelid;\t\t/* relid is index into the range table */\n} Scan;\n\ntypedef struct IndexScan\n{\n\tScan\t\tscan;\n\tOid\t\t\tindexid;\t\t/* OID of index to scan */\n\tList\t   *indexqual;\t\t/* list of index quals (usually OpExprs) */\n\tList\t   *indexqualorig;\t/* the same in original form */\n\tList\t   *indexorderby;\t/* list of index ORDER BY exprs */\n\tList\t   *indexorderbyorig;\t/* the same in original form */\n\tList\t   *indexorderbyops;\t/* OIDs of sort ops for ORDER BY exprs */\n\tScanDirection indexorderdir;\t/* forward or backward or don't care */\n} IndexScan;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.167171"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 58,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.3.3. Creating a Plan Tree",
    "text": "In this example,\nthe WHERE clause ‘$\\text{id} \\lt 240$’ is an access predicate,\nso it is stored in the indexqual of the IndexScanNode.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:07.167171"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "This section explains how the executor processes queries and how aggregate functions are handled.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.029848"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.1. How the Executor Performs",
    "text": "In single-table queries,\nthe executor takes the plan nodes in an order from the end of the plan tree to the root\nand then invokes the functions that perform the processing of the corresponding nodes.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.029848"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.1. How the Executor Performs",
    "text": "Each plan node has functions that are meant for executing the respective operation.\nThese functions are located in the src/backend/executor/ directory.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.029848"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.1. How the Executor Performs",
    "text": "For example,\nthe functions for executing the sequential scan (SeqScan) are defined in nodeSeqscan.c;\nthe functions for executing the index scan (IndexScanNode) are defined in nodeIndexscan.c;\nthe functions for sorting SortNode are defined in nodeSort.c, and so on.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.029848"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.1. How the Executor Performs",
    "text": "The best way to understand how the executor performs is to read the output of the EXPLAIN command.\nPostgreSQL’s EXPLAIN shows the plan tree almost as it is.\nIt will be explained using Example 1 in Section 3.3.3.1.",
    "tables": [
      {
        "table_index": 0,
        "content": "1\n2\n3\n4\n5\n6\n7\n8 | testdb=# EXPLAIN SELECT * FROM tbl_1 WHERE id < 300 ORDER BY data;\n                          QUERY PLAN\n---------------------------------------------------------------\n Sort  (cost=182.34..183.09 rows=300 width=8)\n   Sort Key: data\n   ->  Seq Scan on tbl_1  (cost=0.00..170.00 rows=300 width=8)\n         Filter: (id < 300)\n(4 rows)"
      }
    ],
    "extracted_at": "2025-10-03T12:32:08.029848"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.1. How the Executor Performs",
    "text": "[CODE BLOCK]\ntestdb=# EXPLAIN SELECT * FROM tbl_1 WHERE id < 300 ORDER BY data;\n                          QUERY PLAN\n---------------------------------------------------------------\n Sort  (cost=182.34..183.09 rows=300 width=8)\n   Sort Key: data\n   ->  Seq Scan on tbl_1  (cost=0.00..170.00 rows=300 width=8)\n         Filter: (id < 300)\n(4 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.029848"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.1. How the Executor Performs",
    "text": "Let’s explore how the executor performs. Read the result of the EXPLAIN command from the bottom line to the top line.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.029848"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.1. How the Executor Performs",
    "text": "Line 6: The SeqScan node, defined in nodeSeqscan.c, sequentially scans the target table and sends tuples to the SortNode.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.029848"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.1. How the Executor Performs",
    "text": "Line 4: The SortNode receives tuples one by one from the SeqScan node, stores them in the work_mem buffer, and sorts the tuples after the SeqScan is complete.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.029848"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.1. How the Executor Performs",
    "text": "Figure 3.16 illustrates how the sort processing works.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.029848"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.1. How the Executor Performs",
    "text": "From the Executor’s perspective,\nit starts a SortNode,\nruns a SeqScan within the SortNode to obtain tuples sequentially,\nand then sorts these tuples in memory (work_mem).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.029848"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.1. How the Executor Performs",
    "text": "As mentioned in Section 1.3, data tuples are stored in 8KB physical blocks.\nTo access a single data tuple, the Executor must traverse many layers, such as Buffer Manager (see Chapter 8)\nand Concurrency Control (see Chapter 5).\nFurthermore, the access method differs depending on whether the data block belongs to a table or an index.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.029848"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.1. How the Executor Performs",
    "text": "The method of accessing a single data tuple by the Executor is highly abstracted,\nand the complexity of the intermediate layers is hidden.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.029848"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.1. How the Executor Performs",
    "text": "For example,\nin the case of a sequential scan, by repeatedly calling the SeqNext() function,\nrows in a table can be accessed sequentially, taking transactions into account.\nFor an index scan, an index scan can be performed by repeatedly calling the IndexNext() function.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.029848"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.1. How the Executor Performs",
    "text": "Although the executor uses the work_men and temp_buffers, which are allocated in the memory, for query processing,\nit uses temporary files if the processing cannot be performed within the memory alone.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.029848"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.1. How the Executor Performs",
    "text": "Using the ANALYZE option, the EXPLAIN command actually executes the query\nand displays the true row counts, true run time, and the actual memory usage.\nA specific example is shown below:",
    "tables": [
      {
        "table_index": 0,
        "content": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 | testdb=# EXPLAIN ANALYZE SELECT id, data FROM tbl_25m ORDER BY id;\n                                                        QUERY PLAN\n--------------------------------------------------------------------------------------------------------------------------\n Sort  (cost=3944070.01..3945895.01 rows=730000 width=4104) (actual time=885.648..1033.746 rows=730000 loops=1)\n   Sort Key: id\n   Sort Method: external sort  Disk: 10000kB\n   ->  Seq Scan on tbl_25m  (cost=0.00..10531.00 rows=730000 width=4104) (actual time=0.024..102.548 rows=730000 loops=1)\n Planning time: 1.548 ms\n Execution time: 1109.571 ms\n(6 rows)"
      }
    ],
    "extracted_at": "2025-10-03T12:32:08.029848"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.1. How the Executor Performs",
    "text": "[CODE BLOCK]\ntestdb=# EXPLAIN ANALYZE SELECT id, data FROM tbl_25m ORDER BY id;\n                                                        QUERY PLAN\n--------------------------------------------------------------------------------------------------------------------------\n Sort  (cost=3944070.01..3945895.01 rows=730000 width=4104) (actual time=885.648..1033.746 rows=730000 loops=1)\n   Sort Key: id\n   Sort Method: external sort  Disk: 10000kB\n   ->  Seq Scan on tbl_25m  (cost=0.00..10531.00 rows=730000 width=4104) (actual time=0.024..102.548 rows=730000 loops=1)\n Planning time: 1.548 ms\n Execution time: 1109.571 ms\n(6 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.1. How the Executor Performs",
    "text": "In Line 6, the EXPLAIN command shows that the executor has used a temporary file whose size is 10000kB.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.1. How the Executor Performs",
    "text": "Temporary files are created in the base/pg_tmp subdirectory temporarily,\nand the naming method is shown follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.1. How the Executor Performs",
    "text": "[CODE BLOCK]\n{\"pgsql_tmp\"} + {PID of the postgres process which creates the file} . {sequencial number from 0}",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.1. How the Executor Performs",
    "text": "For example, the temporary file ‘pgsql_tmp8903.5’ is the 6th temporary file created by the postgres process with the pid of 8903.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.1. How the Executor Performs",
    "text": "[CODE BLOCK]\n$ ls -la /usr/local/pgsql/data/base/pgsql_tmp*\n-rw-------  1 postgres  postgres  10240000 12  4 14:18 pgsql_tmp8903.5",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "In practice, calculating aggregate functions is also an important role of the database systems.\nWe briefly explore how aggregate functions are handled, using sum, average and variance.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "[CODE BLOCK]\ntestdb=# CREATE TABLE d (x DOUBLE PRECISION);\nCREATE TABLE\ntestdb=# INSERT INTO d SELECT GENERATE_SERIES(1, 10);\nINSERT 0 10",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "For example, when the sum function is issued, the following plan tree (Figure 3.17) is created.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "[CODE BLOCK]\ntestdb=# SELECT sum(x) FROM d;\n sum\n-----\n  55\n(1 row)",
    "tables": [
      {
        "table_index": 0,
        "content": "1\n2\n3\n4\n5\n6 | testdb=# EXPLAIN SELECT sum(x) FROM d;\n                       QUERY PLAN\n--------------------------------------------------------\n Aggregate  (cost=38.25..38.26 rows=1 width=8)\n   ->  Seq Scan on d  (cost=0.00..32.60 rows=2260 width=8)\n(2 rows)"
      }
    ],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "[CODE BLOCK]\ntestdb=# EXPLAIN SELECT sum(x) FROM d;\n                       QUERY PLAN\n--------------------------------------------------------\n Aggregate  (cost=38.25..38.26 rows=1 width=8)\n   ->  Seq Scan on d  (cost=0.00..32.60 rows=2260 width=8)\n(2 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "Line 5: The SeqScan node sequentially scans the target table and sends the value of the target column (datum) to the AggregateNode.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "Line 4: The AggregateNode receives the datum from the SeqScan node and processes it according to the specified aggregate function (e.g., sum, average, variance, count, etc.).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "Figure 3.18 orverviews how the aggregate function is processed.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 31,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "In the following subsections, we will explore how aggregate functions are processed using concrete examples.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 32,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "The formulas for the sum $S_{n}$ and average $A_{n}$ are given by:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 33,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "where $x_{i}$  is the value of the target column at index $i$.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 34,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "As is evident,\nthe only difference between the sum and average is whether or not we divide by the number of elements, $n$.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 35,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "Internally, an Aggregate node accumulates the scanned values sequentially.\nWhen returning the result, it returns the sum for the sum operation, and the sum divided by $n$ for the average.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 36,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "[CODE BLOCK]\nd =[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]\n\nN = 0\nS = 0\n\n# Seq Scan\nfor x in d:\n\n    # Aggregate: Sum\n    N += 1\n    S += x\n\nprint(\"Sum=\", S)\nprint(\"Avg=\", S/N)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 37,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "[CODE BLOCK]\ntestdb=# SELECT var_samp(x) FROM d;\n     var_samp\n-------------------\n 9.166666666666666\n(1 row)\n\ntestdb=# SELECT var_pop(x) FROM d;\n var_pop\n---------\n    8.25\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 38,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "A naive implementation of the variance formula $(18)$ requires two passes over the data: one to calculate the average and another to calculate the squared differences.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 39,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "However, we can optimize this to a single-pass calculation using the following formula (For details, refer to the following ):",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 40,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "This allows us to calculate the variance in a single pass by iteratively calculating $x_{i}^{2}$ and $S_{i}$.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 41,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "[CODE BLOCK]\nd =[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]\n\nN = 0\nS = 0\nX2 = 0\n\n# SeqScan\nfor x in d:\n\n    # Aggregate: Variance\n    N += 1\n    S += x\n    X2 += x**2\n\nV = X2 - S**2/N\n\nprint(\"V=\", V)\nprint(\"Var_samp=\", V/(N-1))\nprint(\"Var_pop=\", V/N)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 42,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "A paper titled “A Closer Look at Variance ImplementationsIn Modern Database Systems” pointed out the low accuracy of PostgreSQL’s variance function in 2016.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 43,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "To address this issue, a patch was created in November 2018,\nand the Youngs and Cramer method was subsequently adopted in version 12.\nThis method offers a more accurate way to calculate variance.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 44,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "Following is the pseudocode of Youngs and Cramer method:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 45,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "[CODE BLOCK]\nd =[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]\n\nN = 0\nS = 0\nV = 0\n\n# SeqScan\nfor x in d:\n\n    # Aggregate: Variance\n    N += 1\n    S += x\n    if 1 < N:\n        V += (x * N - S)**2 / (N * (N-1))\n\nprint(\"V=\", V)\nprint(\"Var_samp=\", V/(N-1))\nprint(\"Var_pop=\", V/N)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 46,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "The Youngs and Cramer method is an improvement on the Welfold method.\nTo derive the Youngs and Cramer method, we first examine the Welfold method.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 47,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "The Welfold method for calculating variance is defined as follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 48,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.4.2. Aggregate Functions",
    "text": "The Youngs and Cramer method is a modification of the Welfold method,\nwhere the average $A_{n-1}$ is replaced by the sum $S_{n-1}$ and further optimizations are made.\nThe recurrence relation for the Youngs and Cramer method is:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.030852"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "PostgreSQL supports three join operations: nested loop join, merge join and hash join.\nThe nested loop join and the merge join in PostgreSQL have several variations.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.879090"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "In the following, we assume that the reader is familiar with the basic behavior of these three joins.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.879090"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "If you are unfamiliar with these terms, see the references:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.879090"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "Abraham Silberschatz, Henry F. Korth, and S. Sudarshan, “Database System Concepts”, McGraw-Hill Education, ISBN-13: 978-0073523323",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.879090"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "Thomas M. Connolly, and Carolyn E. Begg, “Database Systems”, Pearson, ISBN-13: 978-0321523068",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.879090"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "However, as there is not much explanation on the hybrid hash join with skew supported by PostgreSQL, it will be explained in more detail here.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.879090"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "Note that the three join methods supported by PostgreSQL can perform all join operations,\nnot only INNER JOIN, but also LEFT/RIGHT OUTER JOIN, FULL OUTER JOIN, and so on.\nHowever, for simplicity, we focus on the NATURAL INNER JOIN in this chapter.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:08.879090"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "The nested loop join is the most fundamental join operation,\nand it can be used in all join conditions.\nPostgreSQL supports the nested loop join and five variations of it.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.1. Nested Loop Join",
    "text": "The nested loop join does not need any start-up operation, so the start-up cost is 0:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.1. Nested Loop Join",
    "text": "The run cost of the nested loop join is proportional to the product of the sizes of the outer and inner tables.\nIn other words,\nthe $ \\text{‘run cost’} $ is $ O(N_{outer} \\times N_{inner})  $, where $ N_{outer} $ and $ N_{inner} $ are the numbers of tuples of the outer table and the inner table, respectively.\nMore precisely, the run cost is defined by the following equation:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.1. Nested Loop Join",
    "text": "where $ C_{outer} $ and $ C_{inner} $ are the scanning costs of the outer table and the inner table, respectively.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.1. Nested Loop Join",
    "text": "The cost of the nested loop join is always estimated, but this join operation is rarely used because more efficient variations, which are described in the following, are usually used.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.2. Materialized Nested Loop Join",
    "text": "The nested loop join described above has to scan all the tuples of the inner table whenever each tuple of the outer table is read.\nSince scanning the entire inner table for each outer table tuple is a costly process,\nPostgreSQL supports the materialized nested loop join to reduce the total scanning cost of the inner table.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.2. Materialized Nested Loop Join",
    "text": "Before running a nested loop join,\nthe executor writes the inner table tuples to the work_mem or a temporary file by scanning the inner table once\nusing the temporary tuple storage module described in  below.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.2. Materialized Nested Loop Join",
    "text": "This has the potential to process the inner table tuples more efficiently than using the buffer manager,\nespecially if at least all the tuples are written to work_mem.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.2. Materialized Nested Loop Join",
    "text": "Figure 3.20 illustrates how the materialized nested loop join performs.\nScanning materialized tuples is internally called rescan.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.2. Materialized Nested Loop Join",
    "text": "PostgreSQL internally provides a temporary tuple storage module for materializing tables, creating batches in hybrid hash join and so on.\nThis module is composed of the functions defined in tuplestore.c,\nand they store and read a sequence of tuples to/from work_mem or temporary files.\nThe decision of whether to use the work_mem or temporary files depends on the total size of the tuples to be stored.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.2. Materialized Nested Loop Join",
    "text": "We will explore how the executor processes the plan tree of the materialized nested loop join\nand how the cost is estimated using the specific example shown below.",
    "tables": [
      {
        "table_index": 0,
        "content": "1\n2\n3\n4\n5\n6\n7\n8\n9 | testdb=# EXPLAIN SELECT * FROM tbl_a AS a, tbl_b AS b WHERE a.id = b.id;\n                              QUERY PLAN\n-----------------------------------------------------------------------\n Nested Loop  (cost=0.00..750230.50 rows=5000 width=16)\n   Join Filter: (a.id = b.id)\n   ->  Seq Scan on tbl_a a  (cost=0.00..145.00 rows=10000 width=8)\n   ->  Materialize  (cost=0.00..98.00 rows=5000 width=8)\n         ->  Seq Scan on tbl_b b  (cost=0.00..73.00 rows=5000 width=8)\n(5 rows)"
      }
    ],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.2. Materialized Nested Loop Join",
    "text": "[CODE BLOCK]\ntestdb=# EXPLAIN SELECT * FROM tbl_a AS a, tbl_b AS b WHERE a.id = b.id;\n                              QUERY PLAN\n-----------------------------------------------------------------------\n Nested Loop  (cost=0.00..750230.50 rows=5000 width=16)\n   Join Filter: (a.id = b.id)\n   ->  Seq Scan on tbl_a a  (cost=0.00..145.00 rows=10000 width=8)\n   ->  Materialize  (cost=0.00..98.00 rows=5000 width=8)\n         ->  Seq Scan on tbl_b b  (cost=0.00..73.00 rows=5000 width=8)\n(5 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.2. Materialized Nested Loop Join",
    "text": "First, the operation of the executor is shown.\nThe executor processes the displayed plan nodes as follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.2. Materialized Nested Loop Join",
    "text": "In what follows, the costs of the ‘Materialize’ (Line 7) and ‘Nested Loop’ (Line 4) operations are estimated.\nAssume that the materialized inner tuples are stored in the work_mem.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.2. Materialized Nested Loop Join",
    "text": "There is no cost to start up, so the start-up cost is 0.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.2. Materialized Nested Loop Join",
    "text": "The run cost is defined by the following equation:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.2. Materialized Nested Loop Join",
    "text": "In addition,\nthe total cost is the sum of the startup cost, the total cost of the sequential scan, and the run cost:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.2. Materialized Nested Loop Join",
    "text": "There is no cost to start up, so the start-up cost is 0.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.2. Materialized Nested Loop Join",
    "text": "Before estimating the run cost, we consider the rescan cost.\nThis cost is defined by the following equation:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.2. Materialized Nested Loop Join",
    "text": "The run cost is defined by the following equation:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.2. Materialized Nested Loop Join",
    "text": "where\n$ C_{outer,seqscan}^{total} $ is the total scan cost of the outer table\nand $ C^{total}_{materialize} $ is the total cost of the materialized.\nTherefore,",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.3. Indexed Nested Loop Join",
    "text": "If there is an index on the inner table that can be used to look up the tuples satisfying the join condition for each tuple of the outer table,\nthe planner will consider using this index for directly searching the inner table tuples instead of sequential scanning.\nThis variation is called indexed nested loop join; see Figure 3.21.\nDespite the name, this algorithm can process all the tuples of the outer table in a single loop,\nso it can perform the join operation efficiently.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.3. Indexed Nested Loop Join",
    "text": "A specific example of the indexed nested loop join is shown below.",
    "tables": [
      {
        "table_index": 0,
        "content": "1\n2\n3\n4\n5\n6\n7\n8 | testdb=# EXPLAIN SELECT * FROM tbl_c AS c, tbl_b AS b WHERE c.id = b.id;\n                                   QUERY PLAN\n--------------------------------------------------------------------------------\n Nested Loop  (cost=0.29..1935.50 rows=5000 width=16)\n   ->  Seq Scan on tbl_b b (cost=0.00..73.00 rows=5000 width=8)\n   ->  Index Scan using tbl_c_pkey on tbl_c c  (cost=0.29..0.36 rows=1 width=8)\n         Index Cond: (id = b.id)\n(4 rows)"
      }
    ],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.3. Indexed Nested Loop Join",
    "text": "[CODE BLOCK]\ntestdb=# EXPLAIN SELECT * FROM tbl_c AS c, tbl_b AS b WHERE c.id = b.id;\n                                   QUERY PLAN\n--------------------------------------------------------------------------------\n Nested Loop  (cost=0.29..1935.50 rows=5000 width=16)\n   ->  Seq Scan on tbl_b b (cost=0.00..73.00 rows=5000 width=8)\n   ->  Index Scan using tbl_c_pkey on tbl_c c  (cost=0.29..0.36 rows=1 width=8)\n         Index Cond: (id = b.id)\n(4 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.3. Indexed Nested Loop Join",
    "text": "In Line 6, the cost of accessing a tuple of the inner table is displayed.\nThis is the cost of looking up the inner table if the tuple satisfies the index condition ‘$(\\text{id} = \\text{b.id})$’, which is shown in Line 7.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.3. Indexed Nested Loop Join",
    "text": "In the index condition ‘$(\\text{id} = \\text{b.id})$’ in Line 7,  ‘$\\text{b.id}$’ is the value of the outer table’s attribute used in the join condition.\nWhenever a tuple of the outer table is retrieved by sequential scanning,\nthe index scan path in Line 6 looks up the inner tuples to be joined.\nIn other words,\nwhenever the outer table is passed as a parameter,\nthis index scan path looks up the inner tuples that satisfy the join condition.\nSuch an index path is called a parameterized (index) path.\nDetails are described in README.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.747477"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.3. Indexed Nested Loop Join",
    "text": "The start-up cost of this nested loop join is equal to the cost of the index scan in Line 6; thus,",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.748481"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.3. Indexed Nested Loop Join",
    "text": "The total cost of the indexed nested loop join is defined by the following equation:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.748481"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.3. Indexed Nested Loop Join",
    "text": "where $ C^{total}_{inner,parameterized} $ is the total cost of the parameterized inner index scan.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.748481"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.3. Indexed Nested Loop Join",
    "text": "As shown above,\nthe total cost of the indexed nested loop is $ O(N_{outer}) $.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.748481"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 31,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.4. Other Variations",
    "text": "If there is an index of the outer table and its attributes are involved in the join condition,\nit can be used for index scanning instead of the sequential scan of the outer table.\nIn particular,\nif there is an index whose attribute can be used as an access predicate in the WHERE clause,\nthe search range of the outer table is narrowed.\nThis can drastically reduce the cost of the nested loop join.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.748481"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 32,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.4. Other Variations",
    "text": "PostgreSQL supports three variations of the nested loop join with an outer index scan.\nSee Figure 3.22.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.748481"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 33,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.4. Other Variations",
    "text": "The results of these joins’ EXPLAIN are shown below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.748481"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 34,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.4. Other Variations",
    "text": "[CODE BLOCK]\ntestdb=# SET enable_hashjoin TO off;\nSET\ntestdb=# SET enable_mergejoin TO off;\nSET\ntestdb=# EXPLAIN SELECT * FROM tbl_c AS c, tbl_b AS b WHERE c.id = b.id AND c.id = 500;\n                                   QUERY PLAN\n--------------------------------------------------------------------------------\n Nested Loop  (cost=0.29..93.81 rows=1 width=16)\n   ->  Index Scan using tbl_c_pkey on tbl_c c  (cost=0.29..8.30 rows=1 width=8)\n         Index Cond: (id = 500)\n   ->  Seq Scan on tbl_b b  (cost=0.00..85.50 rows=1 width=8)\n         Filter: (id = 500)\n(5 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.748481"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 35,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.4. Other Variations",
    "text": "(2) Materialized nested loop join with outer index scan",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.748481"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 36,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.4. Other Variations",
    "text": "[CODE BLOCK]\ntestdb=# SET enable_hashjoin TO off;\nSET\ntestdb=# SET enable_mergejoin TO off;\nSET\ntestdb=# EXPLAIN SELECT * FROM tbl_c AS c, tbl_b AS b WHERE c.id = b.id AND c.id < 40 AND b.id < 10;\n                                   QUERY PLAN\n---------------------------------------------------------------------------------\n Nested Loop  (cost=0.29..99.76 rows=1 width=16)\n   Join Filter: (c.id = b.id)\n   ->  Index Scan using tbl_c_pkey on tbl_c c  (cost=0.29..8.97 rows=39 width=8)\n         Index Cond: (id < 40)\n   ->  Materialize  (cost=0.00..85.55 rows=9 width=8)\n         ->  Seq Scan on tbl_b b  (cost=0.00..85.50 rows=9 width=8)\n               Filter: (id < 10)\n(7 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.748481"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 37,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.4. Other Variations",
    "text": "(3) Indexed nested loop join with outer index scan",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.748481"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 38,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.1.4. Other Variations",
    "text": "[CODE BLOCK]\ntestdb=# SET enable_hashjoin TO off;\nSET\ntestdb=# SET enable_mergejoin TO off;\nSET\ntestdb=# EXPLAIN SELECT * FROM tbl_a AS a, tbl_d AS d WHERE a.id = d.id AND a.id <  40;\n                                   QUERY PLAN\n---------------------------------------------------------------------------------\n Nested Loop  (cost=0.57..173.06 rows=20 width=16)\n   ->  Index Scan using tbl_a_pkey on tbl_a a  (cost=0.29..8.97 rows=39 width=8)\n         Index Cond: (id < 40)\n   ->  Index Scan using tbl_d_pkey on tbl_d d  (cost=0.28..4.20 rows=1 width=8)\n         Index Cond: (id = a.id)\n(5 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:09.748481"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "Unlike the nested loop join, the merge join can only be used in natural joins and equi-joins.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:10.613843"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "The cost of the merge join is estimated by the initial_cost_mergejoin() and final_cost_mergejoin() functions.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:10.613843"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "The exact cost estimation is complicated, so it is omitted here.\nInstead, we will only the runtime order of the merge join algorithm.\nThe start-up cost of the merge join is the sum of sorting costs of both inner and outer tables.\nThis means that the start-up cost is $ O(N_{outer} \\log_2(N_{outer}) + N_{inner} \\log_2(N_{inner})) $, where $ N_{outer} $ and $ N_{inner} $ are the number of tuples of the outer and inner tables, respectively.\nThe run cost is $ O(N_{outer} + N_{inner}) $.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:10.613843"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "Similar to the nested loop join,\nthe merge join in PostgreSQL has four variations.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:10.613843"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.2.1. Merge Join",
    "text": "Figure 3.23 shows a conceptual illustration of a merge join.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:10.613843"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.2.1. Merge Join",
    "text": "If all tuples can be stored in memory, the sorting operations will be able to be carried out in memory itself.\nOtherwise, temporary files will be used.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:10.613843"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.2.1. Merge Join",
    "text": "A specific example of the EXPLAIN command’s result of the merge join is shown below.",
    "tables": [
      {
        "table_index": 0,
        "content": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 | testdb=# EXPLAIN SELECT * FROM tbl_a AS a, tbl_b AS b WHERE a.id = b.id AND b.id < 1000;\n                               QUERY PLAN\n-------------------------------------------------------------------------\n Merge Join  (cost=944.71..984.71 rows=1000 width=16)\n   Merge Cond: (a.id = b.id)\n   ->  Sort  (cost=809.39..834.39 rows=10000 width=8)\n         Sort Key: a.id\n         ->  Seq Scan on tbl_a a  (cost=0.00..145.00 rows=10000 width=8)\n   ->  Sort  (cost=135.33..137.83 rows=1000 width=8)\n         Sort Key: b.id\n         ->  Seq Scan on tbl_b b  (cost=0.00..85.50 rows=1000 width=8)\n               Filter: (id < 1000)\n(9 rows)"
      }
    ],
    "extracted_at": "2025-10-03T12:32:10.613843"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.2.1. Merge Join",
    "text": "[CODE BLOCK]\ntestdb=# EXPLAIN SELECT * FROM tbl_a AS a, tbl_b AS b WHERE a.id = b.id AND b.id < 1000;\n                               QUERY PLAN\n-------------------------------------------------------------------------\n Merge Join  (cost=944.71..984.71 rows=1000 width=16)\n   Merge Cond: (a.id = b.id)\n   ->  Sort  (cost=809.39..834.39 rows=10000 width=8)\n         Sort Key: a.id\n         ->  Seq Scan on tbl_a a  (cost=0.00..145.00 rows=10000 width=8)\n   ->  Sort  (cost=135.33..137.83 rows=1000 width=8)\n         Sort Key: b.id\n         ->  Seq Scan on tbl_b b  (cost=0.00..85.50 rows=1000 width=8)\n               Filter: (id < 1000)\n(9 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:10.614842"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.2.2. Materialized Merge Join",
    "text": "Same as in the nested loop join,\nthe merge join also supports the materialized merge join to materialize the inner table to make the inner table scan more efficient.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:10.614842"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.2.2. Materialized Merge Join",
    "text": "An example of the result of the materialized merge join is shown.\nIt is easy to see that the difference from the merge join result above is Line 9: ‘Materialize’.",
    "tables": [
      {
        "table_index": 0,
        "content": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13 | testdb=# EXPLAIN SELECT * FROM tbl_a AS a, tbl_b AS b WHERE a.id = b.id;\n                                    QUERY PLAN\n-----------------------------------------------------------------------------------\n Merge Join  (cost=10466.08..10578.58 rows=5000 width=2064)\n   Merge Cond: (a.id = b.id)\n   ->  Sort  (cost=6708.39..6733.39 rows=10000 width=1032)\n         Sort Key: a.id\n         ->  Seq Scan on tbl_a a  (cost=0.00..1529.00 rows=10000 width=1032)\n   ->  Materialize  (cost=3757.69..3782.69 rows=5000 width=1032)\n         ->  Sort  (cost=3757.69..3770.19 rows=5000 width=1032)\n               Sort Key: b.id\n               ->  Seq Scan on tbl_b b  (cost=0.00..1193.00 rows=5000 width=1032)\n(9 rows)"
      }
    ],
    "extracted_at": "2025-10-03T12:32:10.614842"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.2.2. Materialized Merge Join",
    "text": "[CODE BLOCK]\ntestdb=# EXPLAIN SELECT * FROM tbl_a AS a, tbl_b AS b WHERE a.id = b.id;\n                                    QUERY PLAN\n-----------------------------------------------------------------------------------\n Merge Join  (cost=10466.08..10578.58 rows=5000 width=2064)\n   Merge Cond: (a.id = b.id)\n   ->  Sort  (cost=6708.39..6733.39 rows=10000 width=1032)\n         Sort Key: a.id\n         ->  Seq Scan on tbl_a a  (cost=0.00..1529.00 rows=10000 width=1032)\n   ->  Materialize  (cost=3757.69..3782.69 rows=5000 width=1032)\n         ->  Sort  (cost=3757.69..3770.19 rows=5000 width=1032)\n               Sort Key: b.id\n               ->  Seq Scan on tbl_b b  (cost=0.00..1193.00 rows=5000 width=1032)\n(9 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:10.614842"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.2.3. Other Variations",
    "text": "Similar to the nested loop join,\nthe merge join in PostgreSQL also has variations based on which the index scanning of the outer table can be carried out.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:10.614842"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.2.3. Other Variations",
    "text": "The results of these joins’ EXPLAIN are shown below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:10.614842"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.2.3. Other Variations",
    "text": "[CODE BLOCK]\ntestdb=# SET enable_hashjoin TO off;\nSET\ntestdb=# SET enable_nestloop TO off;\nSET\ntestdb=# EXPLAIN SELECT * FROM tbl_c AS c, tbl_b AS b WHERE c.id = b.id AND b.id < 1000;\n                                      QUERY PLAN\n--------------------------------------------------------------------------------------\n Merge Join  (cost=135.61..322.11 rows=1000 width=16)\n   Merge Cond: (c.id = b.id)\n   ->  Index Scan using tbl_c_pkey on tbl_c c  (cost=0.29..318.29 rows=10000 width=8)\n   ->  Sort  (cost=135.33..137.83 rows=1000 width=8)\n         Sort Key: b.id\n         ->  Seq Scan on tbl_b b  (cost=0.00..85.50 rows=1000 width=8)\n               Filter: (id < 1000)\n(7 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:10.614842"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.2.3. Other Variations",
    "text": "[CODE BLOCK]\ntestdb=# SET enable_hashjoin TO off;\nSET\ntestdb=# SET enable_nestloop TO off;\nSET\ntestdb=# EXPLAIN SELECT * FROM tbl_c AS c, tbl_b AS b WHERE c.id = b.id AND b.id < 4500;\n                                      QUERY PLAN\n--------------------------------------------------------------------------------------\n Merge Join  (cost=421.84..672.09 rows=4500 width=16)\n   Merge Cond: (c.id = b.id)\n   ->  Index Scan using tbl_c_pkey on tbl_c c  (cost=0.29..318.29 rows=10000 width=8)\n   ->  Materialize  (cost=421.55..444.05 rows=4500 width=8)\n         ->  Sort  (cost=421.55..432.80 rows=4500 width=8)\n               Sort Key: b.id\n               ->  Seq Scan on tbl_b b  (cost=0.00..85.50 rows=4500 width=8)\n                     Filter: (id < 4500)\n(8 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:10.614842"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.2.3. Other Variations",
    "text": "[CODE BLOCK]\ntestdb=# SET enable_hashjoin TO off;\nSET\ntestdb=# SET enable_nestloop TO off;\nSET\ntestdb=# EXPLAIN SELECT * FROM tbl_c AS c, tbl_d AS d WHERE c.id = d.id AND d.id < 1000;\n                                      QUERY PLAN\n--------------------------------------------------------------------------------------\n Merge Join  (cost=0.57..226.07 rows=1000 width=16)\n   Merge Cond: (c.id = d.id)\n   ->  Index Scan using tbl_c_pkey on tbl_c c  (cost=0.29..318.29 rows=10000 width=8)\n   ->  Index Scan using tbl_d_pkey on tbl_d d  (cost=0.28..41.78 rows=1000 width=8)\n         Index Cond: (id < 1000)\n(5 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:10.615846"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "Similar to the merge join, the hash join can be only used in natural joins and equi-joins.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "The hash join in PostgreSQL behaves differently depending on the sizes of the tables.\nIf the target table is small enough (more precisely, the size of the inner table is 25% or less of the work_mem),\nit will be a simple two-phase in-memory hash join.\nOtherwise, the hybrid hash join is used with the skew method.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "In this subsection, the execution of both hash joins in PostgreSQL is described.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "Discussion of the cost estimation has been omitted because it is complicated.\nRoughly speaking, the start-up and run costs are $ O(N_{outer} + N_{inner}) $ if assuming there is no conflict when searching and inserting into a hash table.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.1. In-Memory Hash Join",
    "text": "In this subsection, the in-memory hash join is described.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.1. In-Memory Hash Join",
    "text": "This in-memory hash join is processed in the work_mem,\nand the hash table area is called a batch in PostgreSQL.\nA batch has hash slots, internally called buckets,\nand the number of buckets is determined by the ExecChooseHashTableSize() function defined in nodeHash.c; the number of buckets is always $ 2^{n} $, where $ n $ is an integer.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.1. In-Memory Hash Join",
    "text": "The in-memory hash join has two phases: the build and the probe phases.\nIn the build phase,\nall tuples of the inner table are inserted into a batch;\nin the probe phase,\neach tuple of the outer table is compared with the inner tuples in the batch and joined if the join condition is satisfied.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.1. In-Memory Hash Join",
    "text": "A specific example is shown to clearly understand this operation.\nAssume that the query shown below is executed using a hash join.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.1. In-Memory Hash Join",
    "text": "[CODE BLOCK]\ntestdb=# SELECT * FROM tbl_outer AS outer, tbl_inner AS inner WHERE inner.attr1 = outer.attr2;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.1. In-Memory Hash Join",
    "text": "In the following, the operation of a hash join is shown.\nRefer to Figures 3.26 and 3.27.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.1. In-Memory Hash Join",
    "text": "(1) Create a batch on work_mem.\nIn this example, the batch has 8 buckets, which means the number of buckets is $ 2^{3} $.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.1. In-Memory Hash Join",
    "text": "(2) Insert the first tuple of the inner table into the corresponding bucket of the batch. \nThe details are as follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.1. In-Memory Hash Join",
    "text": "Calculate the hash-key of the first tuple’s attribute that is involved in the join condition.\nIn this example,\nthe hash-key of the attribute ‘attr1’ of the first tuple is calculated using the built-in hash function\nbecause the WHERE clause is ‘inner.attr1 = outer.attr2’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.1. In-Memory Hash Join",
    "text": "Insert the first tuple into the corresponding bucket.\nAssume that the hash-key of the first tuple is ‘0x000â¦001’ by binary notatio, which means the last three bits are ‘001’.\nIn this case, this tuple is inserted into the bucket whose key is ‘001’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.1. In-Memory Hash Join",
    "text": "In this document, this insertion operation to build a batch is represented by this operator: $ \\oplus $",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.1. In-Memory Hash Join",
    "text": "(4) Probe the first tuple of the outer table.\nThe details are as follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.1. In-Memory Hash Join",
    "text": "(5) Probe the remaining tuples of the outer table.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.2. Hybrid Hash Join with Skew",
    "text": "When the tuples of the inner table cannot be stored in one batch in work_mem,\nPostgreSQL uses the hybrid hash join with the skew algorithm, which is a variation based on the hybrid hash join.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.2. Hybrid Hash Join with Skew",
    "text": "First, the basic concept of the hybrid hash join is described.\nIn the first build and probe phases, PostgreSQL prepares multiple batches.\nThe number of batches is the same as the number of buckets, determined by the ExecChooseHashTableSize() function.\nIt is always $ 2^{m} $, where $ m $ is an integer.\nAt this stage, only one batch is allocated in work_mem, and the other batches are created as temporary files.\nThe tuples belonging to these batches are written to the corresponding files and saved using the temporary tuple storage feature.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.2. Hybrid Hash Join with Skew",
    "text": "Figure 3.28 illustrates how tuples are stored in four (= $ 2^{2} $) batches.\nIn this case,\nwhich batch stores each tuple is determined by the first two bits of the last 5 bits of the tuple’s hash-key,\nbecause the sizes of the buckets and batches are $ 2^{3} $ and $ 2^{2} $, respectively.\nBatch_0 stores the tuples whose last 5 bits of the hash-key are between ‘00000’ and ‘00111’,\nBatch_1 stores the tuples whose last 5 bits of the hash-key are between ‘01000’ and ‘01111’ and so on.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.2. Hybrid Hash Join with Skew",
    "text": "In the hybrid hash join, the build and probe phases are performed the same number of times as the number of batches, because the inner and outer tables are stored in the same number of batches.\nIn the first round of the build and probe phases, not only is every batch created, but also the first batches of both the inner and the outer tables are processed.\nOn the other hand, the processing of the second and subsequent rounds needs writing and reloading to/from the temporary files, so these are costly processes.\nTherefore, PostgreSQL also prepares a special batch called skew to process many tuples more efficiently in the first round.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.2. Hybrid Hash Join with Skew",
    "text": "The skew batch stores the inner table tuples that will be joined with the outer table tuples whose MCV values of the attribute involved in the join condition are relatively large.\nHowever, this explanation may not be easy to understand, so it will be explained using a specific example.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.2. Hybrid Hash Join with Skew",
    "text": "Assume that there are two tables: customers and purchase_history.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.2. Hybrid Hash Join with Skew",
    "text": "Under these assumptions,\nlet us consider how the hybrid hash join with skew performs in the first round when the query shown below is executed.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.2. Hybrid Hash Join with Skew",
    "text": "[CODE BLOCK]\ntestdb=# SELECT * FROM customers AS c, purchase_history AS h WHERE c.name = h.customer_name;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.2. Hybrid Hash Join with Skew",
    "text": "If the customers’ table is inner and the purchase_history is outer,\nthe top 10% of customers are stored in the skew batch using the MCV values of the purchase_history table.\nNote that the outer table’s MCV values are referenced to insert the inner table tuples into the skew batch.\nIn the probe phase of the first round,\n70% of the tuples of the outer table (purchase_history) will be joined with the tuples stored in the skew batch.\nThis way, the more non-uniform the distribution of the outer table,\nthe more tuples of the outer table can be processed in the first round.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.2. Hybrid Hash Join with Skew",
    "text": "In the following, the working of the hybrid hash join with skew is shown. Refer to Figures 3.29 to 3.32.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.2. Hybrid Hash Join with Skew",
    "text": "(2) Create temporary batch files for storing the inner table tuples.\nIn this example, three batch files are created\nbecause the inner table will be divided into four batches.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.2. Hybrid Hash Join with Skew",
    "text": "(3) Perform the build operation for the first tuple of the inner table.\nThe detail are described below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.2. Hybrid Hash Join with Skew",
    "text": "(4) Perform the build operation for the remaining tuples of the inner table.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 31,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.2. Hybrid Hash Join with Skew",
    "text": "(5) Create temporary batch files for storing the outer table tuples.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 32,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.2. Hybrid Hash Join with Skew",
    "text": "(6) If the MCV value of the first tuple is large, perform a probe operation with the skew batch. Otherwise, proceed to (7).\nIn the example explained above,\nif the first tuple is the purchase data of the top 10% customers,\nit is compared with the tuples in the skew batch.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 33,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.2. Hybrid Hash Join with Skew",
    "text": "(7) Perform the probe operation of the first tuple.\nDepending on the hash-key value of the first tuple, the following process is performed:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 34,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.2. Hybrid Hash Join with Skew",
    "text": "(8) Perform the probe operation from the remaining tuples of the outer table.\nNote that, in this example, 70% of the tuples of the outer table have been processed by the skew in the first round without writing and reading to/from temporary files.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 35,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.2. Hybrid Hash Join with Skew",
    "text": "(9) Remove the skew batch and clear Batch_0 to prepare the second round.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 36,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.2. Hybrid Hash Join with Skew",
    "text": "(10) Perform the build operation from the batch file ‘batch_1_in’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.470573"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 37,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.2. Hybrid Hash Join with Skew",
    "text": "(11) Perform the probe operation for tuples which are stored in the batch file ‘batch_1_out’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.471577"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 38,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.2. Hybrid Hash Join with Skew",
    "text": "(12) Perform build and probe operations using batch files ‘batch_2_in’ and ‘batch_2_out’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.471577"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 39,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.2. Hybrid Hash Join with Skew",
    "text": "(13) Perform build and probe operations using batch files ‘batch_3_in’ and ‘batch_3_out’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.471577"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 40,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.3. Index Scans in Hash Join",
    "text": "Hash join in PostgreSQL uses index scans if possible.\nA specific example is shown below.",
    "tables": [
      {
        "table_index": 0,
        "content": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 | testdb=# EXPLAIN SELECT * FROM pgbench_accounts AS a, pgbench_branches AS b\ntestdb-#                                              WHERE a.bid = b.bid AND a.aid BETWEEN 100 AND 1000;\n                                                QUERY PLAN\n----------------------------------------------------------------------------------------------------------\n Hash Join  (cost=1.88..51.93 rows=865 width=461)\n   Hash Cond: (a.bid = b.bid)\n   ->  Index Scan using pgbench_accounts_pkey on pgbench_accounts a  (cost=0.43..47.73 rows=865 width=97)\n         Index Cond: ((aid >= 100) AND (aid <= 1000))\n   ->  Hash  (cost=1.20..1.20 rows=20 width=364)\n         ->  Seq Scan on pgbench_branches b  (cost=0.00..1.20 rows=20 width=364)\n(6 rows)"
      }
    ],
    "extracted_at": "2025-10-03T12:32:11.471577"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 41,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.3.3. Index Scans in Hash Join",
    "text": "[CODE BLOCK]\ntestdb=# EXPLAIN SELECT * FROM pgbench_accounts AS a, pgbench_branches AS b\ntestdb-#                                              WHERE a.bid = b.bid AND a.aid BETWEEN 100 AND 1000;\n                                                QUERY PLAN\n----------------------------------------------------------------------------------------------------------\n Hash Join  (cost=1.88..51.93 rows=865 width=461)\n   Hash Cond: (a.bid = b.bid)\n   ->  Index Scan using pgbench_accounts_pkey on pgbench_accounts a  (cost=0.43..47.73 rows=865 width=97)\n         Index Cond: ((aid >= 100) AND (aid <= 1000))\n   ->  Hash  (cost=1.20..1.20 rows=20 width=364)\n         ->  Seq Scan on pgbench_branches b  (cost=0.00..1.20 rows=20 width=364)\n(6 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:11.471577"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.4.1. Join Access Paths",
    "text": "The JoinPath structure is an access path for the nested loop join.\nOther join access paths, such as MergePath and HashPath,\nare based on it.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:12.334886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.4.1. Join Access Paths",
    "text": "All join access paths are illustrated below, without explanation.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:12.334886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.4.1. Join Access Paths",
    "text": "[CODE BLOCK]\ntypedef JoinPath NestPath;\n\n/*\n * JoinType -\n *\t  enums for types of relation joins\n *\n * JoinType determines the exact semantics of joining two relations using\n * a matching qualification.  For example, it tells what to do with a tuple\n * that has no match in the other relation.\n *\n * This is needed in both parsenodes.h and plannodes.h, so put it here...\n */\ntypedef enum JoinType\n{\n\t/*\n\t * The canonical kinds of joins according to the SQL JOIN syntax. Only\n\t * these codes can appear in parser output (e.g., JoinExpr nodes).\n\t */\n\tJOIN_INNER,\t\t\t\t\t/* matching tuple pairs only */\n\tJOIN_LEFT,\t\t\t\t\t/* pairs + unmatched LHS tuples */\n\tJOIN_FULL,\t\t\t\t\t/* pairs + unmatched LHS + unmatched RHS */\n\tJOIN_RIGHT,\t\t\t\t\t/* pairs + unmatched RHS tuples */\n\n\t/*\n\t * Semijoins and anti-semijoins (as defined in relational theory) do not\n\t * appear in the SQL JOIN syntax, but there are standard idioms for\n\t * representing them (e.g., using EXISTS).  The planner recognizes these\n\t * cases and converts them to joins.  So the planner and executor must\n\t * support these codes.  NOTE: in JOIN_SEMI output, it is unspecified\n\t * which matching RHS row is joined to.  In JOIN_ANTI output, the row is\n\t * guaranteed to be null-extended.\n\t */\n\tJOIN_SEMI,\t\t\t\t\t/* 1 copy of each LHS row that has match(es) */\n\tJOIN_ANTI,\t\t\t\t\t/* 1 copy of each LHS row that has no match */\n\tJOIN_RIGHT_ANTI,\t\t\t/* 1 copy of each RHS row that has no match */\n\n\t/*\n\t * These codes are used internally in the planner, but are not supported\n\t * by the executor (nor, indeed, by most of the planner).\n\t */\n\tJOIN_UNIQUE_OUTER,\t\t\t/* LHS path must be made unique */\n\tJOIN_UNIQUE_INNER\t\t\t/* RHS path must be made unique */\n\n\t/*\n\t * We might need additional join types someday.\n\t */\n} JoinType;\n\n/*\n * All join-type paths share these fields.\n */\n\ntypedef struct JoinPath\n{\n\tpg_node_attr(abstract)\n\n\tPath\t\tpath;\n\n\tJoinType\tjointype;\n\n\tbool\t\tinner_unique;\t/* each outer tuple provably matches no more\n\t\t\t\t\t\t\t\t * than one inner tuple */\n\n\tPath\t   *outerjoinpath;\t/* path for the outer side of the join */\n\tPath\t   *innerjoinpath;\t/* path for the inner side of the join */\n\n\tList\t   *joinrestrictinfo;\t/* RestrictInfos to apply to join */\n\n\t/*\n\t * See the notes for RelOptInfo and ParamPathInfo to understand why\n\t * joinrestrictinfo is needed in JoinPath, and can't be merged into the\n\t * parent RelOptInfo.\n\t */\n} JoinPath;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:12.334886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.4.1. Join Access Paths",
    "text": "[CODE BLOCK]\n/*\n * A mergejoin path has these fields.\n *\n * Unlike other path types, a MergePath node doesn't represent just a single\n * run-time plan node: it can represent up to four.  Aside from the MergeJoin\n * node itself, there can be a Sort node for the outer input, a Sort node\n * for the inner input, and/or a Material node for the inner input.  We could\n * represent these nodes by separate path nodes, but considering how many\n * different merge paths are investigated during a complex join problem,\n * it seems better to avoid unnecessary palloc overhead.\n *\n * path_mergeclauses lists the clauses (in the form of RestrictInfos)\n * that will be used in the merge.\n *\n * Note that the mergeclauses are a subset of the parent relation's\n * restriction-clause list.  Any join clauses that are not mergejoinable\n * appear only in the parent's restrict list, and must be checked by a\n * qpqual at execution time.\n *\n * outersortkeys (resp. innersortkeys) is NIL if the outer path\n * (resp. inner path) is already ordered appropriately for the\n * mergejoin.  If it is not NIL then it is a PathKeys list describing\n * the ordering that must be created by an explicit Sort node.\n *\n * skip_mark_restore is true if the executor need not do mark/restore calls.\n * Mark/restore overhead is usually required, but can be skipped if we know\n * that the executor need find only one match per outer tuple, and that the\n * mergeclauses are sufficient to identify a match.  In such cases the\n * executor can immediately advance the outer relation after processing a\n * match, and therefore it need never back up the inner relation.\n *\n * materialize_inner is true if a Material node should be placed atop the\n * inner input.  This may appear with or without an inner Sort step.\n */\n\ntypedef struct MergePath\n{\n\tJoinPath\tjpath;\n\tList\t   *path_mergeclauses;\t/* join clauses to be used for merge */\n\tList\t   *outersortkeys;\t/* keys for explicit sort, if any */\n\tList\t   *innersortkeys;\t/* keys for explicit sort, if any */\n\tbool\t\tskip_mark_restore;\t/* can executor skip mark/restore? */\n\tbool\t\tmaterialize_inner;\t/* add Materialize to inner? */\n} MergePath;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:12.334886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.4.1. Join Access Paths",
    "text": "[CODE BLOCK]\n/*\n * A hashjoin path has these fields.\n *\n * The remarks above for mergeclauses apply for hashclauses as well.\n *\n * Hashjoin does not care what order its inputs appear in, so we have\n * no need for sortkeys.\n */\n\ntypedef struct HashPath\n{\n\tJoinPath\tjpath;\n\tList\t   \t*path_hashclauses;\t/* join clauses used for hashing */\n\tint\t\tnum_batches;\t\t/* number of batches expected */\n\tCardinality \tinner_rows_total;\t/* total inner rows expected */\n} HashPath;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:12.334886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.4.2. Join Nodes",
    "text": "This subsection shows the three join nodes: NestedLoopNode, MergeJoinNode and HashJoinNode, without explanation.\nThey are all based on the JoinNode.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:12.334886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.4.2. Join Nodes",
    "text": "[CODE BLOCK]\n/* ----------------\n *\t\tJoin node\n *\n * jointype:\trule for joining tuples from left and right subtrees\n * inner_unique each outer tuple can match to no more than one inner tuple\n * joinqual:\tqual conditions that came from JOIN/ON or JOIN/USING\n *\t\t\t\t(plan.qual contains conditions that came from WHERE)\n *\n * When jointype is INNER, joinqual and plan.qual are semantically\n * interchangeable.  For OUTER jointypes, the two are *not* interchangeable;\n * only joinqual is used to determine whether a match has been found for\n * the purpose of deciding whether to generate null-extended tuples.\n * (But plan.qual is still applied before actually returning a tuple.)\n * For an outer join, only joinquals are allowed to be used as the merge\n * or hash condition of a merge or hash join.\n *\n * inner_unique is set if the joinquals are such that no more than one inner\n * tuple could match any given outer tuple.  This allows the executor to\n * skip searching for additional matches.  (This must be provable from just\n * the joinquals, ignoring plan.qual, due to where the executor tests it.)\n * ----------------\n */\ntypedef struct Join\n{\n\tpg_node_attr(abstract)\n\n\tPlan\t\tplan;\n\tJoinType\tjointype;\n\tbool\t\tinner_unique;\n\tList\t   *joinqual;\t\t/* JOIN quals (in addition to plan.qual) */\n} Join;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:12.334886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.4.2. Join Nodes",
    "text": "[CODE BLOCK]\n/* ----------------\n *\t\tnest loop join node\n *\n * The nestParams list identifies any executor Params that must be passed\n * into execution of the inner subplan carrying values from the current row\n * of the outer subplan.  Currently we restrict these values to be simple\n * Vars, but perhaps someday that'd be worth relaxing.  (Note: during plan\n * creation, the paramval can actually be a PlaceHolderVar expression; but it\n * must be a Var with varno OUTER_VAR by the time it gets to the executor.)\n * ----------------\n */\ntypedef struct NestLoop\n{\n\tJoin\t\tjoin;\n\tList\t   *nestParams;\t\t/* list of NestLoopParam nodes */\n} NestLoop;\n\ntypedef struct NestLoopParam\n{\n\tpg_node_attr(no_equal, no_query_jumble)\n\n\tNodeTag\t\ttype;\n\tint\t\t\tparamno;\t\t/* number of the PARAM_EXEC Param to set */\n\tVar\t\t   *paramval;\t\t/* outer-relation Var to assign to Param */\n} NestLoopParam;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:12.334886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.4.2. Join Nodes",
    "text": "[CODE BLOCK]\n/* ----------------\n *\t\tmerge join node\n *\n * The expected ordering of each mergeable column is described by a btree\n * opfamily OID, a collation OID, a direction (BTLessStrategyNumber or\n * BTGreaterStrategyNumber) and a nulls-first flag.  Note that the two sides\n * of each mergeclause may be of different datatypes, but they are ordered the\n * same way according to the common opfamily and collation.  The operator in\n * each mergeclause must be an equality operator of the indicated opfamily.\n * ----------------\n */\ntypedef struct MergeJoin\n{\n\tJoin\t\tjoin;\n\n\t/* Can we skip mark/restore calls? */\n\tbool\t\tskip_mark_restore;\n\n\t/* mergeclauses as expression trees */\n\tList\t   *mergeclauses;\n\n\t/* these are arrays, but have the same length as the mergeclauses list: */\n\n\t/* per-clause OIDs of btree opfamilies */\n\tOid\t\t   *mergeFamilies pg_node_attr(array_size(mergeclauses));\n\n\t/* per-clause OIDs of collations */\n\tOid\t\t   *mergeCollations pg_node_attr(array_size(mergeclauses));\n\n\t/* per-clause ordering (ASC or DESC) */\n\tint\t\t   *mergeStrategies pg_node_attr(array_size(mergeclauses));\n\n\t/* per-clause nulls ordering */\n\tbool\t   *mergeNullsFirst pg_node_attr(array_size(mergeclauses));\n} MergeJoin;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:12.334886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/05/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.5.4.2. Join Nodes",
    "text": "[CODE BLOCK]\n/* ----------------\n *\t\thash join node\n * ----------------\n */\ntypedef struct HashJoin\n{\n\tJoin\t\tjoin;\n\tList\t   *hashclauses;\n\tList\t   *hashoperators;\n\tList\t   *hashcollations;\n\n\t/*\n\t * List of expressions to be hashed for tuples from the outer plan, to\n\t * perform lookups in the hashtable over the inner plan.\n\t */\n\tList\t   *hashkeys;\n} HashJoin;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:12.334886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "In this section, the process of creating a plan tree of a multiple-table query is explained.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.1. Preprocessing",
    "text": "The subquery_planner() function defined in planner.c invokes preprocessing.\nThe preprocessing for single-table queries has already been described in Section 3.3.1.\nIn this subsection, the preprocessing for a multiple-table query will be described.\nHowever, only some parts will be described, as there are many.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.1. Preprocessing",
    "text": "Planning and Converting CTE\nIf there are WITH lists, the planner processes each WITH query by the SS_process_ctes() function.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.1. Preprocessing",
    "text": "Pulling Subqueries Up\nIf the FROM clause has a subquery and it does not have GROUP BY, HAVING, ORDER BY, LIMIT or DISTINCT clauses, and also it does not use INTERSECT or EXCEPT,\nthe planner converts to a join form by the pull_up_subqueries() function.\nFor example, the query shown below which contains a subquery in the FROM clause can be converted to a natural join query.\nNeedless to say, this conversion is done in the query tree.\ntestdb=# SELECT * FROM tbl_a AS a, (SELECT * FROM tbl_b) as b WHERE a.id = b.id;\n$$\n\\Downarrow\n$$\ntestdb=# SELECT * FROM tbl_a AS a, tbl_b as b WHERE a.id = b.id;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.1. Preprocessing",
    "text": "[CODE BLOCK]\ntestdb=# SELECT * FROM tbl_a AS a, (SELECT * FROM tbl_b) as b WHERE a.id = b.id;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.1. Preprocessing",
    "text": "[CODE BLOCK]\ntestdb=# SELECT * FROM tbl_a AS a, tbl_b as b WHERE a.id = b.id;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.1. Preprocessing",
    "text": "Transforming an Outer Join to an Inner Join\nThe planner transforms an outer join query to an inner join query if possible.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.2. Getting the Cheapest Path",
    "text": "To get the optimal plan tree, the planner has to consider all the combinations of indexes and join methods.\nThis is a very expensive process and it will be infeasible if the number of tables exceeds a certain level due to a combinatorial explosion.\nFortunately, if the number of tables is smaller than around 12, the planner can get the optimal plan by applying dynamic programming.\nOtherwise, the planner uses the genetic algorithm. Refer to the  below.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.2. Getting the Cheapest Path",
    "text": "When a query joining many tables is executed, a huge amount of time will be needed to optimize the query plan.\nTo deal with this situation, PostgreSQL implements an interesting feature:\nthe Genetic Query Optimizer.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.2. Getting the Cheapest Path",
    "text": "This is a kind of approximate algorithm to determine a reasonable plan within a reasonable time.\nHence, in the query optimization stage,\nif the number of the joining tables is higher than the threshold specified by the parameter geqo_threshold (the default is 12), PostgreSQL generates a query plan using the genetic algorithm.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.2. Getting the Cheapest Path",
    "text": "Determination of the optimal plan tree by dynamic programming can be explained by the following steps:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.2. Getting the Cheapest Path",
    "text": "Level = 1\nGet the cheapest path for each table. The cheapest path is stored in the respective RelOptInfo.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.2. Getting the Cheapest Path",
    "text": "Level = 2\nGet the cheapest path for each combination of two tables.\nFor example, if there are two tables, A and B, get the cheapest join path of tables A and B. This is the final answer.\nIn the following, the RelOptInfo of two tables is represented by {A, B}.\nIf there are three tables, get the cheapest path for each of {A, B}, {A, C}, and {B, C}.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.2. Getting the Cheapest Path",
    "text": "Level = 3 and higher\nContinue the same process until the level that equals the number of tables is reached.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.2. Getting the Cheapest Path",
    "text": "This way, the cheapest paths of the partial problems are obtained at each level and are used to get the upper level’s calculation.\nThis makes it possible to calculate the cheapest plan tree efficiently.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.2. Getting the Cheapest Path",
    "text": "In the following, the process of how the planner gets the cheapest plan of the following query is described.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.2. Getting the Cheapest Path",
    "text": "[CODE BLOCK]\ntestdb=# \\d tbl_a\n     Table \"public.tbl_a\"\n Column |  Type   | Modifiers\n--------+---------+-----------\n id     | integer | not null\n data   | integer |\nIndexes:\n    \"tbl_a_pkey\" PRIMARY KEY, btree (id)\n\ntestdb=# \\d tbl_b\n     Table \"public.tbl_b\"\n Column |  Type   | Modifiers\n--------+---------+-----------\n id     | integer |\n data   | integer |\n\ntestdb=# SELECT * FROM tbl_a AS a, tbl_b AS b WHERE a.id = b.id AND b.data < 400;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.2. Getting the Cheapest Path",
    "text": "In Level 1,\nthe planner creates a RelOptInfo structure and estimates the cheapest costs for each relation in the query.\nThe RelOptInfo structures are added to the simple_rel_array of the PlannerInfo of this query.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.2. Getting the Cheapest Path",
    "text": "The RelOptInfo of tbl_a has three access paths, which are added to the pathlist of the RelOptInfo.\nEach access path is linked to a cheapest cost path: the cheapest start-up (cost) path,\nthe cheapest total (cost) path,\nand the cheapest parameterized (cost) path.\nThe cheapest start-up and total cost paths are obvious,\nso the cost of the cheapest parameterized index scan path will be described.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.2. Getting the Cheapest Path",
    "text": "As described in Section 3.5.1.3, the planner considers the use of the parameterized path for the indexed nested loop join (and rarely the indexed merge join with an outer index scan).\nThe cheapest parameterized cost is the cheapest cost of the estimated parameterized paths.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.2. Getting the Cheapest Path",
    "text": "The RelOptInfo of tbl_b only has a sequential scan access path because tbl_b does not have a related index.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.2. Getting the Cheapest Path",
    "text": "In level 2, a RelOptInfo structure is created and added to the join_rel_list of the PlannerInfo.\nThen, the costs of all possible join paths are estimated, and the best access path, whose total cost is the cheapest, is selected.\nThe RelOptInfo stores the best access path as the cheapest total cost path.\nSee Figure 3.36.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.2. Getting the Cheapest Path",
    "text": "Table 3.1 shows all combinations of join access paths in this example.\nThe query of this example is an equi-join type, so all three join methods are estimated.\nFor convenience, some notations of access paths are introduced:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.2. Getting the Cheapest Path",
    "text": "SeqScanPath(table) means the sequential scan path of table.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.2. Getting the Cheapest Path",
    "text": "Materialized->SeqScanPath(table) means the materialized sequential scan path of a table.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.2. Getting the Cheapest Path",
    "text": "IndexScanPath(table, attribute) means the index scan path by the attribute of the a table.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.2. Getting the Cheapest Path",
    "text": "ParameterizedIndexScanPath(table, attribute1, attribute2) means the parameterized index path by the attribute1 of the table, and it is parameterized by attribute2 of the outer table.",
    "tables": [
      {
        "table_index": 0,
        "content": " | Outer Path | Inner Path | \nNested Loop Join\n2 | SeqScanPath(tbl_a) | Materialized->SeqScanPath(tbl_b) | Materialized nested loop join\n3 | IndexScanPath(tbl_a,id) | SeqScanPath(tbl_b) | Nested loop join with outer index scan\n4 | IndexScanPath(tbl_a,id) | Materialized->SeqScanPath(tbl_b) | Materialized nested loop join with outer index scan\n5 | SeqScanPath(tbl_b) | SeqScanPath(tbl_a) | \n6 | SeqScanPath(tbl_b) | Materialized->SeqScanPath(tbl_a) | Materialized nested loop join\n7 | SeqScanPath(tbl_b) | ParametalizedIndexScanPath(tbl_a, id, tbl_b.id) | Indexed nested loop join\nMerge Join\n2 | IndexScanPath(tbl_a,id) | SeqScanPath(tbl_b) | Merge join with outer index scan\n3 | SeqScanPath(tbl_b) | SeqScanPath(tbl_a) | \nHash Join\n2 | SeqScanPath(tbl_b) | SeqScanPath(tbl_a) | "
      }
    ],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.2. Getting the Cheapest Path",
    "text": "For example, in the nested loop join, seven join paths are estimated.\nThe first one indicates that the outer and inner paths are the sequential scan paths of tbl_a and tbl_b, respectively.\nThe second indicates that the outer path is the sequential scan path of tbl_a and the inner path is the materialized sequential scan path of tbl_b. And so on.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.2. Getting the Cheapest Path",
    "text": "The planner finally selects the cheapest access path from the estimated join paths,\nand the cheapest path is added to the pathlist of the RelOptInfo {tbl_a,tbl_b}. See Figure 3.36.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.2. Getting the Cheapest Path",
    "text": "In this example,\nas shown in the result of EXPLAIN below, the planner selects the hash join whose inner and outer tables are tbl_b and tbl_c.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 31,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.2. Getting the Cheapest Path",
    "text": "[CODE BLOCK]\ntestdb=# EXPLAIN  SELECT * FROM tbl_b AS b, tbl_c AS c WHERE c.id = b.id AND b.data < 400;\n                              QUERY PLAN\n----------------------------------------------------------------------\n Hash Join  (cost=90.50..277.00 rows=400 width=16)\n   Hash Cond: (c.id = b.id)\n   ->  Seq Scan on tbl_c c  (cost=0.00..145.00 rows=10000 width=8)\n   ->  Hash  (cost=85.50..85.50 rows=400 width=8)\n         ->  Seq Scan on tbl_b b  (cost=0.00..85.50 rows=400 width=8)\n               Filter: (data < 400)\n(6 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 32,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.3. Getting the Cheapest Path of a Triple-Table Query",
    "text": "Obtaining the cheapest path of a query involving three tables is as follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 33,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.3. Getting the Cheapest Path of a Triple-Table Query",
    "text": "[CODE BLOCK]\ntestdb=# \\d tbl_a\n     Table \"public.tbl_a\"\n Column |  Type   | Modifiers\n--------+---------+-----------\n id     | integer |\n data   | integer |\n\ntestdb=# \\d tbl_b\n     Table \"public.tbl_b\"\n Column |  Type   | Modifiers\n--------+---------+-----------\n id     | integer |\n data   | integer |\n\ntestdb=# \\d tbl_c\n     Table \"public.tbl_c\"\n Column |  Type   | Modifiers\n--------+---------+-----------\n id     | integer | not null\n data   | integer |\nIndexes:\n    \"tbl_c_pkey\" PRIMARY KEY, btree (id)\n\ntestdb=# SELECT * FROM tbl_a AS a, tbl_b AS b, tbl_c AS c\ntestdb-#                WHERE a.id = b.id AND b.id = c.id AND a.data < 40;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 34,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.3. Getting the Cheapest Path of a Triple-Table Query",
    "text": "Level 1:\nThe planner estimates the cheapest paths of all tables and stores this information in the corresponding RelOptInfo objects: {tbl_a}, {tbl_b}, and {tbl_c}.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 35,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.3. Getting the Cheapest Path of a Triple-Table Query",
    "text": "Level 2:\nThe planner picks all the combinations of pairs of the three tables and estimates the cheapest path for each combination.\nThe planner then stores the information in the corresponding RelOptInfo objects: {tbl_a, tbl_b}, {tbl_b, tbl_c}, and {tbl_a, tbl_c}.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 36,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.3. Getting the Cheapest Path of a Triple-Table Query",
    "text": "Level 3:\nThe planner finally gets the cheapest path using the already obtained RelOptInfo objects.\n\nMore precisely,\nthe planner considers three combinations of RelOptInfo objects: {tbl_a, {tbl_b, tbl_c}}, {tbl_b, {tbl_a, tbl_c}}, and {tbl_c, {tbl_a, tbl_b}}, because",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 37,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.3. Getting the Cheapest Path of a Triple-Table Query",
    "text": "The planner then estimates the costs of all possible join paths in them.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 38,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.3. Getting the Cheapest Path of a Triple-Table Query",
    "text": "In the RelOptInfo onject {tbl_c, {tbl_a, tbl_b}}, the planner estimates all the combinations of tbl_c and the cheapest path of {tbl_a, tbl_b}, which is the hash join whose inner and outer tables are tbl_a and tbl_b, respectively, in this example.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 39,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.3. Getting the Cheapest Path of a Triple-Table Query",
    "text": "The estimated join paths will contain three kinds of join paths and their variations, such as those shown in the previous subsection,\nthat is, the nested loop join and its variations, the merge join and its variations, and the hash join.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 40,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.3. Getting the Cheapest Path of a Triple-Table Query",
    "text": "The planner processes the RelOptInfo objects {tbl_a, {tbl_b, tbl_c}} and {tbl_b, {tbl_a, tbl_c}} in the same way and finally selects the cheapest access path from all the estimated paths.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 41,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.3. Getting the Cheapest Path of a Triple-Table Query",
    "text": "The result of the EXPLAIN command of this query is shown below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 42,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.6.3. Getting the Cheapest Path of a Triple-Table Query",
    "text": "The outermost join is the indexed nested loop join (Line 5).\nThe inner parameterized index scan is shown in line 13,\nand the outer relation is the result of the hash join whose inner and outer tables are tbl_b and tbl_a, respectively (lines 7-12).\nTherefore, the executor first executes the hash join of tbl_a and tbl_b and then executes the indexed nested loop join.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:13.196124"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "Parallel Query, supported from version 9.6, is a feature that processes a single query using multiple processes (Workers).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.324929"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "For instance, if certain conditions are met,\nthe PostgreSQL process that executes the query becomes the Leader and starts up to Worker processes (maximum number is max_parallel_workers_per_gather).\nEach Worker process then performs scan processing, and returns the results sequentially to the Leader process.\nThe Leader process aggregates the results returned from the Worker processes.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.324929"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "Figure 3.38 illustrates how a sequential scan query is processed by two Worker processes.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.324929"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "The configuration parameter parallel_leader_participation, introduced in version 14, allows the Leader process to also process queries while waiting for responses from Workers. The default is on.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.324929"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "However, to simplify the explanation and diagrams, we will explain this under the assumption that the Leader process does not process queries (i.e., parallel_leader_participation is off).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.324929"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "Parallel Query is gradually improved.\nTable 3.2 highlights key points from the official documentation’s release notes about Parallel Query.",
    "tables": [
      {
        "table_index": 0,
        "content": "Version | Description\n9.6 | Seq Scan.\n Nested Loop Join and Hash Join.\n10 | Merge Join.\n B-tree Index Scan, Bitmap Heap Scan.\n Allow non-correlated subqueries.\n11 | CREATE INDEX can now use parallel processing while building a B-tree index.\nAllow hash joins to be performed in parallel using a shared hash table.\nAllow UNION to run each SELECT in parallel if the individual SELECTs cannot be parallelized.\nAllow parallelization of commands CREATE TABLE ... AS, SELECT INTO, and CREATE MATERIALIZED VIEW.\n12 | Allow parallelized queries when in SERIALIZABLE isolation mode.\n14 | Allow a query referencing multiple foreign tables to perform foreign table scans in parallel.\nAllow REFRESH MATERIALIZED VIEW to use parallelism.\n15 | Allow SELECT DISTINCT to be parallelized.\nAllow a query referencing multiple foreign tables to perform parallel foreign table scans in more cases.\nAllow parallel commit on postgres_fdw servers.\n16 | Allow parallelization of FULL and internal right OUTER hash joins.\nAllow postgres_fdw to do aborts in parallel."
      }
    ],
    "extracted_at": "2025-10-03T12:32:14.324929"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "Note that Parallel Query is primarily READ-ONLY and does not yet support cursor operations.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.324929"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 3: Query Processing",
    "section": null,
    "text": "In the following, we will first provide an overview of Parallel Query,\nthen explore Join operations,\nand finally explain how aggregate functions are calculated in parallel queries.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.324929"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "Figure 3.39 briefly describes how parallel query performs in PostgreSQL.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.324929"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "In Parallel Query processing, the Leader and Worker processes communicate Dynamic Shared Memory (DSM) area.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.324929"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "The Leader process allocates memory space on demand (i.e., it can be allocated as needed and released when no longer required).\nWorker processes can then read and write data to these memory regions as if they were their own.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.324929"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "In this section,\nto demonstrate using concrete examples, we use Table d as follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.324929"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "[CODE BLOCK]\ntestdb=# CREATE TABLE d (id double precision, data int);\nCREATE TABLE\ntestdb=# INSERT INTO d SELECT i::double precision, (random()*1000)::int FROM generate_series(1, 1000000) AS i;\nINSERT 0 1000000\ntestdb=# ANALYZE;\nANALYZE",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.324929"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "Parallel Query is not always considered.\nIf the table size to be scanned is greater than or equal to min_parallel_table_scan_size (default is 8MB),\nor if the index size to be scanned is greater than or equal to min_parallel_index_scan_size (default is 512kB),\nthe optimizer will consider Parallel Query.",
    "tables": [
      {
        "table_index": 0,
        "content": "1\n2\n3\n4\n5\n6\n7\n8 | testdb=# EXPLAIN SELECT * FROM d WHERE id BETWEEN 1 AND 100;\n                                     QUERY PLAN\n-------------------------------------------------------------------------------------\n Gather  (cost=1000.00..16609.10 rows=1 width=12)\n   Workers Planned: 2\n   ->  Parallel Seq Scan on d  (cost=0.00..15609.00 rows=1 width=12)\n         Filter: ((id >= '1'::double precision) AND (id <= '100'::double precision))\n(4 rows)"
      }
    ],
    "extracted_at": "2025-10-03T12:32:14.324929"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "[CODE BLOCK]\ntestdb=# EXPLAIN SELECT * FROM d WHERE id BETWEEN 1 AND 100;\n                                     QUERY PLAN\n-------------------------------------------------------------------------------------\n Gather  (cost=1000.00..16609.10 rows=1 width=12)\n   Workers Planned: 2\n   ->  Parallel Seq Scan on d  (cost=0.00..15609.00 rows=1 width=12)\n         Filter: ((id >= '1'::double precision) AND (id <= '100'::double precision))\n(4 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "As shown above, the simplest plan consists of a Gather node and a Seq Scan node.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "Figure 3.40 shows the plan tree of the above query:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "The Gather node is specific to Parallel Query and collects the results from the Workers.\nIn addition to Gather, Parallel Query has the following specific nodes:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "The nodes executed by Workers are generally the subplan tree below the Gather node, and the parallel_safe value is set to True.\nIn the above example, the Seq Scan node and below, which is under the Gather node, are executed by Workers.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "To execute the query collaboratively with the Workers,\nthe Leader stores information to be shared with the Workers in its DSM (Dynamic Shared Memory) area.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "The Leader and Workers share two types of information: execution state and query.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "Execution State:\nThe environment information necessary for the Leader and Workers to execute the same query consistently.\nSee README.parallel in details.\nThis includes information such as:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "This information is stored by InitializeParallelDSM().",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "This information is stored by ExecInitParallelPlan().",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "Additionally,\nthe Leader creates a TupleQueue (based on tqueue.c) on DSM to read the Worker’s results.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "The number of Workers planned in the query plan may differ from the actual number of Workers running.\nThis is because the maximum number of Workers is limited by max_parallel_workers,\nand there may not be enough available Workers due to other parallel query processes.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "The EXPLAIN ANALYZE command shows both the planned and launched number of Workers.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "[CODE BLOCK]\ntestdb=# EXPLAIN ANALYZE SELECT * FROM d WHERE id BETWEEN 1 AND 100;\n                                                    QUERY PLAN\n------------------------------------------------------------------------------------------------------------------\n Gather  (cost=1000.00..16609.10 rows=1 width=12) (actual time=60.035..60.994 rows=100 loops=1)\n   Workers Planned: 2\n   Workers Launched: 2\n   ->  Parallel Seq Scan on d  (cost=0.00..15609.00 rows=1 width=12) (actual time=31.073..52.248 rows=50 loops=2)\n         Filter: ((id >= '1'::double precision) AND (id <= '100'::double precision))\n         Rows Removed by Filter: 499950\n Planning Time: 0.265 ms\n Execution Time: 61.012 ms\n(8 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "Upon startup, a Worker reads the shared Execution State and Query information prepared by the Leader.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "By setting the Execution State information, the Worker can execute the query in the same environment as the Leader.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 31,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "When reading the Query information, the ExecSerializePlan() function is used to generate and save a plan tree for the Worker based on the PlannedStmt.\nSpecifically, a new sub-plan tree (typically a Gather node sub-plan tree) where parallel_safe is True is generated as the Worker’s plan tree.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 32,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "As discussed in Section 3.4.1.1,\nthe Executor’s methods for accessing individual data tuples are highly abstracted.\nThis principle extends to Parallel Queries.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 33,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "Although a detailed explanation is omitted,\nsince the Leader and Workers share the query execution environment via DSM,\na single sequential scan can be executed in parallel by the Leader and Workers calling the SeqNext() function.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 34,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "Similarly, results are returned to the Gather node via a TupleQueue on DSM.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 35,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.1. Overview",
    "text": "The Gather node, a Parallel Query specific node, gathers the results returned by the Workers.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 36,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.2. Parallel Join",
    "text": "Parallel Query in PostgreSQL supports nested-loop joins, merge joins, and hash joins.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 37,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.2. Parallel Join",
    "text": "In this section, we will use the following tables: d and f:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 38,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.2. Parallel Join",
    "text": "[CODE BLOCK]\ntestdb=# CREATE TABLE d (id double precision, data int);\nCREATE TABLE\ntestdb=# INSERT INTO d SELECT i::double precision, (random()*1000)::int FROM generate_series(1, 1000000) AS i;\nINSERT 0 1000000\ntestdb=# CREATE INDEX d_id_idx ON d (id);\nCREATE INDEX\ntestdb=# CREATE TABLE f (id double precision, data int);\nCREATE TABLE\ntestdb=# INSERT INTO f SELECT i::double precision, (random()*1000)::int FROM generate_series(1, 10000000) AS i;\nINSERT 0 10000000\ntestdb=# \\d d\n                      Table \"public.d\"\n Column |       Type       | Collation | Nullable | Default\n--------+------------------+-----------+----------+---------\n id     | double precision |           |          |\n data   | integer          |           |          |\nIndexes:\n    \"d_id_idx\" btree (id)\n\ntestdb=# \\d f\n                      Table \"public.f\"\n Column |       Type       | Collation | Nullable | Default\n--------+------------------+-----------+----------+---------\n id     | double precision |           |          |\n data   | integer          |           |          |\n\ntestdb=# ANALYZE;\nANALYZE",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 39,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.2. Parallel Join",
    "text": "In a nested loop join, the inner table is always processed for all rows, not in parallel.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 40,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.2. Parallel Join",
    "text": "Therefore, for example, in a materialized nested loop join, each Worker must materialize the inner table independently, which is inefficient.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 41,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.2. Parallel Join",
    "text": "[CODE BLOCK]\ntestdb=# SET enable_nestloop = ON;\nSET\ntestdb=# SET enable_mergejoin = OFF;\nSET\ntestdb=# SET enable_hashjoin = OFF;\nSET\n\ntestdb=# EXPLAIN SELECT * FROM d, f WHERE d.data = f.data AND f.id < 10000;\n                                  QUERY PLAN\n-------------------------------------------------------------------------------\n Gather  (cost=1000.00..97163469.29 rows=9651513 width=24)\n   Workers Planned: 2\n   ->  Nested Loop  (cost=0.00..96197317.99 rows=4825756 width=24)\n         Join Filter: (d.data = f.data)\n         ->  Parallel Seq Scan on f  (cost=0.00..121935.99 rows=4831 width=12)\n               Filter: (id < '10000'::double precision)\n         ->  Materialize  (cost=0.00..27992.00 rows=1000000 width=12)\n               ->  Seq Scan on d  (cost=0.00..18109.00 rows=1000000 width=12)\n(8 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 42,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.2. Parallel Join",
    "text": "On the other hand, in an Indexed Nested Loop Join, the inner table can be scanned in parallel by the Workers, making it more efficient.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 43,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.2. Parallel Join",
    "text": "[CODE BLOCK]\ntestdb=# EXPLAIN SELECT * FROM d, f WHERE d.id = f.id AND f.id < 10000;\n                                  QUERY PLAN\n-------------------------------------------------------------------------------\n Gather  (cost=1000.42..142818.71 rows=967 width=24)\n   Workers Planned: 2\n   ->  Nested Loop  (cost=0.42..141722.01 rows=484 width=24)\n         ->  Parallel Seq Scan on f  (cost=0.00..121935.99 rows=4831 width=12)\n               Filter: (id < '10000'::double precision)\n         ->  Index Scan using d_id_idx on d  (cost=0.42..4.09 rows=1 width=12)\n               Index Cond: (id = f.id)\n(7 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 44,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.2. Parallel Join",
    "text": "Like nested loop joins,\na merge join always processes the inner table for all rows, not in parallel.\nTherefore, each Worker performs the sorting process of the inner table independently.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 45,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.2. Parallel Join",
    "text": "However,\nif the inner table is accessed using an index scan,\nthe join operation can be performed efficiently,\nsimilar to an Indexed Nested Loop Join.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 46,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.2. Parallel Join",
    "text": "[CODE BLOCK]\ntestdb=# SET enable_nestloop = OFF;\nSET\ntestdb=# SET enable_mergejoin = ON;\nSET\ntestdb=# SET enable_hashjoin = OFF;\nSET\ntestdb=# EXPLAIN SELECT * FROM d, f WHERE d.id = f.id AND d.id < 100000;\n                                       QUERY PLAN\n----------------------------------------------------------------------------------------\n Gather  (cost=837387.83..853944.33 rows=97361 width=24)\n   Workers Planned: 2\n   ->  Merge Join  (cost=836387.83..843208.23 rows=48680 width=24)\n         Merge Cond: (f.id = d.id)\n         ->  Sort  (cost=836385.61..848880.80 rows=4998079 width=12)\n               Sort Key: f.id\n               ->  Parallel Seq Scan on f  (cost=0.00..109440.79 rows=4998079 width=12)\n         ->  Index Scan using d_id_idx on d  (cost=0.42..3569.24 rows=97361 width=12)\n               Index Cond: (id < '100000'::double precision)\n(9 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 47,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.2. Parallel Join",
    "text": "In versions 10 and 9.6,\nduring a Parallel Query Hash Join,\neach Worker performs the hash table build process for the inner table independently.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 48,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.2. Parallel Join",
    "text": "[CODE BLOCK]\ntestdb=# SET enable_nestloop = OFF;\nSET\ntestdb=# SET enable_mergejoin = OFF;\nSET\ntestdb=# SET enable_hashjoin = ON;\nSET\ntestdb=# SET enable_parallel_hash = OFF;\nSET\ntestdb=# EXPLAIN SELECT * FROM d, f WHERE d.id = f.id;\n                                    QUERY PLAN\n----------------------------------------------------------------------------------\n Gather  (cost=36492.00..323368.59 rows=1000000 width=24)\n   Workers Planned: 2\n   ->  Hash Join  (cost=35492.00..222368.59 rows=500000 width=24)\n         Hash Cond: (f.id = d.id)\n         ->  Parallel Seq Scan on f  (cost=0.00..109440.79 rows=4998079 width=12)\n         ->  Hash  (cost=18109.00..18109.00 rows=1000000 width=12)\n               ->  Seq Scan on d  (cost=0.00..18109.00 rows=1000000 width=12)\n(7 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 49,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.2. Parallel Join",
    "text": "Parallel hash join was supported in version 11 (enable_parallel_hash, enabled by default).\nWith this feature, hash tables are created for each Worker during the build phase and are shared between workers,\nmaking the build phase more efficient.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 50,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.2. Parallel Join",
    "text": "[CODE BLOCK]\ntestdb=# SET enable_parallel_hash = ON;\nSET\ntestdb=# EXPLAIN SELECT * FROM d, f WHERE d.id = f.id;\n                                      QUERY PLAN\n--------------------------------------------------------------------------------------\n Gather  (cost=22801.00..304736.59 rows=1000000 width=24)\n   Workers Planned: 2\n   ->  Parallel Hash Join  (cost=21801.00..203736.59 rows=500000 width=24)\n         Hash Cond: (f.id = d.id)\n         ->  Parallel Seq Scan on f  (cost=0.00..109440.79 rows=4998079 width=12)\n         ->  Parallel Hash  (cost=13109.00..13109.00 rows=500000 width=12)\n               ->  Parallel Seq Scan on d  (cost=0.00..13109.00 rows=500000 width=12)\n(7 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 51,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.3. Parallel Aggregate",
    "text": "Almost aggregate functions in PostgreSQL can be also processed in parallel.\nWhether an aggregate function can be parallelized depends on whether Partial Mode is set to YES\nin Official Document.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 52,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.3. Parallel Aggregate",
    "text": "When the predicted number of target rows is small:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 53,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.3. Parallel Aggregate",
    "text": "[CODE BLOCK]\ntestdb=# EXPLAIN SELECT avg(id) FROM d where id BETWEEN 1 AND 10;\n                                        QUERY PLAN\n------------------------------------------------------------------------------------------\n Aggregate  (cost=16609.10..16609.11 rows=1 width=8)\n   ->  Gather  (cost=1000.00..16609.10 rows=1 width=8)\n         Workers Planned: 2\n         ->  Parallel Seq Scan on d  (cost=0.00..15609.00 rows=1 width=8)\n               Filter: ((id >= '1'::double precision) AND (id <= '10'::double precision))\n(5 rows)\n\ntestdb=# EXPLAIN SELECT var_pop(id) FROM d where id BETWEEN 1 AND 10;\n                                        QUERY PLAN\n------------------------------------------------------------------------------------------\n Aggregate  (cost=16609.10..16609.11 rows=1 width=8)\n   ->  Gather  (cost=1000.00..16609.10 rows=1 width=8)\n         Workers Planned: 2\n         ->  Parallel Seq Scan on d  (cost=0.00..15609.00 rows=1 width=8)\n               Filter: ((id >= '1'::double precision) AND (id <= '10'::double precision))\n(5 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 54,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.3. Parallel Aggregate",
    "text": "When the predicted number of target rows is large:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 55,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.3. Parallel Aggregate",
    "text": "[CODE BLOCK]\ntestdb=# EXPLAIN SELECT avg(id) FROM d where data > 100;\n                                     QUERY PLAN\n-------------------------------------------------------------------------------------\n Finalize Aggregate  (cost=16485.14..16485.15 rows=1 width=8)\n   ->  Gather  (cost=16484.93..16485.14 rows=2 width=32)\n         Workers Planned: 2\n         ->  Partial Aggregate  (cost=15484.93..15484.94 rows=1 width=32)\n               ->  Parallel Seq Scan on d  (cost=0.00..14359.00 rows=450371 width=8)\n                     Filter: (data > 100)\n(6 rows)\n\ntestdb=# EXPLAIN  SELECT var_pop(id) FROM d where data > 100;\n                                     QUERY PLAN\n-------------------------------------------------------------------------------------\n Finalize Aggregate  (cost=16485.14..16485.15 rows=1 width=8)\n   ->  Gather  (cost=16484.93..16485.14 rows=2 width=32)\n         Workers Planned: 2\n         ->  Partial Aggregate  (cost=15484.93..15484.94 rows=1 width=32)\n               ->  Parallel Seq Scan on d  (cost=0.00..14359.00 rows=450371 width=8)\n                     Filter: (data > 100)\n(6 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 56,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.3. Parallel Aggregate",
    "text": "Multiple sums, averages, and variances can be calculated using the following formulas:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 57,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.3. Parallel Aggregate",
    "text": "The finalize aggregate node aggregates the intermediate results using the formulas above.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 58,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.3. Parallel Aggregate",
    "text": "For three or more values, the process can be repeated iteratively, adding one value at a time.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql03/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 59,
    "chapter": "Chapter 3: Query Processing",
    "section": "3.7.3. Parallel Aggregate",
    "text": "The variance of the entire dataset, $V_{n}$, can be expressed in terms of\n$V_{n_{1}}$,\n$V_{n_{2}}$,\n$S_{n_{1}}$,\nand $S_{n_{2}}$ as follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:14.325930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": null,
    "text": "To utilize the FDW feature, the appropriate extension must be installed, and setup commands such as\nCREATE FOREIGN TABLE,\nCREATE SERVER\nand CREATE USER MAPPING.\n(For details, refer to the official document.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.059301"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": null,
    "text": "After providing the appropriate setting,\nthe functions defined in the extension are invoked during query processing to access the foreign tables.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.059301"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": null,
    "text": "Figure 4.2 briefly describes how FDW performs in PostgreSQL.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.059301"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": null,
    "text": "The executor then processes the received data if necessary.\nFor example, if a multi-table query is executed,\nthe executor performs the join processing of the received data and other tables.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.059301"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": null,
    "text": "The details of each processing are described in the following sections.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.059301"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.1.1. Creating a Query Tree",
    "text": "The analyzer/analyser creates the query tree of the input SQL using the definitions of the foreign tables,\nwhich are stored in the pg_catalog.pg_class and\npg_catalog.pg_foreign_table catalogs using the CREATE FOREIGN TABLE or IMPORT FOREIGN SCHEMA command.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.059301"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.1.2. Connecting to the Remote Server",
    "text": "To connect to the remote server, the planner (or executor) uses the appropriate library to connect to the remote database server.\nFor example,\nto connect to the remote PostgreSQL server,\nthe postgres_fdw uses the libpq library.\nTo connect to the MySQL server, the mysql_fdw extension,\nwhich is developed by EnterpriseDB, uses the libmysqlclient library.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.059301"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.1.2. Connecting to the Remote Server",
    "text": "The connection parameters, such as username, server’s IP address and port number, are stored in\nthe pg_catalog.pg_user_mapping\nand pg_catalog.pg_foreign_server catalogs using the CREATE USER MAPPING and\nCREATE SERVER commands.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.059301"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.1.3. Creating a Plan Tree Using EXPLAIN Commands (Optional)",
    "text": "PostgreSQL’s FDW supports the ability to obtain statistics of foreign tables to estimate the plan tree of a query.\nSome FDW extensions, such as postgres_fdw, mysql_fdw, tds_fdw, and jdbc2_fdw, use these statistics.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.059301"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.1.3. Creating a Plan Tree Using EXPLAIN Commands (Optional)",
    "text": "If the use_remote_estimate option is set to ‘on’ using the ALTER SERVER command,\nthe planner queries the cost of plans to the remote server by executing the EXPLAIN command. Otherwise, the embedded constant values are used by default.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.059301"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.1.3. Creating a Plan Tree Using EXPLAIN Commands (Optional)",
    "text": "[CODE BLOCK]\nlocaldb=# ALTER SERVER remote_server_name OPTIONS (use_remote_estimate 'on');",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.059301"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.1.3. Creating a Plan Tree Using EXPLAIN Commands (Optional)",
    "text": "Although some extensions use the values of the EXPLAIN command, only postgres_fdw can reflect the results of the EXPLAIN commands because PostgreSQL’s EXPLAIN command returns both the start-up and total costs.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.059301"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.1.3. Creating a Plan Tree Using EXPLAIN Commands (Optional)",
    "text": "The results of the EXPLAIN command cannot be used by other DBMS FDW extensions for planning.\nFor example, mysql’s EXPLAIN command only returns the estimated number of rows.\nHowever, PostgreSQL’s planner needs more information to estimate the cost as described in Chapter 3.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.059301"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.1.4. Deparesing",
    "text": "To generate the plan tree,\nthe planner creates a plain text SQL statement from the plan tree’s scan paths of the foreign tables.\nFor example, Figure 4.3 shows the plan tree of the following SELECT statement:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.059301"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.1.4. Deparesing",
    "text": "[CODE BLOCK]\nlocaldb=# SELECT * FROM tbl_a AS a WHERE a.id < 10;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.059301"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.1.4. Deparesing",
    "text": "Figure 4.3 shows that the ForeignScan node, which is linked from the plan tree of the PlannedStmt, stores a plain SELECT text.\nHere, postgres_fdw recreates a plain SELECT text from the query tree that has been created by parsing and analysing, which is called deparsing in PostgreSQL.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.059301"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.1.4. Deparesing",
    "text": "The use of mysql_fdw recreates a SELECT text for MySQL from the query tree.\nThe use of redis_fdw or rw_redis_fdw creates a SELECT command.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.059301"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.1.5. Sending SQL Statements and Receiving Result",
    "text": "After deparsing, the executor sends the deparsed SQL statements to the remote server and receives the result.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.059301"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.1.5. Sending SQL Statements and Receiving Result",
    "text": "The method for sending the SQL statements to the remote server depends on the developer of each extension.\nFor example, mysql_fdw sends the SQL statements without using a transaction.\nThe typical sequence of SQL statements to execute a SELECT query in mysql_fdw is shown below (Figure 4.4).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.059301"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.1.5. Sending SQL Statements and Receiving Result",
    "text": "[CODE BLOCK]\nmysql> SELECT command_type,argument FROM mysql.general_log;\n+--------------+-----------------------------------------------------------------------+\n| command_type | argument                                                              |\n+--------------+-----------------------------------------------------------------------+\n... snip ...\n\n| Query        | SET sql_mode='ANSI_QUOTES'                                            |\n| Prepare      | SELECT `id`, `data` FROM `localdb`.`tbl_a` WHERE ((`id` < 10))        |\n| Close stmt   |                                                                       |\n+--------------+-----------------------------------------------------------------------+",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.059301"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.1.5. Sending SQL Statements and Receiving Result",
    "text": "In postgres_fdw, the sequence of SQL commands is more complicated.\nThe typical sequence of SQL statements to execute a SELECT query in postgres_fdw is shown below (Figure 4.5).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.059301"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.1.5. Sending SQL Statements and Receiving Result",
    "text": "[CODE BLOCK]\nLOG:  statement: START TRANSACTION ISOLATION LEVEL REPEATABLE READ\nLOG:  parse <unnamed>: DECLARE c1 CURSOR FOR SELECT id, data FROM public.tbl_a WHERE ((id < 10))\nLOG:  bind <unnamed>: DECLARE c1 CURSOR FOR SELECT id, data FROM public.tbl_a WHERE ((id < 10))\nLOG:  execute <unnamed>: DECLARE c1 CURSOR FOR SELECT id, data FROM public.tbl_a WHERE ((id < 10))\nLOG:  statement: FETCH 100 FROM c1\nLOG:  statement: CLOSE c1\nLOG:  statement: COMMIT TRANSACTION",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.059301"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.1.5. Sending SQL Statements and Receiving Result",
    "text": "The explanation for why the default remote transaction isolation level is REPEATABLE READ is provided in the\n\nofficial document.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.059301"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.1.5. Sending SQL Statements and Receiving Result",
    "text": "The remote transaction uses the SERIALIZABLE isolation level when the local transaction has the SERIALIZABLE isolation level; otherwise it uses the REPEATABLE READ isolation level.\nThis choice ensures that if a query performs multiple table scans on the remote server, it will get snapshot-consistent results for all the scans.\nA consequence is that successive queries within a single transaction will see the same data from the remote server,\neven if concurrent updates are occurring on the remote server due to other activities.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.059301"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": null,
    "text": "The postgres_fdw extension is a special module that is officially maintained by the PostgreSQL Global Development Group.\nIts source code is included in the PostgreSQL source code tree.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.946722"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": null,
    "text": "postgres_fdw is gradually improved.\nTable 4.1 presents the release notes related to postgres_fdw from the official document.",
    "tables": [
      {
        "table_index": 0,
        "content": "Version | Description\n9.6 | Consider performing sorts on the remote server.\nConsider performing joins on the remote server.\nWhen feasible, perform UPDATE or DELETE entirely on the remote server.\nAllow the fetch size to be set as a server or table option.\n10 | Push aggregate functions to the remote server, when possible.\n11 | Allow to push down aggregates to foreign tables that are partitions.\nAllow to push UPDATEs and DELETEs using joins to foreign servers.\n12 | Allow ORDER BY sorts and LIMIT clauses to be pushed in more cases.\n14 | Allow TRUNCATE to operate on foreign tables.\nAllow INSERT rows in bulk.\nAdd function postgres_fdw_get_connections() to report open foreign server connections.\n15 | Allow postgres_fdw to push down CASE expressions.\nAdd server variable postgres_fdw.application_name to control the application name of postgres_fdw connections.\nAllow parallel commit on postgres_fdw servers.\n16 | Allow postgres_fdw to do aborts in parallel.\nMake ANALYZE on foreign postgres_fdw tables more efficient.\nRestrict shipment of \"reg*\" type constants in postgres_fdw to those referencing built-in objects or extensions marked as shippable.\nHave postgres_fdw and dblink handle interrupts during connection establishment.\n17 | Allow pushdown of EXISTS and IN subqueries to postgres_fdw foreign servers."
      }
    ],
    "extracted_at": "2025-10-03T12:32:16.946722"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": null,
    "text": "Since the previous section describes how postgres_fdw processes a single-table query,\nthe following subsection describes how it processes a multi-table query, sort operation, and aggregate functions.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": null,
    "text": "This subsection focuses on the SELECT statement. However, postgres_fdw can also process other DML (INSERT, UPDATE, and DELETE) statements.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": null,
    "text": "The postgres_fdw extension and the FDW feature do not support the distributed lock manager and the distributed deadlock detection feature.\nTherefore, a deadlock can easily be generated.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": null,
    "text": "For example, if Client_A updates a local table ’tbl_local’ and a foreign table ’tbl_remote’, and Client_B updates ’tbl_remote’ and ’tbl_local’,\nthen these two transactions are in deadlock, but PostgreSQL cannot detect it.\nTherefore, these transactions cannot be committed.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": null,
    "text": "[CODE BLOCK]\nlocaldb=# -- Client A\nlocaldb=# BEGIN;\nBEGIN\nlocaldb=# UPDATE tbl_local SET data = 0 WHERE id = 1;\nUPDATE 1\nlocaldb=# UPDATE tbl_remote SET data = 0 WHERE id = 1;\nUPDATE 1",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": null,
    "text": "[CODE BLOCK]\nlocaldb=# -- Client B\nlocaldb=# BEGIN;\nBEGIN\nlocaldb=# UPDATE tbl_remote SET data = 0 WHERE id = 1;\nUPDATE 1\nlocaldb=# UPDATE tbl_local SET data = 0 WHERE id = 1;\nUPDATE 1",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "To execute a multi-table query,\npostgres_fdw fetches each foreign table using a single-table SELECT statement and then join them on the local server.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "In versions 9.5 or earlier,\neven if the foreign tables are stored in the same remote server,\npostgres_fdw fetches them individually and joins them.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "In versions 9.6 or later, postgres_fdw has been improved and can execute the remote join operation on the remote server\nwhen the foreign tables are on the same server and the use_remote_estimate option is enabled.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "Let us explore how PostgreSQL processes the following query that joins two foreign tables: ’tbl_a’ and ’tbl_b'.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "[CODE BLOCK]\nlocaldb=# SELECT * FROM tbl_a AS a, tbl_b AS b WHERE a.id = b.id AND a.id < 200;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "The result of the EXPLAIN command of the query is shown below:",
    "tables": [
      {
        "table_index": 0,
        "content": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12 | localdb=# EXPLAIN SELECT * FROM tbl_a AS a, tbl_b AS b WHERE a.id = b.id AND a.id < 200;\n                                  QUERY PLAN\n------------------------------------------------------------------------------\n Merge Join  (cost=532.31..700.34 rows=10918 width=16)\n   Merge Cond: (a.id = b.id)\n   ->  Sort  (cost=200.59..202.72 rows=853 width=8)\n         Sort Key: a.id\n         ->  Foreign Scan on tbl_a a  (cost=100.00..159.06 rows=853 width=8)\n   ->  Sort  (cost=331.72..338.12 rows=2560 width=8)\n         Sort Key: b.id\n         ->  Foreign Scan on tbl_b b  (cost=100.00..186.80 rows=2560 width=8)\n(8 rows)"
      }
    ],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "[CODE BLOCK]\nlocaldb=# EXPLAIN SELECT * FROM tbl_a AS a, tbl_b AS b WHERE a.id = b.id AND a.id < 200;\n                                  QUERY PLAN\n------------------------------------------------------------------------------\n Merge Join  (cost=532.31..700.34 rows=10918 width=16)\n   Merge Cond: (a.id = b.id)\n   ->  Sort  (cost=200.59..202.72 rows=853 width=8)\n         Sort Key: a.id\n         ->  Foreign Scan on tbl_a a  (cost=100.00..159.06 rows=853 width=8)\n   ->  Sort  (cost=331.72..338.12 rows=2560 width=8)\n         Sort Key: b.id\n         ->  Foreign Scan on tbl_b b  (cost=100.00..186.80 rows=2560 width=8)\n(8 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "The result shows that the executor selects the merge join and is processed as the following steps:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "The following describes how the executor fetches the rows (Figure 4.6).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "(5-2) Declare the cursor c1, the SELECT statement of which is shown below:\nSELECT id,data FROM public.tbl_a WHERE (id < 200)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "(5-3) Execute FETCH commands to obtain the result of the cursor 1.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "(5-4) Declare the cursor c2, whose SELECT statement is shown below:\nSELECT id,data FROM public.tbl_b\nNote that the WHERE clause of the original two-table query is “tbl_a.id = tbl_b.id AND tbl_a.id < 200”.\nTherefore, a WHERE clause “tbl_b.id < 200” can be logically added to the SELECT statement as shown previously.\nHowever, postgres_fdw cannot perform this inference; therefore, the executor has to execute the SELECT statement without any WHERE clauses and has to fetch all rows of the foreign table ’tbl_b’.\n\nThis process is inefficient because unnecessary rows must be read from the remote server via the network. Furthermore, the received rows must be sorted to execute the merge join.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "(5-5) Execute FETCH commands to obtain the result of the cursor 2.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "[CODE BLOCK]\nLOG:  statement: START TRANSACTION ISOLATION LEVEL REPEATABLE READ\nLOG:  parse <unnamed>: DECLARE c1 CURSOR FOR\n      SELECT id, data FROM public.tbl_a WHERE ((id < 200))\nLOG:  bind <unnamed>: DECLARE c1 CURSOR FOR\n      SELECT id, data FROM public.tbl_a WHERE ((id < 200))\nLOG:  execute <unnamed>: DECLARE c1 CURSOR FOR\n      SELECT id, data FROM public.tbl_a WHERE ((id < 200))\nLOG:  statement: FETCH 100 FROM c1\nLOG:  statement: FETCH 100 FROM c1\nLOG:  parse <unnamed>: DECLARE c2 CURSOR FOR\n      SELECT id, data FROM public.tbl_b\nLOG:  bind <unnamed>: DECLARE c2 CURSOR FOR\n      SELECT id, data FROM public.tbl_b\nLOG:  execute <unnamed>: DECLARE c2 CURSOR FOR\n      SELECT id, data FROM public.tbl_b\nLOG:  statement: FETCH 100 FROM c2\nLOG:  statement: FETCH 100 FROM c2\nLOG:  statement: FETCH 100 FROM c2\nLOG:  statement: FETCH 100 FROM c2\n\n... snip\n\nLOG:  statement: FETCH 100 FROM c2\nLOG:  statement: FETCH 100 FROM c2\nLOG:  statement: FETCH 100 FROM c2\nLOG:  statement: FETCH 100 FROM c2\nLOG:  statement: CLOSE c2\nLOG:  statement: CLOSE c1\nLOG:  statement: COMMIT TRANSACTION",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "After receiving the rows,\nthe executor sorts both received rows of ’tbl_a’ and ’tbl_b’,\nand then executes a merge join operation with the sorted rows.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "If the use_remote_estimate option is ‘on’ (the default is ‘off’),\npostgres_fdw sends several EXPLAIN commands to obtain the costs of all plans related to the foreign tables.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "To send the EXPLAIN commands, postgres_fdw sends both the EXPLAIN command of each single-table query and the EXPLAIN commands of the SELECT statements to execute remote join operations.\nIn this example, the following seven EXPLAIN commands are sent to the remote server to obtain the estimated costs of each SELECT statement. The planner then selects the cheapest plan.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "[CODE BLOCK]\n(1) EXPLAIN SELECT id, data FROM public.tbl_a WHERE ((id < 200))\n(2) EXPLAIN SELECT id, data FROM public.tbl_b\n(3) EXPLAIN SELECT id, data FROM public.tbl_a WHERE ((id < 200)) ORDER BY id ASC NULLS LAST\n(4) EXPLAIN SELECT id, data FROM public.tbl_a WHERE ((((SELECT null::integer)::integer) = id)) AND ((id < 200))\n(5) EXPLAIN SELECT id, data FROM public.tbl_b ORDER BY id ASC NULLS LAST\n(6) EXPLAIN SELECT id, data FROM public.tbl_b WHERE ((((SELECT null::integer)::integer) = id))\n(7) EXPLAIN SELECT r1.id, r1.data, r2.id, r2.data FROM (public.tbl_a r1 INNER JOIN public.tbl_b r2 ON (((r1.id = r2.id)) AND ((r1.id < 200))))",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "Let us execute the EXPLAIN command on the local server to observe what plan is selected by the planner.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "[CODE BLOCK]\nlocaldb=# EXPLAIN SELECT * FROM tbl_a AS a, tbl_b AS b WHERE a.id = b.id AND a.id < 200;\n                        QUERY PLAN\n-----------------------------------------------------------\n Foreign Scan  (cost=134.35..244.45 rows=80 width=16)\n   Relations: (public.tbl_a a) INNER JOIN (public.tbl_b b)\n(2 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "The result shows that the planner selects the inner join query that is processed on the remote server, which is very efficient.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "The following describes how postgres_fdw is performed (Figure 4.7).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 31,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "In this example, seven EXPLAIN commands are executed.\nThen, the planner selects the cheapest cost of the SELECT queries using the results of the executed EXPLAIN commands.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 32,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "(5-1) Declare the cursor c1, whose SELECT statement is shown below:\nSELECT r1.id, r1.data, r2.id, r2.data FROM (public.tbl_a r1 INNER JOIN public.tbl_b r2\n  ON (((r1.id = r2.id)) AND ((r1.id < 200))))",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 33,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "[CODE BLOCK]\nSELECT r1.id, r1.data, r2.id, r2.data FROM (public.tbl_a r1 INNER JOIN public.tbl_b r2\n  ON (((r1.id = r2.id)) AND ((r1.id < 200))))",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 34,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "[CODE BLOCK]\nLOG:  statement: START TRANSACTION ISOLATION LEVEL REPEATABLE READ\nLOG:  statement: EXPLAIN SELECT id, data FROM public.tbl_a WHERE ((id < 200))\nLOG:  statement: EXPLAIN SELECT id, data FROM public.tbl_b\nLOG:  statement: EXPLAIN SELECT id, data FROM public.tbl_a WHERE ((id < 200)) ORDER BY id ASC NULLS LAST\nLOG:  statement: EXPLAIN SELECT id, data FROM public.tbl_a WHERE ((((SELECT null::integer)::integer) = id)) AND ((id < 200))\nLOG:  statement: EXPLAIN SELECT id, data FROM public.tbl_b ORDER BY id ASC NULLS LAST\nLOG:  statement: EXPLAIN SELECT id, data FROM public.tbl_b WHERE ((((SELECT null::integer)::integer) = id))\nLOG:  statement: EXPLAIN SELECT r1.id, r1.data, r2.id, r2.data FROM (public.tbl_a r1 INNER JOIN public.tbl_b r2 ON (((r1.id = r2.id)) AND ((r1.id < 200))))\nLOG:  parse: DECLARE c1 CURSOR FOR\n\t   SELECT r1.id, r1.data, r2.id, r2.data FROM (public.tbl_a r1 INNER JOIN public.tbl_b r2 ON (((r1.id = r2.id)) AND ((r1.id < 200))))\nLOG:  bind: DECLARE c1 CURSOR FOR\n\t   SELECT r1.id, r1.data, r2.id, r2.data FROM (public.tbl_a r1 INNER JOIN public.tbl_b r2 ON (((r1.id = r2.id)) AND ((r1.id < 200))))\nLOG:  execute: DECLARE c1 CURSOR FOR\n\t   SELECT r1.id, r1.data, r2.id, r2.data FROM (public.tbl_a r1 INNER JOIN public.tbl_b r2 ON (((r1.id = r2.id)) AND ((r1.id < 200))))\nLOG:  statement: FETCH 100 FROM c1\nLOG:  statement: FETCH 100 FROM c1\nLOG:  statement: CLOSE c1\nLOG:  statement: COMMIT TRANSACTION",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 35,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.1. Multi-Table Query",
    "text": "Note that if the use_remote_estimate option is off (by default),\na remote-join query is rarely selected because the costs are estimated using a very large embedded value.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 36,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.2. Sort Operations",
    "text": "The sort operation, such as ORDER BY, is processed on the local server.\nThis means that the local server fetches all the target rows from the remote server before the sort operation.\nLet us explore how a simple query that includes an ORDER BY clause is processed using the EXPLAIN command.",
    "tables": [
      {
        "table_index": 0,
        "content": "1\n2\n3\n4\n5\n6\n7 | localdb=# EXPLAIN SELECT * FROM tbl_a AS a WHERE a.id < 200 ORDER BY a.id;\n                              QUERY PLAN\n-----------------------------------------------------------------------\n Sort  (cost=200.59..202.72 rows=853 width=8)\n   Sort Key: id\n   ->  Foreign Scan on tbl_a a  (cost=100.00..159.06 rows=853 width=8)\n(3 rows)"
      }
    ],
    "extracted_at": "2025-10-03T12:32:16.947723"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 37,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.2. Sort Operations",
    "text": "[CODE BLOCK]\nlocaldb=# EXPLAIN SELECT * FROM tbl_a AS a WHERE a.id < 200 ORDER BY a.id;\n                              QUERY PLAN\n-----------------------------------------------------------------------\n Sort  (cost=200.59..202.72 rows=853 width=8)\n   Sort Key: id\n   ->  Foreign Scan on tbl_a a  (cost=100.00..159.06 rows=853 width=8)\n(3 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.948871"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 38,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.2. Sort Operations",
    "text": "Line 6: The executor sends the following query to the remote server, and then fetches the query result.\nSELECT id, data FROM public.tbl_a WHERE ((id < 200))",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.948871"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 39,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.2. Sort Operations",
    "text": "[CODE BLOCK]\nSELECT id, data FROM public.tbl_a WHERE ((id < 200))",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.948871"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 40,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.2. Sort Operations",
    "text": "Line 4: The executor sorts the fetched rows of ’tbl_a’ on the local server.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.948871"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 41,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.2. Sort Operations",
    "text": "[CODE BLOCK]\nLOG:  statement: START TRANSACTION ISOLATION LEVEL REPEATABLE READ\nLOG:  parse <unnamed>: DECLARE c1 CURSOR FOR\n      SELECT id, data FROM public.tbl_a WHERE ((id < 200))\nLOG:  bind <unnamed>: DECLARE c1 CURSOR FOR\n      SELECT id, data FROM public.tbl_a WHERE ((id < 200))\nLOG:  execute <unnamed>: DECLARE c1 CURSOR FOR\n      SELECT id, data FROM public.tbl_a WHERE ((id < 200))\nLOG:  statement: FETCH 100 FROM c1\nLOG:  statement: FETCH 100 FROM c1\nLOG:  statement: CLOSE c1\nLOG:  statement: COMMIT TRANSACTION",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.948871"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 42,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.2. Sort Operations",
    "text": "The postgres_fdw can execute the SELECT statements with an ORDER BY clause on the remote server if possible.",
    "tables": [
      {
        "table_index": 0,
        "content": "1\n2\n3\n4\n5 | localdb=# EXPLAIN SELECT * FROM tbl_a AS a WHERE a.id < 200 ORDER BY a.id;\n                           QUERY PLAN\n-----------------------------------------------------------------\n Foreign Scan on tbl_a a  (cost=100.00..167.46 rows=853 width=8)\n(1 row)"
      }
    ],
    "extracted_at": "2025-10-03T12:32:16.948871"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 43,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.2. Sort Operations",
    "text": "[CODE BLOCK]\nlocaldb=# EXPLAIN SELECT * FROM tbl_a AS a WHERE a.id < 200 ORDER BY a.id;\n                           QUERY PLAN\n-----------------------------------------------------------------\n Foreign Scan on tbl_a a  (cost=100.00..167.46 rows=853 width=8)\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.948871"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 44,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.2. Sort Operations",
    "text": "[CODE BLOCK]\nSELECT id, data FROM public.tbl_a WHERE ((id < 200)) ORDER BY id ASC NULLS LAST",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.948871"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 45,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.2. Sort Operations",
    "text": "[CODE BLOCK]\nLOG:  statement: START TRANSACTION ISOLATION LEVEL REPEATABLE READ\nLOG:  parse <unnamed>: DECLARE c1 CURSOR FOR\n\t   SELECT id, data FROM public.tbl_a WHERE ((id < 200)) ORDER BY id ASC NULLS LAST\nLOG:  bind <unnamed>: DECLARE c1 CURSOR FOR\n\t   SELECT id, data FROM public.tbl_a WHERE ((id < 200)) ORDER BY id ASC NULLS LAST\nLOG:  execute <unnamed>: DECLARE c1 CURSOR FOR\n\t   SELECT id, data FROM public.tbl_a WHERE ((id < 200)) ORDER BY id ASC NULLS LAST\nLOG:  statement: FETCH 100 FROM c1\nLOG:  statement: FETCH 100 FROM c1\nLOG:  statement: CLOSE c1\nLOG:  statement: COMMIT TRANSACTION",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.948871"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 46,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.2. Sort Operations",
    "text": "This improvement has reduced the workload of the local server.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.948871"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 47,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.3. Aggregate Functions",
    "text": "Similar to the sort operation mentioned in the previous subsection,\naggregate functions such as AVG() and COUNT() are processed on the local server as the following steps:",
    "tables": [
      {
        "table_index": 0,
        "content": "1\n2\n3\n4\n5\n6 | localdb=# EXPLAIN SELECT AVG(data) FROM tbl_a AS a WHERE a.id < 200;\n                              QUERY PLAN\n-----------------------------------------------------------------------\n Aggregate  (cost=168.50..168.51 rows=1 width=4)\n   ->  Foreign Scan on tbl_a a  (cost=100.00..166.06 rows=975 width=4)\n(2 rows)"
      }
    ],
    "extracted_at": "2025-10-03T12:32:16.948871"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 48,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.3. Aggregate Functions",
    "text": "[CODE BLOCK]\nlocaldb=# EXPLAIN SELECT AVG(data) FROM tbl_a AS a WHERE a.id < 200;\n                              QUERY PLAN\n-----------------------------------------------------------------------\n Aggregate  (cost=168.50..168.51 rows=1 width=4)\n   ->  Foreign Scan on tbl_a a  (cost=100.00..166.06 rows=975 width=4)\n(2 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.948871"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 49,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.3. Aggregate Functions",
    "text": "Line 5: The executor sends the following query to the remote server, and then fetches the query result.\nSELECT id, data FROM public.tbl_a WHERE ((id < 200))",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.948871"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 50,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.3. Aggregate Functions",
    "text": "[CODE BLOCK]\nSELECT id, data FROM public.tbl_a WHERE ((id < 200))",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.948871"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 51,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.3. Aggregate Functions",
    "text": "Line 4: The executor computes the average of the fetched rows of ’tbl_a’ on the local server.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.948871"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 52,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.3. Aggregate Functions",
    "text": "[CODE BLOCK]\nLOG:  statement: START TRANSACTION ISOLATION LEVEL REPEATABLE READ\nLOG:  parse <unnamed>: DECLARE c1 CURSOR FOR\n      SELECT data FROM public.tbl_a WHERE ((id < 200))\nLOG:  bind <unnamed>: DECLARE c1 CURSOR FOR\n      SELECT data FROM public.tbl_a WHERE ((id < 200))\nLOG:  execute <unnamed>: DECLARE c1 CURSOR FOR\n      SELECT data FROM public.tbl_a WHERE ((id < 200))\nLOG:  statement: FETCH 100 FROM c1\nLOG:  statement: FETCH 100 FROM c1\nLOG:  statement: CLOSE c1\nLOG:  statement: COMMIT TRANSACTION",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.948871"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 53,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.3. Aggregate Functions",
    "text": "This process is costly because sending a large number of rows consumes heavy network traffic and takes a long time.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.948871"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 54,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.3. Aggregate Functions",
    "text": "The postgres_fdw executes the SELECT statement with the aggregate function on the remote server if possible.",
    "tables": [
      {
        "table_index": 0,
        "content": "1\n2\n3\n4\n5\n6 | localdb=# EXPLAIN SELECT AVG(data) FROM tbl_a AS a WHERE a.id < 200;\n                     QUERY PLAN\n-----------------------------------------------------\n Foreign Scan  (cost=102.44..149.03 rows=1 width=32)\n   Relations: Aggregate on (public.tbl_a a)\n(2 rows)"
      }
    ],
    "extracted_at": "2025-10-03T12:32:16.948871"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 55,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.3. Aggregate Functions",
    "text": "[CODE BLOCK]\nlocaldb=# EXPLAIN SELECT AVG(data) FROM tbl_a AS a WHERE a.id < 200;\n                     QUERY PLAN\n-----------------------------------------------------\n Foreign Scan  (cost=102.44..149.03 rows=1 width=32)\n   Relations: Aggregate on (public.tbl_a a)\n(2 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.949871"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 56,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.3. Aggregate Functions",
    "text": "[CODE BLOCK]\nSELECT avg(data) FROM public.tbl_a WHERE ((id < 200))",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.949871"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 57,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.3. Aggregate Functions",
    "text": "[CODE BLOCK]\nLOG:  statement: START TRANSACTION ISOLATION LEVEL REPEATABLE READ\nLOG:  parse <unnamed>: DECLARE c1 CURSOR FOR\n\t   SELECT avg(data) FROM public.tbl_a WHERE ((id < 200))\nLOG:  bind <unnamed>: DECLARE c1 CURSOR FOR\n\t   SELECT avg(data) FROM public.tbl_a WHERE ((id < 200))\nLOG:  execute <unnamed>: DECLARE c1 CURSOR FOR\n\t   SELECT avg(data) FROM public.tbl_a WHERE ((id < 200))\nLOG:  statement: FETCH 100 FROM c1\nLOG:  statement: CLOSE c1\nLOG:  statement: COMMIT TRANSACTION",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.949871"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 58,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.3. Aggregate Functions",
    "text": "This process is obviously efficient because the remote server calculates the average and sends only one row as the result.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.949871"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql04/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 59,
    "chapter": "Chapter 4: Foreign Data Wrappers (FDW)",
    "section": "4.2.3. Aggregate Functions",
    "text": "Similar to the given example,\npush-down is an operation where the local server allows the remote server to process some operations, such as aggregate procedures.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:16.949871"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "At the start of every transaction, the transaction manager assigns a unique identifier known as a transaction ID (txid).\nPostgreSQL’s txid is a 32-bit unsigned integer, with a maximum value of approximately 4.2 billion (thousand millions).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:18.651662"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "Executing the built-in txid_current() function after a transaction begins returns the current txid, as shown below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:18.651662"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "[CODE BLOCK]\ntestdb=# BEGIN;\nBEGIN\ntestdb=# SELECT txid_current();\n txid_current\n--------------\n          100\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:18.651662"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "PostgreSQL reserves the following three special txids:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:18.651662"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "1 means Bootstrap txid, which is only used in the initialization of the database cluster.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:18.651662"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "2 means Frozen txid, which is described in Section 5.10.1.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:18.651662"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "Txids can be compared with each other.\nFor example, at the viewpoint of txid 100,\ntxids that are greater than 100 are ‘in the future’ and are invisible from the txid 100;\ntxids that are less than 100 are ‘in the past’ and are visible (Figure 5.1 a)).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:18.651662"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "Since the txid space is insufficient in practical systems,\nPostgreSQL treats the txid space as a circle.\nThe previous 2.1 billion txids are ‘in the past’,\nand the next 2.1 billion txids are ‘in the future’ (Figure 5.1 b).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:18.651662"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "Note that the so-called txid wraparound problem is described in Section 5.10.1.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:18.651662"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "Note that BEGIN command does not be assigned a txid.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:18.651662"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "In PostgreSQL,\nwhen the first command is executed after a BEGIN command executed, a tixd is assigned by the transaction manager,\nand then the transaction starts.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:18.651662"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "Heap tuples in table pages are classified into two types: usual data tuples and TOAST tuples. This section describes only the usual tuple.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:19.504767"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "A heap tuple comprises three parts: the HeapTupleHeaderData structure, NULL bitmap, and user data (Figure 5.2).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:19.504767"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "The HeapTupleHeaderData structure is defined in src/include/access/htup_details.h.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:19.504767"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "The HeapTupleHeaderData structure contains seven fields,\nbut only four of them are required in the subsequent sections:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:19.504767"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "t_xmin holds the txid of the transaction that inserted this tuple.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:19.504767"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "t_xmax holds the txid of the transaction that deleted or updated this tuple.\nIf this tuple has not been deleted or updated, t_xmax is set to 0, which means INVALID.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:19.504767"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "t_cid holds the command id (cid), which is the number of SQL commands that were executed before this command was executed within the current transaction, starting from 0.\nFor example, assume that we execute three INSERT commands within a single transaction: ‘BEGIN; INSERT; INSERT; INSERT; COMMIT;’.\nIf the first command inserts this tuple, t_cid is set to 0.\nIf the second command inserts this tuple, t_cid is set to 1, and so on.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:19.504767"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "t_ctid holds the tuple identifier (tid) that points to itself or a new tuple.\ntid, described in Section 1.3, is used to identify a tuple within a table.\nWhen this tuple is updated, the t_ctid of this tuple points to the new tuple;\notherwise, the t_ctid points to itself.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:19.504767"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "[CODE BLOCK]\ntypedef struct HeapTupleFields\n{\n        TransactionId t_xmin;\t\t   /* inserting xact ID */\n        TransactionId t_xmax;              /* deleting or locking xact ID */\n\n        union\n        {\n                CommandId       t_cid;     /* inserting or deleting command ID, or both */\n                TransactionId \tt_xvac;    /* old-style VACUUM FULL xact ID */\n        } t_field3;\n} HeapTupleFields;\n\ntypedef struct DatumTupleFields\n{\n        int32          datum_len_;          /* varlena header (do not touch directly!) */\n        int32          datum_typmod;   \t    /* -1, or identifier of a record type */\n        Oid            datum_typeid;   \t    /* composite type OID, or RECORDOID */\n\n        /*\n         * Note: field ordering is chosen with thought that Oid might someday\n         * widen to 64 bits.\n         */\n} DatumTupleFields;\n\ntypedef struct HeapTupleHeaderData\n{\n        union\n        {\n                HeapTupleFields t_heap;\n                DatumTupleFields t_datum;\n        } t_choice;\n\n        ItemPointerData t_ctid;         /* current TID of this or newer tuple */\n\n        /* Fields below here must match MinimalTupleData! */\n        uint16          t_infomask2;    /* number of attributes + various flags */\n        uint16          t_infomask;     /* various flag bits, see below */\n        uint8           t_hoff;         /* sizeof header incl. bitmap, padding */\n        /* ^ - 23 bytes - ^ */\n        bits8           t_bits[1];      /* bitmap of NULLs -- VARIABLE LENGTH */\n\n        /* MORE DATA FOLLOWS AT END OF STRUCT */\n} HeapTupleHeaderData;\n\ntypedef HeapTupleHeaderData *HeapTupleHeader;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:19.504767"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "This section describes how tuples are inserted, deleted, and updated.\nThen, the Free Space Map (FSM), which is used to insert and update tuples, is briefly described.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:20.359496"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "To focus on tuples, page headers and line pointers are not represented in the following.\nFigure 5.3 shows an example of how tuples are represented.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:20.359496"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.3.1. Insertion",
    "text": "With the insertion operation,\na new tuple is inserted directly into a page of the target table (Figure 5.4).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:20.359496"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.3.1. Insertion",
    "text": "Suppose that a tuple is inserted in a page by a transaction whose txid is 99.\nIn this case, the header fields of the inserted tuple are set as follows.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:20.359496"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.3.1. Insertion",
    "text": "PostgreSQL provides the ‘pageinspect’ extension, which is a contribution module, to show the contents of the database pages.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:20.359496"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.3.1. Insertion",
    "text": "[CODE BLOCK]\ntestdb=# CREATE EXTENSION pageinspect;\nCREATE EXTENSION\ntestdb=# CREATE TABLE tbl (data text);\nCREATE TABLE\ntestdb=# INSERT INTO tbl VALUES('A');\nINSERT 0 1\ntestdb=# SELECT lp as tuple, t_xmin, t_xmax, t_field3 as t_cid, t_ctid\n                FROM heap_page_items(get_raw_page('tbl', 0));\n tuple | t_xmin | t_xmax | t_cid | t_ctid\n-------+--------+--------+-------+--------\n     1 |     99 |      0 |     0 | (0,1)\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:20.359496"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.3.2. Deletion",
    "text": "In the deletion operation,\nthe target tuple is deleted logically.\nThe value of the txid that executes the DELETE command is set to the t_xmax of the tuple (Figure 5.5).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:20.359496"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.3.2. Deletion",
    "text": "Suppose that tuple Tuple_1 is deleted by txid 111.\nIn this case, the header fields of Tuple_1 are set as follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:20.359496"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.3.2. Deletion",
    "text": "If txid 111 is committed, Tuple_1 is no longer required.\nGenerally, unneeded tuples are referred to as dead tuples in PostgreSQL.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:20.359496"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.3.2. Deletion",
    "text": "Dead tuples should eventually be removed from pages.\nCleaning dead tuples is referred to as VACUUM processing, which is described in Chapter 6.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:20.359496"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.3.3. Update",
    "text": "In the update operation,\nPostgreSQL logically deletes the latest tuple and inserts a new one (Figure 5.6).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:20.359496"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.3.3. Update",
    "text": "Suppose that the row, which has been inserted by txid 99, is updated twice by txid 100.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:20.359496"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.3.3. Update",
    "text": "When the first UPDATE command is executed,\nTuple_1 is logically deleted by setting txid 100 to the t_xmax,\nand then Tuple_2 is inserted.\nThen, the t_ctid of Tuple_1 is rewritten to point to Tuple_2.\nThe header fields of both Tuple_1 and Tuple_2 are as follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:20.359496"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.3.3. Update",
    "text": "When the second UPDATE command is executed, as in the first UPDATE command,\nTuple_2 is logically deleted and Tuple_3 is inserted.\nThe header fields of both Tuple_2 and Tuple_3 are as follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:20.359496"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.3.3. Update",
    "text": "As with the delete operation, if txid 100 is committed, Tuple_1 and Tuple_2 will be dead tuples, and,\nif txid 100 is aborted, Tuple_2 and Tuple_3 will be dead tuples.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:20.359496"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.3.4. Free Space Map",
    "text": "When inserting a heap or an index tuple,\nPostgreSQL uses the Free Space Map (FSM) of the corresponding table or index\nto select the page which can be inserted into.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:20.359496"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.3.4. Free Space Map",
    "text": "As mentioned in Section 1.2.3,\nall tables and indexes have respective FSMs.\nEach FSM stores the information about the free space capacity of each page within the corresponding table or index file.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:20.359496"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.3.4. Free Space Map",
    "text": "All FSMs are stored with the suffix ‘fsm’,\nand they are loaded into shared memory if necessary.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:20.359496"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.3.4. Free Space Map",
    "text": "The extension pg_freespacemap provides the freespace of the specified table/index.\nThe following query shows the freespace ratio of each page in the specified table.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:20.359496"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.3.4. Free Space Map",
    "text": "[CODE BLOCK]\ntestdb=# CREATE EXTENSION pg_freespacemap;\nCREATE EXTENSION\n\ntestdb=# SELECT *, round(100 * avail/8192 ,2) as \"freespace ratio\"\n                FROM pg_freespace('accounts');\n blkno | avail | freespace ratio\n-------+-------+-----------------\n     0 |  7904 |           96.00\n     1 |  7520 |           91.00\n     2 |  7136 |           87.00\n     3 |  7136 |           87.00\n     4 |  7136 |           87.00\n     5 |  7136 |           87.00\n....",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:20.359496"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "PostgreSQL holds the statuses of transactions in the Commit Log.\nThe Commit Log, often called the clog,\nis allocated to shared memory\nand is used throughout transaction processing.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:21.207766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "This section describes the the status of transactions in PostgreSQL,\nhow the clog operates, and maintenance of the clog.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:21.207766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.4.1 Transaction Status",
    "text": "PostgreSQL defines four transaction states: IN_PROGRESS, COMMITTED, ABORTED, and SUB_COMMITTED.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:21.207766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.4.1 Transaction Status",
    "text": "The first three statuses are self-explanatory.\nFor example, when a transaction is in progress, its status is IN_PROGRESS.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:21.207766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.4.1 Transaction Status",
    "text": "SUB_COMMITTED is for sub-transactions, and its description is omitted in this document.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:21.207766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.4.2. How Clog Performs",
    "text": "The clog comprises one or more 8 KB pages in shared memory.\nIt logically forms an array, where the indices of the array correspond to the respective transaction ids,\nand each item in the array holds the status of the corresponding transaction id.\nFigure 5.7 shows the clog and how it operates.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:21.207766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.4.2. How Clog Performs",
    "text": "T1:txid 200 commits; the status of txid 200 is changed from IN_PROGRESS to COMMITTED.T2:txid 201 aborts;the status of txid 201 is changed from IN_PROGRESS to ABORTED.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:21.207766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.4.2. How Clog Performs",
    "text": "When the current txid advances and the clog can no longer store it, a new page is appended.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:21.207766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.4.2. How Clog Performs",
    "text": "When the status of a transaction is needed, internal functions are invoked. Those functions read the clog and return the status of the requested transaction.\n(See also ‘Hint Bits’ in Section 5.7.1.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:21.207766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.4.3. Maintenance of the Clog",
    "text": "When PostgreSQL shuts down or whenever the checkpoint process runs,\nthe data of the clog are written into files stored in the pg_xact subdirectory.\n(Note that pg_xact was called pg_clog in versions 9.6 or earlier.)\nThese files are named ‘0000’, ‘0001’, and so on.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:21.207766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.4.3. Maintenance of the Clog",
    "text": "The maximum file size is 256 KB.\nFor example, if the clog uses eight pages (the first page to the eighth page, the total size is 64 KB),\nits data are written into ‘0000’ (64 KB).\nIf the clog uses 37 pages (296 KB), its data are written into ‘0000’ and ‘0001’,\nwhich are 256 KB and 40 KB in size, respectively.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:21.207766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.4.3. Maintenance of the Clog",
    "text": "When PostgreSQL starts up, the data stored in the pg_xact files are loaded to initialize the clog.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:21.207766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.4.3. Maintenance of the Clog",
    "text": "The size of the clog continuously increases because a new page is appended whenever the clog is filled up.\nHowever, not all data in the clog are necessary.\nVacuum processing, described in Chapter 6, regularly removes such old data (both the clog pages and files).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:21.207766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.4.3. Maintenance of the Clog",
    "text": "Details about removing the clog data are described in Section 6.4.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:21.207766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "A transaction snapshot is a dataset that stores information about whether all transactions are active at a certain point in time for an individual transaction.\nHere an active transaction means it is in progress or has not yet started.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.062855"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "PostgreSQL internally defines the textual representation format of transaction snapshots as ‘100:100:’.\nFor example, ‘100:100:’ means ’txids that are less than 99 are not active, and txids that are equal or greater than 100 are active’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.062855"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "In the following descriptions, this convenient representation form is used.\nIf you are not familiar with it,\nsee  below.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.062855"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "The function pg_current_snapshot shows a snapshot of the current transaction.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.062855"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "[CODE BLOCK]\ntestdb=# SELECT pg_current_snapshot();\n pg_current_snapshot\n---------------------\n 100:104:100,102\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.062855"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "The textual representation of the txid_current_snapshot is ‘xmin:xmax:xip_list’,\nand the components are described as follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.062855"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "xmin\n(earliest txid that is still active): All earlier transactions will either be committed and visible, or rolled back and dead.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.062855"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "xmax\n(first as-yet-unassigned txid): All txids greater than or equal to this are not yet started as of the time of the snapshot, and thus invisible.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.062855"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "xip_list\n(list of active transaction ids at the time of the snapshot): The list includes only active txids between xmin and xmax.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.062855"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "For example, in the snapshot ‘100:104:100,102’, xmin is ‘100’, xmax ‘104’, and xip_list ‘100,102’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.062855"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "The first example is ‘100:100:’.\nThis snapshot means the following (Figure 5.8(a)):",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.062855"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "The second example is ‘100:104:100,102’.\nThis snapshot means the following (Figure 5.8(b)):",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.062855"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "Transaction snapshots are provided by the transaction manager.\nIn the READ COMMITTED isolation level, the transaction obtains a snapshot whenever an SQL command is executed;\notherwise (REPEATABLE READ or SERIALIZABLE), the transaction only gets a snapshot when the first SQL command is executed.\nThe obtained transaction snapshot is used for a visibility check of tuples, which is described in Section 5.7.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.062855"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "When using the obtained snapshot for the visibility check,\nactive transactions in the snapshot must be treated as in progress\neven if they have actually been committed or aborted.\nThis rule is important because it causes the difference in the behavior between READ COMMITTED and REPEATABLE READ (or SERIALIZABLE).\nWe refer to this rule repeatedly in the following sections.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.062855"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "In the remainder of this section, the transaction manager and transactions are described using the specific scenario illustrated in Figure 5.9.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.062855"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "The transaction manager always holds information about currently running transactions.\nSuppose that three transactions start one after another,\nand the isolation level of Transaction_A and Transaction_B are READ COMMITTED,\nand that of Transaction_C is REPEATABLE READ.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.062855"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "T1:\nTransaction_A starts and executes the first SELECT command.\nWhen executing the first command, Transaction_A requests the txid and snapshot of this moment.\n\nIn this scenario,\nthe transaction manager assigns txid 200, and returns the transaction snapshot ‘200:200:’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.062855"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "T2:\nTransaction_B starts and executes the first SELECT command.\nThe transaction manager assigns txid 201, and returns the transaction snapshot ‘200:200:’\nbecause Transaction_A (txid 200) is in progress.\nThus, Transaction_A cannot be seen from Transaction_B.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.062855"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "T3:\nTransaction_C starts and executes the first SELECT command.\nThe transaction manager assigns txid 202, and returns the transaction snapshot ‘200:200:’,\nthus, Transaction_A and Transaction_B cannot be seen from Transaction_C.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.062855"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "T4:\nTransaction_A has been committed.\nThe transaction manager removes the information about this transaction.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.062855"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "T5:\nTransaction_B and Transaction_C execute their respective SELECT commands.\nTransaction_B requires a transaction snapshot because it is in the READ COMMITTED level.\nIn this scenario, Transaction_B obtains a new snapshot ‘201:201:’\nbecause Transaction_A (txid 200) is committed.\nThus, Transaction_A is no longer invisible from Transaction_B.\n\nIn contrast,\nTransaction_C does not require a transaction snapshot because it is in the REPEATABLE READ level\nand uses the obtained snapshot, i.e. ‘200:200:’.\nThus, Transaction_A is still invisible from Transaction_C.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.062855"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "Visibility check rules are a set of rules used to determine whether each tuple is visible or invisible using both the t_xmin and t_xmax of the tuple, the clog, and the obtained transaction snapshot.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "These rules are too complicated to explain in detail.\nTherefore this document shows the minimal rules required for the subsequent descriptions.\nIn the following,\nwe omit the rules related to sub-transactions\nand ignore discussion about t_ctid, i.e. we do not consider tuples that have been updated more than twice within a transaction.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "The number of selected rules is ten, and they can be classified into three cases.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.1. Status of t_xmin is ABORTED",
    "text": "A tuple whose t_xmin status is ABORTED is always invisible (Rule 1)\nbecause the transaction that inserted this tuple has been aborted.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.1. Status of t_xmin is ABORTED",
    "text": "[CODE BLOCK]\n/* t_xmin status == ABORTED */\nRule 1:\t  IF t_xmin status is 'ABORTED' THEN\n                 RETURN 'Invisible'\n          END IF",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.1. Status of t_xmin is ABORTED",
    "text": "This rule is explicitly expressed as the following mathematical expression.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.2. Status of t_xmin is IN_PROGRESS",
    "text": "A tuple whose t_xmin status is IN_PROGRESS is essentially invisible (Rules 3 and 4), except under one condition.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.2. Status of t_xmin is IN_PROGRESS",
    "text": "[CODE BLOCK]\n/* t_xmin status == IN_PROGRESS */\n       IF t_xmin status is 'IN_PROGRESS' THEN\n              IF t_xmin = current_txid THEN\nRule 2:              IF t_xmax = INVALID THEN\n                           RETURN 'Visible'\nRule 3:              ELSE  /* this tuple has been deleted or updated  */\n                           /* by the current transaction itself.      */\n                            RETURN 'Invisible'\n                     END IF\nRule 4:       ELSE   /* t_xmin != current_txid */\n                     RETURN 'Invisible'\n              END IF\n       END IF",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.2. Status of t_xmin is IN_PROGRESS",
    "text": "If this tuple is inserted by another transaction and the status of t_xmin is IN_PROGRESS,\nthen this tuple is obviously invisible (Rule 4).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.2. Status of t_xmin is IN_PROGRESS",
    "text": "If t_xmin is equal to the current txid (i.e., this tuple is inserted by the current transaction) and t_xmax is not INVALID,\nthen this tuple is invisible\nbecause it has been updated or deleted by the current transaction (Rule 3).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.2. Status of t_xmin is IN_PROGRESS",
    "text": "The exception condition is the case where this tuple is inserted by the current transaction and t_xmax is INVALID.\nIn this case, this tuple must be visible from the current transaction (Rule 2) because this tuple is the tuple inserted by the current transaction itself.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.2. Status of t_xmin is IN_PROGRESS",
    "text": "Rule 2: If Status(t_xmin) = IN_PROGRESS $\\wedge$ t_xmin = current_txid $\\wedge$ t_xmax = INVALID $\\Rightarrow$ Visible",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.2. Status of t_xmin is IN_PROGRESS",
    "text": "Rule 3: If Status(t_xmin) = IN_PROGRESS $\\wedge$ t_xmin = current_txid $\\wedge$ t_xmax $\\ne$ INVALID $\\Rightarrow$ Invisible",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.2. Status of t_xmin is IN_PROGRESS",
    "text": "Rule 4: If Status(t_xmin) = IN_PROGRESS $\\wedge$ t_xmin $\\ne$  current_txid $\\Rightarrow$ Invisible",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.3. Status of t_xmin is COMMITTED",
    "text": "A tuple whose t_xmin status is COMMITTED is  visible (Rules 6,8, and 9), except under three conditions.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.3. Status of t_xmin is COMMITTED",
    "text": "[CODE BLOCK]\n/* t_xmin status == COMMITTED */\n        IF t_xmin status is 'COMMITTED' THEN\nRule 5:        IF t_xmin is 'active' in the obtained transaction snapshot THEN\n                      RETURN 'Invisible'\nRule 6:        ELSE IF t_xmax = INVALID OR status of t_xmax is 'ABORTED' THEN\n                      RETURN 'Visible'\n               ELSE IF t_xmax status is 'IN_PROGRESS' THEN\nRule 7:               IF t_xmax =  current_txid THEN\n                             RETURN 'Invisible'\nRule 8:               ELSE  /* t_xmax != current_txid */\n                             RETURN 'Visible'\n                      END IF\n               ELSE IF t_xmax status is 'COMMITTED' THEN\nRule 9:               IF t_xmax is 'active' in the obtained transaction snapshot THEN\n                             RETURN 'Visible'\nRule 10:              ELSE\n                             RETURN 'Invisible'\n                      END IF\n               END IF\n        END IF",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.3. Status of t_xmin is COMMITTED",
    "text": "Rule 6 is obvious because t_xmax is INVALID or ABORTED.\nThree exception conditions and both Rules 8 and 9 are described as follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.3. Status of t_xmin is COMMITTED",
    "text": "The first exception condition is that t_xmin is active in the obtained transaction snapshot (Rule 5).\nUnder this condition,\nthis tuple is invisible\nbecause t_xmin should be treated as in progress.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.3. Status of t_xmin is COMMITTED",
    "text": "The second exception condition is that t_xmax is the current txid (Rule 7).\nUnder this condition,\nas with Rule 3,\nthis tuple is invisible\nbecause it has been updated or deleted by this transaction itself.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.3. Status of t_xmin is COMMITTED",
    "text": "In contrast,\nif the status of t_xmax is IN_PROGRESS and t_xmax is not the current txid (Rule 8),\nthe tuple is visible\nbecause it has not been deleted.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.3. Status of t_xmin is COMMITTED",
    "text": "The third exception condition is that the status of t_xmax is COMMITTED and t_xmax is not active in the obtained transaction snapshot (Rule 10).\nUnder this condition,\nthis tuple is invisible\nbecause it has been updated or deleted by another transaction.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.3. Status of t_xmin is COMMITTED",
    "text": "In contrast,\nif the status of t_xmax is COMMITTED but t_xmax is active in the obtained transaction snapshot (Rule 9),\nthe tuple is visible because t_xmax should be treated as in progress.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.3. Status of t_xmin is COMMITTED",
    "text": "Rule 5: If Status(t_xmin) = COMMITTED $\\wedge$ Snapshot(t_xmin) = active  $\\Rightarrow$ Invisible",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.3. Status of t_xmin is COMMITTED",
    "text": "Rule 6: If Status(t_xmin) = COMMITTED $\\wedge$ (t_xmax = INVALID $\\vee$ Status(t_xmax) = ABORTED) $\\Rightarrow$ Visible",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.3. Status of t_xmin is COMMITTED",
    "text": "Rule 7: If Status(t_xmin) = COMMITTED $\\wedge$ Status(t_xmax) = IN_PROGRESS $\\wedge$ t_xmax = current_txid $\\Rightarrow$ Invisible",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.3. Status of t_xmin is COMMITTED",
    "text": "Rule 8: If Status(t_xmin) = COMMITTED $\\wedge$ Status(t_xmax) = IN_PROGRESS $\\wedge$ t_xmax $\\ne$ current_txid $\\Rightarrow$ Visible",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.3. Status of t_xmin is COMMITTED",
    "text": "Rule 9: If Status(t_xmin) = COMMITTED $\\wedge$ Status(t_xmax) = COMMITTED $\\wedge$ Snapshot(t_xmax) = active $\\Rightarrow$ Visible",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.6.3. Status of t_xmin is COMMITTED",
    "text": "Rule 10: If Status(t_xmin) = COMMITTED $\\wedge$ Status(t_xmax) = COMMITTED $\\wedge$ Snapshot(t_xmax) $\\ne$ active $\\Rightarrow$ Invisible",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:22.920286"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "This section describes how PostgreSQL performs a visibility check,\nwhich is the process of selecting heap tuples of the appropriate versions in a given transaction.\nThis section also describes how PostgreSQL prevents the anomalies defined in the ANSI SQL-92 Standard: Dirty Reads, Repeatable Reads and Phantom Reads.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "Figure 5.10 shows a scenario to describe the visibility check.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "In the scenario shown in Figure 5.10, SQL commands are executed in the following time sequence.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "To simplify the description,\nassume that there are only two transactions, i.e. txid 200 and 201.\nThe isolation level of txid 200 is READ COMMITTED,\nand the isolation level of txid 201 is either READ COMMITTED or REPEATABLE READ.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "We explore how SELECT commands perform a visibility check for each tuple.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "At T3, there is only Tuple_1 in the table ’tbl’ and it is visible by Rule 6.\nTherefore, SELECT commands in both transactions return ‘Jekyll’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "[CODE BLOCK]\ntestdb=# -- txid 200\ntestdb=# SELECT * FROM tbl;\n  name\n--------\n Jekyll\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "[CODE BLOCK]\ntestdb=# -- txid 201\ntestdb=# SELECT * FROM tbl;\n  name\n--------\n Jekyll\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "First, we explore the SELECT command executed by txid 200.\nTuple_1 is invisible by Rule 7 and Tuple_2 is visible by Rule 2.\nTherefore, this SELECT command returns ‘Hyde’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "Rule7(Tuple_1): Status(t_xmin:199) = COMMITTED $\\wedge$ Status(t_xmax:200) = IN_PROGRESS $\\wedge$ t_xmax:200 = current_txid:200 $\\Rightarrow$ Invisible",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "Rule2(Tuple_2): Status(t_xmin:200) = IN_PROGRESS $\\wedge$ t_xmin:200 = current_txid:200 $\\wedge$ t_xmax = INVALID $\\Rightarrow$ Visible",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "[CODE BLOCK]\ntestdb=# -- txid 200\ntestdb=# SELECT * FROM tbl;\n name\n------\n Hyde\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "On the other hand, in the SELECT command executed by txid 201,\nTuple_1 is visible by Rule 8 and Tuple_2 is invisible by Rule 4.\nTherefore, this SELECT command returns ‘Jekyll’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "Rule8(Tuple_1): Status(t_xmin:199) = COMMITTED $\\wedge$ Status(t_xmax:200) = IN_PROGRESS $\\wedge$ t_xmax:200 $\\ne$ current_txid:201 $\\Rightarrow$ Visible",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "Rule4(Tuple_2): Status(t_xmin:200) = IN_PROGRESS $\\wedge$ t_xmin:200 $\\ne$ current_txid:201 $\\Rightarrow$ Invisible",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "[CODE BLOCK]\ntestdb=# -- txid 201\ntestdb=# SELECT * FROM tbl;\n  name\n--------\n Jekyll\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "If the updated tuples are visible from other transactions before they are committed,\nthis is known  as Dirty Reads, also known as wr-conflicts.\nHowever, as shown above, Dirty Reads do not occur in any isolation levels in PostgreSQL.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "In the following, the behaviors of SELECT commands of T7 in both isolation levels are described.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "When txid 201 is in the READ COMMITTED level,\ntxid 200 is treated as COMMITTED because the transaction snapshot is ‘201:201:’.\nTherefore, Tuple_1 is invisible by Rule 10 and Tuple_2 is visible by Rule 6.\nThe SELECT command returns ‘Hyde’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "Rule10(Tuple_1): Status(t_xmin:199) = COMMITTED $\\wedge$ Status(t_xmax:200) = COMMITTED $\\wedge$ Snapshot(t_xmax:200) $\\ne$ active $\\Rightarrow$ Invisible",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "Rule6(Tuple_2): Status(t_xmin:200) = COMMITTED $\\wedge$ t_xmax = INVALID $\\Rightarrow$ Visible",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "[CODE BLOCK]\ntestdb=# -- txid 201 (READ COMMITTED)\ntestdb=# SELECT * FROM tbl;\n name\n------\n Hyde\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "Note that the results of the SELECT commands, which are executed before and after txid 200 is committed, differ.\nThis is generally known as Non-Repeatable Reads.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "In contrast,\nwhen txid 201 is in the REPEATABLE READ level, txid 200 must be treated as IN_PROGRESS because the transaction snapshot is ‘200:200:’.\nTherefore, Tuple_1 is visible by Rule 9 and Tuple_2 is invisible by Rule 5.\nThe SELECT command returns ‘Jekyll’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "Note that Non-Repeatable Reads do not occur in the REPEATABLE READ (and SERIALIZABLE) level.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "Rule9(Tuple_1): Status(t_xmin:199) = COMMITTED $\\wedge$ Status(t_xmax:200) = COMMITTED $\\wedge$ Snapshot(t_xmax:200) = active $\\Rightarrow$ Visible",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "Rule5(Tuple_2): Status(t_xmin:200) = COMMITTED $\\wedge$ Snapshot(t_xmin:200) = active  $\\Rightarrow$ Invisible",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "[CODE BLOCK]\ntestdb=# -- txid 201 (REPEATABLE READ)\ntestdb=# SELECT * FROM tbl;\n  name\n--------\n Jekyll\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "To obtain the status of a transaction,\nPostgreSQL internally provides three functions: TransactionIdIsInProgress, TransactionIdDidCommit, and TransactionIdDidAbort.\nThese functions are implemented to reduce frequent access to the clog, such as caches.\nHowever, bottlenecks will occur if they are executed whenever each tuple is checked.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "To deal with this issue, PostgreSQL uses hint bits, which are shown blow:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 31,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "[CODE BLOCK]\n#define HEAP_XMIN_COMMITTED       0x0100   /* t_xmin committed */\n#define HEAP_XMIN_INVALID         0x0200   /* t_xmin invalid/aborted */\n#define HEAP_XMAX_COMMITTED       0x0400   /* t_xmax committed */\n#define HEAP_XMAX_INVALID         0x0800   /* t_xmax invalid/aborted */",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 32,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.1. Visibility Check",
    "text": "When reading or writing a tuple, PostgreSQL sets hint bits to the t_informask of the tuple if possible.\nFor example, assume that PostgreSQL checks the status of the t_xmin of a tuple and obtains the status COMMITTED.\nIn this case, PostgreSQL sets a hint bit HEAP_XMIN_COMMITTED to the t_infomask of the tuple.\nIf hint bits are already set, TransactionIdDidCommit and TransactionIdDidAbort are no longer needed.\nTherefore, PostgreSQL can efficiently check the statuses of both t_xmin and t_xmax of each tuple.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 33,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.2. Phantom Reads in PostgreSQL’s REPEATABLE READ Level",
    "text": "REPEATABLE READ as defined in the ANSI SQL-92 standard allows Phantom Reads.\nHowever, PostgreSQL’s implementation does not allow them.\nIn principle, SI does not allow Phantom Reads.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 34,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.2. Phantom Reads in PostgreSQL’s REPEATABLE READ Level",
    "text": "Assume that two transactions, i.e. Tx_A and Tx_B, are running concurrently.\nTheir isolation levels are READ COMMITTED and REPEATABLE READ, and their txids are 100 and 101, respectively.\nFirst, Tx_A inserts a tuple.\nThen, it is committed.\nThe t_xmin of the inserted tuple is 100.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 35,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.2. Phantom Reads in PostgreSQL’s REPEATABLE READ Level",
    "text": "Next, Tx_B executes a SELECT command;\nhowever, the tuple inserted by Tx_A is invisible by Rule 5.\nThus, Phantom Reads do not occur.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 36,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.2. Phantom Reads in PostgreSQL’s REPEATABLE READ Level",
    "text": "[CODE BLOCK]\ntestdb=# -- Tx_A: txid 100\ntestdb=# START TRANSACTION\ntestdb-#  ISOLATION LEVEL READ COMMITTED;\nSTART TRANSACTION\ntestdb=# SELECT txid_current();\n txid_current\n--------------\n          100\n(1 row)\n\ntestdb=# INSERT INTO tbl(id, data)\n                VALUES (1,'phantom');\nINSERT 1\ntestdb=# COMMIT;\nCOMMIT",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 37,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.7.2. Phantom Reads in PostgreSQL’s REPEATABLE READ Level",
    "text": "[CODE BLOCK]\ntestdb=# -- Tx_B: txid 101\ntestdb=# START TRANSACTION\ntestdb-#  ISOLATION LEVEL REPEATABLE READ;\nSTART TRANSACTION\ntestdb=# SELECT txid_current();\n txid_current\n--------------\n          101\n(1 row)\n\n\n\n\n\n\ntestdb=# SELECT * FROM tbl WHERE id=1;\n id | data\n----+------\n(0 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:23.833618"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "A Lost Update, also known as a ww-conflict,\nis an anomaly that occurs when concurrent transactions update the same rows,\nand it must be prevented in both the REPEATABLE READ and SERIALIZABLE levels.\n(Note that the READ COMMITTED level does not need to prevent Lost Updates.)\nThis section describes how PostgreSQL prevents Lost Updates and shows examples.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.1. Behavior of Concurrent UPDATE Commands",
    "text": "When an UPDATE command is executed, the function ExecUpdate is internally invoked.\nThe pseudocode of the ExecUpdate is shown below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.1. Behavior of Concurrent UPDATE Commands",
    "text": "[CODE BLOCK]\n(1)   FOR each row that will be updated by this UPDATE command\n(2)        WHILE true\n\n                /*\n                 * The First Block\n                 */\n(3)             IF the target row is 'being updated' THEN\n(4)\t             WAIT for the termination of the transaction that updated the target row\n\n(5)                  IF (the status of the terminated transaction is COMMITTED)\n   \t               AND (the isolation level of this transaction is REPEATABLE READ or SERIALIZABLE) THEN\n(6)\t                  ABORT this transaction  /* First-Updater-Win */\n                     ELSE\n(7)                       GOTO step (2)\n                     END IF\n\n                /*\n                 * The Second Block\n                 */\n(8)             ELSE IF the target row has been updated by another concurrent transaction THEN\n(9)                  IF (the isolation level of this transaction is READ COMMITTED THEN\n(10)                      UPDATE the target row\n                     ELSE\n(11)                      ABORT this transaction  /* First-Updater-Win */\n                     END IF\n\n                /*\n                 * The Third Block\n                 */\n                ELSE  /* The target row is not yet modified               */\n                      /* or has been updated by a terminated transaction. */\n(12)                  UPDATE the target row\n                END IF\n           END WHILE\n      END FOR",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.1. Behavior of Concurrent UPDATE Commands",
    "text": "Get each row that will be updated by this UPDATE command.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.1. Behavior of Concurrent UPDATE Commands",
    "text": "Repeat the following process until the target row has been updated (or this transaction is aborted).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.1. Behavior of Concurrent UPDATE Commands",
    "text": "If the target row is being updated, go to step (3); otherwise, go to step (8).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.1. Behavior of Concurrent UPDATE Commands",
    "text": "Wait for the termination of the transaction that updated the target row,  because PostgreSQL uses first-updater-win scheme in SI.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.1. Behavior of Concurrent UPDATE Commands",
    "text": "If the status of the transaction that updated the target row is COMMITTED and the isolation level of this transaction is REPEATABLE READ (or SERIALIZABLE), go to step (6); otherwise, go to step (7).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.1. Behavior of Concurrent UPDATE Commands",
    "text": "Go to step (2) and attempt to update the target row in the next round.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.1. Behavior of Concurrent UPDATE Commands",
    "text": "If the target row has been updated by another concurrent transaction, go to step (9); otherwise, go to step (12).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.1. Behavior of Concurrent UPDATE Commands",
    "text": "If the isolation level of this transaction is READ COMMITTED, go to step (10); otherwise, go to step (11).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.1. Behavior of Concurrent UPDATE Commands",
    "text": "UPDATE the target row, and go to step (1), because the target row is not yet modified or has been updated by a terminated transaction, i.e. there is ww-conflict.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.1. Behavior of Concurrent UPDATE Commands",
    "text": "This function performs update operations for each of the target rows.\nIt has a while loop to update each row,\nand the inside of the while loop branches to three blocks according to the conditions shown in Figure 5.11.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.1. Behavior of Concurrent UPDATE Commands",
    "text": "[1] The target row is being updated (Figure 5.11[1])\n‘Being updated’ means that the row is being updated by another concurrent transaction and its transaction has not terminated.\n\nIn this case, the current transaction must wait for termination of the transaction that updated the target row\nbecause PostgreSQL’s SI uses the first-updater-win scheme.\n\nFor example, assume that transactions Tx_A and Tx_B run concurrently,\nand Tx_B attempts to update a row;\nhowever, Tx_A has updated it and is still in progress.\nIn this case, Tx_B waits for the termination of Tx_A.\n\nAfter the transaction that updated the target row commits,\nthe update operation of the current transaction proceeds.\n\nIf the current transaction is in the READ COMMITTED level, the target row will be updated;\notherwise (REPEATABLE READ or SERIALIZABLE), the current transaction is aborted immediately to prevent lost updates.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.1. Behavior of Concurrent UPDATE Commands",
    "text": "[2] The target row has been updated by the concurrent transaction (Figure 5.11[2])\nThe current transaction attempts to update the target tuple;\nhowever, the other concurrent transaction has updated the target row and has already been committed.\n\nIn this case,\nif the current transaction is in the READ COMMITTED level, the target row will be updated;\notherwise, the current transaction is aborted immediately to prevent lost updates.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.1. Behavior of Concurrent UPDATE Commands",
    "text": "[3] There is no conflict (Figure 5.11[3])\nWhen there is no conflict, the current transaction can update the target row.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.1. Behavior of Concurrent UPDATE Commands",
    "text": "As mentioned in this section, PostgreSQL’s concurrency control based on SI uses the first-updater-win scheme to avoid lost update anomalies.\nIn contrast, as explained in the next section, PostgreSQL’s SSI uses the first-committer-win scheme to avoid serialization anomalies.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.2. Examples",
    "text": "Three examples are shown in the following.\nThe first and second examples show behaviours when the target row is being updated,\nand the third example shows the behaviour when the target row has been updated.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.2. Examples",
    "text": "Transactions Tx_A and Tx_B update the same row in the same table,\nand their isolation level is READ COMMITTED.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.2. Examples",
    "text": "[CODE BLOCK]\ntestdb=# -- Tx_A\ntestdb=# START TRANSACTION\ntestdb-#    ISOLATION LEVEL READ COMMITTED;\nSTART TRANSACTION\n\n\ntestdb=# UPDATE tbl SET name = 'Hyde';\nUPDATE 1\n\n\n\n\n\ntestdb=# COMMIT;\nCOMMIT",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.2. Examples",
    "text": "[CODE BLOCK]\ntestdb=#\ntestdb=# -- Tx_B\ntestdb=# START TRANSACTION\ntestdb-#    ISOLATION LEVEL READ COMMITTED;\nSTART TRANSACTION\n\n\ntestdb=# UPDATE tbl SET name = 'Utterson';\n\n\n(this transaction is being blocked)\n\n\nUPDATE 1",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.2. Examples",
    "text": "After executing the UPDATE command,\nTx_B should wait for the termination of Tx_A,\nbecause the target tuple is being updated by Tx_A  (Step (4) in ExecUpdate).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.2. Examples",
    "text": "After Tx_A is committed,\nTx_B attempts to update the target row (Step (7) in ExecUpdate).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.2. Examples",
    "text": "In the second round of ExecUpdate,\nthe target row is updated again by Tx_B\n(Steps (2),(8),(9),(10) in ExecUpdate).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.2. Examples",
    "text": "Tx_A and Tx_B update the same row in the same table,\nand their isolation levels are READ COMMITTED and REPEATABLE READ, respectively.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.2. Examples",
    "text": "[CODE BLOCK]\ntestdb=# -- Tx_A\ntestdb=# START TRANSACTION\ntestdb-#    ISOLATION LEVEL READ COMMITTED;\nSTART TRANSACTION\n\n\ntestdb=# UPDATE tbl SET name = 'Hyde';\nUPDATE 1\n\n\n\n\n\ntestdb=# COMMIT;\nCOMMIT",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.2. Examples",
    "text": "[CODE BLOCK]\ntestdb=#\ntestdb=# -- Tx_B\ntestdb=# START TRANSACTION\ntestdb-#    ISOLATION LEVEL REPEATABLE READ;\nSTART TRANSACTION\n\n\ntestdb=# UPDATE tbl SET name = 'Utterson';\n\n\n(this transaction is being blocked)\n\n\nERROR:couldn't serialize access due to concurrent update",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.2. Examples",
    "text": "After executing the UPDATE command, Tx_B should wait for the termination of Tx_A (Step (4) in ExecUpdate).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.2. Examples",
    "text": "After Tx_A is committed, Tx_B is aborted to resolve conflict\nbecause the target row has been updated and the isolation level of this transaction is REPEATABLE READ\n(Steps (5) and (6) in ExecUpdate).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.2. Examples",
    "text": "Tx_B (REPEATABLE READ) attempts to update the target row that has been updated by the committed Tx_A.\nIn this case, Tx_B is aborted (Steps (2),(8),(9), and (11) in ExecUpdate).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 31,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.2. Examples",
    "text": "[CODE BLOCK]\ntestdb=# -- Tx_A\ntestdb=# START TRANSACTION\ntestdb-#    ISOLATION LEVEL READ COMMITTED;\nSTART TRANSACTION\n\n\ntestdb=# UPDATE tbl SET name = 'Hyde';\nUPDATE 1\n\ntestdb=# COMMIT;\nCOMMIT",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 32,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.8.2. Examples",
    "text": "[CODE BLOCK]\ntestdb=#\ntestdb=#\ntestdb=# -- Tx_B\ntestdb=# START TRANSACTION\ntestdb-#    ISOLATION LEVEL REPEATABLE READ;\nSTART TRANSACTION\ntestdb=# SELECT * FROM tbl;\n  name\n--------\n Jekyll\n(1 row)\ntestdb=# UPDATE tbl SET name = 'Utterson';\nERROR:couldn't serialize access due to concurrent update",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:24.693212"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "Serializable Snapshot Isolation (SSI) has been embedded in SI since version 9.1 to realize a true SERIALIZABLE isolation level.\nSince the explanation of SSI is not simple, only an outline is explained.\nFor details,\nsee the original paper : “Serializable Snapshot Isolation in PostgreSQL”",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "In the following,\nthe technical terms shown in below are used without definitions.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "precedence graph (also known as dependency graph and serialization graph)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "If you are unfamiliar with these terms, see the references:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "Abraham Silberschatz, Henry F. Korth, and S. Sudarshan, “Database System Concepts”, McGraw-Hill Education, ISBN-13: 978-0073523323",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "Thomas M. Connolly, and Carolyn E. Begg, “Database Systems”, Pearson, ISBN-13: 978-0321523068",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.1. Basic Strategy for SSI Implementation",
    "text": "If a cycle is present in the precedence graph, there will be a serialization anomaly.\nThis can be explained using the simplest anomaly, write-skew.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.1. Basic Strategy for SSI Implementation",
    "text": "Figure 5.12(1) shows a schedule.\nHere, Transaction_A reads Tuple_B and Transaction_B reads Tuple_A.\nThen, Transaction_A writes Tuple_A and Transaction_B writes Tuple_B.\nIn this case, there are two rw-conflicts,\nand they make a cycle in the precedence graph of this schedule, as shown in Figure 5.12(2).\nThus, this schedule has a serialization anomaly, Write-Skew.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.1. Basic Strategy for SSI Implementation",
    "text": "Conceptually, there are three types of conflicts: wr-conflicts (Dirty Reads), ww-conflicts (Lost Updates), and rw-conflicts.\nHowever, wr- and ww-conflicts do not need to be considered because PostgreSQL prevents such conflicts, as shown in the previous sections.\nThus, SSI implementation in PostgreSQL only needs to consider rw-conflicts.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.1. Basic Strategy for SSI Implementation",
    "text": "PostgreSQL takes the following strategy for the SSI implementation:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.2. Implementing SSI in PostgreSQL",
    "text": "To realize the strategy described above,\nPostgreSQL has implemented many functions and data structures.\nHowever,\nhere we uses only two data structures: SIREAD locks and rw-conflicts, to describe the SSI mechanism.\nThey are stored in shared memory.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.2. Implementing SSI in PostgreSQL",
    "text": "For simplicity, some important data structures, such as SERIALIZABLEXACT, are omitted in this document.\nThus, the explanations of the functions, i.e. CheckForSerializableConflictOut, CheckForSerializableConflictIn, and PreCommit_CheckForSerializationFailure, are also extremely simplified.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.2. Implementing SSI in PostgreSQL",
    "text": "For example, we indicate which functions detect conflicts; however, how the conflicts are detected is not explained in detail.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.2. Implementing SSI in PostgreSQL",
    "text": "For detailed information, refer to the source code: src/backend/storage/lmgr/predicate.c.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.2. Implementing SSI in PostgreSQL",
    "text": "Assume that a transaction Tx has read tuple_1 and tuple_2 in Page_1. In this case, two tuple-level SIREAD locks are created. Next, Tx reads tuple_3, meaning all tuples in Page_1 have now been read. At this point, the tuple-level SIREAD locks on Page_1 are removed and created with a page-level SIREAD lock.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.2. Implementing SSI in PostgreSQL",
    "text": "Both the CheckForSerializableConflictOut and CheckForSerializableConflictIn functions, as well as the PreCommit_CheckForSerializationFailure function, which is invoked when the COMMIT command is executed in SERIALIZABLE mode, check serialization anomalies using the created rw-conflicts.\nIf they detect anomalies, only the first-committed transaction is committed and the other transactions are aborted\n(by the first-committer-win scheme).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.3. How SSI Performs",
    "text": "Here, we describe how SSI resolves Write-Skew anomalies.\nWe use a simple table ’tbl’ shown below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.3. How SSI Performs",
    "text": "[CODE BLOCK]\ntestdb=# CREATE TABLE tbl (id INT primary key, flag bool DEFAULT false);\ntestdb=# INSERT INTO tbl (id) SELECT generate_series(1,2000);\ntestdb=# ANALYZE tbl;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.3. How SSI Performs",
    "text": "Transactions Tx_A and Tx_B execute the following commands (Figure 5.14).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.3. How SSI Performs",
    "text": "Assume that all commands use index scan.\nTherefore, when the commands are executed,\nthey read both heap tuples and index pages,\neach of which contains the index tuple that points to the corresponding heap tuple.\nSee Figure 5.15.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.3. How SSI Performs",
    "text": "T1: Tx_A executes a SELECT command. This command reads a heap tuple (Tuple_2000) and one page of the primary key (Pkey_2).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.3. How SSI Performs",
    "text": "T2: Tx_B executes a SELECT command. This command reads a heap tuple (Tuple_1) and one page of the primary key (Pkey_1).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.3. How SSI Performs",
    "text": "T3: Tx_A executes an UPDATE command to update Tuple_1.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.3. How SSI Performs",
    "text": "T4: Tx_B executes an UPDATE command to update Tuple_2000.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.3. How SSI Performs",
    "text": "T6: Tx_B commits; however, it is aborted due to a Write-Skew anomaly.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.3. How SSI Performs",
    "text": "Figure 5.16 shows how PostgreSQL detects and resolves the Write-Skew anomaly described in the above scenario.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.3. How SSI Performs",
    "text": "T1:\nWhen executing the SELECT command of Tx_A, CheckForSerializableConflictOut creates SIREAD locks.\nIn this scenario, the function creates two SIREAD locks: L1 and L2.\n\n\nL1 and L2 are associated with Pkey_2 and Tuple_2000, respectively.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.3. How SSI Performs",
    "text": "T2:\nWhen executing the SELECT command of Tx_B,\nCheckForSerializableConflictOut creates two SIREAD locks: L3 and L4.\n\n\nL3 and L4 are associated with Pkey_1 and Tuple_1, respectively.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.3. How SSI Performs",
    "text": "T3:\nWhen executing the UPDATE command of Tx_A,\nboth CheckForSerializableConflictOut and CheckTargetForConflictsIN are invoked before and after ExecUpdate.\n\n\nIn this scenario, CheckForSerializableConflictOut does nothing.\n\n\nCheckForSerializableConflictIn creates rw-conflict C1,\nwhich is the conflict of both Pkey_1 and Tuple_1 between Tx_B and Tx_A,\nbecause both Pkey_1 and Tuple_1 were read by Tx_B and written by Tx_A.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.3. How SSI Performs",
    "text": "T4:\nWhen executing the UPDATE command of Tx_B,\nCheckForSerializableConflictIn creates rw-conflict C2,\nwhich is the conflict of both Pkey_2 and Tuple_2000 between Tx_A and Tx_B.\n\n\nIn this scenario,\nC1 and C2 create a cycle in the precedence graph;\nthus, Tx_A and Tx_B are in a non-serializable state.\nHowever, both transactions Tx_A and Tx_B have not been committed,\ntherefore CheckForSerializableConflictIn does not abort Tx_B.\nNote that this occurs because PostgreSQL’s SSI implementation is based on the first-committer-win scheme.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 31,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.3. How SSI Performs",
    "text": "T5:\nWhen Tx_A attempts to commit, PreCommit_CheckForSerializationFailure is invoked.\nThis function can detect serialization anomalies\nand can execute a commit action if possible.\nIn this scenario,\nTx_A is committed because Tx_B is still in progress.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 32,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.3. How SSI Performs",
    "text": "T6:\nWhen Tx_B attempts to commit,\nPreCommit_CheckForSerializationFailure detects a serialization anomaly\nand Tx_A has already been committed; thus, Tx_B is aborted.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 33,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.3. How SSI Performs",
    "text": "In addition,\nif the UPDATE command is executed by Tx_B after Tx_A has been committed (at T5),\nTx_B is immediately aborted\nbecause CheckForSerializableConflictIn invoked by Tx_B’s UPDATE command detects a serialization anomaly (Figure 5.17(1)).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 34,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.3. How SSI Performs",
    "text": "If the SELECT command is executed instead of COMMIT at T6,\nTx_B is immediately aborted\nbecause CheckForSerializableConflictOut invoked by Tx_B’s SELECT command detects a serialization anomaly (Figure 5.17(2)).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 35,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.3. How SSI Performs",
    "text": "This Wiki explains several more complex anomalies.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 36,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.4. False-Positive Serialization Anomalies",
    "text": "In SERIALIZABLE mode,\nthe serializability of concurrent transactions is always fully guaranteed\nbecause false-negative serialization anomalies are never detected.\nHowever, under some circumstances,\nfalse-positive anomalies can be detected;\ntherefore, users should keep this in mind when using SERIALIZABLE mode.\nIn the following, the situations in which PostgreSQL detects false-positive anomalies are described.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 37,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.4. False-Positive Serialization Anomalies",
    "text": "Figure 5.18 shows a scenario where a false-positive serialization anomaly occurs.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 38,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.4. False-Positive Serialization Anomalies",
    "text": "When using sequential scan,\nas mentioned in the explanation of SIREAD locks, PostgreSQL creates a relation level SIREAD lock.\nFigure 5.19(1) shows SIREAD locks and rw-conflicts when PostgreSQL uses sequential scan.\nIn this case, rw-conflicts C1 and C2, which are associated with the tbl’s SIREAD lock,\nare created,\nand they create a cycle in the precedence graph.\nThus, a false-positive Write-Skew anomaly is detected (and either Tx_A or Tx_B will be aborted even though there is no conflict).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 39,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.4. False-Positive Serialization Anomalies",
    "text": "Even when using index scan,\nif both transactions Tx_A and Tx_B get the same index SIREAD lock,\nPostgreSQL detects a false-positive anomaly.\nFigure 5.20 shows this situation.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 40,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.4. False-Positive Serialization Anomalies",
    "text": "Assume that the index page Pkey_1 contains two index items, one of which points to Tuple_1 and the other points to Tuple_2.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 41,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.4. False-Positive Serialization Anomalies",
    "text": "When Tx_A and Tx_B execute respective SELECT and UPDATE commands, Pkey_1 is read and written by both Tx_A and Tx_B.\nIn this case,\nrw-conflicts C1 and C2, both of which are associated with Pkey_1, create a cycle in the precedence graph;\nthus, a false-positive Write-Skew anomaly is detected.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 42,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.9.4. False-Positive Serialization Anomalies",
    "text": "(If Tx_A and Tx_B get the  SIREAD locks of different index pages,\na false-positive is not detected and both transactions can be committed.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:25.549555"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "PostgreSQL’s concurrency control mechanism requires the following maintenance processes:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:26.399939"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "The need for the first and second processes have been explained in Sections Section 5.3.2 and Section 5.4.3, respectively.\nThe third process is related to the transaction id wraparound problem, which is briefly described in the following subsection.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:26.399939"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 5: Concurrency Control",
    "section": null,
    "text": "In PostgreSQL, VACUUM processing is responsible for these processes,\nand it is described in Chapter 6.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:26.399939"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.10.1. FREEZE Processing",
    "text": "Assume that tuple Tuple_1 is inserted with a txid of 100,\ni.e. the t_xmin of Tuple_1 is 100.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:26.399939"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.10.1. FREEZE Processing",
    "text": "The server has been running for a very long period and Tuple_1 has not been modified.\nThe current txid is 2.1 billion + 100 and a SELECT command is executed.\nAt this time, Tuple_1 is visible because txid 100 is in the past.\nThen, the same SELECT command is executed; thus, the current txid is 2.1 billion + 101.\nHowever, Tuple_1 is no longer visible because txid 100 is in the future (Figure 5.21).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:26.399939"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.10.1. FREEZE Processing",
    "text": "This is the so called transaction wraparound problem in PostgreSQL.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:26.399939"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.10.1. FREEZE Processing",
    "text": "To deal with this problem,\nPostgreSQL introduced a concept called frozen txid, and implemented a process called FREEZE.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:26.399939"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.10.1. FREEZE Processing",
    "text": "In PostgreSQL, a frozen txid, which is a special reserved txid 2,\nis defined such that it is always older than all other txids.\nIn other words,\nthe frozen txid is always inactive and visible.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:26.399939"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.10.1. FREEZE Processing",
    "text": "The freeze process is invoked by the vacuum process.\nThe freeze process scans all table files and rewrites the t_xmin of tuples to the frozen txid(2)\nif the t_xmin value is older than the current txid minus the vacuum_freeze_min_age (the default is 50 million = 50,000,000).\nThis is explained in more detail in Chapter 6.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:26.399939"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.10.1. FREEZE Processing",
    "text": "For example,\nas can be seen in Figure 5.22 a),\nthe current txid is 50,002,500 and the freeze process is invoked by the VACUUM command.\nIn this case, the t_xmin of both Tuple_1 and Tuple_2 are rewritten to 2.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:26.399939"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql05/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 5: Concurrency Control",
    "section": "5.10.1. FREEZE Processing",
    "text": "In versions 9.4 or later, the XMIN_FROZEN bit is set to the t_infomask field of tuples\nrather than rewriting  the t_xmin of tuples to the frozen txid (Figure 5.22 b).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:26.399939"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "Vacuum processing performs the following tasks for specified tables or all tables in the database:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.103785"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "It is assumed that readers are familiar with following terms:\ndead tuples,\nfreezing txid,\nFSM,\nand the clog;\nif you are not, refer to  Chapter 5.\nVM is introduced in Section 6.2.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.103785"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "The following pseudocode describes vacuum processing.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.103785"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "[CODE BLOCK]\n// Phase 1: initializing\n\n(1)    FOR each table\n(2)      Acquire a ShareUpdateExclusiveLock lock for the target table\n\n         /* The first block */\n\n         // Phase 2: Scan Heap\n(3)      Scan all pages to get all dead tuples, and freeze old tuples if necessary\n         // Phase 3: Vacuuming Indexes\n(4)      Remove the index tuples that point to the respective dead tuples if exists\n\n         /* The second block */\n\n         // Phase 4: Vacuuming Heap\n(5)      FOR each page of the table\n(6)         Remove the dead tuples, and Reallocate the live tuples in the page\n(7)         Update FSM and VM\n         END FOR\n\n         /* The third block */\n\n         // Phase 5: Cleaning up indexes\n(8)      Clean up indexes\n         // Phase 6: Truncating heap\n(9)      Truncate the last page if possible\n(10)     Update both the statistics and system catalogs of the target table\n\n         Release the ShareUpdateExclusiveLock lock\n      END FOR\n\n      /* Post-processing */\n\n      // Phase 7: Final Cleaning\n(11)  Update statistics and system catalogs\n(12)  Remove both unnecessary files and pages of the clog if possible",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.104787"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "PostgreSQL internally divides the vacuum process into seven distinct phases.\nHowever, to make the overall vacuum process easier to understand, this document explains it using 3+1 simplified blocks introduced for clarity.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.104787"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "The accompanying pseudocode illustrates how these seven phases correspond to the 3+1 blocks.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.104787"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "The VACUUM command has supported the PARALLEL option since version 13.\nIf this option is set and there are multiple indexes created, the vacuuming index and cleaning index up phases are processed in parallel.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.104787"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "Note that this feature is only valid for the VACUUM command and is not supported by autovacuum.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.104787"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "The current phase of an active vacuum process can be identified by examining the phase column in the pg_stat_progress_vacuum view.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.104787"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "[CODE BLOCK]\ntestdb=# SELECT datname, relid, phase FROM pg_stat_progress_vacuum;\n datname | relid |     phase\n---------+-------+---------------\n testdb  | 16415 | scanning heap\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.104787"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.1.1. First Block",
    "text": "This block performs freeze processing and removes index tuples that point to dead tuples.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.104787"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.1.1. First Block",
    "text": "First,\nPostgreSQL scans a target table to build a list of dead tuples and freeze old tuples if possible.\nThe list is stored in the local memory called maintenance_work_mem.\nFreeze processing is described in Section 6.3.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.104787"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.1.1. First Block",
    "text": "After scanning,\nPostgreSQL removes index tuples by referring to the dead tuple list.\nFigure 6.1 shows an example of removing an index tuple that points to a dead tuple.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.104787"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.1.1. First Block",
    "text": "If maintenance_work_mem is full and scanning is incomplete,\nPostgreSQL proceeds to the next tasks, i.e. steps (4) to (7).\nThen, it goes back to step (3) and proceeds remainder scanning.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.104787"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.1.2. Second Block",
    "text": "This block removes dead tuples and updates both the FSM and VM on a page-by-page basis.\nFigure 6.2 shows an example:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.104787"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.1.2. Second Block",
    "text": "Assume that the table contains three pages.\nWe focus on the 0th page (i.e., the first page).\nThis page has three tuples. Tuple_2 is a dead tuple (Figure 6.1(1)).\nIn this case, PostgreSQL removes Tuple 2 and reorders the remaining tuples to repair fragmentation.\nThen, it updates both the FSM and VM of this page (Figure 6.1(2)).\nPostgreSQL continues this process until the last page.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.104787"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.1.2. Second Block",
    "text": "Note that unnecessary line pointers are not removed. They will be reused in the future.\nThis is because if line pointers are removed, all index tuples of the associated indexes must be updated.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.104787"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.1.3. Third Block",
    "text": "The third block performs the cleanup after the deletion of the indexes,\nand also updates the statistics and system catalogs related to vacuum processing for each target table.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.104787"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.1.3. Third Block",
    "text": "Additionally, if the last pages contains no tuples, they are truncated from the table file.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.104787"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.1.3. Third Block",
    "text": "To make this easier to understand, Figure 6.3 shows a slightly exaggerated example.\nIn the figure, there is no tuples on the 1st, 3rd, and 4th pages by vacuuming heap.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.104787"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.1.3. Third Block",
    "text": "During the truncating  heap, the 4th and 3rd pages are removed from the table file, reducing its size by 16KB (= 8KB $\\times$ 2 pages).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.104787"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.1.3. Third Block",
    "text": "Although the 1st page also contains no tuples, it is not removed1.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.104787"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.1.4. Post-processing",
    "text": "When vacuum processing is complete,\nPostgreSQL updates all the statistics and system catalogs related to vacuum processing.\nIt also removes unnecessary parts of the clog if possible (Section 6.4).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.104787"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.1.4. Post-processing",
    "text": "Vacuum processing uses a ring buffer, described in Section 8.5.\nTherefore, processed pages are not cached in the shared buffers.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.104787"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.1.4. Post-processing",
    "text": "To remove such pages, use the VACUUM FULL command, as explained in Section 6.6. ↩︎",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.104787"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "Vacuum processing is costly. Therefore, the VM was introduced in version 8.4 to reduce this cost.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.954160"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "The basic concept of the VM is simple.\nEach table has an individual visibility map that holds the visibility of each page in the table file.\nThe visibility of pages determines whether or not each page has dead tuples.\nVacuum processing can skip a page that does not have dead tuples by using the corresponding visibility map (VM).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.954160"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "Suppose that the table consists of three pages,\nand the 0th and 2nd pages contain dead tuples and the 1st page does not.\nThe VM of this table holds information about which pages contain dead tuples.\nIn this case, vacuum processing skips the 1st page by referring to the VM’s information.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.954160"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "Each VM is composed of one or more 8 KB pages, and this file is stored with the ‘vm’ suffix.\nAs an example, one table file whose relfilenode is 18751 with FSM (18751_fsm) and VM (18751_vm) files shown in the following.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.954160"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "[CODE BLOCK]\n$ cd $PGDATA\n$ ls -la base/16384/18751*\n-rw------- 1 postgres postgres  8192 Apr 21 10:21 base/16384/18751\n-rw------- 1 postgres postgres 24576 Apr 21 10:18 base/16384/18751_fsm\n-rw------- 1 postgres postgres  8192 Apr 21 10:18 base/16384/18751_vm",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.954160"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.2.1. Enhancement of VM",
    "text": "The VM was enhanced in version 9.6 to improve the efficiency of freeze processing.\nThe new VM shows page visibility and information about whether tuples are frozen or not in each page (Section 6.3.3).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:28.954160"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "Freeze processing, described in Section 5.10.1, has two modes.\nFor convenience, these modes are referred to as lazy mode and eager mode.\nIt is performed in either mode depending on certain conditions.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "Concurrent VACUUM is often called “lazy vacuum” internally.\nHowever, the lazy mode defined in this document is a mode of freeze processing.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "Freeze processing typically runs in lazy mode,\nbut eager mode is run when specific conditions are satisfied.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "In lazy mode,\nfreeze processing scans only pages that contain dead tuples using the respective VM of the target tables.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "In contrast,\neager mode scans all pages regardless of whether each page contains dead tuples or not.\nIt also updates system catalogs related to freeze processing and removes unnecessary parts of the clog if possible.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "Sections 6.3.1 and 6.3.2 describe these modes, respectively.\nSection 6.3.3 describes how to improve the freeze process in eager mode.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.1. Lazy Mode",
    "text": "When starting freeze processing,\nPostgreSQL calculates the $\\text{freezeLimit_txid}$ and freezes tuples whose t_xmin is less than the freezeLimit_txid.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.1. Lazy Mode",
    "text": "where OldestXmin is the oldest txid among currently running transactions.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.1. Lazy Mode",
    "text": "For example, if three transactions (txids 100, 101, and 102) are running when the VACUUM command is executed, OldestXmin is 100.\nIf no other transactions exist, OldestXmin  is the txid that executes this VACUUM command.\nHere, vacuum_freeze_min_age is a configuration parameter (the default is 50,000,000).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.1. Lazy Mode",
    "text": "Figure 6.5 shows a specific example.\nHere, Table_1 consists of three pages, and each page has three tuples.\nWhen the VACUUM command is executed, the current txid is 50,002,500 and there are no other transactions.\nIn this case, OldestXmin is 50,002,500; thus, the freezeLimit_txid is 2500.\nFreeze processing is executed as follows.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.1. Lazy Mode",
    "text": "0th page:\nThree tuples are frozen because all t_xmin values are less than the freezeLimit_txid.\nIn addition, Tuple_1 is removed in this vacuum process due to a dead tuple.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.1. Lazy Mode",
    "text": "1st page:\nThis page is skipped by referring to the VM.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.1. Lazy Mode",
    "text": "2nd page:\nTuple_7 and Tuple_8 are frozen; Tuple_7 is removed.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.1. Lazy Mode",
    "text": "Before completing the vacuum process,\nthe statistics related to vacuuming are updated,\ne.g.\npg_stat_all_tables’ n_live_tup, n_dead_tup,\nlast_vacuum, vacuum_count, etc.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.1. Lazy Mode",
    "text": "As shown in the above example,\nthe lazy mode might not be able to freeze tuples completely because it can skip pages.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.2. Eager Mode",
    "text": "The eager mode compensates for the defect of the lazy mode.\nIt scans all pages to inspect all tuples in tables,\nupdates relevant system catalogs,\nand removes unnecessary files and pages of the clog if possible.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.2. Eager Mode",
    "text": "The eager mode is performed when the following condition is satisfied:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.2. Eager Mode",
    "text": "In the condition above,\n$\\text{pg_database.datfrozenxid}$ represents the columns of the pg_database system catalog and holds the oldest frozen txid for each database.\nDetails are described later;\ntherefore, we assume that the value of all pg_database.datfrozenxid are 1821\n(which is the initial value just after installation of a new database cluster in version 9.5).\nVacuum_freeze_table_age is a configuration parameter (the default is 150,000,000).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.2. Eager Mode",
    "text": "Figure 6.6 shows a specific example.\nIn Table_1, both Tuple_1 and Tuple_7 have been removed.\nTuple_10 and Tuple_11 have been inserted into the 2nd page.\nWhen the VACUUM command is executed,\nthe current txid is 150,002,000, and there are no other transactions.\nThus, OldestXmin is 150,002,000 and the freezeLimit_txid is 100,002,000.\nIn this case,\nthe above condition is satisfied because",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.2. Eager Mode",
    "text": "Therefore, the freeze processing performs in eager mode as follows.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.2. Eager Mode",
    "text": "(Note that this is the behavior of versions 9.5 or earlier;\nthe latest behavior is described in Section 6.3.3.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.2. Eager Mode",
    "text": "0th page:\nTuple_2 and Tuple_3 have been checked even though all tuples have been frozen.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.2. Eager Mode",
    "text": "1st page:\nThree tuples in this page have been frozen because all t_xmin values are less than the freezeLimit_txid.\nNote that this page is skipped in lazy mode.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.2. Eager Mode",
    "text": "2nd page:\nTuple_10 has been frozen. Tuple_11 has not.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.2. Eager Mode",
    "text": "After freezing each table,\nthe pg_class.relfrozenxid of the target table is updated.\nThe pg_class is a system catalog,\nand each pg_class.relfrozenxid column holds the latest frozen xid of the corresponding table.\nIn this example,\nTable_1’s pg_class.relfrozenxid is updated to the current freezeLimit_txid (i.e. 100,002,000),\nwhich means that all tuples whose t_xmin is less than 100,002,000 in Table_1 are frozen.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.2. Eager Mode",
    "text": "Before completing the vacuum process,\npg_database.datfrozenxid is updated if necessary.\nEach pg_database.datfrozenxid column holds the minimum pg_class.relfrozenxid in the corresponding database.\nFor example, if only Table_1 is frozen in eager mode,\nthe pg_database.datfrozenxid of this database is not updated\nbecause the pg_class.relfrozenxid of other relations\n(both other tables and system catalogs that can be seen from the current database) have not been changed (Figure 6.7(1)).\nIf all relations in the current database are frozen in eager mode,\nthe pg_database.datfrozenxid of the database is updated\nbecause all relations’ pg_class.relfrozenxid for this database are updated to the current freezeLimit_txid (Figure 6.7(2)).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.2. Eager Mode",
    "text": "In the following,\nthe first query shows the relfrozenxids of all visible relations in the ’testdb’ database,\nand the second query shows the pg_database.datfrozenxld of the ’testdb’ database.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.2. Eager Mode",
    "text": "[CODE BLOCK]\ntestdb=# VACUUM table_1;\nVACUUM\ntestdb=# SELECT n.nspname as \"Schema\", c.relname as \"Name\", c.relfrozenxid\n             FROM pg_catalog.pg_class c\n             LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n             WHERE c.relkind IN ('r','')\n                   AND n.nspname <> 'information_schema' AND n.nspname !~ '^pg_toast'\n                   AND pg_catalog.pg_table_is_visible(c.oid)\n                   ORDER BY c.relfrozenxid::text::bigint DESC;\n   Schema   |            Name         | relfrozenxid\n------------+-------------------------+--------------\n public     | table_1                 |    100002000\n public     | table_2                 |         1846\n pg_catalog | pg_database             |         1827\n pg_catalog | pg_user_mapping         |         1821\n pg_catalog | pg_largeobject          |         1821\n\n...\n\n pg_catalog | pg_transform            |         1821\n(57 rows)\n\ntestdb=# SELECT datname, datfrozenxid FROM pg_database WHERE datname = 'testdb';\n datname | datfrozenxid\n---------+--------------\n testdb  |         1821\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.2. Eager Mode",
    "text": "The VACUUM command with the FREEZE option forces all txids in the specified tables to be frozen.\nThis is performed in eager mode, but the freezeLimit is set to OldestXmin (not ‘OldestXmin - vacuum_freeze_min_age’).\nFor example, when the VACUUM FULL command is executed by txid 5000 and there are no other running transactions, OldesXmin is set to 5000 and txids that are less than 5000 are frozen.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.3. Improving Freeze Processing in Eager Mode",
    "text": "The eager mode in versions 9.5 or earlier is not efficient\nbecause always scans all pages.\nFor instance, in the example of Section 6.3.2,\nthe 0th page is scanned even though all tuples in its page are frozen.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 31,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.3. Improving Freeze Processing in Eager Mode",
    "text": "To deal with this issue,\nthe VM and freeze process have been improved in version 9.6.\nAs mentioned in Section 6.2.1,\nthe new VM has information about whether all tuples are frozen in each page.\nWhen freeze processing is executed in eager mode,\npages that contain only frozen tuples can be skipped.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 32,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.3.3. Improving Freeze Processing in Eager Mode",
    "text": "Figure 6.8 shows an example.\nWhen freezing this table,\nthe 0th page is skipped by referring to the VM’s information.\nAfter freezing the 1st page, the associated VM information is updated\nbecause all tuples of this page have been frozen.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:29.809692"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "The clog, described in Section 5.4, stores transaction states.\nWhen pg_database.datfrozenxid is updated,\nPostgreSQL attempts to remove unnecessary clog files.\nNote that corresponding clog pages are also removed.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:30.659489"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "Figure 6.9 shows an example.\nIf the minimum pg_database.datfrozenxid is contained in the clog file ‘0002’,\nthe older files (‘0000’ and ‘0001’)  can be removed\nbecause all transactions stored in those files can be treated as frozen txids in the whole database cluster.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:30.659489"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "The following shows the actual output of pg_database.datfrozenxid and the clog files:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:30.659489"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "[CODE BLOCK]\n$ psql testdb -c \"SELECT datname, datfrozenxid FROM pg_database\"\n  datname  | datfrozenxid\n-----------+--------------\n template1 |      7308883\n template0 |      7556347\n postgres  |      7339732\n testdb    |      7506298\n(4 rows)\n\n$ ls -la -h data/pg_xact/\t# In versions 9.6 or earlier, \"ls -la -h data/pg_clog/\"\ntotal 316K\ndrwx------  2 postgres postgres   28 Dec 29 17:15 .\ndrwx------ 20 postgres postgres 4.0K Dec 29 17:13 ..\n-rw-------  1 postgres postgres 256K Dec 29 17:15 0006\n-rw-------  1 postgres postgres  56K Dec 29 17:15 0007",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:30.659489"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "Vacuum processing has been automated with the autovacuum daemon,\nmaking the operation of PostgreSQL extremely easy.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:31.510179"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "The autovacuum daemon periodically invokes several autovacuum_worker processes.\nBy default, it wakes every 1 minute (defined by autovacuum_naptime) and invokes three workers (defined by autovacuum_max_works).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:31.510179"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "The autovacuum workers invoked by the autovacuum daemon perform vacuum processing concurrently for respective tables, gradually and with minimal impact on database activity.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:31.510179"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.5.1. Conditions for autovacuum to run",
    "text": "The autovacuum process runs for a target table if any of the following conditions are satisfied:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:31.510179"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.5.1. Conditions for autovacuum to run",
    "text": "The current txid precedes the following expression:\n$$\n\\text{relfrozenxid} + \\text{autovacuum_freeze_max_age}\n$$\nwhere\n$\\text{relfrozenxid}$ is the relfrozenxid value of the target table that is defined in the pg_class, and autovacuum_freeze_max_age (the default is 200,000,000) is a configuration parameter.\n\nIf this condition is satisfied, the autovacuum process runs for the target table to perform freeze processing.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:31.510179"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.5.1. Conditions for autovacuum to run",
    "text": "The number of dead tuples is greater than the following expression:\n$$\n\\text{autovacuum_vacuum_threshold} + \\text{autovacuum_vacuum_scale_factor} \\times \\text{reltuples}\n$$\nwhere autovacuum_vacuum_threshold (the default is 50) and\nautovacuum_vacuum_scale_factor (the default is 0.2) are configuration parameters, $\\text{reltuples}$ is the number of tuples in the target table.\n\n\nFor example, if the target table has 10,000 tuples and 2,100 dead tuples,\nthe autovacuum process runs for the target table, because\n$$\n2100 \\gt 50 + 0.2 \\times 10000.\n$$",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:31.510179"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.5.1. Conditions for autovacuum to run",
    "text": "The number of inserted tuples in the target table is greater than the following expression:\n$$\n\\text{autovacuum_vacuum_insert_threshold} + \\text{autovacuum_vacuum_insert_scale_factor} \\times \\text{reltuples}\n$$\nwhere\nautovacuum_vacuum_insert_threshold (the default is 1000)\nand\nautovacuum_vacuum_insert_scale_factor (the default is 0.2)\nare configuration parameters, $\\text{reltuples}$ is the number of tuples in the target table.\n\n\nFor example,\nif the target table has 10,000 tuples and 3,010 inserted tuples,\nthe autovacuum process runs for the target table, because\n$$\n3010 \\gt 1000 + 0.2 \\times 10000.\n$$\n\nThis condition has been added since version 13.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:31.510179"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.5.1. Conditions for autovacuum to run",
    "text": "In addition,\nif the following condition is satisfied for the target table, the autovacuum process will also perform analyze processing.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:31.510179"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.5.1. Conditions for autovacuum to run",
    "text": "where\n$\\text{mod_since_analyze}$ is the number of modified tuples (by INSERT, DELETE or UPDATE) since the previous analyze processing,\nautovacuum_analyze_threshold (the default is 50)\nand\nautovacuum_analyze_scale_factor (the default is 0.1)\nare configuration parameters, $\\text{reltuples}$ is the number of tuples in the target table.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:31.510179"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.5.1. Conditions for autovacuum to run",
    "text": "For example, if the target table has 10,000 tuples and 1,100 modified tuples since the previous analyze processing,\nthe autovacuum process will run, because\n$$\n1100 \\gt 50 + 0.1 \\times 10000.\n$$",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:31.510179"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.5.1. Conditions for autovacuum to run",
    "text": "The relation_needs_vacanalyze() function determines whether target tables need to be vacuumed or analyzed.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:31.510179"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.5.2. Maintenance tips",
    "text": "As frequently mentioned, table bloat is one of the most annoying things in managing PostgreSQL.\nSeveral things can cause that problem, and Autovacuum is one of them.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:31.510179"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.5.2. Maintenance tips",
    "text": "The autovacuum runs when the number of dead tuples is greater than: 250 for 1,000 relations, 20,050 for 100,000 relations, and 20,000,050 for 100,000,000 relations.\nIt is clear from these examples that the more tuples a table has, the less often autovacuum runs.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:31.510179"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.5.2. Maintenance tips",
    "text": "A good known tip is to reduce the autovacuum_vacuum_scale_factor value.\nIn fact, its default value (0.2) is too large for big tables.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:31.510179"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.5.2. Maintenance tips",
    "text": "PostgreSQL can set an appropriate autovacuum_vacuum_scale_factor in each table using ALTER TABLE command.\nFor example, the following example shows how to set the new value of autovacuum_vacuum_scale_factor for the pgbench_accounts table.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:31.510179"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.5.2. Maintenance tips",
    "text": "[CODE BLOCK]\npostgres=# ALTER TABLE pgbench_accounts SET (autovacuum_vacuum_scale_factor = 0.05);\nALTER TABLE",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:31.510179"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.5.2. Maintenance tips",
    "text": "To ensure that Autovacuum runs for target tables independently of the number of their tuples, specific settings can be applied.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:31.510179"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.5.2. Maintenance tips",
    "text": "For instance, if Autovacuum processing is required whenever the number of dead tuples reaches 10,000,\nthe following storage parameters can be configured for the table.\nWith these settings, the Autovacuum process triggers vacuuming each time the threshold of 10,000 dead tuples is reached:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:31.510179"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": "6.5.2. Maintenance tips",
    "text": "[CODE BLOCK]\npostgres=# ALTER TABLE pgbench_accounts SET (autovacuum_vacuum_threshold = 10000);\nALTER TABLE\npostgres=# ALTER TABLE pgbench_accounts SET (autovacuum_vacuum_scale_factor = 0.0);\nALTER TABLE",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:31.510179"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "Although Concurrent VACUUM is essential for operation, it is not sufficient.\nFor example, it cannot reduce the size of a table even if many dead tuples are removed.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:32.366464"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "Figure 6.10 shows an extreme example.\nSuppose that a table consists of three pages, and each page contains six tuples.\nThe following DELETE command is executed to remove tuples, and the VACUUM command is executed to remove dead tuples:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:32.366464"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "[CODE BLOCK]\ntestdb=# DELETE FROM tbl WHERE id % 6 != 0;\ntestdb=# VACUUM tbl;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:32.366464"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "The dead tuples are removed; but the table size is not reduced.\nThis is both a waste of disk space and has a negative impact on database performance.\nFor instance, in the above example, when three tuples in the table are read, three pages must be loaded from disk.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:32.366464"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "To deal with this situation, PostgreSQL provides the Full VACUUM mode.\nFigure 6.11 shows an outline of this mode.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:32.366464"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "[1] Create new table file: Figure 6.11(1)\nWhen the VACUUM FULL command is executed for a table,\nPostgreSQL first acquires the AccessExclusiveLock lock for the table\nand creates a new table file whose size is 8 KB.\nThe AccessExclusiveLock lock prevents other users from accessing the table.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:32.366464"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "[2] Copy live tuples to the new table: Figure 6.11(2)\nPostgreSQL copies only live tuples within the old table file to the new table.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:32.366464"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "[3] Remove the old file, rebuild indexes, and update the statistics, FSM, and VM: Figure 6.11(3)\nAfter copying all live tuples, PostgreSQL removes the old file, rebuilds all associated table indexes,\nupdates both the FSM and VM of this table, and updates associated statistics and system catalogs.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:32.366464"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "The pseudocode of the Full VACUUM is shown in below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:32.366464"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "[CODE BLOCK]\n(1)  FOR each table\n(2)     Acquire AccessExclusiveLock lock for the table\n(3)     Create a new table file\n(4)     FOR each live tuple in the old table\n(5)        Copy the live tuple to the new table file\n(6)        Freeze the tuple IF necessary\n        END FOR\n(7)     Remove the old table file\n(8)     Rebuild all indexes\n(9)     Update FSM and VM\n(10)    Update statistics\n        Release AccessExclusiveLock lock\n     END FOR\n(11) Remove unnecessary clog files and pages if possible",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:32.367012"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "Two points should be considered when using the VACUUM FULL command:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:32.367012"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "Nobody can access(read/write) the table when Full VACUUM is processing.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:32.367012"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "At most twice the disk space of the table is used temporarily;\ntherefore, it is  necessary to check the remaining disk capacity when a huge table is processed.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:32.367012"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "There is no universal answer to the question of when to execute VACUUM FULL.\nHowever, the pg_freespacemap extension can provide useful insights.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:32.367012"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "The following query calculates the average free space ratio for a specific table:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:32.367012"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "[CODE BLOCK]\ntestdb=# CREATE EXTENSION pg_freespacemap;\nCREATE EXTENSION\n\ntestdb=# SELECT count(*) as \"number of pages\",\n       pg_size_pretty(cast(avg(avail) as bigint)) as \"Av. freespace size\",\n       round(100 * avg(avail)/8192 ,2) as \"Av. freespace ratio\"\n       FROM pg_freespace('accounts');\n number of pages | Av. freespace size | Av. freespace ratio\n-----------------+--------------------+---------------------\n            1640 | 99 bytes           |                1.21\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:32.367012"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "If most tuples are deleted and the VACUUM command is executed, many pages may become empty (e.g., 86.97% free space),\nbut the total number of pages remains unchanged, indicating that the table file has not been compacted:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:32.367012"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "[CODE BLOCK]\ntestdb=# DELETE FROM accounts WHERE aid %10 != 0 OR aid < 100;\nDELETE 90009\n\ntestdb=# VACUUM accounts;\nVACUUM\n\ntestdb=# SELECT count(*) as \"number of pages\",\n       pg_size_pretty(cast(avg(avail) as bigint)) as \"Av. freespace size\",\n       round(100 * avg(avail)/8192 ,2) as \"Av. freespace ratio\"\n       FROM pg_freespace('accounts');\n number of pages | Av. freespace size | Av. freespace ratio\n-----------------+--------------------+---------------------\n            1640 | 7124 bytes         |               86.97\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:32.367012"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "To inspect the free space ratio for each page of a table, the following query can be used:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:32.367012"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "[CODE BLOCK]\ntestdb=# SELECT *, round(100 * avail/8192 ,2) as \"freespace ratio\"\n                FROM pg_freespace('accounts');\n blkno | avail | freespace ratio\n-------+-------+-----------------\n     0 |  7904 |           96.00\n     1 |  7520 |           91.00\n     2 |  7136 |           87.00\n     3 |  7136 |           87.00\n     4 |  7136 |           87.00\n     5 |  7136 |           87.00\n....",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:32.367012"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "In such a situation, running VACUUM FULL compacts the table file:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:32.367012"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "[CODE BLOCK]\ntestdb=# VACUUM FULL accounts;\nVACUUM\ntestdb=# SELECT count(*) as \"number of blocks\",\n       pg_size_pretty(cast(avg(avail) as bigint)) as \"Av. freespace size\",\n       round(100 * avg(avail)/8192 ,2) as \"Av. freespace ratio\"\n       FROM pg_freespace('accounts');\n number of pages | Av. freespace size | Av. freespace ratio\n-----------------+--------------------+---------------------\n             164 | 0 bytes            |                0.00\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:32.367012"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql06/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 6: VACUUM Processing",
    "section": null,
    "text": "By compacting the table, VACUUM FULL reduces the physical size of the table file, making it more efficient.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:32.367012"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": null,
    "text": "The HOT was implemented in version 8.3 to effectively use the pages of both index and table when the updated row is stored in the same table page that stores the old row.\nHOT also reduces the need for VACUUM processing.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.072421"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": null,
    "text": "Since the details of HOT are described in the README.HOT file in the source code directory,\nthis chapter only provides a brief introduction to HOT.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.072421"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": null,
    "text": "Section 7.1.1 first describes how to update a row without HOT to clarify the issues that HOT resolves.\nSection 7.1.2 then describes how HOT works.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.072421"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": "7.1.1. Update a Row Without HOT",
    "text": "Assume that the table ’tbl’ has two columns: ‘id’ and ‘data’; ‘id’ is the primary key of ’tbl’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.072421"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": "7.1.1. Update a Row Without HOT",
    "text": "[CODE BLOCK]\ntestdb=# \\d tbl\n                Table \"public.tbl\"\n Column |  Type   | Collation | Nullable | Default\n--------+---------+-----------+----------+---------\n id     | integer |           | not null |\n data   | text    |           |          |\nIndexes:\n    \"tbl_pkey\" PRIMARY KEY, btree (id)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.072421"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": "7.1.1. Update a Row Without HOT",
    "text": "The table ’tbl’ has 1000 tuples; the last tuple, whose id is 1000, is stored in the 5th page of the table.\nThe last tuple is pointed by the corresponding index tuple, whose key is 1000 and whose tid is ‘(5, 1)’.\nSee Figure 7.1(a).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.072421"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": "7.1.1. Update a Row Without HOT",
    "text": "We consider how the last tuple is updated without HOT.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.072421"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": "7.1.1. Update a Row Without HOT",
    "text": "[CODE BLOCK]\ntestdb=# UPDATE tbl SET data = 'B' WHERE id = 1000;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.072421"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": "7.1.1. Update a Row Without HOT",
    "text": "In this case,\nPostgreSQL inserts not only the new table tuple but also the new index tuple into the index page.\nSee Figure 7.1(b).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.072421"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": "7.1.1. Update a Row Without HOT",
    "text": "The inserting of the index tuples consumes the index page space,\nand both the inserting and vacuuming costs of the index tuples are high.\nHOT reduces the impact of these issues.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.072421"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": "7.1.2. How HOT Performs",
    "text": "When a row is updated with HOT,\nif the updated row will be stored in the same table page that stores the old row,\nPostgreSQL does not insert the corresponding index tuple and sets the HEAP_HOT_UPDATED bit and the HEAP_ONLY_TUPLE bit to the t_informask2 fields of the old tuple and the new tuple, respectively.\nSee Figures. 7.2 and 7.3.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.072421"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": "7.1.2. How HOT Performs",
    "text": "For example, in this case, Tuple_1 and Tuple_2 are set to the HEAP_HOT_UPDATED bit and the HEAP_ONLY_TUPLE bit, respectively.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.072421"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": "7.1.2. How HOT Performs",
    "text": "In addition,\nthe HEAP_HOT_UPDATED and the HEAP_ONLY_TUPLE bits are used regardless of the pruning and the defragmentation processes, which are described in the following, are executed.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.072421"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": "7.1.2. How HOT Performs",
    "text": "In the following, a description of how PostgreSQL accesses the updated tuples using the index scan immediately after updating the tuples with HOT is given.\nSee Figure 7.4(a).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.072421"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": "7.1.2. How HOT Performs",
    "text": "In this case, PostgreSQL reads two tuples, Tuple_1 and Tuple_2,\nand decides which is visible using the concurrency control mechanism described in Chapter 5.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.072421"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": "7.1.2. How HOT Performs",
    "text": "However, a problem arises if the dead tuples in the table pages are removed.\nFor example, in Figure 7.4(a),\nif Tuple_1 is removed since it is a dead tuple, Tuple_2 cannot be accessed from the index.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.072421"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": "7.1.2. How HOT Performs",
    "text": "To resolve this problem, at an appropriate time,\nPostgreSQL redirects the line pointer that points to the old tuple to the line pointer that points to the new tuple.\nIn PostgreSQL, this processing is called pruning.\nFigure 7.4(b) depicts how PostgreSQL accesses the updated tuples after pruning.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.072421"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": "7.1.2. How HOT Performs",
    "text": "The pruning processing will be executed, if possible, when a SQL command is executed such as SELECT, UPDATE, INSERT and DELETE.\nThe exact execution timing is not described in this chapter because it is very complicated.\nThe details are described in the README.HOT file.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.072421"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": "7.1.2. How HOT Performs",
    "text": "PostgreSQL removes dead tuples if possible, as in the pruning process, at an appropriate time.\nIn the document of PostgreSQL, this processing is called defragmentation.\nFigure 7.5 depicts the defragmentation by HOT.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.072421"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": "7.1.2. How HOT Performs",
    "text": "Note that the cost of defragmentation is less than the cost of normal VACUUM processing\nbecause defragmentation does not involve removing the index tuples.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.072421"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": "7.1.2. How HOT Performs",
    "text": "Thus, using HOT reduces the consumption of both indexes and tables of pages;\nthis also reduces the number of tuples that the VACUUM processing has to process.\nTherefore, HOT has a positive influence on performance\nbecause it eventually reduces the number of insertions of the index tuples by updating and the necessity of VACUUM processing.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.072421"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": "7.1.2. How HOT Performs",
    "text": "To better understand HOT performance, we will describe cases where HOT is not available.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.072421"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": "7.1.2. How HOT Performs",
    "text": "When the updated tuple is stored in a different page from the page that stores the old tuple, the index tuple that points to the tuple must also be inserted in the index page. See Figure 7.6(a).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.072421"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": "7.1.2. How HOT Performs",
    "text": "When the key value of the index tuple is updated, a new index tuple must be inserted in the index page. See Figure 7.6(b).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.072421"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": null,
    "text": "To reduce the I/O (input/output) cost,\nindex-only scans (often called index-only access) directly use the index key without accessing the corresponding table pages when all of the target entries of the SELECT statement are included in the index key.\nThis technique is provided by almost all commercial RDBMS, such as DB2 and Oracle.\nPostgreSQL has introduced this option since version 9.2.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.924687"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": null,
    "text": "In the following,\nusing a specific example, a description of how index-only scans in PostgreSQL perform is given.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.924687"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": null,
    "text": "The assumptions of the example are explained below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.924687"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": null,
    "text": "[CODE BLOCK]\ntestdb=# \\d tbl\n      Table \"public.tbl\"\n Column |  Type   | Modifiers\n--------+---------+-----------\n id     | integer |\n name   | text    |\n data   | text    |\nIndexes:\n    \"tbl_idx\" btree (id, name)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.925205"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": null,
    "text": "Index\nThe table ’tbl’ has an index ’tbl_idx’, which is composed of two columns: ‘id’ and ’name’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.925205"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": null,
    "text": "Visibility\nAll tuples in the 0th page are always visible; the tuples in the 1st page are not always visible.\nNote that the visibility of each page is stored in the corresponding visibility map (VM),\nand the VM is described in Section 6.2.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.925205"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": null,
    "text": "Let us explore how PostgreSQL reads tuples when the following SELECT command is executed.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.925205"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": null,
    "text": "[CODE BLOCK]\ntestdb=# SELECT id, name FROM tbl WHERE id BETWEEN 18 and 19;\n id |  name\n----+--------\n 18 | Queen\n 19 | Boston\n(2 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.925205"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": null,
    "text": "This query gets data from two columns of the table, ‘id’ and ’name’, and the index ’tbl_idx’ is composed of these columns.\nThus, it seems at first glance that accessing the table pages is not required when using index scan, because the index tuples contain the necessary data.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.925205"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": null,
    "text": "However, in fact, PostgreSQL has to check the visibility of the tuples in principle.\nThe index tuples do not have any information about transactions, such as the t_xmin and t_xmax of the heap tuples, which are described in Section 5.2.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.925205"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": null,
    "text": "Therefore, PostgreSQL has to access the table data to check the visibility of the data in the index tuples.\nThis is like putting the cart before the horse.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.925205"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": null,
    "text": "To avoid this dilemma,\nPostgreSQL uses the visibility map of the target table.\nIf all tuples stored in a page are visible, PostgreSQL uses the key of the index tuple and does not access the table page that is pointed at from the index tuple to check its visibility.\nOtherwise, PostgreSQL reads the table tuple that is pointed at from the index tuple and checks the visibility of the tuple, which is the ordinary process.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.925205"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql07/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 7: HOT and Index-Only Scans",
    "section": null,
    "text": "In this example,\nTuple_18 does not need to be accessed because the 0th page that stores Tuple_18 is visible.\nThat is, all tuples in the 0th page, including Tuple_18, are visible.\nIn contrast, Tuple_19 needs to be accessed to handle concurrency control because the visibility of the 1st page is not visible.\nSee Figure 7.7.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:34.925205"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 8: Buffer Manager",
    "section": null,
    "text": "This section introduces key concepts that are necessary to understand the descriptions in the subsequent sections.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.1. Buffer Manager Structure",
    "text": "The PostgreSQL buffer manager comprises a buffer table, buffer descriptors, and buffer pool, which are described in the next section.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.1. Buffer Manager Structure",
    "text": "The buffer pool layer stores data file pages, such as tables and indexes, as well as freespace maps and visibility maps.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.1. Buffer Manager Structure",
    "text": "The buffer pool is an array,\nwhere each slot stores one page of a data file.\nThe Indices of a buffer pool array are referred to as buffer_ids.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.1. Buffer Manager Structure",
    "text": "Sections 8.2 and 8.3 describe the details of the buffer manager internals.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.2. Buffer Tag",
    "text": "In PostgreSQL, each page of all data files can be assigned a unique tag, i.e. a buffer tag.\nWhen the buffer manager receives a request, PostgreSQL uses the buffer_tag of the desired page.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.2. Buffer Tag",
    "text": "specOid: The OID of the tablespace to which the relation containing the target page belongs.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.2. Buffer Tag",
    "text": "dbOid: The OID of the database to which the relation containing the target page belongs.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.2. Buffer Tag",
    "text": "relNumber: The number of the relation file that contains the target page.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.2. Buffer Tag",
    "text": "blockNum: The block number of the target page in the relation.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.2. Buffer Tag",
    "text": "forkNum: The fork number of the relation that the page belongs to.\nThe fork numbers of tables, freespace maps, and visibility maps are defined in 0, 1 and 2, respectively.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.2. Buffer Tag",
    "text": "[CODE BLOCK]\n/*\n * Buffer tag identifies which disk block the buffer contains.\n *\n * Note: the BufferTag data must be sufficient to determine where to write the\n * block, without reference to pg_class or pg_tablespace entries.  It's\n * possible that the backend flushing the buffer doesn't even believe the\n * relation is visible yet (its xact may have started before the xact that\n * created the rel).  The storage manager must be able to cope anyway.\n *\n * Note: if there's any pad bytes in the struct, InitBufferTag will have\n * to be fixed to zero them, since this struct is used as a hash key.\n */\ntypedef struct buftag\n{\n\tOid\t\t\tspcOid;\t\t\t/* tablespace oid */\n\tOid\t\t\tdbOid;\t\t\t/* database oid */\n\tRelFileNumber relNumber;\t/* relation file number */\n\tForkNumber\tforkNum;\t\t/* fork number */\n\tBlockNumber blockNum;\t\t/* blknum relative to begin of reln */\n} BufferTag;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.2. Buffer Tag",
    "text": "For example,\nthe buffer_tag ‘{16821, 16384, 37721, 0, 7}’ identifies the page that is in the seventh block of the table whose OID and fork number are 37721 and 0, respectively.\nThe table is contained in the database whose OID is 16384 under the tablespace whose OID is 16821.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.2. Buffer Tag",
    "text": "Similarly, the buffer_tag ‘{16821, 16384, 37721, 1, 3}’ identifies the page that is in the third block of the freespace map whose OID and fork number are 37721 and 1, respectively.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.3. How a Backend Process Reads Pages",
    "text": "This subsection describes how a backend process reads a page from the buffer manager (Figure 8.2).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.3. How a Backend Process Reads Pages",
    "text": "(1) When reading a table or index page, a backend process sends a request that includes the page’s buffer_tag to the buffer manager.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.3. How a Backend Process Reads Pages",
    "text": "(2) The buffer manager returns the buffer_ID of the slot that stores the requested page.\nIf the requested page is not stored in the buffer pool, the buffer manager loads the page from persistent storage to one of the buffer pool slots and then returns the buffer_ID of the slot.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.3. How a Backend Process Reads Pages",
    "text": "(3) The backend process accesses the buffer_ID’s slot (to read the desired page).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.3. How a Backend Process Reads Pages",
    "text": "When a backend process modifies a page in the buffer pool (e.g., by inserting tuples),\nthe modified page, which has not yet been flushed to storage, is referred to as a dirty page.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.3. How a Backend Process Reads Pages",
    "text": "Section 8.4 describes how the buffer manager works in mode detail.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.4. Page Replacement Algorithm",
    "text": "When all buffer pool slots are occupied and the requested page is not stored,\nthe buffer manager must select one page in the buffer pool to be replaced by the requested page.\nTypically, in the field of computer science, page selection algorithms are called page replacement algorithms,\nand the selected page is referred to as a victim page.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.4. Page Replacement Algorithm",
    "text": "Research on page replacement algorithms has been ongoing since the advent of computer science.\nMany replacement algorithms have been proposed,\nand PostgreSQL has used the clock sweep algorithm since version 8.1.\nClock sweep is simpler and more efficient than the LRU algorithm used in previous versions.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.4. Page Replacement Algorithm",
    "text": "Section 8.4.4 describes the details of clock sweep.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.4. Page Replacement Algorithm",
    "text": "Until version 7.4, PostgreSQL used a simple LRU algorithm.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.4. Page Replacement Algorithm",
    "text": "Although PostgreSQL implemented ARC (Adaptive Replacement Cache) in version 8.0, it might have been possible to violate IBM’s patent.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.4. Page Replacement Algorithm",
    "text": "As a result, the PostgreSQL community tentatively changed the replacement algorithm to 2Q,\nand then PostgreSQL supported clock sweep in version 8.1.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.5. Flushing Dirty Pages",
    "text": "Dirty pages should eventually be flushed to storage.\nHowever, the buffer manager requires help to perform this task.\nIn PostgreSQL, two background processes, checkpointer and background writer, are responsible for this task.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.5. Flushing Dirty Pages",
    "text": "Section 8.6 describes the checkpointer and background writer.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.5. Flushing Dirty Pages",
    "text": "PostgreSQL versions 15 and earlier do not support direct I/O, although it has been discussed.\nRefer to this article on the pgsql-ML and this article.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.1.5. Flushing Dirty Pages",
    "text": "In version 16, the debug-io-direct option has been added.\nThis option is for developers to improve the use of direct I/O in PostgreSQL.\nIf development goes well, direct I/O will be officially supported in the near future.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:36.651023"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 8: Buffer Manager",
    "section": null,
    "text": "The PostgreSQL buffer manager comprises three layers: the ‘buffer table’, ‘buffer descriptors’ and ‘buffer pool’ (Figure 8.3):",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.513808"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 8: Buffer Manager",
    "section": null,
    "text": "Buffer pool: An array that stores data file pages.\nEach slot in the array is referred to as buffer_ids.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.513808"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 8: Buffer Manager",
    "section": null,
    "text": "Buffer descriptors: An array of buffer descriptors.\nEach descriptor has a one-to-one correspondence to a buffer pool slot and holds the metadata of the stored page in the corresponding slot.\n\nNote that the term ‘buffer descriptors layer’ has been adopted for convenience and is only used in this document.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.513808"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 8: Buffer Manager",
    "section": null,
    "text": "Buffer table:\nA hash table that stores the relations between the buffer_tags of stored pages and the buffer_ids of the descriptors that hold the stored pages’ respective metadata.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.513808"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 8: Buffer Manager",
    "section": null,
    "text": "These layers are described in detail in the following subsections.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.513808"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.1. Buffer Table",
    "text": "A buffer table can be logically divided into three parts: a hash function, hash bucket slots, and data entries (Figure 8.4).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.513808"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.1. Buffer Table",
    "text": "The built-in hash function maps buffer_tags to the hash bucket slots.\nEven though the number of hash bucket slots is greater than the number of buffer pool slots, collisions may occur.\nTherefore, the buffer table uses a separate chaining with linked lists method to resolve collisions.\nWhen data entries are mapped to the same bucket slot, this method stores the entries in the same linked list, as shown in Figure 8.4.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.513808"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.1. Buffer Table",
    "text": "A data entry comprises two values: the buffer_tag of a page, and the buffer_id of the descriptor that holds the page’s metadata.\nFor example, a data entry ‘Tag_A, id=1’ means that the buffer descriptor with buffer_id ‘1’ stores metadata of the page tagged with Tag_A.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.513808"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.1. Buffer Table",
    "text": "The hash function is a composite function of calc_bucket() and  hash().",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.513808"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.1. Buffer Table",
    "text": "The following is its representation as a pseudo-function.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.513808"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.1. Buffer Table",
    "text": "[CODE BLOCK]\nuint32 bucket_slot = calc_bucket(unsigned hash(BufferTag buffer_tag), uint32 bucket_size)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.513808"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.1. Buffer Table",
    "text": "Note: Basic operations (lookup, insertion, and deletion of data entries) are not explained here. These are very common operations and are explained in the following sections.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.513808"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "The structure of buffer descriptors was improved in version 9.6\nThis section first explains buffer descriptors in versions 9.5 or earlier,\nfollowed by a discussion of the changes introduced in versions 9.6 or later.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.513808"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "The buffer descriptors layer is described in the next subsection.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.513808"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "The buffer descriptor structure in versions 9.5 and earlier holds the metadata of the stored page in the corresponding buffer pool slot.\nThe buffer descriptor structure is defined by the BufferDesc structure.\nThe following are some of the main fields:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.513808"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "[CODE BLOCK]\n/*\n * Flags for buffer descriptors\n *\n * Note: TAG_VALID essentially means that there is a buffer hashtable\n * entry associated with the buffer's tag.\n */\n#define BM_DIRTY                (1 << 0)    /* data needs writing */\n#define BM_VALID                (1 << 1)    /* data is valid */\n#define BM_TAG_VALID            (1 << 2)    /* tag is assigned */\n#define BM_IO_IN_PROGRESS       (1 << 3)    /* read or write in progress */\n#define BM_IO_ERROR             (1 << 4)    /* previous I/O failed */\n#define BM_JUST_DIRTIED         (1 << 5)    /* dirtied since write started */\n#define BM_PIN_COUNT_WAITER     (1 << 6)    /* have waiter for sole pin */\n#define BM_CHECKPOINT_NEEDED    (1 << 7)    /* must write for checkpoint */\n#define BM_PERMANENT            (1 << 8)    /* permanent relation (not unlogged) */\n\nsrc/include/storage/buf_internals.h\ntypedef struct sbufdesc\n{\n   BufferTag    tag;                 /* ID of page contained in buffer */\n   BufFlags     flags;               /* see bit definitions above */\n   uint16       usage_count;         /* usage counter for clock sweep code */\n   unsigned     refcount;            /* # of backends holding pins on buffer */\n   int          wait_backend_pid;    /* backend PID of pin-count waiter */\n   slock_t      buf_hdr_lock;        /* protects the above fields */\n   int          buf_id;              /* buffer's index number (from 0) */\n   int          freeNext;            /* link in freelist chain */\n\n   LWLockId     io_in_progress_lock; /* to wait for I/O to complete */\n   LWLockId     content_lock;        /* to lock access to buffer contents */\n} BufferDesc;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "tag holds the buffer_tag of the stored page in the corresponding buffer pool slot.\n(buffer tag is defined in Section 8.1.2.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "buf_id identifies the descriptor.\nIt is equivalent to the buffer_id of the corresponding buffer pool slot.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "refcount (also referred to as pin count) holds the number of PostgreSQL processes currently accessing the associated stored page.\n\nWhen a PostgreSQL process accesses the stored page, the refcount must be incremented  by 1 (refcount++).\nAfter accessing the page, the refcount must be decreased by 1 (refcount–).\n\nWhen the refcount is zero, the associated stored page is unpinned, meaning it is not currently being accessed.\nOtherwise, it is pinned.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "usage_count holds the number of times the associated stored page has been accessed since it was loaded into the corresponding buffer pool slot.\nIt is used in the page replacement algorithm (Section 8.4.4).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "content_lock and io_in_progress_lock are light-weight locks that are used to control access to the associated stored page.\nThese fields are described in Section 8.3.2.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "flags can hold several states of the associated stored page.\nThe main states are as follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "dirty bit indicates that the stored page is dirty.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "valid bit indicates whether the stored page is valid, meaning it can be read or written.\n\nIf this bit is valid, then the corresponding buffer pool slot stores a page and the descriptor holds the page metadata, and the stored page can be read or written.\n\nIf this bit is invalid, then the descriptor does not hold any metadata and the stored page cannot be read or written.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "io_in_progress bit indicates whether the buffer manager is reading or writing the associated page from or to storage.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "buf_hdr_lock is a spin lock that protects the fields: flags, usage_count, refcount.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "freeNext is a pointer to the next descriptor to generate a freelist, which is described in the next subsection.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "The buffer descriptor structure is defined by the BufferDesc structure.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "[CODE BLOCK]\n/*\n * Flags for buffer descriptors\n *\n * Note: BM_TAG_VALID essentially means that there is a buffer hashtable\n * entry associated with the buffer's tag.\n */\n#define BM_LOCKED\t\t(1U << 22)\t/* buffer header is locked */\n#define BM_DIRTY\t\t(1U << 23)\t/* data needs writing */\n#define BM_VALID\t\t(1U << 24)\t/* data is valid */\n#define BM_TAG_VALID\t\t(1U << 25)\t/* tag is assigned */\n#define BM_IO_IN_PROGRESS\t(1U << 26)\t/* read or write in progress */\n#define BM_IO_ERROR\t\t(1U << 27)\t/* previous I/O failed */\n#define BM_JUST_DIRTIED\t\t(1U << 28)\t/* dirtied since write started */\n#define BM_PIN_COUNT_WAITER\t(1U << 29)\t/* have waiter for sole pin */\n#define BM_CHECKPOINT_NEEDED\t(1U << 30)\t/* must write for checkpoint */\n#define BM_PERMANENT\t\t(1U << 31)\t/* permanent buffer (not unlogged,\n\t\t\t\t\t\t * or init fork) */\n\n#define PG_HAVE_ATOMIC_U32_SUPPORT\ntypedef struct pg_atomic_uint32\n{\n\tvolatile uint32 value;\n} pg_atomic_uint32;\n\n\ntypedef struct BufferDesc\n{\n\tBufferTag\ttag;\t\t\t/* ID of page contained in buffer */\n\tint\t\tbuf_id;\t\t\t/* buffer's index number (from 0) */\n\n\t/* state of the tag, containing flags, refcount and usagecount */\n\tpg_atomic_uint32 state;\n\n\tint\t\twait_backend_pgprocno;\t/* backend of pin-count waiter */\n\tint\t\tfreeNext;\t\t/* link in freelist chain */\n\tLWLock\t\tcontent_lock;\t/* to lock access to buffer contents */\n} BufferDesc;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "tag holds the buffer_tag of the stored page in the corresponding buffer pool slot.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 31,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "content_lock is a light-weight lock that is used to control access to the associated stored page.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 32,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "freeNext is a pointer to the next descriptor to generate a freelist.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 33,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "states can hold several states and variables of the associated stored page, such as refcount and usage_count.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 34,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "The flags, usage_count, and refcount fields have been combined into a single 32-bit data (states) to use the CPU atomic operations.\nTherefore, the io_in_progress_lock and spin lock (buf_hdr_lock) have been removed\nsince there is no longer a need to protect these values.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 35,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "An atomic operation is one that executes as a single, indivisible unit without being interrupted by context switches or other processes.\nIn operating systems, this ensures that even if multiple processes or threads attempt to access the same value concurrently, the operation maintains consistency without requiring explicit synchronization.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 36,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "These operations are commonly used for tasks such as updating counters without locks or implementing lock-free data structures.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 37,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "The structure BufferDesc is defined in src/include/storage/buf_internals.h.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 38,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "To simplify the following descriptions, we define three descriptor states as follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 39,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "Empty:\nWhen the corresponding buffer pool slot does not store a page (i.e. refcount and usage_count are 0), the state of this descriptor is empty.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 40,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "Pinned:\nWhen the corresponding buffer pool slot stores a page and any PostgreSQL processes are accessing the page (i.e. refcount and usage_count are greater than or equal to 1), the state of this buffer descriptor is pinned.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 41,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "Unpinned:\nWhen the corresponding buffer pool slot stores a page but no PostgreSQL processes are accessing the page (i.e. usage_count is greater than or equal to 1, but refcount is 0),\nthe state of this buffer descriptor is unpinned.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 42,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "Each descriptor will have one of the above states.\nThe descriptor state changes depending on certain conditions, which are described in the next subsection.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 43,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "In the following figures, buffer descriptors’ states are represented by coloured boxes.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 44,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.2. Buffer Descriptor",
    "text": "In addition,\na dirty page is denoted as ‘X’.\nFor example, an unpinned dirty descriptor is represented by Â XÂ .",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 45,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.3. Buffer Descriptors Layer",
    "text": "A collection of buffer descriptors forms an array, which is referred to as the buffer descriptors layer in this document.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 46,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.3. Buffer Descriptors Layer",
    "text": "When the PostgreSQL server starts, the state of all buffer descriptors is ’empty’.\nIn PostgreSQL, those descriptors comprise a linked list called freelist (Figure 8.5).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 47,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.3. Buffer Descriptors Layer",
    "text": "It is important to note that the freelist in PostgreSQL is completely different concept from the freelists in Oracle.\nThe freelist in PostgreSQL is simply linked list of empty buffer descriptors.\nIn PostgreSQL, freespace maps (FSM), which are described in Section 5.3.4, serve as the same purpose as the freelists in Oracle.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 48,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.3. Buffer Descriptors Layer",
    "text": "Figure 8.6 shows that how the first page is loaded.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 49,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.3. Buffer Descriptors Layer",
    "text": "(1) Retrieve an empty descriptor from the top of the freelist, and pin it (i.e. increase its refcount and usage_count by 1).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 50,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.3. Buffer Descriptors Layer",
    "text": "(2) Insert a new entry into the buffer table that maps the tag of the first page to the buffer_id of the retrieved descriptor.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 51,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.3. Buffer Descriptors Layer",
    "text": "(3) Load the new page from storage into the corresponding buffer pool slot.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 52,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.3. Buffer Descriptors Layer",
    "text": "(4) Save the metadata of the new page to the retrieved descriptor.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 53,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.3. Buffer Descriptors Layer",
    "text": "The second and subsequent pages are loaded in a similar manner.\nAdditional details are provided in Section 8.4.2.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 54,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.3. Buffer Descriptors Layer",
    "text": "Descriptors that have been retrieved from the freelist always hold page’s metadata.\nIn other words, non-empty descriptors do not return to the freelist once they have been used.\nHowever, the corresponding descriptors are added to the freelist again and the descriptor state is set to ’empty’ when one of the following occurs:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 55,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.3. Buffer Descriptors Layer",
    "text": "The freelist is created to allow for the immediate retrieval of the first descriptor.\nThis is a usual practice for dynamic memory resource allocation.\nFor more information, refer to this description.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 56,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.3. Buffer Descriptors Layer",
    "text": "The buffer descriptors layer contains an unsigned 32-bit integer variable, i.e. nextVictimBuffer.\nThis variable is used in the page replacement algorithm described in Section 8.4.4.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 57,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.4. Buffer Pool",
    "text": "The buffer pool is a simple array that stores data file pages, such as tables and indexes. The indices of the buffer pool array are called  buffer_ids.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 58,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.2.4. Buffer Pool",
    "text": "The buffer pool slot size is 8 KB, which is equal to the size of a page. Therefore, each slot can store an entire page.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:37.514320"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 8: Buffer Manager",
    "section": null,
    "text": "The buffer manager uses many locks for a variety of purposes.\nThis section describes the locks that are necessary for the explanations in the subsequent sections.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:38.366766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 8: Buffer Manager",
    "section": null,
    "text": "Note that the locks described in this section are part of a synchronization mechanism for the buffer manager. They do not relate to any SQL statements or SQL options.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:38.366766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.3.1. Buffer Table Locks",
    "text": "BufMappingLock protects the data integrity of the entire buffer table.\nIt is a light-weight lock that can be used in both shared and exclusive modes.\nWhen searching an entry in the buffer table, a backend process holds a shared BufMappingLock.\nWhen inserting or deleting entries, a backend process holds an exclusive lock.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:38.366766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.3.1. Buffer Table Locks",
    "text": "The BufMappingLock is split into partitions to reduce contention in the buffer table (the default is 128 partitions).\nEach BufMappingLock partition guards a portion of the corresponding hash bucket slots.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:38.366766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.3.1. Buffer Table Locks",
    "text": "Figure 8.7 shows a typical example of the effect of splitting BufMappingLock.\nTwo backend processes can simultaneously hold respective BufMappingLock partitions in exclusive mode to insert new data entries.\nIf BufMappingLock were a single system-wide lock, both processes would have to wait for the other process to finish, depending on which process started first.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:38.366766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.3.1. Buffer Table Locks",
    "text": "The buffer table requires many other locks.\nFor example, the buffer table internally uses a spin lock to delete an entry.\nHowever, descriptions of these other locks are omitted because they are not required in this document.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:38.366766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.3.1. Buffer Table Locks",
    "text": "The BufMappingLock was introduced in version 8.1.\nUntil version 9.4, the BufMappingLock was split into 16 separate locks by default.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:38.366766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.3.1. Buffer Table Locks",
    "text": "Before the introduction of BufMappingLock, PostgreSQL used BufMgrLock,\na giant lock mechanism that had to be acquired whenever the shared buffer was accessed, resulting in poor concurrency.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:38.366766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.3.2. Locks for Each Buffer Descriptor",
    "text": "In versions 9.5 or earlier,\neach buffer descriptor used two lightweight locks, content_lock and io_in_progress_lock, to control access to the stored page in the corresponding buffer pool slot.\nA spinlock (buf_hdr_lock) was used when the values of its own fields (i.e., usage_count, refcount, flags) were checked or changed.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:38.366766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.3.2. Locks for Each Buffer Descriptor",
    "text": "In version 9.6, buffer access methods were improved.\nThe io_in_progress_lock and spin lock (buf_hdr_lock) were removed.\nInstead of using these locks, versions 9.6 or later use CPU atomic operations to inspect and change their values.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:38.366766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.3.2. Locks for Each Buffer Descriptor",
    "text": "If you need more information about atomic operations, see the  in Section 8.2.2.2  for details.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:38.366766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.3.2. Locks for Each Buffer Descriptor",
    "text": "The content_lock is a typical lock that enforces access restrictions.\nIt can be used in shared and exclusive modes.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:38.366766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.3.2. Locks for Each Buffer Descriptor",
    "text": "When reading a page,\na backend process acquires a shared content_lock of the buffer descriptor that stores the page.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:38.366766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.3.2. Locks for Each Buffer Descriptor",
    "text": "An exclusive content_lock is acquired when doing one of the following:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:38.366766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.3.2. Locks for Each Buffer Descriptor",
    "text": "Inserting rows (i.e., tuples) into the stored page or changing the t_xmin/t_xmax fields of tuples within the stored page. (t_xmin and t_xmax are described in Section 5.2; simply, when deleting or updating rows, these fields of the associated tuples are changed).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:38.366766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.3.2. Locks for Each Buffer Descriptor",
    "text": "Physically removing tuples or compacting free space on the stored page. (This is performed by vacuum processing and HOT, which are described in Chapters 6 and 7, respectively).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:38.366766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.3.2. Locks for Each Buffer Descriptor",
    "text": "Freezing tuples within the stored page. (Freezing is described in Section 5.10.1 and Section 6.3.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:38.366766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.3.2. Locks for Each Buffer Descriptor",
    "text": "In versions 9.5 or earlier, the io_in_progress lock was used to wait for I/O on a buffer to complete.\nWhen a PostgreSQL process loads or writes page data from or to storage,\nthe process acquires an exclusive io_in_progress lock of the corresponding descriptor while accessing the storage.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:38.366766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.3.2. Locks for Each Buffer Descriptor",
    "text": "When the flags or other fields (such as refcount and usage_count) are checked or changed, a spinlock was used.\nTwo specific examples of spinlock usage are given below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:38.366766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.3.2. Locks for Each Buffer Descriptor",
    "text": "[CODE BLOCK]\nLockBufHdr(bufferdesc);    /* Acquire a spinlock */\nbufferdesc->refcont++;\nbufferdesc->usage_count++;\nUnlockBufHdr(bufferdesc); /* Release the spinlock */",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:38.366766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.3.2. Locks for Each Buffer Descriptor",
    "text": "[CODE BLOCK]\n#define BM_DIRTY             (1 << 0)    /* data needs writing */\n#define BM_VALID             (1 << 1)    /* data is valid */\n#define BM_TAG_VALID         (1 << 2)    /* tag is assigned */\n#define BM_IO_IN_PROGRESS    (1 << 3)    /* read or write in progress */\n#define BM_JUST_DIRTIED      (1 << 5)    /* dirtied since write started */\n\nLockBufHdr(bufferdesc);\nbufferdesc->flags |= BM_DIRTY;\nUnlockBufHdr(bufferdesc);",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:38.366766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.3.2. Locks for Each Buffer Descriptor",
    "text": "Changing other bits is performed in the same manner.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:38.366766"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 8: Buffer Manager",
    "section": null,
    "text": "This section describes how the buffer manager works.\nWhen a backend process wants to access a desired page, it calls the ReadBufferExtended() function.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 8: Buffer Manager",
    "section": null,
    "text": "The behavior of the ReadBufferExtended() function depends on three logical cases.\nEach case is described in the following subsections.\nIn addition, the PostgreSQL clock sweep page replacement algorithm is described in the final subsection.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.1. Accessing a Page Stored in the Buffer Pool",
    "text": "First, the simplest case is described, in which the desired page is already stored in the buffer pool.\nIn this case, the buffer manager performs the following steps:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.1. Accessing a Page Stored in the Buffer Pool",
    "text": "(1) Create the buffer_tag of the desired page (in this example, the buffer_tag is ‘Tag_C’)\nand compute the hash bucket slot that contains the associated entry of the created buffer_tag, using the hash function.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.1. Accessing a Page Stored in the Buffer Pool",
    "text": "(2) Acquire the BufMappingLock partition that covers the obtained hash bucket slot in shared mode (this lock will be released in step (5)).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.1. Accessing a Page Stored in the Buffer Pool",
    "text": "(3) Look up the entry whose tag is ‘Tag_C’ and obtain the buffer_id from the entry. In this example, the buffer_id is 2.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.1. Accessing a Page Stored in the Buffer Pool",
    "text": "(4) Pin the buffer descriptor for buffer_id 2, increasing the refcount and usage_count of the descriptor by 1.\n( Section 8.3.2 describes pinning).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.1. Accessing a Page Stored in the Buffer Pool",
    "text": "Then, when reading rows from the page in the buffer pool slot,\nthe PostgreSQL process acquires the shared content_lock of the corresponding buffer descriptor.\nTherefore, buffer pool slots can be read by multiple processes simultaneously.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.1. Accessing a Page Stored in the Buffer Pool",
    "text": "When inserting (and updating or deleting) rows to the page,\na Postgres process acquires the exclusive content_lock of the corresponding buffer descriptor.\n(Note that the dirty bit of the page must be set to 1.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.1. Accessing a Page Stored in the Buffer Pool",
    "text": "After accessing the pages,\nthe refcount values of the corresponding buffer descriptors are decreased by 1.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.2. Loading a Page from Storage to Empty Slot",
    "text": "In this second case, assume that the desired page is not in the buffer pool and the freelist has free elements (empty descriptors). In this case, the buffer manager performs the following steps:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.2. Loading a Page from Storage to Empty Slot",
    "text": "(1) Look up the buffer table (we assume that it is not found).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.2. Loading a Page from Storage to Empty Slot",
    "text": "(2) Obtain an empty buffer descriptor from the freelist, and pin it.\nIn this example, the buffer_id of the obtained descriptor is 4.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.2. Loading a Page from Storage to Empty Slot",
    "text": "(3) Acquire the BufMappingLock partition in exclusive mode. (This lock will be released in step (6).)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.2. Loading a Page from Storage to Empty Slot",
    "text": "(4) Create a new data entry that comprises the buffer_tag ‘Tag_E’ and buffer_id 4. Insert the created entry to the buffer table.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.2. Loading a Page from Storage to Empty Slot",
    "text": "(5) Load the desired page data from storage to the buffer pool slot with buffer_id 4 as follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.3. Loading a Page from Storage to a Victim Buffer Pool Slot",
    "text": "In this case, assume that all buffer pool slots are occupied by pages but the desired page is not stored.\nThe buffer manager performs the following steps:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.3. Loading a Page from Storage to a Victim Buffer Pool Slot",
    "text": "(1) Create the buffer_tag of the desired page and look up the buffer table.\nIn this example, we assume that the buffer_tag is ‘Tag_M’ (the desired page is not found).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.3. Loading a Page from Storage to a Victim Buffer Pool Slot",
    "text": "(2) Select a victim buffer pool slot using the clock-sweep algorithm.\nObtain the old entry, which contains the buffer_id of the victim pool slot,\nfrom the buffer table and pin the victim pool slot in the buffer descriptors layer.\nIn this example, the buffer_id of the victim slot is 5 and the old entry is ‘Tag_F, id=5’.\nThe clock sweep is described in Section 8.4.4.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.3. Loading a Page from Storage to a Victim Buffer Pool Slot",
    "text": "(3) Flush (write and fsync) the victim page data if it is dirty; otherwise proceed to step (4).\n\nThe dirty page must be written to storage before overwriting with new data.\nFlushing a dirty page is performed as follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.3. Loading a Page from Storage to a Victim Buffer Pool Slot",
    "text": "(4) Acquire the old BufMappingLock partition that covers the slot that contains the old entry, in exclusive mode.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.3. Loading a Page from Storage to a Victim Buffer Pool Slot",
    "text": "(5) Acquire the new BufMappingLock partition and insert the new entry to the buffer table:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.3. Loading a Page from Storage to a Victim Buffer Pool Slot",
    "text": "(6) Delete the old entry from the buffer table, and release the old BufMappingLock partition.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.3. Loading a Page from Storage to a Victim Buffer Pool Slot",
    "text": "(7) Load the desired page data from the storage to the victim buffer slot.\nThen, update the flags of the descriptor with buffer_id 5; the dirty bit is set to 0 and other bits are initialized.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.4. Page Replacement Algorithm: Clock Sweep",
    "text": "The rest of this section describes the clock-sweep algorithm. This algorithm is a variant of NFU (Not Frequently Used) with low overhead; it selects less frequently used pages efficiently.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.4. Page Replacement Algorithm: Clock Sweep",
    "text": "Imagine buffer descriptors as a circular list (Figure 8.12).\nThe nextVictimBuffer, an unsigned 32-bit integer, is always pointing to one of the buffer descriptors and rotates clockwise.\nThe pseudocode and description of the algorithm are follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.4. Page Replacement Algorithm: Clock Sweep",
    "text": "[CODE BLOCK]\nWHILE true\n(1)    Obtain the candidate buffer descriptor pointed by the nextVictimBuffer\n(2)    IF the candidate descriptor is 'unpinned' THEN\n(3)       IF the candidate descriptor's usage_count == 0 THEN\n             BREAK WHILE LOOP  /* the corresponding slot of this descriptor */\n                               /* is victim slot.                           */\n          ELSE\n             Decrease the candidate descriptpor's usage_count by 1\n          END IF\n       END IF\n(4)    Advance nextVictimBuffer to the next one\n    END WHILE\n(5) RETURN buffer_id of the victim",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.4. Page Replacement Algorithm: Clock Sweep",
    "text": "A specific example is shown in Figure 8.12.\nThe buffer descriptors are shown as blue or cyan boxes,\nand the numbers in the boxes show the usage_count of each descriptor.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.4. Page Replacement Algorithm: Clock Sweep",
    "text": "1) The nextVictimBuffer points to the first descriptor (buffer_id 1).\nHowever, this descriptor is skipped because it is pinned.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.4. Page Replacement Algorithm: Clock Sweep",
    "text": "2) The nextVictimBuffer points to the second descriptor (buffer_id 2).\nThis descriptor is unpinned but its usage_count is 2.\nThus, the usage_count is decreased by 1, and the nextVictimBuffer advances to the third candidate.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 31,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.4. Page Replacement Algorithm: Clock Sweep",
    "text": "3) The nextVictimBuffer points to the third descriptor (buffer_id 3).\nThis descriptor is unpinned and its usage_count is 0.\nThus, this is the victim in this round.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 32,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.4.4. Page Replacement Algorithm: Clock Sweep",
    "text": "Whenever the nextVictimBuffer sweeps an unpinned descriptor, its usage_count is decreased by 1.\nTherefore, if unpinned descriptors exist in the buffer pool, this algorithm can always find a victim, whose usage_count is 0,  by rotating the nextVictimBuffer.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:39.219886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 8: Buffer Manager",
    "section": null,
    "text": "This section introduces two types of temporary buffers:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:40.069564"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.5.1. Ring Buffer",
    "text": "When reading or writing a huge table, PostgreSQL uses a ring buffer instead of the buffer pool.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:40.069564"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.5.1. Ring Buffer",
    "text": "The ring buffer is a small, temporary buffer area.\nIt is allocated in shared memory when any of the following conditions is met:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:40.069564"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.5.1. Ring Buffer",
    "text": "Bulk-reading:\nWhen scanning a relation whose size exceeds one-quarter of the buffer pool size ($ \\text{shared_buffers} / 4 $).\nIn this case, the ring buffer size is 256 KB.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:40.069564"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.5.1. Ring Buffer",
    "text": "Bulk-writing:\nWhen executing the following SQL commands, the ring buffer size is 16 MB:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:40.069564"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.5.1. Ring Buffer",
    "text": "Vacuum-processing:\nWhen an autovacuum process performs vacuuming. In this case, the ring buffer size is 256 KB.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:40.069564"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.5.1. Ring Buffer",
    "text": "The ring buffer is released immediately after use.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:40.069564"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.5.1. Ring Buffer",
    "text": "The benefit of the ring buffer is clear:\nIf a backend process reads a large table without a ring buffer,\nall pages stored in the buffer pool may be evicted, reducing the cache hit ratio.\nThe ring buffer prevents this by providing a temporary buffer area for large tables.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:40.069564"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.5.1. Ring Buffer",
    "text": "The answer is explained in the README located under the buffer manager’s source directory.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:40.069564"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.5.1. Ring Buffer",
    "text": "For sequential scans, a 256 KB ring is used. That’s small enough to fit in L2\ncache, which makes transferring pages from OS cache to shared buffer cache\nefficient.  Even less would often be enough, but the ring must be big enough\nto accommodate all pages in the scan that are pinned concurrently.\n(snip)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:40.069564"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.5.1. Ring Buffer",
    "text": "When the same relation is accessed concurrently by two or more backends, the ring buffer is shared among them.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:40.069564"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.5.1. Ring Buffer",
    "text": "Figure 8.13 illustrates how two backends access the ring buffer using a sequential scan:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:40.069564"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.5.2. Temporary Tables and Local Buffer Management",
    "text": "When a backend creates a temporary table,\nthe buffer manager allocates a memory area for the backend and creates a local buffer.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:40.069564"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.5.2. Temporary Tables and Local Buffer Management",
    "text": "While the numbering of bucket slots for the shared buffer is positive,\nthe numbering of the local bucket slots for the local buffer is negative, i.e., -1, -2, and so on.\nThis allows the backend to seamlessly access both regular tables and temporary tables.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:40.069564"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 8: Buffer Manager",
    "section": "8.5.2. Temporary Tables and Local Buffer Management",
    "text": "Managing local buffers does not require locks, as these buffers are accessed exclusively by the backend that creates them.\nAdditionally, local buffers do not need to be WAL-logged or checkpointed.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:40.069564"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 8: Buffer Manager",
    "section": null,
    "text": "In addition to replacing victim pages, the checkpointer and background writer processes flush dirty pages to storage.\nBoth processes have the same function, flushing dirty pages, but they have different roles and behaviors.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:40.920709"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 8: Buffer Manager",
    "section": null,
    "text": "The checkpointer process writes a checkpoint record to the WAL segment file and flushes dirty pages whenever checkpointing starts.\nSection 9.7 describes checkpointing and when it begins.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:40.920709"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 8: Buffer Manager",
    "section": null,
    "text": "The role of the background writer is to reduce the impact of the intensive writing of checkpointing.\nThe background writer continues to flush dirty pages little by little with minimal impact on database activity.\nBy default, the background writer wakes every 200 msec (defined by bgwriter_delay) and flushes bgwriter_lru_maxpages (the default is 100 pages) at most.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:40.920709"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 8: Buffer Manager",
    "section": null,
    "text": "In versions 9.1 or earlier, background writer had regularly done the checkpoint processing.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:40.920709"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 8: Buffer Manager",
    "section": null,
    "text": "In version 9.2, the checkpointer process has been separated from the background writer process.\nSince the reason is described in the proposal whose title is “Separating bgwriter and checkpointer”, the sentences from it are shown in the following.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:40.920709"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql08/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 8: Buffer Manager",
    "section": null,
    "text": "Currently(in 2011) the bgwriter process performs both background writing, checkpointing and some other duties. This means that we can’t perform the final checkpoint fsync without stopping background writing, so there is a negative performance effect from doing both things in one process.\n\nAdditionally, our aim in 9.2 is to replace polling loops with latches\nfor power reduction. The complexity of the bgwriter loops is high and\nit seems unlikely to come up with a clean approach using latches.\n\n(snip)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:40.920709"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "Let’s take a look at the overview of the WAL mechanism.\nTo clarify the issue that WAL solves, the first subsection shows what happens when a crash occurs if PostgreSQL does not implement WAL.\nThe second subsection introduces some key concepts and shows an overview of the main subjects in this chapter: the writing of WAL data and the database recovery process.\nThe final subsection completes the overview of WAL by adding one more key concept.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "In this section, to simplify the description, the table TABLE_A which contains just one page has been used.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.1. Insertion Operations without WAL",
    "text": "As described in Chapter 8,\nevery DBMS implements a shared buffer pool to provide efficient access to the relation’s pages.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.1. Insertion Operations without WAL",
    "text": "Assume that we insert some data tuples into TABLE_A on PostgreSQL which does not implement the WAL feature.\nThis situation is illustrated in Figure 9.1.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.1. Insertion Operations without WAL",
    "text": "When we issue the first INSERT statement,\nPostgreSQL loads the TABLE_A page from the database cluster into the in-memory shared buffer pool and inserts a tuple into the page.\nThe page is not written to the database cluster immediately.\n(As mentioned in Chapter 8, modified pages are generally called dirty pages.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.1. Insertion Operations without WAL",
    "text": "When we issue the second INSERT statement,\nPostgreSQL inserts a new tuple into the page in the buffer pool.\nThe page has not been written to storage yet.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.1. Insertion Operations without WAL",
    "text": "If the operating system or PostgreSQL server should fail for any reason, such as a power failure,\nall of the inserted data would be lost.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.1. Insertion Operations without WAL",
    "text": "Therefore, a database without WAL is vulnerable to system failures.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.1. Insertion Operations without WAL",
    "text": "Before WAL was introduced (versions 7.0 or earlier), PostgreSQL did synchronous writes to the disk by issuing a sync system call whenever a page was changed in memory in order to ensure durability.\nThis made modification commands such as INSERT and UPDATE very poor-performing.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.2. Insertion Operations and Database Recovery",
    "text": "To deal with the system failures mentioned above without compromising performance, PostgreSQL supports WAL.\nIn this subsection, some keywords and key concepts are described, followed by the writing of WAL data and the recovery of the database.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.2. Insertion Operations and Database Recovery",
    "text": "PostgreSQL writes all modifications as history data into a persistent storage to prepare for failures.\nIn PostgreSQL, the history data are known as XLOG record(s) or WAL data.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.2. Insertion Operations and Database Recovery",
    "text": "XLOG records are written into the in-memory WAL buffer by change operations such as insertion, deletion, or commit action.\nThey are immediately written into a WAL segment file on the storage when a transaction commits or aborts.\n(To be precise, the writing of XLOG records may occur in other cases. The details will be described in Section 9.5.)\nThe LSN (Log Sequence Number) of an XLOG record represents the location where its record is written on the transaction log.\nThe LSN of a record is used as the unique id of the XLOG record.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.2. Insertion Operations and Database Recovery",
    "text": "When considering how a database system recovers, one question that may arise is: what point does PostgreSQL start to recover from? The answer is the REDO point.\nThat is the location to write the XLOG record at the moment when the latest checkpoint is started.\n(Checkpoints in PostgreSQL are described in Section 9.7.)\nIn fact, the database recovery process is closely linked to the checkpoint process, and both of these processes are inseparable.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.2. Insertion Operations and Database Recovery",
    "text": "The WAL and checkpoint process were implemented at the same time in version 7.1.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.2. Insertion Operations and Database Recovery",
    "text": "As the introduction of major keywords and concepts has just finished, the following is a description of the tuple insertion with WAL.\nSee Figure 9.2 and the following description.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.2. Insertion Operations and Database Recovery",
    "text": "TABLE_A’s LSN shows the value of ‘pd_lsn’ within the page-header of TABLE_A.\n\nPage’s LSN is the same manner.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.2. Insertion Operations and Database Recovery",
    "text": "A checkpointer, a background process, periodically performs checkpointing.\nWhenever the checkpointer starts, it writes a XLOG record called checkpoint record to the current WAL segment.\nThis record contains the location of the latest REDO point.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.2. Insertion Operations and Database Recovery",
    "text": "When we issue the first INSERT statement,\nPostgreSQL loads the TABLE_A page into the shared buffer pool,\ninserts a tuple into the page,\ncreates and writes a XLOG record of this statement into the WAL buffer at the location LSN_1,\nand updates the TABLE_A’s LSN from LSN_0 to LSN_1.\n\nIn this example, this XLOG record is a pair of a header-data and the tuple entire.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.2. Insertion Operations and Database Recovery",
    "text": "As this transaction commits,\nPostgreSQL creates and writes a XLOG record of this commit action into the WAL buffer,\nand then, writes and flushes all XLOG records on the WAL buffer to the WAL segment file, from LSN_1.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.2. Insertion Operations and Database Recovery",
    "text": "When we issue the second INSERT statement,\nPostgreSQL inserts a new tuple into the page,\ncreates and writes this tuple’s XLOG record to the WAL buffer at LSN_2,\nand updates the TABLE_A’s LSN from LSN_1 to LSN_2.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.2. Insertion Operations and Database Recovery",
    "text": "When this statement’s transaction commits, PostgreSQL operates in the same manner as in step (3).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.2. Insertion Operations and Database Recovery",
    "text": "Imagine that an operating system failure occurs.\nEven though all of the data in the shared buffer pool is lost, all modifications to the page have been written to the WAL segment files as history data.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.2. Insertion Operations and Database Recovery",
    "text": "The following instructions show how to recover our database cluster back to the state immediately before the crash.\nThere is no need to do anything special, since PostgreSQL will automatically enter recovery-mode by restarting.\nSee Figure 9.3.\nPostgreSQL will sequentially read and replay XLOG records within the appropriate WAL segment files from the REDO point.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.2. Insertion Operations and Database Recovery",
    "text": "PostgreSQL reads the XLOG record of the first INSERT statement from the appropriate WAL segment file,\nand loads the TABLE_A page from the database cluster into the shared buffer pool.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.2. Insertion Operations and Database Recovery",
    "text": "Before trying to replay the XLOG record, PostgreSQL compares the XLOG record’s LSN with the corresponding page’s LSN.\nthe reason for doing this will be described in Section 9.8.\nThe rules for replaying XLOG records are as follows:\n\nIf the XLOG record’s LSN is larger than the page’s LSN,\nthe data-portion of the XLOG record is inserted into the page,\nand the page’s LSN is updated to the XLOG record’s LSN.\n\nOn the other hand,\nif the XLOG record’s LSN is smaller,\nthere is nothing to do other than to read next WAL record.\n\nIn this example,\nthe XLOG record is replayed since the XLOG record’s LSN (LSN_1) is larger than the TABLE_A’s LSN (LSN_0).\nThen, TABLE_A’s LSN is updated from LSN_0 to LSN_1.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.2. Insertion Operations and Database Recovery",
    "text": "PostgreSQL replays the remaining XLOG record(s) in the same way.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.2. Insertion Operations and Database Recovery",
    "text": "PostgreSQL can recover itself in this way by replaying XLOG records written in WAL segment files in chronological order.\nThus, PostgreSQL’s XLOG records are REDO log.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.2. Insertion Operations and Database Recovery",
    "text": "Although writing XLOG records certainly costs a certain amount, it is nothing compared to writing the entire modified pages.\nWe are confident that the benefit we gain, namely system failure tolerance, is greater than the amount we pay.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.3. Full-Page Writes",
    "text": "Suppose that the TABLE_A’s page data on the storage is corrupted because the operating system has failed while the background writer process has been writing the dirty pages.\nAs XLOG records cannot be replayed on the corrupted page, we would need an additional feature.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.3. Full-Page Writes",
    "text": "PostgreSQL supports a feature called full-page writes to deal with such failures.\nIf it is enabled, PostgreSQL writes a pair of the header data and the entire page as an XLOG record during the first change of each page after every checkpoint.\n(This is the default setting.)\nIn PostgreSQL, such a XLOG record containing the entire page is called a backup block (or full-page image).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 31,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.3. Full-Page Writes",
    "text": "Let’s describe the insertion of tuples again, but with full-page writes enabled.\nSee Figure 9.4 and the following description.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 32,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.3. Full-Page Writes",
    "text": "When we insert the first INSERT statement,\nPostgreSQL operates in the same way as in the previous subsection,\nexcept that this XLOG record is the backup block of this page,\nbecause this is the first writing of this page after the latest checkpoint.\n(In other words, it contains the entire page.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 33,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.3. Full-Page Writes",
    "text": "As this transaction commits,\nPostgreSQL operates in the same way as in the previous subsection.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 34,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.3. Full-Page Writes",
    "text": "When we insert the second INSERT statement,\nPostgreSQL operates in the same way as in the previous subsection,\nsince this XLOG record is not a backup block.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 35,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.3. Full-Page Writes",
    "text": "When this statement’s transaction commits,\nPostgreSQL operates in the same way as in the previous subsection.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 36,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.3. Full-Page Writes",
    "text": "To demonstrate the effectiveness of full-page writes,\nlet’s consider the case in which the TABLE_A page on the storage has been corrupted due to an operating system failure that occurred while the background writer was writing it to the storage (HDD or SSD).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 37,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.3. Full-Page Writes",
    "text": "Restart the PostgreSQL server to repair the broken cluster. See Figure 9.5 and the following description.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 38,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.3. Full-Page Writes",
    "text": "PostgreSQL reads the XLOG record of the first INSERT statement and loads the corrupted TABLE_A page from the database cluster into the shared buffer pool.\nIn this example, the XLOG record is a backup block,\nbecause the first XLOG record of each page is always its backup block according to the writing rule of full-page writes.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 39,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.3. Full-Page Writes",
    "text": "When a XLOG record is its backup block, another rule of replaying is applied: the record’s data-portion (i.e., the page itself) is to be overwritten onto the page regardless of the values of both LSNs, and the page’s LSN updated to the XLOG record’s LSN.\n\nIn this example, PostgreSQL overwrites the data-portion of the record to the corrupted page, and updates the TABLE_A’s LSN to LSN_1.\nIn this way, the corrupted page is restored by its backup block.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 40,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.3. Full-Page Writes",
    "text": "Since the second XLOG record is a non-backup block,\nPostgreSQL operates in the same way as the instruction in the previous subsection.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 41,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.3. Full-Page Writes",
    "text": "In this way, PostgreSQL can recover the database even if some data write errors occur due to a process or operating system crash.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.624924"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 42,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.3. Full-Page Writes",
    "text": "As mentioned above, WAL can prevent data loss due to process or operating system crashes.\nHowever, if a file system or media failure occurs, the data will be lost.\nTo deal with such failures, PostgreSQL provides online backup and replication features.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.625439"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 43,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.3. Full-Page Writes",
    "text": "If online backups are taken regularly,\nthe database can be restored from the most recent backup, even if a media failure occurs.\nHowever, it is important to note that the changes made after taking the last backup cannot be restored.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.625439"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 44,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.3. Full-Page Writes",
    "text": "The synchronous replication feature can store all changes to another storage or host in real time.\nThis means that if a media failure occurs on the primary server, the data can be restored from the secondary server.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.625439"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 45,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.3. Full-Page Writes",
    "text": "For more information, see Chapters 10 and 11, respectively.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.625439"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 46,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.3. Full-Page Writes",
    "text": "No. Synchronous replication does not eliminate the need for backups.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.625439"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 47,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.3. Full-Page Writes",
    "text": "Operating a DBMS requires addressing not only hardware or software failures but also data loss and errors caused by human mistakes or software bugs.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.625439"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 48,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.3. Full-Page Writes",
    "text": "For instance, if critical data is accidentally deleted, the deletion is immediately reflected on the replicated standby server.\nSimilarly, if erroneous data is written due to a mistake, the error propagates instantly across all replication servers.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.625439"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 49,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.1.3. Full-Page Writes",
    "text": "In such cases, replication cannot restore the lost or corrupted data.\nThe only way to recover from these critical failures is by using backup data (+ archive logs).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:42.625439"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "Logically, PostgreSQL writes XLOG records into a virtual file that is 8 bytes long (16 ExaBytes).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:43.475331"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "Since a transaction log capacity is effectively unlimited and so can be said that 8-bytes of address space is vast enough, it is impossible for us to handle a file with a capacity of 8 bytes.\nTherefore, a transaction log in PostgreSQL is divided into files of 16 megabytes, by default, each of which is known as a WAL segment.\nSee Figure 9.6.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:43.475331"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "In versions 11 or later, the size of WAL segment file can be configured using –wal-segsize option when PostgreSQL cluster is created by initdb command.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:43.475331"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "The WAL segment filename is in hexadecimal 24-digit number and the naming rule is as follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:43.475331"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "$$\n\\begin{align}\n\\text{WAL segment file name} = \\text{timelineId} + (\\text{uint32}) \\frac{\\text{LSN}-1}{16\\text{M}*256}\n+ ( \\text{uint32})\\left(\\frac{\\text{LSN}-1}{16\\text{M}}\\right) % 256\n\\end{align}\n$$",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:43.475331"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "PostgreSQL’s WAL contains the concept of timelineId (4-byte unsigned integer), which is for Point-in-Time Recovery (PITR) described in Chapter 10.\nHowever, the timelineId is fixed to 0x00000001 in this chapter because this concept is not required in the following descriptions.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:43.475331"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "The first WAL segment file is 000000010000000000000001.\nIf the first one has been filled up with the writing of XLOG records, the second one 000000010000000000000002 would be provided.\nFiles are used in ascending order in succession.\nAfter 0000000100000000000000FF has been filled up, the next one 000000010000000100000000 will be provided.\nIn this way, whenever the last 2-digit carries over, the middle 8-digit number increases one.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:43.475331"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "Similarly, after 0000000100000001000000FF has been filled up, 000000010000000200000000 will be provided, and so on.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:43.475331"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "Using the built-in function pg_xlogfile_name (versions 9.6 or earlier) or pg_walfile_name (versions 10 or later),\nwe can find the WAL segment file name that contains the specified LSN. An example is shown below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:43.475331"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "[CODE BLOCK]\ntestdb=# SELECT pg_xlogfile_name('1/00002D3E');  # In versions 10 or later, \"SELECT pg_walfile_name('1/00002D3E');\"\n     pg_xlogfile_name\n--------------------------\n 000000010000000100000000\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:43.475331"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "A WAL segment is a 16 MB file by default, and it is internally divided into pages of 8192 bytes (8 KB).\nThe first page has a header-data defined by the XLogLongPageHeaderData structure,\nwhile the headings of all other pages have the page information defined by the XLogPageHeaderData structure.\nFollowing the page header, XLOG records are written in each page from the beginning in descending order.\nSee Figure 9.7.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:44.327847"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "[CODE BLOCK]\ntypedef XLogPageHeaderData *XLogPageHeader;\n\n/*\n * When the XLP_LONG_HEADER flag is set, we store additional fields in the\n * page header.  (This is ordinarily done just in the first page of an\n * XLOG file.)\tThe additional fields serve to identify the file accurately.\n */\ntypedef struct XLogLongPageHeaderData\n{\n\tXLogPageHeaderData std;\t\t/* standard header fields */\n\tuint64\t\txlp_sysid;\t\t/* system identifier from pg_control */\n\tuint32\t\txlp_seg_size;\t/* just as a cross-check */\n\tuint32\t\txlp_xlog_blcksz;\t/* just as a cross-check */\n} XLogLongPageHeaderData;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:44.327847"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "[CODE BLOCK]\n/*\n * Each page of XLOG file has a header like this:\n */\n#define XLOG_PAGE_MAGIC 0xD113\t/* can be used as WAL version indicator */\n\ntypedef struct XLogPageHeaderData\n{\n\tuint16\t\txlp_magic;\t\t/* magic value for correctness checks */\n\tuint16\t\txlp_info;\t\t/* flag bits, see below */\n\tTimeLineID\txlp_tli;\t\t/* TimeLineID of first record on page */\n\tXLogRecPtr\txlp_pageaddr;\t/* XLOG address of this page */\n\n\t/*\n\t * When there is not enough space on current page for whole record, we\n\t * continue on the next page.  xlp_rem_len is the number of bytes\n\t * remaining from a previous page; it tracks xl_tot_len in the initial\n\t * header.  Note that the continuation data isn't necessarily aligned.\n\t */\n\tuint32\t\txlp_rem_len;\t/* total len of remaining data for record */\n} XLogPageHeaderData;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:44.327847"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "The XLogLongPageHeaderData structure and the XLogPageHeaderData structure are defined in src/include/access/xlog_internal.h.\nThe explanation of both structures is omitted because they are not required in the following descriptions.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:44.327847"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "An XLOG record comprises a general header portion and each associated data portion.\nThe first subsection describes the header structure.\nThe remaining two subsections explain the structure of the data portion in versions 9.4 and earlier, and version 9.5, respectively. (The data format changed in version 9.5.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.1. Header Portion of XLOG Record",
    "text": "All XLOG records have a general header portion defined by the XLogRecord structure.\nHere, the structure of 9.4 and earlier versions is shown below, although it has been changed in version 9.5.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.1. Header Portion of XLOG Record",
    "text": "[CODE BLOCK]\ntypedef struct XLogRecord\n{\n   uint32          xl_tot_len;   /* total len of entire record */\n   TransactionId   xl_xid;       /* xact id */\n   uint32          xl_len;       /* total len of rmgr data. This variable was removed in ver.9.5. */\n   uint8           xl_info;      /* flag bits, see below */\n   RmgrId          xl_rmid;      /* resource manager for this record */\n   /* 2 bytes of padding here, initialize to zero */\n   XLogRecPtr      xl_prev;      /* ptr to previous record in log */\n   pg_crc32        xl_crc;       /* CRC for this record */\n} XLogRecord;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.1. Header Portion of XLOG Record",
    "text": "In versions 9.5 or later, one variable (xl_len) has been removed the XLogRecord structure to refine the XLOG record format, which reduced the size by a few bytes.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.1. Header Portion of XLOG Record",
    "text": "[CODE BLOCK]\ntypedef struct XLogRecord\n{\n        uint32          xl_tot_len;             /* total len of entire record */\n        TransactionId \txl_xid;           \t/* xact id */\n        XLogRecPtr      xl_prev;                /* ptr to previous record in log */\n        uint8           xl_info;                /* flag bits, see below */\n        RmgrId          xl_rmid;                /* resource manager for this record */\n        /* 2 bytes of padding here, initialize to zero */\n        pg_crc32c       xl_crc;                 /* CRC for this record */\n        /* XLogRecordBlockHeaders and XLogRecordDataHeader follow, no padding */\n} XLogRecord;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.1. Header Portion of XLOG Record",
    "text": "Apart from two variables, most of the variables are so obvious that they do not need to be described.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.1. Header Portion of XLOG Record",
    "text": "Both xl_rmid and xl_info are variables related to resource managers, which are collections of operations associated with the WAL feature, such as writing and replaying of XLOG records.\nThe number of resource managers tends to increase with each PostgreSQL version.\nVersion 10 contains the following:",
    "tables": [
      {
        "table_index": 0,
        "content": "Operation | Resource manager\nHeap tuple operations | RM_HEAP, RM_HEAP2\nIndex operations | RM_BTREE, RM_HASH, RM_GIN, RM_GIST, RM_SPGIST, RM_BRIN\nSequence operations | RM_SEQ\nTransaction operations | RM_XACT, RM_MULTIXACT, RM_CLOG, RM_XLOG, RM_COMMIT_TS\nTablespace operations | RM_SMGR, RM_DBASE, RM_TBLSPC, RM_RELMAP\nreplication and hot standby operations | RM_STANDBY, RM_REPLORIGIN, RM_GENERIC_ID, RM_LOGICALMSG_ID"
      }
    ],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.1. Header Portion of XLOG Record",
    "text": "Here are some representative examples of how resource managers work:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.1. Header Portion of XLOG Record",
    "text": "If an INSERT statement is issued, the header variables xl_rmid and xl_info of its XLOG record are set to ‘RM_HEAP’ and ‘XLOG_HEAP_INSERT’, respectively.\nWhen recovering the database cluster, the RM_HEAP’s function heap_xlog_insert() is selected according to the xl_info and replays this XLOG record.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.1. Header Portion of XLOG Record",
    "text": "Similarly, for an UPDATE statement, the header variable xl_info of the XLOG record is set to ‘XLOG_HEAP_UPDATE’, and the RM_HEAP’s function heap_xlog_update() replays its record when the database recovers.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.1. Header Portion of XLOG Record",
    "text": "When a transaction commits, the header variables xl_rmid and xl_info of its XLOG record are set to ‘RM_XACT’ and ‘XLOG_XACT_COMMIT’, respectively.\nWhen recovering the database cluster, the function xact_redo_commit() replays this record.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.1. Header Portion of XLOG Record",
    "text": "XLogRecord structure in versions 9.4 or earlier is defined in src/include/access/xlog.h and that of versions 9.5 or later is defined in src/include/access/xlogrecord.h.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.1. Header Portion of XLOG Record",
    "text": "The heap_xlog_insert and heap_xlog_update are defined in src/backend/access/heap/heapam.c; while the function xact_redo_commit is defined in src/backend/access/transam/xact.c.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.2. Data Portion of XLOG Record (versions 9.4 or earlier)",
    "text": "The data portion of an XLOG record can be classified into either a backup block (which contains the entire page) or a non-backup block (which contains different data depending on the operation).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.2. Data Portion of XLOG Record (versions 9.4 or earlier)",
    "text": "The internal layouts of XLOG records are described below, using some specific examples.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.2. Data Portion of XLOG Record (versions 9.4 or earlier)",
    "text": "A backup block is shown in Figure 9.8(a).\nIt is composed of two data structures and one data object:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.2. Data Portion of XLOG Record (versions 9.4 or earlier)",
    "text": "The BkpBlock structure contains the variables that identify the page in the database cluster (i.e., the relfilenode and the fork number of the relation that contains the page, and the page’s block number),\nas well as the starting position and length of the page’s free space.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.2. Data Portion of XLOG Record (versions 9.4 or earlier)",
    "text": "[CODE BLOCK]\ntypedef struct BkpBlock @ include/access/xlog_internal.h\n{\n  RelFileNode node;        /* relation containing block */\n  ForkNumber  fork;        /* fork within the relation */\n  BlockNumber block;       /* block number */\n  uint16      hole_offset; /* number of bytes before \"hole\" */\n  uint16      hole_length; /* number of bytes in \"hole\" */\n\n  /* ACTUAL BLOCK DATA FOLLOWS AT END OF STRUCT */\n} BkpBlock;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.2. Data Portion of XLOG Record (versions 9.4 or earlier)",
    "text": "In non-backup blocks, the layout of the data portion differs depending on the operation.\nHere, the XLOG record for an INSERT statement is explained as a representative example.\nSee Figure 9.8(b).\nIn this case, the XLOG record for the INSERT statement is composed of two data structures and one data object:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.2. Data Portion of XLOG Record (versions 9.4 or earlier)",
    "text": "The xl_heap_insert structure contains the variables that identify the inserted tuple in the database cluster (i.e., the relfilenode of the table that contains this tuple, and the tuple’s tid), as well as a visibility flag of this tuple.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.2. Data Portion of XLOG Record (versions 9.4 or earlier)",
    "text": "[CODE BLOCK]\ntypedef struct BlockIdData\n{\n   uint16          bi_hi;\n   uint16          bi_lo;\n} BlockIdData;\n\ntypedef uint16 OffsetNumber;\n\ntypedef struct ItemPointerData\n{\n   BlockIdData     ip_blkid;\n   OffsetNumber    ip_posid;\n}\n\ntypedef struct RelFileNode\n{\n   Oid             spcNode;             /* tablespace */\n   Oid             dbNode;              /* database */\n   Oid             relNode;             /* relation */\n} RelFileNode;\n\ntypedef struct xl_heaptid\n{\n   RelFileNode     node;\n   ItemPointerData tid;                 /* changed tuple id */\n} xl_heaptid;\n\ntypedef struct xl_heap_insert\n{\n   xl_heaptid      target;              /* inserted tuple id */\n   bool            all_visible_cleared; /* PD_ALL_VISIBLE was cleared */\n} xl_heap_insert;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.2. Data Portion of XLOG Record (versions 9.4 or earlier)",
    "text": "The reason to remove a few bytes from inserted tuple is described in the source code comment of the structure xl_heap_header:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.2. Data Portion of XLOG Record (versions 9.4 or earlier)",
    "text": "We don’t store the whole fixed part (HeapTupleHeaderData) of an inserted or updated tuple in WAL;\nwe can save a few bytes by reconstructing the fields that are available elsewhere in the WAL record, or perhaps just plain needn’t be reconstructed.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.2. Data Portion of XLOG Record (versions 9.4 or earlier)",
    "text": "One more example will be shown here.\nSee Figure 9.8(c).\nThe XLOG record for a checkpoint record is quite simple; it is composed of two data structures:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.2. Data Portion of XLOG Record (versions 9.4 or earlier)",
    "text": "The xl_heap_header structure (versions 9.4 or earlier) is defined in src/include/access/heapam_xlog.h while the CheckPoint structure is defined in src/include/catalog/pg_control.h.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "In versions 9.4 or earlier, there was no common format for XLOG records, so each resource manager had to define its own format.\nThis made it increasingly difficult to maintain the source code and implement new features related to WAL.\nTo address this issue, a common structured format that is independent of resource managers was introduced in version 9.5.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "The data portion of an XLOG record can be divided into two parts: header and data.\nSee Figure 9.9.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "The header part contains zero or more XLogRecordBlockHeaders and zero or one XLogRecordDataHeaderShort (or XLogRecordDataHeaderLong).\nIt must contain at least one of these.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "When the record stores a full-page image (i.e., a backup block), the XLogRecordBlockHeader includes the XLogRecordBlockImageHeader, and also includes the XLogRecordBlockCompressHeader if its block is compressed.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "[CODE BLOCK]\n/*\n * Header info for block data appended to an XLOG record.\n *\n * 'data_length' is the length of the rmgr-specific payload data associated\n * with this block. It does not include the possible full page image, nor\n * XLogRecordBlockHeader struct itself.\n *\n * Note that we don't attempt to align the XLogRecordBlockHeader struct!\n * So, the struct must be copied to aligned local storage before use.\n */\ntypedef struct XLogRecordBlockHeader\n{\n\tuint8\t\tid;\t\t\t\t/* block reference ID */\n\tuint8\t\tfork_flags;\t\t/* fork within the relation, and flags */\n\tuint16\t\tdata_length;\t/* number of payload bytes (not including page\n\t\t\t\t\t\t\t\t * image) */\n\n\t/* If BKPBLOCK_HAS_IMAGE, an XLogRecordBlockImageHeader struct follows */\n\t/* If BKPBLOCK_SAME_REL is not set, a RelFileLocator follows */\n\t/* BlockNumber follows */\n} XLogRecordBlockHeader;\n\n/*\n * The fork number fits in the lower 4 bits in the fork_flags field. The upper\n * bits are used for flags.\n */\n#define BKPBLOCK_FORK_MASK\t0x0F\n#define BKPBLOCK_FLAG_MASK\t0xF0\n#define BKPBLOCK_HAS_IMAGE\t0x10\t/* block data is an XLogRecordBlockImage */\n#define BKPBLOCK_HAS_DATA\t0x20\n#define BKPBLOCK_WILL_INIT\t0x40\t/* redo will re-init the page */\n#define BKPBLOCK_SAME_REL\t0x80\t/* RelFileLocator omitted, same as\n\t\t\t\t\t\t\t\t\t * previous */",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 31,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "[CODE BLOCK]\n/*\n * Additional header information when a full-page image is included\n * (i.e. when BKPBLOCK_HAS_IMAGE is set).\n *\n * The XLOG code is aware that PG data pages usually contain an unused \"hole\"\n * in the middle, which contains only zero bytes.  Since we know that the\n * \"hole\" is all zeros, we remove it from the stored data (and it's not counted\n * in the XLOG record's CRC, either).  Hence, the amount of block data actually\n * present is (BLCKSZ - <length of \"hole\" bytes>).\n *\n * Additionally, when wal_compression is enabled, we will try to compress full\n * page images using one of the supported algorithms, after removing the\n * \"hole\". This can reduce the WAL volume, but at some extra cost of CPU spent\n * on the compression during WAL logging. In this case, since the \"hole\"\n * length cannot be calculated by subtracting the number of page image bytes\n * from BLCKSZ, basically it needs to be stored as an extra information.\n * But when no \"hole\" exists, we can assume that the \"hole\" length is zero\n * and no such an extra information needs to be stored. Note that\n * the original version of page image is stored in WAL instead of the\n * compressed one if the number of bytes saved by compression is less than\n * the length of extra information. Hence, when a page image is successfully\n * compressed, the amount of block data actually present is less than\n * BLCKSZ - the length of \"hole\" bytes - the length of extra information.\n */\ntypedef struct XLogRecordBlockImageHeader\n{\n\tuint16\t\tlength;\t\t\t/* number of page image bytes */\n\tuint16\t\thole_offset;\t/* number of bytes before \"hole\" */\n\tuint8\t\tbimg_info;\t\t/* flag bits, see below */\n\n\t/*\n\t * If BKPIMAGE_HAS_HOLE and BKPIMAGE_COMPRESSED(), an\n\t * XLogRecordBlockCompressHeader struct follows.\n\t */\n} XLogRecordBlockImageHeader;\n\n/* Information stored in bimg_info */\n#define BKPIMAGE_HAS_HOLE\t\t0x01\t/* page image has \"hole\" */\n#define BKPIMAGE_APPLY\t\t\t0x02\t/* page image should be restored\n\t\t\t\t\t\t\t\t\t\t * during replay */\n/* compression methods supported */\n#define BKPIMAGE_COMPRESS_PGLZ\t0x04\n#define BKPIMAGE_COMPRESS_LZ4\t0x08\n#define BKPIMAGE_COMPRESS_ZSTD\t0x10\n\n#define\tBKPIMAGE_COMPRESSED(info) \\\n\t((info & (BKPIMAGE_COMPRESS_PGLZ | BKPIMAGE_COMPRESS_LZ4 | \\\n\t\t\t  BKPIMAGE_COMPRESS_ZSTD)) != 0)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 32,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "[CODE BLOCK]\n/*\n * Extra header information used when page image has \"hole\" and\n * is compressed.\n */\ntypedef struct XLogRecordBlockCompressHeader\n{\n\tuint16\t\thole_length;\t/* number of bytes in \"hole\" */\n} XLogRecordBlockCompressHeader;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 33,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "[CODE BLOCK]\n/*\n * XLogRecordDataHeaderShort/Long are used for the \"main data\" portion of\n * the record. If the length of the data is less than 256 bytes, the short\n * form is used, with a single byte to hold the length. Otherwise the long\n * form is used.\n *\n * (These structs are currently not used in the code, they are here just for\n * documentation purposes).\n */\ntypedef struct XLogRecordDataHeaderShort\n{\n\tuint8\t\tid;\t\t\t\t/* XLR_BLOCK_ID_DATA_SHORT */\n\tuint8\t\tdata_length;\t/* number of payload bytes */\n}\t\t\tXLogRecordDataHeaderShort;\n\n#define SizeOfXLogRecordDataHeaderShort (sizeof(uint8) * 2)\n\ntypedef struct XLogRecordDataHeaderLong\n{\n\tuint8\t\tid;\t\t\t\t/* XLR_BLOCK_ID_DATA_LONG */\n\t/* followed by uint32 data_length, unaligned */\n}\t\t\tXLogRecordDataHeaderLong;\n\n#define SizeOfXLogRecordDataHeaderLong (sizeof(uint8) + sizeof(uint32))",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 34,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "The data part is composed of zero or more block data and zero or one main data, which correspond to the XLogRecordBlockHeader(s) and to the XLogRecordDataHeader, respectively.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 35,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "In versions 9.5 or later,\nfull-page images within XLOG records can be compressed using the LZ compression method by setting the parameter wal_compression = enable.\nIn that case, the XLogRecordBlockCompressHeader structure will be added.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 36,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "This feature has two advantages and one disadvantage.\nThe advantages are reducing the I/O cost for writing records and suppressing the consumption of WAL segment files.\nThe disadvantage is consuming much CPU resource to compress.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 37,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "Some specific examples are shown below, as in the previous subsection.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 38,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "The backup block created by an INSERT statement is shown in Figure 9.10(a).\nIt is composed of four data structures and one data object:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 39,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "The XLogRecordBlockHeader structure contains the variables to identify the block in the database cluster (the relfilenode, the fork number, and the block number).\nThe XLogRecordImageHeader structure contains the length of this block and offset number.\n(These two header structures together can store the same data as the BkBlock structure used until version 9.4.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 40,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "The XLogRecordDataHeaderShort structure stores the length of the xl_heap_insert structure, which is the main data of the record.\n(See  below.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 41,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "The main data of an XLOG record that contains a full-page image is not used except in some special cases, such as logical decoding and speculative insertions.\nIt is ignored when the record is replayed, making it redundant data.\nThis may be improved in the future.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 42,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "In addition, the main data of backup block records depends on the statements that create them.\nFor example, an UPDATE statement appends xl_heap_lock or xl_heap_updated.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 43,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "Next, we will describe the non-backup block record created by the INSERT statement (see Figure 9.10(b)).\nIt is composed of four data structures and one data object:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 44,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "The XLogRecordBlockHeader structure contains three values (the relfilenode, the fork number, and the block number) to specify the block that the tuple was inserted into, and the length of the data portion of the inserted tuple.\nThe XLogRecordDataHeaderShort structure contains the length of the new xl_heap_insert structure, which is the main data of this record.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 45,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "The new xl_heap_insert structure contains only two values: the offset number of this tuple within the block, and a visibility flag.\nIt became very simple because the XLogRecordBlockHeader structure stores most of the data that was contained in the old xl_heap_insert structure.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 46,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "[CODE BLOCK]\ntypedef struct xl_heap_insert\n{\n        OffsetNumber\toffnum;            /* inserted tuple's offset */\n        uint8           flags;\n\n        /* xl_heap_header & TUPLE DATA in backup block 0 */\n} xl_heap_insert;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 47,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "As the final example, a checkpoint record is shown in the Figure 9.10(c).\nIt is composed of three data structures:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 48,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "The structure xl_heap_header is defined in src/include/access/htup.h and the CheckPoint structure is defined in src/include/catalog/pg_control.h.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 49,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "The new XLOG format, while more complex for human interpretation, is optimized for parser efficiency.\nAdditionally, many XLOG record types are now smaller in size.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 50,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "The sizes of the main structures are shown in Figures 9.8 and 9.10, allowing for the calculation and comparison of record sizes1.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 51,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.4.3. Data Portion of XLOG Record (versions 9.5 or later)",
    "text": "While the size of the new checkpoint is larger than the previous one, it includes more variables. ↩︎",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:45.194402"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "Having finished the warm-up exercises, we are now ready to understand the writing of XLOG records.\nThis section will provide a comprehensive overview of the process.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.049930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "First, issue the following statement to explore the PostgreSQL internals:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.049930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "By issuing the above statement, the internal function exec_simple_query() is invoked.\nThe pseudocode of exec_simple_query() is shown below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.049930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "[CODE BLOCK]\nexec_simple_query() @postgres.c\n\n(1) ExtendCLOG() @clog.c                  /* Write the state of this transaction\n                                           * \"IN_PROGRESS\" to the CLOG.\n                                           */\n(2) heap_insert()@heapam.c                /* Insert a tuple, creates a XLOG record,\n                                           * and invoke the function XLogInsert.\n                                           */\n(3)   XLogInsert() @xloginsert.c (9.4 or earlier, xlog.c)\n                                          /* Write the XLOG record of the inserted tuple\n                                           *  to the WAL buffer, and update page's pd_lsn.\n                                           */\n(4) finish_xact_command() @postgres.c     /* Invoke commit action.*/\n      XLogInsert() @xloginsert.c (9.4 or earlier, xlog.c)\n                                          /* Write a XLOG record of this commit action\n                                           * to the WAL buffer.\n                                           */\n(5)   XLogWrite() @xloginsert.c (9.4 or earlier, xlog.c)\n                                          /* Write and flush all XLOG records on\n                                           * the WAL buffer to WAL segment.\n                                           */\n(6) TransactionIdCommitTree() @transam.c  /* Change the state of this transaction\n                                           * from \"IN_PROGRESS\" to \"COMMITTED\"\n                                           * on the CLOG.\n                                           */",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.049930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "The following paragraphs explain each line of the pseudocode to illustrate XLOG record writing.\nFor a visual representation, refer to Figures 9.11 and 9.12.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.049930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "The function ExtendCLOG() writes the state of this transaction ‘IN_PROGRESS’ in the (in-memory) CLOG.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.049930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "The function heap_insert() inserts a heap tuple into the target page in the shared buffer pool, creates the XLOG record for that page, and invokes the function XLogInsert().",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.049930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "The function XLogInsert() writes the XLOG record created by the heap_insert() to the WAL buffer at LSN_1, and then updates the modified page’s pd_lsn from LSN_0 to LSN_1.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.049930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "The function finish_xact_command(), which invoked to commit this transaction, creates the XLOG record for the commit action, and then the function XLogInsert() writes this record to the WAL buffer at LSN_2.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.049930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "The function XLogWrite() writes and flushes all XLOG records on the WAL buffer to the WAL segment file.\n\nIf the parameter wal_sync_method is set to ‘open_sync’ or ‘open_datasync’, the records are synchronously written because the function writes all records with the open() system call specified the flag ‘O_SYNC’ or ‘O_DSYNC’.\n\nIf the parameter is set to ‘fsync’, ‘fsync_writethrough’ or ‘fdatasync’, the respective system call â fsync(), fcntl() with F_FULLFSYNC option, or fdatasync() â will be executed. In any case, all XLOG records are ensured to be written into the storage.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.049930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "The function TransactionIdCommitTree() changes the state of this transaction from ‘IN_PROGRESS’ to ‘COMMITTED’ on the CLOG.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.049930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "In the above example, the commit action caused the writing of XLOG records to the WAL segment, but such writing may be caused by any of the following:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.049930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "The WAL buffer has been filled up with many tuples.\n(The WAL buffer size is set to the parameter wal_buffers.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.049930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "A WAL writer process writes periodically. (See the next section.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.049930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "If any of the above occurs, all WAL records on the WAL buffer are written into a WAL segment file regardless of whether their transactions have been committed or not.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.049930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "PostgreSQL versions 15 or earlier do not support direct I/O, although it has been discussed.\nRefer to this discussion on the pgsql-ML and this article.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.049930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "In version 16, the debug-io-direct option has been added.\nThis option is for developers to improve the use of direct I/O in PostgreSQL.\nIf development goes well, direct I/O will be officially supported in the near future.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.049930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.5.1. Remark on Writing XLOG records",
    "text": "It is well understood that DML (Data Manipulation Language) operations generate XLOG records. However, non-DML operations can also create XLOG records.\nFor instance:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.049930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.5.1. Remark on Writing XLOG records",
    "text": "In special cases, even SELECT statements can generate XLOG records, despite typically not doing so. For example:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.049930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.5.1. Remark on Writing XLOG records",
    "text": "Additionally, if the wal_level parameter is set to replica or higher, ACCESS EXCLUSIVE LOCKS are also recorded as XLOG records.\nThis occurs not only when an ACCESS EXCLUSIVE LOCK is explicitly acquired using the LOCK command but also when commands like DROP TABLE and TRUNCATE (which acquire EXCLUSIVE LOCKS) are executed, as described in the official document.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.049930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.5.1. Remark on Writing XLOG records",
    "text": "Occasionally, users report unexpected increases in WAL segment consumption despite executing only SELECT commands. In such cases, check whether SELECT FOR UPDATE commands are being run. ↩︎",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.049930"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.1. WAL Writer Process",
    "text": "The WAL writer is a background process that periodically checks the WAL buffer and writes all unwritten XLOG records to the WAL segments.\nThis process helps to avoid bursts of XLOG record writing.\nIf the WAL writer is not enabled, writing XLOG records could be bottlenecked when a large amount of data is committed at once.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.920886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.1. WAL Writer Process",
    "text": "The WAL writer is enabled by default and cannot be disabled.\nThe check interval is set to the configuration parameter wal_writer_delay, which defaults to 200 milliseconds.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.920886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "Introduced in version 17 to support the incremental backups (described in Section 10.5).\nthe WAL Summarizer process tracks changes to all database blocks (including relations and visibility maps)\nand writes these modifications to WAL summary files located in the pg_wal/summaries/ directory.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.920886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "The configuration parameter summarize_wal enables the WAL summarizer process; it is disabled by default.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.920886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "Note that the free-space map fork is not tracked because it is not properly WAL-logged.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.920886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "In the context of the WAL Summarizer process, “previous REDO point” and “current REDO point” are referred to as “start_lsn” and “end_lsn,” respectively.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.920886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "[CODE BLOCK]\n$ ls -1 data/pg_wal/summaries/\n00000001000000000100002800000000010B1D30.summary\n0000000100000000010B1D300000000001473DE0.summary\n000000010000000001473DE00000000001473EE0.summary\n000000010000000001473EE0000000000147A8A8.summary\n00000001000000000147A8A8000000000147A9A8.summary\n\n... snip ...",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.920886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "The pg_available_wal_summaries() function can show the wal summaries:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.920886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "[CODE BLOCK]\ntestdb=# SELECT tli, start_lsn, end_lsn FROM pg_available_wal_summaries() ORDER BY start_lsn;\n tli | start_lsn  |  end_lsn\n-----+------------+------------\n   1 | 0/1000028  | 0/10B1D30\n   1 | 0/10B1D30  | 0/1473DE0\n   1 | 0/1473DE0  | 0/1473EE0\n   1 | 0/1473EE0  | 0/147A8A8\n   1 | 0/147A8A8  | 0/147A9A8\n\n... snip ...",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.920886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "Summary files are automatically removed after the configured wal_summary_keep_time (default 10 days) has passed since their creation.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.920886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "To illustrate the contents of a summary file,\nwe will create four tables, t1, t2, t3, and t4, each containing of four blocks:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.920886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "[CODE BLOCK]\ntestdb=# CREATE TABLE t1 (id int);\nCREATE TABLE\ntestdb=# INSERT INTO t1 SELECT  GENERATE_SERIES(1, 800);\nINSERT 0 800\ntestdb=# SELECT * FROM pg_freespace('t1');\n blkno | avail\n-------+-------\n     0 |     0\n     1 |     0\n     2 |     0\n     3 |     0\n(4 rows)\n\ntestdb=# CREATE TABLE t2 (id int);\nCREATE TABLE\ntestdb=# INSERT INTO t2 SELECT  GENERATE_SERIES(1, 800);\nINSERT 0 800\ntestdb=# CREATE TABLE t3 (id int);\nCREATE TABLE\ntestdb=# INSERT INTO t3 SELECT  GENERATE_SERIES(1, 800);\nINSERT 0 800\ntestdb=# CREATE TABLE t4 (id int);\nCREATE TABLE\ntestdb=# INSERT INTO t4 SELECT  GENERATE_SERIES(1, 800);\nINSERT 0 800\ntestdb=# CHECKPOINT;\nCHECKPOINT",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.920886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "After a CHECKPOINT, we will perform the following operations:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.920886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "[CODE BLOCK]\ntestdb=# -- [1] Update two rows to modify the blocks of t1\ntestdb=# UPDATE t1 SET id = id + 1000 WHERE id = 1 OR id = 200;\nUPDATE 2\ntestdb=# -- [2] Insert 150 rows to modify the last block and add a new block\ntestdb=# INSERT INTO t2 SELECT GENERATE_SERIES(1, 150);\nINSERT 0 150\ntestdb=# -- [3] Delete 500 rows to remove blocks\ntestdb=# DELETE FROM t3 WHERE id > 300;\nDELETE 500\ntestdb=# -- [4] Truncate all blocks\ntestdb=# TRUNCATE t4;\nTRUNCATE TABLE\ntestdb=# -- [5] Create new table\ntestdb=# CREATE TABLE t5 (id int);\nCREATE TABLE\ntestdb=# INSERT INTO t5 SELECT  GENERATE_SERIES(1, 800);\nINSERT 0 800\ntestdb=# CHECKPOINT;\nCHECKPOINT",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.920886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "Following these operations, we will examine the summary of changes to all relation blocks generated by the WALsummarizer process,\nusing the pg_wal_summary_contents() function.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.920886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "The pg_wal_summary_contents(timeline, start_lsn, end_lsn) function shows all changed blocks from start_lsn to end_lsn.\nThe output contains: filenode (OID), block number, fork number, is_limit_block (explained later), etc.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.920886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "[CODE BLOCK]\ntestdb=# UPDATE t1 SET id = id + 1000 WHERE id = 1 OR id = 200;\nUPDATE 2",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.920886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "Using the pg_wal_summary_contents() function, we can retrieve the summary data for table t1 as follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.920886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "[CODE BLOCK]\ntestdb=# SELECT p.relname, s.relforknumber, s.relblocknumber, s.is_limit_block\ntestdb-# \tFROM pg_wal_summary_contents(1, '0/1F4225F8', '0/1F476450') AS s, pg_class AS p\ntestdb-#  \tWHERE s.relfilenode = p.oid AND p.relname = 't1';\n relname | relforknumber | relblocknumber | is_limit_block\n---------+---------------+----------------+----------------\n t1      |             0 |              0 | f\n t1      |             0 |              3 | f\n(2 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.920886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "The output shows that the 0th and 3rd blocks of table t1 have been modified due to the UPDATE command.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.920886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "Figure 9.13 illustrates the modification of table t1, which reflects the summary data for t1.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.920886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "As a result, we can confirm that the 3rd block was changed and the new 4th block was added.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.920886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "[CODE BLOCK]\ntestdb=# SELECT p.relname, s.relforknumber, s.relblocknumber, s.is_limit_block\ntestdb-# \tFROM pg_wal_summary_contents(1, '0/1F4225F8', '0/1F476450') AS s, pg_class AS p\ntestdb-#  \tWHERE s.relfilenode = p.oid AND p.relname = 't2';\n relname | relforknumber | relblocknumber | is_limit_block\n---------+---------------+----------------+----------------\n t2      |             0 |              3 | f\n t2      |             0 |              4 | f\n(2 rows)\n\ntestdb=# select * from pg_freespace('t2');\n blkno | avail\n-------+-------\n     0 |     0\n     1 |     0\n     2 |     0\n     3 |     0\n     4 |     0\n(5 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.920886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "Figure 9.14 illustrates the modification of table t2, which reflects the summary data for t2.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.920886"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "[CODE BLOCK]\ntestdb=# SELECT p.relname, s.relforknumber, s.relblocknumber, s.is_limit_block\ntestdb-# \tFROM pg_wal_summary_contents(1, '0/1F4225F8', '0/1F476450') AS s, pg_class AS p\ntestdb-#  \tWHERE s.relfilenode = p.oid AND p.relname = 't3';\n relname | relforknumber | relblocknumber | is_limit_block\n---------+---------------+----------------+----------------\n t3      |             0 |              2 | t\n t3      |             0 |              1 | f\n t3      |             0 |              0 | f\n t3      |             2 |              2 | t\n t3      |             2 |              0 | f\n(5 rows)\n\ntestdb=# select * from pg_freespace('t3');\n blkno | avail\n-------+-------\n     0 |     0\n     1 |  5472\n(2 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.921885"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "According to the output, the 2nd and 3rd blocks were removed, and the remaining blocks, i.e., 0th and 1st blocks, were modified.\nMoreover, the 2nd block of t3’s visibility map was removed, and the 0th block was modified.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.921885"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "In this way, if blocks after a certain block number were deleted,\nthe block on the boundary of the deleted blocks is also recorded, and is_limit_block is set to true.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.921885"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "In this case, the 2nd block of table t3 and the 2nd block of table t3’s visibility space map are both set to is_limit_block = true,\nbecause both the 2nd block and the subsequent blocks were deleted.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.921885"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "Figure 9.15 illustrates the modification of table t3, which reflects the summary data for t3.\nAs shown in Figure 9.15, the limit block acts as a virtual termination block.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.921885"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "Since the truncated table t4 and visibility-map files were removed,\nthe block number for all related blocks was set to 0, and is_limit_block was set to true.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.921885"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 31,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "[CODE BLOCK]\ntestdb=# SELECT p.relname, s.relforknumber, s.relblocknumber, s.is_limit_block\ntestdb-# \tFROM pg_wal_summary_contents(1, '0/1F4225F8', '0/1F476450') AS s, pg_class AS p\ntestdb-#  \tWHERE s.relfilenode = p.oid AND p.relname = 't4';\n relname | relforknumber | relblocknumber | is_limit_block\n---------+---------------+----------------+----------------\n t4      |             0 |              0 | t\n t4      |             2 |              0 | t\n t4      |             3 |              0 | t  <= fork_num 3 is a special number,\n                                                  so the explanation is omitted here.\n(3 rows)\n\ntestdb=# select * from pg_freespace('t4');\n blkno | avail\n-------+-------\n(0 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.921885"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 32,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "Figure 9.16 illustrates the modification of table t4, which reflects the summary data for t4.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.921885"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 33,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "This same result returns when DROP TABLE is executed.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.921885"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 34,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "Not only when data blocks are removed,\nbut also when a new table is created, the block number of the created relation is set to 0, and is_limit_block is set to true.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.921885"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 35,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "In this case, we created table t5 and inserted rows into it.\nTherefore, the summary file contains two rows that are both for the 0th block of table t5, but is_limit_block is true and false, respectively.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.921885"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 36,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "[CODE BLOCK]\ntestdb=# SELECT p.relname, s.relforknumber, s.relblocknumber, s.is_limit_block\ntestdb-# \tFROM pg_wal_summary_contents(1, '0/1F4225F8', '0/1F476450') AS s, pg_class AS p\ntestdb-#  \tWHERE s.relfilenode = p.oid AND p.relname = 't5';\n relname | relforknumber | relblocknumber | is_limit_block\n---------+---------------+----------------+----------------\n t5      |             0 |              0 | t\n t5      |             0 |              0 | f\n t5      |             0 |              1 | f\n t5      |             0 |              2 | f\n t5      |             0 |              3 | f\n t5      |             2 |              0 | f\n(6 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.921885"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/06.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 37,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.6.2. WAL Summarizer Process",
    "text": "Figure 9.17 illustrates the modification of table t5, which reflects the summary data for t5.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:46.921885"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "In PostgreSQL, the checkpointer (background) process performs checkpoints.\nIt starts when one of the following occurs:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:47.775817"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "The interval time set for checkpoint_timeout from the previous checkpoint has been elapsed (the default interval is 300 seconds).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:47.775817"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "In versions 9.4 or earlier, the number of WAL segment files set for checkpoint_segments has been consumed since the previous checkpoint (the default number is 3).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:47.775817"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "In versions 9.5 or later, the total size of the WAL segment files in the pg_wal (in versions 9.6 or earlier, pg_xlog) directory has exceeded the value of the parameter max_wal_size (the default value is 1GB (64 files)).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:47.775817"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "The PostgreSQL server stops in smart or fast mode.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:47.775817"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "A superuser issues the CHECKPOINT command manually.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:47.775817"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "In versions 9.1 or earlier, as mentioned in Section 8.6,\nthe background writer process did both checkpinting and dirty-page writing.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:47.775817"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "In the following subsections,\nthe outline of checkpointing and the pg_control file, which holds the metadata of the current checkpoint, are described.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:47.775817"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.7.1. Outline of the Checkpoint Processing",
    "text": "The checkpoint process has two aspects: preparing for database recovery, and cleaning dirty pages in the shared buffer pool.\nIn this subsection, we will focus on the former aspect and describe its internal processing.\nSee Figure 9.18 for an overview.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:47.775817"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.7.1. Outline of the Checkpoint Processing",
    "text": "When a checkpoint process starts, the REDO point is stored in memory. The REDO point is the location of the XLOG record written at the moment this checkpoint process began. It is the starting point for database recovery.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:47.775817"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.7.1. Outline of the Checkpoint Processing",
    "text": "All data in shared memory (e.g., the contents of the clog, etc..) is flushed to the storage.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:47.775817"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.7.1. Outline of the Checkpoint Processing",
    "text": "All dirty pages in the shared buffer pool are gradually written and flushed to the storage.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:47.775817"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.7.1. Outline of the Checkpoint Processing",
    "text": "A XLOG record of this checkpoint (i.e., the checkpoint record) is written to the WAL buffer.\nThe data-portion of the record is defined by the CheckPoint structure, which contains several variables such as the REDO point stored in step (1).\n\nThe location where the checkpoint record is written is also called the checkpoint.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:47.775817"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.7.1. Outline of the Checkpoint Processing",
    "text": "The pg_control file is updated.\nThis file contains fundamental information such as the location where the checkpoint record was written (a.k.a. the checkpoint location).\nWe will discuss this file in more detail later.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:47.775817"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.7.1. Outline of the Checkpoint Processing",
    "text": "[CODE BLOCK]\ntypedef struct CheckPoint\n{\n  XLogRecPtr      redo;           /* next RecPtr available when we began to\n                                   * create CheckPoint (i.e. REDO start point) */\n  TimeLineID      ThisTimeLineID; /* current TLI */\n  TimeLineID      PrevTimeLineID; /* previous TLI, if this record begins a new\n                                   * timeline (equals ThisTimeLineID otherwise) */\n  bool            fullPageWrites; /* current full_page_writes */\n  uint32          nextXidEpoch;   /* higher-order bits of nextXid */\n  TransactionId   nextXid;        /* next free XID */\n  Oid             nextOid;        /* next free OID */\n  MultiXactId     nextMulti;      /* next free MultiXactId */\n  MultiXactOffset nextMultiOffset;/* next free MultiXact offset */\n  TransactionId   oldestXid;      /* cluster-wide minimum datfrozenxid */\n  Oid             oldestXidDB;    /* database with minimum datfrozenxid */\n  MultiXactId     oldestMulti;    /* cluster-wide minimum datminmxid */\n  Oid             oldestMultiDB;  /* database with minimum datminmxid */\n  pg_time_t       time;           /* time stamp of checkpoint */\n\n /*\n  * Oldest XID still running. This is only needed to initialize hot standby\n  * mode from an online checkpoint, so we only bother calculating this for\n  * online checkpoints and only when wal_level is hot_standby. Otherwise\n  * it's set to InvalidTransactionId.\n  */\n  TransactionId oldestActiveXid;\n} CheckPoint;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:47.775817"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.7.1. Outline of the Checkpoint Processing",
    "text": "To summarize the description above from the perspective of database recovery, checkpointing creates a checkpoint record that contains the REDO point, and stores the checkpoint location and other information in the pg_control file.\nThis allows PostgreSQL to recover itself by replaying WAL data from the REDO point (obtained from the checkpoint record) provided by the pg_control file.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:47.775817"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.7.2. pg_control File",
    "text": "As the pg_control file contains the fundamental information of the checkpoint, it is essential for database recovery.\nIf it is corrupted or unreadable, the recovery process cannot start because it cannot obtain a starting point.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:47.775817"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.7.2. pg_control File",
    "text": "Even though pg_control file stores over 40 items, three items that will be needed in the next section are shown below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:47.775817"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.7.2. pg_control File",
    "text": "State â The state of the database server at the time the latest checkpoint was started.\nThere are seven states in total:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:47.775817"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.7.2. pg_control File",
    "text": "Latest checkpoint location â The LSN Location of the latest checkpoint record.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:47.775817"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.7.2. pg_control File",
    "text": "Prior checkpoint location  â The LSN Location of the prior checkpoint record.\nNote that this is deprecated in version 11; the details are described in  below.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:47.775817"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.7.2. pg_control File",
    "text": "A pg_control file is stored in the global subdirectory under the base-directory.\nIts contents can be shown using the pg_controldata utility.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:47.775817"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.7.2. pg_control File",
    "text": "[CODE BLOCK]\n$ pg_controldata  /usr/local/pgsql/data\npg_control version number:            1300\nCatalog version number:               202306141\nDatabase system identifier:           7250496631638317596\nDatabase cluster state:               in production\npg_control last modified:             Mon Jan 1 15:16:38 2024\nLatest checkpoint location:           0/16AF0090\nLatest checkpoint's REDO location:    0/16AF0090\nLatest checkpoint's REDO WAL file:    000000010000000000000016\n\n... snip ...",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:47.775817"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/07.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.7.2. pg_control File",
    "text": "PostgreSQL 11 or later only stores the  WAL segments that contain the latest checkpoint or newer.\nOlder segment files, which contains the prior checkpoint, are not stored to reduce the disk space used for saving WAL segment files under the pg_wal subdirectory.\nSee this thread in details.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:47.775817"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "PostgreSQL implements redo log-based recovery.\nIf the database server crashes, PostgreSQL can restore the database cluster by sequentially replaying the XLOG records in the WAL segment files from the REDO point.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:48.626183"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "We have already discussed database recovery several times.\nThis section will cover two additional aspects of recovery.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:48.626183"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "The first thing is how PostgreSQL starts the recovery process.\nWhen PostgreSQL starts up, it first reads the pg_control file.\nThe following are the details of the recovery process from that point.\nSee Figure 9.19 and the following description.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:48.626183"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "PostgreSQL reads all items in the pg_control file when it starts.\nIf the state item is ‘in production’,\nPostgreSQL enters recovery-mode because this means that the database was not shut down normally.\nIf it is ‘shut down’, PostgreSQL enters normal startup-mode.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:48.626183"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "PostgreSQL reads the latest checkpoint record, the location of which is written in the pg_control file, from the appropriate WAL segment file.\nIt then gets the REDO point from the record.\nIf the latest checkpoint record is invalid, PostgreSQL reads the one prior to it.\nIf both records are unreadable, it gives up recovering by itself.\n(Note that the prior checkpoint is not stored in PostgreSQL 11 or later.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:48.626183"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "The appropriate resource managers read and replay XLOG records in sequence from the REDO point until they reach the end of the latest WAL segment.\nWhen an XLOG record is replayed and if it is a backup block, it is overwritten on the corresponding table page regardless of its LSN.\nOtherwise, a (non-backup block) XLOG record is replayed only if the LSN of the record is greater than the ‘pd_lsn’ of the corresponding page.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:48.626183"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "The second point is about the comparison of LSNs: why the non-backup block’s LSN and the corresponding page’s pd_lsn should be compared.\nUnlike the previous examples, this will be explained using a specific example that emphasizes the need for this comparison.\nSee Figures 9.20 and 9.21.\n(Note that the WAL buffer is omitted to simplify the description.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:48.626183"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "PostgreSQL inserts a tuple into the TABLE_A, and writes an XLOG record at LSN_1.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:48.626183"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "The background-writer process writes the TABLE_A page to storage. At this point, this page’s pd_lsn is LSN_1.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:48.626183"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "PostgreSQL inserts a new tuple into the TABLE_A, and writes a XLOG record at LSN_2. The modified page is not written into the storage yet.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:48.626183"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "Unlike the examples in overview, the TABLE_A’s page has been once written to the storage in this scenario.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:48.626183"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "Do shutdown with immediate-mode, and then start the database.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:48.626183"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "PostgreSQL loads the first XLOG record and the TABLE_A page, but does not replay it because the LSN of the record (LSN_1) is not larger than the LSN of the page (also LSN_1). In fact, it is clear that there is no need to replay it.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:48.626183"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "Next, PostgreSQL replays the second XLOG record because the LSN of the record (LSN_2) is greater than the current LSN of the TABLE_A page (LSN_1).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:48.626183"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "In this example, if the replay order of non-backup blocks is incorrect or non-backup blocks are replayed more than once,\nthe database cluster becomes inconsistent.\nThis highlights that the redo (replay) operation for non-backup blocks is not idempotent.\nTo ensure the correct replay order,\nnon-backup block records should only be replayed when their LSN is greater than the corresponding page’s pd_lsn.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:48.626183"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/08.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "In contrast, the redo operation for backup blocks is idempotent,\nmeaning these blocks can be replayed multiple times regardless of their LSN.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:48.626183"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "PostgreSQL writes XLOG records to one of the WAL segment files stored in the pg_wal subdirectory (in versions 9.6 or earlier, pg_xlog subdirectory).\nA new WAL segment file is switched in if the old one has been filled up.\nThe number of WAL files varies depending on several configuration parameters, as well as server activity.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:49.477056"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "Starting with version 9.4,\nthe number of WAL files can also be controlled based on replication status using Replication Slots.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:49.477056"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "In addition, the management policy for WAL segment files has been improved in version 9.5.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:49.477056"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "The following subsections describe WAL segment file switching and basic management methods.\nReplication slots are explained in detail in Section 11.4.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:49.477056"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.9.1. WAL Segment Switches",
    "text": "WAL segment switches occur when one of the following events happens:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:49.477056"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.9.1. WAL Segment Switches",
    "text": "The archive_mode parameter is enabled and the archive_timeout parameter has expired.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:49.477056"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.9.1. WAL Segment Switches",
    "text": "When a WAL segment file is switched, it is usually recycled (renamed and reused) for future use.\nHowever, it may be removed later if it is not needed.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:49.477056"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.9.2. WAL Segment Management",
    "text": "Whenever a checkpoint starts, PostgreSQL estimates and prepares the number of WAL segment files that will be needed for the next checkpoint cycle.\nThis estimate is based on the number of WAL segment files that were consumed in previous checkpoint cycles.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:49.477056"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.9.2. WAL Segment Management",
    "text": "The number of WAL segment files is counted from the segment that contains the prior REDO point,\nand the value must be between the min_wal_size parameter (which default to 80 MB, or 5 files) and the max_wal_size parameter  (which default to 1 GB, or 64 files).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:49.477056"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.9.2. WAL Segment Management",
    "text": "If a checkpoint starts, PostgreSQL will keep or recycle the necessary WAL segment files, and remove any unnecessary files.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:49.477056"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.9.2. WAL Segment Management",
    "text": "A specific example is shown in Figure 9.22.\nAssuming that there are six WAL segment files before a checkpoint starts, WAL_3 contains the prior REDO point (in versions 10 or earlier; in versions 11 or later, the REDO point), and PostgreSQL estimates that five files will be needed.\nIn this case, WAL_1 will be renamed as WAL_7 for recycling and WAL_2 will be removed.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:49.477056"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.9.2. WAL Segment Management",
    "text": "The files older than the one that contains the prior REDO point can be removed, because, as is clear from the recovery mechanism described in Section 9.8, they would never be used.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:49.477056"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.9.2. WAL Segment Management",
    "text": "If more WAL segment files are required due to a spike in WAL activity, new WAL segment files will be created while the total size of the WAL segment files is less than the max_wal_size parameter.\nFor example, in Figure 9.23, if WAL_7 has been filled up, WAL_8 will be newly created.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:49.477056"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.9.2. WAL Segment Management",
    "text": "The number of WAL segment files adapts to the server activity.\nIf the amount of WAL data writing has been constantly increasing, the estimated number of WAL segment files, as well as the total size of the WAL segment files, will gradually increase.\nIn the opposite case (i.e., the amount of WAL data writing has decreased), these will decrease.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:49.477056"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.9.2. WAL Segment Management",
    "text": "If the total size of the WAL segment files exceeds the max_wal_size parameter, a checkpoint will be started.\nFigure 9.24 illustrates this situation.\nBy checkpointing, a new REDO point will be created and the prior REDO point will be discarded; then, unnecessary old WAL segment files will be recycled.\nIn this way, PostgreSQL will always keep just the WAL segment files that are needed for database recovery.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:49.477056"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/09.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": "9.9.2. WAL Segment Management",
    "text": "The wal_keep_size\n(or wal_keep_segments in versions 12 or earlier)\nand the replication slot feature also affect the number of WAL segment files.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:49.477056"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "Continuous archiving is a feature that copies WAL segment files to an archival area at the time when a WAL segment switch occurs.\nIt is performed by the archiver (background) process.\nThe copied file is called an archive log.\nThis feature is typically used for hot physical backup and PITR (Point-in-Time Recovery), which are described in Chapter 10.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:50.328181"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "The path to the  archival area is set by the archive_command configuration parameter.\nFor example,\nthe following parameter would copy WAL segment files to the directory ‘/home/postgres/archives/’ every time a segment switch occurs:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:50.328181"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "[CODE BLOCK]\narchive_command = 'cp %p /home/postgres/archives/%f'",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:50.328181"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "where,\nthe ‘%p’ placeholder represents the copied WAL segment, and the ‘%f’ placeholder represents the archive log.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:50.328181"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "When the WAL segment file WAL_7 is switched, the file is copied to the archival area as Archive log 7.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:50.328181"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "The archive_command parameter can be set to any Unix command or tool.\nThis enables the use of scp or other file backup tools to transfer archive logs to remote hosts, instead of relying on simple copy commands.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:50.328181"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "PostgreSQL versions 14 and earlier relied on shell commands for continuous archiving.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:50.328181"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "However, version 15 introduced a loadable library feature, enabling continuous archiving through library-based mechanisms.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:50.328181"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "For further details, consult the documentation on archive_library and basic_archive.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:50.328181"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "PostgreSQL does not automatically clean up created archive logs, so proper log management is essential when using this feature.\nWithout intervention, the number of archive logs will continuously grow.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:50.328181"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "The pg_archivecleanup utility is one of the useful tools for managing archive log files.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:50.328181"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "Additionally, the find command can be used to delete old archive logs.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:50.328181"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "For instance, to remove logs older than three days:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:50.328181"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql09/10.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 9: Write Ahead Logging (WAL)",
    "section": null,
    "text": "[CODE BLOCK]\n$ find /home/postgres/archives -mtime +3d -exec rm  -f {} \\;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:50.328181"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "Before the introduction of the pg_basebackup utility in version 9.1,\nonline (full) backups were performed using the pg_backup_start and pg_backup_stop commands (versions 8.0 to 9.0).\nWhile these commands are no longer commonly used, understanding them is essential for comprehending PostgreSQL’s backup and Point-in-Time Recovery (PITR) mechanisms.\nWe will explore them in more detail in the following subsections and then discuss how pg_basebackup works.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "Figure 10.1 shows the standard procedure for taking a base backup using these commands is as follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "This procedure does not require table locks, allowing all users to continue issuing queries without being affected by the backup operation.\nThis is a significant advantage over other major open-source RDBMSs.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "The pg_basebackup utility internally invokes the commands described above and therefore inherits their advantages.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "The pg_backup_start and pg_backup_stop commands are defined here: src/backend/access/transam/xlogfuncs.c.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.1. pg_backup_start (Ver.14 or earlier, pg_start_backup)",
    "text": "The pg_backup_start command, internally invokes do_pg_backup_start() function, prepares for making a base backup.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.1. pg_backup_start (Ver.14 or earlier, pg_start_backup)",
    "text": "As discussed in Section 9.8, the recovery process starts from a REDO point, so the pg_backup_start command must do a checkpoint to explicitly create a REDO point at the start of making a base backup.\nMoreover, the checkpoint location of its checkpoint must be saved in a file other than pg_control because regular checkpoints might be done a number of times during the backup.\nTherefore, the pg_backup_start performs the following four operations:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.1. pg_backup_start (Ver.14 or earlier, pg_start_backup)",
    "text": "Switch to the new WAL segment file (versions 8.4 or later).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.1. pg_backup_start (Ver.14 or earlier, pg_start_backup)",
    "text": "Create a backup_label file â This file, created in the top level of the base directory, contains essential information about base backup itself, such as the checkpoint location of this checkpoint.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.1. pg_backup_start (Ver.14 or earlier, pg_start_backup)",
    "text": "The third and fourth operations are the heart of this command.\nThe first and second operations are performed to recover a database cluster more reliably.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.1. pg_backup_start (Ver.14 or earlier, pg_start_backup)",
    "text": "A backup_label file contains the following six items (versions 11 or later, seven items):",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.1. pg_backup_start (Ver.14 or earlier, pg_start_backup)",
    "text": "CHECKPOINT LOCATION â This is the LSN location where the checkpoint created by this command has been recorded.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.1. pg_backup_start (Ver.14 or earlier, pg_start_backup)",
    "text": "START WAL LOCATION â This is not used with PITR, but used with the streaming replication, which is described in Chapter 11.\nIt is named ‘START WAL LOCATION’ because the standby server in replication-mode reads this value only once at initial startup.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.1. pg_backup_start (Ver.14 or earlier, pg_start_backup)",
    "text": "BACKUP METHOD â This is the method used to make this base backup.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.1. pg_backup_start (Ver.14 or earlier, pg_start_backup)",
    "text": "BACKUP FROM â This shows whether this backup is taken from the primary or standby server.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.1. pg_backup_start (Ver.14 or earlier, pg_start_backup)",
    "text": "START TIME â This is the timestamp when the pg_backup_start command was executed.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.1. pg_backup_start (Ver.14 or earlier, pg_start_backup)",
    "text": "LABEL â This is the label specified at the pg_backup_start command.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.1. pg_backup_start (Ver.14 or earlier, pg_start_backup)",
    "text": "START TIMELINE â This is the timeline that the backup started.\nThis is for a sanity check and has been introduced in version 11.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.1. pg_backup_start (Ver.14 or earlier, pg_start_backup)",
    "text": "An actual example of a backup_label file in version 16, which is taken by using pg_basebackup, is shown below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.1. pg_backup_start (Ver.14 or earlier, pg_start_backup)",
    "text": "[CODE BLOCK]\n$ cat /usr/local/pgsql/data/backup_label\nSTART WAL LOCATION: 0/1B000028 (file 00000001000000000000001B)\nCHECKPOINT LOCATION: 0/1B000060\nBACKUP METHOD: streamed\nBACKUP FROM: primary\nSTART TIME: 2024-1-1 11:45:19 GMT\nLABEL: pg_basebackup base backup\nSTART TIMELINE: 1",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.1. pg_backup_start (Ver.14 or earlier, pg_start_backup)",
    "text": "As you may imagine, when you recover a database using this base backup,\nPostgreSQL takes the ‘CHECKPOINT LOCATION’ from the backup_label file to read the checkpoint record from the appropriate archive log.\nIt then gets the REDO point from the record and starts the recovery process.\n(The details will be described in the next section.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.2. pg_backup_stop (Ver.14 or earlier, pg_stop_backup)",
    "text": "The pg_backup_stop command, internally invokes do_pg_backup_stop() function, performs the following five operations to complete the backup:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.2. pg_backup_stop (Ver.14 or earlier, pg_stop_backup)",
    "text": "Reset to non-full-page writes mode if it has been forcibly changed by the pg_backup_start command.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.2. pg_backup_stop (Ver.14 or earlier, pg_stop_backup)",
    "text": "Create a backup history file.\nThis file contains the contents of the backup_label file and the timestamp that the pg_backup_stop command was executed.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.2. pg_backup_stop (Ver.14 or earlier, pg_stop_backup)",
    "text": "Delete the backup_label file.\nThe backup_label file is required for recovery from the base backup, but once copied, it is not necessary in the original database cluster.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.2. pg_backup_stop (Ver.14 or earlier, pg_stop_backup)",
    "text": "The naming method for backup history file is shown below.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.2. pg_backup_stop (Ver.14 or earlier, pg_stop_backup)",
    "text": "[CODE BLOCK]\n{WAL segment}.{offset value at the time the base backup was started}.backup",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.3. pg_basebackup",
    "text": "pg_basebackup is a utility for taking online backups.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.3. pg_basebackup",
    "text": "In version 16 or earlier, pg_basebackup supported full backups of the entire database cluster.\nIn version 17, incremental backups were added.\nThis section explains how to take a full backup. Incremental backups will be discussed in Section 10.5.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.3. pg_basebackup",
    "text": "To perform a backup remotely,\npg_basebackup utilizes the walsender process, a component of streaming replication, which will be explained in Chapter 11.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 31,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.3. pg_basebackup",
    "text": "For instance, to take a full backup from host 192.168.1.10 to the local server at ‘/usr/local/pgsql/backup/full’,\nwe can execute the following command:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 32,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.3. pg_basebackup",
    "text": "[CODE BLOCK]\n$ pg_basebackup -h 192.168.1.10 -p 5432 -D /usr/local/pgsql/backup/full -X stream -P -v",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 33,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.3. pg_basebackup",
    "text": "Figure 10.2 shows the sequence of how the pg_basebackup takes a full backup:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 34,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.3. pg_basebackup",
    "text": "The reason why WAL segment files are not sent in step 5 is to ensure that the last WAL segment files will be sent to pg_basebackup.\nIn the step 6, the current WAL segment is switched by executing the do_pg_backup_stop() function, which means that all WAL segment files generated during the backup procedure are certainly stored in the pg_wal directory.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 35,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.3. pg_basebackup",
    "text": "[CODE BLOCK]\n$ ls /usr/local/pgsql/backup/full\nPG_VERSION        global        pg_ident.conf  pg_serial     pg_tblspc             postgresql.conf\nbackup_label      log           pg_logical     pg_snapshots  pg_twophase\nbackup_manifest   pg_commit_ts  pg_multixact   pg_stat       pg_wal\nbase              pg_dynshmem   pg_notify      pg_stat_tmp   pg_xact\ncurrent_logfiles  pg_hba.conf   pg_replslot    pg_subtrans   postgresql.auto.conf",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 36,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.3. pg_basebackup",
    "text": "Walsender is a process for replication, as explained in Chapter 11.\npg_basebackup does not have a direct relationship with replication.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 37,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.3. pg_basebackup",
    "text": "However, when pg_basebackup was developed (and still today), the only processes that could be started as a PostgreSQL server process from an external program were ‘postgres’ and ‘walsender’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 38,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.3. pg_basebackup",
    "text": "Therefore, the walsender protocol was extended to accommodate pg_basebackup.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 39,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.3. pg_basebackup",
    "text": "A backup manifest file is a JSON file that contains metadata and verification information about the backup.",
    "tables": [
      {
        "table_index": 0,
        "content": "Key | Values\nPostgreSQL-Backup-Manifest-Version | Backup manifest version number.\nFiles | List of objects that contains all file’s path, size, checksum, etc.\nWAL-Ranges | Timeline and the LSN range during the backup procedure:* Start-LSN: The LSN of the REDO point generated by CHECKPOINT when the do_pg_backup_start function is invoked.* End-LSN: The LSN of the WAL log created by the do_pg_backup_stop function.\nManifest-Checksum | The checksum value of this manifest file."
      }
    ],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 40,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.1.3. pg_basebackup",
    "text": "[CODE BLOCK]\n$ cat /usr/local/pgsql/backup/full/backup_manifest\n{ \"PostgreSQL-Backup-Manifest-Version\": 2,\n\"System-Identifier\": 7426689740139212305,\n\"Files\": [\n{ \"Path\": \"backup_label\", \"Size\": 225, \"Last-Modified\": \"2024-10-17 10:41:48 GMT\", \"Checksum-Algorithm\": \"CRC32C\", \"Checksum\": \"1950abcb\" },\n{ \"Path\": \"postgresql.conf\", \"Size\": 30771, \"Last-Modified\": \"2024-10-17 10:29:00 GMT\", \"Checksum-Algorithm\": \"CRC32C\", \"Checksum\": \"a9c769e0\" },\n{ \"Path\": \"postgresql.auto.conf\", \"Size\": 88, \"Last-Modified\": \"2024-10-17 10:29:12 GMT\", \"Checksum-Algorithm\": \"CRC32C\", \"Checksum\": \"536f950b\" },\n{ \"Path\": \"pg_ident.conf\", \"Size\": 2640, \"Last-Modified\": \"2024-10-17 10:29:12 GMT\", \"Checksum-Algorithm\": \"CRC32C\", \"Checksum\": \"0ce04d87\" },\n{ \"Path\": \"log/postgresql-2024-10-17_193211.log\", \"Size\": 1359, \"Last-Modified\": \"2024-10-17 10:41:48 GMT\", \"Checksum-Algorithm\": \"CRC32C\", \"Checksum\": \"62ed7886\" },\n{ \"Path\": \"log/postgresql-2024-10-17_192939.log\", \"Size\": 5631, \"Last-Modified\": \"2024-10-17 10:32:11 GMT\", \"Checksum-Algorithm\": \"CRC32C\", \"Checksum\": \"e9891cb3\" },\n{ \"Path\": \"pg_xact/0000\", \"Size\": 8192, \"Last-Modified\": \"2024-10-17 10:41:48 GMT\", \"Checksum-Algorithm\": \"CRC32C\", \"Checksum\": \"4c2ce5fc\" },\n{ \"Path\": \"pg_hba.conf\", \"Size\": 5711, \"Last-Modified\": \"2024-10-17 10:29:12 GMT\", \"Checksum-Algorithm\": \"CRC32C\", \"Checksum\": \"d62da38c\" },\n{ \"Path\": \"PG_VERSION\", \"Size\": 3, \"Last-Modified\": \"2024-10-17 10:29:12 GMT\", \"Checksum-Algorithm\": \"CRC32C\", \"Checksum\": \"64440205\" },\n{ \"Path\": \"base/4/113\", \"Size\": 8192, \"Last-Modified\": \"2024-10-17 10:29:12 GMT\", \"Checksum-Algorithm\": \"CRC32C\", \"Checksum\": \"d1bc40bb\" },\n{ \"Path\": \"base/4/1417\", \"Size\": 0, \"Last-Modified\": \"2024-10-17 10:29:12 GMT\", \"Checksum-Algorithm\": \"CRC32C\", \"Checksum\": \"00000000\" },\n{ \"Path\": \"base/4/2610_fsm\", \"Size\": 24576, \"Last-Modified\": \"2024-10-17 10:29:12 GMT\", \"Checksum-Algorithm\": \"CRC32C\", \"Checksum\": \"b9b5f34f\" },\n{ \"Path\": \"base/4/3542\", \"Size\": 16384, \"Last-Modified\": \"2024-10-17 10:29:12 GMT\", \"Checksum-Algorithm\": \"CRC32C\", \"Checksum\": \"e7f849bf\" },\n\n... snip ...\n\n{ \"Path\": \"global/pg_control\", \"Size\": 8192, \"Last-Modified\": \"2024-10-17 10:41:48 GMT\", \"Checksum-Algorithm\": \"CRC32C\", \"Checksum\": \"43872087\" }\n],\n\"WAL-Ranges\": [\n{ \"Timeline\": 1, \"Start-LSN\": \"0/4000028\", \"End-LSN\": \"0/4000120\" }\n],\n\"Manifest-Checksum\": \"4c6d8a85379990904f6986f5bfd98db9f4640cfc96f440f8674abe6251cfffb8\"}",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.040823"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "Figure 10.3 illustrates the basic concept of PITR.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.897187"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "In PITR mode, PostgreSQL replays the WAL data from the archive logs on the base backup,\nstarting at the REDO point created by pf_backup_start and continuing up to the specified recovery point.\nThis recovery point in PostgreSQL is referred to as the recovery target.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.897187"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "Suppose a mistake occurred at 12:05 GMT on 1 January 2024.\nThe database cluster should be removed, and a new one restored using the base backup created before that time.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.897187"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "To begin, configure the command for the restore_command parameter and set the time for the recovery_target_time parameter to the point of the error (in this case, 12:05 GMT) in the postgresql.conf file (or recovery.conf for versions 11 or earlier).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.897187"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "[CODE BLOCK]\n# Place archive logs under /mnt/server/archivedir directory.\nrestore_command = 'cp /mnt/server/archivedir/%f %p'\nrecovery_target_time = \"2024-1-1 12:05 GMT\"",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.897187"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "When PostgreSQL starts up, it enters into PITR mode\nif there is a ‘backup_label’ file and a ‘recovery.signal’ file (versions 11 or earlier, ‘recovery.conf’) in the database cluster.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.897187"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "The recovery.conf file was removed in version 12, and all recovery-related parameters are now written in postgresql.conf.\nFor detailed information, refer to the official document.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.898193"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "In versions 12 and later, restoring a server from a base backup requires creating an empty file named recovery.signal in the database cluster directory.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.898193"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "The PITR (Point-in-Time Recovery) process is almost the same as the normal recovery process described in Section 9.8.\nThe only two differences are:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.898193"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "PostgreSQL reads the value of ‘CHECKPOINT LOCATION’ from the backup_label file using the internal function read_backup_label() to find the REDO point.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.898193"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "PostgreSQL reads some values of parameters from the postgresql.conf (versions 11 or earlier, recovery.conf), such as restore_command and recovery_target_time.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.898193"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "PostgreSQL starts replaying WAL data from the REDO point, which can be easily obtained from the value of ‘CHECKPOINT LOCATION’.\nThe WAL data are read from archive logs that are copied from the archival area to a temporary area by executing the command written in the restore_command parameter.\n(The copied log files in the temporary area are removed after use.)\n\nIn this example, PostgreSQL reads and replays WAL data from the REDO point to the one before the timestamp ‘2024-1-1 12:05:00’ because the recovery_target_time parameter is set to this timestamp.\nIf a recovery target is not set to the postgresql.conf (versions 11 or earlier, recovery.conf),\nPostgreSQL will replay until the end of the archiving logs.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.898193"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "When the recovery process completes,\na timeline history file, such as ‘00000002.history’, is created in the pg_wal subdirectory (in versions 9.6 or earlier, pg_xlog subdirectory).\n\nIf archiving log feature is enabled, the same named file is also created in the archival directory.\nThe contents and role of this file are described in the following sections.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.898193"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "The records of commit and abort actions contain the timestamp at which each action has done (XLOG data portion of both actions are defined in\nxl_xact_commit and xl_xact_abort respectively).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.898193"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "[CODE BLOCK]\ntypedef struct xl_xact_commit\n{\n        TimestampTz\txact_time;          /* time of commit */\n        uint32          xinfo;              /* info flags */\n        int            \tnrels;              /* number of RelFileNodes */\n        int            \tnsubxacts;          /* number of subtransaction XIDs */\n        int            \tnmsgs;              /* number of shared inval msgs */\n        Oid            \tdbId;               /* MyDatabaseId */\n        Oid            \ttsId;               /* MyDatabaseTableSpace */\n        /* Array of RelFileNode(s) to drop at commit */\n        RelFileNode     xnodes[1];          /* VARIABLE LENGTH ARRAY */\n        /* ARRAY OF COMMITTED SUBTRANSACTION XIDs FOLLOWS */\n        /* ARRAY OF SHARED INVALIDATION MESSAGES FOLLOWS */\n} xl_xact_commit;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.898193"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "[CODE BLOCK]\ntypedef struct xl_xact_abort\n{\n        TimestampTz     xact_time;          /* time of abort */\n        int            \tnrels;              /* number of RelFileNodes */\n        int             nsubxacts;          /* number of subtransaction XIDs */\n        /* Array of RelFileNode(s) to drop at abort */\n        RelFileNode     xnodes[1];          /* VARIABLE LENGTH ARRAY */\n        /* ARRAY OF ABORTED SUBTRANSACTION XIDs FOLLOWS */\n} xl_xact_abort;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.898193"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "Therefore, if a target time is set to the recovery_target_time parameter,\nPostgreSQL may select whether to continue recovery or not, whenever it replays XLOG record of either commit or abort action.\nWhen XLOG record of each action is replayed, PostgreSQL compares the target time and each timestamp written in the record,\nand if the timestamp exceed the target time, PITR process will be finished.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.898193"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "The function read_backup_label() is defined in src/backend/access/transam/xlog.c.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.898193"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "The structure xl_xact_commit and xl_xact_abort are defined in src/include/access/xact.h.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.898193"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "The recovery process is a process of restoring a database cluster to a consistent state, even if the cluster is inconsistent.\nPITR is based on the recovery process, so it can recover a database cluster even if the base backup is a bunch of inconsistent files.\nThis is why we can use common archiving tools without the need for a file system snapshot capability or a special tool.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:52.898193"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "A timeline in PostgreSQL is used to distinguish between the original database cluster and the recovered ones.\nIt is a central concept of PITR.\nIn this section, two things associated with the timeline are described: timelineId and timeline history files.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:53.748822"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.3.1. timelineId",
    "text": "Each timeline is given a corresponding timelineId, a 4-byte unsigned integer starting at 1.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:53.748822"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.3.1. timelineId",
    "text": "An individual timelineId is assigned to each database cluster.\nThe timelineId of the original database cluster created by the initdb utility is 1.\nWhenever a database cluster recovers, the timelineId is increased by 1.\nFor example, in the example of the previous section, the timelineId of the cluster recovered from the original one is 2.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:53.748822"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.3.1. timelineId",
    "text": "Figure 10.4 illustrates the PITR process from the viewpoint of the timelineId.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:53.748822"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.3.1. timelineId",
    "text": "First, we remove our current database cluster and restore the base backup made in the past, in order to go back to the starting point of recovery.\nThis situation is represented by the red arrow curve in the figure.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:53.748822"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.3.1. timelineId",
    "text": "Next, we start the PostgreSQL server, which replays WAL data in the archive logs from the REDO point created by the pg_backup_start until the recovery target by tracing along the initial timeline (timelineId 1).\nThis situation is represented by the blue arrow line in the figure.\nThen, a new timelineId 2 is assigned to the recovered database cluster and PostgreSQL runs on the new timeline.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:53.748822"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.3.1. timelineId",
    "text": "As briefly mentioned in Chapter 9,\nthe first 8 digits of the WAL segment filename are equal to the timelineId of the database cluster that created the segment.\nWhen the timelineId is changed, the WAL segment filename will also be changed.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:53.748822"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.3.1. timelineId",
    "text": "Focusing on WAL segment files, the recovery process can be described again.\nSuppose that we recover the database cluster using two archive logs ‘000000010000000000000009’ and ‘00000001000000000000000A’.\nThe newly recovered database cluster is assigned the timelineId 2, and PostgreSQL creates the WAL segment from ‘00000002000000000000000A’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:53.748822"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.3.2. Timeline History File",
    "text": "When a PITR process completes, a timeline history file with names like ‘00000002.history’ is created under the archival directory and the pg_xlog subdirectory (in versions 10 or later, pg_wal subdirectory).\nThis file records which timeline it branched off from and when.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:53.748822"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.3.2. Timeline History File",
    "text": "The timeline history file contains at least one line, and each line is composed of the following three items:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:53.748822"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.3.2. Timeline History File",
    "text": "[CODE BLOCK]\n$ cat /home/postgres/archivelogs/00000002.history\n1\t  0/A000198\tbefore 2024-1-1 12:05:00.861324+00",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:53.748822"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.3.2. Timeline History File",
    "text": "The database cluster (timelineId = 2) is based on the base backup whose timelineId is 1,\nand is recovered in the time just before ‘2024-1-1 12:05:00.861324+00’ by replaying the archive logs until the ‘0/A000198’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:53.748822"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.3.2. Timeline History File",
    "text": "In this way, each timeline history file tells us a complete history of the individual recovered database cluster.\nMoreover, it is also used in the PITR process itself.\nThe details are explained in the next section.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:53.748822"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.3.2. Timeline History File",
    "text": "The timeline history file format is changed in version 9.3.\nThe formats of versions 9.3 or later and earlier are shown below, but not in detail.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:53.748822"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "The timeline history file is essential for performing second and subsequent Point-in-Time Recovery (PITR) operations.\nThe following example demonstrates how it is utilized during a second recovery attempt.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:54.599347"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "Consider a scenario where an error occurs at ‘12:15:00’ in the recovered database cluster, which has a timelineId of 2.\nTo recover the database to this point, the postgresql.conf file (or recovery.conf for versions 11 or earlier) should be configured as follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:54.599347"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "[CODE BLOCK]\nrestore_command = 'cp /mnt/server/archivedir/%f %p'\nrecovery_target_time = \"2024-1-1 12:15:00 GMT\"\nrecovery_target_timeline = 2",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:54.599347"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "The recovery_target_time parameter specifies the desired recovery time, while the recovery_target_timeline parameter is set to 2 to recover along its timeline.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:54.599347"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "Restart the PostgreSQL server to enter PITR mode and recover the database at the target time along timeline ID 2 (see Figure 10.6).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:54.599347"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "During recovery, PostgreSQL performs the following steps:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:54.599347"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "PostgreSQL reads the value of ‘CHECKPOINT LOCATION’ from the backup_label file.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:54.599347"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "Some values of parameters are read from the postgresql.conf (versions 11 or earlier, recovery.conf);\nin this example, restore_command, recovery_target_time and recovery_target_timeline.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:54.599347"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "PostgreSQL reads the timeline history file ‘00000002.history’ that is corresponding to the value of the parameter recovery_target_timeline.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:54.599347"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "PostgreSQL does replaying WAL data by the following steps:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:54.599347"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "When the recovery process completes, the current timelineId will advance to 3, and a new timeline history file named ‘00000003.history’ is created in the pg_wal subdirectory (pg_xlog if versions 9.6 or earlier) and the archival directory.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:54.599347"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "[CODE BLOCK]\n$ cat /home/postgres/archivelogs/00000003.history\n1         0/A000198     before 2024-1-1 12:05:00.861324+00\n\n2         0/B000078     before 2024-1-1 12:15:00.927133+00",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:54.599347"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "For multiple PITR operations, the appropriate timelineId should be explicitly set to ensure the correct timeline history file is used.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:54.599347"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "In this way, timeline history files serve not only as logs of the database clusterâs timeline history but also as recovery instruction documents for the PITR process.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:54.599347"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "In normal operation, backups need to be taken regularly. However, multiple full backups consume huge amounts of storage space.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.456815"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "To address this issue, PostgreSQL introduced incremental backups in version 17.\nAn incremental backup saves only the changed portions of the files taken in the preceding backup.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.456815"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": null,
    "text": "In the following subsections,\nwe will explore the overview of incremental backups, the process of creating incremental backups with pg_basebackup, and the data format of incremental backups.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.456815"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.1. Incremental Backup Overview",
    "text": "Incremental backup is performed based on full backup and WAL summary files collected by WALsummarizer, described in Section 9.6.2.\nTherefore, we begin to explain incremental backup from taking a full backup.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.456815"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.1. Incremental Backup Overview",
    "text": "Taking the full backup:\nAfter issuing do_pg_backup_start(),\na full backup is taken, containing all relation files.\nWe assume the REDO point of the full backup is $REDO_{full}$.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.456815"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.1. Incremental Backup Overview",
    "text": "From full backup to incremental backup:\nThe WAL Summarizer process tracks changes to all database blocks and writes these modifications to WAL summary files.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.456815"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.1. Incremental Backup Overview",
    "text": "Taking the incremental backup:\nWe assume the REDO point of this incremental backup is $REDO_{inc01}$.\nUsing the summary files generated between $REDO_{full}$ and $REDO_{inc01}$,\nthe incremental backup files, which contain only the changed blocks, are backed up instead of the entire relation files.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.456815"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.1. Incremental Backup Overview",
    "text": "In incremental backups, relation and visibility map files are backed up as incremental backup files, while free-space map files are always entirely backed up.\nThis is because, as mentioned in Section 9.6.2, free-space map forks are not properly tracked by the WAL Summarizer.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.456815"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.1. Incremental Backup Overview",
    "text": "If relations are created after taking the preceding backup, the entire relation files are backed up.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.456815"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.1. Incremental Backup Overview",
    "text": "Incremental backup files are named using the following convention:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.456815"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.1. Incremental Backup Overview",
    "text": "For instance, the incremental backup file for Table t1 (OID = 16551) is named ‘INCREMENTAL.16551’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.457376"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.1. Incremental Backup Overview",
    "text": "Here’s an example of the full and incremental backup files for t1:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.457376"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.1. Incremental Backup Overview",
    "text": "[CODE BLOCK]\n$ ls -la -h backup/full/base/16425/ | grep \"16551$\"\n-rw------- 1 postgres postgres 32K Oct 17 11:11 16551\n16551\n$ ls -la -h backup/inc01/base/16425/ | grep \"16551$\"\n-rw------- 1 postgres postgres 24K Oct 17 11:20 INCREMENTAL.16551\nINCREMENTAL.16551",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.457376"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.1. Incremental Backup Overview",
    "text": "The INCREMENTAL file format is described in Section 10.5.3.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.457376"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.1. Incremental Backup Overview",
    "text": "To reconstruct a base backup from incremental backups,\nPostgreSQL provides pg_combinebackup utility.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.457376"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.1. Incremental Backup Overview",
    "text": "Assuming that a full backup is located at ‘/usr/local/pgsql/backup/full’ and an incremental backup at ‘/usr/local/pgsql/backup/inc01’,\nwe can reconstruct the base backup under ‘/usr/local/pgsql/reconstructed’ by issuing the following command:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.457376"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.1. Incremental Backup Overview",
    "text": "[CODE BLOCK]\n$ pg_combinebackup -d -n -o /usr/local/pgsql/reconstructed  \\\n>    /usr/local/pgsql/backup/full/  \\\n>    /usr/local/pgsql/backup/inc01/",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.457376"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.1. Incremental Backup Overview",
    "text": "Figure 10.8 illustrates how the pg_combinebackup utility reconstructs a base backup from a full backup and an incremental backup.\nIn essence, pg_combinebackup applies the file changes stored in the incremental backup file to the original relation file.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.457376"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.1. Incremental Backup Overview",
    "text": "For instance,\nassuming the relation file for Table t1 (OID=16551) is stored in the full backup and the incremental backup file named ‘INCREMENTAL.16551’ is in the incremental backup, pg_combinebackup overwrites the changed blocks (e.g., the 0th and 3rd blocks) stored in ‘INCREMENTAL.16551’ onto the relation file named ‘16551’.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.457376"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.2. How to Take Incremental Backups",
    "text": "To take an incremental backup, use the ‘–incremental’ option with the path to the preceding backup’s manifest file.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.457376"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.2. How to Take Incremental Backups",
    "text": "For example, to take an incremental backup from host 192.168.1.10 to the local server at ‘/usr/local/pgsql/backup/inc01’,\nbased on the full backup located at ‘/usr/local/pgsql/backup/full’, we can execute the following command:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.457376"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.2. How to Take Incremental Backups",
    "text": "[CODE BLOCK]\n$ pg_basebackup -h 192.168.1.10 -p 5432 \\\n>   --incremental /usr/local/pgsql/backup/full/backup_manifest \\\n>   -D /usr/local/pgsql/backup/inc01 -X stream -P -v",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.457376"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.2. How to Take Incremental Backups",
    "text": "Figure 10.9 shows the sequence of how the pg_basebackup takes an incremental backup:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.457376"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.2. How to Take Incremental Backups",
    "text": "Note that, in step 8,  the walsender sends the entire relation file if the relation is created after taking the preceding backup.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.457376"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.2. How to Take Incremental Backups",
    "text": "When taking the next incremental backup,\nwe can execute the following command,\nsetting the ‘–incremental’ option to the previous incremental backup manifest ‘/usr/local/pgsql/backup/inc01/backup_manifest’:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.457376"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.2. How to Take Incremental Backups",
    "text": "[CODE BLOCK]\n$ pg_basebackup -h 192.168.1.10 -p 5432 \\\n>   --incremental /usr/local/pgsql/backup/inc01/backup_manifest \\\n>   -D /usr/local/pgsql/backup/inc02 -X stream -P -v",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.457376"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.3. Format of INCREMENTAL File",
    "text": "An INCREMENTAL file is typically composed of a header block and modified blocks, each block being 8 KB in size.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.457376"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.3. Format of INCREMENTAL File",
    "text": "A header block contains four types of information:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.457376"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.3. Format of INCREMENTAL File",
    "text": "A header block is typically 8 KB in size, or a multiple of 8 KB.\nNormally, a header block is padded with zeros to reach an 8 KB alignment after the list of modified block numbers.\nIf the list of modified block numbers exceeds 8 KB, additional header blocks are added.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.457376"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.3. Format of INCREMENTAL File",
    "text": "If a table is truncated, dropped, or unchanged, its header block becomes a 12-byte block containing three fields: a magic number, a number of incremental blocks set to 0, and a truncation block length of 1.\nThe INCREMENTAL file itself also becomes a 12-byte file containing only the header.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.457376"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql10/05.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 31,
    "chapter": "Chapter 10: Online Backup and PITR",
    "section": "10.5.3. Format of INCREMENTAL File",
    "text": "Figure 10.11 shows four examples of the INCREMENTAL files that are explained in Section 9.6.2.2:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:55.457376"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 11: Streaming Replication",
    "section": null,
    "text": "In streaming replication, three types of processes work cooperatively:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:57.156246"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 11: Streaming Replication",
    "section": null,
    "text": "The walsender and walreceiver communicate using a single TCP connection.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:57.156246"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 11: Streaming Replication",
    "section": null,
    "text": "The startup sequence of streaming replication is shown in Figure 11.1:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:57.156246"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 11: Streaming Replication",
    "section": null,
    "text": "The walreceiver sends a connection request to the primary server.\nIf the primary server is not running, the walreceiver sends these requests periodically.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:57.156246"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 11: Streaming Replication",
    "section": null,
    "text": "When the primary server receives a connection request, it starts a walsender process and a TCP connection is established between the walsender and walreceiver.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:57.156246"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 11: Streaming Replication",
    "section": null,
    "text": "The walreceiver sends the latest LSN (Log Sequence Number) of standby’s database cluster.\nThis is known as handshaking in the field of information technology.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:57.156246"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 11: Streaming Replication",
    "section": null,
    "text": "If the standby’s latest LSN is less than the primary’s latest LSN (Standby’s LSN $ \\lt $ Primary’s LSN),\nthe walsender sends WAL data from the former LSN to the latter LSN.\nThese WAL data are provided by WAL segments stored in the primary’s pg_wal subdirectory (in versions 9.6 or earlier, pg_xlog).\nThe standby server then replays the received WAL data.\nIn this phase, the standby catches up with the primary, so it is called catch-up.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:57.156246"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 11: Streaming Replication",
    "section": null,
    "text": "Each walsender process keeps a state that is appropriate for the working phase of the connected walreceiver or application.\nThe following are the possible states of a walsender process:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:57.156246"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 11: Streaming Replication",
    "section": null,
    "text": "The pg_stat_replication view shows the state of all running walsenders.\nAn example is shown below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:57.156246"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 11: Streaming Replication",
    "section": null,
    "text": "[CODE BLOCK]\ntestdb=# SELECT application_name,state FROM pg_stat_replication;\n application_name |   state\n------------------+-----------\n standby1         | streaming\n standby2         | streaming\n pg_basebackup    | backup\n(3 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:57.156246"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 11: Streaming Replication",
    "section": null,
    "text": "As shown in the above result,\ntwo walsenders are running to send WAL data for the connected standby servers,\nand another one is running to send all files of the database cluster for pg_basebackup utility.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:57.156246"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.1.1 What Happens When a Standby Server Restarts After a Long Downtime?",
    "text": "In versions 9.3 or earlier, if the primary’s WAL segments required by the standby server have already been recycled, the standby cannot catch up with the primary server.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:57.156246"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.1.1 What Happens When a Standby Server Restarts After a Long Downtime?",
    "text": "There is no reliable solution for this problem, but only to set a large value to the configuration parameter wal_keep_size (or wal_keep_segments in versions 12 or earlier) to reduce the possibility of the occurrence.\nThis is a stopgap solution.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:57.156246"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/01.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.1.1 What Happens When a Standby Server Restarts After a Long Downtime?",
    "text": "In versions 9.4 or later, this problem can be prevented by using replication slot.\nA replication slot is a feature that expands the flexibility of the WAL data sending.\nRefer the Section 11.4 for detail.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:57.156246"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 11: Streaming Replication",
    "section": null,
    "text": "Streaming replication has two aspects: log shipping and database synchronization.\nLog shipping is the main aspect of streaming replication, as the primary server sends WAL data to the connected standby servers whenever they are written.\nDatabase synchronization is required for synchronous replication, where the primary server communicates with each standby server to synchronize their database clusters.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 11: Streaming Replication",
    "section": null,
    "text": "To accurately understand how streaming replication works, we need to understand how one primary server manages multiple standby servers.\nWe will start with the simple case (i.e., single-primary single-standby system) in this section, and then discuss the general case (single-primary multi-standby system) in the next section.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.1. Communication Between a Primary and a Synchronous Standby",
    "text": "Assume that the standby server is in the synchronous replication mode,\nbut the configuration parameter hot_standby is disabled and wal_level is ‘replica’.\nThe main parameter of the primary server is shown below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.1. Communication Between a Primary and a Synchronous Standby",
    "text": "[CODE BLOCK]\nsynchronous_standby_names = 'standby1'\nhot_standby = off\nwal_level = replica",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.1. Communication Between a Primary and a Synchronous Standby",
    "text": "Additionally, among the three triggers to write the WAL data mentioned in Section 9.5, we focus on the transaction commits here.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.1. Communication Between a Primary and a Synchronous Standby",
    "text": "Suppose that one backend process on the primary server issues a simple INSERT statement in autocommit mode.\nThe backend starts a transaction, issues an INSERT statement, and then commits the transaction immediately.\nLet’s explore further how this commit action will be completed.\nSee the following sequence diagram in Figure 11.2:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.1. Communication Between a Primary and a Synchronous Standby",
    "text": "The backend process writes and flushes WAL data to a WAL segment file by executing the functions XLogInsert() and XLogFlush().",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.1. Communication Between a Primary and a Synchronous Standby",
    "text": "The walsender process sends the WAL data written into the WAL segment to the walreceiver process.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.1. Communication Between a Primary and a Synchronous Standby",
    "text": "After sending the WAL data, the backend process continues to wait for an ACK response from the standby server.\nMore precisely, the backend process gets a latch by executing the internal function SyncRepWaitForLSN(), and waits for it to be released.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.1. Communication Between a Primary and a Synchronous Standby",
    "text": "The walreceiver on the standby server writes the received WAL data into the standby’s WAL segment using the write() system call, and returns an ACK response to the walsender.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.1. Communication Between a Primary and a Synchronous Standby",
    "text": "The walreceiver flushes the WAL data to the WAL segment using the system call such as fsync(),\nreturns another ACK response to the walsender,\nand informs the startup process about WAL data updated.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.1. Communication Between a Primary and a Synchronous Standby",
    "text": "The startup process replays the WAL data, which has been written to the WAL segment.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.1. Communication Between a Primary and a Synchronous Standby",
    "text": "The walsender releases the latch of the backend process on receiving the ACK response from the walreceiver,\nand then, the backend process’s commit or abort action will be completed.\nThe timing for latch-release depends on the parameter synchronous_commit.\n\nIt is ‘on’ (default), the latch is released when the ACK of step (5) received,\nwhereas it is ‘remote_write’, the latch is released when the ACK of step (4) is received.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.1. Communication Between a Primary and a Synchronous Standby",
    "text": "Each ACK response informs the primary server of the internal information of standby server.\nIt contains four items below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.1. Communication Between a Primary and a Synchronous Standby",
    "text": "[CODE BLOCK]\nXLogWalRcvSendReply(void)@src/backend/replication/walreceiver.c\n\t/* Construct a new message */\n\twritePtr = LogstreamResult.Write;\n\tflushPtr = LogstreamResult.Flush;\n\tapplyPtr = GetXLogReplayRecPtr(NULL);\n\n\tresetStringInfo(&reply_message);\n\tpq_sendbyte(&reply_message, 'r');\n\tpq_sendint64(&reply_message, writePtr);\n\tpq_sendint64(&reply_message, flushPtr);\n\tpq_sendint64(&reply_message, applyPtr);\n\tpq_sendint64(&reply_message, GetCurrentTimestamp());\n\tpq_sendbyte(&reply_message, requestReply ? 1 : 0);",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.1. Communication Between a Primary and a Synchronous Standby",
    "text": "The walreceiver returns ACK responses not only when WAL data have been written and flushed, but also periodically as a heartbeat from the standby server.\nThe primary server therefore always has an accurate understanding of the status of all connected standby servers.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.1. Communication Between a Primary and a Synchronous Standby",
    "text": "The LSN-related information of the connected standby servers can be displayed by issuing the queries shown below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.1. Communication Between a Primary and a Synchronous Standby",
    "text": "[CODE BLOCK]\ntestdb=# SELECT application_name AS host,\n        write_location AS write_LSN, flush_location AS flush_LSN,\n        replay_location AS replay_LSN FROM pg_stat_replication;\n\n   host   | write_lsn | flush_lsn | replay_lsn\n----------+-----------+-----------+------------\n standby1 | 0/5000280 | 0/5000280 | 0/5000280\n standby2 | 0/5000280 | 0/5000280 | 0/5000280\n(2 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.1. Communication Between a Primary and a Synchronous Standby",
    "text": "The heartbeat interval is set to the parameter wal_receiver_status_interval, which is 10 seconds by default.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.2. Detecting Failures of Standby Servers",
    "text": "Streaming replication uses two common failure detection procedures that do not require any special hardware.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.2. Detecting Failures of Standby Servers",
    "text": "Depending on the type of failure, it can usually be detected immediately after the failure occurs.\nHowever, there may be a time lag between the occurrence of the failure and its detection.\nIn particular, if the latter type of failure occurs in a synchronous standby server, all transaction processing on the primary server will be stopped until the failure of the standby is detected, even if multiple potential standby servers may have been working.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.3. Behavior When a Failure Occurs",
    "text": "This subsection describes how the primary server behaves when a synchronous standby server fails, and how to deal with the situation.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.3. Behavior When a Failure Occurs",
    "text": "Even if a synchronous standby server fails and is no longer able to return an ACK response, the primary server will continue to wait for responses forever.\nThis means that running transactions cannot commit and subsequent query processing cannot be started.\nIn other words, all primary server operations are effectively stopped.\n(Streaming replication does not support a function to automatically revert to asynchronous mode after a timeout.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.3. Behavior When a Failure Occurs",
    "text": "There are two ways to avoid such situation.\nOne is to use multiple standby servers to increase system availability.\nThe other is to manually switch from synchronous to asynchronous mode by performing the following steps:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.3. Behavior When a Failure Occurs",
    "text": "Set the parameter synchronous_standby_names to an empty string.\nsynchronous_standby_names = ''",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.3. Behavior When a Failure Occurs",
    "text": "Execute the pg_ctl command with reload option.\n$ pg_ctl -D $PGDATA reload",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.3. Behavior When a Failure Occurs",
    "text": "This procedure does not affect connected clients.\nThe primary server will continue to process transactions and all sessions between clients and their respective backend processes will be maintained.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.4. Conflicts",
    "text": "In streaming replication,\nstandbys can execute SELECT commands independently of the primary server.\nHowever, conflicts can arise between the standby and the primary server under certain conditions, potentially leading to errors.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.4. Conflicts",
    "text": "Figure 11.3 shows a typical example: the primary server drops the table that the standby server is selecting.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.4. Conflicts",
    "text": "[CODE BLOCK]\ntestdb=# -- Primary\n\n\n\ntestdb=# DROP TABLE tbl;\nDROP TABLE\n\n\n\n\n\ntestdb=#",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 31,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.4. Conflicts",
    "text": "[CODE BLOCK]\ntestdb=# -- Standby\ntestdb=# SELECT count(*) FROM tbl;\n\n\n\n\n\n\nERROR:  canceling statement due to conflict with recovery\nDETAIL:  User was holding a relation lock for too long.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 32,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.4. Conflicts",
    "text": "The cause of this conflict is the WAL data generated by the Access Exclusive Lock acquired internally by the DROP TABLE command on the primary1, which conflicts with the standby’s SELECT command.\n(As described in Section 9.5.1, WAL data includes not only changes to data but also lock information.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 33,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.4. Conflicts",
    "text": "According to the official document,\nthe causes of conflicts can be classified into the following three types:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 34,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.4. Conflicts",
    "text": "Here is another example: the primary server deletes rows and performs the VACUUM command on a table being selected by the standby.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 35,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.4. Conflicts",
    "text": "[CODE BLOCK]\ntestdb=# -- Primary\n\n\ntestdb=# DELETE FROM FROM tbl\ntestdb-#      WHERE data > 100000;\nDELETE 1050\n\ntestdb=# VACUUM tbl;\nVACUUM\n\n\n\n\ntestdb=#",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 36,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.4. Conflicts",
    "text": "[CODE BLOCK]\ntestdb=# -- Standby\ntestdb=# SELECT count(*) FROM tbl;\n\n\n\n\n\n\n\n\nERROR:  canceling statement due to conflict with recovery\nDETAIL:  User query might have needed to see row versions that must be removed.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 37,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.4. Conflicts",
    "text": "Conflicts caused by VACUUM processing are particularly troublesome\nbecause they can occur not only during explicitly run VACUUM commands but also during autovacuum operations, which is described in Section 6.5.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 38,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.4. Conflicts",
    "text": "On standby servers,\nconflicts can be mitigated by increasing the values of max_standby_archive_delay and max_standby_streaming_delay (default: 30 seconds).\nThese settings allow the standby to delay replaying WAL data, reducing the likelihood of conflicts.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 39,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.4. Conflicts",
    "text": "However, these parameters cannot always eliminate conflicts.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 40,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.4. Conflicts",
    "text": "Additionally, they affect other PostgreSQL backends on the standby,\npreventing them from accessing the latest data during the delay.\nThis means the standby server is not fully synchronous during such conflicts.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 41,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.4. Conflicts",
    "text": "It is essential to configure these parameters while carefully considering the disadvantages of the settings and the operational trade-offs.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 42,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.4. Conflicts",
    "text": "On the primary server,\nby setting the parameter hot_standby_feedback (default: off) to on,\nthe primary delays deleting data that the standby needs during vacuum processing,\nbased on the standby’s state. This helps avoid conflicts caused by vacuum operations.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 43,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.4. Conflicts",
    "text": "The standby’s state is sent to the primary at intervals defined by wal_receiver_status_interval (default: 10 seconds).",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 44,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.4. Conflicts",
    "text": "While enabling hot_standby_feedback resolves vacuum-induced conflicts, it has the following drawbacks for the primary server:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 45,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.4. Conflicts",
    "text": "Table and Index Bloat: Retaining old tuples visible to the standby prevents vacuuming, leading to increased table and index bloat on the primary.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 46,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.4. Conflicts",
    "text": "WAL Retention Issues: Retaining additional data for standby consistency can increase WAL usage.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 47,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.4. Conflicts",
    "text": "Issuing the pg_stat_database_conflicts on a standby server displays the causes and number of conflicts:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 48,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.4. Conflicts",
    "text": "[CODE BLOCK]\ntestdb=# -- Standby\ntestdb=# \\x\nExpanded display is on.\ntestdb=# SELECT * FROM pg_stat_database_conflicts WHERE datname = 'testdb';\n-[ RECORD 1 ]------------+-------\ndatid                    | 16384\ndatname                  | testdb\nconfl_tablespace         | 0\nconfl_lock               | 1\nconfl_snapshot           | 1\nconfl_bufferpin          | 0\nconfl_deadlock           | 0\nconfl_active_logicalslot | 0",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 49,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.4. Conflicts",
    "text": "Until version 15,\nthe vacuum_defer_cleanup_age parameter\nwas supported to defer the deletion of dead tuples during a vacuum operation.\nIf a positive number was set, vacuum operations would defer deleting the dead tuples for the specified number of transactions.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 50,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.4. Conflicts",
    "text": "This parameter was removed in version 16\nbecause it could not always eliminate conflicts, and using hot_standby_feedback and Replication Slots, described in Section 11.4, could manage conflicts more effectively.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/02.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 51,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.2.4. Conflicts",
    "text": "More precisely, in situations where the primary drops objects that the standby is accessing,\nstreaming replication is designed to transition to a conflict state. This serves as a grace period to prevent the standby from suddenly returning an error.\nAs part of this design, the acquisition of Access Exclusive Locks is recorded as XLOG records.\nNote that Access Exclusive Locks do not generate XLOG records if wal_level is set to minimal. That is, XLOG records for these locks are required for replication, not for ordinary recovery.\nTherefore, this type of conflict is not caused accidentally by the Access Exclusive Lock itself but is intentionally introduced to avoid sudden errors on the standby. ↩︎",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.018472"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 11: Streaming Replication",
    "section": null,
    "text": "This section describes how streaming replication works with multiple standby servers.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.1. sync_priority and sync_state",
    "text": "The primary server assigns the sync_priority and sync_state attributes to all managed standby servers, and treats each standby server according to its respective values.\n(The primary server assigns these values even if it manages just one standby server; this was not mentioned in the previous section.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.1. sync_priority and sync_state",
    "text": "The sync_priority attribute indicates the priority of the standby server in synchronous mode.\nThe lower the value, the higher the priority.\nThe special value 0 means that the standby server is ‘in asynchronous mode’.\nThe priorities of the standby servers are assigned in the order listed in the primary server’s configuration parameter synchronous_standby_names.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.1. sync_priority and sync_state",
    "text": "For example, in the following configuration, the priorities of standby1 and standby2 are 1 and 2, respectively.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.1. sync_priority and sync_state",
    "text": "(Standby servers that are not listed in this parameter are in asynchronous mode and have a priority of 0.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.1. sync_priority and sync_state",
    "text": "sync_state is the state of the standby server.\nThe sync_state attribute indicates the state of the standby server.\nIt can be one of the following values:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.1. sync_priority and sync_state",
    "text": "sync: The standby server is in synchronous mode and is the highest priority standby server that is currently working.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.1. sync_priority and sync_state",
    "text": "potential: The standby server is in synchronous mode and is a lower priority standby server that is currently working.\nIf the current sync standby server fails, this standby server will be promoted to sync state.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.1. sync_priority and sync_state",
    "text": "async: The standby server is in asynchronous mode. (It will never be in ‘sync’ or ‘potential’ mode.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.1. sync_priority and sync_state",
    "text": "quorum: The standby servers are in quorum mode. See Section 11.3.2.1 for detail.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.1. sync_priority and sync_state",
    "text": "The priority and state of the standby servers can be shown by issuing the following query:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.1. sync_priority and sync_state",
    "text": "[CODE BLOCK]\ntestdb=# SELECT application_name AS host,\n         sync_priority, sync_state FROM pg_stat_replication;\n   host   | sync_priority | sync_state\n----------+---------------+------------\n standby1 |             1 | sync\n standby2 |             2 | potential\n(2 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.2. How the Primary Manages Multiple-standbys",
    "text": "The primary server waits for ACK responses from the synchronous standby server alone.\nIn other words, the primary server confirms only the synchronous standby’s writing and flushing of WAL data.\nStreaming replication, therefore, ensures that only the synchronous standby is in a consistent and synchronous state with the primary.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.2. How the Primary Manages Multiple-standbys",
    "text": "Figure 11.4 shows the case in which the ACK response of the potential standby has been returned earlier than that of the primary standby.\nIn this case, the primary server does not complete the commit action of the current transaction and continues to wait for the primary’s ACK response.\nWhen the primary’s response is received, the backend process releases the latch and completes the current transaction processing.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.2. How the Primary Manages Multiple-standbys",
    "text": "The sync_state of standby1 and standby2 are ‘sync’ and ‘potential’, respectively.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.2. How the Primary Manages Multiple-standbys",
    "text": "In the opposite case (i.e., the primary’s ACK response has been returned earlier than the potential’s), the primary server immediately completes the commit action of the current transaction without ensuring if the potential standby writes and flushes WAL data or not.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.2. How the Primary Manages Multiple-standbys",
    "text": "In version 9.6, quorum-based synchronous replication was introduced.\nThis feature allows transactions in PostgreSQL to be considered committed once a subset (a quorum) of synchronous standby servers acknowledges them. It enhances flexibility in RDBMS configuration design and administration.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.2. How the Primary Manages Multiple-standbys",
    "text": "Quorum-based synchronous replication has two modes: ANY and FIRST.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.2. How the Primary Manages Multiple-standbys",
    "text": "The format of synchronous_standby_names for ANY mode is:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.2. How the Primary Manages Multiple-standbys",
    "text": "In ANY mode,\nthe primary server completes the commit action of the current transaction any ’num_sync’ standby servers in the list return ACK responses.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.2. How the Primary Manages Multiple-standbys",
    "text": "For example,\nthe following setting allows the primary server to complete the commit action of the current transaction as soon as any two standby servers return ACK responses,\neven if the rest of the standby servers do not return responses.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.2. How the Primary Manages Multiple-standbys",
    "text": "[CODE BLOCK]\nsynchronous_standby_names = 'ANY 2 (standby1, standby2, standby3)'",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.2. How the Primary Manages Multiple-standbys",
    "text": "Figure 11.5 illustrates the behavior of the ANY Mode setting:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.2. How the Primary Manages Multiple-standbys",
    "text": "The following is the state of sync_priority and sync_state for the above setting:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.2. How the Primary Manages Multiple-standbys",
    "text": "[CODE BLOCK]\ntestdb=# SELECT application_name AS host,\n        sync_priority, sync_state FROM pg_stat_replication;\n   host   | sync_priority | sync_state\n----------+---------------+------------\n standby1 |             1 | quorum\n standby2 |             1 | quorum\n standby3 |             1 | quorum\n(3 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.2. How the Primary Manages Multiple-standbys",
    "text": "The format of synchronous_standby_names for FIRST mode is:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.2. How the Primary Manages Multiple-standbys",
    "text": "In FIRST mode,\nthe primary server completes the commit action of the current transaction after the first ’num_sync’ standby servers in the list return ACK responses.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.2. How the Primary Manages Multiple-standbys",
    "text": "For example,\nthe following setting allows the primary server to wait for the commit action of the current transaction until the first two standby servers, i.e., standby1 and standby2, return ACK responses,\neven if standby3 has already returned ACK response:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.2. How the Primary Manages Multiple-standbys",
    "text": "[CODE BLOCK]\nsynchronous_standby_names = 'FIRST 2 (standby1, standby2, standby3)'",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.2. How the Primary Manages Multiple-standbys",
    "text": "Figure 11.6 illustrates the behavior of the FIRST Mode setting:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 31,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.2. How the Primary Manages Multiple-standbys",
    "text": "The following is the state of sync_priority and sync_state for the above setting:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 32,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.2. How the Primary Manages Multiple-standbys",
    "text": "[CODE BLOCK]\nSELECT application_name AS host,\n        sync_priority, sync_state FROM pg_stat_replication;\n   host   | sync_priority | sync_state\n----------+---------------+------------\n standby3 |             3 | potential\n standby2 |             2 | sync\n standby1 |             1 | sync\n(3 rows)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 33,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.3. Behavior When a Failure Occurs",
    "text": "Once again, let’s see how the primary server behaves when a standby server has failed.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 34,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.3. Behavior When a Failure Occurs",
    "text": "When either a potential or an asynchronous standby server has failed, the primary server terminates the walsender process connected to the failed standby and continues all processing.\nIn other words, transaction processing on the primary server would not be affected by the failure of either type of standby server.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 35,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.3. Behavior When a Failure Occurs",
    "text": "When a synchronous standby server has failed, the primary server terminates the walsender process connected to the failed standby, and replaces the synchronous standby with the highest priority potential standby.\nSee Figure 11.7.\nIn contrast to the failure described above, query processing on the primary server will be paused from the point of failure to the replacement of the synchronous standby.\n(Therefore, failure detection of the standby server is a very important function to increase the availability of the replication system. Failure detection will be described in the next section.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/03.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 36,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.3.3. Behavior When a Failure Occurs",
    "text": "In any case, if one or more standby servers are running in synchronous mode, the primary server keeps only one synchronous standby server at all times, and the synchronous standby server is always in a consistent and synchronous state with the primary.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:58.889226"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 1,
    "chapter": "Chapter 11: Streaming Replication",
    "section": null,
    "text": "As discussed in Section 11.1.1,\nReplication slots, introduced in version 9.4, were designed primarily to ensure that WAL segments and old tuple versions are retained long enough to support replication completion.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 2,
    "chapter": "Chapter 11: Streaming Replication",
    "section": null,
    "text": "We will explore replication slots in this section.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 3,
    "chapter": "Chapter 11: Streaming Replication",
    "section": null,
    "text": "Note that although replication slots are fundamental to logical replication, this section does not cover them in that context.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 4,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.1. Advantages of Replication Slots in Streaming Replication",
    "text": "In streaming replication, although replication slots are not mandatory, they offer the following advantages compared to using wal_keep_size:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 5,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.1. Advantages of Replication Slots in Streaming Replication",
    "text": "Ensure Streaming Replication Works Without Losing Required WAL Segments:\nReplication slots track which WAL segments are needed and prevent their removal.\nIn contrast, when using only wal_keep_size, necessary segments may be removed if standbys do not read them for an extended period.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 6,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.1. Advantages of Replication Slots in Streaming Replication",
    "text": "Maintain Only the Minimum Necessary WAL Segments:\nWith replication slots, only the required WAL segments are kept in the pg_wal directory, while unnecessary segments are removed.\nConversely, using wal_keep_size keeps a fixed number of WAL segments, regardless of whether they are needed or not.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 7,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.1. Advantages of Replication Slots in Streaming Replication",
    "text": "Since Replication Slots can store WAL segments indefinitely,\nthere is a risk of the storage area filling up with stored WAL segments in the worst-case scenario, potentially leading to an operating system panic.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 8,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.1. Advantages of Replication Slots in Streaming Replication",
    "text": "To address this issue, the configuration parameter max_slot_wal_keep_size was introduced in version 13.\nIt limits the maximum size of WAL segments in the pg_wal directory at checkpoint time.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 9,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.1. Advantages of Replication Slots in Streaming Replication",
    "text": "The key difference between using max_slot_wal_keep_size with replication slots and wal_keep_size is in how they manage WAL segments:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 10,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.2. Replication Slots and Related Processes and Files",
    "text": "Replication Slots are stored in the memory area allocated in the shared memory.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 11,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.2. Replication Slots and Related Processes and Files",
    "text": "Figure 11.8 illustrates replication slots and the related processes and files:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 12,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.2. Replication Slots and Related Processes and Files",
    "text": "The processes related to Replication Slots are shown below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 13,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.2. Replication Slots and Related Processes and Files",
    "text": "Walsender: Continuously updates the corresponding replication slot to reflect the current state of WAL data of the standby server.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 14,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.2. Replication Slots and Related Processes and Files",
    "text": "Checkpointer background worker: Reads the replication slots to determine whether WAL segments can be removed or not during checkpointing.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 15,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.2. Replication Slots and Related Processes and Files",
    "text": "Postgres backend: Displays the slot information using the system view pg_replication_slots.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 16,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.2. Replication Slots and Related Processes and Files",
    "text": "The files related to Replication Slots are shown below:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 17,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.2. Replication Slots and Related Processes and Files",
    "text": "State files under the pg_replslot directory:\nWalsenders regularly save detailed information about their replication slots to state files located in this directory.\nWhen the server is restarted, it loads this saved information back into memory to restore the status of its replication slots.\n\nThe state is defined by the ReplicationSlotPersistentData structure, described in the next section.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 18,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.2. Replication Slots and Related Processes and Files",
    "text": "WAL segment files under the pg_wal directory:\nThe number of WAL segment files are managed by the checkpointer background worker.\nThe checkpointer  prioritizes Replication Slots and wal_keep_size over max_wal_size to ensure essential data is not removed.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 19,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.3. Data Structure",
    "text": "Replication Slots are defined by the ReplicationSlot structure in slot.h.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 20,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.3. Data Structure",
    "text": "[CODE BLOCK]\n/*\n * Shared memory state of a single replication slot.\n *\n * The in-memory data of replication slots follows a locking model based\n * on two linked concepts:\n * - A replication slot's in_use flag is switched when added or discarded using\n * the LWLock ReplicationSlotControlLock, which needs to be hold in exclusive\n * mode when updating the flag by the backend owning the slot and doing the\n * operation, while readers (concurrent backends not owning the slot) need\n * to hold it in shared mode when looking at replication slot data.\n * - Individual fields are protected by mutex where only the backend owning\n * the slot is authorized to update the fields from its own slot.  The\n * backend owning the slot does not need to take this lock when reading its\n * own fields, while concurrent backends not owning this slot should take the\n * lock when reading this slot's data.\n */\ntypedef struct ReplicationSlot\n{\n\t/* lock, on same cacheline as effective_xmin */\n\tslock_t\t\tmutex;\n\n\t/* is this slot defined */\n\tbool\t\tin_use;\n\n\t/* Who is streaming out changes for this slot? 0 in unused slots. */\n\tpid_t\t\tactive_pid;\n\n\t/* any outstanding modifications? */\n\tbool\t\tjust_dirtied;\n\tbool\t\tdirty;\n\n\t/*\n\t * For logical decoding, it's extremely important that we never remove any\n\t * data that's still needed for decoding purposes, even after a crash;\n\t * otherwise, decoding will produce wrong answers.  Ordinary streaming\n\t * replication also needs to prevent old row versions from being removed\n\t * too soon, but the worst consequence we might encounter there is\n\t * unwanted query cancellations on the standby.  Thus, for logical\n\t * decoding, this value represents the latest xmin that has actually been\n\t * written to disk, whereas for streaming replication, it's just the same\n\t * as the persistent value (data.xmin).\n\t */\n\tTransactionId effective_xmin;\n\tTransactionId effective_catalog_xmin;\n\n\t/* data surviving shutdowns and crashes */\n\tReplicationSlotPersistentData data;\n\n\t/* is somebody performing io on this slot? */\n\tLWLock\t\tio_in_progress_lock;\n\n\t/* Condition variable signaled when active_pid changes */\n\tConditionVariable active_cv;\n\n\t/* all the remaining data is only used for logical slots */\n\n\t/*\n\t * When the client has confirmed flushes >= candidate_xmin_lsn we can\n\t * advance the catalog xmin.  When restart_valid has been passed,\n\t * restart_lsn can be increased.\n\t */\n\tTransactionId candidate_catalog_xmin;\n\tXLogRecPtr\tcandidate_xmin_lsn;\n\tXLogRecPtr\tcandidate_restart_valid;\n\tXLogRecPtr\tcandidate_restart_lsn;\n\n\t/*\n\t * This value tracks the last confirmed_flush LSN flushed which is used\n\t * during a shutdown checkpoint to decide if logical's slot data should be\n\t * forcibly flushed or not.\n\t */\n\tXLogRecPtr\tlast_saved_confirmed_flush;\n\n\t/* The time since the slot has become inactive */\n\tTimestampTz inactive_since;\n} ReplicationSlot;\n\n#define SlotIsPhysical(slot) ((slot)->data.database == InvalidOid)\n#define SlotIsLogical(slot) ((slot)->data.database != InvalidOid)\n\n/*\n * Shared memory control area for all of replication slots.\n */\ntypedef struct ReplicationSlotCtlData\n{\n\t/*\n\t * This array should be declared [FLEXIBLE_ARRAY_MEMBER], but for some\n\t * reason you can't do that in an otherwise-empty struct.\n\t */\n\tReplicationSlot replication_slots[1];\n} ReplicationSlotCtlData;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 21,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.3. Data Structure",
    "text": "Although the structure contains many items, as it is shared between both streaming and logical replication,\nthe main items  relevant to streaming replication are as follows:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 22,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.3. Data Structure",
    "text": "[CODE BLOCK]\n/*\n * On-Disk data of a replication slot, preserved across restarts.\n */\ntypedef struct ReplicationSlotPersistentData\n{\n\n\tNameData\tname;\n\n\t/* database the slot is active on */\n\tOid\t\t\tdatabase;\n\n\t/*\n\t * The slot's behaviour when being dropped (or restored after a crash).\n\t */\n\tReplicationSlotPersistency persistency;\n\n\tTransactionId xmin;\n\n\t/*\n\t * xmin horizon for catalog tuples\n\t *\n\t * NB: This may represent a value that hasn't been written to disk yet;\n\t * see notes for effective_xmin, below.\n\t */\n\tTransactionId catalog_xmin;\n\n\t/* oldest LSN that might be required by this replication slot */\n\tXLogRecPtr\trestart_lsn;\n\n\t/* RS_INVAL_NONE if valid, or the reason for having been invalidated */\n\tReplicationSlotInvalidationCause invalidated;\n\n\t/*\n\t * Oldest LSN that the client has acked receipt for.  This is used as the\n\t * start_lsn point in case the client doesn't specify one, and also as a\n\t * safety measure to jump forwards in case the client specifies a\n\t * start_lsn that's further in the past than this value.\n\t */\n\tXLogRecPtr\tconfirmed_flush;\n\n\t/*\n\t * LSN at which we enabled two_phase commit for this slot or LSN at which\n\t * we found a consistent point at the time of slot creation.\n\t */\n\tXLogRecPtr\ttwo_phase_at;\n\n\t/*\n\t * Allow decoding of prepared transactions?\n\t */\n\tbool\t\ttwo_phase;\n\n\t/* plugin name */\n\tNameData\tplugin;\n\n\t/*\n\t * Was this slot synchronized from the primary server?\n\t */\n\tchar\t\tsynced;\n\n\t/*\n\t * Is this a failover slot (sync candidate for standbys)? Only relevant\n\t * for logical slots on the primary server.\n\t */\n\tbool\t\tfailover;\n} ReplicationSlotPersistentData;",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 23,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.3. Data Structure",
    "text": "The data stored in ReplicationSlotPersistentData structure is regularly saved in the pg_replslot directory.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 24,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.4. Starting Replication Slot",
    "text": "Figure 11.9 illustrates the starting sequence of a replication slot:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 25,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.4. Starting Replication Slot",
    "text": "Creating a (physical) replication slot using the pg_create_physical_replication_slot() function.\n\nExcept for the slot name, the data written to the replication slot is set to its default value.\ntestdb=# SELECT * FROM pg_create_physical_replication_slot('standby_slot');\n   slot_name   | lsn\n---------------+-----\n standby_slot  |\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 26,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.4. Starting Replication Slot",
    "text": "[CODE BLOCK]\ntestdb=# SELECT * FROM pg_create_physical_replication_slot('standby_slot');\n   slot_name   | lsn\n---------------+-----\n standby_slot  |\n(1 row)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 27,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.4. Starting Replication Slot",
    "text": "Writing a portion of the slot data, defined by the ReplicationSlotPersistentData structure, in the pg_replslot directory.\n\nA file named state is created under the subdirectory corresponding to the slot name, as shown below:\n$ ls -1 pg_replslot/\nstandby_slot\n$ find pg_replslot/\npg_replslot/\npg_replslot/standby_slot\npg_replslot/standby_slot/state",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 28,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.4. Starting Replication Slot",
    "text": "[CODE BLOCK]\n$ ls -1 pg_replslot/\nstandby_slot\n$ find pg_replslot/\npg_replslot/\npg_replslot/standby_slot\npg_replslot/standby_slot/state",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 29,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.4. Starting Replication Slot",
    "text": "(Re)Connecting standby server to the primary server.\nTo (re)connect the standby server to the primary server, set the primary_slot_name\nconfiguration parameter to the name of the replication slot.\n# standby's postgresql.conf\nprimary_slot_name = 'standby_slot'\nThen, issue the pg_ctl command with the reload option:\n$ pg_ctl -D $PGDATA_STANDBY reload",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 30,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.4. Starting Replication Slot",
    "text": "[CODE BLOCK]\n# standby's postgresql.conf\nprimary_slot_name = 'standby_slot'",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 31,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.4. Starting Replication Slot",
    "text": "Updating the replication slot, e.g., active_pid, restart_lsn, etc.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 32,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.4. Starting Replication Slot",
    "text": "Writing a portion of the updated slot data in the pg_replslot directory.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 33,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.5. Managing Replication Slots",
    "text": "After replication slots are set in shared memory,\nwalsender processes continuously update the slots to reflect the current states of the corresponding standby servers.",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 34,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.5. Managing Replication Slots",
    "text": "Below is an example of the states of the replication slots:",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 35,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.5. Managing Replication Slots",
    "text": "[CODE BLOCK]\ntestdb=# \\x\nExpanded display is on.\ntestdb=# SELECT * FROM pg_replication_slots;\n-[ RECORD 1 ]-------+--------------\nslot_name           | standby_slot\nplugin              |\nslot_type           | physical\ndatoid              |\ndatabase            |\ntemporary           | f\nactive              | t\nactive_pid          | 236772\nxmin                | 754\ncatalog_xmin        |\nrestart_lsn         | 0/303B968\nconfirmed_flush_lsn |\nwal_status          | reserved\nsafe_wal_size       |\ntwo_phase           | f\ninactive_since      |\nconflicting         |\ninvalidation_reason |\nfailover            | f\nsynced              | f",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  },
  {
    "source_type": "web",
    "source_url": "https://www.interdb.jp/pg/pgsql11/04.html",
    "book_name": "The Internals of PostgreSQL",
    "page_number": 36,
    "chapter": "Chapter 11: Streaming Replication",
    "section": "11.4.5. Managing Replication Slots",
    "text": "The primary PostgreSQL server regularly saves detailed information about its replication slots to state files in the pg_replslot directory.\n(When the primary server restarts, it loads this saved information back into memory to restore the status of its replication slots.)",
    "tables": [],
    "extracted_at": "2025-10-03T12:32:59.752273"
  }
]