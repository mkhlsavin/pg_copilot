[
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 2,
    "chapter": null,
    "section": null,
    "text": "КомпанияPostgresProfessional\nЕгор Рогов\nPostgreSQL 17\nизнутри\nМосква,2025",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:42.697411"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 3,
    "chapter": null,
    "section": null,
    "text": "УДК004.65\nББК32.972.134\nР59\nРоговЕ.В.\nР59 PostgreSQL17изнутри.—М.:ДМКПресс,2025.—668с.\nISBN978-5-93700-372-0\nВ книге рассматривается внутреннее устройство СУБД Post-\ngreSQL: детали реализации многоверсионности и изоляции на\nоснове снимковданных,включая процедуру очистки неактуаль-\nных версий строк; буферный кеш и журнал предзаписи; исполь-\nзованиеблокировокразличныхуровней;планированиеивыпол-\nнение SQL-запросов; принципы расширяемости и особенности\nимеющихсяиндексныхметодовдоступа.Большоевниманиеуде-\nляется возможностям, предоставляемым для самостоятельного\nизучениямеханизмовфункционированияPostgreSQL.\nВнастоящемизданииучтенызамечаниячитателейиисправлены\nопечатки,атакжеотраженыизменения,произошедшиевверсии\nPostgreSQL17.\nСайткниги:https://postgrespro.ru/education/books/internals.\nДляадминистраторовипрограммистов.\nУДК004.65\nББК32.972.134\nНа обложке использован фрагмент гравюры из книги The History of Four-\nfootedBeastsandSerpentsЭдвардаТопсела,изданнойв1658годувЛондоне.\nISBN978-5-93700-372-0 ©Текст,оформление,ООО«ППГ»,2025\n©Издание,ДМКПресс,2025",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:42.721869"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 4,
    "chapter": null,
    "section": null,
    "text": "Оглавление\nОкниге . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\nГлава1.Введение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23\nЧастьI.Изоляцияимноговерсионность 45\nГлава2.Изоляция . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\nГлава3.Страницыиверсиистрок . . . . . . . . . . . . . . . . . . . . . . 75\nГлава4.Снимкиданных . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97\nГлава5.Внутристраничнаяочисткаиhot-обновления . . . . . . . . . . 111\nГлава6.Очисткаиавтоочистка . . . . . . . . . . . . . . . . . . . . . . . . 125\nГлава7.Заморозка . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150\nГлава8.Перестроениетаблицииндексов . . . . . . . . . . . . . . . . . . 165\nЧастьII.Буферныйкешижурнал 177\nГлава9.Буферныйкеш . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179\nГлава10.Журналпредзаписи . . . . . . . . . . . . . . . . . . . . . . . . . 201\nГлава11.Режимыжурнала. . . . . . . . . . . . . . . . . . . . . . . . . . . 224\nЧастьIII.Блокировки 243\nГлава12.Блокировкиотношений . . . . . . . . . . . . . . . . . . . . . . 245\nГлава13.Блокировкистрок . . . . . . . . . . . . . . . . . . . . . . . . . . 258\nГлава14.Блокировкиразныхобъектов . . . . . . . . . . . . . . . . . . . 283\nГлава15.Блокировкивпамяти . . . . . . . . . . . . . . . . . . . . . . . . 295\nЧастьIV.Выполнениезапросов 305\nГлава16.Этапывыполнениязапросов. . . . . . . . . . . . . . . . . . . . 307\nГлава17.Статистика . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333\nГлава18.Табличныеметодыдоступа . . . . . . . . . . . . . . . . . . . . 358\nГлава19.Индексныеметодыдоступа . . . . . . . . . . . . . . . . . . . . 381\nГлава20.Индексноесканирование . . . . . . . . . . . . . . . . . . . . . . 401\nГлава21.Вложенныйцикл . . . . . . . . . . . . . . . . . . . . . . . . . . . 426\n3",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:42.756134"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 5,
    "chapter": null,
    "section": null,
    "text": "Оглавление\nГлава22.Хеширование . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 446\nГлава23.Сортировкаислияние . . . . . . . . . . . . . . . . . . . . . . . 472\nЧастьV.Типыиндексов 499\nГлава24.Хеш-индекс . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 501\nГлава25.B-дерево . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 513\nГлава26.ИндексGiST . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 540\nГлава27.ИндексSP-GiST . . . . . . . . . . . . . . . . . . . . . . . . . . . . 574\nГлава28.ИндексGIN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 598\nГлава29.ИндексBRIN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 628\nЗаключение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 656\nПредметныйуказатель . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 657\n4",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:42.771760"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 6,
    "chapter": null,
    "section": "1.1 Организацияданных . . . . . . . . . . . . . . . . . . . . . . . . . 23",
    "text": "Содержание\nОкниге 17\nГлава1.Введение 23\n1.1. Организацияданных . . . . . . . . . . . . . . . . . . . . . . . . . 23\nБазыданных . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23\nСистемныйкаталог . . . . . . . . . . . . . . . . . . . . . . . . . . 24\nСхемы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\nТабличныепространства. . . . . . . . . . . . . . . . . . . . . . . 26\nОтношения . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\nСлоиифайлы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\nСтраницы. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33\nTOAST . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33\n1.2. Процессыипамять . . . . . . . . . . . . . . . . . . . . . . . . . . 39\n1.3. Клиентыиклиент-серверныйпротокол . . . . . . . . . . . . . . 41\nЧасть I. Изоляция и многоверсионность 45\nГлава2.Изоляция 47\n2.1. Согласованность. . . . . . . . . . . . . . . . . . . . . . . . . . . . 47\n2.2. УровниизоляцииианомалиивстандартеSQL . . . . . . . . . . 49\nПотерянноеобновление . . . . . . . . . . . . . . . . . . . . . . . 50\nГрязноечтениеиReadUncommitted . . . . . . . . . . . . . . . . 50\nНеповторяющеесячтениеиReadCommitted . . . . . . . . . . . 51\nФантомноечтениеиRepeatableRead . . . . . . . . . . . . . . . 51\nОтсутствиеаномалийиSerializable . . . . . . . . . . . . . . . . 52\nПочемуименноэтианомалии? . . . . . . . . . . . . . . . . . . . 52\n2.3. УровниизоляциивPostgreSQL . . . . . . . . . . . . . . . . . . . 54\nReadCommitted . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55\nRepeatableRead . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\nSerializable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70\n2.4. Какойуровеньизоляциииспользовать? . . . . . . . . . . . . . . 73\n5",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:42.926350"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 7,
    "chapter": null,
    "section": "3.3 Выполнениеоперацийнадверсиямистрок . . . . . . . . . . . . 80",
    "text": "Содержание\nГлава3.Страницыиверсиистрок 75\n3.1. Структурастраниц . . . . . . . . . . . . . . . . . . . . . . . . . . 75\nЗаголовокстраницы . . . . . . . . . . . . . . . . . . . . . . . . . 75\nСпециальнаяобласть . . . . . . . . . . . . . . . . . . . . . . . . . 76\nВерсиистрок . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76\nУказателинаверсиистрок . . . . . . . . . . . . . . . . . . . . . . 77\nСвободноеместо . . . . . . . . . . . . . . . . . . . . . . . . . . . 78\n3.2. Структураверсийстрок . . . . . . . . . . . . . . . . . . . . . . . 78\n3.3. Выполнениеоперацийнадверсиямистрок . . . . . . . . . . . . 80\nВставка . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81\nФиксация . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85\nУдаление . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87\nОтмена . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88\nОбновление . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88\n3.4. Индексы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89\n3.5. TOAST . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90\n3.6. Виртуальныетранзакции . . . . . . . . . . . . . . . . . . . . . . 91\n3.7. Вложенныетранзакции . . . . . . . . . . . . . . . . . . . . . . . 92\nТочкисохранения . . . . . . . . . . . . . . . . . . . . . . . . . . . 92\nОшибкииатомарностьопераций . . . . . . . . . . . . . . . . . 94\nГлава4.Снимкиданных 97\n4.1. Чтотакоеснимокданных . . . . . . . . . . . . . . . . . . . . . . 97\n4.2. Видимостьверсийстроквснимке . . . . . . . . . . . . . . . . . 98\n4.3. Изчегосостоитснимок . . . . . . . . . . . . . . . . . . . . . . . 99\n4.4. Видимостьсобственныхизменений . . . . . . . . . . . . . . . . 104\n4.5. Горизонттранзакции . . . . . . . . . . . . . . . . . . . . . . . . . 105\n4.6. Снимокданныхдлясистемногокаталога . . . . . . . . . . . . . 108\n4.7. Экспортснимкаданных . . . . . . . . . . . . . . . . . . . . . . . 109\nГлава5.Внутристраничнаяочисткаиhot-обновления 111\n5.1. Внутристраничнаяочистка . . . . . . . . . . . . . . . . . . . . . 111\n5.2. Hot-обновления . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115\n5.3. Внутристраничнаяочисткаприhot-обновлениях . . . . . . . . 119\n5.4. Разрывhot-цепочки . . . . . . . . . . . . . . . . . . . . . . . . . 121\n5.5. Внутристраничнаяочисткаиндексов . . . . . . . . . . . . . . . 123\n6",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:42.966118"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 8,
    "chapter": null,
    "section": "6.4 Анализ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134",
    "text": "Содержание\nГлава6.Очисткаиавтоочистка 125\n6.1. Очисткавручную . . . . . . . . . . . . . . . . . . . . . . . . . . . 125\n6.2. Ещеразогоризонтебазыданных . . . . . . . . . . . . . . . . . 128\n6.3. Этапывыполненияочистки . . . . . . . . . . . . . . . . . . . . . 131\nСканированиетаблицы . . . . . . . . . . . . . . . . . . . . . . . 131\nОчисткаиндексов . . . . . . . . . . . . . . . . . . . . . . . . . . . 132\nОчисткатаблицы . . . . . . . . . . . . . . . . . . . . . . . . . . . 133\nУсечениетаблицы . . . . . . . . . . . . . . . . . . . . . . . . . . . 133\n6.4. Анализ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134\n6.5. Автоматическаяочисткаианализ . . . . . . . . . . . . . . . . . 134\nУстройствоавтоочистки . . . . . . . . . . . . . . . . . . . . . . . 135\nКакиетаблицытребуюточистки . . . . . . . . . . . . . . . . . . 136\nКакиетаблицытребуютанализа . . . . . . . . . . . . . . . . . . 138\nАвтоочисткавдействии . . . . . . . . . . . . . . . . . . . . . . . 139\n6.6. Регулированиенагрузки . . . . . . . . . . . . . . . . . . . . . . . 143\nУправлениеинтенсивностьюобычнойочистки . . . . . . . . . 144\nУправлениеинтенсивностьюавтоочистки . . . . . . . . . . . . 144\n6.7. Мониторингочистки . . . . . . . . . . . . . . . . . . . . . . . . . 145\nОтслеживаниевыполненияручнойочистки . . . . . . . . . . . 145\nОтслеживаниевыполненияавтоочистки . . . . . . . . . . . . . 148\nГлава7.Заморозка 150\n7.1. Переполнениесчетчикатранзакций . . . . . . . . . . . . . . . . 150\n7.2. Заморозкаверсийиправилавидимости . . . . . . . . . . . . . 151\n7.3. Управлениезаморозкой . . . . . . . . . . . . . . . . . . . . . . . 154\nМинимальныйвозрастдлязаморозки . . . . . . . . . . . . . . . 155\nВозрастдляагрессивнойзаморозки . . . . . . . . . . . . . . . . 157\nВозрастдляаварийногосрабатыванияавтоочистки. . . . . . . 159\nВозрастдляприоритетногорежимазаморозки . . . . . . . . . 161\n7.4. Заморозкавручную . . . . . . . . . . . . . . . . . . . . . . . . . . 162\nОчисткасзаморозкой . . . . . . . . . . . . . . . . . . . . . . . . 162\nЗаморозкапризагрузке . . . . . . . . . . . . . . . . . . . . . . . 162\nГлава8.Перестроениетаблицииндексов 165\n8.1. Полнаяочистка . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165\nНеобходимость . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165\nОценкаплотностиинформации . . . . . . . . . . . . . . . . . . 166\n7",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:43.006289"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 9,
    "chapter": null,
    "section": "8.3 Профилактика . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173",
    "text": "Содержание\nЗаморозка . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170\n8.2. Другиеспособыперестроения . . . . . . . . . . . . . . . . . . . 171\nАналогиполнойочистки . . . . . . . . . . . . . . . . . . . . . . . 171\nПерестроениебездолгихблокировок . . . . . . . . . . . . . . . 172\n8.3. Профилактика . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173\nЧитающиезапросы . . . . . . . . . . . . . . . . . . . . . . . . . . 173\nОбновлениеданных . . . . . . . . . . . . . . . . . . . . . . . . . 173\nЧасть II. Буферный кеш и журнал 177\nГлава9.Буферныйкеш 179\n9.1. Кеширование . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179\n9.2. Устройствобуферногокеша . . . . . . . . . . . . . . . . . . . . . 180\n9.3. Попаданиевкеш . . . . . . . . . . . . . . . . . . . . . . . . . . . 182\n9.4. Промахкеша . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187\nПоискбуфераивытеснение . . . . . . . . . . . . . . . . . . . . . 188\n9.5. Массовоевытеснение . . . . . . . . . . . . . . . . . . . . . . . . 190\n9.6. Настройкаразмера . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n9.7. Прогревкеша . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197\n9.8. Локальныйкеш . . . . . . . . . . . . . . . . . . . . . . . . . . . . 199\nГлава10.Журналпредзаписи 201\n10.1. Журналирование . . . . . . . . . . . . . . . . . . . . . . . . . . . 201\n10.2. Устройствожурнала . . . . . . . . . . . . . . . . . . . . . . . . . 203\nЛогическаяструктура. . . . . . . . . . . . . . . . . . . . . . . . . 203\nФизическаяструктура . . . . . . . . . . . . . . . . . . . . . . . . 206\n10.3. Контрольнаяточка . . . . . . . . . . . . . . . . . . . . . . . . . . 208\n10.4. Восстановление . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213\n10.5. Фоноваязапись . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216\n10.6. Настройка . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217\nНастройкаконтрольнойточки . . . . . . . . . . . . . . . . . . . 217\nНастройкафоновойзаписи . . . . . . . . . . . . . . . . . . . . . 220\nМониторинг . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221\nГлава11.Режимыжурнала 224\n11.1. Производительность . . . . . . . . . . . . . . . . . . . . . . . . . 224\n8",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:43.042996"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 10,
    "chapter": null,
    "section": "11.3 Уровнижурнала . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236",
    "text": "Содержание\n11.2. Надежность . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228\nКеширование . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229\nПовреждениеданных . . . . . . . . . . . . . . . . . . . . . . . . . 230\nНеатомарностьзаписи . . . . . . . . . . . . . . . . . . . . . . . . 232\n11.3. Уровнижурнала . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236\nMinimal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237\nReplica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239\nLogical. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241\nЧасть III. Блокировки 243\nГлава12.Блокировкиотношений 245\n12.1. Общиесведенияоблокировках . . . . . . . . . . . . . . . . . . . 245\n12.2. Тяжелыеблокировки . . . . . . . . . . . . . . . . . . . . . . . . . 248\n12.3. Блокировкиномеровтранзакций . . . . . . . . . . . . . . . . . 249\n12.4. Блокировкиотношений . . . . . . . . . . . . . . . . . . . . . . . 251\n12.5. Очередьожидания . . . . . . . . . . . . . . . . . . . . . . . . . . 254\nГлава13.Блокировкистрок 258\n13.1. Устройство . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258\n13.2. Режимыблокировкистроки . . . . . . . . . . . . . . . . . . . . . 259\nИсключительныережимы . . . . . . . . . . . . . . . . . . . . . . 259\nРазделяемыережимы . . . . . . . . . . . . . . . . . . . . . . . . 261\n13.3. Мультитранзакции . . . . . . . . . . . . . . . . . . . . . . . . . . 262\n13.4. Очередьожидания . . . . . . . . . . . . . . . . . . . . . . . . . . 264\nИсключительныережимы . . . . . . . . . . . . . . . . . . . . . . 264\nРазделяемыережимы . . . . . . . . . . . . . . . . . . . . . . . . 271\n13.5. Блокировкабезожидания . . . . . . . . . . . . . . . . . . . . . . 274\n13.6. Взаимоблокировки . . . . . . . . . . . . . . . . . . . . . . . . . . 276\nВзаимоблокировкаприобновлениистрок . . . . . . . . . . . . 278\nВзаимоблокировкадвухкомандUPDATE . . . . . . . . . . . . . 279\nГлава14.Блокировкиразныхобъектов 283\n14.1. Блокировкинеотношений . . . . . . . . . . . . . . . . . . . . . . 283\n14.2. Блокировкирасширенияотношения. . . . . . . . . . . . . . . . 285\n14.3. Блокировкистраниц . . . . . . . . . . . . . . . . . . . . . . . . . 286\n9",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:43.079493"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 11,
    "chapter": null,
    "section": "15.3 Примеры . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 296",
    "text": "Содержание\n14.4. Рекомендательныеблокировки . . . . . . . . . . . . . . . . . . . 286\n14.5. Предикатныеблокировки . . . . . . . . . . . . . . . . . . . . . . 288\nГлава15.Блокировкивпамяти 295\n15.1. Спин-блокировки . . . . . . . . . . . . . . . . . . . . . . . . . . . 295\n15.2. Легкиеблокировки . . . . . . . . . . . . . . . . . . . . . . . . . . 296\n15.3. Примеры . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 296\nБуферныйкеш . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 296\nБуферыжурналапредзаписи . . . . . . . . . . . . . . . . . . . . 298\nКешSLRU . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299\n15.4. Мониторингожиданий . . . . . . . . . . . . . . . . . . . . . . . . 300\n15.5. Семплирование . . . . . . . . . . . . . . . . . . . . . . . . . . . . 302\nЧасть IV. Выполнение запросов 305\nГлава16.Этапывыполнениязапросов 307\n16.1. Демонстрационнаябазаданных . . . . . . . . . . . . . . . . . . 307\n16.2. Простойпротоколзапросов . . . . . . . . . . . . . . . . . . . . . 310\nРазбор . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 310\nТрансформация . . . . . . . . . . . . . . . . . . . . . . . . . . . . 312\nПланирование . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 314\nИсполнение . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 325\n16.3. Расширенныйпротоколзапросов . . . . . . . . . . . . . . . . . 327\nПодготовка . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327\nПривязкапараметров . . . . . . . . . . . . . . . . . . . . . . . . 328\nПланированиеиисполнение . . . . . . . . . . . . . . . . . . . . 329\nПолучениерезультатов. . . . . . . . . . . . . . . . . . . . . . . . 332\nГлава17.Статистика 333\n17.1. Базоваястатистика . . . . . . . . . . . . . . . . . . . . . . . . . . 333\n17.2. Неопределенныезначения . . . . . . . . . . . . . . . . . . . . . 337\n17.3. Уникальныезначения . . . . . . . . . . . . . . . . . . . . . . . . 338\n17.4. Наиболеечастыезначения . . . . . . . . . . . . . . . . . . . . . 340\n17.5. Гистограмма . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 343\n17.6. Статистикадлянескалярныхтиповданных . . . . . . . . . . . 347\n17.7. Среднийразмерполя . . . . . . . . . . . . . . . . . . . . . . . . . 348\n10",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:43.117361"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 12,
    "chapter": null,
    "section": "17.10 Многовариантнаястатистика . . . . . . . . . . . . . . . . . . . . 352",
    "text": "Содержание\n17.8. Корреляция . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 348\n17.9. Статистикаповыражению. . . . . . . . . . . . . . . . . . . . . . 349\nРасширеннаястатистикаповыражению . . . . . . . . . . . . . 350\nСтатистикадляиндексаповыражению . . . . . . . . . . . . . . 351\n17.10. Многовариантнаястатистика . . . . . . . . . . . . . . . . . . . . 352\nФункциональныезависимостимеждустолбцами . . . . . . . . 352\nМноговариантноечислоразличныхзначений . . . . . . . . . . 354\nМноговариантныеспискичастыхзначений . . . . . . . . . . . 356\nГлава18.Табличныеметодыдоступа 358\n18.1. Подключаемыедвижкихранения . . . . . . . . . . . . . . . . . 358\n18.2. Последовательноесканирование . . . . . . . . . . . . . . . . . . 361\nОценкастоимости . . . . . . . . . . . . . . . . . . . . . . . . . . 362\n18.3. Параллельныепланывыполнения . . . . . . . . . . . . . . . . . 366\n18.4. Параллельноепоследовательноесканирование . . . . . . . . . 367\nОценкастоимости . . . . . . . . . . . . . . . . . . . . . . . . . . 367\n18.5. Ограниченияпараллельноговыполнения. . . . . . . . . . . . . 371\nКоличестворабочихпроцессов . . . . . . . . . . . . . . . . . . . 371\nНераспараллеливаемыезапросы . . . . . . . . . . . . . . . . . . 375\nОграниченнораспараллеливаемыезапросы . . . . . . . . . . . 376\nГлава19.Индексныеметодыдоступа 381\n19.1. Индексыирасширяемость . . . . . . . . . . . . . . . . . . . . . 381\n19.2. Классыисемействаоператоров . . . . . . . . . . . . . . . . . . 384\nКлассоператоров . . . . . . . . . . . . . . . . . . . . . . . . . . . 384\nСемействооператоров . . . . . . . . . . . . . . . . . . . . . . . . 389\n19.3. Интерфейсмеханизмаиндексирования . . . . . . . . . . . . . . 391\nСвойстваметодадоступа . . . . . . . . . . . . . . . . . . . . . . 392\nСвойстваиндекса . . . . . . . . . . . . . . . . . . . . . . . . . . . 396\nСвойствастолбцов . . . . . . . . . . . . . . . . . . . . . . . . . . 397\nГлава20.Индексноесканирование 401\n20.1. Простоеиндексноесканирование . . . . . . . . . . . . . . . . . 401\nОценкастоимости . . . . . . . . . . . . . . . . . . . . . . . . . . 402\nХорошийслучай:высокаякорреляция. . . . . . . . . . . . . . . 403\nПлохойслучай:низкаякорреляция . . . . . . . . . . . . . . . . 406\n11",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:43.155734"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 13,
    "chapter": null,
    "section": "20.5 Сравнениеметодовдоступа . . . . . . . . . . . . . . . . . . . . . 424",
    "text": "Содержание\n20.2. Сканированиетолькоиндекса . . . . . . . . . . . . . . . . . . . 409\nInclude-индексы . . . . . . . . . . . . . . . . . . . . . . . . . . . . 412\n20.3. Сканированиепобитовойкарте . . . . . . . . . . . . . . . . . . 414\nТочностькарты . . . . . . . . . . . . . . . . . . . . . . . . . . . . 415\nДействиясбитовымикартами . . . . . . . . . . . . . . . . . . . 417\nОценкастоимости . . . . . . . . . . . . . . . . . . . . . . . . . . 418\n20.4. Параллельныеверсиииндексногосканирования . . . . . . . . 422\n20.5. Сравнениеметодовдоступа . . . . . . . . . . . . . . . . . . . . . 424\nГлава21.Вложенныйцикл 426\n21.1. Видыиспособысоединений . . . . . . . . . . . . . . . . . . . . 426\n21.2. Соединениевложеннымциклом . . . . . . . . . . . . . . . . . . 428\nДекартовопроизведение. . . . . . . . . . . . . . . . . . . . . . . 428\nПараметризованноесоединение . . . . . . . . . . . . . . . . . . 432\nКеширование(мемоизация)строк . . . . . . . . . . . . . . . . . 436\nВнешниесоединения . . . . . . . . . . . . . . . . . . . . . . . . . 440\nАнти-иполусоединения . . . . . . . . . . . . . . . . . . . . . . . 441\nНеэквисоединения . . . . . . . . . . . . . . . . . . . . . . . . . . 443\nПараллельныйрежим . . . . . . . . . . . . . . . . . . . . . . . . 444\nГлава22.Хеширование 446\n22.1. Соединениехешированием . . . . . . . . . . . . . . . . . . . . . 446\nОднопроходноесоединениехешированием . . . . . . . . . . . 446\nДвухпроходноесоединениехешированием. . . . . . . . . . . . 452\nДинамическиекорректировкиплана . . . . . . . . . . . . . . . 455\nСоединениехешированиемвпараллельныхпланах. . . . . . . 459\nПараллельноеоднопроходноехеш-соединение . . . . . . . . . 460\nПараллельноедвухпроходноехеш-соединение . . . . . . . . . 462\nМодификации . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 465\n22.2. Группировкаиуникальныезначения . . . . . . . . . . . . . . . 467\nГлава23.Сортировкаислияние 472\n23.1. Соединениеслиянием . . . . . . . . . . . . . . . . . . . . . . . . 472\nСлияниеотсортированныхнаборов . . . . . . . . . . . . . . . . 472\nПараллельныйрежим . . . . . . . . . . . . . . . . . . . . . . . . 476\nМодификации . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 477\n12",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:43.193604"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 14,
    "chapter": null,
    "section": "23.4 Сравнениеспособовсоединения . . . . . . . . . . . . . . . . . . 494",
    "text": "Содержание\n23.2. Сортировка. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 478\nБыстраясортировка . . . . . . . . . . . . . . . . . . . . . . . . . 480\nЧастичнаяпирамидальнаясортировка . . . . . . . . . . . . . . 481\nВнешняясортировка . . . . . . . . . . . . . . . . . . . . . . . . . 483\nИнкрементальнаясортировка. . . . . . . . . . . . . . . . . . . . 487\nПараллельныйрежим . . . . . . . . . . . . . . . . . . . . . . . . 489\n23.3. Группировкаиуникальныезначения . . . . . . . . . . . . . . . 491\n23.4. Сравнениеспособовсоединения . . . . . . . . . . . . . . . . . . 494\nЧастьV.Типы индексов 499\nГлава24.Хеш-индекс 501\n24.1. Общийпринцип . . . . . . . . . . . . . . . . . . . . . . . . . . . . 501\n24.2. Страничнаяорганизация . . . . . . . . . . . . . . . . . . . . . . 502\n24.3. Классоператоров . . . . . . . . . . . . . . . . . . . . . . . . . . . 509\n24.4. Свойства . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 510\nСвойстваметодадоступа . . . . . . . . . . . . . . . . . . . . . . 510\nСвойстваиндекса . . . . . . . . . . . . . . . . . . . . . . . . . . . 511\nСвойствастолбцов . . . . . . . . . . . . . . . . . . . . . . . . . . 512\nГлава25.B-дерево 513\n25.1. Общийпринцип . . . . . . . . . . . . . . . . . . . . . . . . . . . . 513\n25.2. Поискивставка . . . . . . . . . . . . . . . . . . . . . . . . . . . . 514\nПоискпоравенству . . . . . . . . . . . . . . . . . . . . . . . . . . 514\nПоискпонеравенству . . . . . . . . . . . . . . . . . . . . . . . . 516\nПоискподиапазону . . . . . . . . . . . . . . . . . . . . . . . . . 517\nВставка . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 517\n25.3. Страничнаяорганизация . . . . . . . . . . . . . . . . . . . . . . 519\nКомпактноехранениедубликатов . . . . . . . . . . . . . . . . . 523\nКомпактноехранениевнутреннихиндексныхзаписей . . . . . 525\n25.4. Классоператоров . . . . . . . . . . . . . . . . . . . . . . . . . . . 526\nСемантикасравнения . . . . . . . . . . . . . . . . . . . . . . . . 526\nСортировкаисоставныеиндексы . . . . . . . . . . . . . . . . . 532\n25.5. Свойства . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 537\nСвойстваметодадоступа . . . . . . . . . . . . . . . . . . . . . . 537\nСвойстваиндекса . . . . . . . . . . . . . . . . . . . . . . . . . . . 538\nСвойствастолбцов . . . . . . . . . . . . . . . . . . . . . . . . . . 539\n13",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:43.232452"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 15,
    "chapter": null,
    "section": "26.2 R-дереводляточек . . . . . . . . . . . . . . . . . . . . . . . . . . 542",
    "text": "Содержание\nГлава26.ИндексGiST 540\n26.1. Общийпринцип . . . . . . . . . . . . . . . . . . . . . . . . . . . . 540\n26.2. R-дереводляточек . . . . . . . . . . . . . . . . . . . . . . . . . . 542\nСтраничнаяорганизация . . . . . . . . . . . . . . . . . . . . . . 545\nКлассоператоров . . . . . . . . . . . . . . . . . . . . . . . . . . . 546\nПоисквхождениявобласть . . . . . . . . . . . . . . . . . . . . . 548\nПоискближайшихсоседей . . . . . . . . . . . . . . . . . . . . . . 550\nВставка . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 555\nОграничениеисключения . . . . . . . . . . . . . . . . . . . . . . 556\nСвойства . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 559\n26.3. RD-дереводляполнотекстовогопоиска . . . . . . . . . . . . . . 562\nПрополнотекстовыйпоиск . . . . . . . . . . . . . . . . . . . . . 562\nИндексацияtsvector . . . . . . . . . . . . . . . . . . . . . . . . . 563\nСвойства . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 571\n26.4. Другиетипыданных . . . . . . . . . . . . . . . . . . . . . . . . . 571\nГлава27.ИндексSP-GiST 574\n27.1. Общийпринцип . . . . . . . . . . . . . . . . . . . . . . . . . . . . 574\n27.2. Деревоквадрантовдляточек . . . . . . . . . . . . . . . . . . . . 576\nКлассоператоров . . . . . . . . . . . . . . . . . . . . . . . . . . . 577\nСтраничнаяорганизация . . . . . . . . . . . . . . . . . . . . . . 581\nПоиск . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 582\nВставка . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 583\nСвойства . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 586\n27.3. K-мерныедеревьядляточек. . . . . . . . . . . . . . . . . . . . . 588\n27.4. Префиксноедереводлястрок . . . . . . . . . . . . . . . . . . . . 590\nКлассоператоров . . . . . . . . . . . . . . . . . . . . . . . . . . . 591\nПоиск . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 592\nВставка . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 593\nСвойства . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 595\n27.5. Другиетипыданных . . . . . . . . . . . . . . . . . . . . . . . . . 596\nГлава28.ИндексGIN 598\n28.1. Общийпринцип . . . . . . . . . . . . . . . . . . . . . . . . . . . . 598\n28.2. Индексдляполнотекстовогопоиска . . . . . . . . . . . . . . . . 599\nСтраничнаяорганизация . . . . . . . . . . . . . . . . . . . . . . 601\nКлассоператоров . . . . . . . . . . . . . . . . . . . . . . . . . . . 603\n14",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:43.274241"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 16,
    "chapter": null,
    "section": "28.5 ИндексдляJSON . . . . . . . . . . . . . . . . . . . . . . . . . . . 622",
    "text": "Содержание\nПоиск . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 605\nЧастыеиредкиелексемы . . . . . . . . . . . . . . . . . . . . . . 606\nВставка . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 610\nОграничениевыборки . . . . . . . . . . . . . . . . . . . . . . . . 612\nСвойства . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 613\nОграниченияGINиRUM-индекс . . . . . . . . . . . . . . . . . . 615\n28.3. Индексдлятриграмм . . . . . . . . . . . . . . . . . . . . . . . . . 616\n28.4. Индексдлямассивов . . . . . . . . . . . . . . . . . . . . . . . . . 618\n28.5. ИндексдляJSON . . . . . . . . . . . . . . . . . . . . . . . . . . . 622\nКлассоператоровjsonb_ops . . . . . . . . . . . . . . . . . . . . . 622\nКлассоператоровjsonb_path_ops . . . . . . . . . . . . . . . . . . 625\n28.6. Другиетипыданных . . . . . . . . . . . . . . . . . . . . . . . . . 627\nГлава29.ИндексBRIN 628\n29.1. Общийпринцип . . . . . . . . . . . . . . . . . . . . . . . . . . . . 628\n29.2. Пример . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 629\n29.3. Страничнаяорганизация . . . . . . . . . . . . . . . . . . . . . . 631\n29.4. Поиск . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 633\n29.5. Обновлениесводнойинформации . . . . . . . . . . . . . . . . . 634\nВставказначений . . . . . . . . . . . . . . . . . . . . . . . . . . . 634\nОбобщениезоны . . . . . . . . . . . . . . . . . . . . . . . . . . . 635\n29.6. Диапазонызначений(minmax) . . . . . . . . . . . . . . . . . . . 636\nВыборстолбцовдляиндексирования . . . . . . . . . . . . . . . 637\nРазмерзоныиэффективностьпоиска . . . . . . . . . . . . . . . 638\nСвойства . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 642\n29.7. Мультидиапазонызначений(minmax-multi) . . . . . . . . . . . 645\n29.8. Охватывающиезначения(inclusion) . . . . . . . . . . . . . . . . 648\n29.9. ФильтрыБлума(bloom) . . . . . . . . . . . . . . . . . . . . . . . 651\nЗаключение 656\nПредметныйуказатель 657\n15",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:43.306931"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 18,
    "chapter": null,
    "section": "28.5 ИндексдляJSON . . . . . . . . . . . . . . . . . . . . . . . . . . . 622",
    "text": "О книге\n—Дочегожеэтовсепросто!—воскликнулШпунтик.—Аягде-то\nчитал,чтописателюнуженкакой-товымысел,замысел...\n—Э,замысел!—нетерпеливоперебилегоСмекайло.—Этотольков\nкнигахтакпишется,чтонужензамысел,апопробуйзадумай\nчто-нибудь,когдавсеужеибезтебязадумано!Чтонивозьми—\nвсеужебыло.\nНиколайНосов,ПриключенияНезнайкииегодрузей\nДля кого эта книга\nЭта книгадлятех,кого не устраиваетработа с базойданных как с черным\nящиком.Есливылюбознательны,недовольствуетесьавторитетнымисове-\nтамиихотитевовсемразобратьсясами—нампопути.\nЯ ориентируюсь на читателей, имеющих определенный опыт использова-\nнияPostgreSQLихотябывобщихчертахпредставляющихсебе,чтокчему.\nДля совсем новичков текст будет тяжеловат. Например, я ни слова не ска-\nжу отом,как устанавливатьсервер,вводитькоманды в psql или изменять\nконфигурационныепараметры.\nНадеюсь,чтокнигабудетполезнойитем,ктохорошознакомсустройством\nдругой СУБД,но переходит на PostgreSQL и хочет разобраться в отличиях.\nНескольколетназадтакаякнигасэкономилабымнемноговремени.Имен-\nнопоэтомуяеевконцеконцовинаписал.\nЧего нет в книге\nЭта книга — не сборник рецептов. На все случаи жизни готовых решений\nне напасешься,а понимание внутренней механики сложной системы дает\n17",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:43.330668"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 19,
    "chapter": null,
    "section": "28.5 ИндексдляJSON . . . . . . . . . . . . . . . . . . . . . . . . . . . 622",
    "text": "Окниге\nвозможность критически переосмысливать чужой опыт и делать свои соб-\nственные выводы. Поэтому я и объясняю такие подробности устройства,\nзнаниекоторыхнапервыйвзгляднеимеетпрактическогосмысла.\nНоэтакнигаинеучебник.Онауглубляетсяводниобласти(болееинтерес-\nныемнесамому)иобходитсторонойдругие.ЕсливыизучаетеSQL,обрати-\nтевниманиенаучебникЕвгенияМоргуноваPostgreSQL.ОсновыязыкаSQL1,\nа необходимыйтеоретический фундаментдасткнига Бориса Новикова Ос-\nновытехнологийбазданных2.\nНазываться справочником эта книга тоже не претендует. Я старался быть\nточным,ноуменянебылоцелизаменитькнигойдокументацию,поэтому\nя легко опускал непринципиальные,на мой взгляд,подробности.В любой\nнепонятнойситуациичитайтедокументацию.\nЕще эта книга не учит разрабатывать ядро PostgreSQL. Я не предполагаю\nучитателязнанияязыкаCиориентируюсьнаадминистраторовиприклад-\nныхразработчиков.Хотяиссылаюсьпостояннонаисходныйкод,изкоторо-\nгоможноузнатьстолькоподробностей,сколькодушеугодно,идажебольше.\nЧто в книге есть\nВовводнойглавебезособыхдеталейядаюосновныепонятия,накоторые\nопираетсявседальнейшееповествование.Япредполагаю,чтовынепочерп-\nнетеизэтойглавыпрактическиничегонового,новсе-такивключаюеедля\nполноты картины. К тому же она может пригодиться тем, кто переходит\nсдругихСУБД.\nПерваячастькнигипосвященавопросамсогласованностииизоляции,кото-\nрыеясперварассматриваюспозициипользователя(какиеуровниизоляции\nсуществуюти чем это грозит),а затем сточки зрения внутреннего устрой-\nства.Дляэтогомнеприходитсяпогрузитьсявдеталиреализациимноговер-\nсионностииизоляциинаосновеснимковданных.Особенномноговнима-\nниятребуетпроцедураочисткинеактуальныхверсийстрок.\n1 postgrespro.ru/education/books/sqlprimer.\n2 postgrespro.ru/education/books/dbtech.\n18",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:43.363693"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 20,
    "chapter": null,
    "section": "28.5 ИндексдляJSON . . . . . . . . . . . . . . . . . . . . . . . . . . . 622",
    "text": "Обозначения\nВовторойчастиярассматриваюбуферныйкешимеханизм,позволяющий\nвосстанавливатьсогласованностьпослесбоев,—журналпредзаписи.\nВтретьейчастидетальноразбираетсяустройствоииспользованиеблокиро-\nвокразныхуровней:легкихблокировокдляоперативнойпамяти,тяжелых\nблокировокдляотношений,блокировоктабличныхстрок.\nЧетвертаячастьобъясняет,каксерверпланируетивыполняетSQL-запросы.\nЯрассказываю,какиеестьспособыдоступакданным,какиеприменяются\nметодысоединенияикакиспользуетсястатистическаяинформация.\nВ пятой части обсуждение индексов,сводившееся ранее к B-деревьям,до-\nбираетсяидоостальныхметодовдоступа.Сначалаярассматриваюобщие\nпринципырасширяемости,устанавливающиеграницымеждуядромсисте-\nмыиндексирования,индекснымиметодамидоступаитипамиданных(что\nтребуетвведения понятия классов операторов),а затем подробно останав-\nливаюсьнаособенностяхкаждогоизимеющихсяметодов.\nВсоставPostgreSQLвходитмасса«интроспективных»расширений,которые\nненужныдляобычнойработы,нодаютвозможностьзаглянутьвовнутрен-\nнюю жизньсервера.В книге используются многие из них.Крометого,что\nэти расширения позволяют лучше изучить устройство сервера, они могут\nоблегчитьдиагностикувсложныхслучаях.\nОбозначения\nЯпыталсяписатькнигутак,чтобыееможнобылочитатьпоследовательно,\nстраницазастраницей.Новсюправдунеполучаетсяраскрытьсразу,икод-\nной итой жетеме приходится возвращаться несколько раз.Если бы я каж-\nдыйразписал«этобудетрассмотренопозже»,книгасильноувеличиласьбы\nв размере,поэтомувтаких случаях я ставлюна поляхномер страницы,на с.19\nкоторойтемаразвиваетсядальше.Такойженомер,ведущийназад,отсылает\nкместувкниге,гдеужечто-тоговорилосьопредметеобсуждения.\nТексткнигиивсепримерыактуальныдляPostgreSQL17.Некоторыеабзацы v.17\nимеютнаполяхотметкуономереверсии.Этоозначает,чтосказанноеспра-\nведливодляверсийPostgreSQL,начинаясуказанной,аболееранниеверсии\nлибо вовсе не имели описанной возможности,либо были устроены как-то\n19",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:43.400501"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 21,
    "chapter": null,
    "section": "28.5 ИндексдляJSON . . . . . . . . . . . . . . . . . . . . . . . . . . . 622",
    "text": "Окниге\nиначе.Такиепометкимогутоказатьсяполезнымидлятех,ктоещенеобно-\nвилсистемудопоследнеговыпуска.\nТакженаполяхуказываютсязначенияпоумолчаниюдляобсуждаемыхпа-\nраметров.Самипараметры(какобычные,такипараметрыхранения)выде-\n4MB леныкурсивом:work_mem.\nВсноскахяпостоянноссылаюсьнапервоисточники.Ихнесколько,инапер-\nвомместестоиткладезьполезнойинформации—документация1.Являясь\nорганичной частью проекта, она всегда поддерживается в актуальном со-\nстояниисамимиразработчиками.Ноглавныйпервоисточник—безусловно,\nисходныйкод2.Удивительно,накакоеколичествовопросовможнонайтиот-\nветы просто в комментариях и файлах README,даже не владея языком C.\nРежеяссылаюсьназаписикоммитфеста3:вперепискахpgsql-hackersвсегда\nможнопроследитьисториюизмененийипонятьлогикупринятыхразработ-\nчикамирешений,ноценойчтенияогромногомассиваобсуждений.\nЛирические отступления и замечания,которые могутувести в сторонуотосновной\nмысли,нокоторыеянеудержалсяивставилвкнигу,выделенытак,чтобыихможно\nбылопропустить.\nКонечно,вкнигемногофрагментовкода,восновномнаязыкеSQL.Кодпо-\nказан с приглашением =>; если необходимо,то следом за ним приведен и\nответсервера:\n=> SELECT clock_timestamp();\nclock_timestamp\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n2025−01−12 14:38:17.955752+03\n(1 row)\nЕсли аккуратно повторять все приведенные команды в PostgreSQL 17,дол-\nженполучитьсятакойжерезультат(конечно,сточностьюдономеровтран-\nзакцийипрочихнесущественныхдеталей).Вовсякомслучае,веськодвкни-\nге—результатвыполненияскрипта,содержащегоровноэтикоманды.\nКогда требуется показать одновременную работу нескольких транзакций,\nкод,выполняющийсявдругомсеансе,выделенотступомиотчеркиванием:\n1 postgrespro.ru/docs/postgresql/17/index.\n2 git.postgresql.org/gitweb/?p=postgresql.git;a=summary.\n3 commitfest.postgresql.org.\n20",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:43.443441"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 22,
    "chapter": null,
    "section": "28.5 ИндексдляJSON . . . . . . . . . . . . . . . . . . . . . . . . . . . 622",
    "text": "Благодарности\n=> SHOW server_version;\nserver_version\n−−−−−−−−−−−−−−−−\n17.2\n(1 row)\nЧтобы повторитьтакие команды (а это полезно для самообразования,как\nилюбыеэксперименты),удобнооткрытьдватерминаласpsql.\nОтдельные команды и названия различных объектов базы данных (таких\nкактаблицыистолбцы,функции,расширения)выделенывтекстемоноши-\nриннымшрифтом:UPDATE,pg_class.\nВызовыутилитизоперационнойсистемыпоказанысприглашением,окан-\nчивающимсяна$:\npostgres$ whoami\npostgres\nЯиспользуюLinux,нобезкакой-либоспецифики;достаточнобудетсамого\nбазовогопонимания.\nБлагодарности\nКнигуневозможнонаписатьводиночку,иэтоотличныйповодсказатьспа-\nсибохорошимлюдям.\nЯблагодаренПавлуЛузанову,которыйвнужныймоментпредложилмнеза-\nнятьсячем-тодействительностоящим.\nЯпризнателенкомпанииPostgresProfessionalзавозможностьработатьнад\nэтойкнигойнетольковсвободноевремя.Нокомпания—этолюди,ияхо-\nчусказатьотдельноеспасибоОлегуБартуновузанеиссякаемуюэнергиюи\nидеииИвануПанченкозавсестороннююподдержкуиLATEX.\nСпасибомоимтоварищампообразовательномуотделузатворческуюатмо-\nсферуидискуссии,входекоторыхформировалсяматериалучебныхкурсов\nи способ его подачи,что нашло свое отражение и в книге. Спасибо Павлу\nТолмачевузавнимательнуювычиткучерновиков.\n21",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:43.471583"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 23,
    "chapter": null,
    "section": "28.5 ИндексдляJSON . . . . . . . . . . . . . . . . . . . . . . . . . . . 622",
    "text": "Окниге\nМногие главы книги впервые были опубликованы в виде статей на Хабре1,\nияблагодаренчитателямзазамечанияиотклики.Онипоказалинужность\nэтой работы,позволили разглядетьбелые пятна в моих знаниях и сделать\nтекстлучше.\nСпасибо Людмиле Мантровой,проделавшей огромную работу над языком\nкниги.Есливынеспотыкаетесьнакаждомвторомпредложении,этоееза-\nслуга.\nВ книге я не называю имен,но за каждой функцией и возможностью,про\nкоторыеяпишу,стоитмноголетнийтрудвполнеконкретныхлюдей.Явос-\nхищаюсьразработчикамиPostgreSQL,имнеособенноприятно,чтомногих\nизнихяимеючестьназыватьколлегами.\n1 habr.com/ru/company/postgrespro/blog.\n22",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:43.483603"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 24,
    "chapter": null,
    "section": "1.1 Организация данных",
    "text": "1\nВведение\n1.1. Организация данных\nБазы данных\nPostgreSQL—программа,котораяотноситсякклассусистемуправленияба-\nзамиданных.Когдаэтапрограммавыполняется,мыназываемеесервером\nPostgreSQL,илиэкземпляромсервера.\nДанные,которыми управляетPostgreSQL,хранятся в базах данных1.Один\nэкземплярPostgreSQLодновременноработаетснесколькимибазами,кото-\nрыевместеназываютсякластеромбазданных.\nЧтобы кластер можно было использовать, его необходимо инициализиро-\nвать2 (создать).Каталог,в котором размещаются все файлы,относящиеся\nк кластеру,обычно называютсловом PGDATA, по имени переменной окру-\nжения,указывающейнаэтоткаталог.\nПакетные установки могут вводить свои «слои абстракции» над штатным механиз-\nмомPostgreSQL,явнопрописываявсенеобходимыеутилитампараметры.Сервербаз\nданныхпредставляетсявтакомслучаеввидеслужбыоперационнойсистемы,инепо-\nсредственно с переменной PGDATA можно никогда не встретиться.Но сам термин\nустоялся,иябудуимпользоваться.\n1 postgrespro.ru/docs/postgresql/17/managing-databases.\n2 postgrespro.ru/docs/postgresql/17/app-initdb.\n23",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:43.505265"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 25,
    "chapter": null,
    "section": "1.1 Организация данных",
    "text": "Глава1. Введение\nПриинициализациивPGDATAсоздаютсятриодинаковыебазыданных:\ntemplate0 используется, например, для восстановления из логической ре-\nс.617 зервнойкопииилидлясозданиябазывдругойкодировкеиникогдане\nдолжнаменяться;\ntemplate1 служитшаблономдлявсехостальныхбазданных,которыеможет\nсоздатьпользовательвэтомкластере;\npostgres представляетсобойобычнуюбазуданных,которуюможноисполь-\nзоватьпосвоемуусмотрению.\nЭкземплярPostgreSQL\nкластер\nбаз\nCREATEDATABASE\nданных\npostgres template0 template1 newdb\nСистемный каталог\nМетаинформацияобовсехобъектахкластера(такихкактаблицы,индексы,\nтипы данных или функции) хранится в таблицах, относящихся к систем-\nномукаталогу1.Вкаждойбазеданныхимеетсясобственныйнабортаблиц\n(ипредставлений),описывающихобъектыэтойконкретнойбазы.Существу-\nеттакженесколькотаблицсистемногокаталога,общихдлявсегокластера,\nкоторыенепринадлежаткакой-либоопределеннойбазеданных(формаль-\nноиспользуетсяфиктивнаябазаснулевымидентификатором),нодоступны\nвлюбойизних.\n1 postgrespro.ru/docs/postgresql/17/catalogs.\n24",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:43.682419"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 26,
    "chapter": null,
    "section": "1.1 Организацияданных",
    "text": "1.1. Организацияданных\nК системному каталогу можно обращаться с помощью обычных запросов\nSQL,а изменения в нем происходятпри выполнении команд DDL.Клиент\npsqlрасполагаетцелымрядомспециальныхкоманддляпросмотрасистем-\nногокаталога.\nВсе имена таблиц системного каталога имеют префикс pg_, например\npg_database.Именастолбцовначинаютсястрехбуквенногокода,который\nобычносоответствуетименитаблицы,напримерdatname.\nВовсехтаблицахсистемногокаталогастолбецспервичнымключомназыва-\nетсяoidиимеетодноименныйтипoid(objectidentifier)—целое32-битное\nчисло.\nПо сути, механизм идентификаторов объектов oid — аналог последовательностей,\nпоявившийсявPostgreSQLзадолгодосамихпоследовательностей.Егоособенность\nвтом,чтоуникальныеномераиспользуютсявразныхтаблицахсистемногокаталога,\nхотявыдаютсяспомощьюединогосчетчика.Когдаобщеечисловыданныхномеров\nвыходитзадиапазонзначений,счетчикобнуляется.Уникальностьзначенийвконкрет-\nнойтаблицегарантируетсятем,чтоочередноезначениеoidпроверяетсяспомощью\nуникальногоиндексаи,еслионоужеиспользуетсявэтойтаблице,счетчикувеличи-\nвается,апроверкаповторяется1.\nСхемы\nСхемы2 представляют собой пространства имен для всех объектов, храня-\nщихсявбазеданных.Кромепользовательскихсхем,имеетсянесколькоспе-\nциальныхслужебных:\npublic используетсяпоумолчаниюдляпользовательскихобъектов,еслине\nвыполненыиныенастройки;\npg_catalog используетсядлятаблицсистемногокаталога;\ninformation_schema даетальтернативноепредставлениесистемногокатало-\nга,регламентируемоестандартомSQL;\npg_toast используетсядляобъектов,относящихсякTOAST; с.33\n1 backend/catalog/catalog.c,функцияGetNewOidWithIndex.\n2 postgrespro.ru/docs/postgresql/17/ddl-schemas.\n25",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:43.716483"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 27,
    "chapter": null,
    "section": "1.1 Организацияданных",
    "text": "Глава1. Введение\npg_temp объединяетвременныетаблицы(хотявременныетаблицыразных\nпользователейсоздаютсявразныхсхемахpg_temp_N,каждыйобраща-\nетсяксвоимобъектам,используяимяpg_temp).\nСхемы существуют внутри базы данных,и все объекты базы принадлежат\nкаким-либосхемам.\nЕсли при обращении к объекту схема не указана явно,выбирается первая\nподходящая схема из перечисленных в пути поиска.Путь формируется на\nосновезначенияпараметраsearch_path,ккоторому,вчастности,неявнодо-\nбавляютсясхемыpg_catalogи(принеобходимости)pg_temp.Этопозволя-\nетиметьвразныхсхемахобъектысодинаковымиименами.\nТабличные пространства\nВ отличие отлогического распределения объектов по базам данных и схе-\nмам,табличные пространства определяютфизическое расположениедан-\nных.Фактическитабличноепространство—этокаталогфайловойсистемы.\nНапример,табличныепространстваможноиспользовать,чтобыразместить\nархивныеданные на медленных носителях,аданные,с которыми идетак-\nтивнаяработа,—набыстрых.\nОдноитожетабличноепространствоможетиспользоватьсяразнымибаза-\nмиданных,аоднабазаданныхможетхранитьданныевнесколькихтаблич-\nныхпространствах.Тоестьлогическаяифизическаяструктурынезависят\nдруготдруга.\nУ каждой базы данных есть так называемое табличное пространство по\nумолчанию, в котором создаются все объекты, если явно не указать иное.\nВэтомжетабличномпространствехранятсяиобъектысистемногокаталога.\nПриинициализациикластерасоздаютсядватабличныхпространства:\npg_default располагается в каталоге PGDATA/base и используется как таб-\nличноепространствопоумолчанию,еслиявноневыбратьдляэтойцели\nдругоепространство;\npg_global располагаетсявкаталогеPGDATA/globalихранитобщиедлявсего\nкластераобъектысистемногокаталога.\n26",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:43.749210"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 28,
    "chapter": null,
    "section": "1.1 Организацияданных",
    "text": "1.1. Организацияданных\nПри создании пользовательского табличного пространства указывается\nпроизвольныйкаталог;PostgreSQLсоздаетнанегосимвольнуюссылкувка-\nталогеPGDATA/pg_tblspc.Вообще,всепутиPostgreSQLотносительныеиот-\nсчитываются откаталогаданных PGDATA.Благодаря этому можно перено-\nситьPGDATAнадругоеместо(конечно,предварительноостановивсервер).\nРисунок сводит воедино базы данных, схемы и табличные пространства.\nЗдесь база данных postgres используеттабличное пространство по умол-\nчанию xyzzy,а база template1 — pg_default.На пересечениитабличных\nпространствисхемнаходятсяразличныеобъектыбазыданных:\npg_global\nобщиеобъектыкластера\npg_default\nxyzzy\npg_catalog public plugh pg_catalog public\npostgres template1\nОтношения\nСамыеважныеобъектыбазыданных—таблицыииндексы—привсехсвоих\nразличияхсхоживтом,чтосостоятизстрок.Длятаблицэтоочевидно,нои\n27",
    "tables": [
      {
        "table_index": 0,
        "rows": 3,
        "cols": 15,
        "content": "|  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T15:59:43.792461"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 29,
    "chapter": null,
    "section": "1.1 Организацияданных",
    "text": "Глава1. Введение\nс.513 вB-деревьяхузлысостоятизстрок,содержащихиндексированныезначения\nиссылкинадругиеузлыилинатабличныестроки.\nЕсть еще некоторое количество объектов, устроенных похожим образом:\nпоследовательности (по сути однострочные таблицы), материализованные\nпредставления(посутитаблицы,которыепомнятзапрос).Аещеестьобыч-\nные представления, которые сами по себе не хранят данные, но во всех\nостальныхсмыслахпохожинатаблицы.\nВсе эти объекты в PostgreSQL называются общим словом отношение (re-\nlation).\nСлово,намойвзгляд,выбранонеудачно,посколькусмешиваеттаблицыбазыданных\nи (настоящие) отношения реляционной теории.Дает о себе знать университетское\nпроисхождениепроектаисклонностьегооснователя,МайклаСтоунбрейкера,вовсем\nвидетьотношения.Воднойизработондажеввелпонятие«упорядоченногоотноше-\nния»(orderedrelation)длятаблицы,вкоторойпорядокстрокзадаетсяиндексом.\nТаблицасистемногокаталогадляотношенийизначальноназываласьpg_relation,\nно довольно скоро, на волне увлечения объектной ориентированностью, ее пере-\nименовали в привычный нам сейчас pg_class.Однако столбцы этой таблицы по-\nпрежнемуимеютпрефиксrel.\nСлои и файлы\nИнформация, связанная с отношением, организована в несколько слоев1\n(forks) разных типов, каждый из них содержит определенный вид данных.\nИзначальнослойпредставленединственнымфайлом.Имяфайласостоитиз\nчисловогоидентификатора(oid),ккоторомуможетбытьдобавленсуффикс,\nсоответствующийтипуслоя.\nФайл постепенно растет,и когда его размер достигает 1 Гбайта,создается\nследующийфайлэтогожеслоя(такиефайлыиногданазываютсегментами).\nПорядковыйномерсегментадобавляетсявконецименифайла.\nОграничениеразмерафайлав1Гбайтвозниклоисторическидляподдерж-\nки различных файловых систем,некоторыеиз которых не умеютработать\n1 postgrespro.ru/docs/postgresql/17/storage-file-layout.\n28",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:43.828141"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 30,
    "chapter": null,
    "section": "1.1 Организацияданных",
    "text": "1.1. Организацияданных\nс файлами большого размера. Ограничение можно изменить при сборке\nPostgreSQL(./configure--with-segsize).\nТаким образом, одному отношению на диске может соответствовать\nнесколькофайлов.Дажедлянебольшойтаблицыбезиндексовихбудетми-\nнимумтри,почислуобязательныхслоев.\nВнутри каталога каждого табличного пространства (кроме pg_global) со-\nздаются подкаталогидля отдельных базданных.Все файлы объектов,при-\nнадлежащиходномутабличномупространствуиоднойбазеданных,будут\nпомещеныводинподкаталог.Этонеобходимоучитывать,потомучтофай-\nловыесистемыобычнонеоченьхорошоработаютсбольшимколичеством\nфайловвкаталоге.\nосновнойслой\n12345.2\n12345.1\n12345 картасвободного\nпространства\n12345_fsm.1\n12345_fsm картавидимости\n12345_vm\nИмеетсянесколькостандартныхтиповслоев.\nОсновнойслой (mainfork)—этособственноданные:тесамыетабличныеили\nиндексные строки. Основной слой существует для любых отношений\n(кромепредставлений,которыенесодержатданных).\nИмена файлов основного слоя состояттолько из числового идентифи-\nкатора(равногозначениюстолбцаrelfilenodeтаблицыpg_class).\nПосмотримдляпримерапутькфайлутаблицы,созданнойвтабличном\nпространствеpg_default:\n29",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:43.894558"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 31,
    "chapter": null,
    "section": "1.1 Организацияданных",
    "text": "Глава1. Введение\n=> CREATE UNLOGGED TABLE t(\na integer,\nb numeric,\nc text,\nd json\n);\n=> INSERT INTO t VALUES (1, 2.0, 'foo', '{}');\n=> SELECT pg_relation_filepath('t');\npg_relation_filepath\n−−−−−−−−−−−−−−−−−−−−−−\nbase/16384/16385\n(1 row)\nКаталогbase соответствуеттабличному пространству pg_default,сле-\nдующийподкаталог—базеданных,иужевнемнаходитсяинтересую-\nщийнасфайл:\n=> SELECT oid FROM pg_database WHERE datname = 'internals';\noid\n−−−−−−−\n16384\n(1 row)\n=> SELECT relfilenode FROM pg_class WHERE relname = 't';\nrelfilenode\n−−−−−−−−−−−−−\n16385\n(1 row)\nВотсоответствующийфайлвфайловойсистеме:\n=> SELECT size\nFROM pg_stat_file('/usr/local/pgsql/data/base/16384/16385');\nsize\n−−−−−−\n8192\n(1 row)\nСлойинициализации (init fork)1 существует только для нежурналируемых\nтаблиц(созданныхсуказаниемUNLOGGED)иихиндексов.Такиеобъекты\n1 postgrespro.ru/docs/postgresql/17/storage-init.\n30",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:43.918309"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 32,
    "chapter": null,
    "section": "1.1 Организацияданных",
    "text": "1.1. Организацияданных\nничемнеотличаютсяотобычных,крометого,чтодействияснимине\nзаписываютсявжурналпредзаписи.Засчетэтогоработаснимипроис- с.201\nходитбыстрее,новслучаесбояневозможновосстановитьданныевсо-\nгласованномсостоянии.ПоэтомупривосстановленииPostgreSQLпрос-\nтоудаляетвсеслоитакихобъектовизаписываетслойинициализации\nнаместоосновногослоя.Врезультатеполучается«пустышка».\nТаблицаt создананежурналируемой,поэтомуунееестьслойинициа-\nлизации.Онимееттакоежеимя,какиосновнойслой,носсуффиксом\n_init:\n=> SELECT size\nFROM pg_stat_file('/usr/local/pgsql/data/base/16384/16385_init');\nsize\n−−−−−−\n0\n(1 row)\nКартасвободногопространства (freespacemap)1—слой,вкоторомотслежи-\nваетсяпримерныйобъемсвободногоместавнутристраниц.Этотобъем\nпостоянноменяется:придобавленииновыхверсийстрокуменьшается,\nприочистке—увеличивается.Картасвободногопространстваиспользу-\nетсяпривставкеновыхверсийстрок,чтобыбыстронайтиподходящую\nстраницу,накоторуюпоместятсядобавляемыеданные.\nФайлы,относящиесяккартесвободногопространства,имеютсуффикс\n_fsm.Нопоявляютсяонинесразу,атолькопринеобходимости.Самый\nпростойспособдобитьсяэтого—выполнитьочисткутаблицы: с.133\n=> VACUUM t;\n=> SELECT size\nFROM pg_stat_file('/usr/local/pgsql/data/base/16384/16385_fsm');\nsize\n−−−−−−−\n24576\n(1 row)\n1 postgrespro.ru/docs/postgresql/17/storage-fsm;\nbackend/storage/freespace/README.\n31",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:43.948828"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 33,
    "chapter": null,
    "section": "1.1 Организацияданных",
    "text": "Глава1. Введение\nДляускоренияпоискакартасвободногопространстваорганизованакак\nдеревоизанимаетминимумтристраницы(отсюдаиразмерфайласлоя\nдляпочтипустойтаблицы).\nКарта свободного пространства существуетнетолькодлятаблиц,но и\nдляиндексов.Нопосколькуиндекснуюстрокунельзядобавитьнапро-\nизвольнуюстраницу(например,дляB-дереваместовставкиопределя-\nется порядком сортировки), отслеживаются только те страницы, кото-\nрыебылиполностьюочищеныимогутбытьсновазадействованывин-\nдекснойструктуре.\nКартавидимости (visibilitymap)1—слой,которыйпозволяетбыстроопреде-\nлить,требуетлистраницаочисткиилизаморозки.Дляэтогонакаждую\nтабличнуюстраницувэтомслоеотведенодвабита.\nОдним битом отмечены страницы, которые содержат только актуаль-\nс.131 ные версии строк. Процесс очистки пропускает такие страницы, по-\nсколькувнихнечегоочищать.Крометого,когдатранзакцияпытается\nпрочитатьстрокуизтакойстраницы,можнонепроверятьеевидимость,\nс.409 аэтопозволяетиспользоватьсканированиетолькоиндекса.\nВторойбитотмечаетстраницы,накоторыхвсеверсиистрокзамороже-\nс.150 ны.Этучастьслояябудуназыватькартойзаморозки.\nФайлы карты видимости имеют суффикс _vm. Обычно они самые\nнебольшиепоразмеру:\n=> SELECT size\nFROM pg_stat_file('/usr/local/pgsql/data/base/16384/16385_vm');\nsize\n−−−−−−\n8192\n(1 row)\nс.89 Картавидимостисуществуетдлятаблиц,нонедляиндексов.\n1 postgrespro.ru/docs/postgresql/17/storage-vm.\n32",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:43.978672"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 34,
    "chapter": null,
    "section": "1.1 Организацияданных",
    "text": "1.1. Организацияданных\nСтраницы\nДля удобства организации ввода-вывода файлы логически поделены на\nстраницы (или блоки)—это минимальный объем данных,который считы- с.75\nваетсяилизаписывается.Соответственно,имногиевнутренниеалгоритмы\nPostgreSQLориентированынаработусостраницами.\nОбычно страница имеет размер 8 Кбайт. Его можно поменять в некото-\nрых пределах (до 32 Кбайт), но только при сборке (./configure --with-\nblocksize),и,как правило,никто этим не занимается.Собранный и запу-\nщенныйэкземплярможетработатьсостраницамитолькоодногоразмера—\nсоздатьтабличныепространствасразноразмернымистраницаминельзя.\nНезависимооттого,ккакомуслоюпринадлежатфайлы,онииспользуются\nсерверомпримерноодинаково.Страницысначалапомещаютсявбуферный\nкеш(гдеихмогутчитатьиизменятьпроцессы),азатемпринеобходимости с.179\nвытесняютсяобратнонадиск.\nTOAST\nКаждаястрокадолжнапомещатьсяцеликомнаоднустраницу:нетспособа\n«продолжить» строку на следующей странице. Для длинных строк исполь-\nзуетсятехнология,названнаяTOAST1(TheOversizedAttributesStorageTech-\nnique).\nTOAST подразумевает несколько стратегий. Длинные значения атрибутов\nможноотправитьвотдельнуюслужебнуютаблицу,предварительнонарезав\nнанебольшиефрагменты-«тосты».Другойвариант—сжатьдлинноезначе-\nниетак,чтобыстрокавсе-такипоместиласьнаоднустраницу.Аможноито\nидругое:сначаласжать,аужепотомнарезатьиотправить.\nЕсли основная таблица содержит потенциально длинные атрибуты, для\nнее сразу же создается отдельная toast-таблица (одна для всех атрибутов).\nНапример, если в таблице есть столбец типа numeric или text, toast-таб-\nлицабудетсоздана,дажеесливтакомстолбценикогданебудутхраниться\nдлинныезначения.\n1 postgrespro.ru/docs/postgresql/17/storage-toast;\ninclude/access/heaptoast.h.\n33",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.011643"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 35,
    "chapter": null,
    "section": "1.1 Организацияданных",
    "text": "Глава1. Введение\nДля индексов технология TOAST предлагает только сжатие; вынесение ат-\nрибутоввотдельнуютаблицунеподдерживается.Этонакладываетограни-\nчениенаразмериндексируемыхключей(какэтоограничениереализуется,\nс.384 зависитотклассаоператоров).\nОбычно стратегии определяются типами столбцов. Посмотреть стратегии\nпроще всего командой \\d+ в psql,но для сокращения вывода я использую\nзапросксистемномукаталогу:\n=> SELECT attname, atttypid::regtype,\nCASE attstorage\nWHEN 'p' THEN 'plain'\nWHEN 'e' THEN 'external'\nWHEN 'm' THEN 'main'\nWHEN 'x' THEN 'extended'\nEND AS storage\nFROM pg_attribute\nWHERE attrelid = 't'::regclass AND attnum > 0;\nattname | atttypid | storage\n−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−\na | integer | plain\nb | numeric | main\nc | text | extended\nd | json | extended\n(4 rows)\nСтратегиисостоятвследующем:\nplain —TOAST не используется (стратегия применяетсядля заведомо «ко-\nротких»типовданных,какinteger);\nextended — допускается как сжатие, так и хранение в отдельной toast-\nтаблице;\nexternal —длинныезначенияхранятсявtoast-таблиценесжатыми;\nmain —длинныезначениявпервуюочередьсжимаются,авtoast-таблицу\nпопадают,толькоеслисжатиенепомогло.\nВ общих чертах алгоритм выглядитследующим образом1.PostgreSQL стре-\nмится к тому, чтобы на странице помещалось хотя бы четыре строки. По-\nэтому,еслиразмерстрокипревышаетчетвертуючастьстраницызавычетом\n1 backend/access/heap/heaptoast.c.\n34",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.043658"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 36,
    "chapter": null,
    "section": "1.1 Организацияданных",
    "text": "1.1. Организацияданных\nзаголовка(длястраницыстандартногоразмераэтооколо2000байт),кчасти\nзначенийнеобходимоприменитьTOAST.Действуемвпорядке,описанном\nниже,ипрекращаем,кактолькодлинастрокиперестаетпревышатьпорого-\nвоезначение.\n1. Сначала перебираем атрибуты состратегиями external и extended,дви-\nгаясьотсамыхдлинныхкболеекоротким.Extended-атрибутысжимают-\nся,иеслипослеэтогозначение(самопосебе,безучетадругихатрибу-\nтов)превосходитчетвертьстраницы,оносразужеотправляетсявtoast-\nтаблицу. External-атрибуты обрабатываются так же, но не сжимаются.\n2. Если после первого прохода строка все еще не помещается, по одно-\nму отправляем в toast-таблицу оставшиеся атрибуты со стратегиями\nexternalиextended.\n3. Если и это не помогло, пытаемся сжать атрибуты со стратегией main,\nоставляяихприэтомвтабличнойстранице.\n4. Если строка все равно недостаточно коротка, отправляем в toast-таб-\nлицуmain-атрибуты.\nПороговое значение составляетвсете же 2000 байт,но можетпереопреде- v.11\nлятьсяпараметромхраненияtoast_tuple_targetнауровнетаблицы.\nИногда может оказаться полезным изменить стратегию для некоторых\nстолбцов.Если заранее известно,что данные в столбце не сжимаются (на-\nпример,встолбцехранятсяJPEG-изображения),можноустановитьдлянего\nстратегию external — это позволит сэкономить на бесполезных попытках\nсжатия.Изменитьстратегию можно как при созданиитаблицы (предложе- v.16\nниеSTORAGEкомандыCREATETABLE),такивпоследствии:\n=> ALTER TABLE t ALTER COLUMN d SET STORAGE external;\nПовторивзапрос,получим:\nattname | atttypid | storage\n−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−\na | integer | plain\nb | numeric | main\nc | text | extended\nd | json | external\n(4 rows)\n35",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.080370"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 37,
    "chapter": null,
    "section": "1.1 Организацияданных",
    "text": "Глава1. Введение\nv.15 Для сжатия доступны два алгоритма: традиционный PGLZ и более совре-\nменныйLZ4(обаявляютсяразновидностямиалгоритмасловарногосжатия\nЛемпеля—Зива). По умолчанию сжатие выполняется алгоритмом, указан-\npglz нымвпараметреdefault_toast_compression;значениеможноустановитьдля\nотдельных столбцов в предложении COMPRESSION. Эталонные тесты пока-\nзывают,чтоприсходномсPGLZуровнесжатияLZ4тратитменьшересурсов\nпроцессора.\nToast-таблицы располагаются в отдельной схеме pg_toast, не входящей\nвпутьпоиска,ипоэтомуобычноневидны.Длявременныхтаблицисполь-\nзуетсясхемаpg_toast_temp_Nаналогичнообычнойpg_temp_N.\nКонечно,при желании всегда можно подглядетьза внутренней механикой\nпроцесса.Скажем,втаблицеtестьтрипотенциальнодлинныхатрибута,по-\nэтомуtoast-таблицаобязанабыть.Вотона:\n=> SELECT relnamespace::regnamespace, relname\nFROM pg_class WHERE oid = (\nSELECT reltoastrelid FROM pg_class WHERE relname = 't'\n);\nrelnamespace | relname\n−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−\npg_toast | pg_toast_16385\n(1 row)\n=> \\d+ pg_toast.pg_toast_16385\nTOAST table \"pg_toast.pg_toast_16385\"\nColumn | Type | Storage\n−−−−−−−−−−−−+−−−−−−−−−+−−−−−−−−−\nchunk_id | oid | plain\nchunk_seq | integer | plain\nchunk_data | bytea | plain\nOwning table: \"public.t\"\nIndexes:\n\"pg_toast_16385_index\" PRIMARY KEY, btree (chunk_id, chunk_seq)\nAccess method: heap\nЛогично,чтодля«тостов»,накоторыенарезаетсястрока,применяетсястра-\nтегияplain:TOASTвторогоуровнянесуществует.\nВместесtoast-таблицейвтойжесхемесоздаетсяииндекс,которыйвсегда\nиспользуетсядлядоступакфрагментамзначений.Имяиндексавидноввы-\nводекоманды,ноегоможнонайтиизапросом:\n36",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.118145"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 38,
    "chapter": null,
    "section": "1.1 Организацияданных",
    "text": "1.1. Организацияданных\n=> SELECT indexrelid::regclass FROM pg_index\nWHERE indrelid = (\nSELECT oid FROM pg_class WHERE relname = 'pg_toast_16385'\n);\nindexrelid\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\npg_toast.pg_toast_16385_index\n(1 row)\n=> \\d pg_toast.pg_toast_16385_index\nUnlogged index \"pg_toast.pg_toast_16385_index\"\nColumn | Type | Key? | Definition\n−−−−−−−−−−−+−−−−−−−−−+−−−−−−+−−−−−−−−−−−−\nchunk_id | oid | yes | chunk_id\nchunk_seq | integer | yes | chunk_seq\nprimary key, btree, for table \"pg_toast.pg_toast_16385\"\nТакимобразом,toast-таблицаувеличиваетминимальноечислофайлов,«об-\nслуживающих» таблицу, до восьми: три слоя основной таблицы, три слоя\ntoast-таблицыидваслояtoast-индекса.\nСтолбецcиспользуетстратегиюextended,значениявнембудутсжиматься:\n=> UPDATE t SET c = repeat('A',5000);\n=> SELECT * FROM pg_toast.pg_toast_16385;\nchunk_id | chunk_seq | chunk_data\n−−−−−−−−−−+−−−−−−−−−−−+−−−−−−−−−−−−\n(0 rows)\nВtoast-таблиценичегонет:повторяющиесясимволысжалисьалгоритмом\nPGLZ,ипослеэтогозначениепоместилосьвобычнойтабличнойстранице.\nАтеперьсоставимзначениеизслучайныхсимволов:\n=> UPDATE t SET c = (\nSELECT string_agg( chr(trunc(65+random()*26)::integer), '')\nFROM generate_series(1,5000)\n)\nRETURNING left(c,10) || '...' || right(c,10);\n?column?\n−−−−−−−−−−−−−−−−−−−−−−−−−\nFREBELVYJE...VVIREWXHNK\n(1 row)\nUPDATE 1\n37",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.153031"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 39,
    "chapter": null,
    "section": "1.1 Организацияданных",
    "text": "Глава1. Введение\nТакую последовательность сжать не получается.В табличную строку запи-\nсываетсяидентификаторchunk_id:\n=> SELECT pg_column_toast_chunk_id(c) -- начиная с v.17\nFROM t;\npg_column_toast_chunk_id\n−−−−−−−−−−−−−−−−−−−−−−−−−−\n16390\n(1 row)\nАсамозначениепопадаетвtoast-таблицу:\n=> SELECT chunk_id,\nchunk_seq,\nlength(chunk_data),\nleft(encode(chunk_data,'escape')::text, 10) || '...' ||\nright(encode(chunk_data,'escape')::text, 10)\nFROM pg_toast.pg_toast_16385;\nchunk_id | chunk_seq | length | ?column?\n−−−−−−−−−−+−−−−−−−−−−−+−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−\n16390 | 0 | 1996 | FREBELVYJE...VOFJHSIZGM\n16390 | 1 | 1996 | VNXXJAOZQE...EEEMRLUGLJ\n16390 | 2 | 1008 | IOGNFNTZHM...VVIREWXHNK\n(3 rows)\nВидно,чтоданныенарезанынафрагменты.Размерфрагментоввыбирается\nтак,чтобынастраницеtoast-таблицыпомещалосьчетырестроки.Отверсии\nк версии это значение можетнемного меняться в зависимости отразмера\nзаголовкастраницы.\nПри обращении к «длинному» атрибуту PostgreSQL автоматически, про-\nзрачнодляприложения,восстанавливаетисходноезначениеивозвращает\nегоклиенту.Еслижетакиеатрибутынеучаствуютвзапросе,тоtoast-таблица\nне читается.Это одна из причин не использовать «звездочку» в производ-\nственномкоде.\nv.13 Есликлиентзапрашиваетначальнуючастьдлинногозначения,тобудутпро-\nчитанытольконеобходимыефрагменты,втомчислеивслучае,когдазна-\nчениехранитсявсжатомвиде.\nТем не менее и на сжатие с нарезкой, и на последующее восстановле-\nниетратитсядовольномногоресурсов.Поэтомухранитьобъемныеданные\nв PostgreSQL — не лучшая идея, особенно если они активно используются\n38",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.187391"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 40,
    "chapter": null,
    "section": "1.2 Процессы и память",
    "text": "1.2. Процессыипамять\nи при этом для них не требуется транзакционная логика (как пример: от-\nсканированные оригиналы бухгалтерских документов). Потенциально бо-\nлее выгодная альтернатива — хранить такие данные в файловой системе,\nа в базе данных держать только имена соответствующих файлов. Правда,\nтогдаСУБДнесможетобеспечиватьсогласованностьданных.\nЗатраты на распаковкузначений,обработанныхTOAST, позволяетоценитькоманда v.17\nEXPLAINспараметрамиanalyzeиserialize.\n1.2. Процессы и память\nЭкземплярсервераPostgreSQLсостоитиз несколькихвзаимодействующих\nпроцессов.\nВпервуюочередьпристартесерверазапускаетсяпроцессpostgres,традици-\nонноназываемыйpostmaster.Postmasterзапускаетвсеостальныепроцессы\n(вUnix-подобныхсистемахдляэтогоиспользуетсясистемныйвызовfork)\nи «присматривает» за ними—если какой-нибудьпроцесс завершится ава-\nрийно,postmaster перезапустит его (или весь сервер,если сочтет,что про-\nцессмогповредитьобщиеданные).\nПроцесснаямодельприменяетсявPostgreSQLссамогоначалапроектаиз-засвоей\nпростоты,ивсеэтовремянепрекращаютсядискуссииопереходекиспользованию\nпотоков.\nУ текущей модели есть ряд недостатков: статически выделяемая общая память не\nпозволяетна летуменятьразмертакихструктур,как буферный кеш; параллельные\nалгоритмы сложны в реализации и менее эффективны,чем могли бы быть; сеансы\nжестко привязаны к процессам.Использование потоков выглядит многообещающе,\nхотяичреватосложностямисизолированностью,совместимостьюcоперационными\nсистемами,управлениемресурсами.Неговоряужеотом,чтопереходпотребуетра-\nдикальныхизмененийвкодеигодыработы.Покапобеждаетконсервативныйвзгляд,\nивближайшеевремяникакихизмененийнепредвидится.\nРаботу сервера обеспечивает ряд служебных процессов. Основные из них:\nstartup восстанавливаетсистемупослесбоев; с.213\nautovacuum очищаеттаблицыииндексыотнеактуальныхданных; с.134\n39",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.224520"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 41,
    "chapter": null,
    "section": "1.2 Процессы и память",
    "text": "Глава1. Введение\nс.226 walwriter записываетнадискжурнальныезаписи;\nс.209 checkpointer выполняетконтрольнуюточку;\nс.216 writer записываетгрязныестраницынадиск;\nwalsender передаетжурнальныезаписинареплику;\nwalreceiver принимаетжурнальныезаписинареплике.\nНекоторые из этих процессов завершаются после выполнения своей зада-\nчи,другие работают постоянно в фоновом режиме,а какие-то могут быть\nотключены.\nКаждый процесс управляется конфигурационными параметрами,иногда десятками\nпараметров.Чтобы осмысленно выполнятьнастройкусервера,нужно хорошо пред-\nставлятьеговнутреннееустройство.Ноизобщихсоображенийможновыбратьлишь\nначальные адекватные значения параметров,которые затем потребуется уточнять,\nполучаяобратнуюсвязьотмониторинга.\nЧтобы процессы могли обмениваться информацией, postmaster выделяет\nобщуюпамять,котораядоступнавсемпроцессам.\nИз-за того,что диски (особенно HDD,но и SSD тоже) работают значитель-\nс.179 но медленнее, чем оперативная память, применяется кеширование: в об-\nщей области оперативной памяти отводится место под недавно прочитан-\nные страницы в надежде, что они еще не раз понадобятся и можно будет\nсэкономить на повторном обращении к диску.Измененные данные также\nзаписываютсянадискнесразу,ачерезнекотороевремя.\nБуферныйкешзанимаетбóльшуючастьобщейпамяти.Внейжерасполага-\nютсяидругиебуферы,которыеиспользуютсясерверомдляускорениярабо-\nтысдиском.\nСвой кеш имеется и у операционной системы. PostgreSQL не использует\n(почти) прямой ввод-вывод в обход механизмов операционной системы,\nпоэтомукешированиеполучаетсядвойным.\nПри сбое (например, при аварийном отключении питания или крахе опе-\nрационнойсистемы)содержимоеоперативнойпамяти,включаябуферный\nкеш, пропадает. На диске остаются файлы, страницы которых записаны\n40",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.260112"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 42,
    "chapter": null,
    "section": "1.3 Клиентыиклиент-серверныйпротокол",
    "text": "1.3. Клиентыиклиент-серверныйпротокол\nЭкземпляр\nPostgreSQL\npostmaster\nк пк пл рк пл ри л и ри ие и л ие лн е о лн от н ж от жс т жс ек с ек н ео к но и не о ие е ие ее bba bac ack cke ken end ndd фоновыепроцессы\nобщаяпамять\nбуферныйкеш\nОперационная\nсистема\nкеш\nвразныемоментывремени.Чтобыиметьвозможностьвосстановитьсогла-\nсованностьданных,впроцессеработыPostgreSQLведетжурналпредзаписи\n(WAL),позволяющийпринеобходимостивыполнитьпотерянныеоперации с.201\nповторно.\n1.3. Клиенты и клиент-серверный протокол\nЕщеодназадачапроцессаpostmaster—слушатьвходящиесоединения.При\nпоявлении нового клиента postmaster порождаетдля него обслуживающий\nпроцесс1 (backend).Клиентустанавливаетсоединение и начинаетсеанс об-\nщениясосвоимсервернымпроцессом.Сеанспродолжаетсядоотключения\nклиентаилиразрывасвязи.\n1 backend/tcop/postgres.c,функцияPostgresMain.\n41",
    "tables": [
      {
        "table_index": 0,
        "rows": 2,
        "cols": 4,
        "content": "фоно | выепр | оц | ессы\n |  |  |"
      },
      {
        "table_index": 1,
        "rows": 1,
        "cols": 8,
        "content": "|  |  |  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T15:59:44.290530"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 43,
    "chapter": null,
    "section": "1.3 Клиентыиклиент-серверныйпротокол",
    "text": "Глава1. Введение\nДлякаждогоклиентанасерверепорождаетсясобственныйобслуживающий\nпроцесс.Большоеколичествоподключенийможетвызыватьпроблемы:\n• Каждому процессу требуется оперативная память для хранения кеша\nс.327 системного каталога, подготовленных запросов, промежуточных ре-\nс.326 зультатов при выполнении запросов и других данных.Чем больше со-\nединенийоткрыто,тембольшедолжнобытьдоступнойпамяти.\n• Если соединения выполняются часто, а сеансы при этом короткие (то\nестьклиентвыполняетодин небольшой запрос и отключается),непоз-\nволительно много ресурсов будеттратиться на установление соедине-\nния, порождение нового процесса и ненужное заполнение локальных\nкешей.\n• Чембольшезапущенопроцессов,тембольшевременитребуетсянапро-\nс.99 смотрихсписка,аэтаоперациявыполняетсяоченьчасто.Врезультате\nсувеличениемчислаклиентовпроизводительностьможетпадать.\nВ таких случаях используют пул соединений, чтобы ограничить число об-\nслуживающих процессов. PostgreSQL не имеет встроенного пула соедине-\nний, поэтому приходится применять сторонние решения: менеджеры пу-\nлов,встроенныевсерверприложений,иливнешниепрограммы(такиекак\nPgBouncer1 или Odyssey2). При этом, как правило, один процесс на серве-\nре поочередно выполняет транзакции разных клиентов. Это накладывает\nопределенныеограничениянаразработкуприложений,позволяяиспользо-\nватьсредства,которыелокализованывпределахтранзакции,нонесеанса.\nЧтобыклиентисерверпонималидругдруга,онидолжныиспользоватьодин\nитотжепротоколвзаимодействия3.Обычнодляреализациипротоколаис-\nпользуютштатную библиотеку libpq,хотя встречаются и независимые реа-\nлизации.\nГоворя в самых общих чертах, протокол позволяет клиенту подключиться\nксерверуивыполнятьSQL-запросы.\n1 pgbouncer.org.\n2 yandex.ru/dev/odyssey.\n3 postgrespro.ru/docs/postgresql/17/protocol.\n42",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.323921"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 44,
    "chapter": null,
    "section": "1.3 Клиентыиклиент-серверныйпротокол",
    "text": "1.3. Клиентыиклиент-серверныйпротокол\nПодключениевсегдавыполняетсяподопределеннойролью(пользователем)\nи к конкретной базе данных. Несмотря на то что сервер работает с клас-\nтером базданных,для использования в приложении сразу нескольких баз\nпридетсявыполнитьотдельноеподключениеккаждойизних.Приподклю-\nчениивыполняетсяаутентификация:обслуживающийпроцессудостоверя-\nется,чтопользовательявляетсятем,закогосебявыдает(например,спросив\nпароль),и проверяетполномочия пользователя на подключение к серверу\nиквыбраннойбазеданных.\nSQL-запросыпередаютсяобслуживающемупроцессувтекстовомвиде.Про-\nцессразбираеттекст,оптимизируетзапрос,выполняетегоивозвращаетре-\nзультатклиенту.\n43",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.337537"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 48,
    "chapter": null,
    "section": "2.1 Согласованность",
    "text": "2\nИзоляция\n2.1. Согласованность\nВажная особенность реляционных СУБД — обеспечение согласованности\n(consistency),тоестькорректностиданных.\nИзвестно,чтонауровнебазыданныхможносоздаватьограниченияцелост-\nности(integrityconstraints),такиекакNOTNULLилиUNIQUE.СУБДследитза\nтем, чтобы данные никогда не нарушали эти ограничения,то есть остава-\nлисьцелостными.\nЕсли бы все ограничения были сформулированы на уровне базы данных,\nсогласованность была бы гарантирована. Но некоторые условия слишком\nсложныдляэтого,напримерохватываютсразунесколькотаблиц.Идажеес-\nлиограничение в принципе можнобыло бы определитьв базеданных,но\nизкаких-тосоображенийононеопределено,этонеозначает,чтоегоможно\nнарушать.\nИтак,согласованностьстроже,чем целостность,но что конкретно под ней\nпонимается,СУБДнезнает.Еслиприложениенарушитсогласованность,не\nнарушая целостности, у СУБД не будет способа узнать об этом. Получает-\nся,чтогарантомсогласованностивыступаетприложение,иостаетсяверить,\nчтоононаписанокорректноиникогданеошибается.\nНо если приложение выполняет только корректные последовательности\nоператоров,вчемтогдарольСУБД?\nВо-первых, корректная последовательность операторов может временно\nнарушатьсогласованностьданных,иэто,какнистранно,нормально.\n47",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.363536"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 49,
    "chapter": null,
    "section": "2.1 Согласованность",
    "text": "Глава2. Изоляция\nЗаезженный,нопонятныйпримерсостоитвпереводесредствсодногосче-\nтанадругой.Правилосогласованностиможетзвучатьтак:переводникогдане\nменяетобщейсуммыденегнасчетах.Такоеправилодовольнотрудно(хотяи\nвозможно)записатьнаSQLввидеограниченияцелостности,такчтопусть\nоносуществуетнауровнеприложенияиостаетсяневидимымдляСУБД.Пе-\nреводсостоитиздвухопераций:перваяуменьшаетсредстванаодномсчете,\nвторая — увеличивает на другом. Первая операция нарушает согласован-\nностьданных,вторая—восстанавливает.\nЕслиперваяоперациявыполнится,авторая—попричинекакого-тосбоя—\nнет, то согласованность нарушится. А это недопустимо. Ценой неимовер-\nныхусилийтакиеситуацииможнообрабатыватьнауровнеприложения,но,\nксчастью,этонетребуется.ЗадачуполностьюрешаетСУБД,еслизнает,что\nдвеоперациисоставляютнеделимоецелое,тоестьтранзакцию.\nНо есть и второй, более тонкий момент. Транзакции, абсолютно правиль-\nныесамипосебе,приодновременномвыполнениимогутначатьработать\nнекорректно.Это происходитиз-затого,что перемешивается порядок вы-\nполненияоперацийразныхтранзакций.ЕслибыСУБДсначалавыполняла\nвсеоперацииоднойтранзакции,атолькопотом—всеоперациидругой,та-\nкойпроблемыневозникалобы,нобезраспараллеливанияработыпроизво-\nдительностьбылабыневообразимонизкой.\nДействительно одновременно транзакции работают в системах, где это позволяет\nаппаратура: многоядерный процессор,дисковый массив.Но всете же рассуждения\nсправедливыидлясервера,которыйвыполняеткомандыпоследовательноврежиме\nразделения времени.Иногда для обобщения используют термин конкурентное вы-\nполнение.\nСитуации,когдакорректныетранзакциинекорректноработаютвместе,на-\nзываютсяаномалиямиодновременноговыполнения.\nПростой пример: если приложение хочетполучить из базы согласованные\nданные,тоонокакминимумнедолжновидетьизменениядругихнезафик-\nсированныхтранзакций.Иначе(есликакая-либотранзакциябудетотмене-\nна)можноувидетьсостояние,вкоторомбазаданныхникогданенаходилась.\nТакаяаномалияназываетсягрязнымчтением.Естьмножестводругих,более\nсложныханомалий.\n48",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.406459"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 50,
    "chapter": null,
    "section": "2.2 УровниизоляцииианомалиивстандартеSQL",
    "text": "2.2. УровниизоляцииианомалиивстандартеSQL\nРольСУБДсостоитвтом,чтобывыполнятьтранзакциипараллельноипри\nэтомгарантировать,чторезультаттакогоодновременноговыполнениябу-\nдет совпадать с результатом одного из возможных последовательных вы-\nполнений.Инымисловами—изолироватьтранзакциидруготдруга,устра-\nнивлюбыевозможныеаномалии.\nТакимобразом,транзакциейназываетсямножествоопераций,которыепе-\nреводятбазуданныхизодногокорректногосостояниявдругоекорректное\nсостояние(согласованность)приусловии,чтотранзакциявыполненаполно-\nстью (атомарность) и без помех со стороныдругихтранзакций (изоляция).\nЭто определение объединяет требования, стоящие за первыми тремя бук-\nвами акронима ACID: Atomicity, Consistency, Isolation. Они настолько тес-\nно связаны друг с другом, что рассматривать их по отдельности просто\nнет смысла. На самом деле сложно отделить и требование долговечности\n(Durability),ведьприкрахесистемывнейостаютсяизменениянезафикси- с.201\nрованныхтранзакций,аснимиприходитсячто-тоделать,чтобывосстано-\nвитьсогласованностьданных.\nПолучается, что СУБД помогает приложению поддерживать согласован-\nность,учитываясоставтранзакции,нонеимеяприэтомпонятияоподра-\nзумеваемыхправилахсогласованности.\nК сожалению, реализация полной изоляции — технически сложная зада-\nча,сопряженнаясуменьшениемпроизводительностисистемы.Поэтомуна\nпрактикепочтивсегдаприменяетсяослабленнаяизоляция,котораяпредот-\nвращает некоторые,но не все аномалии.А это означает,что часть работы\nпообеспечениюсогласованностиданныхложитсянаприложение.Именно\nпоэтомуоченьважнопонимать,какойуровеньизоляциииспользуетсявси-\nстеме,какиегарантииондает,акакие—нет,икаквтакихусловияхписать\nкорректныйкод.\n2.2. Уровни изоляции и аномалии в стандарте SQL\nСтандарт SQL описывает четыре уровня изоляции1. Эти уровни определя-\nются перечислением аномалий,которые допускаются или не допускаются\n1 postgrespro.ru/docs/postgresql/17/transaction-iso.\n49",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.443041"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 51,
    "chapter": null,
    "section": "2.2 УровниизоляцииианомалиивстандартеSQL",
    "text": "Глава2. Изоляция\nприодновременномвыполнениитранзакций.Поэтомуразговоробуровнях\nпридетсяначатьсаномалий.\nСтоитиметьввиду,чтостандарт—некоетеоретическоепостроение,кото-\nроевлияетнапрактику,носкоторымпрактикавтожевремясильнорасхо-\nдится.Поэтомувсепримерыздесьумозрительные.Онибудутиспользовать\nоперации над счетами клиентов: это довольно наглядно, хотя, надо при-\nзнать,неимеетнималейшегоотношенияктому,какбанковскиеоперации\nустроенывдействительности.\nИнтересно,чтосостандартомSQLрасходитсяинастоящаятеориябаздан-\nных1,развившаясяужепослетого,какстандартбылпринят,апрактикауспе-\nлауйтивперед.\nПотерянное обновление\nАномалия потерянного обновления (lost update) возникает, когда две тран-\nзакции читаютодну иту же строкутаблицы,затем одна из них обновляет\nэтустроку,послечеговтораяобновляетэтужестроку,неучитываяизмене-\nний,сделанныхпервойтранзакцией.\nНапример,дветранзакциисобираютсяувеличитьсуммунаодномитомже\nсчетена100₽.Перваятранзакциячитаеттекущеезначение(1000₽),затем\nвтораятранзакциячитаеттожесамоезначение.Перваяувеличиваетсумму\n(получается1100₽)изаписываетвбазуэтоновоезначение.Втораяпоступа-\nеттакже:получаеттеже1100₽изаписываетих.Врезультатеклиентпотерял\n100₽.\nПотерянное обновление не допускается стандартом ни на одном уровне\nизоляции.\nГрязное чтение и Read Uncommitted\nАномалия грязного чтения (dirty read) возникает,когда транзакция читает\nещенезафиксированныеизменения,сделанныедругойтранзакцией.\n1 postgrespro.ru/education/books/dbtech.\n50",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.639267"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 52,
    "chapter": null,
    "section": "2.2 УровниизоляцииианомалиивстандартеSQL",
    "text": "2.2. УровниизоляцииианомалиивстандартеSQL\nНапример,перваятранзакция переводит 100 ₽ на пустой счет клиента,но\nне фиксирует изменение. Другая транзакция читает состояние счета (об-\nновленное,нонезафиксированное)ипозволяетклиентуснятьналичные—\nнесмотрянато,чтоперваятранзакцияпрерываетсяиотменяетсвоиизме-\nнения,такчтоникакихденегнасчетеклиентанет.\nГрязноечтениедопускаетсястандартомнауровнеReadUncommitted.\nНеповторяющееся чтение и Read Committed\nАномалиянеповторяющегосячтения(non-repeatableread)возникает,когда\nтранзакциячитаетоднуитужестрокудвараза,авпромежуткемеждучте-\nниями вторая транзакция изменяет (или удаляет) эту строку и фиксирует\nизменения.Тогдаперваятранзакцияполучитразныерезультаты.\nНапример,пусть правило согласованности запрещает отрицательные сум-\nмынасчетахклиентов.Перваятранзакциясобираетсяуменьшитьсуммуна\nсчете на 100 ₽. Она проверяет текущее значение, получает 1000 ₽ и реша-\nет, что уменьшение возможно. В это время вторая транзакция уменьшает\nсуммунасчетедонуляификсируетизменения.Еслибытеперьперваятран-\nзакцияповторнопровериласумму,онаполучилабы0₽(ноонаужеприняла\nрешениеуменьшитьзначение,исчет«уходитвминус»).\nНеповторяющееся чтениедопускается стандартом на уровнях Read Uncom-\nmittedиReadCommitted.\nФантомное чтение и Repeatable Read\nАномалия фантомного чтения (phantom read) возникает, когда одна тран-\nзакциядваразачитаетнаборстрокпоодинаковомуусловию,авпромежут-\nкемеждучтениямидругаятранзакциядобавляетстроки,удовлетворяющие\nэтому условию,и фиксируетизменения.Тогда перваятранзакция получит\nразныенаборыстрок.\nНапример,пустьправилосогласованностизапрещаетклиентуиметьболее\nтрехсчетов.Перваятранзакциясобираетсяоткрытьновыйсчет,проверяет\nихтекущееколичество(скажем,два)ирешает,чтооткрытиевозможно.Вэто\n51",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.673129"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 53,
    "chapter": null,
    "section": "2.2 УровниизоляцииианомалиивстандартеSQL",
    "text": "Глава2. Изоляция\nвремявтораятранзакциятожеоткрываетклиентуновыйсчетификсирует\nизменения.Если бытеперь перваятранзакция перепроверила количество,\nона получила бы три (но она уже выполняет открытие еще одного счета,\nиуклиентаихоказываетсячетыре).\nФантомное чтение допускается стандартом на уровнях Read Uncommitted,\nReadCommittedиRepeatableRead.\nОтсутствие аномалий и Serializable\nСтандартопределяетиуровень,накоторомнедопускаютсяникакиеанома-\nлии,—Serializable.Иэтосовсемнетожесамое,чтозапретнапотерянноеоб-\nновлениеинагрязное,неповторяющеесяифантомноечтение.Деловтом,\nчтосуществуетзначительнобольшеизвестныханомалий,чемперечислено\nвстандарте,иещенеизвестноечислопоканеизвестных.\nУровень Serializable должен предотвращать любые аномалии.Это означает,\nчтонатакомуровнеразработчикуприложенияненадодуматьобизоляции.\nЕсли транзакции выполняют корректные последовательности операторов,\nработая в одиночку,данные останутся согласованными и при одновремен-\nнойработеэтихтранзакций.\nВкачествеиллюстрацииприведуизвестнуювсемтаблицуизстандарта,кко-\nторойдляясностидобавленпоследнийстолбец:\nпотерянные грязное неповторяющееся фантомное другие\nизменения чтение чтение чтение аномалии\nReadUncommitted — да да да да\nReadCommitted — — да да да\nRepeatableRead — — — да да\nSerializable — — — — —\nПочемуименно эти аномалии?\nПочемуизмножествавозможныханомалийвстандартеперечисленытоль-\nконесколько,ипочемуименнотакие?\n52",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.700539"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 54,
    "chapter": null,
    "section": "2.2 УровниизоляцииианомалиивстандартеSQL",
    "text": "2.2. УровниизоляцииианомалиивстандартеSQL\nДостоверно этого,видимо,никто не знает.Но не исключено,что о других\nаномалиях во времена принятия первых версий стандарта просто не заду-\nмывались,посколькутеориязаметноотставалаотпрактики.\nКроме того,предполагалось,что изоляция должна быть построена на бло-\nкировках.Идеяширокоприменявшегосяпротоколадвухфазногоблокирова-\nния (2PL) состоитвтом,что в процессе выполнениятранзакция блокирует\nзатронутые строки,а при завершении—освобождаетблокировки.Сильно\nупрощая: чем больше блокировок захватываеттранзакция,тем лучше она\nизолирована отдругихтранзакций.Но итем сильнее страдаетпроизводи-\nтельностьсистемы,посколькувместосовместнойработытранзакцииначи-\nнаютвыстраиватьсявочередьзаоднимиитемижестроками.\nКакмнепредставляется,разницамеждустандартнымиуровнямиизоляции\nвзначительнойстепениобъясняетсякакразколичествомнеобходимыхдля\nихреализацииблокировок.\nЕслитранзакция блокирует изменяемые строки для изменений,но не для\nчтения, получаем уровень Read Uncommitted с возможностью прочитать\nнезафиксированныеданные.\nЕслиизменяемыестрокиблокируютсяидлячтения,идляизменений,полу-\nчаемуровеньRead Committed:незафиксированныеданныепрочитатьнель-\nзя,ноприповторномобращениикстрокеможнополучитьдругоезначение\n(неповторяющеесячтение).\nЕслидлявсехоперацийблокируютсяичитаемые,иизменяемыестроки,по-\nлучаемуровеньRepeatableRead:повторноечтениестрокибудетвыдаватьто\nжезначение.\nНосSerializableпроблема:невозможнозаблокироватьстроку,которойеще\nнет.Из-заэтогоостаетсявозможностьфантомногочтения:другаятранзак-\nцияможетдобавитьстроку,попадающуюподусловиявыполненногоранее\nзапроса,иэтастрокаокажетсявповторнойвыборке.\nПоэтомудляполнойизоляцииобычныхблокировокнехватает—нужнобло-\nкироватьнестроки,аусловия(предикаты).Такиепредикатныеблокировки\nбыли предложены еще в 1976 году при работе над System R, но их прак-\nтическая применимость ограничена достаточно простыми условиями,для\nкоторых понятно, конфликтуют ли два разных предиката. До реализации с.288\n53",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.738817"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 55,
    "chapter": null,
    "section": "2.3 Уровни изоляции в PostgreSQL",
    "text": "Глава2. Изоляция\nпредикатныхблокировоквзадуманномвидедело,насколькомнеизвестно,\nнедошлониводнойсистеме.\n2.3. Уровни изоляции в PostgreSQL\nСовременемнасменублокировочнымпротоколамуправлениятранзакция-\nмипришелпротоколизоляциинаосновеснимков(SnapshotIsolation,SI).Его\nидеясостоитвтом,чтокаждаятранзакцияработаетссогласованнымсним-\nкомданныхнаопределенныймоментвремени.Вснимокпопадаютвсеак-\nтуальныеизменения,зафиксированныедомоментаегосоздания.\nИзоляция на основе снимков позволяет обходиться минимумом блокиро-\nс.258 вок.Фактическиблокируетсятолькоповторноеизменениеоднойитойже\nстроки.Все остальные операции могут выполняться одновременно: пишу-\nщиетранзакцииникогданеблокируютчитающиетранзакции,ачитающие\nвообщеникогданикогонеблокируют.\nВPostgreSQLреализованмноговерсионныйвариантпротоколаSI.Многовер-\nсионность подразумевает, что в СУБД в один момент времени могут со-\nсуществоватьнескольковерсийоднойитойжестроки.Этопозволяетвклю-\nчатьвснимокподходящуюверсию,анеобрыватьтранзакции,пытающиеся\nпрочитатьустаревшиеданные.\nЗасчетиспользованияснимковданныхизоляциявPostgreSQLотличаетсяот\nтой,чтотребуетстандарт,ивцеломонастроже.Грязноечтениенедопуска-\nетсяпоопределению.ФормальновPostgreSQLможноуказатьуровеньRead\nUncommitted,ноработатьонбудетточнотакже,какReadCommitted,поэтому\nдальшеявообщенебудуговоритьпроэтотуровень.УровеньRepeatableRead\nс.162 недопускаетнетольконеповторяющегося,ноифантомногочтения(хотяи\nнеобеспечиваетполнуюизоляцию).Правда,науровнеReadCommittedмож-\nноврядеслучаевпотерятьизменения.\nпотерянные грязное неповторяющееся фантомное другие\nизменения чтение чтение чтение аномалии\nReadCommitted да — да да да\nRepeatableRead — — — — да\nSerializable — — — — —\n54",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.771432"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 56,
    "chapter": null,
    "section": "2.3 УровниизоляциивPostgreSQL",
    "text": "2.3. УровниизоляциивPostgreSQL\nПеред тем как исследовать внутреннее устройство изоляции, давайте по- с.97\nдробнорассмотримкаждыйизтрехуровнейсточкизренияпользователя.\nДляэтогосоздадимтаблицусчетов.УАлисыиБобапо1000₽,ноуБобаот-\nкрытодвасчета:\n=> CREATE TABLE accounts(\nid integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,\nclient text,\namount numeric\n);\n=> INSERT INTO accounts VALUES\n(1, 'alice', 1000.00),\n(2, 'bob', 100.00),\n(3, 'bob', 900.00);\nRead Committed\nОтсутствиегрязногочтения. Легкоубедитьсявтом,чтогрязныеданныепро-\nчитать невозможно. Начнем транзакцию. По умолчанию она использует\nуровеньизоляцииReadCommitted1:\n=> BEGIN;\n=> SHOW transaction_isolation;\ntransaction_isolation\n−−−−−−−−−−−−−−−−−−−−−−−\nread committed\n(1 row)\nГоворяточнее,умолчательныйуровеньзадаетсяпараметром,которыйпри\nнеобходимостиможноизменить:\n=> SHOW default_transaction_isolation;\ndefault_transaction_isolation\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nread committed\n(1 row)\n1 postgrespro.ru/docs/postgresql/17/transaction-iso#XACT-READ-COMMITTED.\n55",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.798260"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 57,
    "chapter": null,
    "section": "2.3 УровниизоляциивPostgreSQL",
    "text": "Глава2. Изоляция\nИтак,воткрытойтранзакцииснимаемсредствасосчета,нонефиксируем\nизменения.Своисобственныеизменениятранзакциявсегдавидит:\n=> UPDATE accounts SET amount = amount - 200 WHERE id = 1;\n=> SELECT * FROM accounts WHERE client = 'alice';\nid | client | amount\n−−−−+−−−−−−−−+−−−−−−−−\n1 | alice | 800.00\n(1 row)\nВо втором сеансе начинаем еще одну транзакцию с тем же уровнем Read\nCommitted:\n=> BEGIN;\n=> SELECT * FROM accounts WHERE client = 'alice';\nid | client | amount\n−−−−+−−−−−−−−+−−−−−−−−−\n1 | alice | 1000.00\n(1 row)\nКакиожидалось,другаятранзакцияневидитнезафиксированныеизмене-\nния—грязноечтениенедопускается.\nНеповторяющеесячтение. Пустьтеперьперваятранзакциязафиксируетиз-\nменения,автораяповторновыполниттотжесамыйзапрос:\n=> COMMIT;\n=> SELECT * FROM accounts WHERE client = 'alice';\nid | client | amount\n−−−−+−−−−−−−−+−−−−−−−−\n1 | alice | 800.00\n(1 row)\n=> COMMIT;\nЗапросполучаетуженовыеданные—этоиестьаномалиянеповторяющегося\nчтения,котораядопускаетсянауровнеReadCommitted.\nПрактический вывод: втранзакции нельзя приниматьрешения на основа-\nнииданных,прочитанных предыдущим оператором,ведьза время между\n56",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.827464"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 58,
    "chapter": null,
    "section": "2.3 УровниизоляциивPostgreSQL",
    "text": "2.3. УровниизоляциивPostgreSQL\nвыполнениемоператороввсеможетизмениться.Вотпример,вариациико-\nтороговстречаютсявприкладномкодетакчасто,чтоонявляетсяклассиче-\nскимантипаттерном:\nIF (SELECT amount FROM accounts WHERE id = 1) >= 1000 THEN\nUPDATE accounts SET amount = amount - 1000 WHERE id = 1;\nEND IF;\nЗавремя,котороепроходитмеждупроверкойиобновлением,другиетран-\nзакциимогуткакугодноизменитьсостояниесчета,такчтотакая«проверка»\nниотчегонеспасает.Удобнопредставлятьсебе,чтомеждуоператорамиод-\nнойтранзакциимогут«вклиниться»произвольныеоператорыдругихтран-\nзакций,напримервоттак:\nIF (SELECT amount FROM accounts WHERE id = 1) >= 1000 THEN\nUPDATE accounts SET amount = amount - 200 WHERE id = 1;\nCOMMIT;\nUPDATE accounts SET amount = amount - 1000 WHERE id = 1;\nEND IF;\nЕсли, переставив операторы, можно все испортить, значит, код написан\nнекорректно. Не стоит обманывать себя, что с таким стечением обстоя-\nтельств мы не столкнемся: если неприятность может случиться, она про-\nизойдет обязательно. А вот воспроизводить и, следовательно, исправлять\nтакиеошибкиоченьсложно.\nКакнаписатькодкорректно?Естьнескольковозможностей:\n• Заменитьпроцедурныйкоддекларативным.\nНапример,в данном случае проверка легко превращается в ограниче-\nниецелостности:\nALTER TABLE accounts ADD CHECK amount >= 0;\nТеперь никакие проверки в коде не нужны: достаточно просто выпол-\nнить действие и при необходимости обработать исключение, которое\nвозникнетвслучаепопыткинарушенияцелостности.\n57",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.862994"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 59,
    "chapter": null,
    "section": "2.3 УровниизоляциивPostgreSQL",
    "text": "Глава2. Изоляция\n• ИспользоватьодиноператорSQL.\nПроблемыссогласованностьювозникаютиз-затого,чтовпромежутке\nмеждуоператорамиможетзавершитьсядругаятранзакция,ивидимые\nданныеизменятся.Еслиоператородин,тоипромежутковникакихнет.\nВPostgreSQLдостаточносредств,чтобыоднимSQL-операторомрешать\nсложныезадачи.Отмечуобщиетабличныевыражения(CTE),вкоторых\nв том числе можно использовать операторы INSERT, UPDATE, DELETE,\nv.15 MERGE, а также оператор INSERT ON CONFLICT, который атомарно реа-\nлизуетлогику«вставить,аеслистрокаужеесть,тообновить».\n• Задействоватьпользовательскиеблокировки.\nПоследнеесредство—вручнуюустановитьисключительнуюблокиров-\nс.258 ку на все нужные строки (SELECT FOR UPDATE) или вообще на всютаб-\nс.251 лицу(LOCKTABLE).Этовсегдаработает,носводитнанетпреимущества\nмноговерсионности:вместоодновременноговыполнениячастьопера-\nцийбудетвыполнятьсяпоследовательно.\nНесогласованноечтение. Однако не всетак просто.Реализация PostgreSQL\nтакова,чтодопускаетдругие,менееизвестныеаномалии,которыенерегла-\nментируютсястандартом.\nДопустим,перваятранзакцияначалапереводсредствсодногосчетаБобана\nдругой:\n=> BEGIN;\n=> UPDATE accounts SET amount = amount - 100 WHERE id = 2;\nВэтовремядругаятранзакцияподсчитываетбалансБоба,причемподсчет\nвыполняетсявциклеповсемсчетамБоба.Фактическитранзакцияначинает\nспервогосчета(и,разумеется,видитпрежнеесостояние):\n=> BEGIN;\n=> SELECT amount FROM accounts WHERE id = 2;\namount\n−−−−−−−−\n100.00\n(1 row)\n58",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.897380"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 60,
    "chapter": null,
    "section": "2.3 УровниизоляциивPostgreSQL",
    "text": "2.3. УровниизоляциивPostgreSQL\nВэтотмоментперваятранзакцияуспешнозавершается:\n=> UPDATE accounts SET amount = amount + 100 WHERE id = 3;\n=> COMMIT;\nАдругаячитаетсостояниевторогосчета(ивидитуженовоезначение):\n=> SELECT amount FROM accounts WHERE id = 3;\namount\n−−−−−−−−−\n1000.00\n(1 row)\n=> COMMIT;\nВ итоге вторая транзакция получила в сумме 1100 ₽, то есть прочитала\nнекорректныеданные.Такаяаномалияназываетсянесогласованнымчтени-\nем(readskew).\nКакизбежатьэтойаномалии,оставаясьнауровнеReadCommitted?Конечно,\nиспользоватьодиноператор.Например,так:\nSELECT sum(amount) FROM accounts WHERE client = 'bob';\nДо сих пор я утверждал, что видимость данных может поменяться только\nмежду операторами, но так ли это очевидно? А если запрос выполняется\nдолго,можетлионувидетьчастьданныхводномсостоянии,ачасть—уже\nвдругом?\nПроверим.Удобныйспособдляэтого—вставитьвоператорискусственную\nзадержку,вызвавфункциюpg_sleep.Перваястрокабудетпрочитанасразу,\nавторая—черездвесекунды:\n=> SELECT amount, pg_sleep(2) -- 2 секунды\nFROM accounts WHERE client = 'bob';\nПока эта конструкция выполняется,в другой транзакции переводим сред-\nстваобратно:\n=> BEGIN;\n=> UPDATE accounts SET amount = amount + 100 WHERE id = 2;\n=> UPDATE accounts SET amount = amount - 100 WHERE id = 3;\n=> COMMIT;\n59",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.930911"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 61,
    "chapter": null,
    "section": "1000.00 |",
    "text": "Глава2. Изоляция\nРезультатпоказывает,чтооператорвидитданныевтакомсостоянии,вка-\nком они находились на момент начала его выполнения, что, безусловно,\nправильно:\namount | pg_sleep\n−−−−−−−−−+−−−−−−−−−−\n0.00 |\n1000.00 |\n(2 rows)\nНоитутневсетакпросто.Есливзапросевызываетсяизменчиваяфункция\n(скатегориейизменчивостиVOLATILE)ивэтойфункциивыполняетсядру-\nгойзапрос,тоэтотвложенныйзапрос будетвидетьданные,несогласован-\nныесданнымиосновногозапроса.\nПроверимсостояниесчетовБоба,используяфункцию:\n=> CREATE FUNCTION get_amount(id integer) RETURNS numeric\nAS $$\nSELECT amount FROM accounts a WHERE a.id = get_amount.id;\n$$ VOLATILE LANGUAGE sql;\n=> SELECT get_amount(id), pg_sleep(2)\nFROM accounts WHERE client = 'bob';\nИсновапереведемденьгимеждусчетами,показапроссзадержкойвыпол-\nняется:\n=> BEGIN;\n=> UPDATE accounts SET amount = amount + 100 WHERE id = 2;\n=> UPDATE accounts SET amount = amount - 100 WHERE id = 3;\n=> COMMIT;\nВэтомслучаеполучимнесогласованныеданные—100₽пропали:\nget_amount | pg_sleep\n−−−−−−−−−−−−+−−−−−−−−−−\n100.00 |\n800.00 |\n(2 rows)\nПодчеркну, что такой эффект возможен только на уровне изоляции Read\nCommitted и только с категорией изменчивости VOLATILE. Беда в том, что\nпо умолчанию используется именно этот уровень изоляции и именно эта\n60",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.964208"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 62,
    "chapter": null,
    "section": "2.3 УровниизоляциивPostgreSQL",
    "text": "2.3. УровниизоляциивPostgreSQL\nкатегория изменчивости,так что остается признать—грабли лежат очень\nудачно.\nНесогласованноечтениевместопотерянногообновления. Аномалиюнесогла-\nсованногочтенияврамкаходногооператораможно—нескольконеожидан-\nнымобразом—получитьиприобновлении.\nПосмотрим,чтопроисходитприпопыткеизмененияоднойитойжестроки\nдвумятранзакциями.СейчасуБоба1000₽надвухсчетах:\n=> SELECT * FROM accounts WHERE client = 'bob';\nid | client | amount\n−−−−+−−−−−−−−+−−−−−−−−\n2 | bob | 200.00\n3 | bob | 800.00\n(2 rows)\nНачинаемтранзакцию,котораяуменьшаетбалансБоба:\n=> BEGIN;\n=> UPDATE accounts SET amount = amount - 100 WHERE id = 3;\nВэтожевремядругаятранзакцияначисляетпроцентынавсесчетасобщим\nбалансом,равнымилипревышающим1000₽:\n=> UPDATE accounts SET amount = amount * 1.01\nWHERE client IN (\nSELECT client\nFROM accounts\nGROUP BY client\nHAVING sum(amount) >= 1000\n);\nВыполнениеоператораUPDATEсостоитиздвухчастей.Сначалафактически\nвыполняется оператор SELECT, который отбирает для обновления строки,\nсоответствующиеусловию.Посколькуизменениепервойтранзакциинеза-\nфиксировано,втораятранзакциянеможетеговидеть,иононикакневлия-\nет на выбор строк для начисления процентов. Таким образом, счета Боба\nпопадаютподусловие,ипослевыполненияобновленияегобалансдолжен\nувеличитьсяна10₽.\n61",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:44.995196"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 63,
    "chapter": null,
    "section": "2.3 УровниизоляциивPostgreSQL",
    "text": "Глава2. Изоляция\nНа втором этапе выполнения выбранные строки обновляются одна задру-\nгой.Втораятранзакциявынужденаподождать,посколькустрокаid=3вна-\nстоящиймоментизменяетсяпервойтранзакциейипоэтомузаблокирована.\nМеждутемперваятранзакцияфиксируетизменения:\n=> COMMIT;\n=> SELECT * FROM accounts WHERE client = 'bob';\nid | client | amount\n−−−−+−−−−−−−−+−−−−−−−−−−\n2 | bob | 202.0000\n3 | bob | 707.0000\n(2 rows)\nДа,соднойстороны,командаUPDATE недолжнавидетьизмененийвторой\nтранзакции.Носдругой—онанедолжнапотерятьизменения,зафиксиро-\nванныевовторойтранзакции.\nс.269 После снятия блокировки оператор UPDATE перечитывает строку,которую\nпытается обновить(нотолько ее одну!).В результате получается,что Бобу\nначислено9₽,исходяизсуммы900₽.НоеслибыуБобабыло900₽,егосчета\nвообщенедолжныбылипопастьввыборку.\nТакимобразом,транзакцияпрочиталанекорректныеданные:частьстрок—\nнаодинмоментвремени,часть—надругой.Взаменпотерянногообновле-\nниямысноваполучаеманомалиюнесогласованногочтения.\nПотерянное обновление. Впрочем, хитростьс перечитыванием заблокиро-\nваннойстрокинеспасаетотпотериизменений,еслиобновлениепроисхо-\nдитневодномоператореSQL.\nс.50 Вотпример,которыйужебыл.Приложениечитаетизапоминает(внебазы\nданных)текущийбаланссчетаАлисы:\n=> BEGIN;\n=> SELECT amount FROM accounts WHERE id = 1;\namount\n−−−−−−−−\n800.00\n(1 row)\nВэтовремядругаятранзакциядействуеттакже:\n62",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.026408"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 64,
    "chapter": null,
    "section": "2.3 УровниизоляциивPostgreSQL",
    "text": "2.3. УровниизоляциивPostgreSQL\n=> BEGIN;\n=> SELECT amount FROM accounts WHERE id = 1;\namount\n−−−−−−−−\n800.00\n(1 row)\nПерваятранзакцияувеличиваетзапомненноеранеезначениена100₽иза-\nписываетвбазу:\n=> UPDATE accounts SET amount = 800.00 + 100 WHERE id = 1\nRETURNING amount;\namount\n−−−−−−−−\n900.00\n(1 row)\nUPDATE 1\n=> COMMIT;\nИвтораятранзакциятоже:\n=> UPDATE accounts SET amount = 800.00 + 100 WHERE id = 1\nRETURNING amount;\namount\n−−−−−−−−\n900.00\n(1 row)\nUPDATE 1\n=> COMMIT;\nК сожалению,Алиса недосчиталась100 ₽.СУБД ничего не знаетотом,что\nзапомненноезначение800₽как-тосвязаносaccounts.amount,идопуска-\nетаномалию потерянного изменения.На уровне изоляции Read Committed\nтакойкоднекорректен.\nRepeatable Read\nОтсутствие неповторяющегося и фантомного чтения. Само название уровня\nизоляцииRepeatableRead1 говоритоповторяемостичтения.Проверимэто,\n1 postgrespro.ru/docs/postgresql/17/transaction-iso#XACT-REPEATABLE-READ.\n63",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.051020"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 65,
    "chapter": null,
    "section": "2.3 УровниизоляциивPostgreSQL",
    "text": "Глава2. Изоляция\nазаодноубедимсяивотсутствиифантомов.Дляэтоговпервойтранзакции\nвернемсчетаБобавпрежнеесостояниеисоздадимновыйсчетдляЧарли:\n=> BEGIN;\n=> UPDATE accounts SET amount = 200.00 WHERE id = 2;\n=> UPDATE accounts SET amount = 800.00 WHERE id = 3;\n=> INSERT INTO accounts VALUES\n(4, 'charlie', 100.00);\n=> SELECT * FROM accounts ORDER BY id;\nid | client | amount\n−−−−+−−−−−−−−−+−−−−−−−−\n1 | alice | 900.00\n2 | bob | 200.00\n3 | bob | 800.00\n4 | charlie | 100.00\n(4 rows)\nВовторомсеансеначнемтранзакциюсуровнемRepeatableRead,указавего\nвкомандеBEGIN(уровеньпервойтранзакцииневажен):\n=> BEGIN ISOLATION LEVEL REPEATABLE READ;\n=> SELECT * FROM accounts ORDER BY id;\nid | client | amount\n−−−−+−−−−−−−−+−−−−−−−−−−\n1 | alice | 900.00\n2 | bob | 202.0000\n3 | bob | 707.0000\n(3 rows)\nТеперьперваятранзакцияфиксируетизменения,автораяповторновыпол-\nняеттотжесамыйзапрос:\n=> COMMIT;\n=> SELECT * FROM accounts ORDER BY id;\nid | client | amount\n−−−−+−−−−−−−−+−−−−−−−−−−\n1 | alice | 900.00\n2 | bob | 202.0000\n3 | bob | 707.0000\n(3 rows)\n=> COMMIT;\n64",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.080692"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 66,
    "chapter": null,
    "section": "2.3 УровниизоляциивPostgreSQL",
    "text": "2.3. УровниизоляциивPostgreSQL\nВтораятранзакцияпродолжаетвидетьровнотежеданные,чтоивначале:\nневиднониизмененийвсуществующихстроках,ниновыхстрок.Натаком\nуровнеможнонебеспокоитьсяотом,чтомеждудвумяоператорамичто-то\nпоменяется.\nОшибкасериализациивместопотерянныхизменений. Какмыужевидели,на с.61\nуровне изоляции Read Committed при обновлении одной и той же строки\nдвумятранзакциямиможетвозникнутьаномалиянесогласованногочтения.\nЭтопроисходитиз-затого,чтоожидающаятранзакцияперечитываетзабло-\nкированнуюстрокуивидитеенаодинмоментвремени,аостальныестроки\nвыборки—надругой.\nНауровнеRepeatable Readтакаяаномалиянедопускается,но,еслионавсе-\nтаки возникает,сделать уже ничего нельзя—поэтомутранзакция обрыва-\nетсясошибкойсериализации.Проверим,повторивтотжесценарийспро-\nцентами:\n=> SELECT * FROM accounts WHERE client = 'bob';\nid | client | amount\n−−−−+−−−−−−−−+−−−−−−−−\n2 | bob | 200.00\n3 | bob | 800.00\n(2 rows)\n=> BEGIN;\n=> UPDATE accounts SET amount = amount - 100.00 WHERE id = 3;\n=> BEGIN ISOLATION LEVEL REPEATABLE READ;\n=> UPDATE accounts SET amount = amount * 1.01\nWHERE client IN (\nSELECT client\nFROM accounts\nGROUP BY client\nHAVING sum(amount) >= 1000\n);\n=> COMMIT;\n65",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.112503"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 67,
    "chapter": null,
    "section": "2.3 УровниизоляциивPostgreSQL",
    "text": "Глава2. Изоляция\nERROR: could not serialize access due to concurrent update\n=> ROLLBACK;\nДанныеосталисьсогласованными:\n=> SELECT * FROM accounts WHERE client = 'bob';\nid | client | amount\n−−−−+−−−−−−−−+−−−−−−−−\n2 | bob | 200.00\n3 | bob | 700.00\n(2 rows)\nТакаяжеошибкабудетивслучаелюбогодругогоконкурентногоизменения\nстроки,дажееслиононезатрагиваетинтересующиенасстолбцы.\nМожнопроверить,чтоисценарийсприложениями,обновляющимибаланс\nнаосновезапомненногозначения,приводитктойжеошибке:\n=> BEGIN ISOLATION LEVEL REPEATABLE READ;\n=> SELECT amount FROM accounts WHERE id = 1;\namount\n−−−−−−−−\n900.00\n(1 row)\n=> BEGIN ISOLATION LEVEL REPEATABLE READ;\n=> SELECT amount FROM accounts WHERE id = 1;\namount\n−−−−−−−−\n900.00\n(1 row)\n=> UPDATE accounts SET amount = 900.00 + 100.00 WHERE id = 1\nRETURNING amount;\namount\n−−−−−−−−−\n1000.00\n(1 row)\nUPDATE 1\n=> COMMIT;\n66",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.150410"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 68,
    "chapter": null,
    "section": "2.3 УровниизоляциивPostgreSQL",
    "text": "2.3. УровниизоляциивPostgreSQL\n=> UPDATE accounts SET amount = 900.00 + 100.00 WHERE id = 1\nRETURNING amount;\nERROR: could not serialize access due to concurrent update\n=> ROLLBACK;\nПрактический вывод: если приложение использует уровень изоляции Re-\npeatableReadдляпишущихтранзакций,онодолжнобытьготовоповторять\nтранзакции,завершившиесяошибкойсериализации.Длятолькочитающих\nтранзакцийтакойисходневозможен.\nНесогласованнаязапись. Итак,вPostgreSQLнауровнеизоляцииRepeatable\nReadпредотвращаютсявсеаномалии,описанныевстандарте.Ноневсево-\nобще—наукедосихпорнеизвестно,сколькоихсуществует.Однакодоказан\nважныйфакт:изоляциянаосновеснимковоставляетвозможнымировнодве\nаномалии,сколькобыихнибыловсего.\nПерваяизэтиханомалий—несогласованнаязапись(writeskew).\nПустьдействуеттакое правило согласованности: допускаются отрицатель-\nные суммы на отдельных счетах клиента, если общая сумма на всех счетах\nэтогоклиентаостаетсянеотрицательной.\nПерваятранзакцияполучаетсуммунасчетахБоба:\n=> BEGIN ISOLATION LEVEL REPEATABLE READ;\n=> SELECT sum(amount) FROM accounts WHERE client = 'bob';\nsum\n−−−−−−−−\n900.00\n(1 row)\nВтораятранзакцияполучаеттужесумму:\n=> BEGIN ISOLATION LEVEL REPEATABLE READ;\n=> SELECT sum(amount) FROM accounts WHERE client = 'bob';\nsum\n−−−−−−−−\n900.00\n(1 row)\n67",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.183647"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 69,
    "chapter": null,
    "section": "2.3 УровниизоляциивPostgreSQL",
    "text": "Глава2. Изоляция\nПерваятранзакциясправедливополагает,чтосуммуодногоизсчетовмож-\nноуменьшитьна600₽:\n=> UPDATE accounts SET amount = amount - 600.00 WHERE id = 2;\nИ вторая транзакция приходит к такому же выводу. Но уменьшаетдругой\nсчет:\n=> UPDATE accounts SET amount = amount - 600.00 WHERE id = 3;\n=> COMMIT;\n=> COMMIT;\n=> SELECT * FROM accounts WHERE client = 'bob';\nid | client | amount\n−−−−+−−−−−−−−+−−−−−−−−−\n2 | bob | −400.00\n3 | bob | 100.00\n(2 rows)\nУ нас получилось увести баланс Боба в минус,хотя поодиночке каждая из\nтранзакцийотработалабыкорректно.\nАномалия только читающей транзакции. Аномалия только читающей тран-\nзакции—втораяипоследняяизаномалий,возможныхнауровнеRepeatable\nRead.Чтобыпродемонстрироватьее,потребуютсятритранзакции,двеизко-\nторыхбудутизменятьданные,атретья—толькочитать.\nНосначалавосстановимсостояниесчетовБоба:\n=> UPDATE accounts SET amount = 900.00 WHERE id = 2;\n=> SELECT * FROM accounts WHERE client = 'bob';\nid | client | amount\n−−−−+−−−−−−−−+−−−−−−−−\n3 | bob | 100.00\n2 | bob | 900.00\n(2 rows)\nПерваятранзакцияначисляетБобупроцентынасуммусредствнавсехсче-\nтах.Процентызачисляютсянаодинизегосчетов:\n68",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.214301"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 70,
    "chapter": null,
    "section": "2.3 УровниизоляциивPostgreSQL",
    "text": "2.3. УровниизоляциивPostgreSQL\n=> BEGIN ISOLATION LEVEL REPEATABLE READ; -- 1\n=> UPDATE accounts SET amount = amount + (\nSELECT sum(amount) FROM accounts WHERE client = 'bob'\n) * 0.01\nWHERE id = 2;\nЗатемдругаятранзакцияснимаетденьгисдругогосчетаБобаификсирует\nсвоиизменения:\n=> BEGIN ISOLATION LEVEL REPEATABLE READ; -- 2\n=> UPDATE accounts SET amount = amount - 100.00 WHERE id = 3;\n=> COMMIT;\nЕсли в этотмоментперваятранзакция будетзафиксирована,никакой ано-\nмалииневозникнет:мымоглибысчитать,чтосначалавыполненапервая\nтранзакция,азатемвторая(ноненаоборот,потомучтоперваятранзакция\nувидела состояние счета id = 3 дотого,как этотсчетбыл изменен второй\nтранзакцией).\nНо представим, что в этот момент третья (только читающая) транзакция\nзапрашивает суммы на счетах Боба. Она может видеть изменения второй\nтранзакции(котораяужебылазафиксирована),нонепервой(котораяеще\nнебылазафиксирована):\n=> SELECT * FROM accounts WHERE client = 'bob'; -- 3\nid | client | amount\n−−−−+−−−−−−−−+−−−−−−−−\n2 | bob | 900.00\n3 | bob | 0.00\n(2 rows)\nС другой стороны, мы уже установили выше, что вторую транзакцию сле-\nдуетсчитатьначавшейся после первой.Последствия аномалии становятся\nпонятнымипослезавершенияпервойтранзакции:\n=> COMMIT;\nУ Боба на счетах всего 900 ₽ (что показала только читающая транзакция),\nапроцентыоказалисьначисленныминавсе1000₽:\n69",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.247786"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 71,
    "chapter": null,
    "section": "2.3 УровниизоляциивPostgreSQL",
    "text": "Глава2. Изоляция\n=> SELECT * FROM accounts WHERE client = 'bob';\nid | client | amount\n−−−−+−−−−−−−−+−−−−−−−−−−\n2 | bob | 910.0000\n3 | bob | 0.00\n(2 rows)\nSerializable\nНауровнеSerializable1 предотвращаютсявсевозможныеаномалии.Факти-\nческиSerializableреализованкакнадстройканадизоляциейнаосновесним-\nковданных.Теаномалии,которыеневозникаютприRepeatableRead(такие\nкакгрязное,неповторяемое,фантомноечтение),невозникаютинауровне\nSerializable.Атедвеаномалии,которыевозникают(несогласованнаязапись\nи аномалия только читающей транзакции),специальным образом обнару-\nживаются,ивэтомслучаетранзакцияобрывается:возникаетужезнакомая\nнамошибкасериализации.\nс.67 Отсутствиеаномалий. Можноубедиться,чтосценарийсаномалиейнесогла-\nсованнойзаписиприведеткошибкесериализации:\n=> BEGIN ISOLATION LEVEL SERIALIZABLE;\n=> SELECT sum(amount) FROM accounts WHERE client = 'bob';\nsum\n−−−−−−−−−−\n910.0000\n(1 row)\n=> BEGIN ISOLATION LEVEL SERIALIZABLE;\n=> SELECT sum(amount) FROM accounts WHERE client = 'bob';\nsum\n−−−−−−−−−−\n910.0000\n(1 row)\n1 postgrespro.ru/docs/postgresql/17/transaction-iso#XACT-SERIALIZABLE.\n70",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.276469"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 72,
    "chapter": null,
    "section": "2.3 УровниизоляциивPostgreSQL",
    "text": "2.3. УровниизоляциивPostgreSQL\n=> UPDATE accounts SET amount = amount - 600.00 WHERE id = 2;\n=> UPDATE accounts SET amount = amount - 600.00 WHERE id = 3;\n=> COMMIT;\nCOMMIT\n=> COMMIT;\nERROR: could not serialize access due to read/write dependencies\namong transactions\nDETAIL: Reason code: Canceled on identification as a pivot, during\ncommit attempt.\nHINT: The transaction might succeed if retried.\nКтакойжеошибкеприведетисценарийаномалиитолькочитающейтран-\nзакции.\nОткладывание читающей транзакции. Чтобы только читающая транзакция\nнеприводилаканомалииинемоглапострадатьотнее,PostgreSQLпредла-\nгаетинтересный механизм:такаятранзакция можетбытьотложенадотех\nпор,покаеевыполнениенестанетбезопасным.Этоединственныйслучай,\nкогдаоператорSELECTможетбытьзаблокированобновлениямистрок.\nПосмотрим на примере сценария аномалиитолько читающейтранзакции:\n=> UPDATE accounts SET amount = 900.00 WHERE id = 2;\n=> UPDATE accounts SET amount = 100.00 WHERE id = 3;\n=> SELECT * FROM accounts WHERE client = 'bob' ORDER BY id;\nid | client | amount\n−−−−+−−−−−−−−+−−−−−−−−\n2 | bob | 900.00\n3 | bob | 100.00\n(2 rows)\n=> BEGIN ISOLATION LEVEL SERIALIZABLE; -- 1\n=> UPDATE accounts SET amount = amount + (\nSELECT sum(amount) FROM accounts WHERE client = 'bob'\n) * 0.01\nWHERE id = 2;\n71",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.310595"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 73,
    "chapter": null,
    "section": "2.3 УровниизоляциивPostgreSQL",
    "text": "Глава2. Изоляция\n=> BEGIN ISOLATION LEVEL SERIALIZABLE; -- 2\n=> UPDATE accounts SET amount = amount - 100.00 WHERE id = 3;\n=> COMMIT;\nТретьютранзакциюявнообъявляемтолькочитающий(READ ONLY)иоткла-\nдываемой(DEFERRABLE):\n=> BEGIN ISOLATION LEVEL SERIALIZABLE READ ONLY DEFERRABLE; -- 3\n=> SELECT * FROM accounts WHERE client = 'alice';\nПрипопыткевыполнитьзапространзакцияблокируется,потомучтоиначе\nонаприведетканомалии.\nИ только после того, как первая транзакция будет зафиксирована, третья\nпродолжитвыполнение:\n=> COMMIT;\nid | client | amount\n−−−−+−−−−−−−−+−−−−−−−−−\n1 | alice | 1000.00\n(1 row)\n=> SELECT * FROM accounts WHERE client = 'bob';\nid | client | amount\n−−−−+−−−−−−−−+−−−−−−−−−−\n2 | bob | 910.0000\n3 | bob | 0.00\n(2 rows)\n=> COMMIT;\nТаким образом, приложение, использующее уровень изоляции Serializable,\nдолжно повторять транзакции, завершившиеся ошибкой сериализации.\n(Точнотак же следуетпоступать и на уровне Repeatable Read,если не огра-\nничиватьсятолькочитающимитранзакциями.)\nУровеньSerializableдаетпростотупрограммирования,ноценазанее—на-\nкладныерасходынаобнаружениевозможныханомалийиобрывнекоторой\nдолитранзакций.Снизитьнакладныерасходыможно,явнообозначаятоль-\nкочитающиетранзакциикакREADONLY.Ноглавныйвопрос,конечно,втом,\n72",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.341993"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 74,
    "chapter": null,
    "section": "2.4 Какойуровеньизоляциииспользовать?",
    "text": "2.4. Какойуровеньизоляциииспользовать?\nнасколько велика доля оборванных транзакций, ведь их придется выпол-\nнятьповторно.Еслибыобрывалисьтолькотетранзакции,которыедействи-\nтельнонесовместимопересекаютсяподанным,всебылобынеплохо.Нота-\nкаяреализациянеизбежнооказаласьбыслишкомресурсоемкой,поскольку\nпришлосьбыотслеживатьоперациискаждойстрокой.\nВ действительности реализация такова, что допускает ложноположитель- с.288\nныесрабатывания:будутобрыватьсяинекоторыесовершеннонормальные\nтранзакции,которым«простонеповезло».Везениезависитотмногихпри-\nчин, например от наличия подходящих индексов или доступного объема\nоперативнойпамяти,иповедениесложнопредсказатьзаранее.\nЕсли используется уровень изоляции Serializable, он должен применяться\nдлявсехтранзакцийприложения.Присмешениитранзакцийразногоуров-\nня изоляции уровень Serializable будет (без всяких предупреждений) вес-\nти себя как Repeatable Read.Поэтому при использовании Serializable имеет\nсмысл изменить значение параметра default_transaction_isolation, хотя, ко- read\nнечно,этонепомешаетуказатьнеправильныйуровеньявно. committed\nЕстьидругиеограниченияреализации,напримерзапросынауровнеSerial- v.12\nizable не будутработатьна репликах.И хотя работа над улучшением функ-\nциональностинепрекращается,имеющиесяограниченияинакладныерас-\nходыснижаютпривлекательностьтакогоуровняизоляции.\n2.4. Какой уровень изоляции использовать?\nУровеньизоляцииReadCommittedиспользуетсявPostgreSQLпоумолчанию,\nи,повсейвидимости,именноэтотуровеньприменяетсявабсолютномболь-\nшинствеприложений.Онудобентем,чтонанемобрывтранзакциивозмо-\nжентольковслучаесбоя,нодляпредотвращениянесогласованностиобрыв\nнеприменяется.Инымисловами,ошибкасериализациивозникнутьнемо-\nжет,иоповторениитранзакцийзаботитьсяненадо.\nОбратная сторона медали—большое число возможных аномалий,подроб-\nнорассмотренныхвыше.Разработчиквынужденпостоянноиметьихвви-\nду и писатькодтак,чтобы недопускатьих появления.Если не получается\n73",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.378975"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 75,
    "chapter": null,
    "section": "2.4 Какойуровеньизоляциииспользовать?",
    "text": "Глава2. Изоляция\nсформулироватьнужныедействияводномSQL-операторе,приходитсяпри-\nбегатькявнойустановкеблокировок.Самоенеприятноето,чтокодсложно\nтестироватьнаналичиеошибок,связанныхсполучениемнесогласованных\nданных,асамиошибкимогутвозникатьнепредсказуемыминевоспроизво-\nдимымобразомипоэтомусложнывисправлении.\nУровень изоляции Repeatable Read снимает часть проблем несогласованно-\nсти,но,увы,невсе.Поэтомуприходитсянетолькопомнитьобоставшихся\nаномалиях, но и изменять приложение так, чтобы оно корректно обраба-\nтывало ошибки сериализации. Это, конечно, неудобно. Но для только чи-\nтающих транзакций этот уровень прекрасно дополняет Read Committed и\nполезен,например,дляпостроенияотчетов,использующихнесколькоSQL-\nзапросов.\nНаконец,уровень Serializable позволяет вообще не заботиться о несогласо-\nванности, что значительно упрощает написание кода. Единственное, что\nтребуетсяотприложения,—уметьповторятьлюбуютранзакциюприполу-\nченииошибкисериализации.Нодоляпрерываемыхтранзакцийидополни-\nтельные накладные расходы могут существенно снизить пропускную спо-\nсобность.Такжеследуетучитывать,чтоуровеньSerializableнеприменимна\nрепликахичтоегонельзясмешиватьсдругимиуровнямиизоляции.\n74",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.402318"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 76,
    "chapter": null,
    "section": "3.1 Структура страниц",
    "text": "3\nСтраницы и версии строк\n3.1. Структура страниц\nКаждаястраницаимеетвнутреннююразметкуи,какправило,содержитсле-\nдующиеразделы1:\n• заголовок;\n• массивуказателейнаверсиистрок;\n• свободноепространство;\n• версиистрок;\n• специальнуюобласть.\nЗаголовок страницы\nЗаголовокстраницырасполагаетсявмладшихадресахиимеетфиксирован-\nныйразмер.Онхранитразличнуюинформациюостранице,такуюкакконт- с.127\nрольнаясумма,атакжеразмерывсехостальныхобластей.\nРазмеры легко получить с помощью расширения pageinspect2. Заглянем\nвсамуюпервуюстраницутаблицы(нумерацияначинаетсяснуля):\n1 postgrespro.ru/docs/postgresql/17/storage-page-layout;\ninclude/storage/bufpage.h.\n2 postgrespro.ru/docs/postgresql/17/pageinspect.\n75",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.416931"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 77,
    "chapter": null,
    "section": "3.1 Структура страниц",
    "text": "Глава3. Страницыиверсиистрок\n=> CREATE EXTENSION pageinspect;\n=> SELECT lower, upper, special, pagesize\nFROM page_header(get_raw_page('accounts',0));\nlower | upper | special | pagesize\n−−−−−−−+−−−−−−−+−−−−−−−−−+−−−−−−−−−−\n152 | 6904 | 8192 | 8192\n(1 row)\n0\nзаголовок\n24\nмассивуказателейнаверсиистрок\nlower\nсвободноепространство\nupper\nверсиистрок\nspecial\nспециальнаяобласть\npagesize\nСпециальная область\nСпециальная область расположена в противоположном конце страницы,\nв старших адресах. Она используется некоторыми типами индексов для\nхранениявспомогательнойинформации.Востальныхслучаях,втомчисле\nвтабличныхстраницах,этаобластьимеетнулевойразмер.\nВцеломиндексныестраницыустроеныболееразнообразно,иихсодержи-\nмое зависит от конкретного типа индекса. И даже у одного типа индекса\nбываютразныевидыстраниц:например,уB-дереваестьнулеваястраница\nс.519 метаданных с особой структурой и «обычные» страницы,организованные\nкактабличные.\nВерсии строк\nПередспециальнойобластьюрасполагаютсястроки(rows)—тесамыедан-\nные,которыехранятсявбазе,сдобавлениемнекоторойслужебнойинфор-\nмации.\n76",
    "tables": [
      {
        "table_index": 0,
        "rows": 5,
        "cols": 1,
        "content": "заголовок\nмассивуказателейнаверсиистрок\nсвободноепространство\nверсиистрок\nспециальнаяобласть"
      }
    ],
    "extracted_at": "2025-10-02T15:59:45.444321"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 78,
    "chapter": null,
    "section": "3.1 Структурастраниц",
    "text": "3.1. Структурастраниц\nВ случае таблиц мы говорим не просто о строках, а о версиях строк (row\nversions, tuples), поскольку многоверсионность предполагает существова-\nние нескольких версий одной итой же строки.На индексы многоверсион-\nностьнераспространяется;вместоэтогоиндексыссылаютсянавсевозмож-\nныетабличныеверсиистрок,средикоторыхпоправиламвидимостивыби-\nраютсяподходящие.\nТерминtupleзаимствованизреляционнойтеорииипереводитсякаккортеж.Этоеще\nодно наследие академического прошлого PostgreSQL.Чтобы не смешиватьтеорию\nсустройствомСУБД,ябудуиспользоватьпереводверсиястроки(иногда,еслиэтоне\nвызываетнеоднозначностей,заменяяболеекороткимсловомстрока).\nУказатели на версии строк\nМассив указателей на версии строк служитоглавлением страницы.Он рас-\nполагаетсясразузазаголовком.\nИндексныестрокидолжныкак-тоссылатьсянаверсиистроквтаблице.Для\nэтогоиспользуютсяшестибайтныеидентификаторыверсийстрок(tupleid,\ntid).Идентификаторсостоитизномерастраницывфайлеосновногослояи с.29\nдолженещесодержатькакое-тоуказаниенаверсиюстрокивэтойстранице.\nВ качестве такого указания можно было бы использовать смещение отно-\nсительно начала страницы. Но тогда версию строки нельзя было бы пере-\nмещатьвнутристраницы,несломавссылкиизиндексов.Аэтопривелобы\nкфрагментацииместавнутристраницидругимнеприятнымпоследствиям.\nПоэтомуиспользуетсякосвеннаяадресация:идентификаторверсииссыла-\nется на номер указателя, а уже указатель — на текущую позицию версии\nстрокивстранице.Приперемещенииверсиистрокиееидентификаторне\nменяется; достаточно изменить указатель, который находится на той же\nстранице.\nКаждыйуказательзанимаетровночетыребайтаисодержит:\n• смещениеверсиистрокиотносительноначаластраницы;\n• длинуверсиистроки;\n• несколькобитов,определяющихстатусверсиистроки.\n77",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.478255"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 79,
    "chapter": null,
    "section": "3.2 Структура версий строк",
    "text": "Глава3. Страницыиверсиистрок\nСвободное место\nМеждууказателямииверсиямистрокможетоставатьсясвободноеместо(ко-\nс.31 тороеиотмеченовкартесвободногопространства).Никакойфрагментации\nвнутристраницынебывает,всесвободноеместовсегдапредставленоодним\nфрагментом1.\n3.2. Структура версий строк\nВерсиястрокисостоитиззаголовка,закоторымследуютсобственноданные.\nЗаголовокверсиисодержитмножествополей,средикоторых:\nxmin,xmax —номератранзакций,которыеотличаютданнуюверсиюотдру-\nгихверсийтойжестроки;\ninfomask —рядинформационныхбитов,определяющихсвойстваверсии;\nctid —ссылканаследующую,болееновуюверсиютойжестроки;\nбитоваякартанеопределенныхзначений —массивбитов,отмечающихстолб-\nцы,которыедопускаютнеопределенныезначения(NULL).\nВрезультатезаголовокполучаетсядовольнобольшой—минимум23байта\nна каждую версию строки, а обычно больше из-за карты неопределенных\nзначенийииз-заобязательноговыравниванияначаладанных.Для«узкой»\nтаблицы объем служебных данных вполне может превышать объем полез-\nнойинформации.\nФормат данных на диске полностью совпадает с представлением данных\nв оперативной памяти. Страница вместе с версиями строк читается в бу-\nферныйкеш«какесть»,безкакихбытонибылопреобразований.Поэтому\nфайлыданныхсоднойплатформыоказываютсянесовместимымисдруги-\nмиплатформами2.\n1 backend/storage/page/bufpage.c,функцияPageRepairFragmentation.\n2 include/access/htup_details.h.\n78",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.505696"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 80,
    "chapter": null,
    "section": "3.2 Структураверсийстрок",
    "text": "3.2. Структураверсийстрок\nОднаизпричиннесовместимости—порядокследованиябайтов.Например,\nв архитектуре x86 принят порядок от младших разрядов к старшим (little-\nendian), z/Architecture использует обратный порядок (big-endian), а в ARM\nпорядокпереключаемый.\nНесовместимость вызывается также выравниванием данных по границам\nмашинных слов,котороетребуется многим архитектурам.Например,в 32-\nбитной системе архитектуры x86 целые числа (тип integer, занимает че-\nтыре байта) будутвыровнены по границе четырехбайтных слов,как и чис-\nла с плавающей точкой двойной точности (тип double precision,восемь\nбайт).Ав64-битнойсистемезначенияdoubleбудутвыровненыпогранице\nвосьмибайтныхслов.\nИз-завыравниванияразмертабличнойстрокизависитотпорядкарасполо-\nженияполей.Обычноэтотэффектнесильнозаметен,новнекоторыхслуча-\nяхонможетпривестиксущественномуувеличениюразмера.Вотпример:\n=> CREATE TABLE padding(\nb1 boolean,\ni1 integer,\nb2 boolean,\ni2 integer\n);\n=> INSERT INTO padding VALUES (true,1,false,2);\n=> SELECT lp_len FROM heap_page_items(get_raw_page('padding', 0));\nlp_len\n−−−−−−−−\n40\n(1 row)\nЯиспользовалфункциюheap_page_items расширенияpageinspect,кото-\nраяпозволяетполучитьинформациюобуказателяхиверсияхстрок.\nСловомheap(куча)вPostgreSQLобозначаютсятаблицы.Этоещеодноневполнеоче-\nвидноеупотреблениетермина,намекающеенасходствомеханизмавыделенияместа\nпод версии строк с динамическим распределением оперативной памяти. Конечно,\nнекоторую аналогию усмотреть можно,но для управления таблицей используются\nсовсемдругиеалгоритмы.Можносчитать,чтословоупотребляетсявсмысле«всесва-\nленовкучу»,подчеркиваяотличиеотупорядоченныхиндексов.\nСтроказанимает40байт.Изних24байтауходитназаголовок,столбцыти-\nпаinteger занимаютпо4байта,boolean—по1байту.Всуммеимеем34,\n79",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.542884"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 81,
    "chapter": null,
    "section": "3.2 Структураверсийстрок",
    "text": "Глава3. Страницыиверсиистрок\nа6байтпропадаютиз-завыравниванияinteger пограницечетырехбайт-\nныхстрок.\nПерестроивтаблицу,можноиспользоватьместоболееэффективно:\n=> DROP TABLE padding;\n=> CREATE TABLE padding(\ni1 integer,\ni2 integer,\nb1 boolean,\nb2 boolean\n);\n=> INSERT INTO padding VALUES (1,2,true,false);\n=> SELECT lp_len FROM heap_page_items(get_raw_page('padding', 0));\nlp_len\n−−−−−−−−\n34\n(1 row)\nЕщеоднавозможнаямикрооптимизация—перенестивначалотаблицывсе\nстолбцыфиксированногоразмера,недопускающиенеопределенныхзначе-\nний.Доступктакимполямбудетболееэффективнымблагодарявозможно-\nстизакешироватьсмещениеполяотначалаверсиистроки1.\n3.3. Выполнение операций над версиями строк\nЧтобыразныеверсииоднойитойжестрокиможнобылоразличить,каждая\nизверсийимеетдвеотметки,определяющиеее«времядействия»,—xminи\nxmax.Ноиспользуетсяневремякактаковое,апостоянноувеличивающийся\nс.150 счетчикномеровтранзакций.\nКогда строка создается, значение xmin устанавливается равным номеру\nтранзакции,выполнившейкомандуINSERT.\nКогда строка удаляется,значению xmax текущей версии присваивается но-\nмертранзакции,выполнившейкомандуDELETE.\n1 backend/access/common/heaptuple.c,функцияheap_deform_tuple.\n80",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.761656"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 82,
    "chapter": null,
    "section": "3.3 Выполнениеоперацийнадверсиямистрок",
    "text": "3.3. Выполнениеоперацийнадверсиямистрок\nКоманду UPDATE можно в некотором приближении рассматривать как две\nоперации:DELETEиINSERT.Втекущейверсиистрокиустанавливаетсязна-\nчениеxmax,равноеномерутранзакции,выполнившейUPDATE.Затемсозда-\nетсяноваяверсиятойжестроки;значениеxminунеесовпадаетсозначени-\nемxmax предыдущейверсии.ТочнотакжеикомандаMERGE «распадается» v.15\nнаэлементарныевставкииудаления.\nДальшеяподробнопокажу,каквыполняютсяразныеоперациисверсиями\nстрокнанизкомуровне1.\nДляэкспериментовпонадобитсятаблицасдвумястолбцамиииндексомпо\nодномуизних:\n=> CREATE TABLE t(\nid integer GENERATED ALWAYS AS IDENTITY,\ns text\n);\n=> CREATE INDEX ON t(s);\nВставка\nВставляемоднустроку,предварительноначавтранзакцию:\n=> BEGIN;\n=> INSERT INTO t(s) VALUES ('FOO');\nВотномернашейтекущейтранзакции:\n=> -- txid_current() до v.13\nSELECT pg_current_xact_id();\npg_current_xact_id\n−−−−−−−−−−−−−−−−−−−−\n781\n(1 row)\nДляпонятиятранзакциивPostgreSQLчастоиспользуетсясокращениеxact,которое\nможнонайтиивименахфункций,ивкоде.Соответственно,номертранзакцииобозна-\nчаетсякакxactid,txidилидажепростоxid.Этиназванияещенеразнамвстретятся.\n1 backend/access/transam/README.\n81",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.791332"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 83,
    "chapter": null,
    "section": "3.3 Выполнениеоперацийнадверсиямистрок",
    "text": "Глава3. Страницыиверсиистрок\nЗаглянемвсодержимоестраницы.Функцияheap_page_itemsдаетнамвсю\nнеобходимую информацию, но показывает данные «как есть», в формате,\nсложномдлявосприятия:\n=> SELECT *\nFROM heap_page_items(get_raw_page('t',0))\n\\gx\n−[ RECORD 1 ]−−−−−−−−−−−−−−−−−−−\nlp | 1\nlp_off | 8160\nlp_flags | 1\nlp_len | 32\nt_xmin | 781\nt_xmax | 0\nt_field3 | 0\nt_ctid | (0,1)\nt_infomask2 | 2\nt_infomask | 2050\nt_hoff | 24\nt_bits |\nt_oid |\nt_data | \\x0100000009464f4f\nЧтобыразобраться,оставимтолькочастьинформацииирасшифруемнеко-\nторыестолбцы:\n=> SELECT '(0,'||lp||')' AS ctid,\nCASE lp_flags\nWHEN 0 THEN 'unused'\nWHEN 1 THEN 'normal'\nWHEN 2 THEN 'redirect to '||lp_off\nWHEN 3 THEN 'dead'\nEND AS state,\nt_xmin as xmin,\nt_xmax as xmax,\n(t_infomask & 256) > 0 AS xmin_committed,\n(t_infomask & 512) > 0 AS xmin_aborted,\n(t_infomask & 1024) > 0 AS xmax_committed,\n(t_infomask & 2048) > 0 AS xmax_aborted\nFROM heap_page_items(get_raw_page('t',0))\n\\gx\n82",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.815890"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 84,
    "chapter": null,
    "section": "3.3 Выполнениеоперацийнадверсиямистрок",
    "text": "3.3. Выполнениеоперацийнадверсиямистрок\n−[ RECORD 1 ]−−+−−−−−−−\nctid | (0,1)\nstate | normal\nxmin | 781\nxmax | 0\nxmin_committed | f\nxmin_aborted | f\nxmax_committed | f\nxmax_aborted | t\nВотчтоздесьсделано:\n• Указательlp приведенкобычномувидуидентификатораверсиистро-\nки:(номерстраницы,номеруказателя).\n• Расшифрованосостояниеуказателяlp_flags.Здесьонимеетзначение\nnormal—этозначит,чтоуказательдействительноссылаетсянаверсию\nстроки.\n• Из всех информационных битов пока выделены только две пары. Би-\nты xmin_committed и xmin_aborted показывают,зафиксированали и\nотменена ли транзакция с номером xmin. Аналогичную информацию\nотранзакцииxmaxдаютбитыxmax_committedиxmax_aborted.\nВрасширенииpageinspectестьфункцияheap_tuple_infomask_flags,расшиф- v.13\nровывающая все информационные биты,но я буду выводитьтолько те,что нужны\nвданныймомент,ивболеекомпактномвиде.\nИтак,привставкестрокивтабличнойстраницепоявилсяуказательсноме-\nром1,ссылающийсянапервуюипокаединственнуюверсиюстроки.\nПолеxmin вверсиистрокизаполненономеромтекущейтранзакции.Тран-\nзакция еще активна, поэтому биты xmin_committed и xmin_aborted не\nустановлены.\nПолеxmaxзаполненофиктивнымномером0,посколькуданнаяверсиястро-\nкинеудаленаиявляетсяактуальной.Транзакциинебудутобращатьвнима-\nниянаэтотномер,посколькуустановленбитxmax_aborted.\nМожетпоказаться странным,что битоборванной транзакции установлен утранзак-\nции, которой не было. Но с точки зрения изоляции это одно и то же: отмененная\nтранзакциянеоставляетследови,следовательно,несуществовала.\n83",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.849497"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 85,
    "chapter": null,
    "section": "3.3 Выполнениеоперацийнадверсиямистрок",
    "text": "Глава3. Страницыиверсиистрок\nТакойзапроснамещенеразпонадобится,поэтомуяобернуеговфункцию.\nАзаоднодлякомпактностивыводауберустолбцыинформационныхбитов,\nприписавстатустранзакциикееномеру:\n=> CREATE FUNCTION heap_page(relname text, pageno integer)\nRETURNS TABLE(ctid tid, state text, xmin text, xmax text)\nAS $$\nSELECT (pageno,lp)::text::tid AS ctid,\nCASE lp_flags\nWHEN 0 THEN 'unused'\nWHEN 1 THEN 'normal'\nWHEN 2 THEN 'redirect to '||lp_off\nWHEN 3 THEN 'dead'\nEND AS state,\nt_xmin || CASE\nWHEN (t_infomask & 256) > 0 THEN ' c'\nWHEN (t_infomask & 512) > 0 THEN ' a'\nELSE ''\nEND AS xmin,\nt_xmax || CASE\nWHEN (t_infomask & 1024) > 0 THEN ' c'\nWHEN (t_infomask & 2048) > 0 THEN ' a'\nELSE ''\nEND AS xmax\nFROM heap_page_items(get_raw_page(relname,pageno))\nORDER BY lp;\n$$ LANGUAGE sql;\nВтаком виде уже значительно понятнее,чтотворится в заголовке версии:\n=> SELECT * FROM heap_page('t',0);\nctid | state | xmin | xmax\n−−−−−−−+−−−−−−−−+−−−−−−+−−−−−−\n(0,1) | normal | 781 | 0 a\n(1 row)\nПохожую,носущественноменеедетальнуюинформациюможнополучить\nиизсамойтаблицы,используяпсевдостолбцыxminиxmax:\n=> SELECT xmin, xmax, * FROM t;\nxmin | xmax | id | s\n−−−−−−+−−−−−−+−−−−+−−−−−\n781 | 0 | 1 | FOO\n(1 row)\n84",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.881005"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 86,
    "chapter": null,
    "section": "3.3 Выполнениеоперацийнадверсиямистрок",
    "text": "3.3. Выполнениеоперацийнадверсиямистрок\nФиксация\nПриуспешномзавершениитранзакциинужнозапомнитьеестатус—отме-\nтить,чтооназафиксирована.Дляэтогоиспользуетсяструктура,называемая\nclog1(commitlog).Этонетаблицасистемногокаталога,аспециальныефай-\nлывкаталогеPGDATA/pg_xact.\nНанесколькофайловclogразбитисключительнодляудобства.Работасэти-\nми файлами ведется постранично,через буферы в общей памяти сервера. с.299\nРазмер кеша clog настраивается параметром transaction_buffers, а по умол- v.17\nчаниюсоставляет 1 размерабуферногокеша.\n512\nВclog,какивзаголовкеверсиистроки,длякаждойтранзакцииотведенодва\nбита:committedиaborted.\nИтак,прификсациитранзакциивclogвыставляетсябитcommittedдлядан-\nной транзакции. Когда какая-либо другая транзакция обратится к нашей\nтабличнойстранице,ейпридетсяответитьнавопрос:завершиласьлитран-\nзакциясномеромxmin?\n• Еслинет,тосозданнаяверсиястрокинедолжнабытьвидна.\nЧтобы проверить, выполняется ли транзакция, просматривается еще\nодна структура, которая располагается в общей памяти экземпляра и\nназываетсяProcArray.Внейнаходитсясписоквсехактивныхпроцессов,\nидлякаждогоуказанномереготекущей(активной)транзакции.\n• Еслизавершилась,тофиксациейилиотменой?Приотменеверсиястро-\nкитоженедолжнабытьвидна.\nДля этой проверки как раз и нужна структура clog. Но хотя послед-\nние страницы clog сохраняются в буферах в оперативной памяти,все\n1 include/access/clog.h;\nbackend/access/transam/clog.c.\n85",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.911077"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 87,
    "chapter": null,
    "section": "3.3 Выполнениеоперацийнадверсиямистрок",
    "text": "Глава3. Страницыиверсиистрок\nравнотакуюпроверкунакладновыполнятькаждыйраз.Поэтомувыяс-\nненныйоднаждыстатустранзакциизаписываетсявзаголовокверсии\nстроки в информационные биты xmin_committed и xmin_aborted;\nихещеназываютбитами-подсказками(hintbits).Еслиодинизэтихби-\nтов установлен,то состояниетранзакции xmin считается известным,\nи следующей транзакции уже не придется обращаться ни к clog, ни\nкProcArray.\nПочему эти биты не устанавливаются той транзакцией,которая вставляет\nстроку?Деловтом,чтовэтовремятранзакцияещенезнает,завершитсяли\nона успешно.А в моментфиксации уже не понятно,какие именно строки\nв каких именно страницах были изменены.Таких страниц может оказать-\nсямного,изапоминатьихневыгодно.Ктомужечастьстраницможетбыть\nвытеснена из буферного кеша на диск; читать их заново,чтобы изменить\nбиты,означалобысущественнозамедлитьфиксацию.\nОбратнаясторонаэкономиисостоитвтом,чтолюбаятранзакция(дажевы-\nполняющая простое чтение— SELECT) можетначатьвыставлятьинформа-\nционные биты в страницах данных. Конечно, страницы в буферном кеше\nприэтомстановятсягрязными.\nЗафиксируемнаконецвставкустроки,скотороймыначалитранзакцию:\n=> COMMIT;\nВстраниценичегонеизменилось(номызнаем,чтостатустранзакцииуже\nзаписанвclog):\n=> SELECT * FROM heap_page('t',0);\nctid | state | xmin | xmax\n−−−−−−−+−−−−−−−−+−−−−−−+−−−−−−\n(0,1) | normal | 781 | 0 a\n(1 row)\nТеперьтранзакция,первойобратившаясякстранице(«нормальным»обра-\nзом,неспомощьюpageinspect),должнабудетопределитьстатустранзак-\nцииxminизаписатьеговинформационныебиты:\n86",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.945850"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 88,
    "chapter": null,
    "section": "3.3 Выполнениеоперацийнадверсиямистрок",
    "text": "3.3. Выполнениеоперацийнадверсиямистрок\n=> SELECT * FROM t;\nid | s\n−−−−+−−−−−\n1 | FOO\n(1 row)\n=> SELECT * FROM heap_page('t',0);\nctid | state | xmin | xmax\n−−−−−−−+−−−−−−−−+−−−−−−−+−−−−−−\n(0,1) | normal | 781 c | 0 a\n(1 row)\nУдаление\nПри удалении строки в поле xmax актуальной версии записывается номер\nудаляющейтранзакции,абитxmax_abortedсбрасывается.\nЭтожезначениеxmax,соответствующееактивнойтранзакции,выступаетвкачестве с.258\nблокировки строки. Если другая транзакция собирается обновить или удалить эту\nстроку,онабудетвынужденадождатьсязавершениятранзакцииxmax.\nУдалимстроку:\n=> BEGIN;\n=> DELETE FROM t;\n=> SELECT pg_current_xact_id();\npg_current_xact_id\n−−−−−−−−−−−−−−−−−−−−\n782\n(1 row)\nНомертранзакциизаписалсявполеxmax,ноинформационныебитыещене\nустановлены:\n=> SELECT * FROM heap_page('t',0);\nctid | state | xmin | xmax\n−−−−−−−+−−−−−−−−+−−−−−−−+−−−−−−\n(0,1) | normal | 781 c | 782\n(1 row)\n87",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.970856"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 89,
    "chapter": null,
    "section": "3.3 Выполнениеоперацийнадверсиямистрок",
    "text": "Глава3. Страницыиверсиистрок\nОтмена\nОтмена изменений работает аналогично фиксации и выполняется так же\nбыстро,тольковclogвместобитаcommittedвыставляетсябитaborted.Хоть\nкомандаиназываетсяROLLBACK,откатаизмененийнепроисходит:все,что\nтранзакцияуспелаизменитьвстраницахданных,остаетсянаместе.\n=> ROLLBACK;\n=> SELECT * FROM heap_page('t',0);\nctid | state | xmin | xmax\n−−−−−−−+−−−−−−−−+−−−−−−−+−−−−−−\n(0,1) | normal | 781 c | 782\n(1 row)\nПриобращениикстраницепроверяетсястатус,ивверсиистрокиустанав-\nливается бит-подсказка xmax_aborted.Сам номер xmax при этом остается\nвстранице,носмотретьнанегоужениктонебудет:\n=> SELECT * FROM t;\nid | s\n−−−−+−−−−−\n1 | FOO\n(1 row)\n=> SELECT * FROM heap_page('t',0);\nctid | state | xmin | xmax\n−−−−−−−+−−−−−−−−+−−−−−−−+−−−−−−−\n(0,1) | normal | 781 c | 782 a\n(1 row)\nОбновление\nОбновлениеработаеттак,какбудтосначалавыполнилосьудалениетекущей\nверсиистроки,азатем—вставкановой:\n=> BEGIN;\n=> UPDATE t SET s = 'BAR';\n=> SELECT pg_current_xact_id();\n88",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:45.997192"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 90,
    "chapter": null,
    "section": "3.4 Индексы",
    "text": "3.4. Индексы\npg_current_xact_id\n−−−−−−−−−−−−−−−−−−−−\n783\n(1 row)\nЗапросвыдаетоднустроку(новуюверсию):\n=> SELECT * FROM t;\nid | s\n−−−−+−−−−−\n1 | BAR\n(1 row)\nНовстраницехранятсяобеверсии:\n=> SELECT * FROM heap_page('t',0);\nctid | state | xmin | xmax\n−−−−−−−+−−−−−−−−+−−−−−−−+−−−−−−\n(0,1) | normal | 781 c | 783\n(0,2) | normal | 783 | 0 a\n(2 rows)\nУдаленная ранее версия помечена номером текущей транзакции в поле\nxmax.Это значение записано поверх старого,поскольку предыдущаятран-\nзакциябылаотменена.Абитxmax_abortedсброшен,таккакстатустекущей\nтранзакцииещенеизвестен.\nНуизавершимтранзакцию.\n=> COMMIT;\n3.4. Индексы\nВ индексах любого типа никогда не бывает версий строк, каждая строка\nпредставлена ровно одним экземпляром.Иными словами,в заголовке ин-\nдекснойстрокинебываетполейxminиxmax.Ссылкиизиндексаведутнавсе\nтабличныеверсиистрок.Транзакциитребуетсязаглянутьвтаблицу,чтобы с.115\nразобраться,какая из версий ей видна (еслитолько страница не отмечена\nвкартевидимости).\n89",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.023214"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 91,
    "chapter": null,
    "section": "3.4 Индексы",
    "text": "Глава3. Страницыиверсиистрок\nДля удобства создадим простую функцию,показывающую с помощью рас-\nширенияpageinspectвсеиндексныезаписинастранице(впределахстра-\nс.513 ницыB-деревазаписирасполагаютсяввидеплоскогосписка):\n=> CREATE FUNCTION index_page(relname text, pageno integer)\nRETURNS TABLE(itemoffset smallint, htid tid)\nAS $$\nSELECT itemoffset,\nhtid -- ctid до v.13\nFROM bt_page_items(relname,pageno);\n$$ LANGUAGE sql;\nОбнаруживаемнастраницеуказателинаобеверсиитабличнойстроки,как\nнаактуальную,такинастарую:\n=> SELECT * FROM index_page('t_s_idx',1);\nitemoffset | htid\n−−−−−−−−−−−−+−−−−−−−\n1 | (0,2)\n2 | (0,1)\n(2 rows)\nПосколькуBAR<FOO,указательнавторуюверсиюстрокистоитвиндексе\nнапервомместе.\n3.5. TOAST\nс.33 Toast-таблица является, по сути, обычной таблицей, и для нее поддержи-\nвается собственная версионность: версии «тостов» не связаны с версиями\nстрокосновнойтаблицы.Новнутренняяработасtoast-таблицейпостроена\nтак,чтострокиникогданеобновляются,атолькодобавляютсяиудаляются,\nтакчтоверсионностьвданномслучаенескольковырожденная.\nКогдаданныеменяются,восновнойтаблицевсегдасоздаетсяноваяверсия\nстроки.Ноеслиобновлениенезатрагивает«длинное»значение,хранящее-\nся в TOAST,то новая версия строки будет ссылаться на прежнее значение\nв toast-таблице.Итолько когдаобновление поменяет«длинное» значение,\nбудутсозданыиноваяверсиястрокивосновнойтаблице,иновые«тосты».\n90",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.054244"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 92,
    "chapter": null,
    "section": "3.6 Виртуальные транзакции",
    "text": "3.6. Виртуальныетранзакции\n3.6. Виртуальные транзакции\nPostgreSQL использует оптимизацию, позволяющую «экономить» номера\nтранзакций.\nЕслитранзакциятолькочитаетданные,тоонаникакневлияетнавидимость\nверсийстрок.Поэтомувначалеобслуживающийпроцессвыдаеттранзакции\nвиртуальный номер1(virtual xid). Номер состоитиз идентификатора обслу- с.249\nживающего процесса и последовательного числа. Выдача этого номера не\nтребует синхронизации между всеми процессами и поэтому выполняется\nоченьбыстро.Настоящегономераутранзакцииещенет:\n=> BEGIN;\n=> -- txid_current_if_assigned() до v.13\nSELECT pg_current_xact_id_if_assigned();\npg_current_xact_id_if_assigned\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n(1 row)\nВ разные моменты времени в системе вполне могут оказаться виртуаль-\nныетранзакциисномерами,которыеужеиспользовались.Иэтонормально,\nпоскольку виртуальные номера существуюттолько в оперативной памяти,\nпокатранзакцияактивна;ониникогданезаписываютсявстраницыданных\nинепопадаютнадиск.\nЕслижетранзакцияначинаетменятьданные,ейвыдаетсянастоящий,уни-\nкальныйномертранзакции:\n=> UPDATE accounts\nSET amount = amount - 1.00;\n=> SELECT pg_current_xact_id_if_assigned();\npg_current_xact_id_if_assigned\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n785\n(1 row)\n=> COMMIT;\n1 postgrespro.ru/docs/postgresql/17/transaction-id;\nbackend/access/transam/xact.c.\n91",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.084317"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 93,
    "chapter": null,
    "section": "3.7 Вложенные транзакции",
    "text": "Глава3. Страницыиверсиистрок\n3.7. Вложенные транзакции\nТочки сохранения\nВ SQL определены точки сохранения (savepoint), которые позволяют отме-\nнитьчастьоперацийтранзакции,непрерываяееполностью.Ноэтонеукла-\nдываетсявприведеннуювышесхему,посколькустатустранзакцииодинна\nвсеизменения,афизическиникакиеданныенеоткатываются.\nЧтобыреализоватьтакойфункционал,транзакциясточкойсохраненияраз-\nбиваетсянанескольковложенныхтранзакций1(subtransaction),статусомко-\nторыхможноуправлятьотдельно.\nВложенныетранзакции имеютсвой собственный номер (больший,чем но-\nмер основной транзакции). Статус вложенных транзакций записывается\nвclogобычнымобразом,нозафиксированныевложенныетранзакцииодно-\nвременно отмечаютсядвумя битами,committed и aborted.Финальный ста-\nтус зависит от статуса основной транзакции: если она отменена,то и все\nвложенныетранзакциисчитаютсяотмененными.\nИнформацияовложенноститранзакцийхранитсявфайлахвнутрикаталога\nPGDATA/pg_subtrans,аобращениекстраницамэтихфайловпроисходитче-\nс.299 резSLRU-кеш.Егоразмернастраиваетсяпараметромsubtransaction_buffers,\nапоумолчаниюсоставляет 1 размерабуферногокеша.\n512\nНепутайтевложенныетранзакциисавтономными.Автономныетранзакцииникакне\nзависятдруготдруга,в отличие отвложенных.Автономныхтранзакций в обычном\nPostgreSQLнет,и,пожалуй,клучшему:поделуонинужныоченьиоченьредко,аих\nналичиевдругихСУБДпровоцируетзлоупотребления,откоторыхпотомвсестрадают.\nОпустошимтаблицу,начнемтранзакциюивставимстроку:\n=> TRUNCATE TABLE t;\n=> BEGIN;\n=> INSERT INTO t(s) VALUES ('FOO');\n=> SELECT pg_current_xact_id();\n1 postgrespro.ru/docs/postgresql/17/subxacts;\nbackend/access/transam/subtrans.c.\n92",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.117840"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 94,
    "chapter": null,
    "section": "3.7 Вложенныетранзакции",
    "text": "3.7. Вложенныетранзакции\npg_current_xact_id\n−−−−−−−−−−−−−−−−−−−−\n787\n(1 row)\nТеперьпоставимточкусохраненияивставимещеоднустроку:\n=> SAVEPOINT sp;\n=> INSERT INTO t(s) VALUES ('XYZ');\n=> SELECT pg_current_xact_id();\npg_current_xact_id\n−−−−−−−−−−−−−−−−−−−−\n787\n(1 row)\nЗаметьте,что функция pg_current_xact_id выдаетномер основной,а не\nвложеннойтранзакции.\n=> SELECT *\nFROM heap_page('t',0) p\nLEFT JOIN t ON p.ctid = t.ctid;\nctid | state | xmin | xmax | id | s\n−−−−−−−+−−−−−−−−+−−−−−−+−−−−−−+−−−−+−−−−−\n(0,1) | normal | 787 | 0 a | 2 | FOO\n(0,2) | normal | 788 | 0 a | 3 | XYZ\n(2 rows)\nОткатимсякточкесохраненияивставимтретьюстроку:\n=> ROLLBACK TO sp;\n=> INSERT INTO t(s) VALUES ('BAR');\n=> SELECT *\nFROM heap_page('t',0) p\nLEFT JOIN t ON p.ctid = t.ctid;\nctid | state | xmin | xmax | id | s\n−−−−−−−+−−−−−−−−+−−−−−−+−−−−−−+−−−−+−−−−−\n(0,1) | normal | 787 | 0 a | 2 | FOO\n(0,2) | normal | 788 | 0 a | |\n(0,3) | normal | 789 | 0 a | 4 | BAR\n(3 rows)\nВ странице мы продолжаем видеть строку, добавленную отмененной вло-\nженнойтранзакцией.\n93",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.145038"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 95,
    "chapter": null,
    "section": "3.7 Вложенныетранзакции",
    "text": "Глава3. Страницыиверсиистрок\nФиксируемизменения:\n=> COMMIT;\n=> SELECT * FROM t;\nid | s\n−−−−+−−−−−\n2 | FOO\n4 | BAR\n(2 rows)\n=> SELECT * FROM heap_page('t',0);\nctid | state | xmin | xmax\n−−−−−−−+−−−−−−−−+−−−−−−−+−−−−−−\n(0,1) | normal | 787 c | 0 a\n(0,2) | normal | 788 a | 0 a\n(0,3) | normal | 789 c | 0 a\n(3 rows)\nТеперь хорошо видно, что каждая вложенная транзакция имеет собствен-\nныйстатус.\nВложенныетранзакциинельзяиспользоватьвSQLнапрямую,тоестьнельзя\nначатьновуютранзакцию,незавершивтекущую:\n=> BEGIN;\nBEGIN\n=> BEGIN;\nWARNING: there is already a transaction in progress\nBEGIN\n=> COMMIT;\nCOMMIT\n=> COMMIT;\nWARNING: there is no transaction in progress\nCOMMIT\nЭтотмеханизмзадействуетсянеявно:прииспользованииточексохранения,\nприобработкеисключенийPL/pgSQLивнекоторыхдругих,болееэкзотиче-\nскихслучаях.\nОшибки и атомарностьопераций\nЧто случится,если в процессе выполнения операции произойдет ошибка?\n94",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.168149"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 96,
    "chapter": null,
    "section": "3.7 Вложенныетранзакции",
    "text": "3.7. Вложенныетранзакции\nНапример:\n=> BEGIN;\n=> SELECT * FROM t;\nid | s\n−−−−+−−−−−\n2 | FOO\n4 | BAR\n(2 rows)\n=> UPDATE t SET s = repeat('X', 1/(id-4));\nERROR: division by zero\nПосле сбоятранзакция считается прерванной,и больше ни одна операция\nвнейнедопускается:\n=> SELECT * FROM t;\nERROR: current transaction is aborted, commands ignored until end\nof transaction block\nИдажееслипопытатьсязафиксироватьизменения,PostgreSQLсообщитоб\nотмене:\n=> COMMIT;\nROLLBACK\nПочему нельзя продолжить выполнение транзакции после сбоя? Посколь-\nку уже выполненные действия никогда не откатываются,мы получили бы\nдоступкчастиизменений,выполненныхдоошибки,—былабынарушена\nатомарностьдаженетранзакции,аоператора.\nКаквнашемпримере,гдеоператордоошибкиуспелобновитьоднустроку\nиздвух:\n=> SELECT * FROM heap_page('t',0);\nctid | state | xmin | xmax\n−−−−−−−+−−−−−−−−+−−−−−−−+−−−−−−\n(0,1) | normal | 787 c | 790\n(0,2) | normal | 788 a | 0 a\n(0,3) | normal | 789 c | 0 a\n(0,4) | normal | 790 | 0 a\n(4 rows)\n95",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.195393"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 97,
    "chapter": null,
    "section": "3.7 Вложенныетранзакции",
    "text": "Глава3. Страницыиверсиистрок\nКслову,вpsqlимеетсярежим,которыйвсе-такипозволяетпродолжатьра-\nботутранзакциипослесбоятак,какбудтодействияошибочногооператора\nоткатываются:\n=> \\set ON_ERROR_ROLLBACK on\n=> BEGIN;\n=> UPDATE t SET s = repeat('X', 1/(id-4));\nERROR: division by zero\n=> SELECT * FROM t;\nid | s\n−−−−+−−−−−\n2 | FOO\n4 | BAR\n(2 rows)\n=> COMMIT;\nCOMMIT\nНетруднодогадаться,чтовтакомрежимеpsqlфактическиставитпередкаж-\nдойкомандойнеявнуюточкусохранения,авслучаесбояинициируетоткат\nкней.Такойрежимнеиспользуетсяпоумолчанию,посколькуустановкато-\nчексохранения(дажебезоткатакним)сопряженассущественныминаклад-\nнымирасходами.\n96",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.210943"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 98,
    "chapter": null,
    "section": "4.1 Что такое снимок данных",
    "text": "4\nСнимки данных\n4.1. Что такое снимок данных\nФизическивстраницахданныхмогутнаходитьсянескольковерсийоднойи\nтой же строки, хотя каждая транзакция должна видеть максимум одну из\nних. Все вместе версии разных строк, наблюдаемые транзакцией, образу-\nют снимок данных (snapshot). Снимок обеспечивает согласованную в ACID- с.54\nсмыслекартинуданныхнаопределенныймоментвремениисодержиттоль-\nкосамыеактуальныеданные,зафиксированныекмоментуегосоздания.\nЧтобы обеспечить изоляцию, каждая транзакция работает со своим соб-\nственнымснимком.Приэтомразныетранзакциивидятразные,нотемне\nменеесогласованные(наразныемоментывремени)данные.\nНауровнеизоляцииReadCommittedснимоксоздаетсявначалекаждогоопе-\nраторатранзакциииостаетсяактивнымвсевремяработыэтогооператора.\nНауровняхRepeatableReadиSerializableснимоксоздаетсяодинразвначале\nпервогооператоратранзакциииостаетсяактивнымдосамогоконцатран-\nзакции.\nснимок1 снимок2 снимок\nоператор1 оператор2 оператор1 оператор2\nxid xid\nReadCommitted RepeatableRead,\nSerializable\n97",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 3,
        "content": "|  |"
      }
    ],
    "extracted_at": "2025-10-02T15:59:46.238771"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 99,
    "chapter": null,
    "section": "4.2 Видимость версий строк в снимке",
    "text": "Глава4. Снимкиданных\n4.2. Видимость версий строк в снимке\nКонечно,снимокданныхнеявляетсяфизическойкопиейвсехнеобходимых\nверсий строк. Фактически снимок задается несколькими числами, а види-\nмостьверсийстроквснимкеопределяетсяправилами.\nБудетданнаяверсиястрокивиднавснимкеилинет—зависитотполейxmin\nи xmax ее заголовка (то есть от номеров создавшей и удалившей транзак-\nций)иотсоответствующихэтимполяминформационныхбитов.Интервалы\nxmin–xmax непересекаются,поэтомукаждаястрокапредставленавлюбом\nснимкемаксимумоднойсвоейверсией.\nТочныеправилавидимости1довольносложныиучитываютмножествораз-\nличных ситуаций и крайних случаев.Упрощая,можно сказать,что версия\nстроки видна, когда в снимке видны изменения, сделанные транзакцией\nxmin, и не видны изменения, сделанные транзакцией xmax (иными слова-\nми,есливерсиястрокиужепоявилась,ноещенеудалена).\nВсвоюочередь,изменениятранзакциивиднывснимке,еслиэтатранзакция\nбылазафиксированадомоментасозданияснимка.Иеще,вкачествеисклю-\nченияизобщегоправила,транзакциявидитвснимкесвоисобственныееще\nнезафиксированныеизменения.Измененияоборванныхтранзакций,разу-\nмеется,ниводномснимкеневидны.\nВотпростойпример.Транзакцииизображеныввидеотрезков(отмомента\nначаладомоментафиксации):\nснимок\nxid\n1 2 3\n1 backend/access/heap/heapam_visibility.c.\n98",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 2,
        "content": "|"
      }
    ],
    "extracted_at": "2025-10-02T15:59:46.269361"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 100,
    "chapter": null,
    "section": "4.3 Из чего состоит снимок",
    "text": "4.3. Изчегосостоитснимок\nЗдесь:\n• изменениятранзакции2будутвидны,потомучтооназавершиласьдо\nсозданияснимка;\n• изменениятранзакции1небудутвидны,потомучтоонабылаактивна\nнамоментсозданияснимка;\n• изменениятранзакции3небудутвидны,потомучтоонаначаласьпоз-\nжесозданияснимка(неважно,закончиласьонаилинет).\n4.3. Из чего состоит снимок\nКсожалению,PostgreSQLвидиткартинусовсемнетак1,какбылопоказано\nнарисунке.Деловтом,чтосистеменеизвестно,когдатранзакциибылиза-\nфиксированы.Известнотолько,когдаониначинались(этотмоментопреде-\nляетсяномеромтранзакции),авотфактзавершениянигденезаписывается.\nВремяфиксацииотслеживается2привключенномпараметреtrack_commit_timestamp, off\nноононикакнеучаствуетвпроверкевидимости(хотяможетбытьполезным,напри-\nмер,длястороннихрепликационныхрешений).\nКрометого,PostgreSQLвсегдасохраняетвремяфиксацииивремяотменытранзакций\nвсоответствующихжурнальныхзаписях,ноиспользуетэтуинформациютолькопри с.201\nвосстановлениидоцелевойточки.\nУзнатьможнолишьтекущийстатустранзакций.Этаинформацияестьвоб-\nщей памяти сервера в структуре ProcArray, которая содержит список всех\nактивных сеансов и ихтранзакций. Постфактум же невозможно выяснить,\nбылаликакая-тотранзакцияактивнавмоментсозданияснимка.\nПоэтомудляполученияснимканедостаточносохранитьмоментегосозда-\nния:требуетсятакжезапомнить,вкакомстатусенаходилисьтранзакциина\nэтот момент.Без информации о статусах впоследствии невозможно будет\nпонять,какиеверсиистрокдолжныбытьвиднывснимке,акакие—нет.\n1 include/utils/snapshot.h.\nbackend/utils/time/snapmgr.c.\n2 backend/access/transam/commit_ts.c.\n99",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.300921"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 101,
    "chapter": null,
    "section": "4.3 Из чего состоит снимок",
    "text": "Глава4. Снимкиданных\nСравните,какаяинформациядоступнасистемевмоментсозданияснимкаи\nнекотороевремяспустя(белымкружкомобозначенаактивнаятранзакция,\nачерными—завершенные):\nxid xid\n1 2 3 1 2 3\nвмоментсозданияснимка черезнекотороевремя\nЕсли не запомнить,что во время создания снимка перваятранзакция еще\nвыполнялась,атретьейнесуществовало,ихневозможнобудетотличитьот\nзафиксированной на тот момент второй транзакции и исключить из рас-\nсмотрения.\nПо этой причине в PostgreSQL нельзя создать снимок, показывающий со-\nгласованныеданныепосостояниюнанекоторыймоментвпрошлом,даже\nесливсенеобходимыедляэтоговерсиистроксуществуютвтабличныхстра-\nницах.Соответственно,невозможно реализовать и ретроспективные (тем-\nпоральные,flashback)запросы.\nИнтересно,чтотакаяфункциональностьбылазаявленакакоднаизцелейPostgresи\nбылареализованассамогоначала,ноееубралиизСУБД,когдапроектбылвзятна\nподдержкусообществом1.\nИтак,снимокданных состоитиз нескольких значений,которые запомина-\nютсявмоментегосоздания2:\nНижняяграницаснимкаxmin, в качестве которой выступает номер самой\nстаройактивнойтранзакции.\nс.150 Всетранзакциисменьшиминомерамилибозафиксированы,итогдаих\nизменениявиднывснимке,либоотменены,итогдаизмененияигнори-\nруются.\n1 Джозеф Хеллерштейн. Postgres в ретроспективе // habr.com/ru/company/postgrespro/blog/\n438890.\n2 backend/storage/ipc/procarray.c,функцияGetSnapshotData.\n100",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.333468"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 102,
    "chapter": null,
    "section": "4.3 Изчегосостоитснимок",
    "text": "4.3. Изчегосостоитснимок\nВерхняяграницаснимкаxmax, вкачествекоторойберетсязначение,наеди-\nницу большее номера последней зафиксированной транзакции. Верх-\nняяграницаопределяетмоментвремени,вкоторыйбылсделанснимок.\nВсетранзакциисномерами,большимиилиравнымиxmax,незаверше-\nныилинесуществуют,ипоэтомуизменениятакихтранзакцийточноне\nвидны.\nСписокактивныхтранзакцийxip_list (xid-in-progress list),в который попа-\nдаютномеравсехактивныхтранзакций(меньшиеxmax),заисключени-\nемвиртуальных,которыеникакневлияютнавидимость. с.91\nТакжевснимкесохраняютсяещенесколькопараметров,ноонипоканетак\nважны.\nГрафическиможнопредставитьснимоккакпрямоугольник,охватывающий\nтранзакцииотxminдоxmax:\nxip_list\nxmin xmax\nxid\n1 2 3\nЧтобы посмотреть, как видимость определяется снимком, воспроизведем\nситуациюпопоказанномувышесценариюнатаблицеaccounts.\n=> TRUNCATE TABLE accounts;\nПерваятранзакциявставляетвтаблицупервуюстрокуиостаетсяактивной:\n=> BEGIN;\n=> INSERT INTO accounts VALUES (1, 'alice', 1000.00);\n=> SELECT pg_current_xact_id();\npg_current_xact_id\n−−−−−−−−−−−−−−−−−−−−\n795\n(1 row)\n101",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.361531"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 103,
    "chapter": null,
    "section": "4.3 Изчегосостоитснимок",
    "text": "Глава4. Снимкиданных\nВтораятранзакциявставляетвторуюстрокуисразузавершается:\n=> BEGIN;\n=> INSERT INTO accounts VALUES (2, 'bob', 100.00);\n=> SELECT pg_current_xact_id();\npg_current_xact_id\n−−−−−−−−−−−−−−−−−−−−\n796\n(1 row)\n=> COMMIT;\nВэтотмомент(вдругомсеансе)создаемновыйснимок.Дляэтогодостаточ-\nновыполнитьлюбойзапрос,номысразупосмотримнаснимокспомощью\nспециальнойфункции:\n=> BEGIN ISOLATION LEVEL REPEATABLE READ;\n=> -- txid_current_snapshot() до v.13\nSELECT pg_current_snapshot();\npg_current_snapshot\n−−−−−−−−−−−−−−−−−−−−−\n795:797:795\n(1 row)\nФункция выводит через двоеточие три составляющих снимка: поля xmin,\nxmaxисписокxip_list(состоящийвданномслучаеизодногономера).\nПослетогокакснимоксоздан,завершаемпервуютранзакцию:\n=> COMMIT;\nТретья транзакция выполняется после создания снимка и меняет вторую\nстроку.Появляетсяноваяверсия:\n=> BEGIN;\n=> UPDATE accounts SET amount = amount + 100 WHERE id = 2;\n=> SELECT pg_current_xact_id();\npg_current_xact_id\n−−−−−−−−−−−−−−−−−−−−\n797\n(1 row)\n=> COMMIT;\nВсозданномснимкевиднатолькооднаверсия:\n102",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.391582"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 104,
    "chapter": null,
    "section": "4.3 Изчегосостоитснимок",
    "text": "4.3. Изчегосостоитснимок\n=> SELECT ctid, * FROM accounts;\nctid | id | client | amount\n−−−−−−−+−−−−+−−−−−−−−+−−−−−−−−\n(0,2) | 2 | bob | 100.00\n(1 row)\nХотявтаблицеихтри:\n=> SELECT * FROM heap_page('accounts',0);\nctid | state | xmin | xmax\n−−−−−−−+−−−−−−−−+−−−−−−−+−−−−−−−\n(0,1) | normal | 795 c | 0 a\n(0,2) | normal | 796 c | 797 c\n(0,3) | normal | 797 c | 0 a\n(3 rows)\nКакPostgreSQLпонимает,какиеверсиипоказывать?Посформулированным\nвыше правилам в снимкевидны изменениятолькоследующихзафиксиро-\nванныхтранзакций:\n• с номерами xid < xmin —безусловно (например,транзакция,создав-\nшаятаблицуaccounts);\n• сномерамиxmin ⩽ xid < xmax—заисключениемпопавшихвсписок\nxip_list.\nПервая строка (0,1) не видна,так как номер создавшей еетранзакции вхо-\nдит в список активных транзакций (хотя и попадает при этом в диапазон\nснимка).\nПоследняяверсиявторойстроки(0,3)невидна,посколькусозданатранзак-\nциейсномером,выходящимзаверхнююграницуснимка.\nЗатовиднаперваяверсиявторойстроки(0,2):номерсоздавшейеетранзак-\nциипопадаетвдиапазонснимка,ноневходитвсписокактивныхтранзак-\nций (вставка видна),и при этом номер удалившейтранзакции выходитза\nверхнююграницуснимка(удалениеневидно).\n=> COMMIT;\n103",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.420355"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 105,
    "chapter": null,
    "section": "4.4 Видимость собственных изменений",
    "text": "Глава4. Снимкиданных\n4.4. Видимость собственных изменений\nКартину несколько усложняет определение видимости собственных изме-\nненийтранзакции,посколькувозможнаситуация,прикоторойдолжнабыть\nвидна только часть из них. Например, курсор, открытый в определенный\nмомент,ни при каком уровне изоляции не можетвидетьпоследующие из-\nменения.\nДля этого в заголовке версии строки естьспециальное поле (которое отоб-\nражаетсявпсевдостолбцахcminиcmax),показывающеепорядковыйномер\nоперациивнутритранзакции.Столбецcmin представляетномероперации\nвставки,а cmax —операции удаления,но для экономии места в заголовке\nстрокиэтонасамомделеоднополе,анедваразных.Считается,чтовставка\nиудалениетойжестрокиводнойтранзакциивыполняютсяредко.(Еслиэто\nвсе-такипроисходит,втожесамоеполезаписываетсяспециальный«комбо-\nномер»,для которого обслуживающий процесс запоминаетреальные cmin\nиcmax1.)\nВкачествепримераначнемтранзакциюивставимвтаблицустроку:\n=> BEGIN;\n=> INSERT INTO accounts VALUES (3, 'charlie', 100.00);\n=> SELECT pg_current_xact_id();\npg_current_xact_id\n−−−−−−−−−−−−−−−−−−−−\n798\n(1 row)\nТеперьоткроемкурсордлязапроса,возвращающегочислостроквтаблице:\n=> DECLARE c CURSOR FOR SELECT count(*) FROM accounts;\nИпослеэтоговставимещеоднустроку:\n=> INSERT INTO accounts VALUES (4, 'charlie', 200.00);\nВыведем содержимое таблицы,добавив столбец cmin для строк, вставлен-\nных нашейтранзакцией (длядругих строк это значение не имеетсмысла):\n1 backend/utils/time/combocid.c.\n104",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.454074"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 106,
    "chapter": null,
    "section": "4.5 Горизонттранзакции",
    "text": "4.5. Горизонттранзакции\n=> SELECT xmin, CASE WHEN xmin = 798 THEN cmin END cmin, *\nFROM accounts;\nxmin | cmin | id | client | amount\n−−−−−−+−−−−−−+−−−−+−−−−−−−−−+−−−−−−−−−\n795 | | 1 | alice | 1000.00\n797 | | 2 | bob | 200.00\n798 | 0 | 3 | charlie | 100.00\n798 | 1 | 4 | charlie | 200.00\n(4 rows)\nЗапрос курсора обнаружиттри строки,а не четыре—строка,добавленная\nпослеоткрытиякурсора,непопадетвснимокданных,посколькувнемучи-\nтываютсятольковерсиистроксcmin <1:\n=> FETCH c;\ncount\n−−−−−−−\n3\n(1 row)\nРазумеется,этотномерcminтакжезапоминаетсявснимке,новывестиего\nсредствамиSQLнеполучится.\n4.5. Горизонт транзакции\nНижняя граница снимка (номер xmin самой раннейтранзакции,активной\nна моментего создания) имеетважный смысл—она определяетгоризонт\nтранзакции,работающейсэтимснимком.\nГоризонттранзакциибезактивногоснимка(например,транзакциисуров-\nнемизоляцииReadCommittedмеждувыполнениямиоператоров)определя-\nетсяеесобственнымномером,еслионейприсвоен.\nВсе транзакции, находящиеся за горизонтом (то есть транзакции с номе-\nрами xid < xmin),уже гарантированно зафиксированы.А это значит,что\nза своим горизонтом транзакция всегда видит только актуальные версии\nстрок.\nНазваниенавеяно,конечно,понятиемгоризонтасобытийвфизике.\n105",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.481013"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 107,
    "chapter": null,
    "section": "4.5 Горизонттранзакции",
    "text": "Глава4. Снимкиданных\nPostgreSQL знает текущий горизонт транзакций всех процессов; собствен-\nныйгоризонттранзакцияможетувидетьвтаблицеpg_stat_activity:\n=> BEGIN;\n=> SELECT backend_xmin FROM pg_stat_activity\nWHERE pid = pg_backend_pid();\nbackend_xmin\n−−−−−−−−−−−−−−\n798\n(1 row)\nВиртуальные транзакции хоть и не имеют настоящего номера, но исполь-\nзуют снимки точно так же, как и обычные транзакции, и поэтому облада-\nют собственным горизонтом. Исключение составляют виртуальные тран-\nзакциибезактивногоснимка:длянихпонятиегоризонтанеимеетсмысла,\nиониполностью«прозрачны»длясистемысточкизренияснимковданных\nивидимости(несмотрянаточтовpg_stat_activity.backend_xminможет\nостатьсяномеротстарогоснимка).\nПохожимобразомможноопределитьигоризонтбазыданных.Дляэтогона-\nдовзятьгоризонтывсехтранзакций,работающихсэтойбазой,исрединих\nнайтинаиболее«дальний»,имеющийсамыйстарыйxmin1.Этоибудеттот\nгоризонт,закоторымнеактуальныеверсиистроквэтойбазеданныхужени-\nкогданебудутвидныниоднойтранзакции.Такиеверсиистрокмогутбыть\nбезопасноудаленыочисткой—именнопоэтомупонятиегоризонтатакважно\nспрактическойточкизрения.\nСделаемвыводыизсказанного:\n• еслитранзакциясуровнемизоляцииRepeatableReadилиSerializable(не\nважно,настоящаяиливиртуальная)выполняетсядолго,онатемсамым\nудерживаетгоризонтбазыданныхипрепятствуеточистке;\n• настоящая транзакция с уровнем изоляции Read Committed точно так\nжеудерживаетгоризонтбазыданных,выполняетлионаоператорили\nпростобездействует(находитсявсостоянииidleintransaction);\n• виртуальнаятранзакциясуровнемизоляцииReadCommittedудержива-\nетгоризонттольковпроцессевыполненияоператоров.\n1 backend/storage/ipc/procarray.c,функцияComputeXidHorizons.\n106",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.517084"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 108,
    "chapter": null,
    "section": "4.5 Горизонттранзакции",
    "text": "4.5. Горизонттранзакции\nгоризонт\nбазыданных\nнеактуальныеверсиистрок\nможновычищать\nxid\n1 2 3 4 5 6 7 8 9 10\nПри этом на всю базу данных есть только один горизонт, и если какая-то\nтранзакцияегоудерживает—онанедаеточищатьданныевнутриэтогого-\nризонта,дажете,ккоторымнеобращалась.\nДляобщекластерныхтаблицсистемногокаталогаиспользуетсяотдельныйгоризонт,\nучитывающийтранзакциивовсехбазахданных.Адлявременныхтаблиц,наоборот,\nненужноучитыватьникакиетранзакции,кромевыполняющихсявтекущемпроцессе.\nПродолжимпример.Транзакциявпервомсеанседосихпорвыполняетсяи\nпродолжаетудерживатьгоризонт,чтоможнопроверить,увеличивсчетчик\nтранзакций:\n=> SELECT pg_current_xact_id();\npg_current_xact_id\n−−−−−−−−−−−−−−−−−−−−\n799\n(1 row)\n=> SELECT backend_xmin FROM pg_stat_activity\nWHERE pid = pg_backend_pid();\nbackend_xmin\n−−−−−−−−−−−−−−\n798\n(1 row)\n107",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.546404"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 109,
    "chapter": null,
    "section": "4.5 Горизонттранзакции",
    "text": "Глава4. Снимкиданных\nИтолькопослезавершениятранзакциигоризонтпродвигаетсявперед,поз-\nволяяочисткеудалитьнеактуальныеверсиистрок:\n=> COMMIT;\n=> SELECT backend_xmin FROM pg_stat_activity\nWHERE pid = pg_backend_pid();\nbackend_xmin\n−−−−−−−−−−−−−−\n800\n(1 row)\nс.173 Видеаленеследуетсовмещатьактивныеобновления(порождающиеверсии\nстрок) сдолгимитранзакциями,поскольку это будетприводитьк раздува-\nниютаблицииндексов.\n4.6. Снимок данных для системного каталога\nХотясистемныйкаталогипредставленобычнымитаблицами,приобраще-\nнии к ним нельзя задействовать тот же снимок данных, что используется\nтранзакцией или оператором. Снимок должен быть достаточно «свежим»,\nчтобывключатьвсепоследниеизменения,ведьиначетранзакциямоглабы\nувидеть уже неактуальное определение столбцовтаблицы или пропустить\nсозданноеограничениецелостности.\nВотпростойпример:\n=> BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;\n=> SELECT 1; -- создан снимок для транзакции\n=> ALTER TABLE accounts ALTER amount SET NOT NULL;\n=> INSERT INTO accounts(client, amount) VALUES ('alice', NULL);\nERROR: null value in column \"amount\" of relation \"accounts\"\nviolates not−null constraint\nDETAIL: Failing row contains (1, alice, null).\n=> ROLLBACK;\n108",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.576230"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 110,
    "chapter": null,
    "section": "4.7 Экспортснимкаданных",
    "text": "4.7. Экспортснимкаданных\nКоманда INSERT «увидела» ограничение целостности, которое появилось\nужепослетого,какбылсозданснимокданныхтранзакции.Можетпоказать-\nся,чтотакоеповедениенарушаетизоляцию,ноеслибытранзакцияуспела\nобратитьсяктаблицеaccounts,токомандаALTER TABLE былабызаблоки-\nрованадоокончанияэтойтранзакции. с.251\nВ целом система ведет себя так, как будто для каждого обращения к си-\nстемномукаталогусоздаетсяновыйснимок.Нореализация1,конечно,более\nсложна, поскольку постоянное создание новых снимков негативно сказа-\nлось бы на производительности; кроме того, многие объекты системного\nкаталогакешируются,иэтотоженадоучитывать.\n4.7. Экспорт снимка данных\nБывают ситуации, когда несколько параллельных транзакций должны га-\nрантированновидетьоднуитужекартинуданных.Вкачествепримерамож-\nнопривестиутилитуpg_dump,умеющуюработатьвпараллельномрежиме:\nвсерабочиепроцессыдолжнывидетьбазуданныхводномитомжесостоя-\nнии,чтобырезервнаякопияполучиласьсогласованной.\nРазумеется,нельзя полагаться нато,что картиныданных совпадутпросто\nпотому, что транзакции запущены «одновременно». Такие гарантии дает\nмеханизмэкспортаиимпортаснимка.\nФункция pg_export_snapshot возвращает идентификатор снимка, кото-\nрый можетбыть передан в другуютранзакцию (внешними по отношению\nкСУБДсредствами):\n=> BEGIN ISOLATION LEVEL REPEATABLE READ;\n=> SELECT count(*) FROM accounts;\ncount\n−−−−−−−\n4\n(1 row)\n1 backend/utils/time/snapmgr.c,функцияGetCatalogSnapshot.\n109",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.606018"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 111,
    "chapter": null,
    "section": "4.7 Экспортснимкаданных",
    "text": "Глава4. Снимкиданных\n=> SELECT pg_export_snapshot();\npg_export_snapshot\n−−−−−−−−−−−−−−−−−−−−−\n00000011−00000008−1\n(1 row)\nПеред тем как выполнить первый оператор, другая транзакция может\nимпортировать снимок с помощью команды SET TRANSACTION SNAPSHOT.\nПредварительно надо установить уровень изоляции Repeatable Read или\nSerializable,потому что на уровне Read Committed операторы будут исполь-\nзоватьсобственныеснимки:\n=> DELETE FROM accounts;\n=> BEGIN ISOLATION LEVEL REPEATABLE READ;\n=> SET TRANSACTION SNAPSHOT '00000011-00000008-1';\nТеперь вторая транзакция будет работать со снимком первой и, соответ-\nственно,видетьчетырестроки(аненоль):\n=> SELECT count(*) FROM accounts;\ncount\n−−−−−−−\n4\n(1 row)\nРазумеется, изменения, сделанные первой транзакцией после экспорта\nснимка,не будутвидны второйтранзакции (и наоборот):действуютобыч-\nныеправилавидимости.\nВремяжизниэкспортированногоснимкасовпадаетсовременемжизниэкс-\nпортирующейтранзакции.\n=> COMMIT;\n=> COMMIT;\n110",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.632671"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 112,
    "chapter": null,
    "section": "5.1 Внутристраничная очистка",
    "text": "5\nВнутристраничная очистка\nи hot-обновления\n5.1. Внутристраничная очистка\nПри обращении к табличной странице — как при обновлении, так и при\nобычном чтении—может выполняться быстрая внутристраничная очист-\nка1.Этопроисходитводномизтрехслучаев:\n• Ранее выполненное обновление (UPDATE) не обнаружило достаточно\nместа,чтобыразместитьновуюверсиюстрокинаэтойжестранице.Та-\nкаяситуациязапоминаетсявзаголовкестраницы.\n• Табличнаястраницазаполненабольше,чемна90%.\n• Табличнаястраницазаполненабольше,чемназначениепараметрахра-\nненияfillfactor.\nPostgreSQL вставляет (INSERT) новую строку на страницу,только если\nэта страница заполнена менее, чем на fillfactor процентов. Остальное 100\nместоприберегаетсядляновыхверсийстрок,которыеполучаютсявре-\nзультатеобновлений(UPDATE).Созначениемпоумолчаниюместовтаб-\nлицахнерезервируется.\nВнутристраничнаяочисткаубираетсостраницыверсиистрок,невидимые\nниводномснимке(находящиесязагоризонтомбазыданных).Онаникогда с.106\nне выходит за одну табличную страницу, зато выполняется очень быстро.\nУказателинавычищенныеверсиистрокнеосвобождаются,таккакнаних\n1 backend/access/heap/pruneheap.c,функцияheap_page_prune_opt.\n111",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.657302"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 113,
    "chapter": null,
    "section": "5.1 Внутристраничная очистка",
    "text": "Глава5. Внутристраничнаяочисткаиhot-обновления\nмогутвестиссылкиизиндексов,аиндекс—этоужедругаястраница.Изэтих\nжесоображенийнеобновляютсяникартавидимости,никартасвободного\nпространства (получается, что освобожденное место используется для об-\nновлений,анедлявставок).\nТотфакт,что страница можеточищаться при чтении,означает,что опера-\nторSELECT можетвызватьизменениестраниц.Этоещеодинтакойслучай\nс.86 вдополнениекотложенномуизменениюбитов-подсказок.\nПосмотримнапримере,какработаетвнутристраничнаяочистка.Создадим\nтаблицусдвумястолбцамиииндексыпокаждомуизних:\n=> CREATE TABLE hot(id integer, s char(2000)) WITH (fillfactor = 75);\n=> CREATE INDEX hot_id ON hot(id);\n=> CREATE INDEX hot_s ON hot(s);\nЕсливстолбцеsхранитьтольколатинскиебуквы,каждаяверсиястрокибу-\nдетиметьфиксированныйразмер2004байта,несчитая24байтзаголовка.\nПараметр хранения fillfactor установлен в 75%. Значит, места на странице\nбудет хватать на четыре версии строки,но вставить получитсятолькотри.\nТеперьвставимоднустрокуинесколькоразизменимее:\n=> INSERT INTO hot VALUES (1, 'A');\n=> UPDATE hot SET s = 'B';\n=> UPDATE hot SET s = 'C';\n=> UPDATE hot SET s = 'D';\nВстраницесейчасчетыреверсиистроки:\n=> SELECT * FROM heap_page('hot',0);\nctid | state | xmin | xmax\n−−−−−−−+−−−−−−−−+−−−−−−−+−−−−−−−\n(0,1) | normal | 806 c | 807 c\n(0,2) | normal | 807 c | 808 c\n(0,3) | normal | 808 c | 809\n(0,4) | normal | 809 | 0 a\n(4 rows)\nКакиожидалось,мытолькочтопревысилипорогfillfactor.Наэтоуказывает\nс.75 разницамеждузначениямиpagesizeиupper—онапревышаетпорогв75%\nотразмерастраницы,составляющий6144байта:\n112",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.693554"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 114,
    "chapter": null,
    "section": "5.1 Внутристраничнаяочистка",
    "text": "5.1. Внутристраничнаяочистка\n=> SELECT upper, pagesize FROM page_header(get_raw_page('hot',0));\nupper | pagesize\n−−−−−−−+−−−−−−−−−−\n64 | 8192\n(1 row)\nПри следующем обращении к странице срабатывает внутристраничная\nочистка.Все неактуальные версии вычищаются; после этого на освободив-\nшеесяместодобавляетсяноваяверсия(0,5):\n=> UPDATE hot SET s = 'E';\n=> SELECT * FROM heap_page('hot',0);\nctid | state | xmin | xmax\n−−−−−−−+−−−−−−−−+−−−−−−−+−−−−−−\n(0,1) | dead | |\n(0,2) | dead | |\n(0,3) | dead | |\n(0,4) | normal | 809 c | 810\n(0,5) | normal | 810 | 0 a\n(5 rows)\nВерсии строк,оставшиеся после очистки,физически сдвигаются в сторону\nстаршихадресовстраницытак,чтобывсесвободноеместобылопредставле-\nно одним непрерывным фрагментом. Соответствующим образом изменя-\nютсяиуказатели.Благодаряэтомуневозникаетпроблемсфрагментацией\nсвободногоместавстранице.\nУказателинаудаленныеверсиистрокпоканельзяосвободить,посколькуна\nнихведутссылкиcиндекснойстраницы;статустакихуказателейменяется\nс normal на dead («мертвая» версия).Заглянем в первую страницу индекса\nhot_s(нулеваязанятаметаинформацией): с.519\n=> SELECT * FROM index_page('hot_s',1);\nitemoffset | htid\n−−−−−−−−−−−−+−−−−−−−\n1 | (0,1)\n2 | (0,2)\n3 | (0,3)\n4 | (0,4)\n5 | (0,5)\n(5 rows)\n113",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.723832"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 115,
    "chapter": null,
    "section": "5.1 Внутристраничнаяочистка",
    "text": "Глава5. Внутристраничнаяочисткаиhot-обновления\nТужекартинумыувидимивдругоминдексе:\n=> SELECT * FROM index_page('hot_id',1);\nitemoffset | htid\n−−−−−−−−−−−−+−−−−−−−\n1 | (0,1)\n2 | (0,2)\n3 | (0,3)\n4 | (0,4)\n5 | (0,5)\n(5 rows)\nПрииндексномдоступесерверможетполучить(0,1),(0,2)или(0,3)вкачестве\nидентификатораверсиистроки.Тогдаонпопробуетпрочитатьсоответству-\nющуюверсиюстрокиизтабличнойстраницы,нообнаружит,чтоуказатель\nимеет статус dead, то есть версия уже не существует и должна игнориро-\nваться.А заодно изменитстатус указателя и в индексной странице,чтобы\nповторнонеобращатьсяктаблице1.\nv.13 Расширимфункциюдляпросмотраиндекснойстраницы,добавивпризнак\n«мертвого»указателя:\n=> DROP FUNCTION index_page(text, integer);\n=> CREATE FUNCTION index_page(relname text, pageno integer)\nRETURNS TABLE(itemoffset smallint, htid tid, dead boolean)\nAS $$\nSELECT itemoffset,\nhtid,\ndead -- начиная с v.13\nFROM bt_page_items(relname,pageno);\n$$ LANGUAGE sql;\n=> SELECT * FROM index_page('hot_id',1);\nitemoffset | htid | dead\n−−−−−−−−−−−−+−−−−−−−+−−−−−−\n1 | (0,1) | f\n2 | (0,2) | f\n3 | (0,3) | f\n4 | (0,4) | f\n5 | (0,5) | f\n(5 rows)\n1 backend/access/index/indexam.c,функцияindex_fetch_heap.\n114",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.752352"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 116,
    "chapter": null,
    "section": "5.2 Hot-обновления",
    "text": "5.2. Hot-обновления\nПокавсеуказателинаиндекснойстраницеактивны.Ноприпервомжеоб-\nращенииктаблицепоиндексустатусуказателейменяется:\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT * FROM hot WHERE id = 1;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Scan using hot_id on hot (actual rows=1 loops=1)\nIndex Cond: (id = 1)\n(2 rows)\n=> SELECT * FROM index_page('hot_id',1);\nitemoffset | htid | dead\n−−−−−−−−−−−−+−−−−−−−+−−−−−−\n1 | (0,1) | t\n2 | (0,2) | t\n3 | (0,3) | t\n4 | (0,4) | t\n5 | (0,5) | f\n(5 rows)\nХотятабличнаястрока,накоторуюссылаетсячетвертыйуказатель,ещене\nвычищена и имеет статус normal, она уже ушла за горизонт базы данных.\nПоэтомуичетвертыйуказательвиндексепомеченкакмертвый.\n5.2. Hot-обновления\nДержатьвиндексессылкинавсеверсиикаждойстрокинеэффективно.\nВо-первых,прилюбомизменениистрокиприходитсяобновлятьвсеиндек-\nсы,созданныедлятаблицы:разпоявиласьноваяверсия,необходимоиметь\nнанеессылкиизкаждогоиндекса,дажееслиизменилисьполя,вэтотиндекс\nневходящие.\nВо-вторых, в индексах накапливаются ссылки на исторические версии\nстрок,которыепотомприходитсявычищатьвместессамимиверсиями. с.125\nЕстественно, чем больше индексов создано на таблице, тем с большими\nсложностямиприходитсясталкиваться.\n115",
    "tables": [
      {
        "table_index": 0,
        "rows": 4,
        "cols": 1,
        "content": "t\nt\nt\nt"
      }
    ],
    "extracted_at": "2025-10-02T15:59:46.783505"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 117,
    "chapter": null,
    "section": "5.2 Hot-обновления",
    "text": "Глава5. Внутристраничнаяочисткаиhot-обновления\nОднако если в результате обновления значения столбцов не изменились\nни в одном индексе, то нет смысла создавать в индексах дополнительную\nзапись,содержащуютежесамыезначения.\nС появлениемлишних индексных записей борется оптимизация,называе-\nмаяhot-обновлением1(Heap-OnlyTupleupdate).Такоеобновлениевозможно\nвтрехслучаях:\n• натаблиценесозданниодининдекс(вэтомслучаелюбоеобновление\nбудетhot-обновлением);\n• натаблицеестьиндексы,нообновляемыестолбцынеиспользуютсяни\nводномизних;\n• обновляемые столбцы используются в индексе, но их значения не из-\nменились.\nПодиспользованиемвиндексездесьпонимаетсяналичиеиндекса(полно-\nго или частичного) по столбцу или по выражению, содержащему столбец,\nатакжеучастиевкачественеключевогостолбцавinclude-индексе—тоесть\nлюбаявозможнаяссылканастолбецвкомандеCREATE INDEX.Исключение\nv.16 составляютлишьиндексыBRIN:внихнетссылокнатабличныестрокиипо-\nс.628 этомуониникакнемешаютhot-обновлениям.\nПриhot-обновлениивиндекснойстраницеприсутствуетлишьодназапись\nсидентификаторомсамойпервойверсиитабличнойстроки.Всеостальные\nверсиитойжестрокивнутритабличнойстраницысвязанывцепочкууказа-\nтелямиctidвзаголовкахверсий.\nВерсии,на которые нетссылок из индекса,маркируются битом Heap-Only\nTuple(«толькотабличнаяверсиястроки»).Еслижеверсиявходитвцепочку,\nонапомечаетсябитомHeapHotUpdated.\nЕслиприсканированиииндексасерверпопадаетвтабличнуюстраницуиоб-\nнаруживает версию с флагом Heap Hot Updated, он понимает, что не надо\nостанавливаться,и проходитдальше по всей цепочке обновлений.Разуме-\nется,длявсехпрочитанныхтакимобразомверсийстрокпроверяетсявиди-\nмость,преждечемклиентполучитрезультат.\n1 backend/access/heap/README.HOT.\n116",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.818258"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 118,
    "chapter": null,
    "section": "5.2 Hot-обновления",
    "text": "5.2. Hot-обновления\nЧтобыпосмотретьнаработуhot-обновления,удалимодининдексиопусто-\nшимтаблицу.\n=> DROP INDEX hot_s;\n=> TRUNCATE TABLE hot;\nДляудобствапересоздадимфункциюheap_page,дополниввыводтремяпо-\nлями—ctidидвумябитами,относящимисякhot-обновлению:\n=> DROP FUNCTION heap_page(text,integer);\n=> CREATE FUNCTION heap_page(\nrelname text,\npageno integer\n)\nRETURNS TABLE(\nctid tid,\nstate text,\nxmin text,\nxmax text,\nhhu text,\nhot text,\nt_ctid tid\n) AS $$\nSELECT (pageno,lp)::text::tid AS ctid,\nCASE lp_flags\nWHEN 0 THEN 'unused'\nWHEN 1 THEN 'normal'\nWHEN 2 THEN 'redirect to '||lp_off\nWHEN 3 THEN 'dead'\nEND AS state,\nt_xmin || CASE\nWHEN (t_infomask & 256) > 0 THEN ' c'\nWHEN (t_infomask & 512) > 0 THEN ' a'\nELSE ''\nEND AS xmin,\nt_xmax || CASE\nWHEN (t_infomask & 1024) > 0 THEN ' c'\nWHEN (t_infomask & 2048) > 0 THEN ' a'\nELSE ''\nEND AS xmax,\nCASE WHEN (t_infomask2 & 16384) > 0 THEN 't' END AS hhu,\nCASE WHEN (t_infomask2 & 32768) > 0 THEN 't' END AS hot,\nt_ctid\nFROM heap_page_items(get_raw_page(relname,pageno))\nORDER BY lp;\n$$ LANGUAGE sql;\n117",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.846229"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 119,
    "chapter": null,
    "section": "5.2 Hot-обновления",
    "text": "Глава5. Внутристраничнаяочисткаиhot-обновления\nПовторяемвставкуиобновлениестроки:\n=> INSERT INTO hot VALUES (1, 'A');\n=> UPDATE hot SET s = 'B';\nВстраницепоявиласьhot-цепочкаизменений:\n• флагHeapHotUpdatedговоритотом,чтонадоидтидальшепоцепочке\nctid;\n• флагHeapOnlyTupleпоказывает,чтонаданнуюверсиюстрокинетссы-\nлокизиндексов.\n=> SELECT * FROM heap_page('hot',0);\nctid | state | xmin | xmax | hhu | hot | t_ctid\n−−−−−−−+−−−−−−−−+−−−−−−−+−−−−−−+−−−−−+−−−−−+−−−−−−−−\n(0,1) | normal | 817 c | 818 | t | | (0,2)\n(0,2) | normal | 818 | 0 a | | t | (0,2)\n(2 rows)\nПридальнейших изменениях цепочка будетрасти—нотолько в пределах\nстраницы:\n=> UPDATE hot SET s = 'C';\n=> UPDATE hot SET s = 'D';\n=> SELECT * FROM heap_page('hot',0);\nctid | state | xmin | xmax | hhu | hot | t_ctid\n−−−−−−−+−−−−−−−−+−−−−−−−+−−−−−−−+−−−−−+−−−−−+−−−−−−−−\n(0,1) | normal | 817 c | 818 c | t | | (0,2)\n(0,2) | normal | 818 c | 819 c | t | t | (0,3)\n(0,3) | normal | 819 c | 820 | t | t | (0,4)\n(0,4) | normal | 820 | 0 a | | t | (0,4)\n(4 rows)\nПри этом в индексе обнаруживаем одну-единственную ссылку на «голову»\nцепочки:\n=> SELECT * FROM index_page('hot_id',1);\nitemoffset | htid | dead\n−−−−−−−−−−−−+−−−−−−−+−−−−−−\n1 | (0,1) | f\n(1 row)\n118",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:46.879135"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 120,
    "chapter": null,
    "section": "5.3 Внутристраничнаяочисткаприhot-обновлениях",
    "text": "5.3. Внутристраничнаяочисткаприhot-обновлениях\nЦепочка hot-обновлений не выходит за рамки страницы, поэтому обход\nвсейцепочкиникогданетребуетобращениякдругимстраницаминеухуд-\nшаетпроизводительность.\nТипобновленийотслеживаетсякакчастьстатистикииспользованиятабли-\nцы.ВданномслучаеизсемиоперацийUPDATEтрибылиhot-обновлениями:\n=> SELECT n_tup_upd, n_tup_hot_upd\nFROM pg_stat_all_tables\nWHERE relid = 'hot'::regclass;\nn_tup_upd | n_tup_hot_upd\n−−−−−−−−−−−+−−−−−−−−−−−−−−−\n7 | 3\n(1 row)\n5.3. Внутристраничная очистка при hot-обновлениях\nЧастный,новажныйслучайвнутристраничнойочисткипредставляетсобой\nочисткаприhot-обновлениях.\nВначатомпримереужепревышенпорогfillfactor,такчтоследующееобнов-\nлениедолжнопривестиквнутристраничнойочистке.Нонаэтотразвстрани-\nценаходитсяцепочкаобновлений.«Голова»этойhot-цепочкивсегдадолжна\nоставатьсянасвоемместе,посколькунанеессылаетсяиндекс,аостальные\nуказателимогутбытьосвобождены,ведьнанихточнонетссылокизвне.\nЧтобы нетрогать«голову»,применяетсядвойная адресация: указатель,на\nкоторыйссылаетсяиндекс,—вданномслучае(0,1)—получаетстатусredirect\nиведетнаверсиюстроки,скоторойвданныймоментначинаетсяцепочка:\n=> UPDATE hot SET s = 'E';\n=> SELECT * FROM heap_page('hot',0);\nctid | state | xmin | xmax | hhu | hot | t_ctid\n−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−+−−−−−−+−−−−−+−−−−−+−−−−−−−−\n(0,1) | redirect to 4 | | | | |\n(0,2) | normal | 821 | 0 a | | t | (0,2)\n(0,3) | unused | | | | |\n(0,4) | normal | 820 c | 821 | t | t | (0,2)\n(4 rows)\n119",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.124076"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 121,
    "chapter": null,
    "section": "5.3 Внутристраничнаяочисткаприhot-обновлениях",
    "text": "Глава5. Внутристраничнаяочисткаиhot-обновления\nЗдесьверсии(0,1),(0,2)и(0,3)быливычищены,«головной»указатель1остал-\nся перенаправлятьдоступ,а указатели 2 и 3 были освобождены (получили\nстатусunused),посколькунаэтиверсиигарантированнонебылоссылокиз\nиндексов.Новаяверсиястрокибылазаписананаосвободившеесяместопод\nномером(0,2).\nВыполнимобновлениеещенесколькораз:\n=> UPDATE hot SET s = 'F';\n=> UPDATE hot SET s = 'G';\nHot-цепочкавыросла:\n=> SELECT * FROM heap_page('hot',0);\nctid | state | xmin | xmax | hhu | hot | t_ctid\n−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−+−−−−−−−+−−−−−+−−−−−+−−−−−−−−\n(0,1) | redirect to 4 | | | | |\n(0,2) | normal | 821 c | 822 c | t | t | (0,3)\n(0,3) | normal | 822 c | 823 | t | t | (0,5)\n(0,4) | normal | 820 c | 821 c | t | t | (0,2)\n(0,5) | normal | 823 | 0 a | | t | (0,5)\n(5 rows)\nСледующееобновлениесновавызываетвнутристраничнуюочистку:\n=> UPDATE hot SET s = 'H';\n=> SELECT * FROM heap_page('hot',0);\nctid | state | xmin | xmax | hhu | hot | t_ctid\n−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−+−−−−−−+−−−−−+−−−−−+−−−−−−−−\n(0,1) | redirect to 5 | | | | |\n(0,2) | normal | 824 | 0 a | | t | (0,2)\n(0,3) | unused | | | | |\n(0,4) | unused | | | | |\n(0,5) | normal | 823 c | 824 | t | t | (0,2)\n(5 rows)\nОпятьчастьверсийвычищена,ауказательна«голову»соответствующимоб-\nразомсдвинут.\n120",
    "tables": [
      {
        "table_index": 0,
        "rows": 2,
        "cols": 1,
        "content": "=> UPDATE hot SET s = 'F';\n=> UPDATE hot SET s = 'G';"
      }
    ],
    "extracted_at": "2025-10-02T15:59:47.157475"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 122,
    "chapter": null,
    "section": "5.4 Разрыв hot-цепочки",
    "text": "5.4. Разрывhot-цепочки\n5.4. Разрыв hot-цепочки\nЕслинастраниценехватитсвободногоместа,чтобыразместитьновуювер-\nсиюстроки,цепочкапрервется.Наверсиюстроки,размещеннуюнадругой\nстранице,придетсясделатьотдельнуюссылкуизиндекса.\nЧтобы получитьтакую ситуацию,начнем параллельную транзакцию и по-\nстроимвнейснимокданных,которыйнедаствычищатьверсиистрок:\n=> BEGIN ISOLATION LEVEL REPEATABLE READ;\n=> SELECT 1;\nТеперьвыполнимобновлениявпервомсеансе:\n=> UPDATE hot SET s = 'I';\n=> UPDATE hot SET s = 'J';\n=> UPDATE hot SET s = 'K';\n=> SELECT * FROM heap_page('hot',0);\nctid | state | xmin | xmax | hhu | hot | t_ctid\n−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−+−−−−−−−+−−−−−+−−−−−+−−−−−−−−\n(0,1) | redirect to 2 | | | | |\n(0,2) | normal | 824 c | 825 c | t | t | (0,3)\n(0,3) | normal | 825 c | 826 c | t | t | (0,4)\n(0,4) | normal | 826 c | 827 | t | t | (0,5)\n(0,5) | normal | 827 | 0 a | | t | (0,5)\n(5 rows)\nПриследующемобновленииместанастраницеуженехватит,авнутристра-\nничнаяочистканесможетничегоосвободить:\n=> UPDATE hot SET s = 'L';\n=> COMMIT; -- снимок больше не нужен\n121",
    "tables": [
      {
        "table_index": 0,
        "rows": 3,
        "cols": 1,
        "content": "=> UPDATE hot SET s = 'I';\n=> UPDATE hot SET s = 'J';\n=> UPDATE hot SET s = 'K';"
      }
    ],
    "extracted_at": "2025-10-02T15:59:47.188855"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 123,
    "chapter": null,
    "section": "5.4 Разрыв hot-цепочки",
    "text": "Глава5. Внутристраничнаяочисткаиhot-обновления\n=> SELECT * FROM heap_page('hot',0);\nctid | state | xmin | xmax | hhu | hot | t_ctid\n−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−+−−−−−−−+−−−−−+−−−−−+−−−−−−−−\n(0,1) | redirect to 2 | | | | |\n(0,2) | normal | 824 c | 825 c | t | t | (0,3)\n(0,3) | normal | 825 c | 826 c | t | t | (0,4)\n(0,4) | normal | 826 c | 827 c | t | t | (0,5)\n(0,5) | normal | 827 c | 828 | | t | (1,1)\n(5 rows)\nВверсии(0,5)видимссылку(1,1),ведущуюнастраницу1:\n=> SELECT * FROM heap_page('hot',1);\nctid | state | xmin | xmax | hhu | hot | t_ctid\n−−−−−−−+−−−−−−−−+−−−−−−+−−−−−−+−−−−−+−−−−−+−−−−−−−−\n(1,1) | normal | 828 | 0 a | | | (1,1)\n(1 row)\nВпрочем,этассылканеиспользуется,посколькувверсии (0,5) неустанов-\nлен бит Heap Hot Updated. А на версию (1,1) можно попасть из индекса,\nв котором теперь две ссылки. Каждая из них ведет на начало своей hot-\nцепочки:\n=> SELECT * FROM index_page('hot_id',1);\nitemoffset | htid | dead\n−−−−−−−−−−−−+−−−−−−−+−−−−−−\n1 | (0,1) | f\n2 | (1,1) | f\n(2 rows)\nv.16 Разрывыhot-цепочекотслеживаютсявстатистикеотдельно:\n=> SELECT n_tup_upd, n_tup_hot_upd, n_tup_newpage_upd\nFROM pg_stat_all_tables\nWHERE relid = 'hot'::regclass;\nn_tup_upd | n_tup_hot_upd | n_tup_newpage_upd\n−−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−\n15 | 10 | 1\n(1 row)\nЗдесьиз пятнадцати операций UPDATE одиннадцатьбыли hot-обновления-\nми:десятихватиломестанастранице,аоднойнет,чтопривелокразрыву\nцепочки.\n122",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.226538"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 124,
    "chapter": null,
    "section": "5.5 Внутристраничная очистка индексов",
    "text": "5.5. Внутристраничнаяочисткаиндексов\nПри частых обновлениях столбцов, не входящих в индексы, может иметь\nсмыслуменьшитьпараметрfillfactor,чтобызарезервироватьнекотороемес-\nто на странице для обновлений. Конечно, надо учитывать, что чем ниже\nfillfactor,тембольшеостаетсянезанятогоместанастранице,и,соответствен-\nно,физическийразмертаблицыувеличивается.\n5.5. Внутристраничная очистка индексов\nЯговорилотом,чтовнутристраничнаяочисткаработаетсоднойтабличной\nстраницейинетрогаетиндексы.Ноидляиндексовестьсобственнаявнут-\nристраничнаяочистка1,котораятожеработаетсодной(ноужеиндексной)\nстраницей.\nТакая очистка происходит,когда при вставке строки в B-дерево на индекс-\nной странице не оказывается места и еетребуется расщепить (split),пере-\nраспределивданныемеждудвумяновымистраницами.Проблемавтом,что\nприудалениистрокдвеиндексныестраницыужене«склеиваются»водну.\nЭто приводит к раздуванию индекса, а однажды выросший размер может\nне уменьшиться даже при удалении существенной части данных. Но если\nвнутристраничной очистке удается убрать часть строк, момент расщепле-\nнияможетбытьотложен.\nЕстьдвавидастрок,которыемогутудалятьсяизиндексавнутристраничной\nочисткой.\nВ первую очередьудаляются строки,помеченные ранее как мертвые2.Как\nяужеговорил,такаяпометкаставитсяприиндексномдоступе,еслиоказы-\nвается,чтоиндекснаязаписьссылаетсянаверсиюстроки,котораяневидна\nниводномснимкеилиуженесуществует.\nЕслизаведомомертвыхстрокненашлось,проверяютсястроки,ссылающие- v.14\nсянаразныеверсииоднойитойжетабличнойстроки3.Из-замноговерсион-\nностиприобновленияхможетвозникатьбольшоеколичествонеактуальных\n1 postgrespro.ru/docs/postgresql/17/btree-implementation#BTREE-DELETION.\n2 backend/access/nbtree/README,разделSimpledeletion.\n3 backend/access/nbtree/README,разделBottom-Updeletion;\ninclude/access/tableam.h.\n123",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.261771"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 125,
    "chapter": null,
    "section": "5.5 Внутристраничная очистка индексов",
    "text": "Глава5. Внутристраничнаяочисткаиhot-обновления\nверсий строк,которые,скорее всего,достаточно быстро уйдутза горизонт\nбазы данных.Hot-обновления смягчают этот эффект,но работают не всег-\nда:еслиобновляемыйстолбецвходитвкакой-нибудьиндекс,ссылкинавсе\nверсии строк появляются и во всех остальных индексах. Перед расщепле-\nниемстраницыимеетсмыслпоискатьвнейстроки,ещенепомеченныекак\nмертвые,ноужедопускающиеочистку.Дляэтогонадопроверитьвидимость\nсоответствующихверсийстрок,чтотребуетобращенияктабличнойстрани-\nце.Поэтомурассматриваютсяневсе,атолько«перспективные»индексные\nстроки,появившиеся как копия существующихдля нужд многоверсионно-\nсти. Заплатить цену проверки видимости таких строк оказывается выгод-\nнее,чемдопуститьлишнеерасщеплениеиндекснойстраницы.\n124",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.276735"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 126,
    "chapter": null,
    "section": "6.1 Очистка вручную",
    "text": "6\nОчистка и автоочистка\n6.1. Очистка вручную\nВнутристраничная очистка выполняется быстро, но освобождает только\nчасть места. Она работает в пределах одной табличной страницы и не за-\nтрагиваетиндексы(илинаоборот:впределаходнойиндекснойинезатра-\nгиваеттаблицу).\nОсновная, обычная очистка1 выполняется командой VACUUM2. Она обраба-\nтываеттаблицуполностью,вычищаянетольконенужныеверсиистрок,но\nиссылкинанихизвсехиндексов.\nОчистка работаетпараллельно сдругой активностью в системе.Таблица и\nиндексы при этом могут использоваться обычным образом и для чтения,\nи для изменения (однако одновременное выполнение таких команд, как\nCREATEINDEX,ALTERTABLE,инекоторыхдругихбудетневозможно). с.251\nЧтобы не просматривать лишних страниц, используется карта видимости. с.32\nОтмеченные в ней страницы пропускаются,поскольку содержаттолько ак-\nтуальныеверсиистрок,авотвостальныхмогутбытьверсии,которыеможно\nвычистить. Очистка обновляет карту видимости, если после обработки на\nстраницеостаютсятольковерсиистрокзагоризонтомбазыданных.\nОчисткаобновляетикартусвободногопространства,отражаяпоявившееся\nвстраницахсвободноеместо.\n1 postgrespro.ru/docs/postgresql/17/routine-vacuuming.\n2 postgrespro.ru/docs/postgresql/17/sql-vacuum;\nbackend/commands/vacuum.c.\n125",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.302741"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 127,
    "chapter": null,
    "section": "6.1 Очистка вручную",
    "text": "Глава6. Очисткаиавтоочистка\nСоздадимтаблицуииндекс:\n=> CREATE TABLE vac(\nid integer,\ns char(100)\n) WITH (autovacuum_enabled = off);\n=> CREATE INDEX vac_s ON vac(s);\nЗдесь с помощью параметра хранения autovacuum_enabled отключается ав-\nтоматическаяочистка,чтобы—исключительнодляцелейэксперимента—\nточноуправлятьмоментомочистки.\nДобавляемстрокуивыполняемпаруобновлений:\n=> INSERT INTO vac(id,s) VALUES (1,'A');\n=> UPDATE vac SET s = 'B';\n=> UPDATE vac SET s = 'C';\nСейчасвтаблицетриверсиистроки:\n=> SELECT * FROM heap_page('vac',0);\nctid | state | xmin | xmax | hhu | hot | t_ctid\n−−−−−−−+−−−−−−−−+−−−−−−−+−−−−−−−+−−−−−+−−−−−+−−−−−−−−\n(0,1) | normal | 831 c | 832 c | | | (0,2)\n(0,2) | normal | 832 c | 833 | | | (0,3)\n(0,3) | normal | 833 | 0 a | | | (0,3)\n(3 rows)\nНакаждуюизнихведетссылкаизиндекса:\n=> SELECT * FROM index_page('vac_s',1);\nitemoffset | htid | dead\n−−−−−−−−−−−−+−−−−−−−+−−−−−−\n1 | (0,1) | f\n2 | (0,2) | f\n3 | (0,3) | f\n(3 rows)\nПослеочисткимертвыеверсиистрокпропадают,иостаетсятолькоодна,ак-\nтуальная:\n=> VACUUM vac;\n126",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.331799"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 128,
    "chapter": null,
    "section": "6.1 Очисткавручную",
    "text": "6.1. Очисткавручную\n=> SELECT * FROM heap_page('vac',0);\nctid | state | xmin | xmax | hhu | hot | t_ctid\n−−−−−−−+−−−−−−−−+−−−−−−−+−−−−−−+−−−−−+−−−−−+−−−−−−−−\n(0,1) | unused | | | | |\n(0,2) | unused | | | | |\n(0,3) | normal | 833 c | 0 a | | | (0,3)\n(3 rows)\nПриэтомдвапервыхуказателя,ссылавшихсянавычищенныеверсии,полу-\nчилистатусunused,анеdead,какбылобыпривнутристраничнойочистке,\nпосколькунанихбольшенетссылокизиндекса:\n=> SELECT * FROM index_page('vac_s',1);\nitemoffset | htid | dead\n−−−−−−−−−−−−+−−−−−−−+−−−−−−\n1 | (0,3) | f\n(1 row)\nУказателивстатусеunusedсчитаютсясвободнымиимогутбытьзадейство-\nваныдляновыхверсийстрок.\nСтраница теперь отмечена в карте видимости, куда мы можем заглянуть\nспомощьюрасширенияpg_visibility:\n=> CREATE EXTENSION pg_visibility;\n=> SELECT all_visible\nFROM pg_visibility_map('vac',0);\nall_visible\n−−−−−−−−−−−−−\nt\n(1 row)\nПризнактого,чтовсеверсиистрокнастраницевиднывовсехснимкахдан-\nных,проставляетсяивзаголовкетабличнойстраницы:\n=> SELECT flags & 4 > 0 AS all_visible\nFROM page_header(get_raw_page('vac',0));\nall_visible\n−−−−−−−−−−−−−\nt\n(1 row)\n127",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.362125"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 129,
    "chapter": null,
    "section": "6.2 Еще раз о горизонте базы данных",
    "text": "Глава6. Очисткаиавтоочистка\n6.2. Еще раз о горизонте базы данных\nОчистка определяет, какие версии строк считать мертвыми, используя го-\nризонтбазыданных.Этонастольковажноепонятие,чтокнемуследуетвер-\nнутьсяещераз.\nПовторимпредыдущийопытсначала:\n=> TRUNCATE vac;\n=> INSERT INTO vac(id,s) VALUES (1,'A');\n=> UPDATE vac SET s = 'B';\nНопередтемкаксноваобновитьстроку,начнемвторуютранзакцию,удер-\nс.106 живающую горизонт базы данных (подойдет практически любая транзак-\nция, кроме виртуальной с уровнем изоляции Read Committed). Например,\nпустьтранзакцияпоменяетчто-нибудьвдругойтаблице.\n=> BEGIN;\n=> INSERT INTO accounts(id, client, amount)\nVALUES (1, 'alice', 1000.00);\n=> UPDATE vac SET s = 'C';\nСейчасвтаблицетриверсиистроки,авиндексе—триссылки.Чтоизменит-\nсяпослеочистки?\n=> VACUUM vac;\n=> SELECT * FROM heap_page('vac',0);\nctid | state | xmin | xmax | hhu | hot | t_ctid\n−−−−−−−+−−−−−−−−+−−−−−−−+−−−−−−−+−−−−−+−−−−−+−−−−−−−−\n(0,1) | unused | | | | |\n(0,2) | normal | 837 c | 839 c | | | (0,3)\n(0,3) | normal | 839 c | 0 a | | | (0,3)\n(3 rows)\n=> SELECT * FROM index_page('vac_s',1);\nitemoffset | htid | dead\n−−−−−−−−−−−−+−−−−−−−+−−−−−−\n1 | (0,2) | f\n2 | (0,3) | f\n(2 rows)\n128",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.393464"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 130,
    "chapter": null,
    "section": "6.2 Ещеразогоризонтебазыданных",
    "text": "6.2. Ещеразогоризонтебазыданных\nЕсливпрошлыйразвтаблицеосталасьтолькооднаверсиястроки,тотеперь\nихдве:очисткарешила,чтоверсия(0,2)ещенеможетбытьудалена.Причи-\nна,конечно,вгоризонтебазыданных,которыйвнашемпримереопределя-\nетсянезавершеннойтранзакцией:\n=> SELECT backend_xmin FROM pg_stat_activity\nWHERE pid = pg_backend_pid();\nbackend_xmin\n−−−−−−−−−−−−−−\n838\n(1 row)\nМожнопопроситьочисткурассказатьотом,чтопроисходит,указавпредло-\nжениеVERBOSE:\n=> VACUUM VERBOSE vac;\nINFO: vacuuming \"internals.public.vac\"\nINFO: finished vacuuming \"internals.public.vac\": index scans: 0\npages: 0 removed, 1 remain, 1 scanned (100.00% of total)\ntuples: 0 removed, 2 remain, 1 are dead but not yet removable\nremovable cutoff: 838, which was 2 XIDs old when operation ended\nfrozen: 0 pages from table (0.00% of total) had 0 tuples frozen\nindex scan not needed: 0 pages from table (0.00% of total) had 0\ndead item identifiers removed\navg read rate: 0.000 MB/s, avg write rate: 0.000 MB/s\nbuffer usage: 14 hits, 0 misses, 0 dirtied\nWAL usage: 0 records, 0 full page images, 0 bytes\nsystem usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s\nVACUUM\nЗдесьвидно,что:\n• втаблиценеобнаруженоверсийстрок,которыеможнобылобыудалить\n(tuples:0removed);\n• найденодвеверсии,которыеудалятьнельзя(2remain);\n• однаизнеудаляемыхстрокмертвая(1aredeadbutnotyetremovable),\nдругая—актуальная;\n• текущийгоризонточистки(removablecutoff)совпадаетсгоризонтом\nоткрытойтранзакции.\n129",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.430485"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 131,
    "chapter": null,
    "section": "6.2 Ещеразогоризонтебазыданных",
    "text": "Глава6. Очисткаиавтоочистка\nЗавершениеоткрытойтранзакцииприводитктому,чтогоризонтбазыдан-\nныхпродвигаетсяипозволяетпродолжитьочистку:\n=> COMMIT;\n=> VACUUM VERBOSE vac;\nINFO: vacuuming \"internals.public.vac\"\nINFO: finished vacuuming \"internals.public.vac\": index scans: 1\npages: 0 removed, 1 remain, 1 scanned (100.00% of total)\ntuples: 1 removed, 1 remain, 0 are dead but not yet removable\nremovable cutoff: 840, which was 0 XIDs old when operation ended\nnew relfrozenxid: 839, which is 2 XIDs ahead of previous value\nfrozen: 0 pages from table (0.00% of total) had 0 tuples frozen\nindex scan needed: 1 pages from table (100.00% of total) had 1 dead\nitem identifiers removed\nindex \"vac_s\": pages: 2 in total, 0 newly deleted, 0 currently\ndeleted, 0 reusable\navg read rate: 0.000 MB/s, avg write rate: 84.005 MB/s\nbuffer usage: 18 hits, 0 misses, 1 dirtied\nWAL usage: 6 records, 1 full page images, 8841 bytes\nsystem usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s\nVACUUM\nОчисткаобнаружилаушедшуюзаизменившийсягоризонтмертвуюверсию\nиудалилаее.\nТеперьвстраницеосталасьтолькопоследняя,актуальнаяверсиястроки:\n=> SELECT * FROM heap_page('vac',0);\nctid | state | xmin | xmax | hhu | hot | t_ctid\n−−−−−−−+−−−−−−−−+−−−−−−−+−−−−−−+−−−−−+−−−−−+−−−−−−−−\n(0,1) | unused | | | | |\n(0,2) | unused | | | | |\n(0,3) | normal | 839 c | 0 a | | | (0,3)\n(3 rows)\nВиндексетакжетолькоодназапись:\n=> SELECT * FROM index_page('vac_s',1);\nitemoffset | htid | dead\n−−−−−−−−−−−−+−−−−−−−+−−−−−−\n1 | (0,3) | f\n(1 row)\n130",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.469819"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 132,
    "chapter": null,
    "section": "6.3 Этапы выполнения очистки",
    "text": "6.3. Этапывыполненияочистки\n6.3. Этапы выполнения очистки\nРаботаочисткивыглядитнесложной,ноэтокажущаясяпростота.Ведьитаб-\nлицу, и индексы надо обрабатывать одновременно, не блокируя при этом\nработу остальных процессов.Для этого очистка каждойтаблицы выполня-\nетсявнесколькоэтапов1.\nВначалетаблицасканируетсявпоискахмертвыхверсийстрок;найденные\nверсии вычищаются сперва из индекса, а затем из таблицы. Этот процесс\nможетповторяться,еслимертвыхверсийоказалосьслишкоммного.Вконце\nработытаблицаможетбытьусечена.\nСканирование таблицы v.17\nВсе начинается со сканирования таблицы2 с учетом карты видимости: от-\nмеченные в карте страницы пропускаются, поскольку гарантированно со-\nдержаттолькоактуальныеверсиистрок.Идентификаторы(tid)техверсий\nстрокизпрочитанныхстраниц,чтовыходятзагоризонтибольшененужны,\nзаписываютсявспециальноехранилищевпамяти.Сразуудалятьэтиверсии\nстрокнельзя,посколькунанихмогутссылатьсяиндексы.\nХранилищепредставляетсобойпрефиксноедерево3.Ключомвнемслужат с.590\nномерастраниц,авузлаххранятсябитовыекартыверсийстрок.Структура с.414\nограниченавразмерахзначениемпараметраmaintenance_work_mem;память 64MB\nподнеевыделяетсяпомеренеобходимости.\nПо сравнению с обычным массивом,который использовался до PostgreSQL 17,пре-\nфиксноедеревохранитидентификаторынапорядоккомпактнее,аегообщийразмер\nможетпревышать1Гбайт—максимальныйразмерфрагмента,выделяемоговпамяти\nзаодинраз.\n1 backend/access/heap/vacuumlazy.c,функцияheap_vacuum_rel.\n2 backend/access/heap/vacuumlazy.c,функцияlazy_scan_heap.\n3 backend/access/common/tidstore.c.\n131",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.501273"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 133,
    "chapter": null,
    "section": "6.3 Этапы выполнения очистки",
    "text": "Глава6. Очисткаиавтоочистка\nОчистка индексов\nДальшевозможноодноиздвух:либосканированиедоходитдоконцатабли-\nцы,либозаканчиваетсяпамять,выделеннаяподидентификаторы.Влюбом\nизэтихслучаевначинаетсяэтапочисткииндексов1.Дляэтогокаждыйизин-\nдексов,созданныхдлятаблицы,полностьюсканируетсявпоискахзаписей,\nкоторые ссылаются на запомненные версии строк. Найденные записи вы-\nчищаютсяизиндексныхстраниц.\nИндекспозволяетбыстронайтиверсиюстроки,еслиизвестенключиндексирования,\nнонетспособабыстронайтииндекснуюстроку,знаяидентификатортабличнойвер-\nсии.РаботавэтомнаправлениидляB-деревьевпоканепривелакуспеху2.\nv.13 Для каждого индекса, размер которого превышает значение параметра\n512kB min_parallel_index_scan_size,можетзапускатьсяотдельныйрабочийпроцесс;\nвэтомслучаеочистканесколькихиндексовбудетпроисходитьвпараллель-\nномрежиме.Вдополнениекобщимограничениямначислофоновыхпро-\nцессов3всистеме,предельноеколичествопроцессовочисткиможноуказать\nв команде VACUUM (parallel N). Но поскольку один индекс не может об-\nрабатыватьсянесколькимипроцессамиодновременно,процессоввлюбом\nслучаебудетзапущенонебольше,чемимеетсяподходящихиндексов.\nНаэтапеочисткииндексоввыполняетсяработапоподдержаниюкартысво-\nбодного пространства в актуальном состоянии и вычислению статистики\nработыочистки.Ноэтотэтапбудетпропущен,еслистрокитолькодобавля-\nются(нонеудаляютсяинеизменяются),посколькувтакомслучаевтаблице\nнебудетниодноймертвойверсии.Тогдаочисткаиндексоввыполнитсяпри-\nнудительноодинразвконце,врамкахотдельногоэтапа«уборки»индексов4.\nИтак, после этого этапа в индексах уже нет ссылок на ненужные версии\nстрок,носамиверсииещеприсутствуютвтаблице.Этонормальнаяситуа-\nция:прииндексномдоступенанихуженевозможнопопасть,априпосле-\nдовательном сканированиитаблицы мертвые версии будут отметены про-\nверкойвидимости.\n1 backend/access/heap/vacuumlazy.c,функцияlazy_vacuum_all_indexes.\n2 commitfest.postgresql.org/21/1802.\n3 postgrespro.ru/docs/postgresql/17/bgworker.\n4 backend/access/heap/vacuumlazy.c,функцияlazy_cleanup_all_indexes;\nbackend/access/nbtree/nbtree.c,функцияbtvacuumcleanup.\n132",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.543118"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 134,
    "chapter": null,
    "section": "6.3 Этапывыполненияочистки",
    "text": "6.3. Этапывыполненияочистки\nОчистка таблицы\nЗатемначинаетсяэтапочисткитаблицы1.Таблицасновасканируется:это\nнеобходимо,чтобывычиститьизстраницзапомненныеранееверсиистрок\nиосвободитьуказатели.Теперь,когдассылокизиндексовуженет,этомож-\nносделатьбезопасно.\nОсвобожденное при очистке место записывается в карту свободного про-\nстранства,а страницы,на которыхосталисьтолько актуальные версии,ви-\nдимыевовсехснимках,отмечаютсявкартевидимости.\nЕслинаэтапесканированиятаблицанебылапрочитанаполностью,тохра-\nнилище tid очищается,и все повторяется стого места,на котором скани-\nрованиетаблицыостановилосьвпрошлыйраз.\nУсечение таблицы\nПослеочисткивтабличныхстраницахпоявляетсясвободноеместо;иногда\nможетпосчастливитьсяосвободитьстраницуцеликом.Есливконцефайла\nобразовалось некоторое количество пустых страниц,очистка может «отку-\nсить» хвостовую часть файла и вернуть место операционной системе.Это\nпроисходитназаключительномэтапеусечениятаблицы2.\nУсечениетребуеткратковременной исключительной блокировки натабли- с.251\nцу. Попытки получить блокировку продолжаются не дольше пяти секунд,\nчтобынеостанавливатьнадолгоработудругихпроцессов.\nИз-занеобходимостиблокироватьработустаблицейусечениевыполняется,\nтолькоеслипустыхстраницдостаточномного:какминимум 1 частьфайла\n16\nили,длябольшихтаблиц,1000страниц(этипороговыезначенияненастра-\nиваются).\nЕслиблокировкавызываетпроблемы,даженесмотрянаэтимерыпредосто- v.12\nрожности, усечение можно полностью отключить с помощью параметров\nхраненияvacuum_truncateиtoast.vacuum_truncate.\n1 backend/access/heap/vacuumlazy.c,функцияlazy_vacuum_heap.\n2 backend/access/heap/vacuumlazy.c,функцияlazy_truncate_heap.\n133",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.577994"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 135,
    "chapter": null,
    "section": "6.4 Анализ",
    "text": "Глава6. Очисткаиавтоочистка\n6.4. Анализ\nВ дополнение к очистке есть еще одна задача, никак с ней формально не\nс.333 связанная:анализ1,или,инымисловами,сборстатистическойинформации\nдляпланировщиказапросов.Статистикавключаетвсебяколичествострок\n(pg_class.reltuples)истраниц(pg_class.relpages)вотношениях,рас-\nпределениеданныхпостолбцамтаблицидругиесведения.\nВручнуюанализможновыполнятьсампосебекомандойANALYZE2,номож-\nно и совмещать с очисткой: VACUUM ANALYZE. Правда, при этом очистка и\nанализвыполняютсяпоследовательно—никакойэкономиинепроисходит.\nИсторически вариант VACUUM ANALYZE возник первым, в версии 6.1, а отдельная\nкомандаANALYZEпоявиласьтольковверсии7.2.Вболеераннихверсияхстатистика\nобновляласьскриптомнаTCL.\nАвтоматическая очистка и автоматический анализ настраиваются схожим\nобразом,поэтомуудобнорассматриватьобезадачивместе.\n6.5. Автоматическая очистка и анализ\nКогда горизонт базы данных не удерживается надолго, обычная очистка\nдолжнасправлятьсясосвоейработой.Вопросвтом,какчастоееследуетвы-\nзывать.\nЕсли очищатьизменяющуюсятаблицу слишком редко,она вырастетв раз-\nмерахбольше,чемхотелосьбы.Крометого,внейможетнакопитьсяслиш-\nком много изменений, и тогда очередной очистке потребуется совершить\nнесколькопроходовпоиндексам.\nЕслиочищатьтаблицуслишкомчасто,товместополезнойработысервербу-\nдетпостояннозаниматьсяобслуживанием.\nКтомуженагрузкаможетизменятьсясовременем,такчтозапускочистки\nпо какому-либо фиксированному расписанию в любом случае не годится:\nчемчащеобновляетсятаблица,темчащееенадоиочищать.\n1 postgrespro.ru/docs/postgresql/17/routine-vacuuming#VACUUM-FOR-STATISTICS.\n2 backend/commands/analyze.c.\n134",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.612193"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 136,
    "chapter": null,
    "section": "6.5 Автоматическаяочисткаианализ",
    "text": "6.5. Автоматическаяочисткаианализ\nЗадача решается автоматической очисткой1— механизмом, который поз-\nволяет запускать очистку и анализ в зависимости от скорости изменения\nтаблиц.\nУстройство автоочистки\nПри включенной автоматической очистке (конфигурационный параметр\nautovacuum) в системе всегда присутствует процесс autovacuum launcher, on\nответственный за расписание. Он поддерживает список баз данных, в ко-\nторых есть какая-либо активность, что определяется по статистике их ис-\nпользования. Такая статистика собирается при установленном параметре\ntrack_counts.Неследуетвыключатьэтипараметры,иначеавтоочистканебу- on\nдетработать.\nРаз в autovacuum_naptime единиц времени процесс autovacuum launcher за- 1min\nпускает (как обычно,с помощью postmaster) рабочий процесс autovacuum\nworker2длякаждой«активной»базыданныхизсписка.Соответственно,ес-\nливкластереиспользуетсянесколькобазданных(N штук),тозаинтервал\nautovacuum_naptime будет запущено N рабочих процессов.Но при этом об-\nщееколичествоодновременновыполняющихсярабочихпроцессовограни-\nченозначениемпараметраautovacuum_max_workers. 3\nРабочие процессы автоочистки очень напоминают фоновые рабочие процессы,но\nпоявилисьзадолгодотого,какбылсозданэтотмеханизмзаданийобщеговида.Реа-\nлизациюпроцессовавтоочисткинесталименять,поэтомуонинезадействуютслоты\nизmax_worker_processes.\nЗапустившись,рабочийпроцессподключаетсякуказаннойемубазеданных\nиначинаетстого,чтостроитдвасписка:\n• списоквсехтаблиц,материализованныхпредставленийиtoast-таблиц,\nтребующихочистки;\n• список всех таблиц и материализованных представлений,требующих\nанализа(toast-таблицынеанализируются,потомучтообращениекним\nвсегдапроисходитпоиндексу).\n1 postgrespro.ru/docs/postgresql/17/routine-vacuuming#AUTOVACUUM.\n2 backend/postmaster/autovacuum.c.\n135",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.647083"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 137,
    "chapter": null,
    "section": "6.5 Автоматическаяочисткаианализ",
    "text": "Глава6. Очисткаиавтоочистка\nДальшерабочийпроцесспоочередиочищаетилианализируетотобранные\nобъекты(иливыполняетитоидругое),послечегозавершается.\nОчистка каждой таблицы происходит так же, как при запуске команды\nVACUUMвручную.Ноестьнекоторыеотличия:\n• Очистка,запускаемая вручную,используетдля накопления идентифи-\nкаторовверсийфрагментпамятиразмеромmaintenance_work_mem.\nПри автоматической очистке одновременно выполняются несколько\nрабочихпроцессов,ипамятьнужнакаждому;ктомужевесьфрагмент\nвыделяется сразу и полностью, а не по необходимости. Поэтому для\n−1 автоочистки предусмотрен отдельный параметр autovacuum_work_mem.\nЗначениепоумолчанию,прикоторомиспользуетсяобычноеограниче-\nниеmaintenance_work_mem,скореевсего,следуетскорректировать,если\nустановленобольшоезначениепараметраautovacuum_max_workers.\n• Очистка,запускаемая вручную,может обрабатывать несколько индек-\nсовнаоднойтаблицепараллельно,аавтоматическаяочистка—нет,по-\nсколькуэтомоглобыпривестикслишкомбольшомучислуодновремен-\nнозапущенныхпроцессов.\nЕслипроцесснеуспеетвыполнитьвсюнамеченнуюработузаинтервалвре-\nмени autovacuum_naptime, процесс autovacuum launcher пошлет в ту же ба-\nзуданныхещеодинрабочийпроцесс,ионибудутработатьвместе.Второй\nпроцесс построитсвои собственные списки объектовдля очистки и анали-\nзаипойдетпоним.Параллельнобудутобрабатыватьсяразныетаблицы;на\nуровнеоднойтаблицыпараллелизманет.\nКакие таблицы требуюточистки\nАвтоочистку можно отключить на уровне отдельных таблиц, хотя сложно\nпридумать причину, по которой это было бы необходимо. За отключение\nотвечаютдвапараметрахранения:одиндляпростыхтаблиц,другой—для\ntoast-таблиц:\n• autovacuum_enabled;\n• toast.autovacuum_enabled.\n136",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.680765"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 138,
    "chapter": null,
    "section": "6.5 Автоматическаяочисткаианализ",
    "text": "6.5. Автоматическаяочисткаианализ\nОбычножесрабатываниеавтоочисткивызываетсялибонакоплениемнеак- с.157\nтуальныхверсийстрок,либовставкойновыхстрок.\nНеактуальныеверсиистрок. Примерноечислонеактуальныхверсийпосто-\nянноотслеживаетсяидоступновтаблицеpg_stat_all_tables.\nСчитается, что очистка необходима, если количество неактуальных, мерт-\nвыхверсийстрокпревышаетпороговоезначение,определяемоепаройпа-\nраметров:\n• autovacuum_vacuum_threshold—абсолютноезначение(вштуках); 50\n• autovacuum_vacuum_scale_factor—долястроквтаблице. 0.2\nФормулатакова:очисткамертвыхверсийтребуется,если\npg_stat_all_tables.n_dead_tup >\nautovacuum_vacuum_threshold+\nautovacuum_vacuum_scale_factor×pg_class.reltuples.\nГлавныйпараметрздесь,конечно,autovacuum_vacuum_scale_factor—именно\nонважендлябольшихтаблиц(аименноснимиисвязанывозможныепроб-\nлемы).Значение по умолчанию 20% представляется сильно завышенным;\nскореевсего,егопотребуетсясущественноуменьшить.\nОптимальные значения параметров могут отличаться для разных таблиц\nвзависимостиотихразмераихарактераизменений.Имеетсмыслустано-\nвитьв целом адекватные значения и—при необходимости—переопреде-\nлитьнастройкидляотдельныхтаблицспомощьюпараметровхранения:\n• autovacuum_vacuum_thresholdиtoast.autovacuum_vacuum_threshold;\n• autovacuum_vacuum_scale_factorиtoast.autovacuum_vacuum_scale_factor.\n137",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.707670"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 139,
    "chapter": null,
    "section": "6.5 Автоматическаяочисткаианализ",
    "text": "Глава6. Очисткаиавтоочистка\nv.13 Вставленные строки. Еслистрокидобавляются,ноникогданеудаляютсяи\nнеизменяются,втаблиценебудетмертвыхверсий.Однакоитакиетаблицы\nс.150 необходимоочищать,чтобызаблаговременнозамораживатьверсиистроки\nс.409 обновлятькарту видимости (итем самым разрешатьсканированиетолько\nиндекса).\nОчистка будет выполняться, если число строк, вставленных с момента по-\nследнейочистки,превышаетпороговоезначение,определяемоеещеодной\nпохожейпаройпараметров:\n1000 • autovacuum_vacuum_insert_threshold;\n0.2 • autovacuum_vacuum_insert_scale_factor.\nКак и число неактуальных версий,количество вставленных строк отслежи-\nваетсякакчастьстатистикииспользованиятаблицы.\nФормулатакова:\npg_stat_all_tables.n_ins_since_vacuum >\nautovacuum_vacuum_insert_threshold+\nautovacuum_vacuum_insert_scale_factor×pg_class.reltuples.\nКак и в предыдущем случае, значения могут переопределяться на уровне\nтаблицспомощьюпараметровхранения:\n• autovacuum_vacuum_insert_thresholdитожедляtoast;\n• autovacuum_vacuum_insert_scale_factorитожедляtoast.\nКакие таблицы требуютанализа\nС автоанализомдело обстоитчутьпроще,чем с очисткой,потому что учи-\nтываютсятолькоизмененныестроки.\nСчитается,что анализа требуютте таблицы,в которых число измененных\nстрок(смоментапрошлогоанализа)превышаетпороговоезначение,задан-\nноепаройпараметров:\n50 • autovacuum_analyze_threshold;\n0.1 • autovacuum_analyze_scale_factor.\n138",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.736216"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 140,
    "chapter": null,
    "section": "6.5 Автоматическаяочисткаианализ",
    "text": "6.5. Автоматическаяочисткаианализ\nФормуласрабатыванияавтоанализа:\npg_stat_all_tables.n_mod_since_analyze >\nautovacuum_analyze_threshold+\nautovacuum_analyze_scale_factor×pg_class.reltuples.\nНастройки автоанализа также можно переопределить с помощью одно-\nименныхпараметровхранениядляотдельныхтаблиц:\n• autovacuum_analyze_threshold;\n• autovacuum_analyze_scale_factor.\nПоскольку toast-таблицы не анализируются,соответствующих параметров\nдлянихнет.\nАвтоочистка в действии\nЧтобы формализоватьвсе сказанное выше в этом разделе,создадим пред-\nставления, показывающие, какие таблицы в данный момент нуждаются\nвочисткеианализе1.Онибудутиспользоватьфункцию,возвращающуюте-\nкущее значение параметра.Функция учитывает,что значение можетбыть\nпереопределенонауровнетаблицы:\n=> CREATE FUNCTION p(param text, c pg_class) RETURNS float\nAS $$\nSELECT coalesce(\n-- если параметр хранения задан, то берем его\n(SELECT option_value\nFROM pg_options_to_table(c.reloptions)\nWHERE option_name = CASE\n-- для toast-таблиц имя параметра отличается\nWHEN c.relkind = 't' THEN 'toast.' ELSE ''\nEND || param\n),\n-- иначе берем значение конфигурационного параметра\ncurrent_setting(param)\n)::float;\n$$ LANGUAGE sql;\n1 backend/postmaster/autovacuum.c,функцияrelation_needs_vacanalyze.\n139",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.763929"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 141,
    "chapter": null,
    "section": "6.5 Автоматическаяочисткаианализ",
    "text": "Глава6. Очисткаиавтоочистка\nТакможетвыглядетьпредставлениедляочистки:\n=> CREATE VIEW need_vacuum AS\nWITH c AS (\nSELECT c.oid,\ngreatest(c.reltuples, 0) reltuples,\np('autovacuum_vacuum_threshold', c) threshold,\np('autovacuum_vacuum_scale_factor', c) scale_factor,\np('autovacuum_vacuum_insert_threshold', c) ins_threshold,\np('autovacuum_vacuum_insert_scale_factor', c) ins_scale_factor\nFROM pg_class c\nWHERE c.relkind IN ('r','m','t')\n)\nSELECT st.schemaname || '.' || st.relname AS tablename,\nst.n_dead_tup AS dead_tup,\nc.threshold + c.scale_factor * c.reltuples AS max_dead_tup,\nst.n_ins_since_vacuum AS ins_tup,\nc.ins_threshold + c.ins_scale_factor * c.reltuples AS max_ins_tup,\nst.last_autovacuum\nFROM pg_stat_all_tables st\nJOIN c ON c.oid = st.relid;\nСтолбецmax_dead_tupпоказываетпороговоезначениесрабатыванияавто-\nочисткииз-замертвыхверсийстрок,астолбецmax_ins_tup—из-завставки\nновыхстрок.\nИаналогичноепредставлениедляанализа:\n=> CREATE VIEW need_analyze AS\nWITH c AS (\nSELECT c.oid,\ngreatest(c.reltuples, 0) reltuples,\np('autovacuum_analyze_threshold', c) threshold,\np('autovacuum_analyze_scale_factor', c) scale_factor\nFROM pg_class c\nWHERE c.relkind IN ('r','m')\n)\nSELECT st.schemaname || '.' || st.relname AS tablename,\nst.n_mod_since_analyze AS mod_tup,\nc.threshold + c.scale_factor * c.reltuples AS max_mod_tup,\nst.last_autoanalyze\nFROM pg_stat_all_tables st\nJOIN c ON c.oid = st.relid;\nСтолбец max_mod_tup показывает пороговое значение срабатывания авто-\nанализа.\n140",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.803128"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 142,
    "chapter": null,
    "section": "6.5 Автоматическаяочисткаианализ",
    "text": "6.5. Автоматическаяочисткаианализ\nЧтобынеждатьдолгоавтоочистку,дляэкспериментовбудемзапускатьпро-\nцесскаждуюсекунду:\n=> ALTER SYSTEM SET autovacuum_naptime = '1s';\n=> SELECT pg_reload_conf();\nОпустошимтаблицуvac ивставимвнеетысячустрок.Напомню,чтоавто-\nочисткаотключенанауровнетаблицы.\n=> TRUNCATE TABLE vac;\n=> INSERT INTO vac(id,s)\nSELECT id, 'A' FROM generate_series(1,1000) id;\nВотчтопокажетнашепредставлениедляочистки:\n=> SELECT * FROM need_vacuum WHERE tablename = 'public.vac' \\gx\n−[ RECORD 1 ]−−−+−−−−−−−−−−−\ntablename | public.vac\ndead_tup | 0\nmax_dead_tup | 50\nins_tup | 1000\nmax_ins_tup | 1000\nlast_autovacuum |\nПороговое значение max_dead_tup = 50,хотя по приведенной выше фор-\nмуледолжнобыть50+0,2×1000=250.Деловтом,чтоещенетстатистики\nпотаблице,посколькукомандаINSERTсамапосебееенеобновляет:\n=> SELECT reltuples FROM pg_class WHERE relname = 'vac';\nreltuples\n−−−−−−−−−−−\n−1\n(1 row)\nЗначениеpg_class.reltuples равно−1;этаспециальнаяконстантавмес- v.14\nто нуля позволяет отличать таблицу без статистики от пустой, но проана-\nлизированнойтаблицы.Длярасчетовотрицательноезначениеприводится\nкнулю,чтоидает50+0,2×0=50.\nЗначениеmax_ins_tup = 1000отличаетсяотрасчетногочисла1200потой\nжепричине.\n141",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.836149"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 143,
    "chapter": null,
    "section": "6.5 Автоматическаяочисткаианализ",
    "text": "Глава6. Очисткаиавтоочистка\nЗаглянемвпредставлениедляанализа:\n=> SELECT * FROM need_analyze WHERE tablename = 'public.vac' \\gx\n−[ RECORD 1 ]−−−−+−−−−−−−−−−−\ntablename | public.vac\nmod_tup | 1006\nmax_mod_tup | 50\nlast_autoanalyze |\nВ таблице изменилась 1000 строк (в данном случае они были добавлены),\nиэтобольшепорога,которыйпокаравен50сучетомнеизвестногоразмера\nтаблицы.Значит,автоанализдолженсработать.Включимего:\n=> ALTER TABLE vac SET (autovacuum_enabled = on);\nПосле небольшой паузы таблица оказывается проанализированной, поро-\nговоезначениеисправляетсянакорректные150строк:\n=> SELECT reltuples FROM pg_class WHERE relname = 'vac';\nreltuples\n−−−−−−−−−−−\n1000\n(1 row)\n=> SELECT * FROM need_analyze WHERE tablename = 'public.vac' \\gx\n−[ RECORD 1 ]−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\ntablename | public.vac\nmod_tup | 0\nmax_mod_tup | 150\nlast_autoanalyze | 2025−01−12 14:38:57.846979+03\nВернемсякавтоочистке:\n=> SELECT * FROM need_vacuum WHERE tablename = 'public.vac' \\gx\n−[ RECORD 1 ]−−−+−−−−−−−−−−−\ntablename | public.vac\ndead_tup | 0\nmax_dead_tup | 250\nins_tup | 1000\nmax_ins_tup | 1200\nlast_autovacuum |\nЗначения max_dead_tup и max_ins_tup тоже исправились с учетом выяс-\nненноговпроцессеанализаразмератаблицы.\n142",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.868218"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 144,
    "chapter": null,
    "section": "6.6 Регулированиенагрузки",
    "text": "6.6. Регулированиенагрузки\nНаданныймоменточисткаможетсостоятьсяводномиздвухслучаев:\n• припоявленииболее250мертвыхверсийстрок;\n• привставкевтаблицуболее200строк. v.13\nСноваотключимавтоочисткуиобновим251строку—наоднубольше,чем\nпороговоезначение:\n=> ALTER TABLE vac SET (autovacuum_enabled = off);\n=> UPDATE vac SET s = 'B' WHERE id <= 251;\n=> SELECT * FROM need_vacuum WHERE tablename = 'public.vac' \\gx\n−[ RECORD 1 ]−−−+−−−−−−−−−−−\ntablename | public.vac\ndead_tup | 251\nmax_dead_tup | 250\nins_tup | 1000\nmax_ins_tup | 1200\nlast_autovacuum |\nТеперь условие срабатывания выполняется.Включим автоочистку и после\nнепродолжительнойпаузыобнаружим,чтотаблицаобработана,астатисти-\nкаиспользованиясброшена:\n=> ALTER TABLE vac SET (autovacuum_enabled = on);\n=> SELECT * FROM need_vacuum WHERE tablename = 'public.vac' \\gx\n−[ RECORD 1 ]−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\ntablename | public.vac\ndead_tup | 0\nmax_dead_tup | 250\nins_tup | 0\nmax_ins_tup | 1200\nlast_autovacuum | 2025−01−12 14:39:02.950019+03\n6.6. Регулирование нагрузки\nОчистка не блокирует другие процессы, поскольку работает постранично,\nнотем не менее создаетнагрузку на систему и можетоказыватьзаметное\nвлияниенапроизводительность.\n143",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.897434"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 145,
    "chapter": null,
    "section": "6.6 Регулированиенагрузки",
    "text": "Глава6. Очисткаиавтоочистка\nУправление интенсивностью обычной очистки\nЧтобыможнобылоуправлятьинтенсивностьюочисткии,следовательно,ее\nвлияниемнасистему,процессчередуетработуиожидание.Очисткавыпол-\n200 няетпримерноvacuum_cost_limitусловныхединицработы,азатемзасыпает\n0 наvacuum_cost_delayединицвремени.\nНулевое значение по умолчаниюдля vacuum_cost_delay фактически означа-\nет,что (обычная) очистка вовсе не засыпает,так что конкретное значение\nvacuum_cost_limit неиграетникакойроли.Этосделаноизсоображения,что\nеслиужадминистраторупришлосьзапускатьочисткувручную,тоон,веро-\nятно,хочетвыполнитьеекакможнобыстрее.\nТемнеменееесливсе-такиустановитьвремясна,тоуказанныйвпарамет-\nре vacuum_cost_limit объем работы будетскладываться из стоимостей рабо-\nс.179 ты со страницами в буферном кеше. Каждое чтение страницы оценивает-\n1 сяв vacuum_cost_page_hit единиц,еслистраницанашласьв буферномкеше,\n2 ивvacuum_cost_page_missединиц,еслиненашлась1.Еслижестраницанебы-\nла грязной, а в результате работы очистки на ней что-то поменялось, это\n20 стоитдополнительныхvacuum_cost_page_dirtyединиц2.\nЕслиоставитьзначениеvacuum_cost_limitпоумолчанию,заодинциклочист-\nкаможетобработатьот200страницвлучшемслучае(есливсеонизакеширо-\nваныиврезультатеработынепоявилосьниоднойновойгрязной)довсего9\nвхудшем(есливсестраницычитаютсясдискаистановятсягрязными).\nУправление интенсивностью автоочистки\nРегулированиенагрузкидляавтоматическойочистки3 работаетпримерно\nтакже,какидляобычной.Ночтобыонимоглиработатьсразнойинтенсив-\nностью,дляавтоочисткипредусмотренысобственныепараметры:\n−1 • autovacuum_vacuum_cost_limit;\n2ms • autovacuum_vacuum_cost_delay.\n1 backend/storage/buffer/bufmgr.c,функцияReadBuffer_common.\n2 backend/storage/buffer/bufmgr.c,функцияMarkBufferDirty.\n3 backend/postmaster/autovacuum.c,функцияautovac_balance_cost.\n144",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.936587"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 146,
    "chapter": null,
    "section": "6.7 Мониторингочистки",
    "text": "6.7. Мониторингочистки\nЕсликакой-либоизэтихпараметровравен−1,длянегоиспользуетсязначе-\nниесоответствующегопараметраобычнойочистки.Тоестьпоумолчанию\nдляautovacuum_vacuum_cost_limitприменяетсязначениеvacuum_cost_limit.\nЕдиницыработыавтоочистки,ограниченныеводномциклепределомauto-\nvacuum_vacuum_cost_limit,расходуютсявсемирабочимипроцессами,такчто\nобщая нагрузка на систему остается примерно одинаковой при любом их\nколичестве.Поэтому,еслистоитзадачаускоритьавтоочистку,приувеличе-\nнии параметра autovacuum_max_workers стоитпропорционально увеличить\nизначениеautovacuum_vacuum_cost_limit.\nПри необходимостидля разныхтаблиц можно устанавливатьсобственные\nзначенияспомощьюпараметровхранения:\n• autovacuum_vacuum_cost_delayиtoast.autovacuum_vacuum_cost_delay;\n• autovacuum_vacuum_cost_limitиtoast.autovacuum_vacuum_cost_limit.\n6.7. Мониторинг очистки\nОтслеживание хода выполнения очистки позволяетобнаружить ситуацию,\nкогдапроцессзаодинприемпытаетсяудалитьтакмноговерсийстрок,что\nссылки на них не помещаются в память размером maintenance_work_mem.\nВтакомслучаевсеиндексыбудутполностьюсканироватьсянесколькораз.\nДля большихтаблиц это можетзанимать существенное время и создавать\nзначительнуюнагрузкунасистему.Конечно,запросынебудутблокировать-\nся,нолишнийввод-выводможетсерьезноснизитьпроизводительность.\nСитуациюможноисправить,либовызываяочисткучаще(чтобызакаждый\nраз очищалось не очень большое количество версий строк),либо выделив\nбольшепамяти.\nОтслеживание выполнения ручной очистки\nКоманда VACUUM с указанием VERBOSE выполняеточисткуи выводитотчет\nопроделаннойработе,апредставлениеpg_stat_progress_vacuumпоказы-\nваетсостояниеужезапущенногопроцесса.\n145",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.969491"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 147,
    "chapter": null,
    "section": "6.7 Мониторингочистки",
    "text": "Глава6. Очисткаиавтоочистка\nv.13 Похожее представление есть и для анализа (pg_stat_progress_analyze),\nхотяанализвыполняетсябыстроиобычнонедоставляетпроблем.\nВставимвтаблицубольшестрокивсеобновим,чтобыочисткавыполнялась\nощутимоевремя:\n=> TRUNCATE vac;\n=> INSERT INTO vac(id,s)\nSELECT id, 'A' FROM generate_series(1,5_000_000) id;\n=> UPDATE vac SET s = 'B';\nДляцелейдемонстрацииуменьшимразмерпамяти,выделеннойподхране-\nниеидентификаторов,доабсурдноскромногозначения:\n=> ALTER SYSTEM SET maintenance_work_mem = '1MB';\n=> SELECT pg_reload_conf();\nЗапустимочисткуи,покаонаработает,обратимсянесколькоразкпредстав-\nлениюpg_stat_progress_vacuum:\n=> VACUUM VERBOSE vac;\nSELECT * FROM pg_stat_progress_vacuum \\gx\n−[ RECORD 1 ]−−−−−−−−+−−−−−−−−−−−−−−\npid | 14639\ndatid | 16391\ndatname | internals\nrelid | 16482\nphase | scanning heap\nheap_blks_total | 172414\nheap_blks_scanned | 90517\nheap_blks_vacuumed | 0\nindex_vacuum_count | 0\nmax_dead_tuple_bytes | 1048576\ndead_tuple_bytes | 0\nnum_dead_item_ids | 0\nindexes_total | 0\nindexes_processed | 0\n146",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:47.999000"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 148,
    "chapter": null,
    "section": "6.7 Мониторингочистки",
    "text": "6.7. Мониторингочистки\nSELECT * FROM pg_stat_progress_vacuum \\gx\n−[ RECORD 1 ]−−−−−−−−+−−−−−−−−−−−−−−−−−−\npid | 14639\ndatid | 16391\ndatname | internals\nrelid | 16482\nphase | vacuuming indexes\nheap_blks_total | 172414\nheap_blks_scanned | 32733\nheap_blks_vacuumed | 0\nindex_vacuum_count | 0\nmax_dead_tuple_bytes | 1048576\ndead_tuple_bytes | 1049600\nnum_dead_item_ids | 1898514\nindexes_total | 1\nindexes_processed | 0\nПредставление,вчастности,показывает: v.17\n• phase—текущийэтап(яописалосновные,новообщеихбольше1);\n• heap_blks_total—общеечислостраництаблицы;\n• heap_blks_scanned—числопросканированныхстраниц;\n• heap_blks_vacuumed—числоужеочищенныхстраниц;\n• index_vacuum_count—количествопроходовпоиндексам;\n• dead_tuple_bytes и num_dead_item_ids —объем и количество мерт-\nвыхверсий,собранныхнаданномпроходе.\nОбщий прогресс очистки определяется отношением heap_blks_vacuumed\nкheap_blks_total,нонужноучитывать,чтоиз-засканированияиндексов\nэтозначениеизменяется«рывками».Основноевниманиестоитобратитьна\nколичествоцикловочистки—значениебольшеединицыозначает,чтовы-\nделеннойпамятинехватилодлязавершенияочисткизаодинпроход.Впро-\nчем,вероятностьэтогоприразумномзначенииmaintenance_work_memмала.\nЭффективностьхраненияможнооценитьпоотношениюdead_tuple_bytes\nкnum_dead_item_ids:вданномпримеренаодинtidрасходуетсяпример-\nнополбайта.\n1 postgrespro.ru/docs/postgresql/17/progress-reporting#VACUUM-PHASES.\n147",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:48.031188"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 149,
    "chapter": null,
    "section": "6.7 Мониторингочистки",
    "text": "Глава6. Очисткаиавтоочистка\nВывод завершившейся к этому времени команды VACUUM VERBOSE показы-\nваетобщуюкартину:\nINFO: vacuuming \"internals.public.vac\"\nINFO: finished vacuuming \"internals.public.vac\": index scans: 3\npages: 0 removed, 172414 remain, 172414 scanned (100.00% of total)\ntuples: 5000000 removed, 5000000 remain, 0 are dead but not yet\nremovable\nremovable cutoff: 864, which was 0 XIDs old when operation ended\nnew relfrozenxid: 863, which is 1 XIDs ahead of previous value\nfrozen: 71131 pages from table (41.26% of total) had 4125534 tuples\nfrozen\nindex scan needed: 86207 pages from table (50.00% of total) had\n5000000 dead item identifiers removed\nindex \"vac_s\": pages: 8652 in total, 4325 newly deleted, 4325\ncurrently deleted, 0 reusable\navg read rate: 42.600 MB/s, avg write rate: 42.276 MB/s\nbuffer usage: 221968 hits, 265001 misses, 262988 dirtied\nWAL usage: 571036 records, 212913 full page images, 1374705398 bytes\nsystem usage: CPU: user: 3.72 s, system: 3.86 s, elapsed: 48.59 s\nVACUUM\nВ данном случае очистке потребовалось выполнить целых три прохода по\nиндексам.\nОтслеживание выполнения автоочистки\nСпомощьюпредставленийneed_vacuum иneed_analyze,которыемырас-\nсмотрели, можно отслеживать список таблиц, требующих очистки и ана-\nлиза. Увеличение длины списка говорит о том, что автоочистка не справ-\nляется и ее надо ускорить, уменьшив паузу (autovacuum_vacuum_cost_delay)\nили увеличив объем работы между паузами (autovacuum_vacuum_cost_limit).\nНе исключено, что понадобится также увеличить степень параллелизма\n(autovacuum_max_workers).\nНо обычный способ мониторинга автоочистки—вывод информации (ана-\nлогичнойтой,которуюпоказываеткомандаVACUUMVERBOSE)вжурналсооб-\nщенийсерверадлядальнейшегоанализа.Принулевомзначениипараметра\n−1 log_autovacuum_min_durationвжурналпопадаютвсезапускиавтоочистки:\n=> ALTER SYSTEM SET log_autovacuum_min_duration = 0;\n148",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:48.072677"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 150,
    "chapter": null,
    "section": "6.7 Мониторингочистки",
    "text": "6.7. Мониторингочистки\n=> SELECT pg_reload_conf();\n=> UPDATE vac SET s = 'C';\nUPDATE 5000000\npostgres$ tail -n 16 /home/postgres/logfile\n2025−01−12 14:44:55.205 MSK [28951] LOG: automatic vacuum of table\n\"internals.public.vac\": index scans: 3\npages: 0 removed, 172414 remain, 172414 scanned (100.00% of\ntotal)\ntuples: 5000000 removed, 5000000 remain, 0 are dead but not yet\nremovable\nremovable cutoff: 866, which was 0 XIDs old when operation ended\nnew relfrozenxid: 866, which is 3 XIDs ahead of previous value\nfrozen: 86208 pages from table (50.00% of total) had 5000000\ntuples frozen\nindex scan needed: 86208 pages from table (50.00% of total) had\n5000000 dead item identifiers removed\nindex \"vac_s\": pages: 16923 in total, 4325 newly deleted, 8650\ncurrently deleted, 4325 reusable\navg read rate: 19.062 MB/s, avg write rate: 17.340 MB/s\nbuffer usage: 236736 hits, 288065 misses, 262040 dirtied\nWAL usage: 616268 records, 196345 full page images, 1501495526\nbytes\nsystem usage: CPU: user: 7.82 s, system: 4.56 s, elapsed: 118.06\ns\n2025−01−12 14:44:56.408 MSK [28951] LOG: automatic analyze of table\n\"internals.public.vac\"\navg read rate: 182.588 MB/s, avg write rate: 0.006 MB/s\nbuffer usage: 2017 hits, 28139 misses, 1 dirtied\nsystem usage: CPU: user: 0.25 s, system: 0.09 s, elapsed: 1.20 s\n149",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:48.102329"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 151,
    "chapter": null,
    "section": "7.1 Переполнение счетчика транзакций",
    "text": "7\nЗаморозка\n7.1. Переполнение счетчика транзакций\nПод номертранзакции в PostgreSQL выделено 32 бита.Четыре миллиарда\nвыглядит довольно большим числом, но при активной работе оно может\nбыть израсходовано довольно быстро. Например, при нагрузке 1000 тран-\nзакцийвсекунду(несчитаявиртуальных)этопроизойдетвсегочерезпол-\nторамесяцанепрерывнойработы.\nПосле исчерпания разрядности счетчик должен будет обнулиться и пойти\nпо следующему кругу (по-английски это называется словом wraparound).\nНоведьсчитать,чтотранзакциясменьшимномеромначаласьраньшетран-\nзакции с бóльшим номером,можно только в случае постоянно возрастаю-\nщихномеров.Поэтомупонятно,чтопростотакобнулитьсчетчикиначать\nнумерациюзановонельзя.\nПочему под номертранзакции не выделено 64 бита—ведьэто полностью\nисключилобыпроблему?Деловтом,чтовзаголовкекаждойверсиистроки\nс.75 хранятсядваномератранзакций—xminиxmax.Заголовокитакдостаточно\nбольшой(минимум24байтасучетомвыравнивания),аувеличениеразряд-\nностидобавилобыеще8байт.\n64-битныеномератранзакций,добавляющиекобычномуномеру32-битную«эпоху»,\nтожеиспользуются1,нотолькодляслужебныхцелейиникогданепопадаютвстрани-\nцыданных.\nЧтобыкорректнообрабатыватьпереполнениесчетчика,надосравниватьне\nномера транзакций, а их возраст (выраженный в количестве транзакций,\n1 include/access/transam.h,типFullTransactionId.\n150",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:48.130403"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 152,
    "chapter": null,
    "section": "7.2 Заморозкаверсийиправилавидимости",
    "text": "7.2. Заморозкаверсийиправилавидимости\nначатых с момента появления данной транзакции). Таким образом, вмес-\nтопонятий«меньше»и«больше»используются«предшествует»(«старше»)\nи«следуетза»(«младше»).\nВкодеэтоестественнымобразомреализуется32-битнойарифметикой:на-\nдо найти разницу 32-битных номеровтранзакций и сравнитьполученный\nрезультатснулем1.\nГрафическиможнопредставить,чтономератранзакцийзакольцованы.Тог-\nдадлялюбойтранзакцииполовинаномеровпротивчасовойстрелкибудет\nстарше(впрошлом),аполовинапочасовойстрелке—младше(вбудущем).\nT1 T1 TT11\nT2 T2\nрп б\nу\nо д\nш у\nщ\nл о е T3\nе е\nОднаковтакойзакольцованнойсхемевозникаетнеприятнаяситуация.Ста-\nраятранзакция (T1) находитсядля новыхтранзакций вдалеком прошлом.\nНочерезнекотороевремядляочереднойтранзакциионаокажетсявтойпо-\nловинекруга,котораяотноситсякбудущему.Еслибыэтобылотак,топриве-\nлобыккатастрофическимпоследствиям—изменения,сделанныетранзак-\nцией T1давным-давно,оказались бы невидимыми для новыхтранзакций.\n7.2. Заморозка версий и правила видимости\nЧтобынедопуститьтаких«путешествийвовремени»,процессочистки(по-\nмимо освобождения места в страницах) выполняет еще одну задачу2. Он\nищетверсиистрок,находящиесязагоризонтомбазыданных(видимыево\nвсехснимках),испециальнымобразомихпомечает—замораживает. с.264\n1 backend/access/transam/transam.c,функцияTransactionIdPrecedes.\n2 postgrespro.ru/docs/postgresql/17/routine-vacuuming#VACUUM-FOR-WRAPAROUND.\n151",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:48.165600"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 153,
    "chapter": null,
    "section": "7.2 Заморозкаверсийиправилавидимости",
    "text": "Глава7. Заморозка\nЗамороженнаяверсиястрокивиднавовсехснимкахданныхбезоглядкина\nномер транзакции xmin, поэтому такой номер может быть безопасно ис-\nпользованзаново.\nМожно считать, что в замороженных версиях строк номер xmin заменяет-\nсянаусловную«минусбесконечность»(показаннуюнарисункеввидесне-\nжинки)—признактого,чтосоздавшаяверсиютранзакциязавершиласьтак\nдавно,чтоконкретныйномеруженеважен.Хотянасамомделеxminнеме-\nняется,а в качестве признака заморозки выставляются одновременно два\nбита-подсказки—битфиксацииибитотмены.\n(cid:94)T1 (cid:94) (cid:94)T1\nT2 (cid:94) (cid:94)\nT3 T3 T2 (cid:94)\nT4 T1 T4 T1 T4\nМногиеисточники(включаядокументацию)упоминаютспециальныйномертранзак-\nцииFrozenTransactionId=2.Этоиестьтасамая«минусбесконечность»,накоторую\nзаменялсяxminдоверсии9.4,носейчасиспользуютсябиты-подсказки.Этопозволяет\nсохранитьвверсиистрокиисходныйномертранзакции,чтоудобнодляподдержкии\nотладки.Однакотранзакциисномером2ещемогутвстретитьсявстраницахданных\nстарыхсистем,дажеобновленныхдопоследнихверсий.\nНомер транзакции xmax никак не участвует в заморозке. Он фигурирует\nтольковнеактуальныхверсияхстрок,акогдатакиеверсииперестанутбыть\nвидимывснимках(тоестьномеруйдетзагоризонтбазыданных),онибудут\nудаленыочисткой.\nДляэкспериментовсоздадимновуютаблицу.Установимдлянееминималь-\nное значение параметра fillfactor так, чтобы на каждой странице помеща-\nлосьвсегодвестроки—такбудетудобнеенаблюдатьзапроисходящим.Иот-\nключим автоматику, чтобы управлять временем очистки самостоятельно.\n152",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:48.204655"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 154,
    "chapter": null,
    "section": "7.2 Заморозкаверсийиправилавидимости",
    "text": "7.2. Заморозкаверсийиправилавидимости\n=> CREATE TABLE tfreeze(\nid integer,\ns char(300)\n) WITH (fillfactor = 10, autovacuum_enabled = off);\nОчередной вариант функции для просмотра страниц с помощью расши-\nрения pageinspect будетотображатьдиапазон страниц,расшифровывать\nпризнак заморозки («f») и показывать возраст транзакции xmin (для это-\nгоиспользуетсясистемнаяфункцияage;самвозраст,конечно,нехранится\nвстраницахданных):\n=> CREATE FUNCTION heap_page(\nrelname text, pageno_from integer, pageno_to integer\n)\nRETURNS TABLE(\nctid tid, state text,\nxmin text, xmin_age integer, xmax text\n) AS $$\nSELECT (pageno,lp)::text::tid AS ctid,\nCASE lp_flags\nWHEN 0 THEN 'unused'\nWHEN 1 THEN 'normal'\nWHEN 2 THEN 'redirect to '||lp_off\nWHEN 3 THEN 'dead'\nEND AS state,\nt_xmin || CASE\nWHEN (t_infomask & 256+512) = 256+512 THEN ' f'\nWHEN (t_infomask & 256) > 0 THEN ' c'\nWHEN (t_infomask & 512) > 0 THEN ' a'\nELSE ''\nEND AS xmin,\nage(t_xmin) AS xmin_age,\nt_xmax || CASE\nWHEN (t_infomask & 1024) > 0 THEN ' c'\nWHEN (t_infomask & 2048) > 0 THEN ' a'\nELSE ''\nEND AS xmax\nFROM generate_series(pageno_from, pageno_to) p(pageno),\nheap_page_items(get_raw_page(relname, pageno))\nORDER BY pageno, lp;\n$$ LANGUAGE sql;\nВставляемвтаблицунекотороеколичествострокисразувыполняемочист-\nку,чтобысоздаласькартавидимости:\n153",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:48.237874"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 155,
    "chapter": null,
    "section": "7.2 Заморозкаверсийиправилавидимости",
    "text": "Глава7. Заморозка\n=> CREATE EXTENSION IF NOT EXISTS pg_visibility;\n=> INSERT INTO tfreeze(id, s)\nSELECT id, 'FOO'||id FROM generate_series(1,100) id;\nINSERT 0 100\n=> VACUUM tfreeze;\nБудем наблюдать за первыми двумя страницами с помощью расширения\npg_visibility. После очистки обе страницы оказываются отмеченными\nвкартевидимости(all_visible),ноневкартезаморозки(all_frozen)—\nониещесодержатнезамороженныеверсиистрок:\n=> SELECT *\nFROM generate_series(0,1) g(blkno),\npg_visibility_map('tfreeze',g.blkno)\nORDER BY g.blkno;\nblkno | all_visible | all_frozen\n−−−−−−−+−−−−−−−−−−−−−+−−−−−−−−−−−−\n0 | t | f\n1 | t | f\n(2 rows)\nУтранзакции,создавшей строки,возраст xmin_age равен 1,поскольку это\nпоследняятранзакция,котораявыполняласьвсистеме:\n=> SELECT * FROM heap_page('tfreeze',0,1);\nctid | state | xmin | xmin_age | xmax\n−−−−−−−+−−−−−−−−+−−−−−−−+−−−−−−−−−−+−−−−−−\n(0,1) | normal | 869 c | 1 | 0 a\n(0,2) | normal | 869 c | 1 | 0 a\n(1,1) | normal | 869 c | 1 | 0 a\n(1,2) | normal | 869 c | 1 | 0 a\n(4 rows)\n7.3. Управление заморозкой\nЗаморозкой управляют четыре основных конфигурационных параметра.\nЗначениявсехчетырехпредставляютвозрасттранзакцийиопределяютмо-\nменты,начинаяскоторых:\n• версииначинаютзамораживаться—vacuum_freeze_min_age;\n154",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:48.268648"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 156,
    "chapter": null,
    "section": "7.3 Управлениезаморозкой",
    "text": "7.3. Управлениезаморозкой\n• выполняется«агрессивная»заморозка—vacuum_freeze_table_age;\n• заморозкасрабатываетаварийно—autovacuum_freeze_max_age;\n• заморозкаработаетвприоритетномрежиме—vacuum_failsafe_age. v.14\nМинимальный возрастдля заморозки\nМинимальныйвозрасттранзакцииxmin,прикоторомверсиюстрокиможно\nзамораживать, определяется параметром vacuum_freeze_min_age. Чем мень- 50млн\nшеэтозначение,темсильнеемогутвырастинакладныерасходы:еслистро-\nкаокажется«горячей»ибудетактивноизменяться,тозаморозкавсеновых\nиновыхверсийбудетпропадатьбезпользы.Установкаотносительноболь-\nшогозначенияпараметрапозволяетвыждать.\nЧтобыпосмотреть,какпроисходитзаморозка,уменьшимзначениедоеди-\nницы:\n=> ALTER SYSTEM SET vacuum_freeze_min_age = 1;\n=> SELECT pg_reload_conf();\nОбновимтеперьоднустрокунанулевойстранице.Новаяверсияпопадетна\nтужестраницублагодарянебольшомузначениюfillfactor:\n=> UPDATE tfreeze SET s = 'BAR' WHERE id = 1;\nВозрасттранзакцийувеличилсянаединицу.Табличныестраницывыглядят\nсейчасследующимобразом:\n=> SELECT * FROM heap_page('tfreeze',0,1);\nctid | state | xmin | xmin_age | xmax\n−−−−−−−+−−−−−−−−+−−−−−−−+−−−−−−−−−−+−−−−−−\n(0,1) | normal | 869 c | 2 | 870\n(0,2) | normal | 869 c | 2 | 0 a\n(0,3) | normal | 870 | 1 | 0 a\n(1,1) | normal | 869 c | 2 | 0 a\n(1,2) | normal | 869 c | 2 | 0 a\n(5 rows)\n155",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:48.300490"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 157,
    "chapter": null,
    "section": "7.3 Управлениезаморозкой",
    "text": "Глава7. Заморозка\nТеперь строки старше vacuum_freeze_min_age = 1 подлежат заморозке. Но\nс.131 очистка рассматриваеттолько те страницы, которые не отмечены в карте\nвидимости:\n=> SELECT * FROM generate_series(0,1) g(blkno),\npg_visibility_map('tfreeze',g.blkno)\nORDER BY g.blkno;\nblkno | all_visible | all_frozen\n−−−−−−−+−−−−−−−−−−−−−+−−−−−−−−−−−−\n0 | f | f\n1 | t | f\n(2 rows)\nОчистка игнорирует карту видимости, если страницы с разными признаками идут\nвразнобой.Пропускаютсядиапазоныминимумиз32страниц,содержащихтолькови-\nдимыевовсехснимкахверсиистрок1,посколькувпротивномслучаевсестраницы,\nскорее всего,окажутся в оперативной памяти благодаря предвыборке,так что про-\nпускать их не имеет большого смысла.Именно поэтому таблица tfreeze создана\nдостаточнобольшой,хотянасинтересуюттолькодвестраницы.\nПредыдущая команда UPDATE сбросила бит видимости нулевой страницы,\nавотпервуюстраницуочисткапропустит:\n=> VACUUM tfreeze;\nVACUUM\n=> SELECT * FROM heap_page('tfreeze',0,1);\nctid | state | xmin | xmin_age | xmax\n−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−+−−−−−−−−−−+−−−−−−\n(0,1) | redirect to 3 | | |\n(0,2) | normal | 869 f | 2 | 0 a\n(0,3) | normal | 870 f | 1 | 0 a\n(1,1) | normal | 869 c | 2 | 0 a\n(1,2) | normal | 869 c | 2 | 0 a\n(5 rows)\nv.16 Обратитевнимание,чтонанулевойстраницебылизамороженыобеверсии\nстрок,хотявозрасттранзакцииxminвовторойверсиинепревышаетзначе-\nнияпараметраvacuum_freeze_min_age.Посколькустраницувсеравноприхо-\nдитсяменять,нанейзамораживаютсявсеверсиистрокзагоризонтомбазы\n1 backend/access/heap/vacuumlazy.c,функцияheap_vac_scan_next_block.\n156",
    "tables": [
      {
        "table_index": 0,
        "rows": 2,
        "cols": 1,
        "content": "f\nf"
      }
    ],
    "extracted_at": "2025-10-02T15:59:48.336812"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 158,
    "chapter": null,
    "section": "7.3 Управлениезаморозкой",
    "text": "7.3. Управлениезаморозкой\nданных—это практически не увеличиваетстоимость операции,но может\nсэкономитьусилиявбудущем.\nТеперьобестраницысноваотмеченывкартевидимости.Несмотрянаточто\nпервая страница содержитнезамороженные строки,очистка будетпропус-\nкатьее,есливнейничегонеизменится:\n=> SELECT * FROM generate_series(0,1) g(blkno),\npg_visibility_map('tfreeze',g.blkno)\nORDER BY g.blkno;\nblkno | all_visible | all_frozen\n−−−−−−−+−−−−−−−−−−−−−+−−−−−−−−−−−−\n0 | t | t\n1 | t | f\n(2 rows)\nВозрастдля агрессивной заморозки\nИтак,еслинастраницеосталисьтолькоактуальныеверсии,видимыевовсех\nснимках,очистканезаморозитих.Справитьсяспроблемойпозволяетпара-\nметр vacuum_freeze_table_age.Его значение определяет возрасттранзакции, 150млн\nприкоторомочисткаигнорируеткартувидимостиизамораживаетвсестра-\nницытаблицы.\nДлякаждойтаблицывсистемномкаталогехранитсяномертранзакции,про\nкоторую известно,что все более старыетранзакции гарантированно замо-\nрожены:\n=> SELECT relfrozenxid, age(relfrozenxid)\nFROM pg_class\nWHERE relname = 'tfreeze';\nrelfrozenxid | age\n−−−−−−−−−−−−−−+−−−−−\n869 | 2\n(1 row)\nСвозрастомэтойзапомненнойтранзакцииисравниваетсязначениепара-\nметра vacuum_freeze_table_age для принятия решения об агрессивной замо-\nрозке.\n157",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:48.366174"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 159,
    "chapter": null,
    "section": "7.3 Управлениезаморозкой",
    "text": "Глава7. Заморозка\nБлагодарякартезаморозкинетнеобходимостиполностьюсканироватьтаб-\nлицу при очистке; достаточно просмотреть только те страницы, которые\nеще не отмечены в карте. Карта заморозки не только существенно умень-\nшает объем работы,но и дает устойчивость к прерываниям: если процесс\nочисткиостановитьиначатьзаново,емунепридетсявозвращатьсякстра-\nницам,которыеужебылиобработаныиотмеченывкартевпрошлыйраз.\nДлязаморозкивсейтаблицыуменьшимзначениеvacuum_freeze_table_ageдо\nдвух,чтобывыполнилосьусловиеагрессивнойзаморозки:\n=> ALTER SYSTEM SET vacuum_freeze_table_age = 2;\n=> SELECT pg_reload_conf();\nВыполнимочистку:\n=> VACUUM VERBOSE tfreeze;\nINFO: aggressively vacuuming \"internals.public.tfreeze\"\nINFO: finished vacuuming \"internals.public.tfreeze\": index scans: 0\npages: 0 removed, 50 remain, 50 scanned (100.00% of total)\ntuples: 0 removed, 100 remain, 0 are dead but not yet removable\nremovable cutoff: 871, which was 0 XIDs old when operation ended\nnew relfrozenxid: 871, which is 2 XIDs ahead of previous value\nfrozen: 48 pages from table (96.00% of total) had 96 tuples frozen\nindex scan not needed: 0 pages from table (0.00% of total) had 0\ndead item identifiers removed\navg read rate: 0.000 MB/s, avg write rate: 0.000 MB/s\nbuffer usage: 109 hits, 0 misses, 0 dirtied\nWAL usage: 97 records, 0 full page images, 6545 bytes\nsystem usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s\nVACUUM\nТеперь,посколькуагрессивнаяочисткапроверяетвсютаблицу,номерзамо-\nроженнойтранзакцииможноувеличить—встраницахгарантированноне\nосталосьболеестаройнезамороженнойтранзакции:\n=> SELECT relfrozenxid, age(relfrozenxid)\nFROM pg_class\nWHERE relname = 'tfreeze';\nrelfrozenxid | age\n−−−−−−−−−−−−−−+−−−−−\n871 | 0\n(1 row)\n158",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:48.406103"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 160,
    "chapter": null,
    "section": "7.3 Управлениезаморозкой",
    "text": "7.3. Управлениезаморозкой\nРазумеется,напервойстраницетеперьзамороженывсеверсиистрок:\n=> SELECT * FROM heap_page('tfreeze',0,1);\nctid | state | xmin | xmin_age | xmax\n−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−+−−−−−−−−−−+−−−−−−\n(0,1) | redirect to 3 | | |\n(0,2) | normal | 869 f | 2 | 0 a\n(0,3) | normal | 870 f | 1 | 0 a\n(1,1) | normal | 869 f | 2 | 0 a\n(1,2) | normal | 869 f | 2 | 0 a\n(5 rows)\nКрометого,перваястраницаотмеченавкартезаморозки:\n=> SELECT * FROM generate_series(0,1) g(blkno),\npg_visibility_map('tfreeze',g.blkno)\nORDER BY g.blkno;\nblkno | all_visible | all_frozen\n−−−−−−−+−−−−−−−−−−−−−+−−−−−−−−−−−−\n0 | t | t\n1 | t | t\n(2 rows)\nАгрессивная заморозка всех страниц в таблице выполняется не чаще,чем v.15\nраз в vacuum_freeze_table_age − vacuum_freeze_min_age транзакций (100 млн\nпри значениях параметров по умолчанию). Она будет запускаться реже,\nесли очистка в неагрессивном режиме тоже сможет продвинуть значение\nrelfrozenxid1.Влюбомслучаенадоучитывать,чтослишкомбольшоезна-\nчение параметра vacuum_freeze_min_age вместо экономии может привести\nк избыточным срабатываниям агрессивной заморозки и увеличению на-\nкладныхрасходов.\nВозрастдля аварийного срабатывания автоочистки\nБывают ситуации, когда предыдущих двух настроек оказывается недоста-\nточнодля своевременной заморозки версий строк.Автоочистку можно от-\nключить, а обычную очистку — не запускать (так делать не надо, но тех-\nническиэтовозможно).Такжемогутприсутствоватьтаблицысархивными\n1 commitfest.postgresql.org/37/3433.\n159",
    "tables": [
      {
        "table_index": 0,
        "rows": 2,
        "cols": 1,
        "content": "f\nf"
      }
    ],
    "extracted_at": "2025-10-02T15:59:48.680883"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 161,
    "chapter": null,
    "section": "7.3 Управлениезаморозкой",
    "text": "Глава7. Заморозка\nданными,непопадающиевочередьавтоочистки,илинеактивныебазыдан-\nс.135 ных (например, template0), в которые автоочистка вообще не приходит.\nДля подобных случаев предусмотрено аварийное срабатывание автоочист-\nкивагрессивномрежиме.\nАварийнаяавтоочистказапускаетсядлябазыданныхпринудительно1(даже\nеслиотключена),когдавозрасткакой-нибудьнезамороженнойтранзакции\n200млн внейможетпревыситьзначениеautovacuum_freeze_max_age.Определяющим\nявляется возрастсамой старой изтранзакций pg_class.relfrozenxid по\nвсемтаблицам базы,поскольку все еще более старыетранзакции гаранти-\nрованно заморожены. Номер этой транзакции запоминается в системном\nкаталоге:\n=> SELECT datname, datfrozenxid, age(datfrozenxid) FROM pg_database;\ndatname | datfrozenxid | age\n−−−−−−−−−−−+−−−−−−−−−−−−−−+−−−−−\npostgres | 730 | 141\ntemplate1 | 730 | 141\ntemplate0 | 730 | 141\ninternals | 730 | 141\n(4 rows)\ndatfrozenxid\nвсеверсии\nстроквбазеданных\nгарантированнозаморожены\nxid\nrelfrozenxid relfrozenxid relfrozenxid\nтаблицы1 таблицы3 таблицы2\n1 backend/access/transam/varsup.c,функцияSetTransactionIdLimit.\n160",
    "tables": [
      {
        "table_index": 0,
        "rows": 3,
        "cols": 3,
        "content": "|  | \n |  | \n |  |"
      }
    ],
    "extracted_at": "2025-10-02T15:59:48.710741"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 162,
    "chapter": null,
    "section": "7.3 Управлениезаморозкой",
    "text": "7.3. Управлениезаморозкой\nПределдля значения autovacuum_freeze_max_age составляет2 млрдтранзак-\nций(чутьменееполовиныкруга),азначениепоумолчаниюв10разменьше.\nВ этом естьсмысл: большое значение увеличиваетрисктого,что за остав-\nшеесядопереполнениясчетчикавремяавтоочисткапростонеуспеетзамо-\nрозитьвсе необходимые версии строк.В этом случае PostgreSQL аварийно\nостановится, чтобы предотвратить возможные проблемы, и запуск потре-\nбуетвмешательстваадминистратора.\nКроме того, значение этого параметра определяет размер структуры clog. с.85\nВ кластере не может остаться более старых незамороженных транзакций,\nчем старейшая из datfrozenxid по всем базам данных, а для заморожен-\nныхтранзакцийстатусхранитьненужно.Ненужныефайлы-сегментыclog\nудаляютсяавтоочисткой1.\nИзменение параметра autovacuum_freeze_max_age требует перезапуска сер-\nвера.Нопринеобходимостивсерассмотренныевышепараметрыуправле-\nния заморозкой можно переопределить с помощью параметров хранения\nна уровне отдельныхтаблиц.Обратите внимание нато,что названия всех\nпараметровначинаютсяна«auto»:\n• autovacuum_freeze_min_ageиtoast.autovacuum_freeze_min_age;\n• autovacuum_freeze_table_ageиtoast.autovacuum_freeze_table_age;\n• autovacuum_freeze_max_ageиtoast.autovacuum_freeze_max_age.\nВозрастдля приоритетного режима заморозки v.14\nЕсли автоочистка уже работает над предотвращением переполнения счет-\nчика транзакций, но явно не успевает, срабатывает «предохранитель»: ав-\nтоочистка прекращает учитывать задержку autovacuum_vacuum_cost_delay\n(vacuum_cost_delay)иперестаеточищатьиндексы,чтобыкакможнобыстрее\nзаморозитьверсиистрок.\n1 backend/commands/vacuum.c,функцияvac_truncate_clog.\n161",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:48.741586"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 163,
    "chapter": null,
    "section": "7.4 Заморозка вручную",
    "text": "Глава7. Заморозка\nПриоритетный режим заморозки включается1, если возраст какой-нибудь\nнезамороженнойтранзакциивбазеданныхможетпревыситьзначениепа-\n1,6млрд раметраvacuum_failsafe_age.Предполагается,чтозначениеэтогопараметра\nдолжнобытьвыше,чемзначениеautovacuum_freeze_max_age.\n7.4. Заморозка вручную\nИногдабываетудобноуправлятьзаморозкойвручную,анедожидатьсяпри-\nходаавтоочистки.\nОчистка с заморозкой\nЗаморозкуможновызватьвручнуюкомандойVACUUM FREEZE.Приэтомбу-\nдут заморожены все версии строк без оглядки на возрасттранзакций, как\nбудтоvacuum_freeze_min_age=0.\nv.12 Если цель такого вызова — как можно быстрее заморозить версии строк\nв таблице, имеет смысл отключить очистку индексов, как в приоритет-\nном режиме. Это можно сделать либо явно, используя команду VACUUM\n(freeze, index_cleanup false), либо с помощью параметра хранения\nvacuum_index_cleanup.Довольноочевидно,чтоэтонеследуетделатьнарегу-\nлярнойоснове,посколькуглавнаяфункцияочистки—освобождениеместа\nнастраницах—приэтомбудетвыполнятьсяплохо.\nЗаморозка при загрузке\nДанные,которыенедолжныменяться,можнозаморозитьсразуприначаль-\nнойзагрузке.ДляэтогоиспользуетсякомандаCOPYспараметромFREEZE.\nЗагружать данные с заморозкой можно только в таблицу, созданную или\nопустошенную (командой TRUNCATE) в этой же транзакции. Обе эти опе-\nс.251 рации монопольно блокируют таблицу. Такое ограничение необходимо,\n1 backend/access/heap/vacuumlazy.c,функцияlazy_check_wraparound_failsafe.\n162",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:48.771796"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 164,
    "chapter": null,
    "section": "7.4 Заморозкавручную",
    "text": "7.4. Заморозкавручную\nпоскольку замороженные версии считаются видимыми во всех снимках\nданныхнезависимоотуровняизоляции;иначетранзакциинеожиданнооб-\nнаруживалибысвежезамороженныестрокипрямопомереихзагрузки.Но\nпокатаблица заблокирована,другиетранзакции не смогутполучитьк ней\nдоступ.\nТем не менее формально нарушение изоляции все же возможно.В отдель-\nномсеансеначнемтранзакциюсуровнемизоляцииRepeatableRead:\n=> BEGIN ISOLATION LEVEL REPEATABLE READ;\n=> SELECT 1; -- построен снимок\nОпустошимтаблицу tfreeze и втой жетранзакции загрузим в нее новые\nстроки.(Еслибычитающаятранзакцияуспелаобратитьсякtfreeze,коман-\nдаTRUNCATEбылабызаблокирована.)\n=> BEGIN;\n=> TRUNCATE tfreeze;\n=> COPY tfreeze FROM stdin WITH FREEZE;\n1 FOO\n2 BAR\n3 BAZ\n\\.\n=> COMMIT;\nТеперьчитающаятранзакциявидитновыеданныевнарушениеизоляции:\n=> SELECT count(*) FROM tfreeze;\ncount\n−−−−−−−\n3\n(1 row)\n=> COMMIT;\nНо поскольку загрузка данных вряд ли происходит регулярно, в большин-\nствеслучаевэтонепредставляетпроблемы.\nПризагрузкесзаморозкойсразужесоздаетсякартавидимости,ивзаголов- v.14\nкахстраницпроставляетсяпризнаквидимости: с.127\n163",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:48.799330"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 165,
    "chapter": null,
    "section": "7.4 Заморозкавручную",
    "text": "Глава7. Заморозка\n=> SELECT * FROM pg_visibility_map('tfreeze',0);\nall_visible | all_frozen\n−−−−−−−−−−−−−+−−−−−−−−−−−−\nt | t\n(1 row)\n=> SELECT flags & 4 > 0 AS all_visible\nFROM page_header(get_raw_page('tfreeze',0));\nall_visible\n−−−−−−−−−−−−−\nt\n(1 row)\nv.14 Таким образом, после загрузки с заморозкой очистка уже не будетобраба-\nтыватьтаблицу(если,конечно,данныевнейостанутсянеизменными).Ксо-\nжалению,этопоканеработаетдляtoast-таблиц:призагрузкедлинныхзна-\nченийочисткепридетсялишнийразпереписатьзанововсюtoast-таблицу,\nчтобыпроставитьпризнаквидимостивзаголовкивсехстраниц.\n164",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:48.812661"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 166,
    "chapter": null,
    "section": "8.1 Полная очистка",
    "text": "8\nПерестроение таблиц\nи индексов\n8.1. Полная очистка\nНеобходимость\nОбычная очистка освобождает больше места,чем внутристраничная,но и\nонаневсегдарешаетзадачуполностью.\nЕсли файлы таблицы или индекса по каким-то причинам сильно выросли\nв размерах,то обычная очистка освобождаетместо внутри существующих\nстраниц, но число страниц в большинстве случаев не уменьшается. Един-\nственная ситуация,при которой очистка возвращает место операционной\nсистеме, — образование полностью пустых страниц в самом конце файла, с.133\nчтопроисходитнечасто.\nИзлишнийразмерприводиткнеприятнымпоследствиям:\n• замедляетсяполноесканированиетаблицы(илииндекса);\n• может потребоваться больший буферный кеш (ведь кешируются стра-\nницы,аплотностьполезнойинформациивнихпадает);\n• вB-деревеможетпоявитьсялишнийуровень,которыйбудетзамедлять\nиндексныйдоступ;\n• файлызанимаютлишнееместонадискеиврезервныхкопиях.\n165",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:48.829321"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 167,
    "chapter": null,
    "section": "8.1 Полная очистка",
    "text": "Глава8. Перестроениетаблицииндексов\nЕслидоляполезнойинформациивфайлахопустиласьниженекоторогора-\nзумногопредела,администраторможетвыполнитьполнуюочистку1коман-\nдойVACUUMFULL.Приэтомтаблицаивсеееиндексыперестраиваютсясну-\nля,аданныеупаковываютсямаксимальнокомпактно(сучетомпараметра\nс.111 fillfactor).\nПри полной очистке PostgreSQL последовательно перестраивает сначала\nтаблицу,азатемикаждыйизееиндексов.Впроцессеперестроенияобъек-\nтанадискехранятсяистарые,иновыефайлы2,поэтомудляработыполной\nочисткиможетпотребоватьсядовольномногосвободногоместа.\nСледуетучитывать,чтонавсевремяперестроениятаблицаполностьюбло-\nкируетсяидлязаписи,идлячтения.\nОценка плотности информации\nДляиллюстрациивставимвтаблицунекотороеколичествострок:\n=> TRUNCATE vac;\n=> INSERT INTO vac(id,s)\nSELECT id, id::text FROM generate_series(1,500000) id;\nПлотностьинформацииудобнооцениватьспомощьюспециальногорасши-\nренияpgstattuple:\n=> CREATE EXTENSION pgstattuple;\n=> SELECT * FROM pgstattuple('vac') \\gx\n−[ RECORD 1 ]−−−−−−+−−−−−−−−−\ntable_len | 70623232\ntuple_count | 500000\ntuple_len | 64500000\ntuple_percent | 91.33\ndead_tuple_count | 0\ndead_tuple_len | 0\ndead_tuple_percent | 0\nfree_space | 381844\nfree_percent | 0.54\n1 postgrespro.ru/docs/postgresql/17/routine-vacuuming#VACUUM-FOR-SPACE-RECOVERY.\n2 backend/commands/cluster.c.\n166",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:48.861617"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 168,
    "chapter": null,
    "section": "8.1 Полнаяочистка",
    "text": "8.1. Полнаяочистка\nФункция читает всю таблицу и показывает статистику по распределению\nместа в файлах. Поле tuple_percent показывает процент места, занято-\nгополезнымиданными(версиямистрок).Егозначениенеизбежноменьше\n100%из-занакладныхрасходовнаслужебнуюинформациювнутристрани-\nцы,нотемнеменеевэтомпримереонодовольновысоко.\nДля индекса выводится другая информация, но поле avg_leaf_density\nимееттотжесмысл:процентполезнойинформации(влистовыхстраницах).\n=> SELECT * FROM pgstatindex('vac_s') \\gx\n−[ RECORD 1 ]−−−−−−+−−−−−−−−−−\nversion | 4\ntree_level | 3\nindex_size | 114302976\nroot_block_no | 2825\ninternal_pages | 376\nleaf_pages | 13576\nempty_pages | 0\ndeleted_pages | 0\navg_leaf_density | 53.88\nleaf_fragmentation | 10.59\nИспользованные функции расширения pgstattuple читают таблицу или\nиндекс целиком,чтобы получитьточную информацию.В случае большого\nобъектаэтоможетоказатьсяслишкомзатратно,поэтомуврасширенииесть\nфункцияpgstattuple_approx,котораяпропускаетстраницы,отмеченные\nвкартевидимости,ипоказываетпримерныецифры.\nЕщеболеебыстрый,ноиещеменееточныйспособ—прикинутьотношение\nобъемаданныхкразмеруфайлапосистемномукаталогу1.\nВоткакойразмерзанимаюттаблицаииндекс:\n=> SELECT pg_size_pretty(pg_table_size('vac')) AS table_size,\npg_size_pretty(pg_indexes_size('vac')) AS index_size;\ntable_size | index_size\n−−−−−−−−−−−−+−−−−−−−−−−−−\n67 MB | 109 MB\n(1 row)\nТеперьудалим90%всехстрок:\n1 wiki.postgresql.org/wiki/Show_database_bloat.\n167",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:48.894487"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 169,
    "chapter": null,
    "section": "8.1 Полнаяочистка",
    "text": "Глава8. Перестроениетаблицииндексов\n=> DELETE FROM vac WHERE id % 10 != 0;\nDELETE 450000\nПослеобычнойочисткиразмерфайловнеменяется,посколькунетпустых\n«хвостовых»страниц:\n=> VACUUM vac;\n=> SELECT pg_size_pretty(pg_table_size('vac')) AS table_size,\npg_size_pretty(pg_indexes_size('vac')) AS index_size;\ntable_size | index_size\n−−−−−−−−−−−−+−−−−−−−−−−−−\n67 MB | 109 MB\n(1 row)\nНоплотностьинформацииуменьшиласьпримерновдесятьраз:\n=> SELECT vac.tuple_percent,\nvac_s.avg_leaf_density\nFROM pgstattuple('vac') vac,\npgstatindex('vac_s') vac_s;\ntuple_percent | avg_leaf_density\n−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−\n9.13 | 6.71\n(1 row)\nСейчастаблицаииндексразмещаютсявфайлахсоследующимиименами:\n=> SELECT pg_relation_filepath('vac') AS vac_filepath,\npg_relation_filepath('vac_s') AS vac_s_filepath \\gx\n−[ RECORD 1 ]−−+−−−−−−−−−−−−−−−−−\nvac_filepath | base/16391/16521\nvac_s_filepath | base/16391/16522\nТеперьпроверим,чтополучитсяпослеполнойочистки.\n=> VACUUM FULL vac;\nv.12 Покакомандаработает,ходеевыполненияможноотслеживатьвпредстав-\nлении pg_stat_progress_cluster (похожем на представление для обыч-\nнойочисткиpg_stat_progress_vacuum):\n168",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:48.926080"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 170,
    "chapter": null,
    "section": "8.1 Полнаяочистка",
    "text": "8.1. Полнаяочистка\n=> SELECT * FROM pg_stat_progress_cluster \\gx\n−[ RECORD 1 ]−−−−−−−+−−−−−−−−−−−−−−−−−\npid | 33908\ndatid | 16391\ndatname | internals\nrelid | 16482\ncommand | VACUUM FULL\nphase | rebuilding index\ncluster_index_relid | 0\nheap_tuples_scanned | 50000\nheap_tuples_written | 50000\nheap_blks_total | 8621\nheap_blks_scanned | 8621\nindex_rebuild_count | 0\nVACUUM\nЭтапы выполнения полной очистки1,конечно,отличаются отэтапов обыч-\nнойочистки.\nПослеполнойочисткифайлыпоменялисьнановые:\n=> SELECT pg_relation_filepath('vac') AS vac_filepath,\npg_relation_filepath('vac_s') AS vac_s_filepath \\gx\n−[ RECORD 1 ]−−+−−−−−−−−−−−−−−−−−\nvac_filepath | base/16391/16533\nvac_s_filepath | base/16391/16536\nРазмертаблицыииндексасущественноуменьшился:\n=> SELECT pg_size_pretty(pg_table_size('vac')) AS table_size,\npg_size_pretty(pg_indexes_size('vac')) AS index_size;\ntable_size | index_size\n−−−−−−−−−−−−+−−−−−−−−−−−−\n6904 kB | 6504 kB\n(1 row)\nПлотность информации после полной очистки, соответственно, увеличи-\nлась,причемвиндексеонаувеличиласьдажепосравнениюспервоначаль-\nной.Зановосоздатьиндекс(B-дерево)поимеющимсяданнымобычновы-\nгоднее,чем вставлятьданные строка за строкой в уже имеющийся индекс:\n1 postgrespro.ru/docs/postgresql/17/progress-reporting#CLUSTER-PHASES.\n169",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:48.957814"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 171,
    "chapter": null,
    "section": "91.23 | 91.08",
    "text": "Глава8. Перестроениетаблицииндексов\n=> SELECT vac.tuple_percent,\nvac_s.avg_leaf_density\nFROM pgstattuple('vac') vac,\npgstatindex('vac_s') vac_s;\ntuple_percent | avg_leaf_density\n−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−\n91.23 | 91.08\n(1 row)\nЗаморозка\nПри перестроении таблицы версии строк замораживаются, поскольку это\nничегонестоитпосравнениюсостальнымобъемомработы:\n=> SELECT * FROM heap_page('vac',0,0) LIMIT 5;\nctid | state | xmin | xmin_age | xmax\n−−−−−−−+−−−−−−−−+−−−−−−−+−−−−−−−−−−+−−−−−−\n(0,1) | normal | 874 f | 6 | 0 a\n(0,2) | normal | 874 f | 6 | 0 a\n(0,3) | normal | 874 f | 6 | 0 a\n(0,4) | normal | 874 f | 6 | 0 a\n(0,5) | normal | 874 f | 6 | 0 a\n(5 rows)\nОднако страницы не отмечаются в карте видимости и заморозки,и в заго-\nловкестраницынепроставляетсяпризнаквидимости(какэтопроисходит\nс.162 привыполнениикомандыCOPYспараметромFREEZE):\n=> SELECT * FROM pg_visibility_map('vac',0);\nall_visible | all_frozen\n−−−−−−−−−−−−−+−−−−−−−−−−−−\nf | f\n(1 row)\n=> SELECT flags & 4 > 0 all_visible\nFROM page_header(get_raw_page('vac',0));\nall_visible\n−−−−−−−−−−−−−\nf\n(1 row)\n170",
    "tables": [
      {
        "table_index": 0,
        "rows": 5,
        "cols": 1,
        "content": "f\nf\nf\nf\nf"
      }
    ],
    "extracted_at": "2025-10-02T15:59:48.989067"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 172,
    "chapter": null,
    "section": "8.2 Другиеспособыперестроения",
    "text": "8.2. Другиеспособыперестроения\nИтолькопослевыполнениякомандыVACUUM(илисрабатыванияавтоочист-\nки)ситуацияисправляется:\n=> VACUUM vac;\n=> SELECT * FROM pg_visibility_map('vac',0);\nall_visible | all_frozen\n−−−−−−−−−−−−−+−−−−−−−−−−−−\nt | t\n(1 row)\n=> SELECT flags & 4 > 0 AS all_visible\nFROM page_header(get_raw_page('vac',0));\nall_visible\n−−−−−−−−−−−−−\nt\n(1 row)\nФактическиэтоозначает,чтотакаястраницабудетперезаписанаещераз—\nдажееслиприперестроениивсеверсиистроктабличнойстраницынаходи-\nлисьзагоризонтомбазыданных.\n8.2. Другие способы перестроения\nАналоги полной очистки\nПомимополнойочисткиестьещенесколькокоманд,которыеперестраива-\nюттаблицы и индексы полностью.Все они монопольно блокируют работу\nстаблицей,всеониудаляютстарыефайлыданныхисоздаютновые.\nКомандаCLUSTER вовсеманалогичнаVACUUM FULL,нодополнительноупо- с.397\nрядочивает версии строк в файлах в соответствии с одним из имеющихся\nиндексов.Этодаетпланировщикувозможностьвнекоторыхслучаяхболее\nэффективно использовать индексный доступ. Однако надо понимать, что с.403\nкластеризациянеподдерживается:припоследующихизмененияхтаблицы\nфизическийпорядокверсийстрокбудетнарушаться.\n171",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.015477"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 173,
    "chapter": null,
    "section": "8.2 Другиеспособыперестроения",
    "text": "Глава8. Перестроениетаблицииндексов\nСточкизрениякодаVACUUMFULL—просточастныйслучайCLUSTER,нетре-\nбующийпереупорядочиваниястрок1.\nКоманда REINDEX перестраивает индекс или несколько индексов2. VACUUM\nFULLиCLUSTERфактическииспользуютмеханизмэтойкоманды,чтобыпе-\nрестроитьиндексы.\nКомандаTRUNCATE3удаляетвсетабличныестрокиилогическисоответству-\nс.87 ет команде DELETE без условия WHERE.Но DELETE только помечает версии\nстроккакудаленные,чтотребуетдальнейшейочистки.TRUNCATEжепросто\nсоздаетновыйчистыйфайл,что,какправило,работаетбыстрее.\nПерестроение без долгих блокировок\nПолнаяочистканепредполагаетрегулярногоиспользования,таккакполно-\nс.251 стьюблокируетвсякийдоступктаблице(включаяивыполнениезапросов)\nнавсевремясвоейработы.Длявысокодоступныхсистемэтообычнонепри-\nемлемо.\nСуществуетнесколькорасширений(например,pg_repack4),позволяющих\nперестроить таблицу и индексы практически без прерывания обслужива-\nния. Исключительная блокировка таблицы все равно требуется, но лишь\nв начале и в конце работы, и на короткое время. Достигается это более\nсложной реализацией: в процессе перестроения изменения данных исход-\nнойтаблицысохраняютсятриггером,азатемприменяютсякновойтаблице;\nвконцеоднатаблицаподменяетсянадругуювсистемномкаталоге.\nИнтересное решение предлагает утилита pgcompacttable5. Идея состоит\nвмногократномфиктивном(неменяющемданные)обновлениистроктаб-\nлицы,в результате которого актуальные версии строк постепенно переме-\nщаютсявнутрифайлаближекегоначалу.Междусериямиобновленийзапус-\n1 backend/commands/cluster.c.\n2 backend/commands/indexcmds.c.\n3 backend/commands/tablecmds.c,функцияExecuteTruncate.\n4 github.com/reorg/pg_repack.\n5 github.com/dataegret/pgcompacttable.\n172",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.050441"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 174,
    "chapter": null,
    "section": "8.3 Профилактика",
    "text": "8.3. Профилактика\nкаетсяочистка,котораяудаляетнеактуальныеверсииипостепенноусекает с.133\nфайл.Такойподходотнимаетсущественнобольшевременииресурсов,но\nнетребуетдополнительногоместадляперестроениятаблицыинесоздает\nпиковыхнагрузок.Кратковременныеисключительныеблокировкиприусе-\nчениитаблицывозникаютивэтомслучае,ноониобрабатываютсяочисткой\nдостаточномягко.\n8.3. Профилактика\nЧитающие запросы\nОднойизпричинраздуванияфайловявляетсясовмещениедолговыполня-\nющихсятранзакций,удерживающихгоризонтбазы,сактивнымобновлени- с.106\nемданных.\nСамипосебедолгие(читающие)транзакцииневызываютникакихпроблем.\nПоэтомуобычноерешение—разнестинагрузкунаразныемашины:OLAP-\nтранзакциивыполнятьнареплике,абыстрыеOLTP-транзакцииоставитьна\nосновном сервере.Конечно,это усложняети удорожаетсистему,но может\nоказатьсянеобходимым.\nБывают ситуации, когда долгие транзакции вызваны не необходимостью,\nаошибкамивприложенииилидрайвере.Еслипроблемунеудаетсярешить\nцивилизованнымпутем,уадминистраторавраспоряженииестьпарапара-\nметров: idle_in_transaction_session_timeout, который определяет максималь- 0ms\nное время жизни бездействующей транзакции, и transaction_timeout, кото- 0ms\nрый ограничиваетобщую продолжительностьтранзакции. Попрошествии v.17\nуказанноговремени(еслиононеравнонулю)транзакцияпрерывается.\nОбновление данных\nВтораяпричинараздуваниясостоитводномоментномизменениибольшого\nчисластрок.Обновлениевсехстроктаблицыможетпривестикувеличению\nколичества версий в два раза,а очистка не успеет вмешаться.Внутристра-\nничнаяочисткаможетсгладитьпроблему,ноитолько.\n173",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.081601"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 175,
    "chapter": null,
    "section": "8.3 Профилактика",
    "text": "Глава8. Перестроениетаблицииндексов\nДобавим к таблице столбец processed,в котором будем отмечать обрабо-\nтанныестроки:\n=> ALTER TABLE vac ADD processed boolean DEFAULT false;\n=> SELECT pg_size_pretty(pg_table_size('vac'));\npg_size_pretty\n−−−−−−−−−−−−−−−−\n6936 kB\n(1 row)\nПосле обновления всех строк размер таблицы увеличивается примерно\nвдвое:\n=> UPDATE vac SET processed = true;\nUPDATE 50000\n=> SELECT pg_size_pretty(pg_table_size('vac'));\npg_size_pretty\n−−−−−−−−−−−−−−−−\n14 MB\n(1 row)\nРешениесостоитвуменьшенииобъемаизменений,выполняемыхводной\nтранзакции, и разнесении изменений во времени, чтобы очистка успела\nудалитьненужныеверсиистрокиосвободитьместоподновыеверсиивнут-\nриужесуществующихстраниц.Еслисчитать,чтообновлениекаждойстроки\nвпринципеможетбытьзафиксированонезависимо,товкачествешаблона\nможноиспользоватьзапрос,выделяющийвтаблицепакетстрокопределен-\nногоразмера:\nSELECT идентификатор\nFROM таблица\nWHERE фильтрация уже обработанных строк\nLIMIT размер пакета\nFOR UPDATE SKIP LOCKED\nВэтомфрагментекодавыбираетсяисразублокируетсянаборстрокнеболее\nзаданного размера.При этом строки,уже заблокированные другимитран-\nс.275 закциями, пропускаются — они попадут в другой пакет в следующий раз.\nЭтодовольноуниверсальныйиудобныйспособ,позволяющийлегкоменять\nразмерпакетаивыполнятьповторнуюобработкувслучаекаких-либосбоев.\n174",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.113533"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 176,
    "chapter": null,
    "section": "8.3 Профилактика",
    "text": "8.3. Профилактика\nСбросим признак обработки и выполним полную очистку, чтобы вернуть\nразмеркисходному:\n=> UPDATE vac SET processed = false;\n=> VACUUM FULL vac;\nПослеобновленияпервогопакетаразмертаблицынемногоувеличивается:\n=> WITH batch AS (\nSELECT id FROM vac WHERE NOT processed LIMIT 1000\nFOR UPDATE SKIP LOCKED\n)\nUPDATE vac SET processed = true\nWHERE id IN (SELECT id FROM batch);\nUPDATE 1000\n=> SELECT pg_size_pretty(pg_table_size('vac'));\npg_size_pretty\n−−−−−−−−−−−−−−−−\n7064 kB\n(1 row)\nНобольшеразмерпрактическинерастет,посколькуновыеверсиистрокдо-\nбавляютсянаместовычищенныхверсий:\n=> VACUUM vac;\n=> WITH batch AS (\nSELECT id FROM vac WHERE NOT processed LIMIT 1000\nFOR UPDATE SKIP LOCKED\n)\nUPDATE vac SET processed = true\nWHERE id IN (SELECT id FROM batch);\nUPDATE 1000\n=> SELECT pg_size_pretty(pg_table_size('vac'));\npg_size_pretty\n−−−−−−−−−−−−−−−−\n7072 kB\n(1 row)\n175",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.139127"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 180,
    "chapter": null,
    "section": "9.1 Кеширование",
    "text": "9\nБуферный кеш\n9.1. Кеширование\nКеширование используется в современных вычислительных системах по-\nвсеместно,какнапрограммном,такинааппаратномуровне.Уодноготоль-\nкопроцессораможнонасчитатьтри-четыреуровнякеша;свойкешбывает\nтакжеиуконтроллеровдисковыхмассивов,иусамихдисков.\nВообще,любой кеш нужендлятого,чтобы компенсировать разную произ-\nводительность двух типов памяти, одна из которых быстрее, но дороже и\nменьшепообъему,адругая—медленнее,нодешевлеибольше.Вбыстрой\nпамятиневозможноразместитьвседанныеизмедленнойпамяти.Новболь-\nшинствеслучаевактивнаяработаведетсяодновременнотолькоснебольшой\nвыборкой,поэтому,выделив часть быстрой памяти под кеш для хранения\n«горячих» данных, удается существенно экономить на обращениях к мед-\nленномуустройству.\nБуферныйкешPostgreSQL1 хранитстраницыотношений,сглаживаяразни-\nцумежду временемдоступа к оперативной памяти (наносекунды)и кдис-\nкам(миллисекунды).\nСвойкеш,решающийтужесамуюзадачу,имеетсяиуоперационнойсисте-\nмы.ПоэтомуобычноприпроектированииСУБДстараютсяизбегатьдвойно-\nгокеширования,предпочитаяобращатьсякдискунапрямую,минуякешОС.\nНовслучаеPostgreSQLэтонетак:вседанныечитаютсяизаписываютсяспо-\nмощьюбуферизованныхфайловыхопераций.\n1 backend/storage/buffer/README.\n179",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.165258"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 181,
    "chapter": null,
    "section": "9.1 Кеширование",
    "text": "Глава9. Буферныйкеш\nЧтобы избежать двойного кеширования, необходимо использовать прямой ввод-\nвывод.Этоболееэффективно,посколькуможноиспользоватьпрямойдоступкпамя-\nти(DMA)вместокопированиястраницизбуферногокешавадресноепространство\nоперационнойсистемы,иктомужепозволяетнепосредственноконтролироватьфи-\nзическуюзаписьнадиск.Ноприпрямомвводе-выводеперестаетработатьпредвы-\nборка данных,которую обеспечиваетбуферизация,и такую предвыборкупридется\nс.415 организовыватьотдельно,используя возможности асинхронного ввода-вывода.Это\nпотребует существенных изменений в коде ядра,и к томуже придется иметьдело\nснесовместимостямиоперационныхсистемвчастиподдержкипрямогоиасинхрон-\nного ввода-вывода.Однако,реализовав асинхронное взаимодействие,можно полу-\nчитьдополнительныепреимущества,избегаяпростоеввовремяобращенийкдискам.\nЭта большая работа уже ведется сообществом1, и для отладки появился параметр\nv.16 debug_io_direct,нопрактическиполезныерезультатыпоявятсяещенескоро.\n9.2. Устройство буферного кеша\nБуферныйкешрасполагаетсявобщейпамятисервераидоступенвсемпро-\nцессам. Он занимает бóльшую часть общей памяти и является одной из\nсамых важных и сложных структур данных. Понимание принципа работы\nкеша важно само по себе; к тому же многие другие структуры (такие как\nвложенные транзакции, статусы транзакций clog, журнальные записи) ис-\nпользуютпохожее,хотяиболеепростоекеширование.\nКешназываетсябуферным,потомучтопредставляетсобоймассивбуферов.\nКаждыйбуферрезервируетфрагментпамяти,достаточныйдляоднойстра-\nницыданныхиеезаголовка2.\nбуферныйкеш\nзаголовок\nстраница\n1 www.postgresql.org/message-id/flat/20210223100344.llw5an2aklengrmn%40alap3.anarazel.de.\n2 include/storage/buf_internals.h.\n180",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.203731"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 182,
    "chapter": null,
    "section": "9.2 Устройствобуферногокеша",
    "text": "9.2. Устройствобуферногокеша\nЗаголовоксодержитинформациюобуфереизагруженнойвнегостранице,\nтакуюкак:\n• физическое расположение страницы (идентификатор файла отноше-\nния,слойиномерблокавслое);\n• признактого,чтоданные на странице изменилисьи рано или поздно\nдолжныбытьзаписанынадиск(такуюстраницуназываютгрязной);\n• числообращенийкбуферу(usagecount);\n• счетчикзакрепленийбуфера(pincountилиreferencecount).\nЧтобы получить доступ к странице данных отношения, процесс запраши-\nвает ее у менеджера буферов1 и получает номер буфера,содержащего эту\nстраницу.Процесс читаетданные из страницы в кеше итам же может ме-\nнятьих.Навремяработысостраницейбуферзакрепляется,чтобыменеджер\nнезаменилеенадругую.Прикаждомзакрепленииувеличиваетсясчетчик\nобращений к странице. Помимо закреплений, применяются и другие бло-\nкировки. с.296\nПокастраницанаходитсявбуферномкеше,работаснейнеприводиткфай-\nловымоперациям.\nВнутрьбуферного кеша позволяетзаглянутьрасширение pg_buffercache:\n=> CREATE EXTENSION pg_buffercache;\nСоздадимтаблицуивставимвнееоднустроку:\n=> CREATE TABLE cacheme(\nid integer\n) WITH (autovacuum_enabled = off);\n=> INSERT INTO cacheme VALUES (1);\nТеперьвбуферномкешесодержитсятабличнаястраницастолькочтовстав-\nленной строкой. В этом можно убедиться, отобрав буферы, относящиеся\nкконкретнойтаблице.Такойзапроснамещепригодится,поэтомуобернем\nеговфункцию:\n1 backend/storage/buffer/bufmgr.c.\n181",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.237648"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 183,
    "chapter": null,
    "section": "9.2 Устройствобуферногокеша",
    "text": "Глава9. Буферныйкеш\n=> CREATE FUNCTION buffercache(rel regclass)\nRETURNS TABLE(\nbufferid integer, relfork text, relblk bigint,\nisdirty boolean, usagecount smallint, pins integer\n) AS $$\nSELECT bufferid,\nCASE relforknumber\nWHEN 0 THEN 'main'\nWHEN 1 THEN 'fsm'\nWHEN 2 THEN 'vm'\nEND,\nrelblocknumber,\nisdirty,\nusagecount,\npinning_backends\nFROM pg_buffercache\nWHERE relfilenode = pg_relation_filenode(rel)\nAND relforknumber = 0 -- только main\nORDER BY relforknumber, relblocknumber;\n$$ LANGUAGE sql;\n=> SELECT * FROM buffercache('cacheme');\nbufferid | relfork | relblk | isdirty | usagecount | pins\n−−−−−−−−−−+−−−−−−−−−+−−−−−−−−+−−−−−−−−−+−−−−−−−−−−−−+−−−−−−\n281 | main | 0 | t | 1 | 0\n(1 row)\nСтраницагрязная(isdirty),посколькуизмененаиещенезаписананадиск.\nСчетчикобращений(usagecount)равенединице.\n9.3. Попадание в кеш\nКогдаменеджерубуферовтребуетсяпрочитатьстраницу1,онсначалапыта-\nется найти ее в буферном кеше. Для быстрого поиска нужного буфера ис-\nпользуетсяхеш-таблица2,хранящаяномерабуферов.\nМногиесовременныеязыкипрограммированиявключаютхеш-таблицыкакодиниз\nбазовыхтипов данных.Часто они называются ассоциативным массивом,и действи-\nтельно,сточкизренияпользователяонивыглядяткакмассив,новкачествеиндекса\n1 backend/storage/buffer/bufmgr.c,функцияReadBuffer_common.\n2 backend/storage/buffer/buf_table.c.\n182",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.270818"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 184,
    "chapter": null,
    "section": "9.3 Попаданиевкеш",
    "text": "9.3. Попаданиевкеш\n(который называется ключом хеширования) можно использоватьлюбой тип данных,\nнапримертекстовуюстроку,анецелоечисло.\nДиапазон возможных значений ключа может быть очень велик, но одновременно\nв хеш-таблице хранится не так много значений.Идея хеширования состоит в том,\nчтозначениеключаспомощьюхеш-функцииотображаетсявнекотороецелоечисло.\nПолученное число или частьего битов используется как индекс обычного массива.\nЭлементытакогомассиваназываюткорзинамихеш-таблицы.\nХорошаяхеш-функцияраспределяетключипокорзинамравномерно,нотемнеме-\nнее она может выдать одинаковые числа для разных ключей и таким образом на-\nправитьключиводнуитужекорзину;этоназываетсяколлизией.Поэтомувместесо\nзначением в корзине сохраняется и ключ хеширования,а при чтении значения по\nключуперепроверяютсявсеключи,которыепопаливоднукорзину.\nИзвестно много вариантов реализации хеш-таблиц. Для буферного кеша\nиспользуется динамически расширяемаятаблица c разрешением хеш-кол-\nлизийспомощьюцепочек1.\nКлючомхешированияслужатидентификаторфайлаотношения,типслояи\nномер страницы внутри файла этого слоя. Таким образом, зная страницу,\nможнобыстронайтисодержащийеебуферилиудостовериться,чтострани-\nцынетвкеше.\n3501,0,3\n2610,0,7\nхеш-таблица\n1 backend/utils/hash/dynahash.c.\n183",
    "tables": [
      {
        "table_index": 0,
        "rows": 6,
        "cols": 1,
        "content": "3501,0,3\n\n2610,0,7"
      },
      {
        "table_index": 1,
        "rows": 2,
        "cols": 1,
        "content": ""
      },
      {
        "table_index": 2,
        "rows": 2,
        "cols": 1,
        "content": ""
      }
    ],
    "extracted_at": "2025-10-02T15:59:49.307707"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 185,
    "chapter": null,
    "section": "9.3 Попаданиевкеш",
    "text": "Глава9. Буферныйкеш\nИспользование хеш-таблицы давно вызывает нарекания.Такая структура никак не\nпомогает найти все буферы,занятые страницами определенного отношения.А это\nтребуется при удалении (DROP), опустошении (TRUNCATE) или усечении хвостовой\nс.133 частитаблицывовремяочистки,чтобыубратьизкешасоответствующиестраницы1.\nНохорошуюзаменупоканиктонепредложил.\nЕслиномербуферанайденвхеш-таблице,менеджерзакрепляетэтотбуфер\nи возвращает его номер процессу. После этого процесс может работать со\nстраницейвбуферномкеше,иэтонеприводитковводу-выводу.\nЧтобызакрепитьбуфер,нужноувеличитьсчетчикpincountвзаголовкебу-\nфера;одинитотжебуфермогутодновременнозакрепитьнесколькопроцес-\nсов.Покабуферзакреплен(т.е.значениесчетчикабольшенуля),считается,\nчто буфер используется и его содержимое не должно «радикально» изме-\nниться. Например, в странице может появиться новая версия строки (она\nнебудетвиднаблагодаряправиламвидимости),ностраницанеможетбыть\nзамененанадругую.\nКомандаEXPLAIN спараметрамиanalyze иbuffers непростопоказывает\nпланзапроса,ноивыполняетего,атакжевыводитколичествоиспользован-\nныхбуферов:\n=> EXPLAIN (analyze, buffers, costs off, timing off, summary off)\nSELECT * FROM cacheme;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on cacheme (actual rows=1 loops=1)\nBuffers: shared hit=1\nPlanning:\nBuffers: shared hit=12 read=7\n(4 rows)\nЗдесь hit=1 говорит о том, что потребовалось прочитать одну страницу\nионабыланайденавкеше.\nЗакреплениебуфераувеличилосчетчикобращенийнаединицу:\n1 backend/storage/buffer/bufmgr.c,функцияDropRelFileNodeBuffers.\n184",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.341960"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 186,
    "chapter": null,
    "section": "9.3 Попаданиевкеш",
    "text": "9.3. Попаданиевкеш\n=> SELECT * FROM buffercache('cacheme');\nbufferid | relfork | relblk | isdirty | usagecount | pins\n−−−−−−−−−−+−−−−−−−−−+−−−−−−−−+−−−−−−−−−+−−−−−−−−−−−−+−−−−−−\n281 | main | 0 | t | 2 | 0\n(1 row)\nТеперьобновимстроку,чтобывстраницебылидвеверсии:однаактуальная,\nавторая—мертвая.Этопонадобитсянамчутьпозже.\n=> UPDATE cacheme SET id = 2;\nUPDATE 1\nВоспользуемся тем, что открытый курсор удерживает закрепление, чтобы\nиметьвозможностьбыстропрочитатьследующуюстрокувыборки.Этопоз-\nволитнамувидетьзакреплениевпроцессеработызапроса:\n=> BEGIN;\n=> DECLARE c CURSOR FOR SELECT * FROM cacheme;\n=> FETCH c;\nid\n−−−−\n2\n(1 row)\n=> SELECT * FROM buffercache('cacheme');\nbufferid | relfork | relblk | isdirty | usagecount | pins\n−−−−−−−−−−+−−−−−−−−−+−−−−−−−−+−−−−−−−−−+−−−−−−−−−−−−+−−−−−−\n281 | main | 0 | t | 4 | 1\n(1 row)\nВнекоторыхслучаях,когдатребуетсяименнозакрепленныйбуфер,процесс\nвстаетвочередьизасыпаетдотогомомента,когдаонсможетполучитьмо-\nнопольныйдоступкбуферу.Примертакойоперации—заморозка1. с.150\nНо,какправило,еслипроцессумешаетзакрепление,онпростопропускает\nтакойбуферивыбираетдругой.Примеромможетслужитьочисткатаблицы.\nВданномслучаестраницабудетпропущена,посколькузакреплениепрепят-\nствуетфизическомуудалениюмертвойверсии:\n1 backend/storage/buffer/bufmgr.c,функцияLockBufferForCleanup.\n185",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.374632"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 187,
    "chapter": null,
    "section": "9.3 Попаданиевкеш",
    "text": "Глава9. Буферныйкеш\n=> VACUUM VERBOSE cacheme;\nINFO: vacuuming \"internals.public.cacheme\"\nINFO: finished vacuuming \"internals.public.cacheme\": index\nscans: 0\npages: 0 removed, 1 remain, 1 scanned (100.00% of total)\ntuples: 0 removed, 2 remain, 0 are dead but not yet removable\ntuples missed: 1 dead from 1 pages not removed due to cleanup\nlock contention\nremovable cutoff: 891, which was 0 XIDs old when operation ended\nnew relfrozenxid: 888, which is 1 XIDs ahead of previous value\nfrozen: 0 pages from table (0.00% of total) had 0 tuples frozen\nindex scan not needed: 0 pages from table (0.00% of total) had 0\ndead item identifiers removed\navg read rate: 0.000 MB/s, avg write rate: 82.237 MB/s\nbuffer usage: 24 hits, 0 misses, 3 dirtied\nWAL usage: 4 records, 3 full page images, 24960 bytes\nsystem usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s\nVACUUM\nПри переходе курсора надругую страницу или после его закрытия закреп-\nление снимается.В нашем примере это происходитодновременно с окон-\nчаниемтранзакции:\n=> COMMIT;\n=> SELECT * FROM buffercache('cacheme') WHERE relfork = 'main';\nbufferid | relfork | relblk | isdirty | usagecount | pins\n−−−−−−−−−−+−−−−−−−−−+−−−−−−−−+−−−−−−−−−+−−−−−−−−−−−−+−−−−−−\n281 | main | 0 | t | 4 | 0\n(1 row)\nТакжезакреплениеработаетиприизменениистраницы.Например,доба-\nвимвтаблицуещеоднустроку(онапопадетвтужесамуюстраницу):\n=> INSERT INTO cacheme VALUES (2);\n=> SELECT * FROM buffercache('cacheme') WHERE relfork = 'main';\nbufferid | relfork | relblk | isdirty | usagecount | pins\n−−−−−−−−−−+−−−−−−−−−+−−−−−−−−+−−−−−−−−−+−−−−−−−−−−−−+−−−−−−\n281 | main | 0 | t | 5 | 0\n(1 row)\nСтраницанезаписываетсянадискнемедленно,аостаетсягрязнойвбуфер-\nномкеше:происходитэкономияиначтениисдиска,иназаписи.\n186",
    "tables": [
      {
        "table_index": 0,
        "rows": 2,
        "cols": 2,
        "content": "| 1 dead from 1 pages not removed due to cleanup\nlock contention |"
      }
    ],
    "extracted_at": "2025-10-02T15:59:49.418418"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 188,
    "chapter": null,
    "section": "9.4 Промах кеша",
    "text": "9.4. Промахкеша\n9.4. Промах кеша\nЕсливхеш-таблицененашлосьзаписи,соответствующейстранице,значит,\nэта страница отсутствует в буферном кеше. В таком случае для страницы\nвыбирается(итутжезакрепляется)новыйбуфер,страницачитаетсявэтот\nбуфер,ассылкивхеш-таблицеизменяютсясоответствующимобразом.\nОчистимбуферотстраницы(вместоэтогоможнобылобыочиститьвесьбу- v.17\nферныйкеш,перезапустивэкземпляр):\n=> SELECT pg_buffercache_evict(281);\npg_buffercache_evict\n−−−−−−−−−−−−−−−−−−−−−−\nt\n(1 row)\nПопытка прочитать страницу приведет к промаху кеша, и страница будет\nзагруженавзановоотведенныйдлянеебуфер:\n=> EXPLAIN (analyze, buffers, costs off, timing off, summary off)\nSELECT * FROM cacheme;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on cacheme (actual rows=2 loops=1)\nBuffers: shared read=1 dirtied=1\nPlanning:\nBuffers: shared hit=2\n(4 rows)\nТеперьвместоhitкомандапоказываетread,чтоозначаетпромахкеша.При\nэтомврезультатезапросастраницасталагрязной(dirtied),таккакзапрос\nизменилбиты-подсказкинастранице. с.86\nЗапрос к буферному кешу покажет,что счетчик использованийтолько что\nдобавленнойстраницыравенединице:\n=> SELECT * FROM buffercache('cacheme');\nbufferid | relfork | relblk | isdirty | usagecount | pins\n−−−−−−−−−−+−−−−−−−−−+−−−−−−−−+−−−−−−−−−+−−−−−−−−−−−−+−−−−−−\n329 | main | 0 | t | 1 | 0\n(1 row)\n187",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.450994"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 189,
    "chapter": null,
    "section": "9.4 Промах кеша",
    "text": "Глава9. Буферныйкеш\nОбщуюстатистикуиспользованиябуферногокешадлятаблицыможнопо-\nлучитьизпредставленияpg_statio_all_tables:\n=> SELECT heap_blks_read, heap_blks_hit\nFROM pg_statio_all_tables\nWHERE relname = 'cacheme';\nheap_blks_read | heap_blks_hit\n−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−\n0 | 5\n(1 row)\nАналогичныепредставленияестьдляиндексовидляпоследовательностей.\nВнихтакжесобираетсястатистикапооперациямввода-вывода,ноонадо-\noff ступнатолькопривключенномпараметреtrack_io_timing.\nПоиск буфера и вытеснение\nПоиск подходящего буфера1 —непростая задача.Естьдва варианта разви-\nтиясобытий.\n1. Сразупослезапускасерверакешсодержиттолькопустые,свободныебу-\nферы,ивсеонисвязанывобщийсписок.\nПока остаются свободные буферы, первый из них считается подходя-\nщимиубираетсяизсписка.\nБуферможетвернуться2 всписоксвободныхбуферовтольковтомслу-\nчае, когда страница исчезает, а не заменяется другой страницей. Это\nпроисходит при удалении (DROP), опустошении (TRUNCATE) или усече-\nс.133 ниихвостовойчаститаблицвовремяочистки.\n2. Раноилипоздносвободныебуферызаканчиваются(посколькуобычно\nразмер базы данных превышает объем памяти,выделенной под кеш),\nитогдаменеджердолженвыбратьодиниззанятыхбуферовивытеснить\nнаходящуюсятамстраницу.Дляэтогоиспользуется«часовой»алгоритм\n(clock sweep).Имеется «часовая стрелка»,указывающая на один из бу-\nферов.Стрелкапробегаетбуферныйкешпокругу,уменьшая счетчики\n1 backend/storage/buffer/freelist.c,функцияStrategyGetBuffer.\n2 backend/storage/buffer/freelist.c,функцияStrategyFreeBuffer.\n188",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.484373"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 190,
    "chapter": null,
    "section": "9.4 Промахкеша",
    "text": "9.4. Промахкеша\nобращений к страницам на единицу.Для вытеснения выбирается пер-\nвыйвстреченныйнезакрепленныйбуферснулевымсчетчиком.\nСоднойстороны,счетчикобращенийувеличиваетсякаждыйраз,когда\nбуфериспользуется(закрепляется).Сдругой—уменьшаетсяприпоиске\nбуферадлявытеснения.Такимобразом,впервуюочередьвытесняются\nтестраницы,ккоторымрежеобращалисьвпоследнеевремя,аактивно\nиспользуемыестраницыостаютсявкеше.\nМожно заметить, что если все буферы имеют ненулевой счетчик об-\nращений,то «часовой стрелке» придется сделатьбольше одного круга,\nуменьшая счетчики, пока какой-нибудь из них не обратится наконец\nв ноль.Чтобы избежатьдолгого «наматывания кругов»,максимальное\nзначениесчетчикаобращенийограниченочислом5.\nПослетого как буфер найден,надо удалитьиз хеш-таблицы ссылку на\nстаруюстраницу,ещенаходящуюсявбуфере.\nНоеслибуфероказалсягрязным,тоестьсодержитизмененныеданные, с.216\nстаруюстраницунельзяпростовыбросить—сначаламенеджербуферов\nсохраняетеенадиск.\nсвободныебуферы\n«часоваястрелка»\nВ найденный буфер — среди свободных или среди занятых — менеджер\nбуферов читает новую страницу. Для этого используется буферизованный\nввод-вывод,поэтомустраницабудетпрочитанасдискатольковтомслучае,\nеслиоперационнаясистеманенайдетеевсвоемсобственномкеше.\n189",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.516821"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 191,
    "chapter": null,
    "section": "9.4 Промахкеша",
    "text": "Глава9. Буферныйкеш\nСУБД,использующиепрямойввод-выводинезависящиеоткешаоперационнойси-\nстемы,различаютлогические чтения (из оперативной памяти,то естьиз буферного\nкеша)ифизическиечтения(сдиска).СточкизренияPostgreSQLстраницалибопро-\nчитанаизбуферногокеша,либозапрошенауоперационнойсистемы,ноуСУБДнет\nвозможностиузнать,былалионавпоследнемслучаенайденавоперативнойпамяти\nилипрочитанасдиска.\nВхеш-таблицупомещаетсяссылканановуюстраницу,абуферзакрепляет-\nся.Это приводит к увеличению счетчика обращений,а фактически к уста-\nновкееговединицу.Витогеубуферапоявляетсявремянараститьсчетчик\nобращений,пока«часоваястрелка»обходитпокругубуферныйкеш.\n9.5. Массовое вытеснение\nПри операциях, выполняющих массовое чтение или запись данных, есть\nопасностьбыстроговытесненияполезныхстраницизбуферногокеша«од-\nноразовыми»данными.\nЧтобы этого избежать,для массовых операций в буферном кеше использу-\nются относительно небольшие буферные кольца (buffer ring),и вытеснение\nпроисходитвихпределах,незатрагиваяостальныебуферы.\nНарядустермином«bufferring»вкодеиспользуетсяи«ringbuffer»,тоесть«кольце-\nвойбуфер».Нотакойпереводвызвалбыпутаницу,посколькусам(кольцевой)буфер\nсостоитизбуферов(буферногокеша).Термин«кольцо»лишентакогонедостатка.\nБуферное кольцо заданного размера представляет собой массив буферов,\nкоторыеиспользуются«покругу»,одинзадругим.Сначалабуферноеколь-\nцопусто,ибуферынабираютсявнегоизбуферногокешаобычнымобразом.\nАзатемначинаетдействоватьвытеснение,нотольковнутрикольца1.\nПри этом буферы,входящие в кольцо,не исключаются из буферного кеша\nи в принципе могут быть использованы и другими операциями. Поэтому,\nеслиочереднойбуфероказываетсязакрепленнымилиимеетболееодного\nобращения,онубираетсяизбуферногокольцаизаменяетсякаким-нибудь\nдругимбуфером.\n1 backend/storage/buffer/freelist.c,функцияGetBufferFromRing.\n190",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.552230"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 192,
    "chapter": null,
    "section": "9.5 Массовоевытеснение",
    "text": "9.5. Массовоевытеснение\nСуществуеттристратегиивытеснения.\nСтратегиямассовогочтения(bulkread) применяется при последовательном\nсканировании больших таблиц, размер которых превышает четверть с.361\nбуферногокеша.Используетсякольцоразмером256Кбайт(чтосостав-\nляет32стандартныестраницы).\nПрииспользованииэтойстратегиигрязныестраницынезаписываются\nна диск, чтобы освободить буфер; вместо этого буфер отключается от\nкольца и заменяется другим. Так чтению не надо дожидаться записи,\nионовыполняетсябыстрее.\nЕсливмоментначаласканированиятаблицыоказывается,чтоэтатаб-\nлицаужесканируетсядругимпроцессом,процессприсоединяетсяксу-\nществующему буферному кольцу и получает часть таблицы без избы-\nточного ввода-вывода1.Когда первый процесс заканчиваетсканирова-\nние,второйотдельнодочитываетпропущенноеначалотаблицы.\nСтратегиямассовойзаписи(bulkwrite) применяетсядля операций COPY FROM,\nCREATE TABLE AS SELECT, CREATE MATERIALIZED VIEW и тех вариантов\nALTER TABLE, которые вызывают перезапись таблицы. Выделяется до-\nвольно большое кольцо размером 16 Мбайт (2048 стандартных стра-\nниц),нонебольше 1 отразмеравсегобуферногокеша.\n8\nСтратегияочистки(vacuum) применяетсяпроцессамиочисткиианализапри\nполномсканированиитаблицбезучетакартывидимости.Размерколь-\nца определяется параметром vacuum_buffer_usage_limit, но может быть 2MB\nпереопределенвкомандеVACUUMилиANALYZE. v.16\nБуферные кольца не всегда защищают от ненужного вытеснения. При из-\nменениибольшогочисластроккомандамиUPDATEилиDELETEвыполняется\nсканированиетаблицы,котороеиспользуетстратегиюмассовогочтения,но\nиз-затого,чтостраницыизменяются,буферноекольцовырождаетсяифак-\nтическинеработает.\nДругой важный случай — хранение в базе данных больших значений,для\nкоторыхиспользуетсяTOAST.Доступкtoast-таблицевсегдапроисходитпо с.33\n1 backend/access/common/syncscan.c.\n191",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.588308"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 193,
    "chapter": null,
    "section": "9.5 Массовоевытеснение",
    "text": "Глава9. Буферныйкеш\nиндексу, несмотря на потенциально большой объем читаемых данных, и,\nследовательно,неиспользуетбуферноекольцо.\nПосмотримтеперьнастратегиюмассовогочтения.Дляупрощениярасчетов\nсоздадимтаблицутак,чтобыпривставкеоднастроказанималацелуюстра-\nницу.Размербуферногокешапоумолчанию—16384страницыпо8Кбайт.\nЗначит,чтобы сканирование таблицы использовало буферное кольцо,таб-\nлицадолжназаниматьбольше4096страниц.\n=> CREATE TABLE big(\nid integer PRIMARY KEY GENERATED ALWAYS AS IDENTITY,\ns char(1000)\n) WITH (fillfactor = 10);\n=> INSERT INTO big(s) SELECT 'FOO' FROM generate_series(1,4096+1);\nПроанализируемтаблицу.\n=> ANALYZE big;\n=> SELECT relname, relfilenode, relpages\nFROM pg_class\nWHERE relname IN ('big', 'big_pkey');\nrelname | relfilenode | relpages\n−−−−−−−−−−+−−−−−−−−−−−−−+−−−−−−−−−−\nbig | 16556 | 4097\nbig_pkey | 16561 | 14\n(2 rows)\nv.17 Очистимкешоттабличныхстраниц,прочитанныхвовремяанализа,после\nчегопрочитаемвсютаблицу:\n=> SELECT pg_buffercache_evict(bufferid)\nFROM pg_buffercache\nWHERE relfilenode = pg_relation_filenode('big'::regclass);\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT * FROM big;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on big (actual rows=4097 loops=1)\n(1 row)\nТабличнымистраницамивбуферномкешезанятотолько32буфера,состав-\nлявшихбуферноекольцоэтойоперации:\n192",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.621788"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 194,
    "chapter": null,
    "section": "9.5 Массовоевытеснение",
    "text": "9.5. Массовоевытеснение\n=> SELECT count(*)\nFROM pg_buffercache\nWHERE relfilenode = pg_relation_filenode('big'::regclass);\ncount\n−−−−−−−\n32\n(1 row)\nЕсли же таблица читается с помощью индекса,то буферное кольцо не ис-\nпользуется:\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT * FROM big\nORDER BY id;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Scan using big_pkey on big (actual rows=4097 loops=1)\n(1 row)\nВрезультатевбуферномкешеоказываетсявсятаблицаивесьиндекс:\n=> SELECT relfilenode, count(*)\nFROM pg_buffercache\nWHERE relfilenode IN (\npg_relation_filenode('big'), pg_relation_filenode('big_pkey')\n)\nGROUP BY relfilenode;\nrelfilenode | count\n−−−−−−−−−−−−−+−−−−−−−\n16561 | 14\n16556 | 4097\n(2 rows)\nПодробнаяинформацияовводе-выводе,проходящемчерезбуферныйкеш, v.16\nнакапливается в представлении pg_stat_io. Например, можно изучить\nобъемввода-выводавразбивкепостратегиямиспользованиябуферныхко-\nлец(контекстnormalсоответствуетобычнымоперациямбезкольца):\n=> SELECT context, sum(reads) reads, sum(writes) writes,\nsum(hits) hits, sum(evictions) evictions, sum(reuses) reuses\nFROM pg_stat_io\nWHERE object = 'relation'\nGROUP BY context;\n193",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.653150"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 195,
    "chapter": null,
    "section": "9.5 Массовоевытеснение",
    "text": "Глава9. Буферныйкеш\ncontext | reads | writes | hits | evictions | reuses\n−−−−−−−−−−−+−−−−−−−−+−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−+−−−−−−−−\nvacuum | 658529 | 544152 | 168505 | 2649 | 653199\nnormal | 103844 | 373088 | 71936923 | 277869 |\nbulkwrite | 0 | 0 | 8 | 2 | 0\nbulkread | 256194 | 108324 | 94895 | 152228 | 105566\n(4 rows)\nПомимо количества прочитанных и записанных страниц (reads и writes)\nздесьпоказаночислопопаданийвкеш(hits)ивытесненийизкеша:«обыч-\nные» вытеснения учитываются в поле evictions, а вытеснения страниц\nизбуферногокольца—вполеreuses.\n9.6. Настройка размера\n128MB Размер буферного кеша определяется параметром shared_buffers.Значение\nпоумолчаниюзаведомозанижено;имеетсмыслувеличитьегосразужепос-\nлеустановкиPostgreSQL.Изменениепараметратребуетперезапускасерве-\nра,посколькуобщаяпамятьвыделяетсяподкешпристартесервера.\nИзкакихсоображенийвыбиратьподходящеезначение?\nДаже самая большая база имеет ограниченный набор «горячих» данных,\nс которыми ведется активная работа в каждый момент времени.В идеале\nименноэтотнаборидолженпомещатьсявбуферныйкеш(конечно,сзапа-\nсомподнеизбежные«одноразовые»данные).Еслиразмеркешабудетмень-\nше, то активно используемые страницы будут постоянно вытеснять друг\nдруга, создавая избыточный ввод-вывод. Но и бездумно увеличивать кеш\nтоже неправильно, поскольку это увеличивает накладные расходы на его\nподдержание,аоперативнаяпамятьтребуетсяидлядругихнужд.\nОптимальныйразмербуферногокешабудетразнымвразныхсистемах:он\nзависитиотобщегодоступногообъемапамяти,иотданных,иотпрофиля\nнагрузки.Ксожалению,неттакоговолшебногозначенияилидажеформулы,\nодинаковохорошоподходящейвсем.\nНадо также принимать во внимание, что промах кеша PostgreSQL не обя-\nзательноприводиткфизическомувводу-выводу.Принебольшомбуферном\n194",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.688980"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 196,
    "chapter": null,
    "section": "9.6 Настройкаразмера",
    "text": "9.6. Настройкаразмера\nкеше свободное место будет задействовано под кеш операционной систе-\nмы,чтоможетвопределеннойстепенисглаживатьпроблему.Но,вотличие\nотСУБД,операционнаясистеманичегонезнаетосмыслепрочитанныхдан-\nных,поэтомуиспользуетдругуюстратегиювытеснения.\nСтандартнаярекомендация—взятьвкачествепервогоприближения 1 опе-\n4\nративнойпамяти,адальшесмотретьпоситуации.\nЛучшевсегопровестиэксперименты:увеличитьилиуменьшитьразмерке-\nша и сравнить характеристики системы. Конечно, для этого надо иметь\nтестовый стенд,аналогичный производственной системе,и уметь воспро-\nизводитьтиповуюнагрузку.\nНонекоторыйанализвсежевозможеннаосновестатистикивpg_stat_io\nиспомощьюрасширенияpg_buffercache.Например,можноизучитьрас-\nпределениебуферовпостепениихиспользования:\n=> SELECT usagecount, count(*)\nFROM pg_buffercache\nGROUP BY usagecount\nORDER BY usagecount;\nusagecount | count\n−−−−−−−−−−−−+−−−−−−−\n1 | 4188\n2 | 86\n3 | 15\n4 | 12\n5 | 201\n| 11882\n(6 rows)\nПустые значения счетчика соответствуют свободным буферам. В данном\nслучае это неудивительно, поскольку сервер перезапускался и к тому же\nпрактическибездействует.Большинствозанятыхбуферовсодержатстрани-\nцы системных таблиц, которые были прочитаны обслуживающим процес-\nсомдлязаполнениясвоегокешасистемногокаталогаидлявыполненияза-\nпросов.\nМожнопосмотреть,какаячастькаждогоизотношенийзакешированаина-\nсколькоактивноиспользуютсяэтиданные(вэтомзапросеактивнымисчи-\nтаютсястраницысосчетчикомиспользованиябольшеединицы):\n195",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.720779"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 197,
    "chapter": null,
    "section": "9.6 Настройкаразмера",
    "text": "Глава9. Буферныйкеш\n=> SELECT c.relname,\ncount(*) blocks,\nround( 100.0 * 8192 * count(*) /\npg_table_size(c.oid) ) AS \"% of rel\",\nround( 100.0 * 8192 * count(*) FILTER (WHERE b.usagecount > 1) /\npg_table_size(c.oid) ) AS \"% hot\"\nFROM pg_buffercache b\nJOIN pg_class c ON pg_relation_filenode(c.oid) = b.relfilenode\nWHERE b.reldatabase IN (\n0, -- общие объекты кластера\n(SELECT oid FROM pg_database\nWHERE datname = current_database())\n)\nAND b.usagecount IS NOT NULL\nGROUP BY c.relname, c.oid\nORDER BY 2 DESC\nLIMIT 5;\nrelname | blocks | % of rel | % hot\n−−−−−−−−−−−−−−+−−−−−−−−+−−−−−−−−−−+−−−−−−−\nbig | 4097 | 100 | 1\npg_attribute | 42 | 69 | 52\npg_proc | 25 | 22 | 15\npg_class | 17 | 94 | 67\nbig_pkey | 14 | 100 | 100\n(5 rows)\nЗдесьвидно,чтотаблицаbig иееиндексполностьюзакешированы,ноих\nстраницынеиспользуютсяактивно.\nИзучениеданныхвразличныхразрезахможетдатьполезнуюинформацию\nдляразмышлений.Стоитучитывать,чтозапросыкpg_buffercache:\n• надоповторятьнесколькораз,таккакцифрыбудутменятьсявопреде-\nленныхпределах;\n• не надо выполнятьнепрерывно,потому что представление блокирует,\nхотьикратковременно,просматриваемыебуферы.\nv.16 Поэтомудлямониторингалучшепользоватьсядругимифункциямирасши-\nрения—pg_buffercache_summaryиpg_buffercache_usage_counts,—ко-\nторые требуют меньше блокировок и за счет этого позволяют быстро оце-\nнитьобщую(хотя,возможно,немногорассогласованную)картинупроисхо-\nдящего.\n196",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.753029"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 198,
    "chapter": null,
    "section": "9.7 Прогрев кеша",
    "text": "9.7. Прогревкеша\n9.7. Прогрев кеша\nПосле перезапуска сервера должно пройти некоторое время, чтобы кеш\n«прогрелся»—набрал актуальные активно использующиеся данные.Иног-\nдаможетоказатьсяполезнымсразупрочитатьвкешданныеопределенных\nтаблиц,идляэтогопредназначенорасширениеpg_prewarm:\n=> CREATE EXTENSION pg_prewarm;\nКроме обычного чтения таблиц в буферный кеш (или только в кеш опера- v.11\nционнойсистемы),расширениепозволяетсохранятьактуальноесостояние\nкешанадискивосстанавливатьегожепослеперезагрузкисервера.Дляэто-\nгонадодобавитьбиблиотекурасширениявпараметрshared_preload_libraries\nиперезагрузитьсервер:\n=> ALTER SYSTEM SET shared_preload_libraries = 'pg_prewarm';\npostgres$ pg_ctl restart -l /home/postgres/logfile\nПослеперезапуска,еслизначениепараметраpg_prewarm.autoprewarmнеме- on\nнялось,будетавтоматическизапущенфоновыйпроцессautoprewarmleader,\nкоторый раз в pg_prewarm.autoprewarm_interval единиц времени будетсбра- 300s\nсыватьнадиск список страниц,находящихся в кеше (этотпроцесс исполь-\nзуетодинизслотовmax_parallel_processes).\nИзначальнопроцессназывалсяautoprewarmmaster,новверсии13ионпопалпод\nраздачу.\npostgres$ ps -o pid,command \\\n--ppid `head -n 1 /usr/local/pgsql/data/postmaster.pid` | \\\ngrep prewarm\n37682 postgres: autoprewarm leader\nСейчас,послеперезагрузки,таблицаbigвкешеотсутствует:\n=> SELECT count(*)\nFROM pg_buffercache\nWHERE relfilenode = pg_relation_filenode('big'::regclass);\ncount\n−−−−−−−\n0\n(1 row)\n197",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.788449"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 199,
    "chapter": null,
    "section": "9.7 Прогрев кеша",
    "text": "Глава9. Буферныйкеш\nЕслиестьобоснованныепредположения,чтовсесодержимоетаблицыбудет\nактивноиспользоваться,адоступкдискунедопустимоснизитвремяоткли-\nказапросов,таблицуможнозаранеепрочитатьвбуферныйкеш:\n=> SELECT pg_prewarm('big');\npg_prewarm\n−−−−−−−−−−−−\n4097\n(1 row)\n=> SELECT count(*)\nFROM pg_buffercache\nWHERE relfilenode = pg_relation_filenode('big'::regclass);\ncount\n−−−−−−−\n4097\n(1 row)\nСписок страниц сбрасывается в файл PGDATA/autoprewarm.blocks. Можно\nподождать,покапроцессautoprewarmleaderотработаетвпервыйраз,номы\nинициируемзаписьвручную:\n=> SELECT autoprewarm_dump_now();\nautoprewarm_dump_now\n−−−−−−−−−−−−−−−−−−−−−−\n4242\n(1 row)\nЧисло сброшенных страниц больше 4097,поскольку включает все занятые\nбуферы.Файл записывается втекстовом формате и содержитидентифика-\nторы базыданных,табличного пространства и файла,номер слоя и номер\nблока:\npostgres$ head -n 10 /usr/local/pgsql/data/autoprewarm.blocks\n<<4242>>\n0,1664,1262,0,0\n0,1664,1260,0,0\n16391,1663,1259,0,0\n16391,1663,1259,0,1\n16391,1663,1259,0,2\n16391,1663,1259,0,3\n16391,1663,1259,0,4\n16391,1663,1259,0,5\n16391,1663,1259,0,6\n198",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.815777"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 200,
    "chapter": null,
    "section": "9.8 Локальныйкеш",
    "text": "9.8. Локальныйкеш\nТеперьсноваперезапустимсервер.\npostgres$ pg_ctl restart -l /home/postgres/logfile\nТаблицасразужеоказываетсявкеше:\n=> SELECT count(*)\nFROM pg_buffercache\nWHERE relfilenode = pg_relation_filenode('big'::regclass);\ncount\n−−−−−−−\n4097\n(1 row)\nЭто обеспечиваетсятем же самым процессом autoprewarm leader: он чита-\nетфайл,разделяетстраницыпобазамданных,сортируетих(чтобычтение\nсдискабылоповозможностипоследовательным)ипередаетотдельномура-\nбочемупроцессуautoprewarmworkerдляобработки.\n9.8. Локальный кеш\nИсключением из общего правила являются временные таблицы. Посколь-\nку временные данные видны только одному процессу, им нечего делать\nвобщембуферномкеше.Поэтомудлявременныхданныхиспользуетсякеш\nвлокальнойпамятипроцесса,владеющеготаблицей1.\nВцеломлокальныйбуферныйкешустроентакже,какиобщий:\n• дляпоискастранициспользуетсясобственнаяхеш-таблица;\n• страницывытесняютсяпообычномуалгоритму(нобезиспользования\nбуферныхколец);\n• принеобходимостиизбежатьвытеснениястраницызакрепляются.\nОднакоегореализациясерьезноупрощается,посколькуотпадаетнеобходи-\nмостьвблокировкахвоперативнойпамяти(таккакдоступкбуферамимеет с.296\nтолько один процесс) и в защитеданных отсбоя (так какданные влюбом с.201\nслучаесуществуютмаксимумдоконцасеанса).\n1 backend/storage/buffer/localbuf.c.\n199",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.844859"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 201,
    "chapter": null,
    "section": "9.8 Локальныйкеш",
    "text": "Глава9. Буферныйкеш\nПамять под локальный кеш выделяется постепенно, по мере необходи-\nмости, поскольку временные таблицы используются далеко не во всех се-\nансах. Максимальный объем кеша одного сеанса ограничен параметром\n8MB temp_buffers.\nПараметр с созвучным именем temp_file_limit относится не к временным таблицам,\nа к файлам,которые могут создаваться при выполнении запросов для временного\nхраненияпромежуточныхданных.\nВ выводе команды EXPLAIN обращения к локальному буферному кешу от-\nмечаютсясловомlocalвместоshared:\n=> CREATE TEMPORARY TABLE tmp AS SELECT 1;\n=> EXPLAIN (analyze, buffers, costs off, timing off, summary off)\nSELECT * FROM tmp;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on tmp (actual rows=1 loops=1)\nBuffers: local hit=1\nPlanning:\nBuffers: shared hit=12 read=7\n(4 rows)\nv.16 Представление pg_stat_io позволяет получить данные о вводе-выводе,\nсвязанномсовременнымиобъектамивлокальныхкешахпроцессов:\n=> SELECT context, sum(reads) reads, sum(writes) writes,\nsum(hits) hits, sum(evictions) evictions, sum(reuses) reuses\nFROM pg_stat_io\nWHERE object = 'temp relation'\nGROUP BY context;\ncontext | reads | writes | hits | evictions | reuses\n−−−−−−−−−+−−−−−−−+−−−−−−−−+−−−−−−+−−−−−−−−−−−+−−−−−−−−\nnormal | 0 | 0 | 1 | 0 |\n(1 row)\n200",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.876493"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 202,
    "chapter": null,
    "section": "10.1 Журналирование",
    "text": "10\nЖурнал предзаписи\n10.1. Журналирование\nВ случае сбоя,например при выключении электропитания или при отказе\nСУБД или операционной системы, теряется все содержимое оперативной\nпамяти;остаетсятолькоинформация,записаннаянадиск.Чтобысервермог\nстартовать после сбоя, необходимо восстановить согласованность данных.\nЕслиприсбоепострадалсамдиск,тажезадачавозникаетипривосстанов-\nленииизрезервнойкопии.\nОдинизтеоретическивозможныхспособов—всевремяподдерживатьдан-\nныенадискевсогласованномвиде.Фактическиэтоозначаетнеобходимость\nпостоянной записи отдельных страниц на диск (а случайная запись обхо-\nдитсядороже последовательной),причем втаком порядке,что ни в какой\nмоментвременисогласованностьненарушается(аэтотрудно,особеннодля\nсложноорганизованныхиндексов).\nPostgreSQL,какибольшинствоСУБД,используетдругойподход.\nВ процессе работы часть актуальных данных хранится только в оператив-\nной памяти и записывается на диск (или на другой энергонезависимый\nноситель)отложенно.Поэтомуданные надискерассогласованы втечение\nвсего времени работы сервера — разные страницы оказываются записан-\nными по состоянию на разные моменты времени. При этом каждое дей-\nствиевоперативнойпамяти(например,изменениестраницывбуферном\nкеше)журналируется:создаетсяисохраняетсянадискежурнальнаязапись,\n201",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.903362"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 203,
    "chapter": null,
    "section": "10.1 Журналирование",
    "text": "Глава10. Журналпредзаписи\nсодержащаяминимальнуюинформацию,достаточнуюдляповторениято-\nгожедействиявслучаенеобходимости1.\nЖурнальнаязаписьобизменениистраницывобязательномпорядкепопа-\nдает на диск перед тем,кактуда попадет измененная страница.Отсюда и\nназвание:журналпредзаписи(write-aheadlog).Этотребованиедаетвозмож-\nностьвслучаесбояпрочитатьсдискажурналиповторитьтеоперации,кото-\nрыебыливыполненыдосбоя,норезультаткоторыхнеуспелдойтидодиска\nизоперативнойпамятиипропал.\nКак правило, вести журнал эффективнее, чем записывать отдельные стра-\nницы.Журнал представляет собой последовательный поток,с записью ко-\nторогонеплохосправляютсядажеHDD-диски.Ктомужежурнальнаязапись\nможетбытьменьшестраницыпоразмеру.\nЖурналировать нужно все операции, при выполнении которых есть риск\nполучитьнесогласованностьнадиске в случае сбоя.В частности,в журнал\nзаписываютсяследующиедействия:\n• изменениестраницотношенийвбуферномкеше—сбросизмененной\nстраницынадискоткладывается;\n• фиксация и отменатранзакций—изменение статуса происходитв бу-\nферахclogитожепопадаетнадискнесразу;\n• файловые операции (создание и удаление файлов и каталогов,напри-\nмер, при создании таблицы) — такие операции должны происходить\nсинхронносизменениемданных.\nВжурналнезаписываются:\n• операцииснежурналируемыми(UNLOGGED)таблицами;\nv.15 • операции с нежурналируемыми последовательностями (как правило,\nотносящимисякнежурналируемымтаблицам);\n• операции с временнымитаблицами и последовательностями—время\nжизнитакихобъектоввлюбомслучаенепревышаетвременижизнисо-\nздавшегоихсеанса.\n1 postgrespro.ru/docs/postgresql/17/wal-intro.\n202",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.934801"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 204,
    "chapter": null,
    "section": "10.2 Устройство журнала",
    "text": "10.2. Устройствожурнала\nЖурналиспользуетсянетолькодлявосстановленияпослесбоя,ноидлявос-\nстановлениянапроизвольныймоментвремениизрезервнойкопии,атакже\nдлярепликации.\n10.2. Устройство журнала\nЛогическая структура\nЛогически журнал1можно представить себе как последовательность запи-\nсей различнойдлины.Каждая запись содержитданные о некоторой опера-\nции,предваренныестандартнымзаголовком2.Взаголовке,вчислепрочего,\nуказаны:\n• номертранзакции,ккоторойотноситсязапись;\n• менеджерресурсов,ответственныйзаинтерпретациюзаписи3;\n• контрольнаясуммадляобнаруженияповрежденийданных;\n• длиназаписи;\n• ссылканапредыдущуюзаписьжурнала.\nОбычно журнал читается в прямом направлении,но,например,утилита pg_rewind\nпросматриваетеговобратном.\nСами данные имеют разный формат и смысл. Например, они могут пред-\nставлять собой некоторый фрагмент страницы, который надо записать\nповерх ее содержимого с определенным смещением. Менеджер ресурсов\n«понимает», как расшифровать и воспроизвести запись. Есть отдельные\nменеджеры для таблиц, для каждого типа индекса, для статуса транзак-\nций и других сущностей. Полный их список можно получить командой\npg_waldump -r list.\n1 postgrespro.ru/docs/postgresql/17/wal-internals;\nbackend/access/transam/README.\n2 include/access/xlogrecord.h.\n3 include/access/rmgrlist.h.\n203",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.959900"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 205,
    "chapter": null,
    "section": "10.2 Устройство журнала",
    "text": "Глава10. Журналпредзаписи\nВ разделяемой памяти сервера для журнала выделены специальные бу-\n−1 феры. Размер журнального кеша задается параметром wal_buffers. Значе-\nние по умолчанию подразумеваетавтоматическую настройку: выделяется\nс.206 16 Мбайт (размер журнального сегмента) или меньше при совсем неболь-\nшихразмерахбуферногокеша.\nЖурнальный кеш похож по своему устройству на буферный, но работает\nпреимущественноврежимекольцевогобуфера:записидобавляютсяв«го-\nлову»,а сохраняются на диск с «хвоста».Слишком маленький размер жур-\nнальногокешаприведетктому,чтосинхронизациясдискомбудетвыпол-\nнятьсячаще,чемнеобходимо.\nПозицияужесохраненныхзаписей(«хвост»буфера)ипозициявставки(«го-\nлова»буфера)вненагруженнойсистемепочтивсегдабудутсовпадать:\n=> SELECT pg_current_wal_lsn(), pg_current_wal_insert_lsn();\npg_current_wal_lsn | pg_current_wal_insert_lsn\n−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−\n2/7CECDF58 | 2/7CECDF58\n(1 row)\nДоверсииPostgreSQL10названиявсехфункцийсодержалиxlogвместоwal.\nЧтобысослатьсянаопределеннуюзапись,используетсятипданныхpg_lsn\n(logsequencenumber,LSN),представляющий64-битноесмещениевбайтах\nдожурнальнойзаписиотносительноначалажурнала.LSNвыводитсякакдва\n32-битныхчиславшестнадцатеричнойсистемечерезкосуючерту.\nСоздадимтаблицу:\n=> CREATE TABLE wal(id integer);\n=> INSERT INTO wal VALUES (1);\nНачнемтранзакциюизапомнимпозициювставкивжурнал:\n=> BEGIN;\n=> SELECT pg_current_wal_insert_lsn();\npg_current_wal_insert_lsn\n−−−−−−−−−−−−−−−−−−−−−−−−−−−\n2/7CEE6290\n(1 row)\n204",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:49.994217"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 206,
    "chapter": null,
    "section": "10.2 Устройствожурнала",
    "text": "10.2. Устройствожурнала\nТеперьвыполнимкакую-нибудьоперацию,напримеробновимстроку:\n=> UPDATE wal SET id = id + 1;\nИзменение выполняется в странице, находящейся в оперативной памяти\nвбуферномкеше.Информацияобизменениисохраняетсяивжурнальную\nстраницу,такжевоперативнойпамяти.Поэтомупозициявставкиувеличи-\nвается:\n=> SELECT pg_current_wal_insert_lsn();\npg_current_wal_insert_lsn\n−−−−−−−−−−−−−−−−−−−−−−−−−−−\n2/7CEE62D8\n(1 row)\nЧтобыгарантировать,чтоизмененнаястраницаданныхбудетвытесненана\nдиск строго позже,чем журнальная запись,в заголовке страницы сохраня-\nетсяномерLSNпоследнейзаписи,относящейсякэтойстранице.Позицию\nможнопроверитьспомощьюрасширенияpageinspect:\n=> SELECT lsn FROM page_header(get_raw_page('wal',0));\nlsn\n−−−−−−−−−−−−\n2/7CEE62D8\n(1 row)\nДля всего кластера базданных используется один общий журнал,и в него\nвсе время попадают новые записи. Поэтому номер LSN на странице мо-\nжетоказатьсяменьше,чемзначение,котороевернулачутьраньшефункция\npg_current_wal_insert_lsn.Новсистеме,гденичегонепроисходит,циф-\nрысовпадут.\nТеперьзавершимтранзакцию:\n=> COMMIT;\nЗаписьофиксациитакжепопадаетвжурнал,ипозициясноваменяется:\n=> SELECT pg_current_wal_insert_lsn();\npg_current_wal_insert_lsn\n−−−−−−−−−−−−−−−−−−−−−−−−−−−\n2/7CEE6300\n(1 row)\n205",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:50.026559"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 207,
    "chapter": null,
    "section": "10.2 Устройствожурнала",
    "text": "Глава10. Журналпредзаписи\nс.85 Фиксация меняет статус транзакции в страницах clog, располагающихся\nс.299 вSLRU-кеше.Чтобыстраницуclogнельзябыловытеснитьнадискраньше,\nчем соответствующую журнальную запись,для страниц clogтоже отслежи-\nвается номер LSN последней журнальной записи.Но эта информация хра-\nнитсяневсамойстранице,авоперативнойпамяти.\nс.225 Вкакой-томоментсозданныежурнальныезаписиокажутсянадиске.После\nэтого страницыданных и clog могутбытьвытеснены из кеша.Если бы по-\nтребовалосьвытеснитьихраньше,этобылобыобнаружено,ижурнальные\nзаписибылибыпринудительносброшенынадискпервыми1.\nЗнаядвепозицииLSN,можнополучитьразмержурнальныхзаписеймежду\nними(вбайтах)простымвычитаниемоднойпозициииздругой.Надотоль-\nкопривестипозицииктипуpg_lsn:\n=> SELECT '2/7CEE6300'::pg_lsn - '2/7CEE6290'::pg_lsn;\n?column?\n−−−−−−−−−−\n112\n(1 row)\nВ данном случае обновление строки и фиксация потребовали около сотни\nбайтоввжурнале.\nТаким же способом можно оценить, какой объем журнальных записей ге-\nнерируетсясерверомзаединицувремениприопределеннойнагрузке.Эта\nинформацияпотребуетсяпринастройкеконтрольнойточки.\nФизическая структура\nНадискежурналхранитсявкаталогеPGDATA/pg_walввидефайлов-сегмен-\n16MB тов. Параметр wal_segment_size, доступный только для чтения, показывает\nразмерсегмента.\n1 backend/storage/buffer/bufmgr.c,функцияFlushBuffer.\n206",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:50.053383"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 208,
    "chapter": null,
    "section": "10.2 Устройствожурнала",
    "text": "10.2. Устройствожурнала\nДлянагруженныхсистемувеличениеразмерасегментовможетснизитьна- v.11\nкладныерасходы,ноэтанастройкавыполняетсятолькоприинициализации\nкластера(initdb--wal-segsize).\nЖурнальные записи попадают в текущий файл; когда он заканчивается —\nначинаетиспользоватьсяследующий.\nМожноузнать,вкакомфайлемынайдемнужнуюпозицию,искакимсме-\nщениемотначалафайла:\n=> SELECT file_name, upper(to_hex(file_offset)) file_offset\nFROM pg_walfile_name_offset('2/7CEE6290');\nfile_name | file_offset\n−−−−−−−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−\n00000001000000020000007C | EE6290\n(1 row)\nветвь logsequencenumber\nвремени\nИмяфайласостоитиздвухчастей.Старшиевосемьшестнадцатеричныхраз-\nрядов показываютномер ветви времени, которая используется при восста-\nновлении из резервной копии,а остаток соответствуетстаршим разрядам\nLSN(младшиеразрядыLSNпоказываетполеfile_offset).\nЖурнальныефайлыможнопосмотретьспециальнойфункцией:\n=> SELECT *\nFROM pg_ls_waldir()\nWHERE name = '00000001000000020000007C';\nname | size | modification\n−−−−−−−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−\n00000001000000020000007C | 16777216 | 2025−01−12 14:45:30+03\n(1 row)\nЗаглянуть в заголовки созданных журнальных записей можно либо утили-\nтойpg_waldump,либоспомощьюрасширенияpg_walinspect: v.15\n=> CREATE EXTENSION pg_walinspect;\n207",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 2,
        "content": "| (1 row)"
      }
    ],
    "extracted_at": "2025-10-02T15:59:50.087268"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 209,
    "chapter": null,
    "section": "10.2 Устройствожурнала",
    "text": "Глава10. Журналпредзаписи\n=> SELECT start_lsn, resource_manager, xid, record_type,\nleft(description,44) description, block_ref\nFROM pg_get_wal_records_info('2/7CEE6290', '2/7CEE6300') \\gx\n−[ RECORD 1 ]−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nstart_lsn | 2/7CEE6290\nresource_manager | Heap\nxid | 900\nrecord_type | HOT_UPDATE\ndescription | old_xmax: 900, old_off: 1, old_infobits: [],\nblock_ref | blkref #0: rel 1663/16391/16572 fork main blk 0\n−[ RECORD 2 ]−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nstart_lsn | 2/7CEE62D8\nresource_manager | Transaction\nxid | 900\nrecord_type | COMMIT\ndescription | 2025−01−12 14:45:30.734485+03\nblock_ref |\nЗдесьмывидимзаголовкидвухзаписей.\nс.115 Первая — операция HOT_UPDATE, относящаяся к менеджеру ресурсов Heap.\nВ столбце block_ref указаны имя файла и номер обновленнойтабличной\nстраницы:\n=> SELECT pg_relation_filepath('wal');\npg_relation_filepath\n−−−−−−−−−−−−−−−−−−−−−−\nbase/16391/16572\n(1 row)\nВтораязапись—COMMIT,относящаясякменеджеруресурсовTransaction.\n10.3. Контрольная точка\nДля восстановления согласованности после сбоя необходимо последова-\nтельно читать журнал и применять к страницам те записи, которые отно-\nсятсякпропавшимизменениям.Чтобыихобнаружить,надосравнитьLSN\nстраницы на диске с LSN журнальной записи. Однако остается непонят-\nным,скакойименнозаписиследуетначинатьвосстановление.Еслиначать\n208",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:50.119401"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 210,
    "chapter": null,
    "section": "10.3 Контрольнаяточка",
    "text": "10.3. Контрольнаяточка\nслишком поздно, то к страницам, записанным на диск раньше этого мо-\nмента,будутпримененыневсеизменения,аэтоприведеткнеобратимому\nповреждению данных. Начать же с самого начала нереально: невозможно\nхранитьтакой потенциально огромный объемданных,и невозможно сми-\nриться со столь же огромным временем восстановления. Нужна такая по-\nстепеннопродвигающаясявпередконтрольнаяточка,скоторойможнобез-\nопасноначинатьвосстановление;предшествующиеейжурнальныезаписи,\nсоответственно,можноудалять.\nСамыйпростойвариантполучитьконтрольнуюточку—периодическипри-\nостанавливатьработусистемыисбрасыватьнадисквсегрязныестраницы\nбуферного и других кешей. Такой способ, конечно, никуда не годится, по-\nсколькувэтимоментысистемабудетзамиратьнанеопределенное,новесь-\nмасущественноевремя.\nПоэтомунапрактикеконтрольнаяточкарастягиваетсявовремениифакти-\nческипревращаетсявотрезок.Выполнениемконтрольнойточкизанимает-\nсяспециальныйфоновыйпроцессcheckpointer1.\nНачалоконтрольнойточки. Сначалапроцессконтрольнойточкисбрасывает\nнадиск структуры,которые можно записатьодномоментно благодаря\nих небольшому объему.К ним относятся статусы транзакций clog,ин-\nформацияовложенныхтранзакцияхинекоторыедругиеобъекты.\nВыполнениеконтрольнойточки. Основное время выполнения контрольной\nточкизанимаетзаписьгрязныхстраницбуферногокеша2.\nСначала в заголовках всех грязных на текущий момент (момент нача-\nла контрольнойточки) буферов проставляется специальный флаг.Это\nпроисходитбыстро,посколькунесвязаносовводом-выводом.\nЗатем процесс контрольнойточки постепенно проходитпо всем буфе-\nрам и сбрасывает помеченные на диск. Страницы при этом не вытес-\nняются из кеша, а только записываются, поэтому не нужно обращать\nвниманияниначислообращенийкбуферу,нинаегозакрепление.\n1 backend/postmaster/checkpointer.c;\nbackend/access/transam/xlog.c,функцияCreateCheckPoint.\n2 backend/storage/buffer/bufmgr.c,функцияBufferSync.\n209",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:50.155845"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 211,
    "chapter": null,
    "section": "10.3 Контрольнаяточка",
    "text": "Глава10. Журналпредзаписи\nСтраницысбрасываютсяпопорядкуномеров,чтобызаписьнадискбы-\nлаповозможностипоследовательной,анеслучайной.Приэтомзапись\nс.26 вразныетабличныепространства(которыемогутсоответствоватьраз-\nнымфизическимустройствам)чередуетсядляравномерногораспреде-\nлениянагрузки.\nПомеченные буферы могут также быть записаны и обслуживающими\nпроцессами — смотря кто доберется до буфера первым. В любом слу-\nчаепризаписиснимаетсяустановленныйранеефлаг,такчто(дляцелей\nконтрольнойточки)буфербудетзаписантолькоодинраз.\nЕстественно,входевыполненияконтрольнойточкистраницыпродол-\nжаютизменятьсявбуферномкеше.Ноновыегрязныебуферынепоме-\nченыфлагом,ипроцессконтрольнойточкинебудетихзаписывать.\nЗавершениеконтрольнойточки. Когда все буферы, которые были грязными\nнамоментначалаконтрольнойточки,оказываютсязаписанными,конт-\nрольная точка считается завершенной. Теперь (но не раньше) момент\nначалаиспользуетсявкачестветойточки,скоторойнадоначинатьвос-\nстановление.Журнальные записи вплотьдо этого момента больше не\nнужны.\nначало\nвосстановления\nнеобходимыефайлыжурнала\nсбой время\nконтрольнаяточка\nначало\nвосстановления\nнеобходимыефайлыжурнала\nсбой время\nконтрольнаяточка контрольнаяточка\n210",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:50.186793"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 212,
    "chapter": null,
    "section": "10.3 Контрольнаяточка",
    "text": "10.3. Контрольнаяточка\nВконцесвоейработыпроцесссоздаетжурнальнуюзаписьобокончании\nконтрольнойточки,указываяLSNмоментаееначала.\nКрометого,вфайлеPGDATA/global/pg_controlобновляетсяуказаниена\nпоследнююпройденнуюконтрольнуюточку.(Дозавершенияпроцесса\npg_controlуказываетнапредыдущую.)\nЧтобыокончательноразобраться,чтоначтоуказывает,рассмотримнеболь-\nшойпример.\nСделаемнесколькостраницвбуферномкешегрязными:\n=> UPDATE big SET s = 'FOO';\n=> SELECT count(*) FROM pg_buffercache WHERE isdirty;\ncount\n−−−−−−−\n4131\n(1 row)\nЗапомнимтекущуюпозициювжурнале:\n=> SELECT pg_current_wal_insert_lsn();\npg_current_wal_insert_lsn\n−−−−−−−−−−−−−−−−−−−−−−−−−−−\n2/7D7796D8\n(1 row)\nТеперьвыполнимконтрольнуюточкувручную.Всегрязныестраницыбудут\nсброшенынадиск;посколькувсистеменичегонепроисходит,новыхгряз-\nныхстраницнепоявится:\n=> CHECKPOINT;\n=> SELECT count(*) FROM pg_buffercache WHERE isdirty;\ncount\n−−−−−−−\n0\n(1 row)\nПосмотрим, как контрольная точка отразилась в журнале. Запись CHECK- v.17\nPOINT_REDO отмечает начало контрольной точки, а CHECKPOINT_ONLINE —\nеезавершение:\n211",
    "tables": [
      {
        "table_index": 0,
        "rows": 2,
        "cols": 1,
        "content": "=> UPDATE big SET s = 'FOO';\n=> SELECT count(*) FROM pg_buffercache WHERE isdirty;\ncount\n−−−−−−−\n4131\n(1 row)"
      },
      {
        "table_index": 1,
        "rows": 2,
        "cols": 1,
        "content": "=> CHECKPOINT;\n=> SELECT count(*) FROM pg_buffercache WHERE isdirty;\ncount\n−−−−−−−\n0\n(1 row)"
      }
    ],
    "extracted_at": "2025-10-02T15:59:50.495230"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 213,
    "chapter": null,
    "section": "10.3 Контрольнаяточка",
    "text": "Глава10. Журналпредзаписи\n=> SELECT start_lsn,\nresource_manager,\nrecord_type,\nleft(description,46)||'...' description\nFROM pg_get_wal_records_info('2/7D7796D8','FFFFFFFF/FFFFFFFF')\n-- pg_get_wal_records_info_till_end_of_wal до v.16\nWHERE record_type LIKE 'CHECKPOINT%'\n\\gx\n−[ RECORD 1 ]−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nstart_lsn | 2/7D7796D8\nresource_manager | XLOG\nrecord_type | CHECKPOINT_REDO\ndescription | wal_level replica...\n−[ RECORD 2 ]−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nstart_lsn | 2/7D779730\nresource_manager | XLOG\nrecord_type | CHECKPOINT_ONLINE\ndescription | redo 2/7D7796D8; tli 1; prev tli 1; fpw true; ...\nМеждудвумяэтимипозициямивжурналебудутрасполагатьсядругиезапи-\nси,порожденныепродолжающимсвоюработусервером.\nТужеинформациюнайдемивуправляющемфайле:\npostgres$ /usr/local/pgsql/bin/pg_controldata \\\n-D /usr/local/pgsql/data | egrep 'Latest.*location'\nLatest checkpoint location: 2/7D779730\nLatest checkpoint's REDO location: 2/7D7796D8\nPGDATA/global/pg_control\nLatestcheckpointlocation: 2/7D779730\nLatestcheckpoint'sREDOlocation: 2/7D7796D8\nначало завершение\nконтрольной контрольной\nточки точки\nREDO ONLINE\n212",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 3,
        "content": "REDO |  | ONLINE"
      }
    ],
    "extracted_at": "2025-10-02T15:59:50.528441"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 214,
    "chapter": null,
    "section": "10.4 Восстановление",
    "text": "10.4. Восстановление\n10.4. Восстановление\nПри старте сервера первым делом запускается процесс postmaster.В свою\nочередь он запускает процесс startup1, задача которого — обеспечить вос-\nстановление,еслипроизошелсбой.\nЧтобы определить,требуется ли восстановление, startup читает управляю-\nщий файл pg_control и проверяет статус кластера. Утилита pg_controldata\nпозволяетзаглянутьвсодержимоефайла:\npostgres$ /usr/local/pgsql/bin/pg_controldata \\\n-D /usr/local/pgsql/data | grep state\nDatabase cluster state: in production\nСтатусаккуратноостановленногосервера—«shutdown».Статус«inproduc-\ntion» у неработающего сервера свидетельствует о сбое.В этом случае про-\nцессstartupавтоматическивыполняетвосстановлениеспозицииначалапо-\nследнейпройденнойконтрольнойточкиизтогожефайлаpg_control.\nЕсливкаталогеPGDATAприсутствуетфайлbackup_labelизрезервнойкопии,позиция\nначалавосстановлениячитаетсяизнего.\nПроцесс последовательно читает журнал, начиная с найденной позиции,\nи применяетжурнальные записи к страницамданных,если LSN страницы\nменьшеLSNзаписи.ЕслижеLSNстраницыоказалсябольше,тозаписьпри-\nменятьненужно,аточнееговоря—нельзя,посколькузаписирассчитанына\nстрогопоследовательноеприменение.\nОднако некоторые записи формируются как полный образ страницы (full\npageimage,FPI).Полныйобразможноприменитьклюбомусостояниюстра-\nницы, поскольку оно все равно будет стерто. Такие изменения называют\nидемпотентными.Другойпримеридемпотентногодействия—записьобиз-\nменениистатусатранзакции:каждойтранзакциисоответствуютотдельные\nфиксированные биты в clog,установка которых не зависитотих предыду-\nщего значения. Поэтому внутри страниц clog нет необходимости хранить\nLSNпоследнегоизменения.\n1 backend/postmaster/startup.c;\nbackend/access/transam/xlog.c,функцияStartupXLOG.\n213",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:50.563400"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 215,
    "chapter": null,
    "section": "10.4 Восстановление",
    "text": "Глава10. Журналпредзаписи\nЖурнальные записи применяются к страницам в буферном кеше, как это\nпроисходитиприобычнойработе.\nАналогичножурнальныезаписиприменяютсяикфайлам:например,если\nзаписьговоритотом,чтофайлдолженсуществовать,аегонет,—файлсо-\nздается.\nПослеокончаниявосстановлениявсенежурналируемыеотношенияпереза-\nс.30 писываютсяспомощьюобразоввinit-файлах.\nВзаключениевыполняетсяконтрольнаяточка,чтобызафиксироватьнадис-\nкевосстановленноесостояние.\nНаэтомработапроцессаstartupзаканчивается.\nВклассическомвидепроцессвосстановлениясостоитиздвухэтапов.Напервом(roll\nforward) накатываются журнальные записи,при этом сервер повторяетпотерянную\nпри сбое работу.На втором (roll back) откатываются транзакции,которые не были\nзафиксированынамоментсбоя.\nPostgreSQLненуждаетсявовторомэтапе.Послевосстановлениявclogнебудетуста-\nновленнибитфиксации,нибитобрыва(чтоформальносоответствуетвыполняющей-\nсятранзакции),нопосколькуточноизвестно,чтотранзакцияуженевыполняется,она\nбудетсчитатьсяоборванной1.\nМожно сымитировать сбой, принудительно остановив сервер в режиме\nimmediate:\npostgres$ pg_ctl stop -m immediate\nПроверимсостояниекластера:\npostgres$ /usr/local/pgsql/bin/pg_controldata \\\n-D /usr/local/pgsql/data | grep 'state'\nDatabase cluster state: in production\nПризапускесерверапроцессstartupпонимает,чтопроизошелсбой,изапус-\nкаетвосстановление:\n1 backend/access/heap/heapam_visibility.c,функцияHeapTupleSatisfiesMVCC.\n214",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:50.594885"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 216,
    "chapter": null,
    "section": "10.4 Восстановление",
    "text": "10.4. Восстановление\npostgres$ pg_ctl start -l /home/postgres/logfile\npostgres$ tail -n 8 /home/postgres/logfile\nLOG: database system was interrupted; last known up at 2025−01−12\n14:45:32 MSK\nLOG: database system was not properly shut down; automatic recovery\nin progress\nLOG: redo starts at 2/7D7796D8\nLOG: invalid record length at 2/7D7797A8: expected at least 24, got\n0\nLOG: redo done at 2/7D779730 system usage: CPU: user: 0.00 s,\nsystem: 0.00 s, elapsed: 0.00 s\nLOG: checkpoint starting: end−of−recovery immediate wait\nLOG: checkpoint complete: wrote 3 buffers (0.0%); 0 WAL file(s)\nadded, 0 removed, 0 recycled; write=0.005 s, sync=0.004 s,\ntotal=0.027 s; sync files=2, longest=0.002 s, average=0.002 s;\ndistance=0 kB, estimate=0 kB; lsn=2/7D7797A8, redo lsn=2/7D7797A8\nLOG: database system is ready to accept connections\nПринормальномостановесерверапроцессpostmasterотключаетвсехкли-\nентов и затем выполняет финальную контрольную точку, чтобы сбросить\nгрязныестраницынадиск.\nЗапомнимтекущуюпозициювжурнале:\n=> SELECT pg_current_wal_insert_lsn();\npg_current_wal_insert_lsn\n−−−−−−−−−−−−−−−−−−−−−−−−−−−\n2/7D779820\n(1 row)\nТеперьаккуратноостановимсервер:\npostgres$ pg_ctl stop\nПроверимсостояниекластера:\npostgres$ /usr/local/pgsql/bin/pg_controldata \\\n-D /usr/local/pgsql/data | grep state\nDatabase cluster state: shut down\nПосмотрев журнал, обнаружим в конце запись о финальной контрольной\nточке(CHECKPOINT_SHUTDOWN):\n215",
    "tables": [
      {
        "table_index": 0,
        "rows": 2,
        "cols": 1,
        "content": "checkpoint starting\ncheckpoint complete"
      }
    ],
    "extracted_at": "2025-10-02T15:59:50.633472"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 217,
    "chapter": null,
    "section": "10.4 Восстановление",
    "text": "Глава10. Журналпредзаписи\npostgres$ /usr/local/pgsql/bin/pg_waldump \\\n-p /usr/local/pgsql/data/pg_wal -s 2/7D779820\nrmgr: XLOG len (rec/tot): 114/ 114, tx: 0, lsn:\n2/7D779820, prev 2/7D7797A8, desc: CHECKPOINT_SHUTDOWN redo\n2/7D779820; tli 1; prev tli 1; fpw true; wal_level replica; xid\n0:903; oid 24764; multi 1; offset 0; oldest xid 730 in DB 1; oldest\nmulti 1 in DB 1; oldest/newest commit timestamp xid: 0/0; oldest\nrunning xid 0; shutdown\npg_waldump: error: error in WAL record at 2/7D779820: invalid record\nlength at 2/7D779898: expected at least 24, got 0\nПоследнее сообщение отpg_waldump говоритотом,что утилита дочитала\nжурналдоконца.\nСновазапустимэкземпляр:\npostgres$ pg_ctl start -l /home/postgres/logfile\n10.5. Фоновая запись\nЕслиобслуживающемупроцессупотребуетсявытеснитьизбуферагрязную\nстраницу,емупридетсясамостоятельнозаписатьеенадиск.Этонехорошая\nситуация,приводящаякожиданиям,—гораздолучше,когдазаписьпроис-\nходитасинхронно,вфоновомрежиме.\nЧастичноработупосбросугрязныхстраницберетнасебяпроцессконтроль-\nнойточки,ноэтогонедостаточно.\nПоэтому существуеттакже процесс фоновой записи bgwriter1,который при-\nменяет тот же алгоритм поиска буферов, что и механизм вытеснения, но\nсдвумяотличиями:\n• используетсясобственная«часоваястрелка»,котораяможетопережать\n«часовуюстрелку»вытеснения,ноникогданеотстаетотнее;\n• приобходебуферовсчетчикобращенийнеуменьшается.\n1 backend/postmaster/bgwriter.c.\n216",
    "tables": [
      {
        "table_index": 0,
        "rows": 2,
        "cols": 1,
        "content": "postgres$ /usr/local/pgsql/bin/pg_waldump \\\n-p /usr/local/pgsql/data/pg_wal -s 2/7D779820\nrmgr: XLOG len (rec/tot): 114/ 114, tx: 0, lsn:\n2/7D779820, prev 2/7D7797A8, desc: CHECKPOINT_SHUTDOWN redo\n2/7D779820; tli 1; prev tli 1; fpw true; wal_level replica; xid\n0:903; oid 24764; multi 1; offset 0; oldest xid 730 in DB 1; oldest\nmulti 1 in DB 1; oldest/newest commit timestamp xid: 0/0; oldest\nrunning xid 0; shutdown\npg_waldump: error: error in WAL record at 2/7D779820: invalid record\nlength at 2/7D779898: expected at least 24, got 0"
      }
    ],
    "extracted_at": "2025-10-02T15:59:50.667752"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 218,
    "chapter": null,
    "section": "10.6 Настройка",
    "text": "10.6. Настройка\nГрязная страница сбрасывается на диск,если буфер не закреплен и имеет\nнулевое число обращений. Таким образом, фоновый процесс записи идет\nвпереди вытеснения и заранее сбрасывает те буферы, которые с большой\nвероятностьювскоребудутвытеснены.\nЭтоувеличиваетшансынато,чтобуферы,выбранныепривытеснении,не\nбудутгрязными.\n10.6. Настройка\nНастройка контрольной точки\nПродолжительность контрольной точки (точнее говоря, продолжитель-\nность этапа записи грязных буферов) определяется значением параметра\ncheckpoint_completion_target.Онопоказывает,какуючастьвременимеждуна- 0.9\nчаламидвухсоседнихконтрольныхточекбудетпроисходитьзапись.Увели- v.14\nчиватьзначениедоединицынерекомендуется,посколькуможетполучить-\nсятак,чтоследующаяконтрольнаяточкадолжнабудетначатьсядотого,как\nполностью завершилась предыдущая. Катастрофы не случится, поскольку\nвлюбомслучаеводинмоментвременивыполняетсятолькооднаконтроль-\nнаяточка,нонормальныйритмработыможетбытьнарушен.\nК настройке остальных параметров можно подойти следующим образом.\nСначала определимся, какой объем журнальных файлов допустимо сохра-\nнятьмеждудвумяпоследовательнымиконтрольнымиточками.Чембольше\nобъем,тем меньше накладных расходов, но в любом случае это значение\nбудетограниченодоступным свободным местом идопустимым временем\nвосстановления.\nМожнопосчитать,закакоевремяприобычнойнагрузкебудетгенерировать-\nсяэтотобъем.Дляэтогонадозапомнитьначальнуюпозициювставкивжур-\nнал и периодически проверятьразностьтекущей и запомненной позиций.\nПолученное время будем считать обычным интервалом между контроль-\nными точками и запишем его в параметр checkpoint_timeout. Значение 5min\nпоумолчанию,скореевсего,слишкоммало;обычновремяувеличивают,на- с.235\nпример,дополучаса.\n217",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:50.701599"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 219,
    "chapter": null,
    "section": "10.6 Настройка",
    "text": "Глава10. Журналпредзаписи\nОднако возможно (идаже вероятно),что иногда нагрузка будетвыше,и за\nуказанноевпараметревремябудетсгенерированслишкомбольшойобъем\nжурнальных записей.В этом случае контрольнаяточкадолжна выполнять-\n1GB сячаще.Дляэтогопараметромmax_wal_sizeограничимобъемжурнальных\nфайлов,необходимыхдлявосстановления.Припревышенииэтогопредела1\nсерверинициируетвнеплановуюконтрольнуюточку.\nv.11 Журнальныефайлы,необходимыедлявосстановления,содержатзаписиза\nпрошедшую завершенную контрольнуюточку и затекущую,еще не завер-\nшенную.Поэтомудляоценкиобщегообъеманадоумножитьизвестныйобъ-\nеммеждуконтрольнымиточкамина1+checkpoint_completion_target.\nДоверсии11хранилисьфайлыизапозапрошлуюконтрольнуюточку,поэтомуумно-\nжатьнадобылона2+checkpoint_completion_target.\nПритакойнастройкебóльшаячастьконтрольныхточекпроисходитпорас-\nписаниюразвcheckpoint_timeout единицвремени.Ноприповышеннойна-\nгрузкеконтрольнаяточкавызываетсячаще,подостиженииобъемажурнала\nmax_wal_size.\nПроцессконтрольнойточкипостоянносопоставляетсвойфактическийпро-\nгресссожидаемым2:\nфактическийпрогресс определяется долей уже просмотренных страниц бу-\nферногокеша;\nожидаемыйпрогрессповремени определяетсядолейужепотраченноговре-\nмени,исходяизтого,чтоконтрольнаяточкадолжназавершитьсязаин-\nтервалcheckpoint_timeout×checkpoint_completion_target;\nожидаемыйпрогресспообъему определяется долей уже заполненных жур-\nнальныхфайлов,планируемоеколичествокоторыхвычисляетсяисходя\nиззначенияmax_wal_size×checkpoint_completion_target.\nЕсли запись грязных страниц опережает график, она приостанавливается;\nесли отстаетхотя бы по одному из двух параметров—догоняетбез задер-\n1 backend/access/transam/xlog.c, функции XLogCheckpointNeeded и CalculateCheckpointSeg-\nments.\n2 backend/postmaster/checkpointer.c,функцияIsCheckpointOnSchedule.\n218",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:50.737582"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 220,
    "chapter": null,
    "section": "10.6 Настройка",
    "text": "10.6. Настройка\nжек1.Учетивремени,иобъемапозволяетоднотипноуправлятьскоростью\nвыполнения контрольных точек как по расписанию,так и по требованию.\nПосле прохождения контрольной точки сервер избавляется от ненужных\nдлявосстановления(идругихзадач)журнальныхзаписей2.Приэтомчасть\nфайловудаляется,аостальныепереименовываютсяииспользуютсязаново.\nИх количество зависит от интенсивности генерации журнальных записей,\nно в любом случае в PGDATA/pg_wal поддерживается минимальный объем\nmin_wal_size3. 80MB\nОбычнопереименованиепозволяетсэкономитьнапостоянномсозданиии v.12\nудалениифайлов,нопринеобходимоститакоеповедениеможноотключить\nспомощьюпараметраwal_recycle. on\nРисунокпоказывает,какменяетсяобъемнеобходимыхсерверужурнальных\nфайловвнормальныхусловиях.\nобъемWAL\nвремя\ncheckpoint_timeout объемWAL,генерируемыйзавремя\nмеждуначаламиконтрольныхточек\n1 backend/postmaster/checkpointer.c,функцияCheckpointWriteDelay.\n2 backend/access/transam/xlog.c,функцияRemoveOldXlogFiles.\n3 backend/access/transam/xlog.c,функцияXLOGfileslop.\n219\nezis_law_xam",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 3,
        "content": "|  |"
      }
    ],
    "extracted_at": "2025-10-02T15:59:50.765774"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 221,
    "chapter": null,
    "section": "10.6 Настройка",
    "text": "Глава10. Журналпредзаписи\nВажно понимать,что реальный объем журнальных файлов на сервере мо-\nжет быть больше, а в некоторых случаях может и превысить значение\nmax_wal_size:\n• Параметрmax_wal_sizeзадаеториентир,нонеслужитжесткимограни-\nчением.Еслинагрузкавозрастет,записьможетотстатьотграфика.\n• Сервернеимеетправастиратьжурнальныефайлы,ещенепереданные\nчерезслотырепликациииещенезаписанныевархивпринепрерывном\nархивировании.Еслиэтотфункционалиспользуется,необходимпосто-\nянныймониторинг,потомучтоможнолегкопереполнитьдисковуюпа-\nмятьсервера.\nv.12 • Некотороеколичествофайловможетбытьзарезервированоустановкой\n0MB параметраwal_keep_size.\nНастройка фоновой записи\nПроцессфоновойзаписиимеетсмыслнастраиватьпослеконтрольнойточ-\nки.Совместноэтипроцессыдолжныуспеватьзаписыватьгрязныебуферы\nдотого,каконипотребуютсяобслуживающимпроцессам.\nПроцесс фоновой записи выполняетработу циклами,засыпая в промежут-\n200ms кахнаbgwriter_delayединицвремени.\nКоличество страниц, которые будут записаны за один цикл работы, опре-\nделяетсяпосреднемуколичествубуферов,запрошенныхобслуживающими\nпроцессами с прошлого запуска (используется скользящее среднее, чтобы\nсгладить неравномерность между запусками, но при этом не зависеть от\nдавней истории). Вычисленное количество дополнительно умножается на\n2 коэффициент bgwriter_lru_multiplier. Но в любом случае за один цикл рабо-\n100 тынебудетзаписаноболееbgwriter_lru_maxpagesстраниц.\nЕслипроцесснеобнаружилниодногогрязногобуфера(тоестьвсистемени-\nчегонепроисходит),он«впадаетвспячку»,изкоторойеговыводитпервое\nжеобращениесерверногопроцессазабуфером.Послеэтогопроцесспросы-\nпаетсяипродолжаетработатьобычнымобразом.\n220",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:50.799916"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 222,
    "chapter": null,
    "section": "10.6 Настройка",
    "text": "10.6. Настройка\nМониторинг\nНастройкуконтрольнойточкиифоновойзаписиможноинужнокорректи-\nровать,получаяобратнуюсвязьотмониторинга.\nЕсли контрольные точки, вызванные превышением объема журнальных\nфайлов, выполняются чаще, чем указано в параметре checkpoint_warning, 30s\nвжурналсообщенийвыводитсяпредупреждение.Значениепараметрасто-\nитпривестивсоответствиеспредполагаемойпиковойнагрузкой.\nДетальнаяинформацияоходевыполненияконтрольныхточкахвыводится\nвжурналсообщенийсерверапривключенномпараметреlog_checkpoints. on\nПоменяемчто-нибудьвданныхиинициируемконтрольнуюточку:\n=> UPDATE big SET s = 'BAR';\n=> CHECKPOINT;\nВ журнале сообщений мы увидим,сколько буферов было записано,как из-\nменилсясоставжурнальныхфайловпослеконтрольнойточки,скольковре-\nмени заняла контрольная точка и расстояние (в байтах) между началами\nсоседнихконтрольныхточек:\npostgres$ tail -n 2 /home/postgres/logfile\nLOG: checkpoint starting: immediate force wait\nLOG: checkpoint complete: wrote 4100 buffers (25.0%); 0 WAL file(s)\nadded, 1 removed, 0 recycled; write=0.295 s, sync=0.114 s,\ntotal=0.432 s; sync files=3, longest=0.109 s, average=0.038 s;\ndistance=9213 kB, estimate=9213 kB; lsn=2/7E078E20, redo\nlsn=2/7E078DC8\nНонаиболееполезнаяинформациядляцелейнастройки—статистикарабо-\nты процесса контрольной точки в представлении pg_stat_checkpointer. v.17\nДо версии 17контрольная точка и фоновая запись разделяли одно представление\npg_stat_bgwriter, поскольку раньше обе задачи выполнялись процессом фоно-\nвой записи; затем в версии 9.2 контрольную точкувыделили в отдельный процесс,\nнопредставлениедолгоевремяоставалосьобщим.\n=> SELECT * FROM pg_stat_checkpointer \\gx\n221",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:50.838911"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 223,
    "chapter": null,
    "section": "10.6 Настройка",
    "text": "Глава10. Журналпредзаписи\n−[ RECORD 1 ]−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nnum_timed | 0\nnum_requested | 26\nrestartpoints_timed | 0\nrestartpoints_req | 0\nrestartpoints_done | 0\nwrite_time | 313461\nsync_time | 21508\nbuffers_written | 101888\nstats_reset | 2025−01−12 14:38:15.939618+03\nВчислепрочегопредставлениепоказываетколичествовыполненныхконт-\nрольныхточек:\n• num_timed—порасписанию(подостиженииинтервалавремениcheck-\npoint_timeout);\n• num_requested —по требованию (в том числе по достижении объема\nжурналаmax_wal_size).\nБольшое значение в столбце num_requested (по сравнению с num_timed)\nговоритотом,что в реальности контрольныеточки происходятчаще,чем\nпредполагалось.\nПоля,начинающиесянаrestartpoints,актуальнытолькодляреплики.\nПредставлениеpg_stat_bgwriterпоказываетстатистикуфоновойзаписи:\n=> SELECT * FROM pg_stat_bgwriter \\gx\n−[ RECORD 1 ]−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nbuffers_clean | 85694\nmaxwritten_clean | 816\nbuffers_alloc | 493103\nstats_reset | 2025−01−12 14:38:15.939618+03\nДлянастройкиполезнозначениеmaxwritten_clean—эточислопоказыва-\nет,сколькоразпроцессфоновойзаписипрекращалциклработыиз-запре-\nвышенияbgwriter_lru_maxpages.\nВ хорошо настроенной системе обслуживающие процессы практически не\nвыполняютзапись,аосновнойееобъемприходитсянапроцессыконтроль-\nнойточки(buffers_written)ифоновойзаписи(buffers_clean).\n222",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:50.871872"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 224,
    "chapter": null,
    "section": "10.6 Настройка",
    "text": "10.6. Настройка\nНаиболеедетальнуюинформациюовводе-выводевразбивкепотипампро- v.16\nцессов (в том числе обслуживающих) можно получить из представления\npg_stat_io:\n=> SELECT backend_type,\nsum(reads) reads, sum(writes) writes, sum(fsyncs) fsyncs\nFROM pg_stat_io\nGROUP BY backend_type\nORDER BY backend_type;\nbackend_type | reads | writes | fsyncs\n−−−−−−−−−−−−−−−−−−−−−+−−−−−−−−+−−−−−−−−+−−−−−−−−\nautovacuum launcher | 5 | 0 | 0\nautovacuum worker | 395549 | 292555 | 0\nbackground worker | 4243 | 0 | 0\nbackground writer | | 85694 | 0\ncheckpointer | | 101886 | 602\nclient backend | 631385 | 548682 | 0\nslotsync worker | 0 | 0 | 0\nstandalone backend | 546 | 979 | 0\nstartup | 0 | 0 | 0\nwalsender | 0 | 0 | 0\n(10 rows)\n223",
    "tables": [
      {
        "table_index": 0,
        "rows": 3,
        "cols": 1,
        "content": "background writer\ncheckpointer\nclient backend"
      }
    ],
    "extracted_at": "2025-10-02T15:59:50.890763"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 225,
    "chapter": null,
    "section": "11.1 Производительность",
    "text": "11\nРежимы журнала\n11.1. Производительность\nПриобычнойработесерверапроисходитпостоянная,нопоследовательная\nзапись журнальных файлов. Поскольку случайный доступ практически от-\nсутствует,сэтойзадачейвполнемогутсправлятьсяиHDD-диски.Нотакой\nхарактернагрузкисущественноотличаетсяоттого,какпроисходитдоступ\nк файлам данных.Поэтому может быть выгодно разместить журнал на от-\nдельномфизическомносителе,создаввместокаталогаPGDATA/pg_walсим-\nвольнуюссылкунакаталогпримонтированнойфайловойсистемы.\nЕстьпара ситуаций,при которыхжурнальные файлы необходимо нетолько писать,\nноичитать.Первая—понятныйслучайвосстановленияпослесбоя.Втораявозника-\nетприиспользованиипотоковойрепликации.Процессwalsender1 стараетсячитать\nv.17 записиWALизжурнальногокеша2,ноеслирепликанеуспеваетполучатьжурнальные\nзаписи,поканужныестраницыещенаходятсявпамятиосновногосервера,данные\nбудут прочитаны с диска.Однако и в этом случае доступ будет последовательным,\nанеслучайным.\nЗаписьжурналапроисходитводномиздвухрежимов:\n• синхронном—при фиксации транзакции продолжение работы невоз-\nможно,покавсежурнальныезаписиобэтойтранзакциинеокажутсяна\nдиске;\n• асинхронном—транзакциязавершаетсянемедленно,ажурналзаписы-\nваетсявфоновомрежиме.\n1 backend/replication/walsender.c.\n2 backend/access/transam/xlog.c,функцияWALReadFromBuffers.\n224",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:50.916843"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 226,
    "chapter": null,
    "section": "11.1 Производительность",
    "text": "11.1. Производительность\nРежимустанавливаетсяпараметромsynchronous_commit. on\nСинхронныйрежим. Для надежного сохранения факта фиксации недоста-\nточно просто передать журнальные записи операционной системе —\nнеобходимосинхронизироватьихсдиском.Посколькусинхронизация\nсвязанасреальным(тоестьмедленным)вводом-выводом,выгодновы-\nполнятьеекакможнореже.\nДляэтогообслуживающийпроцесс,завершающийтранзакциюизапи-\nсывающий журнал,можетделать небольшую паузу,определяемую па-\nраметром commit_delay. Но происходит это только в том случае, если 0s\nв системе имеется не менее commit_siblings активных транзакций1: за 5\nвремяожиданиянекоторыеизнихмогутзавершиться,итогдаудастся\nсинхронизироватьвсе журнальные записи за один прием.Это похоже\nнато,каквыпридерживаетедверилифта,чтобыкто-тоуспелзаскочить\nвкабину.\nСо значениями по умолчанию пауза не выдерживается.Изменятьзна-\nчение параметра commit_delay имеет смысл только в системах, выпол-\nняющихбольшоеколичествокороткихOLTP-транзакций.\nПосле возможной паузы процесс, завершающий транзакцию, сбрасы-\nваетнадиск все накопившиеся журнальные записи и синхронизирует\nихсдиском(важно,чтонадискеоказываетсязаписьофиксацииивсе\nпредыдущиезаписи,относящиесякэтойтранзакции;всеостальноеза-\nписываетсяпростопотому,чтонеувеличиваетстоимость).\nСэтогомоментатранзакциясчитаетсянадежнозавершенной2—гаран-\nтируетсядолговечность(DurabilityизнаборатребованийACID).Поэто-\nмусинхронныйрежимиспользуетсяпоумолчанию.\nОбратная сторона состоит в том, что синхронная запись увеличивает\nвремя отклика (команда COMMIT не возвращаетуправлениедо оконча-\nния синхронизации) и уменьшает производительность системы, осо-\nбенноOLTP.\n1 backend/access/transam/xlog.c,функцияXLogFlush.\n2 backend/access/transam/xlog.c,функцияRecordTransactionCommit.\n225",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:50.952605"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 227,
    "chapter": null,
    "section": "11.1 Производительность",
    "text": "Глава11. Режимыжурнала\nАсинхронныйрежим. Асинхроннуюзапись1можнополучить,установивдля\nпараметраsynchronous_commitзначение«off».\nВасинхронномрежимесбросжурнальныхзаписейвыполняетпроцесс\nwalwriter2,чередуяциклыработысожиданием.Продолжительностьпа-\n200ms узустанавливаетсяпараметромwal_writer_delay.\nПроснувшисьпослеочереднойпаузы,процесспроверяет,появилисьли\nвкешеновыеполностьюзаполненныестраницыWAL.Еслипоявились,\nто процесс записываетих надиск,игнорируятекущую страницу.Если\nжеспрошлогоразаниоднастраницажурналанезаполниласьдоконца,\nтопроцессзаписываеттекущуюнедозаполненнуюстраницу,разужвсе\nравнопроснулся3.\nЭтоталгоритмнацеленнато,чтобыповозможностинесбрасыватьодну\nиту же страницу несколько раз,что важно при большом потоке изме-\nнений.\nХотяжурнальныйкешииспользуетсякаккольцевойбуфер,записьоста-\nнавливается, когда достигает последней страницы кеша; следующий\nпослепаузыциклзаписиначнетсяспервойстраницы.Поэтомувсамом\nхудшемслучаеwalwriterдобираетсядожурнальнойзаписистретьейпо-\nпытки: сначала будутсброшены заполненные страницы в конце кеша,\nзатемвначале,и,наконец,делодойдетдонедозаполненнойстраницы,\nсодержащейискомуюзапись.Вбольшинствежеслучаевхватаетодного-\nдвухциклов.\n1MB Синхронизацияданных происходитчерез каждые wal_writer_flush_after\nмегабайтиодинразвконцециклазаписи.\nАсинхроннаязаписьэффективнеесинхронной—фиксацияизменений\nне ждет физической записи на диск. Однако надежность уменьшает-\nся:вслучаесбоязафиксированныеданныемогутпропасть,еслипосле\nфиксации прошло менее 3×wal_writer_delay единиц времени (что при\nнастройкепоумолчаниюсоставляет0,6секунды).\n1 postgrespro.ru/docs/postgresql/17/wal-async-commit.\n2 backend/postmaster/walwriter.c.\n3 backend/access/transam/xlog.c,функцияXLogBackgroundFlush.\n226",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:50.987632"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 228,
    "chapter": null,
    "section": "11.1 Производительность",
    "text": "11.1. Производительность\nВреальностиэтирежимыдополняютдругдруга.Дажеприсинхроннойфик-\nсации журнальные записи долгой транзакции могут записываться асин-\nхронно,чтобыосвободитьбуферыWAL.Аеслиприсбросестраницыизбу-\nферногокешаокажется,чтосоответствующаяжурнальнаязаписьещенена\nдиске, она будет сброшена немедленно даже в асинхронном режиме, по-\nсколькуиначеневозможнопродолжатьработу.\nВ основном же непростой выбор — эффективность или долговечность —\nостаетсязапроектировщикомсистемы.\nПараметр synchronous_commit можно устанавливать в том числе и для от-\nдельных транзакций. Если на уровне приложения получается разделить\nтранзакции на абсолютно критичные (например, работающие с финансо-\nвымиданными)именееважные,томожноувеличитьпроизводительность,\nжертвуянадежностьютолькочаститранзакций.\nЧтобы получить какое-то представление отом,какой выигрыш дает асин-\nхроннаяфиксация,сравнимвремяоткликаипропускнуюспособностьпри\nдвухрежимахнаэталонномтестеpgbench1.\nИнициализируем необходимые таблицы и запускаем 30-секундный тест\nвсинхронномрежиме:\npostgres$ /usr/local/pgsql/bin/pgbench -i internals\npostgres$ /usr/local/pgsql/bin/pgbench -T 30 internals\npgbench (17.2)\nstarting vacuum...end.\ntransaction type: <builtin: TPC−B (sort of)>\nscaling factor: 1\nquery mode: simple\nnumber of clients: 1\nnumber of threads: 1\nmaximum number of tries: 1\nduration: 30 s\nnumber of transactions actually processed: 7505\nnumber of failed transactions: 0 (0.000%)\nlatency average = 3.998 ms\ninitial connection time = 1.998 ms\ntps = 250.132807 (without initial connection time)\n1 postgrespro.ru/docs/postgresql/17/pgbench.\n227",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.021334"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 229,
    "chapter": null,
    "section": "11.1 Производительность",
    "text": "Глава11. Режимыжурнала\nИзатемпроведемтакойжетествасинхронномрежиме:\n=> ALTER SYSTEM SET synchronous_commit = off;\n=> SELECT pg_reload_conf();\npostgres$ /usr/local/pgsql/bin/pgbench -T 30 internals\npgbench (17.2)\nstarting vacuum...end.\ntransaction type: <builtin: TPC−B (sort of)>\nscaling factor: 1\nquery mode: simple\nnumber of clients: 1\nnumber of threads: 1\nmaximum number of tries: 1\nduration: 30 s\nnumber of transactions actually processed: 81500\nnumber of failed transactions: 0 (0.000%)\nlatency average = 0.368 ms\ninitial connection time = 1.899 ms\ntps = 2716.737845 (without initial connection time)\nПри асинхронной фиксации в этом простом тесте время отклика (latency)\nсущественноуменьшилось,апропускнаяспособность(tps)увеличилась.Ра-\nзумеется, в каждой конкретной системе при конкретной нагрузке соотно-\nшениебудетсвоим,новидно,чтоприкороткихOLTP-транзакцияхэффект\nможетбытьвесьмазначительным.\nВосстановимзначенияпараметровпоумолчанию:\n=> ALTER SYSTEM RESET synchronous_commit;\n=> SELECT pg_reload_conf();\n11.2. Надежность\nОчевидно, что механизм журналирования должен гарантировать возмож-\nностьвосстановленияпослесбоявлюбыхситуациях(несвязанных,конеч-\nно, с разрушением носителя данных). На согласованность данных влияет\nмного факторов, из которых наиболее важны кеширование, повреждение\nданныхинеатомарностьзаписи1.\n1 postgrespro.ru/docs/postgresql/17/wal-reliability.\n228",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.054212"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 230,
    "chapter": null,
    "section": "11.2 Надежность",
    "text": "11.2. Надежность\nКеширование\nНа пути данных к энергонезависимому хранилищу (такому как пластина\nжесткогодиска)стоятмногочисленныекеши.\nСистемныйвызовзаписинадискприводитлишьктому,чтооперационная\nсистема переноситданные в свой кеш(также находящийсяв оперативной\nпамятииподверженныйсбоям).Фактическаязаписьпроисходитасинхрон-\nно,взависимостиотнастроекпланировщикаввода-выводаоперационной\nсистемы.\nКогдапланировщикрешаетзаписатьданные,онипопадаютвкешнакопите-\nля(жесткогодиска).Электрониканакопителятожеможетотложитьзапись,\nнапример собирая данные в группы, которые выгоднее записать одновре-\nменно.RAID-контроллердобавляетещеодинуровенькешированиямежду\nоперационнойсистемойидиском.\nЕсли не предпринимать специальных мер, момент надежного сохранения\nданныхостаетсянеизвестным.Обычноэтоиневажно,посколькуестьжур-\nнал,но сами журнальные записи обязаны немедленно сохраняться надеж-\nным образом1. Это верно и для асинхронного режима, поскольку иначе\nнельзягарантировать,чтожурнальныезаписипопадутнадискраньшеиз-\nмененныхданных.\nКонтрольнаяточкатакжедолжнасохранятьданныенадежно,чтобыгрязные\nстраницыдействительнобылисброшенынадиск,анеосталисьвкешеопе-\nрационнойсистемы.Крометого,контрольнаяточкасинхронизируетсдис-\nкомивсефайловыеоперации,выполненныеранеедругимипроцессами(та-\nкиекакзаписьстраницыилиудалениефайла):кзавершениюконтрольной\nточкирезультатывсехэтихдействийтожедолжныгарантированнооказать-\nсянадиске2.\nЕстьинекоторыедругиеситуации,требующиенадежнойзаписи,например\nвыполнениенежурналируемыхоперацийнауровнежурналаminimal.\nОперационные системы предоставляютразные средства,которые должны\nгарантировать немедленную запись данных в энергонезависимую память.\n1 backend/access/transam/xlog.c,функцияissue_xlog_fsync.\n2 backend/storage/sync/sync.c.\n229",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.087161"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 231,
    "chapter": null,
    "section": "11.2 Надежность",
    "text": "Глава11. Режимыжурнала\nОнисводятсякдвумосновным:либопослезаписивыполняетсяотдельная\nкомандасинхронизации(fsync,fdatasync),либонеобходимостьсинхрониза-\nции(илидажепрямойзаписи,минуякешоперационнойсистемы)указыва-\nетсяприоткрытиифайлаилизаписивнего.\nУтилита pg_test_fsync помогает определить наиболее подходящий способ\nсинхронизации журнала для конкретной операционной системы и конк-\nретной файловой системы; выбранный способ указывается в параметре\nwal_sync_method.Длядругихситуацийспособопределяетсяавтоматически1.\nТонкиймоментсостоитвтом,чтопривыбореметоданадоучитыватьхарак-\nтеристикиаппаратуры.Например,еслииспользуетсяконтроллерсбатареей\nрезервногопитания,нетрезонанеиспользоватьегокеш,посколькубатарея\nпозволитсохранитьданныевслучаесбояэлектропитания.\nАсинхронный режим фиксации и отсутствие синхронизации—принципи-\non ально разные режимы. Отключение синхронизации (параметр fsync) еще\nбольше ускоряет работу системы,но при любом сбое все данные кластера\nбудут безвозвратно потеряны.Асинхронный режим дает гарантию восста-\nновлениясогласованногосостоянияданныхпослесбоя,но,возможно,часть\nпоследнихтранзакцийбудетвэтомсостоянииотсутствовать.\nПовреждение данных\nОборудованиенесовершенно,иданныемогутповредитьсявпамятиилина\nносителе,изменитьсяприпередачепоинтерфейснымкабелям.Частьтаких\nошибокобрабатываетсянааппаратномуровне,ночасть—нет.\nЧтобывовремяобнаружитьвозникшуюпроблему,журнальныезаписивсег-\nдаснабжаютсяконтрольнымисуммами.\nСтраницы данных также можно защитить контрольными суммами2. Это\nv.12 можносделатьлибоприинициализациикластера,либоспомощьюутилиты\npg_checksums3приостановленномсервере4.\n1 backend/storage/file/fd.c,функцияpg_fsync.\n2 backend/storage/page/README.\n3 postgrespro.ru/docs/postgresql/17/app-pgchecksums.\n4 commitfest.postgresql.org/51/5323.\n230",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.121988"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 232,
    "chapter": null,
    "section": "11.2 Надежность",
    "text": "11.2. Надежность\nВ производственной среде контрольные суммы обязательно должны быть\nвключены,несмотряна(незначительные)накладныерасходынаихвычис-\nлениеипроверку.Этоувеличиваетшансыобнаружитьсбойвовремя.Ноне\nдаетполнойгарантии:\n• контрольные суммы проверяются только при обращении к странице,\nпоэтомуповреждениеможетдолгоевремяоставатьсянезамеченными\nпопастьвовсерезервныекопии,такчтонесохранитсяниодногоисточ-\nникавернойинформации;\n• страница, заполненная нулями, считается корректной, поэтому, если\nфайловая система по ошибке «обнулит» файл,проверка не обнаружит\nпроблему;\n• контрольные суммы защищают только основной слой отношений,\nа остальные слои и все прочие файлы (например,статусытранзакций\nclog)ничемнезащищены.\nУбедимся,чтоконтрольныесуммывключены,проверивзначениепарамет-\nраdata_checksums,доступноготолькодлячтения:\n=> SHOW data_checksums;\ndata_checksums\n−−−−−−−−−−−−−−−−\non\n(1 row)\nОстановим сервер и обнулим несколько байтов в нулевой странице основ-\nногослоятаблицы:\n=> SELECT pg_relation_filepath('wal');\npg_relation_filepath\n−−−−−−−−−−−−−−−−−−−−−−\nbase/16391/16572\n(1 row)\npostgres$ pg_ctl stop\npostgres$ dd if=/dev/zero of=/usr/local/pgsql/data/base/16391/16572 \\\noflag=dsync conv=notrunc bs=1 count=8\n8+0 records in\n8+0 records out\n8 bytes copied, 0,0150394 s, 0,5 kB/s\n231",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.151336"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 233,
    "chapter": null,
    "section": "11.2 Надежность",
    "text": "Глава11. Режимыжурнала\nСновазапустимсервер:\npostgres$ pg_ctl start -l /home/postgres/logfile\nВпринципе,серверможнобылобыинеостанавливать.Достаточно,чтобы\nстраница записалась на диск и была вытеснена из кеша (иначе сервер бу-\nдетпродолжатьработатьсзакешированнойстраницей).Нотакойсценарий\nсложнеевоспроизвести.\nТеперьпробуемпрочитатьтаблицу:\n=> SELECT * FROM wal LIMIT 1;\nWARNING: page verification failed, calculated checksum 59576 but\nexpected 64167\nERROR: invalid page in block 0 of relation base/16391/16572\nЕслиданныеневозможновосстановитьизрезервнойкопии,стоитхотябы\nпопытаться прочитатьповрежденную страницу (естественно,с риском по-\nлучить искаженную информацию). Для этого надо установить параметр\noff ignore_checksum_failure:\n=> SET ignore_checksum_failure = on;\n=> SELECT * FROM wal LIMIT 1;\nWARNING: page verification failed, calculated checksum 59576 but\nexpected 64167\nid\n−−−−\n2\n(1 row)\nВданномслучаевсепрошлоуспешно,потомучтомыиспортилинекритич-\nнуючастьзаголовкастраницы(номерLSNпоследнейжурнальнойзаписи),\nанесамиданные.\nНеатомарностьзаписи\nСтраницабазыданныхобычнозанимает8Кбайт,ананизкомуровнезапись\nпроисходитблоками,которыевбольшинствеслучаевимеютменьшийраз-\nмер(какправило,512байтили4Кбайта).Поэтомуприсбоестраницаданных\nможетзаписатьсячастично.Привосстановлениибессмысленноприменять\nктакойповрежденнойстраницеобычныежурнальныезаписи.\n232",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.183756"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 234,
    "chapter": null,
    "section": "11.2 Надежность",
    "text": "11.2. Надежность\nДля защиты отчастичной записи PostgreSQL сохраняетв журнале полный\nобразстраницы(fullpageimage,FPI)припервомееизменениипосленачала с.213\nконтрольнойточки.\nЭтимповедениемуправляетпараметрfull_page_writes.Отказотзаписипол- on\nных образов может привести к неустранимому повреждению данных, но\nполные образы могут появляться в журнале даже при отключенном пара-\nметреиз-забитов-подсказок.Ихизменениясчитаютсянекритичнымиине с.86\nжурналируютсясамипосебе—первыйжезапрос,обратившийсякстрани-\nце,заново установит необходимые биты.Однако изменение любого,даже\nнесущественного бита приводитк изменению контрольной суммы.Поэто-\nму при включенных контрольных суммах (или при установленном пара-\nметреwal_log_hints)первоеизменениебитов-подсказокпослеконтрольной off\nточки вызывает запись полного образа страницы1, невзирая на значение\nfull_page_writes.\nЕслипривосстановлениивжурналевстречаетсяполныйобразстраницы,он\nбезусловно(безпроверкиLSN)записываетсянадиск,поскольку,какився-\nкаяжурнальнаязапись,онзащищенконтрольнойсуммойинеможетбыть\nнезаметно испорчен. И уже к этому гарантированно корректному образу\nприменяютсяобычныежурнальныезаписи.\nНаличие полных образов существенно увеличивает объем генерируемых\nжурнальныхзаписей,несмотрянаточтомеханизмжурналированияисклю-\nчаетизполногообразанезанятоеместовнутристраницы2.Ситуациюможно\nзначительноулучшитьзасчетсжатияполныхобразов,котороевключается\nпараметромwal_compression. off\nПроведем простой эксперимент с помощью утилиты pgbench. Выполним\nконтрольнуюточкуисразужезапустимтестсфиксированнымколичеством\nтранзакций:\n=> CHECKPOINT;\n=> SELECT pg_current_wal_insert_lsn();\n1 backend/storage/buffer/bufmgr.c,функцияMarkBufferDirtyHint.\n2 backend/access/transam/xloginsert.c,функцияXLogRecordAssemble.\n233",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.220211"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 235,
    "chapter": null,
    "section": "11.2 Надежность",
    "text": "Глава11. Режимыжурнала\npg_current_wal_insert_lsn\n−−−−−−−−−−−−−−−−−−−−−−−−−−−\n2/8292A718\n(1 row)\npostgres$ /usr/local/pgsql/bin/pgbench -t 20000 internals\n=> SELECT pg_current_wal_insert_lsn();\npg_current_wal_insert_lsn\n−−−−−−−−−−−−−−−−−−−−−−−−−−−\n2/8439C720\n(1 row)\nРазмержурнальныхзаписей:\n=> SELECT pg_size_pretty('2/8439C720'::pg_lsn - '2/8292A718'::pg_lsn);\npg_size_pretty\n−−−−−−−−−−−−−−−−\n26 MB\n(1 row)\nПолныеобразывнашемслучаесоставляютзначительнуючастьсгенериро-\nванного объема, в чем можно убедиться, посмотрев статистику утилитой\npg_waldumpсключом--stats илифункциейpg_get_wal_stats расшире-\nv.15 нияpg_walinspect.\nТаблица показывает количество журнальных записей (N), объем обычных\nзаписей(Recordsize)иобъемполныхобразов(FPIsize)длякаждоготипа\nресурсов(Type):\npostgres$ /usr/local/pgsql/bin/pg_waldump --stats \\\n-p /usr/local/pgsql/data/pg_wal -s 2/8292A718 -e 2/8439C720\nWAL statistics between 2/8292A718 and 2/8439C720:\nType N (%) Record size (%) FPI size (%)\n−−−− − −−− −−−−−−−−−−− −−− −−−−−−−− −−−\nXLOG 1832 ( 1,42) 89768 ( 1,07) 14727824 ( 77,71)\nTransaction 20005 ( 15,51) 680730 ( 8,10) 0 ( 0,00)\nStorage 1 ( 0,00) 42 ( 0,00) 0 ( 0,00)\nCLOG 1 ( 0,00) 34 ( 0,00) 0 ( 0,00)\nStandby 12 ( 0,01) 852 ( 0,01) 0 ( 0,00)\nHeap2 26885 ( 20,84) 1692836 ( 20,14) 3536904 ( 18,66)\nHeap 80134 ( 62,13) 5935665 ( 70,61) 175164 ( 0,92)\nBtree 111 ( 0,09) 6352 ( 0,08) 512040 ( 2,70)\n−−−−−− −−−−−−−− −−−−−−−−\nTotal 128981 8406279 [30,73%] 18951932 [69,27%]\n234",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.256141"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 236,
    "chapter": null,
    "section": "11.2 Надежность",
    "text": "11.2. Надежность\nСоотношениебудетменьше,еслистраницыуспеютизменитьсямеждуконт-\nрольнымиточкаминесколькораз.Этоещеодинповодневыполнятьконт-\nрольныеточкислишкомчасто.\nТеперьпосмотрим,какпомогаетсжатие,натомжепримере:\n=> ALTER SYSTEM SET wal_compression = on; -- или pglz\n=> SELECT pg_reload_conf();\n=> CHECKPOINT;\n=> SELECT pg_current_wal_insert_lsn();\npg_current_wal_insert_lsn\n−−−−−−−−−−−−−−−−−−−−−−−−−−−\n2/8439C7F0\n(1 row)\npostgres$ /usr/local/pgsql/bin/pgbench -t 20000 internals\n=> SELECT pg_current_wal_insert_lsn();\npg_current_wal_insert_lsn\n−−−−−−−−−−−−−−−−−−−−−−−−−−−\n2/84E33B38\n(1 row)\nРазмержурнальныхзаписейсосжатием:\n=> SELECT pg_size_pretty('2/84E33B38'::pg_lsn - '2/8439C7F0'::pg_lsn);\npg_size_pretty\n−−−−−−−−−−−−−−−−\n11 MB\n(1 row)\npostgres$ /usr/local/pgsql/bin/pg_waldump --stats \\\n-p /usr/local/pgsql/data/pg_wal -s 2/8439C7F0 -e 2/84E33B38\nWAL statistics between 2/8439C7F0 and 2/84E33B38:\nType N (%) Record size (%) FPI size (%)\n−−−− − −−− −−−−−−−−−−− −−− −−−−−−−− −−−\nXLOG 1750 ( 1,43) 89206 ( 1,11) 2651367 ( 94,21)\nTransaction 20005 ( 16,38) 680634 ( 8,50) 0 ( 0,00)\nStorage 1 ( 0,00) 42 ( 0,00) 0 ( 0,00)\nStandby 11 ( 0,01) 762 ( 0,01) 0 ( 0,00)\nHeap2 20280 ( 16,61) 1315523 ( 16,43) 103167 ( 3,67)\nHeap 80039 ( 65,55) 5919260 ( 73,93) 28395 ( 1,01)\nBtree 18 ( 0,01) 1096 ( 0,01) 31314 ( 1,11)\n−−−−−− −−−−−−−− −−−−−−−−\nTotal 122104 8006523 [73,99%] 2814243 [26,01%]\n235",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.293963"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 237,
    "chapter": null,
    "section": "11.2 Надежность",
    "text": "Глава11. Режимыжурнала\nv.15 ПомимотрадиционногоалгоритмасжатияPGLZ,доступныдвадругих:LZ4\nи Zstandard. Алгоритм LZ4 обычно требует меньше ресурсов процессора,\nпоказывая примерно ту же степень сжатия. Алгоритм Zstandard сочетает\nсловарноесжатиесэнтропийнымкодированием;онсильнеенагружаетпро-\nцессор,носжимаетданныелучше.\n=> ALTER SYSTEM SET wal_compression = zstd;\n=> SELECT pg_reload_conf();\n=> CHECKPOINT;\n=> SELECT pg_current_wal_insert_lsn();\npg_current_wal_insert_lsn\n−−−−−−−−−−−−−−−−−−−−−−−−−−−\n2/84E33C08\n(1 row)\npostgres$ /usr/local/pgsql/bin/pgbench -t 20000 internals\n=> SELECT pg_current_wal_insert_lsn();\npg_current_wal_insert_lsn\n−−−−−−−−−−−−−−−−−−−−−−−−−−−\n2/857D7498\n(1 row)\nРазмержурнальныхзаписейсосжатиемZstandard:\n=> SELECT pg_size_pretty('2/857D7498'::pg_lsn - '2/84E33C08'::pg_lsn);\npg_size_pretty\n−−−−−−−−−−−−−−−−\n9870 kB\n(1 row)\nВывод: при наличии большого числа полных образов страниц (из-за конт-\nрольных сумм или full_page_writes, то есть почти всегда) имеет смысл вос-\nпользоватьсясжатием.Несколькоалгоритмовпозволяютнайтикомпромисс\nмеждудополнительнойнагрузкойнапроцессорисокращениемобъемажур-\nнальныхзаписей.\n11.3. Уровни журнала\nОсновная задача журнала предзаписи — обеспечить возможность восста-\nновленияпослесбоя.Ножурналможноиспользоватьидлярешениядругих\n236",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.325278"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 238,
    "chapter": null,
    "section": "11.3 Уровнижурнала",
    "text": "11.3. Уровнижурнала\nзадач, расширив состав входящих в него записей. Есть несколько уров-\nнейжурналирования:minimal,replicaиlogical.Каждыйследующийуровень\nвключаетвсебявсе,чтопопадаетвжурналпредыдущегоуровня,идобавля-\nетнекоторуюновуюинформацию.\nИспользуемый уровень задается параметром wal_level; его изменение тре- replica\nбуетперезапускасервера.\nMinimal\nНачальныйуровеньminimalгарантируеттольковосстановлениепослесбоя.\nДляэкономииместаоперациисотношениями,созданнымиилиопустошен-\nнымивтекущейтранзакции,незаписываютсявжурнал,еслионисвязанысо\nвставкойбольшогообъемаданных(вчастности,этокасаетсятакихкоманд,\nкак CREATE TABLE AS SELECT или CREATE INDEX)1.Вместо журналирования\nнеобходимыеданныесразужесбрасываютсянадиск,аизменениявсистем-\nномкаталогестановятсявидимымипрификсациитранзакции.\nЕслисбойпроизойдетвпроцессевыполненияоперации,тоужезаписанные\nнадискданныеостанутсяневидимымииненарушатсогласованности.Если\nжесбойпроизойдетпослетого,какоперациязавершится,товсенеобходи-\nмыеданныедляпримененияпоследующихжурнальныхзаписейужебудут\nнаходитьсянадиске.\nОбъем данных, который требуется записать в только что созданное отно- v.13\nшение,чтобытакаяоптимизацияначалаработать,определяетсязначением\nпараметраwal_skip_threshold. 2MB\nПосмотрим,чтопопадаетвжурналнауровнеminimal.\nПо умолчанию используется более высокий уровень replica, рассчитанный\nнаподдержкурепликации.Приустановкеминимальногоуровняпотребует-\nсятакжеобнулитьзначениепараметраmax_wal_senders,которыйопределяет 10\nдопустимоеколичествопроцессовwalsender:\n=> ALTER SYSTEM SET wal_level = minimal;\n=> ALTER SYSTEM SET max_wal_senders = 0;\n1 include/utils/rel.h,макросRelationNeedsWAL.\n237",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.361043"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 239,
    "chapter": null,
    "section": "11.3 Уровнижурнала",
    "text": "Глава11. Режимыжурнала\nИзменениепараметровтребуетперезапускасервера:\npostgres$ pg_ctl restart -l /home/postgres/logfile\nЗапомнимтекущуюпозициювжурнале:\n=> SELECT pg_current_wal_insert_lsn();\npg_current_wal_insert_lsn\n−−−−−−−−−−−−−−−−−−−−−−−−−−−\n2/857D9460\n(1 row)\nОпустошимтаблицуивтойжетранзакциивставимновыестроки,превысив\nпределwal_skip_threshold:\n=> BEGIN;\n=> TRUNCATE TABLE wal;\n=> INSERT INTO wal\nSELECT id FROM generate_series(1,100_000) id;\n=> COMMIT;\nЯиспользуюкомандуTRUNCATE,анесоздаюотдельнуютаблицу,посколькуприэтом\nгенерируетсяменьшежурнальныхзаписей.\nv.15 С помощью уже знакомого расширения pg_walinspect посмотрим содер-\nжимоежурнала.\n=> SELECT start_lsn,\nresource_manager AS rmgr,\nrecord_type,\n(regexp_match(block_ref, '[0-9]+\\/[0-9]+\\/[0-9]+'))[1] AS rel\nFROM -- pg_get_wal_records_info_till_end_of_wal до v.16\npg_get_wal_records_info('2/857D9460','FFFFFFFF/FFFFFFFF');\nstart_lsn | rmgr | record_type | rel\n−−−−−−−−−−−−+−−−−−−−−−−−−−+−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−\n2/857D9460 | Storage | CREATE |\n2/857D9490 | Heap | UPDATE | 1663/16391/1259\n2/857D9510 | Btree | INSERT_LEAF | 1663/16391/2662\n2/857D9550 | Btree | INSERT_LEAF | 1663/16391/2663\n2/857D9590 | Btree | INSERT_LEAF | 1663/16391/3455\n2/857D95D0 | Transaction | COMMIT |\n(6 rows)\n238",
    "tables": [
      {
        "table_index": 0,
        "rows": 7,
        "cols": 1,
        "content": "=> BEGIN;\n\n=> TRUNCATE TABLE wal;\n\n=> INSERT INTO wal\nSELECT id FROM generate_series(1,100_000) id;\n\n=> COMMIT;"
      }
    ],
    "extracted_at": "2025-10-02T15:59:51.400543"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 240,
    "chapter": null,
    "section": "11.3 Уровнижурнала",
    "text": "11.3. Уровнижурнала\nПервая запись (CREATE) говорит о создании нового файла для отношения\n(посколькуприопустошениитаблицафактическиперезаписывается). с.172\nДалееследуютнесколькозаписей,относящихсяксистемномукаталогу.Они\nотражают изменение таблицы pg_class (UPDATE) и добавление записей\nктреминдексам,построеннымнаэтойтаблице(INSERT_LEAF).Вэтоммож-\nноубедиться,сопоставивпутькфайлу,показанныйвстолбцеrel,сименем с.30\nотношения.\nНаконец,идетзаписьофиксациитранзакции.Вставкаданныхвтаблицуне\nжурналируется.\nReplica\nКогда система восстанавливается после сбоя,данные,сохраненные надис-\nке,обновляютсядосогласованногосостоянияспомощьюжурнальныхзапи-\nсей.Тожесамоепроисходитипривосстановленииизрезервнойкопии.Но\nвэтомслучаемогутиспользоватьсязаархивированныежурнальныезаписи,\nчтобынепростовосстановитьсогласованность,адовестисостояниеданных\nдо целевой точки восстановления. Количество таких записей может быть\nвесьма велико (например, они могут охватывать несколько дней),то есть\nпериодвосстановлениябудетсодержатьнеоднуконтрольнуюточку,амно-\nжество.Поэтомуминимальногоуровняжурналанедостаточно—нельзяпо-\nвторитьоперацию,еслионанежурналируется.Длявозможностивосстанов-\nленияизрезервнойкопиивжурналдолжныпопадатьвсеоперации.\nТожесамоеверноидлярепликации—все,чтонежурналируется,небудет\nпереданонарепликуинебудетнанейвоспроизведено.\nНо если реплика используется для выполнения запросов, все еще больше\nусложняется.Во-первых,нужнаинформацияобисключительныхблокиров-\nках, возникающих на основном сервере, поскольку они могут конфликто- с.251\nватьсзапросаминареплике.Во-вторых,нужноуметьстроитьснимкидан-\nных,а для этого необходима информация о выполняющихся транзакциях. с.97\nВ случае реплики нужно учитыватьнетольколокальныетранзакции,но и\nтранзакциинаосновномсервере.\n239",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.435627"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 241,
    "chapter": null,
    "section": "11.3 Уровнижурнала",
    "text": "Глава11. Режимыжурнала\nЕдинственныйспособпередатьэтуинформациюреплике—периодически\nзаписыватьеевжурнал1.Этимразв15секунд(интервалненастраивается)\nзанимаетсяпроцессфоновойзаписиbgwriter2.\nВозможностьвосстановитьданныеизрезервнойкопииииспользоватьфи-\nзическуюрепликациюгарантируетсянауровнежурналаreplica.\nИменноэтотуровеньиспользуетсяпоумолчанию,поэтомупростосбросим\nустановленныевышепараметрыиперезагрузимсервер:\n=> ALTER SYSTEM RESET wal_level;\n=> ALTER SYSTEM RESET max_wal_senders;\npostgres$ pg_ctl restart -l /home/postgres/logfile\nПовторимтужепоследовательностьдействий,чтоивпрошлыйраз(ноогра-\nничимсявставкойоднойстроки,чтобынезагромождатьвывод):\n=> SELECT pg_current_wal_insert_lsn();\npg_current_wal_insert_lsn\n−−−−−−−−−−−−−−−−−−−−−−−−−−−\n2/85DFA8B8\n(1 row)\n=> BEGIN;\n=> TRUNCATE TABLE wal;\n=> INSERT INTO wal VALUES (42);\n=> COMMIT;\nТеперьпроверимжурнальныезаписи.\n=> SELECT start_lsn,\nresource_manager AS rmgr,\nrecord_type,\n(regexp_match(block_ref, '[0-9]+\\/[0-9]+\\/[0-9]+'))[1] AS rel\nFROM pg_get_wal_records_info('2/85DFA8B8','FFFFFFFF/FFFFFFFF');\n1 backend/storage/ipc/standby,функцияLogStandbySnapshot.\n2 backend/postmaster/bgwriter.c.\n240",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.467094"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 242,
    "chapter": null,
    "section": "11.3 Уровнижурнала",
    "text": "11.3. Уровнижурнала\nstart_lsn | rmgr | record_type | rel\n−−−−−−−−−−−−+−−−−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−\n2/85DFA8B8 | Standby | LOCK |\n2/85DFA8E8 | Storage | CREATE |\n2/85DFA918 | Heap | UPDATE | 1663/16391/1259\n2/85DFA998 | Btree | INSERT_LEAF | 1663/16391/2662\n2/85DFA9D8 | Btree | INSERT_LEAF | 1663/16391/2663\n2/85DFAA18 | Btree | INSERT_LEAF | 1663/16391/3455\n2/85DFAA58 | Heap | INSERT+INIT | 1663/16391/24797\n2/85DFAA98 | Standby | LOCK |\n2/85DFAAC8 | Standby | RUNNING_XACTS |\n2/85DFAB00 | Transaction | COMMIT |\n(10 rows)\nКзаписям,которыепоявляютсянауровнеminimal,добавились:\n• записи менеджера ресурсов Standby, связанные с репликацией: LOCK\n(блокировки)иRUNNING_XACTS(активныетранзакции);\n• запись об инициализации новой страницы и одновременной вставке\nвнеестрокиINSERT+INIT.\nLogical\nНаконец,максимальныйуровеньlogicalобеспечиваетвозможностьлогиче-\nскогодекодированияилогическойрепликации.Ондолженбытьвключенна\nпубликующемсервере.\nС точки зрения журнальных записей этот уровень практически не отлича-\nетсяотуровняreplica—вимеющиесязаписидобавляютсяидентификаторы\nстрок1; появляются записи,связанные с источниками репликации и анну-\nлированиемкеша,атакжепроизвольныелогическиезаписи,которыемогут\nдобавлятьприложения.В основном желогическоедекодирование зависит\nотинформацииовыполняющихсятранзакциях(RUNNING_XACTS),поскольку\nдля него необходимо строить снимок данных, чтобы отслеживать измене-\nниясистемногокаталога.\n1 postgrespro.ru/docs/postgresql/17/sql-altertable#SQL-ALTERTABLE-REPLICA-IDENTITY.\n241",
    "tables": [
      {
        "table_index": 0,
        "rows": 3,
        "cols": 1,
        "content": "INSERT+INIT\nLOCK\nRUNNING_XACTS"
      }
    ],
    "extracted_at": "2025-10-02T15:59:51.501827"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 246,
    "chapter": null,
    "section": "12.1 Общие сведения о блокировках",
    "text": "12\nБлокировки отношений\n12.1. Общие сведения о блокировках\nБлокировки (locks), называемыетакже замка́ми,упорядочиваютконкурент-\nныйдоступкразделяемымресурсам.\nПод конкурентнымдоступом понимается одновременное обращение к ре-\nсурсу нескольких процессов. Сами процессы могут при этом выполняться\nкак параллельно (если позволяет аппаратура),так и последовательно в ре-\nжимеразделениявремени—этоневажно.Еслинетконкуренции,тонети\nнуждывблокировках(например,общийбуферныйкештребуетблокировок,\nалокальный—нет).\nПеред тем как обратиться к ресурсу, процесс обязан захватить (acquire)\nблокировку, ассоциированную с этим ресурсом, а по окончании работы —\nосвободить(release)ее,чтобыресурсоммогливоспользоватьсядругие.Ког-\nда блокировками управляет СУБД,установленный порядок поддерживает-\nся автоматически; если блокировки устанавливаетприложение,то обязан-\nностьсоблюдатьправилаложитсянанего.\nНанизкомуровнеблокировкапредставляетсяучасткомразделяемойпамя-\nти,вкоторомнекоторымобразомотмечаетсястатусблокировки(свободна\nилизахвачена)и,возможно,дополнительнаяинформация(такаякакномер\nпроцессаивремязахвата).\nМожно заметить, что такой участок разделяемой памяти сам по себе является ре-\nсурсом.Конкурентныйдоступкнемуупорядочиваетсяспомощьюспециальныхпри-\nмитивовсинхронизации(такихкаксемафорыилимьютексы),предоставляемыхопе-\nрационнойсистемой.Ониобеспечиваютстрогопоследовательноевыполнениекода,\nобращающегося к разделяемому ресурсу.На самом низком уровне эти примитивы\n245",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.531969"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 247,
    "chapter": null,
    "section": "12.1 Общие сведения о блокировках",
    "text": "Глава12. Блокировкиотношений\nреализуютсянаосновеатомарныхинструкцийпроцессора(такихкакtest-and-setили\ncompare-and-swap).\nЗащищаемымресурсомвпринципеможетбытьвсечтоугодно,лишьбыэтот\nресурсможнобылооднозначноидентифицироватьисопоставитьемуадрес\nблокировки.\nНапример,ресурсомможетбытьобъект,скоторымработаетСУБД,такойкак\nтаблица(идентифицируетсяспомощьюoidвсистемномкаталоге),страни-\nца данных (идентифицируется именем файла и позицией внутри файла),\nверсия строки (идентифицируется страницей и смещением внутри стра-\nницы). Ресурсом может быть структура в памяти, такая как хеш-таблица\nилибуфер(идентифицируетсязаранееприсвоеннымномером).Иногдада-\nжебываетудобноиспользоватьабстрактныересурсы,неимеющиеникакого\nфизическогосмысла.\nЗахват блокировки возможен не всегда: ресурс может оказаться уже заня-\nтым кем-то другим. Тогда процесс либо встает в очередь (если механизм\nблокировкидаеттакуювозможность),либоповторяетпопыткузахватабло-\nкировкичерезопределенноевремя.Такилииначе,этоприводитктому,что\nпроцессвынужденпростаиватьвожиданииосвобожденияресурса.\nВыделюдвафактора,сильновлияющихнаэффективностьблокировок.\nГранулярность — степень детализации блокировки. Гранулярность важна,\nеслиресурсыобразуютиерархию.\nНапример,таблицасостоитизстраниц,которыесодержатверсиистрок.\nВсеэтиобъектымогутвыступатьвкачествересурсов.Еслиустановить\nблокировку на уровне таблицы (крупная гранулярность), процессы не\nсмогут работать одновременно, даже если они обращаются к разным\nстраницамилистрокам.\nБлокировка отдельных строк (мелкая гранулярность) лишена этого\nнедостатка, но количество блокировок сильно увеличивается. Чтобы\nинформацияонихнезаняласлишкоммногопамяти,могутприменять-\nся разные методы, например повышение уровня (эскалация): когда ко-\nличество низкоуровневых, мелкогранулярных блокировок превышает\nопределенный предел, они заменяются на одну блокировку более вы-\nсокогоуровня.\n246",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.566962"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 248,
    "chapter": null,
    "section": "12.1 Общиесведенияоблокировках",
    "text": "12.1. Общиесведенияоблокировках\nНаборрежимов, вкоторыхмогутзахватыватьсяблокировки.\nЧасто применяют всего два режима. Исключительный (exclusive), или\nмонопольный,режим не совместим ни с какимдругим режимом,втом\nчислессамимсобой.Вразделяемом(shared)режимеблокировкаможет\nзахватываться несколькими процессами одновременно. Разделяемый\nрежимможетиспользоватьсядлячтенияресурса,аисключительный—\nдляизменения.\nВобщемслучаережимовможетбытьбольше.Именарежимовнеимеют\nзначения,важналишьматрицаихсовместимостидругсдругом.\nЧем мельче гранулярностьблокировки и чем больше можно выделитьсов-\nместимыхрежимов,тембольшевозможностейдляраспараллеливания.\nБлокировкиможноклассифицироватьповременииспользования.\nДлительные блокировки захватываются на потенциально большое время\n(обычно до конца транзакции) и чаще всего относятся к таким ресур-\nсам,какотношенияистроки.Какправило,PostgreSQLуправляеттаки-\nмиблокировкамиавтоматически,нопользовательтемнеменееможет\nнекоторымобразомконтролироватьэтотпроцесс.\nДлительныеблокировкихарактеризуютсябольшимколичествомрежи-\nмов,позволяющихвыполнятьразличныеодновременныедействиянад\nданными.Обычнотакиеблокировкиснабжаютсяразвитойинфраструк-\nтурой(очередьюожидания,обнаружениемвзаимоблокировок,монито-\nрингом),посколькузатратынаподдержаниеэтихсредствоказываются\nнесравнимоменьшестоимостиоперацийнадзащищаемымиданными.\nКороткие блокировки захватываются на доли секунды (а зачастую — на\nвремя выполнения нескольких инструкций процессора) и обычно от-\nносятся к структурам данных в общей памяти. Такими блокировками\nPostgreSQLуправляетполностьюавтоматически.\nДля коротких блокировок характерны минимум режимов и простая\nинфраструктура,могутотсутствоватьдажесредствамониторинга.\nВPostgreSQLиспользуютсясамыеразныевидыблокировок1.Кдлительным\nотносятся«тяжелые»блокировки(науровнеотношенийидругихобъектов);\n1 backend/storage/lmgr/README.\n247",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.604129"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 249,
    "chapter": null,
    "section": "12.2 Тяжелые блокировки",
    "text": "Глава12. Блокировкиотношений\nс.258 отдельновыделяютсяблокировкинауровнестрок.Ккороткимблокировкам\nс.295 относятся различные блокировки в оперативной памяти. Особняком стоят\nс.288 предикатныеблокировки,которые,несмотрянаназвание,блокировкамине\nявляются.\n12.2. Тяжелые блокировки\nТяжелые(heavyweight)блокировкиотносятсякдлительным.Ониустанавли-\nваютсянауровнеобъектов:впервуюочередьотношений,нотакжеинекото-\nрыхдругих.Этиблокировкиобычнозащищаютобъектыотодновременного\nизмененияилиотиспользованиявовремяреорганизации,номогутприме-\nнятьсяидлядругихнужд.Такаянечеткаяформулировкасвязанастем,что\nблокировки из этой группы используются для самых разных целей,а объ-\nединяетихлишьто,какониустроены.\nОбычноподсловом«блокировка»,еслинетявныхуточнений,понимаются\nименнотакие,тяжелыеблокировки.\nТяжелые блокировки располагаются в общей памяти сервера1 и доступны\nдля изучения в представлении pg_locks. Их количество ограничено про-\n64 изведением значенийдвух параметров сервера: max_locks_per_transaction и\n100 max_connections.\nПул блокировок — общий для всех транзакций, то есть одна транзакция\nможет захватить больше блокировок, чем max_locks_per_transaction. Важно\nлишь,чтобы общее число блокировок в системе не превысило установлен-\nный предел.Пул создаетсяпри запуске,такчто изменениелюбого издвух\nуказанныхпараметровтребуетперезагрузкисервера.\nЕсли ресурс уже заблокирован в несовместимом режиме, процесс, пытаю-\nщийсязахватитьблокировку,ставитсявочередь.Ожидающиепроцессыне\nтратятпроцессорноевремя:онизасыпаютизатемпробуждаютсяопераци-\nоннойсистемойприосвобожденииресурса.\nс.276 Возможнаситуациявзаимоблокировки(deadlock),илитупикадвухтранзак-\nций,прикоторойпервойизнихдляпродолженияработытребуетсяресурс,\n1 backend/storage/lmgr/lock.c.\n248",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.638503"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 250,
    "chapter": null,
    "section": "12.3 Блокировкиномеровтранзакций",
    "text": "12.3. Блокировкиномеровтранзакций\nзанятый второй транзакцией, а второй в это время необходим ресурс, за-\nнятыйпервой.Этопростойслучай;попастьвтупиковуюситуациюмогути\nболеедвухтранзакций.Привзаимоблокировкеожиданиедлилосьбыбеско-\nнечно,поэтомуPostgreSQLавтоматическиопределяеттупиковыеситуации\nиаварийнопрерываетоднуизтранзакций,чтобыостальныемоглипродол-\nжитьработу.\nПоскольку разные типы тяжелых блокировок служат разным целям,защи-\nщаютразные ресурсы и имеютразные режимы,каждыйтип придется рас-\nсмотретьпоотдельности.\nВприведенномспискеназваниясоответствуютстолбцуlocktypeпредстав-\nленияpg_locks:\ntransactionidиvirtualxid —блокировканомератранзакции; с.249\nrelation —блокировкаотношения; с.251\ntuple —блокировкаверсиистроки; с.265\nobject —блокировкаобъекта,которыйнеявляетсяотношением; с.283\nextend —блокировкафайловотношенийпридобавленииновыхстраниц; с.285\npage —блокировкастраницы(используетсянекоторымитипамииндексов); с.286\nadvisory —рекомендательнаяблокировка. с.286\nПрактическивсетяжелыеблокировкиустанавливаютсяавтоматически,ког-\nдавэтомвозникаетнеобходимость,иавтоматическижеосвобождаютсяпри\nзавершении транзакции. Есть и исключения: например, блокировки отно-\nшенийможнозапроситьявно,ауправлениерекомендательнымиблокиров-\nкамиполностьюнаходитсяврукахпользователя.\n12.3. Блокировки номеров транзакций\nКаждаятранзакциявсегдаудерживаетисключительнуюблокировкусвоего\nсобственногономера(ивиртуального,и—еслиесть—реального). с.91\n249",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.667851"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 251,
    "chapter": null,
    "section": "12.3 Блокировкиномеровтранзакций",
    "text": "Глава12. Блокировкиотношений\nИспользуются два режима блокировки, исключительный и разделяемый.\nМатрицаконфликтовоченьпроста:разделяемыйрежимсовместимсамссо-\nбой;исключительныйрежимнесовместимнискакимрежимом.\nShared Exclusive\nShared ×\nExclusive × ×\nЧтобы дождаться окончания какой-либо транзакции, надо запросить бло-\nкировкуееномера(влюбомрежиме).Посколькусаматранзакцияужеудер-\nживаетисключительнуюблокировкусвоегономера,еенеудастсяполучить.\nЗапрашивающийпроцессвстанетвочередьиуснет.Призавершениитран-\nзакцииблокировкаснимется,итогдаожидающийпроцессбудетразбужен.\nКонечно,получитьзапрошеннуюблокировкуоннесможет—ресурсужеис-\nчез.Ноэтоинетребуется.\nНачнемтранзакциювотдельномсеансеиполучимномеробслуживающего\nпроцесса:\n=> BEGIN;\n=> SELECT pg_backend_pid();\npg_backend_pid\n−−−−−−−−−−−−−−−−\n44244\n(1 row)\nТолько что начатая транзакция удерживает исключительную блокировку\nсобственноговиртуальногономера:\n=> SELECT locktype, virtualxid, mode, granted\nFROM pg_locks WHERE pid = 44244;\nlocktype | virtualxid | mode | granted\n−−−−−−−−−−−−+−−−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−\nvirtualxid | 4/2 | ExclusiveLock | t\n(1 row)\nЗдесь locktype —этотип блокировки, virtualxid —виртуальный номер\nтранзакции (идентифицирующий ресурс), mode—режим (вданном случае\nисключительный).Флагgrantedпоказывает,удалосьлиполучитьзапраши-\nваемуюблокировку.\n250",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.699566"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 252,
    "chapter": null,
    "section": "12.4 Блокировкиотношений",
    "text": "12.4. Блокировкиотношений\nКогдатранзакцияполучаетреальныйномер,егоблокировкатакжедобавля-\nетсяксписку:\n=> SELECT pg_current_xact_id();\npg_current_xact_id\n−−−−−−−−−−−−−−−−−−−−\n149947\n(1 row)\n=> SELECT locktype, virtualxid, transactionid AS xid, mode, granted\nFROM pg_locks WHERE pid = 44244;\nlocktype | virtualxid | xid | mode | granted\n−−−−−−−−−−−−−−−+−−−−−−−−−−−−+−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−\nvirtualxid | 4/2 | | ExclusiveLock | t\ntransactionid | | 149947 | ExclusiveLock | t\n(2 rows)\nТеперь транзакция удерживает исключительную блокировку обоих своих\nномеров.\n12.4. Блокировки отношений\nДляблокировкиотношенийопределеноцелыхвосемьразличныхрежимов1.\nТакое разнообразие необходимодлятого,чтобы как можно большее коли-\nчество команд, относящихся к одному отношению (таблице, индексу или\nдругомуобъекту),могловыполнятьсяодновременно.\nНиже показана матрица конфликтов,дополненная примерами команд,ко-\nторыетребуютсоответствующиережимыблокировок.Нетсмыслапытаться\nзапоминатьэти режимы или искатьлогику в их названиях.Но вниматель-\nнорассмотретьтаблицу,сделатьобщиевыводыиобращатьсякнейпомере\nнеобходимости—безусловно,стоит.\n1 postgrespro.ru/docs/postgresql/17/explicit-locking#LOCKING-TABLES.\n251",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.727266"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 253,
    "chapter": null,
    "section": "12.4 Блокировкиотношений",
    "text": "Глава12. Блокировкиотношений\nAS RS RE SUE S SRE E AE\nAccessShare × SELECT\nRowShare × × SELECTFORUPDATE/SHARE\nRowExclusive × × × × INSERT,UPDATE,DELETE\nShareUpdateExclusive × × × × × VACUUM,CREATEINDEXCONCURRENTLY\nShare × × × × × CREATEINDEX\nShareRowExclusive × × × × × × CREATETRIGGER\nExclusive × × × × × × × REFRESHMAT.VIEWCONCURRENTLY\nAccessExclusive × × × × × × × × DROP,TRUNCATE,VACUUMFULL,\nLOCKTABLE,REFRESHMAT.VIEW\nПервый режимAccess Share самый слабый,он совместим с любым другим,\nкромеAccessExclusive.Этотпоследнийрежим—исключительный,оннесов-\nместимнисоднимрежимом.ПоэтомукомандаSELECTнемешаетвыполне-\nниюпочтиникакихкоманд,нонедаст,например,удалитьтаблицы,ккото-\nрымобращаетсязапрос.\nПервыечетырережимадопускаютодновременноеизменениеданныхвтаб-\nлице,аследующиечетыре—нет.Например,командаCREATEINDEXисполь-\nзуетрежимShare.Онсовместимсамссобой(тоестьможноодновременно\nсоздаватьнесколькоиндексовдляоднойтаблицы)исрежимамичитающих\nкоманд.Такимобразом,командыSELECTбудутвыполняться,авоткоманды\nINSERT,UPDATEиDELETEбудутзаблокированы.\nИ наоборот — незавершенные транзакции, изменяющие данные в табли-\nце,будутблокироватьработукомандыCREATEINDEX.Поэтомуисуществует\nвариант CREATE INDEX CONCURRENTLY, использующий более слабый режим\nShareUpdateExclusive:такаякомандасоздаетиндексдольшеобычной(ида-\nжеможетзавершитьсяошибкой),затодопускаетодновременноеизменение\nданных.\nКомандаALTER TABLE имеетмноговариантов,которыетребуютразныхре-\nжимов блокировки (Share Update Exclusive, Share Row Exclusive,Access Exclu-\nsive).Всережимы,разумеется,описанывдокументации1.\n1 postgrespro.ru/docs/postgresql/17/sql-altertable.\n252",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.762293"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 254,
    "chapter": null,
    "section": "12.4 Блокировкиотношений",
    "text": "12.4. Блокировкиотношений\nПримерывэтойчастикнигибудутиспользоватьужезнакомуюнамтаблицу\nсчетов:\n=> TRUNCATE accounts;\n=> INSERT INTO accounts(id, client, amount)\nVALUES (1, 'alice', 100.00),\n(2, 'bob', 200.00),\n(3, 'charlie', 300.00);\nЗапросктаблицеблокировокпонадобитсяещенераз,поэтомусоздадимдля\nнего представление,в котором для краткости вывода свернем все иденти-\nфикаторыводинобщийстолбец:\n=> CREATE VIEW locks AS\nSELECT pid,\nlocktype,\nCASE locktype\nWHEN 'relation' THEN relation::regclass::text\nWHEN 'transactionid' THEN transactionid::text\nWHEN 'virtualxid' THEN virtualxid\nEND AS lockid,\nmode,\ngranted\nFROM pg_locks\nORDER BY 1, 2, 3;\nТранзакциявпервомсеансе(онанезавершалась)обновляетстроку.Вместе\nстаблицейблокируютсяивсеиндексыэтойтаблицы,поэтомупоявляются\nдвеновыеблокировкистипомrelationирежимомRowExclusive:\n=> UPDATE accounts SET amount = amount + 100.00 WHERE id = 1;\n=> SELECT locktype, lockid, mode, granted\nFROM locks WHERE pid = 44244;\nlocktype | lockid | mode | granted\n−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−+−−−−−−−−−\nrelation | accounts | RowExclusiveLock | t\nrelation | accounts_pkey | RowExclusiveLock | t\ntransactionid | 149947 | ExclusiveLock | t\nvirtualxid | 4/2 | ExclusiveLock | t\n(4 rows)\n253",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.795074"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 255,
    "chapter": null,
    "section": "12.5 Очередь ожидания",
    "text": "Глава12. Блокировкиотношений\n12.5. Очередь ожидания\nТяжелые блокировки предоставляют «честную» очередь ожидания1. Про-\nцесс встает в очередь, если пытается захватить блокировку в режиме,\nнесовместимомсрежимом,вкоторомблокировкаужезахвачена,илисре-\nжимомлюбогоизужеожидающихвочередипроцессов.\nПокавпервомсеансетранзакциявыполняетобновление,попробуемвдру-\nгомсеансесоздатьиндекспотаблице:\n=> SELECT pg_backend_pid();\npg_backend_pid\n−−−−−−−−−−−−−−−−\n44723\n(1 row)\n=> CREATE INDEX ON accounts(client);\nКоманда«подвисает»вожиданииосвобожденияресурса.Транзакцияпыта-\nетсяполучитьблокировкутаблицыврежимеShare,нонеможет:\n=> SELECT locktype, lockid, mode, granted\nFROM locks WHERE pid = 44723;\nlocktype | lockid | mode | granted\n−−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−\nrelation | accounts | ShareLock | f\nvirtualxid | 6/3 | ExclusiveLock | t\n(2 rows)\nПусть теперь в третьем сеансе будет запущена команда VACUUM FULL. Она\nтожебудетпоставленавочередь,посколькунеобходимыйейрежимAccess\nExclusiveнесовместимнисоднимрежимом:\n=> SELECT pg_backend_pid();\npg_backend_pid\n−−−−−−−−−−−−−−−−\n44926\n(1 row)\n=> VACUUM FULL accounts;\n1 backend/storage/lmgr/lock.c,функцияLockAcquire.\n254",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.825961"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 256,
    "chapter": null,
    "section": "12.5 Очередьожидания",
    "text": "12.5. Очередьожидания\n=> SELECT locktype, lockid, mode, granted\nFROM locks WHERE pid = 44926;\nlocktype | lockid | mode | granted\n−−−−−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−\nrelation | accounts | AccessExclusiveLock | f\ntransactionid | 149951 | ExclusiveLock | t\nvirtualxid | 8/4 | ExclusiveLock | t\n(3 rows)\nТеперьивсепоследующиепретендентыбудутпопадатьвочередь,уженеза-\nвисимоотрежимаблокировки.ДажеобычныезапросыSELECTбудутчестно\nвставатьзаVACUUMFULL,хотьисовместимысблокировкойRowExclusive,ко-\nторуюудерживаетпервыйсеанс,выполняющийкомандуUPDATE.\n=> SELECT pg_backend_pid();\npg_backend_pid\n−−−−−−−−−−−−−−−−\n45136\n(1 row)\n=> SELECT * FROM accounts;\n=> SELECT locktype, lockid, mode, granted\nFROM locks WHERE pid = 45136;\nlocktype | lockid | mode | granted\n−−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−−−−+−−−−−−−−−\nrelation | accounts | AccessShareLock | f\nvirtualxid | 10/3 | ExclusiveLock | t\n(2 rows)\nT1\nUPDATE\nT2 relation\nT3\nCREATEINDEX\nT4\nVACUUMFULL\nSELECT\n255",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.858742"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 257,
    "chapter": null,
    "section": "12.5 Очередьожидания",
    "text": "Глава12. Блокировкиотношений\nОбщую картину ожиданий дает функция pg_blocking_pids. Она показы-\nвает номера процессов,которые стоят в очереди перед указанным и либо\nудерживают,либозапрашиваютнесовместимуюблокировку:\n=> SELECT pid,\npg_blocking_pids(pid),\nwait_event_type,\nstate,\nleft(query,50) AS query\nFROM pg_stat_activity\nWHERE pid IN (44244,44723,44926,45136) \\gx\n−[ RECORD 1 ]−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\npid | 44244\npg_blocking_pids | {}\nwait_event_type | Client\nstate | idle in transaction\nquery | UPDATE accounts SET amount = amount + 100.00 WHERE\n−[ RECORD 2 ]−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\npid | 44723\npg_blocking_pids | {44244}\nwait_event_type | Lock\nstate | active\nquery | CREATE INDEX ON accounts(client);\n−[ RECORD 3 ]−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\npid | 44926\npg_blocking_pids | {44244,44723}\nwait_event_type | Lock\nstate | active\nquery | VACUUM FULL accounts;\n−[ RECORD 4 ]−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\npid | 45136\npg_blocking_pids | {44926}\nwait_event_type | Lock\nstate | active\nquery | SELECT * FROM accounts;\nБолеедетальноепредставлениеможнополучить,аккуратноанализируясо-\nдержимоетаблицыpg_locks1.\nКогда транзакция завершается (неважно, фиксацией или обрывом), все ее\nблокировкиснимаются2.Процесс,стоящийпервымвочереди,получаетза-\nпрашиваемуюблокировкуипробуждается.\n1 wiki.postgresql.org/wiki/Lock_dependency_information.\n2 backend/storage/lmgr/lock.c,функцииLockReleaseAllиLockRelease.\n256",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.893821"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 258,
    "chapter": null,
    "section": "12.5 Очередьожидания",
    "text": "12.5. Очередьожидания\nНеочевидный момент состоит в том,что при откате к точке сохранения (командой с.92\nROLLBACKTOSAVEPOINTилиприпопаданиивсекциюEXCEPTIONPL/pgSQL-блока)\nснимаютсявсеблокировки,захваченныетранзакциейсмоментаустановкиэтойточ-\nки.Этосвязаносоткатомвложеннойтранзакциииосвобождениемееблокировок.\nВ нашем примере завершениетранзакции в первом сеансе приведетк по-\nследовательномувыполнениювсехзапросов,стоящихвочереди:\n=> ROLLBACK;\nROLLBACK\nCREATE INDEX\nVACUUM\nid | client | amount\n−−−−+−−−−−−−−−+−−−−−−−−\n1 | alice | 100.00\n2 | bob | 200.00\n3 | charlie | 300.00\n(3 rows)\n257",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.913423"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 259,
    "chapter": null,
    "section": "13.1 Устройство",
    "text": "13\nБлокировки строк\n13.1. Устройство\nБлагодаряизоляциинаосновеснимковтабличныестрокинетребуетсябло-\nкироватьпричтении.Нонельзядопустить,чтобыдветранзакцииизменяли\nодну и ту же строку в один момент времени. Строки нужно блокировать,\nвот только тяжелые блокировки плохо подходят для этого: каждая из них\nзанимаетместовразделяемойпамятисервера(сотнибайт,несчитаявспо-\nмогательнойинфраструктуры),авнутренниемеханизмынерассчитанына\nработусогромнымколичествомодновременносуществующихблокировок.\nВнекоторыхСУБДэтапроблемарешаетсяповышениемуровняблокировки:\nесли блокировок уровня строк становится слишком много, они заменяют-\nся одной более общей блокировкой (например,уровня страницы или всей\nтаблицы).Этоупрощаетреализацию,номожетприводитьксильномусни-\nжениюэффективности.\nВPostgreSQLинформацияотом,чтостроказаблокирована,хранитсятоль-\nковзаголовкеверсиистроки.Фактическиэтопростопризнакивстраницах\nданных,аненастоящиеблокировки—воперативнойпамятиониникакне\nотражаются.\nс.87 Обычнострокаблокируетсяприизмененииилиудалении.Вобоихслучаях\nактуальнаяверсиястрокипомечаетсякакудаленная.Признакомслужитно-\nмертранзакциивполеxmax,иэтотженомер(всочетаниисдополнительны-\nмиинформационнымибитами)указываетнато,чтостроказаблокирована.\nКогда какая-либо транзакция собирается изменить строку, но видит в по-\nлеxmaxактуальнойверсииномернезавершеннойтранзакции,онаобязана\n258",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.940767"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 260,
    "chapter": null,
    "section": "13.2 Режимыблокировкистроки",
    "text": "13.2. Режимыблокировкистроки\nдождаться ее завершения.После этого все блокировки будутсняты,и ожи-\nдающаятранзакциясможетпродолжитьсвоюоперациюнадстрокой.\nТакое решение позволяетблокироватьсколько угодно строк,не потребляя\nникакихресурсов.\nОбратная сторона медали состоит в том,что без информации о блокиров-\nке в оперативной памяти другие процессы не могут встать в очередь. По-\nэтому приходится все-таки использовать и обычные тяжелые блокировки.\nДождатьсяосвобождениястрокиозначаетдождатьсяокончанияблокирую-\nщейтранзакции,адляэтогонужнозапроситьблокировкуееномера.Таким\nобразом,числоиспользуемыхтяжелыхблокировокпропорциональночислу\nодновременно работающих процессов,а не количеству изменяемых строк.\n13.2. Режимы блокировки строки\nСуществуетчетырережима,вкоторыхможнозаблокироватьстроку1.Дваре-\nжима представляют исключительные блокировки, которые одновременно\nможет удерживатьтолько однатранзакция,и еще два—разделяемые бло-\nкировки,которыемогутудерживатьсянесколькимитранзакциями.\nМатрицаконфликтоввыглядитследующимобразом:\nNoKey\nKeyShare Share Update\nUpdate\nKeyShare ×\nShare × ×\nNoKeyUpdate × × ×\nUpdate × × × ×\nИсключительные режимы\nРежим Update предполагает изменение любых полей строки или ее удале-\nние,арежимNoKeyUpdate—изменениетолькотехполей,которыеневходят\n1 postgrespro.ru/docs/postgresql/17/explicit-locking#LOCKING-ROWS.\n259",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:51.967025"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 261,
    "chapter": null,
    "section": "13.2 Режимыблокировкистроки",
    "text": "Глава13. Блокировкистрок\nвуникальныеиндексы(инымисловами,такоеизменение,котороенеможет\nзатронутьвнешниеключи).\nКоманда UPDATE сама выбирает минимальный подходящий режим блоки-\nровки; поскольку ключи обычно не меняются,чаще всего строки блокиру-\nютсяврежимеNoKeyUpdate.\nСоздадим функцию, которая с помощью расширения pageinspect пока-\nжетинтересующую нас информацию о версиях строк,а именно поле xmax\nинекоторыеинформационныебиты:\n=> CREATE FUNCTION row_locks(relname text, pageno integer)\nRETURNS TABLE(\nctid tid, xmax text,\nlock_only text, is_multi text,\nkeys_upd text, keyshr text, shr text\n) AS $$\nSELECT (pageno,lp)::text::tid,\nt_xmax,\nCASE WHEN t_infomask & 128 = 128 THEN 't' END,\nCASE WHEN t_infomask & 4096 = 4096 THEN 't' END,\nCASE WHEN t_infomask2 & 8192 = 8192 THEN 't' END,\nCASE WHEN t_infomask & 16 = 16 THEN 't' END,\nCASE WHEN t_infomask & 16+64 = 16+64 THEN 't' END\nFROM heap_page_items(get_raw_page(relname,pageno))\nORDER BY lp;\n$$ LANGUAGE sql;\nНачнем транзакцию и обновим сумму первого счета в таблице accounts\n(ключнеменяется)иномервторогосчета(ключменяется):\n=> BEGIN;\n=> UPDATE accounts SET amount = amount + 100.00 WHERE id = 1;\n=> UPDATE accounts SET id = 20 WHERE id = 2;\nЗаглянемвстраницу:\n=> SELECT * FROM row_locks('accounts',0) LIMIT 2;\nctid | xmax | lock_only | is_multi | keys_upd | keyshr | shr\n−−−−−−−+−−−−−−−−+−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−+−−−−−\n(0,1) | 149956 | | | | |\n(0,2) | 149956 | | | t | |\n(2 rows)\n260",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:52.004463"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 262,
    "chapter": null,
    "section": "13.2 Режимыблокировкистроки",
    "text": "13.2. Режимыблокировкистроки\nРежим блокировки определяется информационным битом keys_updated.\n=> ROLLBACK;\nТо же самое поле xmax используется как признак блокирования командой\nSELECT FOR,но в этом случае проставляется дополнительный информаци-\nонный бит xmax_lock_only. Он говорит о том, что версия строки только\nзаблокирована,нонеудаленаипо-прежнемуявляетсяактуальной:\n=> BEGIN;\n=> SELECT * FROM accounts WHERE id = 1 FOR NO KEY UPDATE;\n=> SELECT * FROM accounts WHERE id = 2 FOR UPDATE;\n=> SELECT * FROM row_locks('accounts',0) LIMIT 2;\nctid | xmax | lock_only | is_multi | keys_upd | keyshr | shr\n−−−−−−−+−−−−−−−−+−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−+−−−−−\n(0,1) | 149957 | t | | | |\n(0,2) | 149957 | t | | t | |\n(2 rows)\n=> ROLLBACK;\nРазделяемые режимы\nРежимShareможетприменяться,когданужнопрочитатьстроку,ноприэтом\nнельзядопустить,чтобыонакак-либоизмениласьдругойтранзакцией.Ре-\nжимKeyShareдопускаетизменениелюбыхполейстроки,кромеключевых.\nИзразделяемыхрежимовсамоядроPostgreSQLиспользуеттолькоKeyShare\nприпроверкевнешнихключей.Онсовместимсисключительнымрежимом\nNoKeyUpdate,тоестьпроверкавнешнихключейнемешаетодновременному\nобновлениюлюбыхнеключевыхполей.Конечно,приложениямогутисполь-\nзоватьлюбойподходящийрежим.\nПодчеркну еще раз,что при чтении не используются никакие блокировки\nуровнястроки.\n=> BEGIN;\n=> SELECT * FROM accounts WHERE id = 1 FOR KEY SHARE;\n=> SELECT * FROM accounts WHERE id = 2 FOR SHARE;\n261",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:52.038781"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 263,
    "chapter": null,
    "section": "13.2 Режимыблокировкистроки",
    "text": "Глава13. Блокировкистрок\nВверсияхстроквидим:\n=> SELECT * FROM row_locks('accounts',0) LIMIT 2;\nctid | xmax | lock_only | is_multi | keys_upd | keyshr | shr\n−−−−−−−+−−−−−−−−+−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−+−−−−−\n(0,1) | 149958 | t | | | t |\n(0,2) | 149958 | t | | | t | t\n(2 rows)\nВ обоих случаях установлен бит xmax_keyshr_lock, а режим Share можно\nраспознать,посмотревдругиеинформационныебиты1.\n13.3. Мультитранзакции\nПризнакблокировкипредставленномеромблокирующейтранзакциивпо-\nле xmax, но разделяемые блокировки могут удерживаться несколькими\nтранзакциямиодновременно.Какводнополезаписатьсразунескольконо-\nмеров?\nДля разделяемых блокировок применяются так называемые мультитран-\nзакции2 (MultiXact). Мультитранзакция — это группа транзакций, кото-\nрой присвоен отдельный номер. Детальная информация об участниках\nтакой группы и режимах их блокировок хранится в файлах в каталоге\nPGDATA/pg_multixact.Посколькуколичествоучастниковмультитранзакций\nможет быть произвольным, работа со страницами в памяти организована\nс.299 с помощью двух SLRU-кешей: один для состава мультитранзакций, а вто-\nрой для смещений, по которым следует искать информацию в первом\n32 кеше. Размер кешей настраивается параметрами multixact_member_buffers\n16 иmultixact_offset_buffers.\nНомер мультитранзакции имеетту же размерность,что и обычный номер\nтранзакции (32 бита), но номера выделяются независимо,то есть номера\nтранзакцийимультитранзакциймогутпересекаться.Чтобыотличитьодин\nвид транзакций от другого, используется дополнительный информацион-\nныйбитxmax_is_multi.\n1 include/access/htup_details.h.\n2 backend/access/transam/multixact.c.\n262",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:52.073201"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 264,
    "chapter": null,
    "section": "13.3 Мультитранзакции",
    "text": "13.3. Мультитранзакции\nДобавимкимеющимсяблокировкамещеоднуисключительную,выполнен-\nную другой транзакцией (это можно сделать,поскольку режимы Key Share\nиNoKeyUpdateсовместимымеждусобой):\n=> BEGIN;\n=> UPDATE accounts SET amount = amount + 100.00 WHERE id = 1;\n=> SELECT * FROM row_locks('accounts',0) LIMIT 2;\nctid | xmax | lock_only | is_multi | keys_upd | keyshr | shr\n−−−−−−−+−−−−−−−−+−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−+−−−−−\n(0,1) | 1 | | t | | |\n(0,2) | 149958 | t | | | t | t\n(2 rows)\nВ первой строке обычный номер заменен на номер мультитранзакции —\nобэтомговоритбитxmax_is_multi.\nЧтобыневникатьвдеталиреализациимультитранзакций,можновосполь-\nзоватьсярасширениемpgrowlocks,котороепозволяетувидетьвсюинфор-\nмациюовсехтипахблокировокстроквудобномвиде:\n=> CREATE EXTENSION pgrowlocks;\n=> SELECT * FROM pgrowlocks('accounts') \\gx\n−[ RECORD 1 ]−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nlocked_row | (0,1)\nlocker | 1\nmulti | t\nxids | {149958,149959}\nmodes | {\"For Key Share\",\"No Key Update\"}\npids | {45687,45987}\n−[ RECORD 2 ]−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nlocked_row | (0,2)\nlocker | 149958\nmulti | f\nxids | {149958}\nmodes | {\"For Share\"}\npids | {45687}\nТакой запрос внешне похож на обращение к представлению pg_locks,но\nфункция pgrowlocks читает табличные страницы,так как в оперативной\nпамятиинформацииоблокировкахуровнястрокинет.\n263",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:52.106269"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 265,
    "chapter": null,
    "section": "13.3 Мультитранзакции",
    "text": "Глава13. Блокировкистрок\n=> COMMIT;\n=> ROLLBACK;\nПоскольку для мультитранзакций выделяются 32-битные номера, из-за\nограниченияразрядностисчетчикаснимивозникаеттакаяжепроблемапе-\nс.150 реполнения(xidwraparound),чтоисобычнымномером.Поэтомудляноме-\nровмультитранзакцийнеобходимовыполнятьаналогзаморозки—заменять\nстарыеномеранановые(илинаобычныйномертранзакции,есливмомент\nзаморозкиблокировкаудерживаетсяужетолькооднойтранзакцией)1.\nНо если заморозка обычных номеровтранзакций выполняетсятолько для\nполяxmin(таккакверсииснепустымполемxmaxнеактуальныибудуточи-\nщены),тодлямультитранзакций,наоборот,замораживаетсяполеxmax:ак-\nтуальная версия строки можетпостоянно блокироваться все новымитран-\nзакциямивразделяемомрежиме.\nЗазаморозкумультитранзакцийотвечаютпараметрысервера,аналогичные\nтем, что управляют обычной заморозкой: vacuum_multixact_freeze_min_age,\nvacuum_multixact_freeze_table_age, autovacuum_multixact_freeze_max_age, а так-\nv.14 жеvacuum_multixact_failsafe_age.\n13.4. Очередь ожидания\nИсключительные режимы\nИз-затого,что блокировка строки—просто признак,очередь организова-\nнавесьманетривиально.Когдатранзакциясобираетсяизменитьстроку,она\nвыполняетследующуюпоследовательностьдействий2:\n1) если поле xmax и информационные биты версии строки указываютна\nто,чтостроказаблокированавнесовместимомрежиме,захватываетис-\nключительнуютяжелуюблокировкуизменяемойверсиистроки;\n2) при необходимости дожидается освобождения несовместимых блоки-\nровок,запрашивая блокировку номератранзакции xmax (или несколь-\nкихтранзакций,еслиxmax—мультитранзакция);\n1 backend/access/heap/heapam.c,функцияFreezeMultiXactId.\n2 backend/access/heap/README.tuplock.\n264",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:52.144215"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 266,
    "chapter": null,
    "section": "13.4 Очередьожидания",
    "text": "13.4. Очередьожидания\n3) прописываетвверсиюстрокисвойномер(вполеxmax)иустанавливает\nнеобходимыеинформационныебиты;\n4) освобождаетблокировку версии строки,если она захватываласьв п.1.\nБлокировка версии строки (tuple lock) является еще одним видомтяжелых\nблокировок;онаимееттипtuple.Непутайтеегосблокировкойсобственно\nстроки(rowlock).\nМожет показаться, что шаги 1 и 4 избыточны и достаточно ограничиться\nтолькоожиданиемблокирующихтранзакций.Ноеслистрокуодновременно\nпытаютсяобновитьнесколькотранзакций,всеонибудутждатьзавершения\nтранзакции, работающей над строкой в данный момент. При завершении\nэтойтранзакциимеждуожидающимивозникнетсостояниегонкизаправо\nобладания строкой, а это может привести к неопределенно долгому ожи-\nданиюдляотдельных«невезучих»транзакций.Такаяситуацияназывается\nресурснымголоданием(starvation).\nБлокировкаверсиистрокивыделяетпервуювочередитранзакциюигаран-\nтирует,чтоименноонаполучитблокировкуследующей.\nОднаколучшеодинразувидеть.Посколькувпроцессеработывозникаетдо-\nвольномногоразныхблокировок,икаждойсоответствуетотдельнаястрока\nвтаблице pg_locks,я создам еще одно представление над pg_locks.Оно\nпоказывает информацию компактно и оставляет только интересные нам\nсейчасблокировки(относящиесяктаблицеaccountsиксамойтранзакции,\nнобезблокировкивиртуальныхномеров):\n=> CREATE VIEW locks_accounts AS\nSELECT pid,\nlocktype,\nCASE locktype\nWHEN 'relation' THEN relation::regclass::text\nWHEN 'transactionid' THEN transactionid::text\nWHEN 'tuple' THEN relation::regclass||'('||page||','||tuple||')'\nEND AS lockid,\nmode,\ngranted\nFROM pg_locks\nWHERE locktype in ('relation','transactionid','tuple')\nAND (locktype != 'relation' OR relation = 'accounts'::regclass)\nORDER BY 1, 2, 3;\n265",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:52.182018"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 267,
    "chapter": null,
    "section": "13.4 Очередьожидания",
    "text": "Глава13. Блокировкистрок\nНачнемпервуютранзакциюиобновимстроку:\n=> BEGIN;\n=> SELECT txid_current(), pg_backend_pid();\ntxid_current | pg_backend_pid\n−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−\n149961 | 45987\n(1 row)\n=> UPDATE accounts SET amount = amount + 100.00 WHERE id = 1;\nТранзакцияуспешновыполняетчетырешагапоследовательностиитеперь\nудерживаетблокировкутаблицы:\n=> SELECT * FROM locks_accounts WHERE pid = 45987;\npid | locktype | lockid | mode | granted\n−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−−−−−+−−−−−−−−−\n45987 | relation | accounts | RowExclusiveLock | t\n45987 | transactionid | 149961 | ExclusiveLock | t\n(2 rows)\nНачинаемвторуютранзакциюипытаемсяобновитьтужестроку.Транзак-\nцияподвисаетвожиданииблокировки:\n=> BEGIN;\n=> SELECT txid_current(), pg_backend_pid();\ntxid_current | pg_backend_pid\n−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−\n149962 | 46058\n(1 row)\n=> UPDATE accounts SET amount = amount + 100.00 WHERE id = 1;\nT1\nNoKeyUpdate\nT2 (c 0t ,i 1d\n)\nxmin xmax\nданные\nT1\ntuple(0,1)\nВтораятранзакциядошлатолькодовторогошага.Поэтому,помимоблоки-\nровкитаблицы и собственного номера,она добавляет в pg_locks еще две\n266",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:52.215841"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 268,
    "chapter": null,
    "section": "13.4 Очередьожидания",
    "text": "13.4. Очередьожидания\nстроки: захваченную на первом шаге блокировку типа tuple и запрошен-\nнуюнавторомшагеблокировкуномерапервойтранзакции:\n=> SELECT * FROM locks_accounts WHERE pid = 46058;\npid | locktype | lockid | mode | granted\n−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−+−−−−−−−−−\n46058 | relation | accounts | RowExclusiveLock | t\n46058 | transactionid | 149961 | ShareLock | f\n46058 | transactionid | 149962 | ExclusiveLock | t\n46058 | tuple | accounts(0,1) | ExclusiveLock | t\n(4 rows)\nТретья транзакция дойдеттолько до первого шага. Она попытается захва-\nтитьблокировкуверсиистрокииостановитсяуженаэтом:\n=> BEGIN;\n=> SELECT txid_current(), pg_backend_pid();\ntxid_current | pg_backend_pid\n−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−\n149963 | 46129\n(1 row)\n=> UPDATE accounts SET amount = amount + 100.00 WHERE id = 1;\n=> SELECT * FROM locks_accounts WHERE pid = 46129;\npid | locktype | lockid | mode | granted\n−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−+−−−−−−−−−\n46129 | relation | accounts | RowExclusiveLock | t\n46129 | transactionid | 149963 | ExclusiveLock | t\n46129 | tuple | accounts(0,1) | ExclusiveLock | f\n(3 rows)\nЧетвертая и последующие транзакции, желающие обновить ту же самую\nстроку,ничемнебудутотличатьсяоттретьей—всеонибудутожидатьодну\nитужеблокировкуверсиистроки.\n=> BEGIN;\n=> SELECT txid_current(), pg_backend_pid();\ntxid_current | pg_backend_pid\n−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−\n149964 | 46200\n(1 row)\n267",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:52.255986"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 269,
    "chapter": null,
    "section": "13.4 Очередьожидания",
    "text": "Глава13. Блокировкистрок\n=> UPDATE accounts SET amount = amount + 100.00 WHERE id = 1;\n=> SELECT * FROM locks_accounts WHERE pid = 46129;\npid | locktype | lockid | mode | granted\n−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−+−−−−−−−−−\n46129 | relation | accounts | RowExclusiveLock | t\n46129 | transactionid | 149963 | ExclusiveLock | t\n46129 | tuple | accounts(0,1) | ExclusiveLock | f\n(3 rows)\nT1\nNoKeyUpdate\nT2 (c 0t ,i 1d\n)\nxmin xmax\nданные\nT1\nT3 tuple(0,1)\nT4\nОбщую картину текущих ожиданий можно посмотреть в представлении\npg_stat_activity,добавивинформациюоблокирующихпроцессах:\n=> SELECT pid,\nwait_event_type,\nwait_event,\npg_blocking_pids(pid)\nFROM pg_stat_activity\nWHERE pid IN (45987,46058,46129,46200);\npid | wait_event_type | wait_event | pg_blocking_pids\n−−−−−−−+−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−\n45987 | Client | ClientRead | {}\n46058 | Lock | transactionid | {45987}\n46129 | Lock | tuple | {46058}\n46200 | Lock | tuple | {46058,46129}\n(4 rows)\nЕслиперваятранзакциязавершитсяоткатом,всяэтаконструкциябудетра-\nботатьтак,какиследовалобыожидать:оставшиесятранзакциипродвинут-\nсявочередивтомжепорядкенаодиншаг.\n268",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:52.617963"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 270,
    "chapter": null,
    "section": "13.4 Очередьожидания",
    "text": "13.4. Очередьожидания\nНовсе-такиболеевероятно,чтоперваятранзакциязавершитсяфиксацией.\nНа уровне изоляции Repeatable Read или Serializable это приведетк обрыву\nвторойтранзакциисошибкойсериализации1(азатемиостальных,стоящих\nвочереди).НонауровнеReadCommittedизмененнаястрокаперечитывается,\nивозобновляетсяпопыткаееобновления.\nИтак,перваятранзакциязавершается:\n=> COMMIT;\nВтораятранзакцияпробуждаетсяиуспешновыполняеттретийичетвертый\nшагипоследовательности:\nUPDATE 1\n=> SELECT * FROM locks_accounts WHERE pid = 46058;\npid | locktype | lockid | mode | granted\n−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−−−−−+−−−−−−−−−\n46058 | relation | accounts | RowExclusiveLock | t\n46058 | transactionid | 149962 | ExclusiveLock | t\n(2 rows)\nКактольковтораятранзакцияосвобождаетблокировкуверсиистроки,про-\nсыпаетсяитретьятранзакция,ноонаобнаруживаетвполеxmaxновойвер-\nсии строки уже другой номер. На этом последовательность блокирования,\nприведеннаявыше,завершаетсянеуспехом.НауровнеизоляцииRead Com-\nmitted выполняется повторная попытка заблокировать строку2, но эта по-\nпыткауженеследуетприведеннойпоследовательности.Третьятранзакция\nбудетожидать завершения второй без попыток захватить блокировку вер-\nсиистроки:\n=> SELECT * FROM locks_accounts WHERE pid = 46129;\npid | locktype | lockid | mode | granted\n−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−−−−−+−−−−−−−−−\n46129 | relation | accounts | RowExclusiveLock | t\n46129 | transactionid | 149962 | ShareLock | f\n46129 | transactionid | 149963 | ExclusiveLock | t\n(3 rows)\n1 backend/executor/nodeModifyTable.c,функцияExecUpdate.\n2 backend/access/heap/heapam_handler.c,функцияheapam_tuple_lock.\n269",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:52.659208"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 271,
    "chapter": null,
    "section": "13.4 Очередьожидания",
    "text": "Глава13. Блокировкистрок\nТожесамоепроисходитисчетвертойтранзакцией:\n=> SELECT * FROM locks_accounts WHERE pid = 46200;\npid | locktype | lockid | mode | granted\n−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−−−−−+−−−−−−−−−\n46200 | relation | accounts | RowExclusiveLock | t\n46200 | transactionid | 149962 | ShareLock | f\n46200 | transactionid | 149964 | ExclusiveLock | t\n(3 rows)\nТеперьитретья,ичетвертаятранзакцииожидаютзавершениявторойспер-\nспективойгонкизазахватблокировки.Очередькактаковаяраспалась.\nT2\nNoKeyUpdate\n(c 0t ,i 1d\n)\nxmin\nxmax\nданные\nT1\nT3 (0,2)\nT1\nT4 T2\nЕслибы,покаочередьещесуществовала,внееуспеливстатьнесколькодру-\nгихтранзакций,всеониоказалисьбыневольнымиучастникамиэтойгонки.\nВывод:одновременнообновлятьоднуитужестрокутаблицывомногихпа-\nраллельныхпроцессах—несамаяудачнаяидея.Этосоздаетгорячуюточку,\nкоторая при достаточно высокой нагрузке становится узким местом и вы-\nзываетпроблемыспроизводительностью.\nЗавершимвсеначатыетранзакции.\n=> COMMIT;\nUPDATE 1\n=> COMMIT;\nUPDATE 1\n=> COMMIT;\n270",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:52.691219"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 272,
    "chapter": null,
    "section": "13.4 Очередьожидания",
    "text": "13.4. Очередьожидания\nРазделяемые режимы\nРазделяемые блокировки строк применяются PostgreSQL только для про-\nверки ссылочной целостности.Использование их в нагруженном приложе-\nнииможетприводитькресурсномуголоданию,идвухуровневаясхемабло-\nкированияэтомуникакнепрепятствует.\nНапомню еще раз последовательностьдействий,которую выполняеттран-\nзакцияприблокировкестроки:\n1) если поле xmax и информационные биты версии строки указываютна\nто,чтостроказаблокированавнесовместимомрежиме,захватываетис-\nключительнуютяжелуюблокировкуизменяемойверсиистроки;\n2) при необходимости дожидается освобождения несовместимых блоки-\nровок,запрашивая блокировку номератранзакции xmax (или несколь-\nкихтранзакций,еслиxmax—мультитранзакция);\n3) прописываетвверсиюстрокисвойномер(вполеxmax)иустанавливает\nнеобходимыеинформационныебиты;\n4) освобождаетблокировку версии строки,если она захватываласьв п.1.\nПервыедва шага говорятотом,чтоеслирежимыблокировоксовместимы,\nтранзакцияпройдетбезочереди.\nПовторимнашэкспериментсчистоголиста.\n=> TRUNCATE accounts;\n=> INSERT INTO accounts(id, client, amount)\nVALUES (1,'alice',100.00),\n(2,'bob',200.00),\n(3,'charlie',300.00);\nНачинаемпервуютранзакцию:\n=> BEGIN;\n=> SELECT txid_current(), pg_backend_pid();\ntxid_current | pg_backend_pid\n−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−\n149967 | 45987\n(1 row)\n271",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:52.721690"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 273,
    "chapter": null,
    "section": "13.4 Очередьожидания",
    "text": "Глава13. Блокировкистрок\nПерваятранзакцияблокируетстрокувразделяемомрежиме:\n=> SELECT * FROM accounts WHERE id = 1 FOR SHARE;\nВтораятранзакцияпытаетсяобновитьтужестроку,нонеможет—режимы\nShareиNoKeyUpdateнесовместимы:\n=> BEGIN;\n=> SELECT txid_current(), pg_backend_pid();\ntxid_current | pg_backend_pid\n−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−\n149968 | 46058\n(1 row)\n=> UPDATE accounts SET amount = amount + 100.00 WHERE id = 1;\nВтораятранзакцияждетзавершенияпервойиудерживаетблокировкувер-\nсиистроки—какивпрошломпримере:\n=> SELECT * FROM locks_accounts WHERE pid = 46058;\npid | locktype | lockid | mode | granted\n−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−+−−−−−−−−−\n46058 | relation | accounts | RowExclusiveLock | t\n46058 | transactionid | 149967 | ShareLock | f\n46058 | transactionid | 149968 | ExclusiveLock | t\n46058 | tuple | accounts(0,1) | ExclusiveLock | t\n(4 rows)\nT1\nShare\nT2 (c 0t ,i 1d\n)\nxmin xmax\nданные\nT1\ntuple(0,1)\nПусть теперь третья транзакция блокирует строку в разделяемом режиме.\nЕеблокировкасовместимасужеимеющейсяблокировкой,ипоэтомутретья\nтранзакцияпроходитбезочереди:\n272",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:52.755686"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 274,
    "chapter": null,
    "section": "13.4 Очередьожидания",
    "text": "13.4. Очередьожидания\n=> BEGIN;\n=> SELECT txid_current(), pg_backend_pid();\ntxid_current | pg_backend_pid\n−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−\n149969 | 46129\n(1 row)\n=> SELECT * FROM accounts WHERE id = 1 FOR SHARE;\nИвотужедветранзакцииблокируютстроку:\n=> SELECT * FROM pgrowlocks('accounts') \\gx\n−[ RECORD 1 ]−−−−−−−−−−−−−−−−−−−−−−−−−\nlocked_row | (0,1)\nlocker | 2\nmulti | t\nxids | {149967,149969}\nmodes | {\"For Share\",\"For Share\"}\npids | {45987,46129}\nT1\nT3\nShare\nT2 (c 0t ,i 1d\n)\nxmin xmax\nданные\nmulti\ntuple(0,1)\nТеперь, если первая транзакция завершится, вторая будет разбужена, но\nувидит, что блокировка строки никуда не исчезла, и снова встанет в оче-\nредь—наэтотраззатретьейтранзакцией:\n=> COMMIT;\n=> SELECT * FROM locks_accounts WHERE pid = 46058;\npid | locktype | lockid | mode | granted\n−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−+−−−−−−−−−\n46058 | relation | accounts | RowExclusiveLock | t\n46058 | transactionid | 149968 | ExclusiveLock | t\n46058 | transactionid | 149969 | ShareLock | f\n46058 | tuple | accounts(0,1) | ExclusiveLock | t\n(4 rows)\n273",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:52.791545"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 275,
    "chapter": null,
    "section": "13.4 Очередьожидания",
    "text": "Глава13. Блокировкистрок\nИтолькокогдатретьятранзакциязавершится(иеслизаэтовремянепоявят-\nсядругиеразделяемыеблокировки),втораясможетвыполнитьобновление.\n=> COMMIT;\nUPDATE 1\n=> COMMIT;\nПроверкавнешнихключейврядлисоздастпроблемы,посколькуключевые\nполяобычнонеменяются,арежимыKeyShareиNoKeyUpdateсовместимы.\nНо отидеи использования разделяемых режимов блокировок строк в при-\nложениивбольшинствеслучаевлучшеотказаться.\n13.5. Блокировка без ожидания\nОбычнокомандыSQLожидаютосвобождениянеобходимыхимресурсов.Но\nиногдахочетсяотказатьсяотвыполнениякоманды,еслиблокировкунеуда-\nлосьполучитьсразуже.Дляэтоготакиекоманды,какSELECT,LOCKиALTER,\nпозволяютиспользоватьпредложениеNOWAIT.\nЗаблокируемстроку:\n=> BEGIN;\n=> UPDATE accounts SET amount = amount + 100.00 WHERE id = 1;\nКоманда с предложением NOWAIT немедленно завершается ошибкой, если\nресурсоказалсязанят:\n=> SELECT * FROM accounts\nFOR UPDATE NOWAIT;\nERROR: could not obtain lock on row in relation \"accounts\"\nВприкладномкодетакуюошибкуможноперехватитьиобработать.\nУ команд UPDATE и DELETE предложение NOWAIT не предусмотрено. Стан-\nдартный прием состоит в том, чтобы сначала попробовать заблокировать\nстроку командой SELECT FOR UPDATE NOWAIT,а затем—если получилось—\nобновитьилиудалитьее.\n274",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:52.823754"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 276,
    "chapter": null,
    "section": "13.5 Блокировкабезожидания",
    "text": "13.5. Блокировкабезожидания\nВредкихслучаяхбываетудобнопропускатьужезаблокированныестрокии\nсразужеполучатьсвободныедляобработки.ТакработаеткомандаSELECT\nFORспредложениемSKIPLOCKED:\n=> SELECT * FROM accounts\nORDER BY id\nFOR UPDATE SKIP LOCKED\nLIMIT 1;\nid | client | amount\n−−−−+−−−−−−−−+−−−−−−−−\n2 | bob | 200.00\n(1 row)\nВэтомпримерепервая—заблокированная—строкабылапропущена,иза-\nпросзаблокироваливернулвторую.\nТакойподходпозволяеторганизоватьмногопоточнуюобработкуочередей\nилипакетнуюобработкугруппстрок.Нонестоитискатьдляэтойкоманды с.174\nдругие применения — большинство задач решается более простыми сред-\nствами.\nНаконец,естьспособнедопуститьдлительногоожиданияспомощьюуста-\nновкитайм-аута:\n=> SET lock_timeout = '1s';\n=> ALTER TABLE accounts DROP COLUMN amount;\nERROR: canceling statement due to lock timeout\nКоманда завершается ошибкой,поскольку не сумела получитьблокировку\nвтечениеоднойсекунды.Конечно,тайм-аутможноустанавливатьнетолько\nнауровнесеанса,нои,например,дляотдельнойтранзакции.\nЭтот прием позволяет исключить длительную приостановку работы с таб-\nлицей,когдакоманда,требующаяисключительнуюблокировку,выполняет-\nсяподнагрузкой.Приполученииошибкикомандуможноповторитьчерез\nнекотороевремя.\nПараметрlock_timeout отличаетсяотпараметраstatement_timeout тем,чтоограничи-\nваетвремяожиданияблокировки,анеобщеевремявыполненияоператора.\n=> ROLLBACK;\n275",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:52.855191"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 277,
    "chapter": null,
    "section": "13.6 Взаимоблокировки",
    "text": "Глава13. Блокировкистрок\n13.6. Взаимоблокировки\nОднойтранзакциидля продолжения работы можеттребоваться ресурс,за-\nхваченныйдругойтранзакцией;таможетнуждатьсявресурсе,захваченном\nтретьейтранзакцией,итакдалее.Транзакциивыстраиваютсявочередь,ис-\nпользуямеханизмтяжелыхблокировок.\nНо возможна ситуация,когдатранзакции,за которой стоиточередь,пона-\nдобитсяещеодинресурс,иейсамойпотребуетсявстатьзанимвтужесамую\nочередь.Возникнетвзаимоблокировка1:очередьзамкнетсявкругинесмо-\nжетужерассосатьсясамасобой.\nЧтобынагляднопредставитьсебекартинублокировок,построимграфожи-\nданий. Вершины этого графа — выполняющиеся процессы. Его ребра —\nстрелки, проведенные от процессов, ожидающих получения блокировок,\nк процессам, которые удерживают эти блокировки. Если в графе есть кон-\nтур,то есть из какой-либо вершины можно по стрелкам добраться до нее\nжесамой,—значит,произошлавзаимоблокировка.\nНарисункахяпоказываюнепроцессы,атранзакции.Обычнотакаязаменадопустима,\nпосколькуодинпроцессвыполняетоднутранзакцию,аблокировкинезахватываются\nвне транзакций.Но в общем случае нужно говоритьо процессах,посколькуне все\nс.291 блокировкиснимаютсясразупослезавершениятранзакции.\nT3\nT2\nресурс3\nT1\nресурс2\nресурс1\n1 postgrespro.ru/docs/postgresql/17/explicit-locking#LOCKING-DEADLOCKS.\n276",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:52.886859"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 278,
    "chapter": null,
    "section": "13.6 Взаимоблокировки",
    "text": "13.6. Взаимоблокировки\nЕсливзаимоблокировкавозниклаиниодинучастникнеустановилтайм-аут\nожидания,транзакциибудутждатьдругдругабесконечно.Поэтомуменед-\nжерблокировок1автоматическиотслеживаеттакиеситуации.\nОднакопроверкатребуетопределенныхусилий,которыенехочетсяприла-\nгать всякий раз,когда запрашивается новая блокировка (все-таки взаимо-\nблокировкидостаточноредки).Поэтомукогдапроцесспытаетсязахватить\nблокировкуинеможет,онпростовстаетвочередьизасыпает,ноприэтом\nавтоматически устанавливается таймер на время, указанное в параметре\ndeadlock_timeout2.Если ресурс освободится раньше—отлично,на проверке 1s\nудалосьсэкономить.Ноеслипоистеченииdeadlock_timeoutединицвремени\nожиданиепродолжается,ожидающийпроцессбудетразбужениинициирует\nпроверку3.\nПосути,проверкаисостоитвпостроенииграфаожиданийипоискавнем\nконтуров4.Навсевремяпроверкиостанавливаетсялюбаяработастяжелы-\nмиблокировками,чтобы«заморозить»текущеесостояниеграфа.\nЕслипроверканевыявилавзаимоблокировок,процесссновазасыпает;рано\nилипозднодонегодойдеточередь.\nЕслижевзаимоблокировкаобнаружена,однаизтранзакцийпринудительно\nобрывается,чтобы освободитьзахваченные ей блокировки идатьвозмож-\nность остальнымтранзакциям продолжить работу.В большинстве случаев\nпрерываетсятатранзакция,котораяинициировалапроверку,ноесливкон-\nтур входит рабочий процесс автоочистки, не занятый заморозкой в связи\nспереполнениемсчетчикатранзакций,топрерываетсяавтоочисткакакме-\nнееприоритетная.\nВзаимоблокировки обычно означают, что приложение спроектировано\nнеправильно. Обнаружить такие ситуации можно двумя способами: во-\nпервых,будутпоявлятьсясообщениявжурналесервера,аво-вторых,будет\nувеличиватьсязначениеdeadlocksвтаблицеpg_stat_database.\n1 backend/storage/lmgr/README.\n2 backend/storage/lmgr/proc.c,функцияProcSleep.\n3 backend/storage/lmgr/proc.c,функцияCheckDeadLock.\n4 backend/storage/lmgr/deadlock.c.\n277",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:52.924107"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 279,
    "chapter": null,
    "section": "13.6 Взаимоблокировки",
    "text": "Глава13. Блокировкистрок\nВзаимоблокировка при обновлении строк\nХотявконечномсчетеквзаимоблокировкамприводяттяжелыеблокировки,\nнаиболеечастаяпричинаихвозникновения—разныйпорядокблокирова-\nниятабличныхстрок.\nПустьперваятранзакциясобираетсяперенести100₽спервогосчетанавто-\nрой.Дляэтогоонасначалауменьшаетпервыйсчет:\n=> BEGIN;\n=> UPDATE accounts SET amount = amount - 100.00 WHERE id = 1;\nUPDATE 1\nВэтожевремявтораятранзакциясобираетсяперенести10₽совторогосче-\nтанапервый.Онаначинаетстого,чтоуменьшаетвторойсчет:\n=> BEGIN;\n=> UPDATE accounts SET amount = amount - 10.00 WHERE id = 2;\nUPDATE 1\nТеперьперваятранзакцияпытаетсяувеличитьвторойсчет,нообнаружива-\nет,чтостроказаблокирована:\n=> UPDATE accounts SET amount = amount + 100.00 WHERE id = 2;\nЗатем втораятранзакция пытается увеличитьпервый счет,нотоже блоки-\nруется:\n=> UPDATE accounts SET amount = amount + 10.00 WHERE id = 1;\nВозникаетциклическоеожидание,котороеникогданезавершитсясамопо\nсебе.Черезсекундуперваятранзакция,неполучивдоступкресурсу,иници-\nируетпроверкувзаимоблокировкииобрываетсясервером:\nERROR: deadlock detected\nDETAIL: Process 45687 waits for ShareLock on transaction 149975;\nblocked by process 45987.\nProcess 45987 waits for ShareLock on transaction 149974; blocked by\nprocess 45687.\nHINT: See server log for query details.\nCONTEXT: while updating tuple (0,2) in relation \"accounts\"\n278",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:52.959070"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 280,
    "chapter": null,
    "section": "13.6 Взаимоблокировки",
    "text": "13.6. Взаимоблокировки\nТеперь вторая транзакция может продолжить работу.Она пробуждается и\nвыполняетобновление:\nUPDATE 1\nЗавершимтранзакции.\n=> ROLLBACK;\n=> ROLLBACK;\nПравильныйспособвыполнениятакихопераций—блокированиересурсов\nводномитомжепорядке.Например,вданномслучаеможноблокировать\nсчетавпорядкевозрастанияихномеров.\nВзаимоблокировка двух команд UPDATE\nБываютслучаи,когдавзаимоблокировкакажетсяневозможной,новсе-таки\nвозникает.\nУдобноипривычновосприниматькомандыSQLкакатомарные.Новозьмем\nUPDATE:командаблокируетстрокипомереихобновления(аневсесразу),\nиэтопроисходитнеодномоментно.Поэтому,еслиоднакомандаUPDATEоб-\nновляетнесколько строк в одном порядке,адругая—вдругом,они могут\nвзаимозаблокироваться.\nДлявоспроизведениясоздадиминдекспостолбцуamount,построенныйпо\nубываниюсуммы:\n=> CREATE INDEX ON accounts(amount DESC);\nЧтобыуспетьувидетьпроисходящее,напишемзамедляющуюфункцию:\n=> CREATE FUNCTION inc_slow(n numeric)\nRETURNS numeric\nAS $$\nSELECT pg_sleep(1);\nSELECT n + 100.00;\n$$ LANGUAGE sql;\n279",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:52.986889"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 281,
    "chapter": null,
    "section": "13.6 Взаимоблокировки",
    "text": "Глава13. Блокировкистрок\nПервая команда UPDATE будетобновлятьвсютаблицу.План выполнения—\nпоследовательныйпросмотрвсейтаблицы:\n=> EXPLAIN (costs off)\nUPDATE accounts SET amount = inc_slow(amount);\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−\nUpdate on accounts\n−> Seq Scan on accounts\n(2 rows)\nРасположим версии строк на табличной странице в порядке возрастания\nсуммы.Дляэтоговставимихзанововопустошеннуютаблицу:\n=> TRUNCATE accounts;\n=> INSERT INTO accounts(id, client, amount)\nVALUES (1,'alice',100.00),\n(2,'bob',200.00),\n(3,'charlie',300.00);\n=> ANALYZE accounts;\n=> SELECT ctid, * FROM accounts;\nctid | id | client | amount\n−−−−−−−+−−−−+−−−−−−−−−+−−−−−−−−\n(0,1) | 1 | alice | 100.00\n(0,2) | 2 | bob | 200.00\n(0,3) | 3 | charlie | 300.00\n(3 rows)\nПрипоследовательномсканированиистрокибудутобновлятьсявтомжепо-\nс.190 рядке(длябольшихтаблицэтоневсегдаверно).\nЗапускаемобновлениеработать:\n=> UPDATE accounts SET amount = inc_slow(amount);\nАвэтовремявдругомсеансезапретимиспользованиепоследовательного\nсканирования:\n=> SET enable_seqscan = off;\nВ этом случае для следующего оператора UPDATE планировщик решает ис-\nпользоватьсканированиеиндекса:\n280",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.017586"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 282,
    "chapter": null,
    "section": "13.6 Взаимоблокировки",
    "text": "13.6. Взаимоблокировки\n=> EXPLAIN (costs off)\nUPDATE accounts SET amount = inc_slow(amount)\nWHERE amount > 100.00;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nUpdate on accounts\n−> Index Scan using accounts_amount_idx on accounts\nIndex Cond: (amount > 100.00)\n(3 rows)\nПодусловиепопадаютвтораяитретьястроки,причем,посколькуиндекспо-\nстроенпоубываниюсуммы,строкибудутобновлятьсявобратномпорядке.\nЗапускаемследующееобновление:\n=> UPDATE accounts SET amount = inc_slow(amount)\nWHERE amount > 100.00;\nЗаглянув в табличную страницу с помощью расширения pgrowlocks, мы\nувидим,чтопервыйоператоруспелобновитьпервуюстроку(0,1),авторой—\nпоследнюю(0,3):\n=> SELECT locked_row, locker, modes FROM pgrowlocks('accounts');\nlocked_row | locker | modes\n−−−−−−−−−−−−+−−−−−−−−+−−−−−−−−−−−−−−−−−−−\n(0,1) | 149981 | {\"No Key Update\"} первый\n(0,3) | 149982 | {\"No Key Update\"} второй\n(2 rows)\nПроходитеще секунда.Первый оператор обновил вторую строку,а второй\nхотелбыэтосделать,нонеможет.\n=> SELECT locked_row, locker, modes FROM pgrowlocks('accounts');\nlocked_row | locker | modes\n−−−−−−−−−−−−+−−−−−−−−+−−−−−−−−−−−−−−−−−−−\n(0,1) | 149981 | {\"No Key Update\"}\n(0,2) | 149981 | {\"No Key Update\"} первыйуспелраньше\n(0,3) | 149982 | {\"No Key Update\"}\n(3 rows)\nТеперьпервыйоператорхотелбыобновитьпоследнююстрокутаблицы,но\nонаужезаблокированавторым.Произошлавзаимоблокировка.\n281",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.053404"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 283,
    "chapter": null,
    "section": "13.6 Взаимоблокировки",
    "text": "Глава13. Блокировкистрок\nОднаизтранзакцийпрерывается:\nERROR: deadlock detected\nDETAIL: Process 46058 waits for ShareLock on transaction 149981;\nblocked by process 45987.\nProcess 45987 waits for ShareLock on transaction 149982; blocked by\nprocess 46058.\nHINT: See server log for query details.\nCONTEXT: while updating tuple (0,2) in relation \"accounts\"\nАдругаязавершаетвыполнение:\nUPDATE 3\nНесмотрянакажущуюсяневероятность,такиеситуацииреальновозникают\nвнагруженныхсистемах,обновляющихпакетыстрок.\n282",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.067430"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 284,
    "chapter": null,
    "section": "14.1 Блокировки неотношений",
    "text": "14\nБлокировки разных объектов\n14.1. Блокировки неотношений\nКогдатребуетсязаблокироватьресурс,неявляющийсяотношениемвпони-\nманииPostgreSQL,используютсятяжелыеблокировкитипаobject1.Таким\nресурсом может быть почти все, что можно найти в системном каталоге,\nнапример табличные пространства, подписки, схемы, роли, политики, пе-\nречислимыетипыданных.\nНачнемтранзакциюисоздадимвнейтаблицу:\n=> BEGIN;\n=> CREATE TABLE example(n integer);\nТеперьпосмотримнаблокировкинеотношенийвpg_locks:\n=> SELECT database,\n(\nSELECT datname FROM pg_database WHERE oid = database\n) AS dbname,\nclassid,\n(\nSELECT relname FROM pg_class WHERE oid = classid\n) AS classname,\nobjid,\nmode,\ngranted\nFROM pg_locks\nWHERE locktype = 'object'\nAND pid = pg_backend_pid() \\gx\n1 backend/storage/lmgr/lmgr.c,функцииLockDatabaseObjectиLockSharedObject.\n283",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.088582"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 285,
    "chapter": null,
    "section": "14.1 Блокировки неотношений",
    "text": "Глава14. Блокировкиразныхобъектов\n−[ RECORD 1 ]−−−−−−−−−−−−−−\ndatabase | 16391\ndbname | internals\nclassid | 2615\nclassname | pg_namespace\nobjid | 2200\nmode | AccessShareLock\ngranted | t\nБлокируемыйресурсопределяетсяздесьтремяполями:\ndatabase —oidбазыданных,ккоторойотноситсяблокируемыйобъект(или\nноль,еслиэтообщийобъекткластера);\nclassid — oid из pg_class, который соответствует имени таблицы систем-\nногокаталога,определяющейтипресурса;\nobjid —oidизтаблицысистемногокаталога,накоторуюуказалclassid.\nВстолбцеdatabase указанабазаданныхinternals,ккоторойподключен\nсеанс.Столбец classid указывает на таблицу pg_namespace,содержащую\nсхемы.\nТеперьмыможемрасшифроватьobjid:\n=> SELECT nspname FROM pg_namespace WHERE oid = 2200;\nnspname\n−−−−−−−−−\npublic\n(1 row)\nТаким образом,заблокирована схема public,чтобы никто не могудалить\nее,покатранзакцияещенезавершена.\nСоответственно, при удалении объектов захватываются исключительные\nблокировкикаксамогообъекта,такивсех,откоторыхонзависит1.\n=> ROLLBACK;\n1 backend/catalog/dependency.c,функцияperformDeletion.\n284",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.114561"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 286,
    "chapter": null,
    "section": "14.2 Блокировки расширения отношения",
    "text": "14.2. Блокировкирасширенияотношения\n14.2. Блокировки расширения отношения\nКогдачислостроквотношениирастет,PostgreSQLповозможностиисполь-\nзуетдлявставкисвободноеместовимеющихсястраницах.Ноочевидно,что\nвкакой-томоментприходитсядобавлятьиновые,тоестьрасширятьотно-\nшение.Физическистраницыдобавляютсявконецсоответствующегофайла-\nсегмента(иэтоможетпривестиксозданиюновогосегмента).\nЧтобыдвапроцессаненачалидобавлятьстраницыодновременно,этаопе-\nрациязащищенаспециальнойтяжелойблокировкойстипомextend1.Такая\nжеблокировкаиспользуетсяиприочисткеиндексов,чтобыдругиепроцес-\nсынемоглидобавитьновыестраницывовремясканирования.\nБлокировкарасширенияотношенияведетсебянемногоиначе,чемрассмот-\nренныеранее:\n• она снимается сразу по завершении расширения,не дожидаясь конца\nтранзакции;\n• она не может приводить к взаимоблокировкам, поэтому в процедуре\nобнаружениядлянеесделаноисключение:онанепопадаетвграфожи-\nданий.\nТемнеменеепроцедурапроверкивсеравновызывается,еслиожиданиерасширения\nпроисходитдольше,чемустановленопараметромdeadlock_timeout.Этоненормальная\nситуация,ноонаможетвозникнутьприбольшомпотокевставокизбольшогочисла\nпараллельноработающихпроцессов.Вэтомслучаепроверкаможетзапускатьсямно-\nгократно,фактическипарализуянормальнуюработусистемы.\nДляэффективностифайлытаблицрасширяютсяненаоднустраницу,асразу\nна несколько (пропорционально числу ожидающих блокировку процессов,\nно не более чем на 64 страницы за один раз)2. Однако увеличение файлов v.16\nиндексовнаосновеB-деревапроисходиттолькопооднойстранице3.\n1 backend/storage/lmgr/lmgr.c,функцияLockRelationForExtension.\n2 backend/access/heap/hio.c,функцияRelationAddBlocks.\n3 backend/access/nbtree/nbtpage.c,функция_bt_allocbuf.\n285",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.148596"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 287,
    "chapter": null,
    "section": "14.3 Блокировки страниц",
    "text": "Глава14. Блокировкиразныхобъектов\n14.3. Блокировки страниц\nТяжелаяблокировканауровнестраницыстипомpage1применяетсяведин-\nс.598 ственномслучае,связанномсособенностямиGIN-индексов.\nGIN-индексыпозволяютускорятьпоискэлементоввсоставныхзначениях,\nнапримерсловвтекстовыхдокументах.Такиеиндексывпервомприближе-\nнииможнопредставитькакобычноеB-дерево,вкоторомхранятсянесами\nдокументы,а отдельные слова этих документов.Поэтому при добавлении\nновогодокументаиндексприходитсяперестраиватьдовольносильно,вно-\nсявнегокаждоеслово,входящеевдокумент.\nЧтобы улучшить производительность, GIN-индексы предоставляют воз-\nможность отложенной вставки,которая включается параметром хранения\non fastupdate. Новые слова сначала быстро добавляются в неупорядоченный\nсписокожидания(pendinglist),аспустякакое-товремявсенакопившеесяпе-\nремещаетсявосновнуюиндекснуюструктуру.Экономияпроисходитзасчет\nтого, что разные документы с большой вероятностью содержат повторяю-\nщиесяслова.\nЧтобыисключитьперемещениесловизспискаожиданиявосновнойиндекс\nодновременнонесколькимипроцессами,навремяпереносаметастраница\nиндексаблокируетсявисключительномрежиме.Этонемешаетобычному\nиспользованиюиндекса.\nКакиблокировкарасширенияотношения,блокировкастраницыснимается\nсразу по завершении работы (а не в концетранзакции) и не можетприво-\nдитьквзаимоблокировкам.\n14.4. Рекомендательные блокировки\nВ отличие от других тяжелых блокировок (таких как блокировки отноше-\nний),рекомендательные блокировки2 (advisory locks) никогда не устанавли-\nваютсяавтоматически,имиуправляетразработчикприложения.Ихудобно\n1 backend/storage/lmgr/lmgr.c,функцияLockPage.\n2 postgrespro.ru/docs/postgresql/17/explicit-locking#ADVISORY-LOCKS.\n286",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.181046"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 288,
    "chapter": null,
    "section": "14.4 Рекомендательныеблокировки",
    "text": "14.4. Рекомендательныеблокировки\nиспользовать,если приложениюдля каких-то целейтребуется нестандарт-\nнаялогикаблокирования.\nДопустим,имеетсяресурс,несоответствующийникакомуобъектубазыдан-\nных(которыймымоглибызаблокироватькомандамитипаSELECTFORили\nLOCK TABLE). Для блокировки надо сопоставить ресурсу числовой иденти-\nфикатор.Если у ресурса естьуникальное имя,то простой вариант—взять\nхеш-кодотимени:\n=> SELECT hashtext('ресурс1');\nhashtext\n−−−−−−−−−−−\n243773337\n(1 row)\nИмеется целое семейство функций1 для управления рекомендательными\nблокировками.Ихназванияначинаютсянаpg_advisoryисодержатдопол-\nнительныеслова,уточняющиеназначениефункции:\nlock —захватитьблокировку;\ntry —захватитьблокировку,еслиэтоможносделатьбезожидания;\nunlock —освободитьблокировку;\nshare —использоватьразделяемыйрежим(поумолчаниюиспользуетсяис-\nключительныйрежим);\nxact —блокироватьдоконцатранзакции(поумолчанию—доконцасеанса).\nНапример,захватимисключительнуюблокировкудоконцасеанса:\n=> BEGIN;\n=> SELECT pg_advisory_lock(hashtext('ресурс1'));\n=> SELECT locktype, objid, mode, granted\nFROM pg_locks WHERE locktype = 'advisory' AND pid = pg_backend_pid();\nlocktype | objid | mode | granted\n−−−−−−−−−−+−−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−\nadvisory | 243773337 | ExclusiveLock | t\n(1 row)\n1 postgrespro.ru/docs/postgresql/17/functions-admin#FUNCTIONS-ADVISORY-LOCKS.\n287",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.212267"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 289,
    "chapter": null,
    "section": "14.4 Рекомендательныеблокировки",
    "text": "Глава14. Блокировкиразныхобъектов\nЧтобыблокированиедействительноработало,другиепроцессытакжедолж-\nны придерживаться установленного порядка получения доступа к ресурсу.\nЗасоблюдениемэтогоправиладолжноследитьприложение.\nУстановленная блокировка не снимается и после завершения транзакции:\n=> COMMIT;\n=> SELECT locktype, objid, mode, granted\nFROM pg_locks WHERE locktype = 'advisory' AND pid = pg_backend_pid();\nlocktype | objid | mode | granted\n−−−−−−−−−−+−−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−\nadvisory | 243773337 | ExclusiveLock | t\n(1 row)\nПослеокончанияработысресурсомосвобождаемблокировкуявно:\n=> SELECT pg_advisory_unlock(hashtext('ресурс1'));\n14.5. Предикатные блокировки\nТермин предикатная блокировка появился еще при первых попытках реа-\nлизоватьполнуюизоляциюнаосновеблокировок1.Проблема,скоторойто-\nгдастолкнулись,заключаласьвтом,чтодажеблокировкавсехпрочитанных\nи измененных строк недаетполной изоляции: втаблице могутпоявиться\nновыестроки,попадающиеподпрежниеусловияотбора,чтоприводитквоз-\nс.51 никновениюфантомов.\nПоэтому было предложено блокировать не строки, а условия (предикаты).\nПривыполнениизапросаспредикатомa>10блокировкасамогопредика-\nта недастдобавитьвтаблицу новые строки,попадающие под это условие,\nипозволитизбежатьфантомов.Сложностьвтом,чтоприпоявлениизапро-\nсасдругимусловием,напримерa<20,требуетсяопределить,пересекаются\nлиэтиусловия.Вобщемслучаеэтоалгоритмическинеразрешимаязадача;\nнапрактикеееможнорешитьтолькодляпредикатов,имеющихоченьпрос-\nтойвид(каквприведенномпримере).\n1 K.P.Eswaran,J.N.Gray,R.A.Lorie,I.L.Traiger.Thenotionsofconsistencyandpredicatelocksina\ndatabasesystem.\n288",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.249375"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 290,
    "chapter": null,
    "section": "14.5 Предикатныеблокировки",
    "text": "14.5. Предикатныеблокировки\nВ PostgreSQL уровень изоляции Serializable достигается иначе. Для него\nиспользуется протокол сериализуемой изоляции на основе снимков (Seri-\nalizable Snapshot Isolation, SSI)1. Термин предикатная блокировка остался,\nно смысл его в корне изменился. Фактически такие «блокировки» ничего\nне блокируют,а используютсядля отслеживания зависимостей поданным\nмеждутранзакциями.\nДоказано,чтоизоляциянаосновеснимков,реализованнаянауровнеRepeat- с.67\nable Read, допускает аномалию несогласованной записи и аномалию только\nчитающейтранзакции,ноникакиедругиеаномалииневозможны.Двумна-\nзванныманомалиямсоответствуютопределенныезакономерностивграфе\nзависимостей между транзакциями, которые можно обнаруживать, не за-\nтрачиваянаэтослишкоммногоресурсов.\nСложностьвтом,чтонеобходиморазличатьзависимостидвухвидов:\n• однатранзакциячитаетстроку,котораязатемизменяетсядругойтран-\nзакцией(RW-зависимость);\n• одна транзакция изменяет строку, которую затем читает другая тран-\nзакция(WR-зависимость).\nWR-зависимости можно обнаружить, используя уже имеющиеся обычные\nблокировки, а вот RW-зависимости приходится отслеживать дополнитель-\nно с помощью предикатных блокировок. Такое отслеживание включается\nпри выборе уровня изоляции Serializable,и именно поэтому важно,чтобы\nвсе (или по крайней мере все взаимосвязанные)транзакции использовали\nэтотуровень.Есликакая-либотранзакциябудетработатьнадругомуровне,\nона не будетустанавливать(и проверять) предикатные блокировки,и уро-\nвеньSerializableвыродитсядоRepeatableRead.\nЕщеразповторюсь:несмотрянаназвание,предикатныеблокировкиниче-\nгонеблокируют.Вместоэтогопрификсациитранзакциивыполняетсяпро-\nверка,иеслиобнаруживается«нехорошая»структуразависимостей,которая\nможетсвидетельствоватьобаномалии,транзакцияобрывается.\n1 backend/storage/lmgr/README-SSI;\nbackend/storage/lmgr/predicate.c.\n289",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.285729"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 291,
    "chapter": null,
    "section": "14.5 Предикатныеблокировки",
    "text": "Глава14. Блокировкиразныхобъектов\nСоздадимтаблицусданнымиииндекснаней,занимающийнекотороеко-\nличествостраниц(дляэтогоуказанонизкоезначениеfillfactor):\n=> CREATE TABLE pred(n numeric, s text);\n=> INSERT INTO pred(n) SELECT n FROM generate_series(1,10000) n;\n=> CREATE INDEX ON pred(n) WITH (fillfactor = 10);\n=> ANALYZE pred;\nЕслизапросвыполняетсяспомощьюпоследовательногосканированиятаб-\nлицы, предикатная блокировка устанавливается на всю таблицу целиком\n(дажееслиподусловияфильтрациипопадаютневсестроки).\n=> SELECT pg_backend_pid();\npg_backend_pid\n−−−−−−−−−−−−−−−−\n50014\n(1 row)\n=> BEGIN ISOLATION LEVEL SERIALIZABLE;\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT * FROM pred WHERE n > 100;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on pred (actual rows=9900 loops=1)\nFilter: (n > '100'::numeric)\nRows Removed by Filter: 100\n(3 rows)\nХотя предикатные блокировки используют собственную инфраструктуру,\nониотображаютсявпредставленииpg_locksвместестяжелымиблокиров-\nками.Любые предикатные блокировки всегда захватываются в одном спе-\nциальномрежимеSIRead(SerializableIsolationRead):\n=> SELECT relation::regclass, locktype, page, tuple\nFROM pg_locks WHERE mode = 'SIReadLock' AND pid = 50014\nORDER BY 1, 2, 3, 4;\nrelation | locktype | page | tuple\n−−−−−−−−−−+−−−−−−−−−−+−−−−−−+−−−−−−−\npred | relation | |\n(1 row)\n290",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.319608"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 292,
    "chapter": null,
    "section": "14.5 Предикатныеблокировки",
    "text": "14.5. Предикатныеблокировки\n=> ROLLBACK;\nСтоитиметьввиду,чтопредикатныеблокировкиневсегдаснимаютсясразу\nпозавершениитранзакции,ведьонинужны,чтобыотслеживатьзависимо-\nсти между транзакциями. Но в любом случае управление ими происходит\nавтоматически.\nЕсли же запрос выполняется с помощью индексного сканирования,ситуа-\nция меняется влучшую сторону.В случае B-деревадостаточно установить\nпредикатнуюблокировкунапрочитанныетабличныестрокиинапросмот-\nренные листовые страницы индекса.Тем самым «блокируются» не только\nконкретныезначения,ноивесьпрочитанныйдиапазон.\n=> BEGIN ISOLATION LEVEL SERIALIZABLE;\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT * FROM pred WHERE n BETWEEN 1000 AND 1001;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Scan using pred_n_idx on pred (actual rows=2 loops=1)\nIndex Cond: ((n >= '1000'::numeric) AND (n <= '1001'::numeric))\n(2 rows)\n=> SELECT relation::regclass, locktype, page, tuple\nFROM pg_locks WHERE mode = 'SIReadLock' AND pid = 50014\nORDER BY 1, 2, 3, 4;\nrelation | locktype | page | tuple\n−−−−−−−−−−−−+−−−−−−−−−−+−−−−−−+−−−−−−−\npred | tuple | 4 | 96\npred | tuple | 4 | 97\npred_n_idx | page | 28 |\n(3 rows)\nЧислолистовыхстраниц,покрывающихпрочитанныйдиапазон,можетиз-\nмениться,напримериз-зарасщепленияиндексныхстраницпривставкено-\nвыхстрок.Нореализацияэтоучитываетиблокируетновыестраницы:\n=> INSERT INTO pred\nSELECT 1000+(n/1000.0) FROM generate_series(1,999) n;\n291",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.357743"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 293,
    "chapter": null,
    "section": "14.5 Предикатныеблокировки",
    "text": "Глава14. Блокировкиразныхобъектов\n=> SELECT relation::regclass, locktype, page, tuple\nFROM pg_locks WHERE mode = 'SIReadLock' AND pid = 50014\nORDER BY 1, 2, 3, 4;\nrelation | locktype | page | tuple\n−−−−−−−−−−−−+−−−−−−−−−−+−−−−−−+−−−−−−−\npred | tuple | 4 | 96\npred | tuple | 4 | 97\npred_n_idx | page | 28 |\npred_n_idx | page | 266 |\npred_n_idx | page | 267 |\npred_n_idx | page | 268 |\npred_n_idx | page | 269 |\n(7 rows)\nНа каждую прочитанную версию строки создается отдельная блокировка,\nнопотенциальнотакихверсийможетбытьоченьмного.Дляпредикатных\nблокировок используется отдельный пул, память под который выделяет-\nся при старте сервера. Общее количество предикатных блокировок огра-\n64 ниченопроизведениемзначенийпараметровmax_pred_locks_per_transaction\n100 и max_connections (несмотря на названия параметров, учет по отдельным\nтранзакциямневедется).\nПосути,возникаеттажепроблема,чтоисблокировкойстрок,норешается\nонапо-другому:повышениемуровняблокировок1.\nЗначения,прикоторыхповышаетсяуровень,можнозадатьконфигурацион-\nнымипараметрами.Есликоличествоблокировокверсийстрок,относящих-\n2 сякоднойстранице,превышаетmax_pred_locks_per_page,такиеблокировки\nзаменяютсянаоднублокировкууровнястраницы.\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT * FROM pred WHERE n BETWEEN 1000 AND 1002;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Scan using pred_n_idx on pred (actual rows=3 loops=1)\nIndex Cond: ((n >= '1000'::numeric) AND (n <= '1002'::numeric))\n(2 rows)\n1 backend/storage/lmgr/predicate.c,функцияPredicateLockAcquire.\n292",
    "tables": [
      {
        "table_index": 0,
        "rows": 4,
        "cols": 1,
        "content": "266\n267\n268\n269"
      }
    ],
    "extracted_at": "2025-10-02T15:59:53.395783"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 294,
    "chapter": null,
    "section": "14.5 Предикатныеблокировки",
    "text": "14.5. Предикатныеблокировки\nВместотрехблокировоктипаtupleпоявиласьоднатипаpage:\n=> SELECT relation::regclass, locktype, page, tuple\nFROM pg_locks WHERE mode = 'SIReadLock' AND pid = 50014\nORDER BY 1, 2, 3, 4;\nrelation | locktype | page | tuple\n−−−−−−−−−−−−+−−−−−−−−−−+−−−−−−+−−−−−−−\npred | page | 4 |\npred_n_idx | page | 28 |\npred_n_idx | page | 266 |\npred_n_idx | page | 267 |\npred_n_idx | page | 268 |\npred_n_idx | page | 269 |\n(6 rows)\n=> ROLLBACK;\nПотакомужепринципуповышаетсяуровеньстраничныхблокировок.Если\nчислоблокировокстраниц,относящихсякодномуотношению,превышает\nmax_pred_locks_per_relation,такиеблокировкизаменяютсянаоднублокиров- −2\nкууровняотношения.(Приотрицательномзначениивкачествепределабе-\nретсязначениеmax_pred_locks_per_transaction,деленноенамодульзначения 64\nэтогопараметра;такимобразом,поумолчаниюпределсоставит32).\nКонечно, повышение уровня блокировок неизбежно приводит к тому, что\nбольшее число транзакций напрасно завершается ошибкой сериализации.\nПропускная способностьсистемы в итоге снижается.Нужно искатьбаланс\nмежду расходом оперативной памяти на хранение блокировок и произво-\nдительностью.\nПредикатныеблокировкиподдерживаютиндексыследующихтипов:\n• B-деревья;\n• хеш-индексы,GiSTиGIN. v.11\nЕслииспользуетсяиндексныйдоступ,аиндекснеработаетспредикатными\nблокировками,то блокировка накладывается на весь индекс целиком. Ко-\nнечно,этотожеувеличиваетчислолишнихобрывовтранзакций.\n293",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.426787"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 295,
    "chapter": null,
    "section": "14.5 Предикатныеблокировки",
    "text": "Глава14. Блокировкиразныхобъектов\nДляболееэффективнойработынауровнеSerializableследуетявнопомечать\nтолько читающие транзакции как READ ONLY. Если менеджер блокировок\nубедится в невозможности конфликтов читающей транзакции с другими\nтранзакциями1, он сможет освободить уже установленные для нее преди-\nкатные блокировки и не задействовать новые.А если дополнительно объ-\nявитьтакуютранзакцию откладываемой (DEFERRABLE),это позволит избе-\nс.71 жатьаномалиитолькочитающейтранзакции.\n1 backend/storage/lmgr/predicate.c,макросSxactIsROSafe.\n294",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.438869"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 296,
    "chapter": null,
    "section": "15.1 Спин-блокировки",
    "text": "15\nБлокировки в памяти\n15.1. Спин-блокировки\nДлязащитыструктурвразделяемойоперативнойпамятииспользуютсяне\nобычныетяжелые блокировки,а несколько видов болеелегких и менее за-\nтратныхблокировок.\nСамыепростыеизних—спин-блокировки,илиспинлоки(spinlock).Онипред-\nназначены для захвата на очень короткое время (несколько инструкций\nпроцессора)изащищаютотдельныеучасткипамятиотодновременногоиз-\nменения.\nСпин-блокировкиреализуютсянаосновеатомарныхинструкцийпроцессо-\nра,такихкакcompare-and-swap1.Ониподдерживаютединственныйисклю-\nчительный режим.Если блокировка занята,ожидающий процесс выполня-\nетактивноеожидание—командаповторяется(«крутится»вцикле,отсюда\nи название).Если блокировку не удается получитьза определенное время,\nпроцессненадолгоприостанавливаетсяизатемснованачинаетциклактив-\nногоожидания.\nТакаястратегияимеетсмысл,есливероятностьконфликтаоцениваетсякак\nоченьнизкая,ипоэтому,получивотказ,можноожидатьосвобождениябло-\nкировкиужечерезнесколькоинструкций.\nСпин-блокировки не позволяют обнаруживать взаимоблокировки. С при-\nкладной точки зрения остается только знать об их существовании, а весь\nгрузответственностилежитнаразработчикахPostgreSQL.\n1 backend/storage/lmgr/s_lock.c.\n295",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.462728"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 297,
    "chapter": null,
    "section": "15.2 Легкие блокировки",
    "text": "Глава15. Блокировкивпамяти\n15.2. Легкие блокировки\nСледомидуттакназываемыелегкиеблокировки1 (lightweightlocks,lwlocks).\nИхзахватываютнакороткоевремя,котороетребуетсядляработысострук-\nтуройданных(например,схеш-таблицейилиспискомуказателей).Какпра-\nвило,легкиеблокировкиудерживаютсянедолго,новнекоторыхслучаяхони\nзащищаютоперацииввода-вывода,такчто,в принципе,время можетока-\nзатьсяизначительным.\nИмеются два режима: исключительный (для изменения данных) и разде-\nляемый (только для чтения). Поддерживается очередь ожидания, но пока\nблокировкаудерживаетсявразделяемомрежиме,другиечитающиепроцес-\nсы проходят вне очереди.В системах с высокой степенью параллельности\nибольшойнагрузкойэтоможетприводитькнеприятнымэффектам2.\nМеханизм проверки взаимоблокировок не предусмотрен, корректное ис-\nпользованиелегкихблокировок,какиспин-блокировок,остаетсянасовести\nразработчиковPostgreSQL.\n15.3. Примеры\nЧтобы получить некоторое представление о том, как и где используются\nспинлокиилегкиеблокировки,посмотримдвапримераструктурвразделя-\nемойпамяти:буферныйкешибуферыжурналапредзаписи.Яназовудалеко\nневсеблокировки;полнаякартинаслишкомсложнаипредставляетинтерес\nтолькодляразработчиковядра.\nБуферный кеш\nс.179 Чтобы обратиться к хеш-таблице, позволяющей найти буфер в кеше, про-\nцессдолжен захватитьлегкую блокировку BufferMapping: в разделяемом\nрежиме—длячтения,висключительном—дляизменений.\n1 backend/storage/lmgr/lwlock.c.\n2 www.postgresql.org/message-id/flat/CAPpHfdvJhO1qutziOp%3Ddy8TO8Xb4L38BxgKG4RPa1up1Lzh_\nUQ%40mail.gmail.com.\n296",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.493480"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 298,
    "chapter": null,
    "section": "15.3 Примеры",
    "text": "15.3. Примеры\nbufferstrategy\nBufferMapping×128\nсвободныебуферы\n«часоваястрелка»\nзакрепление\nбуфера\nхеш-таблица\nbufferheader\nBufferIO\nBufferContent\nОбращениякхеш-таблицепроисходяточеньактивно,изачастуюэтаблоки-\nровкастановитсяузкимместом.Дляувеличениягранулярностионафакти-\nческиустроенакактранш,состоящийиз128отдельныхлегкихблокировок,\nкаждаяизкоторыхзащищаетсвоючастьхеш-таблицы1.\nВпервыеединичнуюблокировку,защищающуюхеш-таблицу,преобразоваливтранш\nразмером16вверсииPostgreSQL8.2в2006году.Размертраншаувеличилидо128\nспустя 10 летв версии 9.5.На современныхмногоядерныхсистемахпорой и этого\nзначенияоказываетсямало.\nПроцессполучаетдоступкзаголовкубуфера,захватываяспин-блокировку\nbufferheader2(названиеусловное,посколькуспин-блокировкинеимеют\nвнешнихимен).Отдельныеоперации,такиекакувеличениесчетчикаобра-\nщений,могутвыполнятьсяибезявныхблокировокспомощьюатомарных\nинструкцийпроцессора.\nЧтобыпрочитатьсодержимоебуфера,требуетсяблокировка BufferContent.\nОна располагается в заголовке данного буфера3. Обычно эта блокировка\n1 backend/storage/buffer/bufmgr.c;\ninclude/storage/buf_internals.h,макросBufMappingPartitionLock.\n2 backend/storage/buffer/bufmgr.c,функцияLockBufHdr.\n3 include/storage/buf_internals.h.\n297",
    "tables": [
      {
        "table_index": 0,
        "rows": 3,
        "cols": 3,
        "content": "|  | rIO\nB | uffe | rIO\nB | ufferContent |"
      }
    ],
    "extracted_at": "2025-10-02T15:59:53.540876"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 299,
    "chapter": null,
    "section": "15.3 Примеры",
    "text": "Глава15. Блокировкивпамяти\nзахватываетсятольконавремя,необходимоедлячтенияуказателейнавер-\nс.181 сиистрок,адальшедостаточнозащиты,предоставляемой закреплением\nбуфера.ДляизменениясодержимогобуфераблокировкаBufferContentдолж-\nназахватыватьсявисключительномрежиме.\nПри чтении буфера сдиска (или записи надиск) захватываетсятакже бло-\nкировка BufferIO в заголовке буфера; фактически это не настоящая бло-\nкировка,апризнак,играющийеероль1.Блокировкасигнализируетдругим\nпроцессам,заинтересованнымвэтойстранице,чтонеобходимодождаться\nокончанияввода-вывода.\nУказательнасвободныебуферыи«часоваястрелка»механизмавытеснения\nтакжезащищеныоднойобщейспин-блокировкой bufferstrategy2.\nБуферы журнала предзаписи\nWALBufMapping\nWALWrite\nхеш-таблица\nWALInsert×8\ninsertposition\nPrevBytePos\nCurBytePos\nДля журнального кеша тоже используется хеш-таблица, содержащая отоб-\nражениестраницвбуферы.Вотличиеотхеш-таблицыбуферногокешаэта\nтаблица защищена единственной легкой блокировкой WALBufMapping,\nпосколькуразмержурнальногокешагораздоменьше(обычноонравенод-\nномусегменту)иобращениекбуферамболееупорядочено3.\n1 backend/storage/buffer/bufmgr.c,функцияStartBufferIO.\n2 backend/storage/buffer/freelist.c.\n3 backend/access/transam/xlog.c,функцияAdvanceXLInsertBuffer.\n298",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 2,
        "content": "WAL | Write"
      },
      {
        "table_index": 1,
        "rows": 5,
        "cols": 1,
        "content": ""
      }
    ],
    "extracted_at": "2025-10-02T15:59:53.585495"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 300,
    "chapter": null,
    "section": "15.3 Примеры",
    "text": "15.3. Примеры\nЗаписьнадискстраницжурналазащищеналегкойблокировкой WALWrite,\nчтобы в каждый момент времени только один процесс мог выполнять эту\nоперацию.\nЧтобы создать журнальную запись, процесс сначала резервирует место\nвнутристраницыWAL,азатемзаполняетегонеобходимымиданными.Ре-\nзервирование строго упорядочено; процесс должен захватить спин-блоки-\nровку insertposition,защищающуюуказательвставки1.Нозаполнятьуже\nзарезервированное место могут одновременно несколько процессов. Для\nэтогопроцессдолжензахватитьлюбуюизвосьмилегкихблокировок,обра-\nзующихтранш WALInsert2.\nКеш SLRU\nКеши SLRU (simple least-recently-used)3 применяются для страниц таких\nструктур данных, как мультитранзакции (multixact), статусы транзакций\n(clog) или вложенныетранзакции (subtrans).В отличие отбуферного кеша,\nкеш SLRU устроендовольно просто и рассчитан нато,что основной поток\nизмененийичтенийприходитсянапоследниестраницы:например,завер-\nшениетранзакции и проверка ее состояния обычно происходятпримерно\nводновремя,послечегокстатусуэтойтранзакцииужениктонеобращает-\nся.Вытесняютсястраницы,ккоторымдольшевсегонебылообращений. с.86\nBuffer …\nSLRU×N\nКешподеленнабанкипо16страниц;принадлежностьстраницыбанкуопре-\nделяется четырьмя младшими битами ее номера. Такая схема позволяет\nобойтисьбезхеш-таблицы:внутринебольшогобанкадостаточнолинейного\n1 backend/access/transam/xlog.c,функцияReserveXLogInsertLocation.\n2 backend/access/transam/xlog.c,функцияWALInsertLockAcquire.\n3 backend/access/transam/slru.c.\n299",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 2,
        "content": "B | uffer"
      }
    ],
    "extracted_at": "2025-10-02T15:59:53.626162"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 301,
    "chapter": null,
    "section": "15.3 Примеры",
    "text": "Глава15. Блокировкивпамяти\nпоиска. Общий размер кеша, обслуживающего конкретную структуру дан-\nных,настраиваетсяиндивидуально.\nКаждый банк защищен своейлегкой блокировкой SLRU (имятранша за-\nвиситотструктурыданных:например,траншдляclogназываетсяXactSLRU).\nКаждаястраницатакжеимеетсобственнуюлегкуюблокировку Buffer(для\nclog— XactBuffer).Процессы удерживают блокировку банка для получения\nили изменения состояния входящих в него буферов.Получитьблокировку\nбанкатребуетсяидлязахватаблокировкистраницысцельюзаписатьеена\nдиск или прочитать с диска, но на время ввода-вывода блокировка банка\nосвобождается,чтобыпроцессымоглиработатьсдругимистраницамиэто-\nгобанка.\n15.4. Мониторинг ожиданий\nБезусловно,блокировкинеобходимыдлякорректнойработы,ноонимогут\nприводитьикнежелательныможиданиям.Такиеожиданияполезноотсле-\nживать,чтобыразобратьсявпричинеихвозникновения.\nСамыйпростойспособполучитьпредставлениеодлительныхблокировках\noff всистеме—включитьпараметрlog_lock_waits.Вэтомслучаевжурналсооб-\nщений сервера будут попадать подробные сведения о блокировке каждый\n1s раз,когдатранзакцияждетдольше,чемdeadlock_timeout.Этиданныевыво-\nс.276 дятся,когдатранзакциязавершаетпроверкунавзаимоблокировки,отсюда\nиимяпараметра.\nНо гораздо более полную и полезную информацию можно найти в пред-\nставленииpg_stat_activity.Когдапроцесс—системныйилиобслужива-\nющий—неможетвыполнятьсвоюработуиждетчего-либо,этоожидание\nотображается в столбцах wait_event_type (тип ожидания) и wait_event\n(имяконкретногоожидания).\nВсеожиданияможноразделитьнанесколькотипов1.\nБольшуюкатегориюсоставляютожиданияразличныхблокировок:\nLock —тяжелыхблокировок;\n1 postgrespro.ru/docs/postgresql/17/monitoring-stats#WAIT-EVENT-TABLE.\n300",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.664478"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 302,
    "chapter": null,
    "section": "15.4 Мониторингожиданий",
    "text": "15.4. Мониторингожиданий\nLWLock —легкихблокировок;\nBufferPin —закрепленногобуфера.\nКаждый тип конкретизируется именем ожидания. Например, для легких\nблокировокэтобудетимяблокировкиилисоответствующеготранша1.\nНопроцессымогутожидатьидругихсобытий:\nIO —ввода-вывода,когдатребуетсязаписатьилипрочитатьданные;\nClient —данных от клиента (в этом состоянии обычно проводит бóльшую\nчастьвремениpsql);\nIPC —данныхотдругогопроцесса;\nExtension —специфического события,зарегистрированного расширением;\nInjectionPoint —выполнениякодавточкевнедрения(такоесобытиеслужит v.17\nдлятестированияPostgreSQLинепоявляетсяприэксплуатации).\nБываютситуации,когдапроцесспростоневыполняетникакойполезнойра-\nботы.Кэтойкатегорииотносятсяожидания:\nActivity —фоновыхпроцессоввсвоемосновномцикле;\nTimeout —таймера.\nКакправило,такиеожидания«нормальны»инеговорятокаких-либопроб-\nлемах.Однако,например,событие SpinDelayтипаTimeout свидетельствует v.17\nобожиданииспин-блокировки.\nСледуетучитывать,чтопредставлениепоказываеттолькотеожидания,ко-\nторые соответствующим образом обрабатываются в исходном коде2. Если\nимя типа ожидания не определено, процесс не находится ни в одном из-\nвестном ожидании. Такое время следует считать неучтенным, так как это\nне означает со стопроцентной вероятностью,что процесс ничего не ждет;\nнасамомделенеизвестно,чтоименнопроисходитвэтотмомент.\n1 postgrespro.ru/docs/postgresql/17/monitoring-stats#WAIT-EVENT-LWLOCK-TABLE.\n2 include/utils/wait_event.h.\n301",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.693280"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 303,
    "chapter": null,
    "section": "15.4 Мониторингожиданий",
    "text": "Глава15. Блокировкивпамяти\n=> SELECT backend_type, wait_event_type AS event_type, wait_event\nFROM pg_stat_activity;\nbackend_type | event_type | wait_event\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−\nclient backend | |\nautovacuum launcher | Activity | AutovacuumMain\nlogical replication launcher | Activity | LogicalLauncherMain\nwalwriter | Activity | WalWriterMain\nbackground writer | Activity | BgwriterMain\ncheckpointer | Activity | CheckpointerMain\n(6 rows)\nВданномслучаевовремяобращениякпредставлениювсефоновыеслужеб-\nные процессы «бездельничали», а обслуживающий процесс (client back-\nend)былзанятвыполнениемзапросаиничегонеждал.\n15.5. Семплирование\nК сожалению,представление pg_stat_activity показывает информацию\nоб ожиданиях только на текущий момент; статистика не накапливается.\nЕдинственныйспособполучитькартинуожиданийвовремени—семплиро-\nваниесостоянияпредставлениясопределенныминтервалом.\nНеобходимоучитыватьвероятностныйхарактерсемплирования.Чеммень-\nше длится ожидание по отношению к периоду семплирования,тем мень-\nшевероятностьтого,чтоэтоожиданиебудетзафиксировано.Поэтомучем\nбольше период, тем большее количество измерений требуется, чтобы по-\nлучитьдостовернуюкартину.Аповышениечастотысемплированияприво-\nдиткувеличениюнакладныхрасходов.Поэтойжепричинесемплирование\nпрактическибесполезнодляанализакороткоживущихсеансов.\nВстроенных средств для семплирования не предусмотрено, но в качестве\nпримерамывоспользуемсярасширениемpg_wait_sampling1.Необходимо\nпрописать библиотеку в параметр shared_preload_libraries и перезапустить\nсервер.\n1 github.com/postgrespro/pg_wait_sampling.\n302",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.728153"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 304,
    "chapter": null,
    "section": "15.5 Семплирование",
    "text": "15.5. Семплирование\n=> ALTER SYSTEM SET shared_preload_libraries = 'pg_wait_sampling';\npostgres$ pg_ctl restart -l /home/postgres/logfile\nТеперьустановимрасширениевбазеданных:\n=> CREATE EXTENSION pg_wait_sampling;\nРасширениепозволяетпросмотретьисториюожиданий,котораясохраняет-\nся в его кольцевом буфере.Но гораздо интереснее получитьпрофильожи-\nданий—накопленнуюстатистикузавсевремяработы.\nНапример,посмотрим на ожидания,возникающие при работе эталонного\nтестирования.Запустим утилиту pgbench и,пока она работает,определим\nномерпроцесса:\npostgres$ /usr/local/pgsql/bin/pgbench -T 60 internals\n=> SELECT pid FROM pg_stat_activity\nWHERE application_name = 'pgbench';\npid\n−−−−−−−\n51625\n(1 row)\nПрофильожиданийпослеокончанияработы:\n=> SELECT pid, event_type, event, count\nFROM pg_wait_sampling_profile WHERE pid = 51625\nORDER BY count DESC LIMIT 4;\npid | event_type | event | count\n−−−−−−−+−−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−\n51625 | IO | WalSync | 5259\n51625 | | | 518\n51625 | IO | WalWrite | 20\n51625 | LWLock | WALWrite | 3\n(4 rows)\nСустановкамипоумолчанию(параметрpg_wait_sampling.profile_period)зна- 10ms\nчениясохраняются100развсекунду.Поэтому,чтобыоценитьдлительность\nожиданий в секундах,значение count надоделить на 100; общая длитель-\nностьбудетпримерносоответствоватьвремениработыпроцесса. v.1.1.6\n303",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.760904"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 305,
    "chapter": null,
    "section": "15.5 Семплирование",
    "text": "Глава15. Блокировкивпамяти\nv.12 В данном случае бóльшая часть ожиданий приходится на синхронизацию\nжурнальных записей с диском. Этот пример хорошо иллюстрирует поня-\nтие неучтенного времени.Обработкасобытия WALSync появиласьв версии\nPostgreSQL12;наболеераннейверсиипрофильнесодержалбыпервойстро-\nки,хотясамоожидание,разумеется,имелобыместо.\nА вот как будет выглядеть профиль, если искусственно замедлить работу\nфайловойсистемы(например,спомощьюslowfs1),чтобылюбаяоперация\nввода-выводазанимала0,1секунды:\npostgres$ /usr/local/pgsql/bin/pgbench -T 60 internals\n=> SELECT pid FROM pg_stat_activity\nWHERE application_name = 'pgbench';\npid\n−−−−−−−\n52056\n(1 row)\n=> SELECT pid, event_type, event, count\nFROM pg_wait_sampling_profile WHERE pid = 52056\nORDER BY count DESC LIMIT 4;\npid | event_type | event | count\n−−−−−−−+−−−−−−−−−−−−+−−−−−−−−−−−−−−−−+−−−−−−−\n52056 | IO | WalWrite | 5310\n52056 | LWLock | WALWrite | 110\n52056 | IO | WalSync | 99\n52056 | IO | DataFileExtend | 19\n(4 rows)\nТеперь на первое место вышли операции ввода-вывода,главным образом\nсвязанные с записью журнала в синхронном режиме. Поскольку запись\nжурналанадискзащищеналегкойблокировкойWALWrite,соответствующая\nстрокатакжеприсутствуетвпрофиле.\nОчевидно,чтоэтаблокировказапрашиваласьивпредыдущемпримере,но,\nпосколькуееожиданиебылокороче,чемпериодсемплирования,оналибо\nпопала в выборку очень небольшое количество раз,либо не попала вовсе.\nЭтоещеразпоказывает,чтоанализкороткихожиданийтребуетсемплиро-\nваниявтечениедостаточнопродолжительноговремени.\n1 github.com/nirs/slowfs.\n304",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.793705"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 308,
    "chapter": null,
    "section": "16.1 Демонстрационная база данных",
    "text": "16\nЭтапы выполнения запросов\n16.1. Демонстрационная база данных\nВпредыдущихчастяхкнигимыобходилисьпростымитаблицамиснесколь-\nкими строками.Эта и следующая части имеютдело с выполнением запро-\nсов,инампонадобятсявзаимосвязанныетаблицысбольшимколичеством\nстрок.Вместотогочтобыизобретатьдлякаждогопримерасвойнабордан-\nных, я взял готовую демонстрационную базу данных авиаперевозок1. Де-\nмобазасуществуетвнесколькихвариантах; яиспользуюверсиюбольшого\nобъемаот15.08.2017.Дляееустановкинадоразархивироватьфайлскопией\nбазыданных2ивыполнитьеговpsql.\nПри разработке демобазы мы старались сделать схему данных достаточно\nпростой,чтобыеебылолегкопонятьбезособыхпояснений,новтожевремя\nдостаточно сложной, чтобы она позволяла строить осмысленные запросы.\nБаза наполнена реалистичными данными, которые упрощают понимание\nпримеровискоторымиинтересноработать.\nНижеякраткоопишуосновныеобъектыдемобазы,аполноеописаниемож-\nнопрочитатьпоссылкевсноске.\nОсновнойсущностьюявляетсябронирование (таблица bookings).В одно\nбронированиеможновключитьнесколькопассажиров,каждомуизкоторых\nвыдается электронный билет (tickets). Пассажир не является отдельной\nсущностью;будемсчитать,чтовсепассажирыуникальны.\n1 postgrespro.ru/education/demodb.\n2 edu.postgrespro.ru/demo-big-20170815.zip.\n307",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.820883"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 309,
    "chapter": null,
    "section": "16.1 Демонстрационная база данных",
    "text": "Глава16. Этапывыполнениязапросов\nКаждыйбилетвключаетодинилинесколькоперелетов(ticket_flights).\nНесколькоперелетовможетпоявиться,когдавыполняетсяполетспересад-\nками или билет взят «туда и обратно». В схеме данных нет жесткого огра-\nничения,нопредполагается,чтовсебилетыводномбронированииимеют\nодинаковыйнаборперелетов.\nКаждый рейс (flights) следуетиз одного аэропорта (airports) вдругой.\nРейсы с одним номером имеют одинаковые пункты вылета и назначения,\nнобудутотличатьсядатойотправления.\nПредставление routes выделяетизтаблицы рейсов информацию о марш-\nрутах,независящуюотконкретныхдатрейсов.\nПри регистрации на рейс пассажиру выдается посадочный талон (board-\ning_passes), в котором указано место в самолете. Пассажир может заре-\nгистрироватьсятольконатотрейс,которыйестьунеговбилете.Комбина-\nциярейсаиместавсамолетедолжнабытьуникальной,чтобынедопустить\nвыдачудвухпосадочныхталоновнаодноместо.\nКоличество мест (seats) в самолете и их распределение по классам обслу-\nживаниязависитотконкретноймоделисамолета(aircrafts),выполняю-\nщего рейс. Предполагается, что у каждой модели есть только одна компо-\nновкасалона.\nВоднихтаблицахиспользуютсясуррогатныепервичныеключи,вдругих—\nестественные(причемнекоторыеизнихявляютсясоставными).Этосделано\nвдемонстрационныхцеляхинеявляетсяпримеромдляподражания.\nДемобазу можно рассматривать как резервную копию реальной системы:\nонасодержитактуальныеданныенаопределенныймомент.Времяэтогомо-\nментасохраненовфункцииbookings.now.Ееможноиспользоватьвзапро-\nсахтам,гдевобычнойжизнивстретиласьбыфункцияnow.\nНазвания аэропортов, городов и моделей самолетов хранятся в таблицах\nairports_data и aircrafts_data на двух языках, русском и английском.\nВзапросахобычноиспользуютсяпредставленияairportsиaircrafts,по-\nказанные на ER-диаграмме. Они подставляют перевод в зависимости от\nru языка,выбранноговпараметреbookings.lang.Ноименабазовыхтаблицмо-\nгутпоявлятьсявпланахвыполнениязапросов.\n308",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.859965"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 310,
    "chapter": null,
    "section": "16.1 Демонстрационнаябазаданных",
    "text": "16.1. Демонстрационнаябазаданных\n309\nstropriA\nsgnikooB\nedoc_tropria\n#\neman_tropria\n∗\nfer_koob\n#\nytic\n∗\netad_koob\n∗\nsetanidrooc\n∗\ntnuoma_latot\n∗\nenozemit\n∗\nsthgilF\ndi_thgifl\n#\non_thgifl\n∗\nstekciT\nsthgifl_tekciT\nstfarcriA\nerutraped_deludehcs\n∗\non_tekcit\n#\nlavirra_deludehcs\n∗\non_tekcit\n#\nedoc_tfarcria\n#\nfer_koob\n∗\ntropria_erutraped\n∗\ndi_thgifl\n#\nledom\n∗\ndi_regnessap\n∗\ntropria_lavirra\n∗\nsnoitidnoc_eraf\n∗\negnar\n∗\neman_regnessap\n∗\nsutats\n∗\ntnuoma\n∗\natad_tcatnoc\n∘\nedoc_tfarcria\n∗\nerutraped_lautca\n∘\nlavirra_lautca\n∘\nsessap_gnidraoB\nstaeS\non_tekcit\n#\nedoc_tfarcria\n#\ndi_thgifl\n#\non_taes\n#\non_gnidraob\n∗\nsnoitidnoc_eraf\n∗\non_taes\n∗\n1",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 2,
        "content": "staeS | snoitidnoc_eraf\nedoc_tfarcria\non_taes\n# # ∗"
      },
      {
        "table_index": 1,
        "rows": 1,
        "cols": 2,
        "content": "stfarcriA | edoc_tfarcria\nledom egnar\n# ∗ ∗"
      },
      {
        "table_index": 2,
        "rows": 1,
        "cols": 2,
        "content": "sthgilF | erutraped_deludehcs\nlavirra_deludehcs tropria_erutraped erutraped_lautca\ntropria_lavirra edoc_tfarcria lavirra_lautca\ndi_thgifl on_thgifl\nsutats\n# ∗ ∗ ∗ ∗ ∗ ∗ ∗ ∘ ∘"
      },
      {
        "table_index": 3,
        "rows": 1,
        "cols": 2,
        "content": "stropriA | eman_tropria\nedoc_tropria\nsetanidrooc\nenozemit\nytic\n# ∗ ∗ ∗ ∗"
      },
      {
        "table_index": 4,
        "rows": 1,
        "cols": 2,
        "content": "sthgifl_tekciT | snoitidnoc_eraf\non_tekcit\ndi_thgifl tnuoma\n# # ∗ ∗"
      },
      {
        "table_index": 5,
        "rows": 1,
        "cols": 2,
        "content": "sessap_gnidraoB | on_gnidraob\non_tekcit\ndi_thgifl on_taes\n# # ∗ ∗"
      },
      {
        "table_index": 6,
        "rows": 1,
        "cols": 2,
        "content": "stekciT | eman_regnessap\ndi_regnessap atad_tcatnoc\non_tekcit fer_koob\n# ∗ ∗ ∗ ∘"
      },
      {
        "table_index": 7,
        "rows": 1,
        "cols": 2,
        "content": "sgnikooB | tnuoma_latot\netad_koob\nfer_koob\n# ∗ ∗"
      }
    ],
    "extracted_at": "2025-10-02T15:59:53.887125"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 311,
    "chapter": null,
    "section": "16.2 Простой протокол запросов",
    "text": "Глава16. Этапывыполнениязапросов\n16.2. Простой протокол запросов\nПростой вариант клиент-серверного протокола PostgreSQL1 позволяет вы-\nполнитьзапросSQL,отправляясерверуеготекстиполучаявответполный\nрезультатвыполнения,сколькобыстроконнисодержал2.Запрос,поступа-\nющийсерверу,проходитнесколькоэтапов:онразбирается,трансформиру-\nется,планируетсяи,наконец,исполняется.\nРазбор\nВо-первых,текстзапросанеобходиморазобрать3(parse),чтобыпонять,что\nименнотребуетсявыполнить.\nЛексический и синтаксический разборы. Лексический анализатор разбирает\nтекст запроса на лексемы4 (такие как ключевые слова, строковые и число-\nвые литералы), а синтаксический анализатор убеждается,что полученный\nнаборлексемсоответствуетграмматикеязыка5.PostgreSQLиспользуетдля\nразборастандартныеинструменты—утилитыFlexиBison.\nРазобранный запрос представляется в памяти обслуживающего процесса\nввидеабстрактногосинтаксическогодерева.\nВозьмемдляпримераследующийзапрос:\nSELECT schemaname, tablename\nFROM pg_tables\nWHERE tableowner = 'postgres'\nORDER BY tablename;\nЛексическийанализаторвыделитпятьключевыхслов,пятьидентификато-\nров,строковыйлитералитриодносимвольныелексемы(длязапятой,знака\nравенстваиточкисзапятой).Синтаксическийанализаторпостроитизэтих\n1 postgrespro.ru/docs/postgresql/17/protocol.\n2 backend/tcop/postgres.c,функцияexec_simple_query.\n3 postgrespro.ru/docs/postgresql/17/parser-stage;\nbackend/parser/README.\n4 backend/parser/scan.l.\n5 backend/parser/gram.y.\n310",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.918768"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 312,
    "chapter": null,
    "section": "16.2 Простойпротоколзапросов",
    "text": "16.2. Простойпротоколзапросов\nлексем дерево, показанное на рисунке в сильно упрощенном виде. Рядом\nсузламидереваподписанычастизапроса,которыеимсоответствуют:\nSELECT\nQUERY\nTARGETENTRY FROMEXPR SORTGROUPCLAUSE\nschemaname, tablename FROM ORDER BY tablename\nRTE OPEXPR\npg_tables tableowner='postgres'\npg_table WHERE tableowner = 'postgres'\nRTE — неочевидное сокращение от Range Table Entry. Именем range table\nв исходном коде PostgreSQL называютсятаблицы,подзапросы,результаты\nсоединений—инымисловами,наборыстрок,надкоторымиработаютопе-\nраторыSQL1.\nСемантическийразбор. Задачасемантическогоанализа2—определить,есть\nли в базеданныхтаблицы идругие объекты,на которые запрос ссылается\nпоимени,иестьлиупользователяправообращатьсякэтимобъектам.Вся\nнеобходимаядля семантического анализа информация хранится в систем- с.24\nномкаталоге.\nСемантическийанализаторполучаетотсинтаксическогоанализаторадере-\nворазбораиперестраиваетего,дополняяссылкаминаконкретныеобъекты\nбазыданных,указаниемтиповданныхидругойинформацией.\nПолное дерево, построенное в результате разбора, можно получить в жур-\nнале сообщений сервера, установив параметр debug_print_parse, хотя прак-\nтическогосмыславэтомнемного.\n1 include/nodes/parsenodes.h.\n2 backend/parser/analyze.c.\n311",
    "tables": [
      {
        "table_index": 0,
        "rows": 2,
        "cols": 2,
        "content": "QUERY | \n |"
      }
    ],
    "extracted_at": "2025-10-02T15:59:53.948909"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 313,
    "chapter": null,
    "section": "16.2 Простойпротоколзапросов",
    "text": "Глава16. Этапывыполнениязапросов\nТрансформация\nДалеезапросможеттрансформироваться(переписываться)1.\nТрансформациииспользуютсяядромдлянесколькихцелей.Однаизних—\nзаменятьвдереверазбораимяпредставлениянаподдерево,соответствую-\nщеезапросуэтогопредставления.\nДругой пример использования трансформаций ядром системы—реализа-\nцияразграничениядоступанауровнестрок2(row-levelsecurity).\nv.14 На этапе трансформации также происходит преобразование предложений\nSEARCHиCYCLEдлярекурсивныхзапросов3.\nВ примере выше pg_tables —представление; подставив его определение\nвтекстзапроса,мыполучилибы:\nSELECT schemaname, tablename\nFROM (\n-- pg_tables\nSELECT n.nspname AS schemaname,\nc.relname AS tablename,\npg_get_userbyid(c.relowner) AS tableowner,\n...\nFROM pg_class c\nLEFT JOIN pg_namespace n ON n.oid = c.relnamespace\nLEFT JOIN pg_tablespace t ON t.oid = c.reltablespace\nWHERE c.relkind = ANY (ARRAY['r'::char, 'p'::char])\n)\nWHERE tableowner = 'postgres'\nORDER BY tablename;\nНасамомделесервернеработаетстекстовымпредставлениемивыполня-\nетвсеманипуляциитольконаддеревомразбора.Егосостояниепослеэтапа\nтрансформациипоказанонарисункевупрощенномвиде(аполныйможно\nполучить в журнале сообщений, установив параметр debug_print_rewritten).\nДерево разбора отражаетсинтаксическую структуру запроса,но ничего не\nговоритотом,вкакомпорядкебудутвыполненыоперации.\n1 postgrespro.ru/docs/postgresql/17/rule-system.\n2 backend/rewrite/rowsecurity.c.\n3 backend/rewrite/rewriteSearchCycle.c.\n312",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:53.982839"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 314,
    "chapter": null,
    "section": "16.2 Простойпротоколзапросов",
    "text": "16.2. Простойпротоколзапросов\nQUERY\nTARGETENTRY FROMEXPR SORTGROUPCLAUSE\nRTE OPEXPR\npg_tables tableowner='postgres'\nQUERY\nTARGETENTRY FROMEXPR\nOPEXPR\nJOINEXPR\nc.relkind=ANY(ARRAY[...])\nRTE OPEXPR\nJOINEXPR\npg_tablespace t.oid=c.reltablespace\nRTE RTE OPEXPR\npg_class pg_namespace n.oid=c.relnamespace\nPostgreSQL дает пользователю возможность написать свои собственные\nтрансформации.Дляэтогоиспользуетсясистемаправилперезаписи1(rules).\nПоддержка правил была заявлена как одна из целей2 разработки Postgres,так что\nправиласуществовалиещенаэтапеуниверситетскогопроектаизатемнеоднократ-\nнопереосмысливались.Этомощный,носложныйвотладкеипониманиимеханизм.\nПоступалодажепредложениеубратьправилаизPostgreSQL,ноононенашлообщей\nподдержки.В большинстве случаев вместо правил удобнее и безопаснее использо-\nватьтриггеры.\n1 postgrespro.ru/docs/postgresql/17/rules.\n2 M.Stonebraker,L.A.Rowe.TheDesignofPostgres.\n313",
    "tables": [
      {
        "table_index": 0,
        "rows": 5,
        "cols": 2,
        "content": "QUERY | \n | \nFROMEXPR | \n | \nRTE\npg_tables |"
      },
      {
        "table_index": 1,
        "rows": 2,
        "cols": 2,
        "content": "JOINEXPR | \n |"
      }
    ],
    "extracted_at": "2025-10-02T15:59:54.009549"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 315,
    "chapter": null,
    "section": "16.2 Простойпротоколзапросов",
    "text": "Глава16. Этапывыполнениязапросов\nПланирование\nSQL — декларативный язык: запрос определяет, какие данные надо полу-\nчить,нонеговорит,какименноихполучать.\nЛюбой запрос можно выполнить разными способами. Для каждой опера-\nции,представленнойвдереверазбора,могутсуществоватьразныевариан-\nты ее реализации: например,данные из таблицы можно получить,прочи-\nтаввсютаблицу(иотбросивненужное),аможнонайтиподходящиестроки\nс помощью индекса. Наборы строк всегда соединяются попарно, что при-\nводитк огромному количеству вариантов,отличающихся порядком соеди-\nнений.Крометого,существуютразные алгоритмы соединений: например,\nможноперебиратьстрокиодногонабораинаходитьдлянихсоответствиево\nвторомнаборе,аможнопредварительноотсортироватьобанабораизатем\nслить их вместе. Какие-то алгоритмы работают лучше в одних ситуациях,\nкакие-то—вдругих.\nРазницавовременивыполнениямеждунеоптимальнымииоптимальными\nпланами может составлять многие и многие порядки, поэтому планиров-\nщик1, выполняющий оптимизацию разобранного запроса, является одним\nизсамыхсложныхкомпонентовсистемы.\nДерево плана. План выполнения также представляется в виде дерева, но\nегоузлысодержатнелогические,афизическиеоперациинадданными.\nДляисследовательскихцелейполноедеревопланаможнополучитьвжурна-\nлесообщенийсервера,установивпараметрdebug_print_plan.Анапрактике\nтекстовоепредставлениепланавыводиткомандаEXPLAIN2.\nНарисункевыделеныосновныеузлыдерева.Именноониипоказаныниже\nввыводекомандыEXPLAIN.\nс.361 Узлы Seq Scan в плане запроса соответствуютчтениютаблиц,а узел Nested\nс.428 Loop—соединению.\n1 postgrespro.ru/docs/postgresql/17/planner-optimizer.\n2 postgrespro.ru/docs/postgresql/17/using-explain.\n314",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:54.043576"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 316,
    "chapter": null,
    "section": "16.2 Простойпротоколзапросов",
    "text": "16.2. Простойпротоколзапросов\nPLANNEDSTMT\nSORT\nTARGETENTRY NESTLOOP\nSEQSCAN SEQSCAN OPEXPR\nTARGETENTRY\npg_class pg_namespace n.oid=c.relnamespace\nOPEXPR\nrelkind=ANY('r,p'::\"char\"[])ANDpg_get_userbyid(relowner)='postgres'::name\n=> EXPLAIN SELECT schemaname, tablename\nFROM pg_tables\nWHERE tableowner = 'postgres'\nORDER BY tablename;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSort (cost=22.36..22.37 rows=1 width=128)\nSort Key: c.relname\n−> Nested Loop Left Join (cost=0.00..22.35 rows=1 width=128)\nJoin Filter: (n.oid = c.relnamespace)\n−> Seq Scan on pg_class c (cost=0.00..21.26 rows=1 width=72)\nFilter: ((relkind = ANY ('{r,p}'::\"char\"[])) AND (pg_g...\n−> Seq Scan on pg_namespace n (cost=0.00..1.04 rows=4 wid...\n(7 rows)\nПокастоитобратитьвниманиенадвамомента:\n• изтрехтаблицзапросавдеревеосталосьтолькодве:планировщикпо-\nнял,чтооднаизтаблицненужнадляполучениярезультатаиееможно\nудалитьиздереваплана;\n• каждый узел дерева снабжен информацией о предполагаемом числе\nпродуцируемыхстрок(rows)и о стоимости(cost).\n315",
    "tables": [
      {
        "table_index": 0,
        "rows": 3,
        "cols": 2,
        "content": "NESTLOOP | \n | \n | SEQSCAN\npg_namespace"
      }
    ],
    "extracted_at": "2025-10-02T15:59:54.074513"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 317,
    "chapter": null,
    "section": "16.2 Простойпротоколзапросов",
    "text": "Глава16. Этапывыполнениязапросов\nПеребор планов. PostgreSQL использует стоимостной оптимизатор1. Оп-\nтимизатор рассматривает потенциально возможные планы и оценивает\nпредполагаемоеколичестворесурсов,необходимыхдляихвыполнения(та-\nкихкакоперацииввода-выводаитактыпроцессора).Оценкаоптимизатора,\nприведеннаякчисловомувиду,называетсястоимостьюплана.Извсехпро-\nсмотренныхплановвыбираетсяпланснаименьшейстоимостью.\nПроблемавтом,чтоколичествовозможныхплановэкспоненциальнозави-\nситотколичествасоединяемыхтаблиц,ипростоперебратьодинзадругим\nвсе варианты нереальнодажедля относительно простых запросов.Для со-\nкращения пространства переборатрадиционно используется алгоритмди-\nнамического программирования в сочетании с некоторыми эвристиками.\nЭто позволяетувеличитьколичествотаблиц в запросе,для которых может\nбытьнайденоматематическиточноерешениезаприемлемоевремя.\nТочноерешениезадачиоптимизациинегарантирует,чтонайденныйпландействи-\nтельнобудетлучшим,посколькупланировщикиспользуетупрощенныематематиче-\nскиемоделииможетдействоватьнаосновеневполнеточнойвходнойинформации.\nК сожалению,даже алгоритмдинамическогопрограммирования занимает\nслишком много времени и требует слишком много памяти, когда количе-\nство соединений переваливает за десяток. Чтобы еще больше ограничить\nперебор,планировщик может зафиксировать порядок некоторых соедине-\nнийвсоответствииссинтаксическойструктуройзапроса2.\nРассмотримзапрос,вкоторомтаблицыперечисленычереззапятуювпред-\nложенииFROMбезявногоуказанияJOIN:\nSELECT ...\nFROM a, b, c, d, e\nWHERE ...\nДлятакогозапросапланировщикбудетрассматриватьвсевозможныеком-\nбинации попарных соединений.Запросу соответствует следующий (схема-\nтичнопоказанный)фрагментдереваразбора:\n1 backend/optimizer/README.\n2 postgrespro.ru/docs/postgresql/17/explicit-joins.\n316",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:54.112169"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 318,
    "chapter": null,
    "section": "16.2 Простойпротоколзапросов",
    "text": "16.2. Простойпротоколзапросов\nFROMEXPR\nA B C D E\nНиже показан график зависимости объема памяти,необходимогодля пла-\nнирования такого запроса, от количества таблиц в нем (данные получены\nкомандойEXPLAINспараметромMEMORY): v.17\nпамять,\nМбайт\n200\n100\n50\n25 кол-во\nтаблиц\n0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\nВремя планирования также примерно удваивается с каждой добавляемой\nтаблицей.\nВдругом примере соединения имеютопределенную структуру,определяе-\nмуюпредложениемJOIN:\nSELECT ...\nFROM a,\nb JOIN c ON ...,\nd,\ne\nWHERE ...\n317",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:54.139695"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 319,
    "chapter": null,
    "section": "16.2 Простойпротоколзапросов",
    "text": "Глава16. Этапывыполнениязапросов\nДереворазбораотражаетэтуструктуру:\nFROMEXPR\nA JOINEXPR D E\nB C\nОбычнопланировщикуплощаетдеревосоединений,преобразуяегоктому\nжевиду,чтовпервомпримере.Алгоритмрекурсивнообходитдерево,заме-\nняяузлыjoinexprплоскимспискомнижележащихэлементов1.\nНо уплощение выполняется только при условии, что в плоском списке не\n8 появится более join_collapse_limit элементов. В данном примере пять эле-\nментов,поэтомуприлюбыхзначенияхпараметра,меньших5,узелjoinexpr\nуплощатьсянебудет.\nДляпланировщикаэтоозначаетследующее:\n• таблицаBдолжнабытьсоединенастаблицейC(илинаоборот,CсB—на\nпорядоксоединениявпареограничениененакладывается);\n• таблицыA,D,EирезультатсоединенияBсCмогутбытьсоединенывлю-\nбомпорядке.\nПризначениипараметраjoin_collapse_limit=1порядоклюбыхявныхсоеди-\nненийJOINбудетсохранен.\nКроме того, операнды FULL OUTER JOIN никогда не уплощаются, какое бы\nзначениенипринималпараметрjoin_collapse_limit.\n8 Параметр from_collapse_limit точно так же ограничивает уплощение подза-\nпросов.ХотявнешнеподзапросынепохожинасоединенияJOIN,науровне\nдереваразборааналогиястановитсяочевидной.\n1 backend/optimizer/plan/initsplan.c,функцияdeconstruct_jointree.\n318",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:54.168027"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 320,
    "chapter": null,
    "section": "16.2 Простойпротоколзапросов",
    "text": "16.2. Простойпротоколзапросов\nВотпримерзапроса:\nSELECT ...\nFROM a,\n(\nSELECT ...\nFROM b, c\nWHERE ...\n) bc,\nd, e\nWHERE ...\nСоответствующее емудерево соединений показано на рисунке.Вся разни-\nца в том,что вместо узла joinexpr стоит узел fromexpr (отсюда и не совсем\nочевидноеназваниепараметра).\nFROMEXPR\nA FROMEXPR D E\nB C\nТаким образом,количество элементов на одном уровне дерева после про-\nцедурыуплощения,какправило,ограниченозначениямиjoin_collapse_limit 8\nиfrom_collapse_limit. 8\nНиже показан график потребности планировщика в памяти для запроса,\nсодержащего только соединения JOIN. На нем видно, что с увеличением\nколичества таблиц расход ресурсов прибывает экспоненциальными «сту-\nпеньками»,сохраняявцеломлинейныйрост.Начальнаяступенькаобразо-\nвана первыми восьмью (join_collapse_limit) элементами, следующая добав-\nляеткэтойгруппеещесемьэлементовит.д.Такойподходпозволяетпла-\nнировать за разумное время запросы даже с очень большим количеством\nJOIN-соединений.\nДля наглядности пунктиром показан и предыдущий график для запросов\nссоединениямичереззапятую.\n319",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:54.197480"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 321,
    "chapter": null,
    "section": "16.2 Простойпротоколзапросов",
    "text": "Глава16. Этапывыполнениязапросов\nпамять,\nКбайт\n2048\n1792\n1536\n1280\n1024\n768\n512\n256 кол-во\nтаблиц\n0\n4 8 12 16 20 24 28 32\nОстается, однако, проблема запросов с большим количеством соединений\non через запятую. Включенный параметр geqo переключает планировщик на\nиспользование генетического алгоритма1,если число элементовдостигает\n12 значения параметра geqo_threshold.Генетический алгоритм работаетсуще-\nственнобыстрееалгоритмадинамическогопрограммирования(дажесуче-\nтом ограничений join_collapse_limit и from_collapse_limit),но не гарантирует\nнахожденияоптимальногоплана.Длягенетическогоалгоритмаимеетсяце-\nлыйряднастроек2,ноянебудуихрассматривать.\nНиже показан график потребности в памяти для запроса,содержащего со-\nединениячереззапятую,свключеннымпараметромgeqo.Видно,чтокогда\nколичество таблиц доходит до двенадцати (geqo_threshold), необходимость\nвресурсахрезкосокращаетсяидалеерастетлинейноиоченьмедленно.\nДля сравнения пунктиром показан график для запросов с JOIN-соедине-\nниями.\n1 postgrespro.ru/docs/postgresql/17/geqo;\nbackend/optimizer/geqo/geqo_main.c.\n2 postgrespro.ru/docs/postgresql/17/runtime-config-query#RUNTIME-CONFIG-QUERY-GEQO.\n320",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:54.238717"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 322,
    "chapter": null,
    "section": "16.2 Простойпротоколзапросов",
    "text": "16.2. Простойпротоколзапросов\nпамять,\nКбайт\n4608\n4096\n3584\n3072\n2560\n2048\n1536\n1024\n512 кол-во\nтаблиц\n0\n4 8 12 16 20 24 28 32\nНеполноеуплощениедереваилипереключениенагенетическийалгоритм\nприводят к произвольному сокращению рассматриваемых вариантов пла-\nна и, как следствие, к риску упустить оптимальный план и нестабильным\nрезультатам планирования. В таких случаях автору запроса может потре-\nбоватьсявзятьнасебяразбиениезапросананезависимооптимизируемые\nчасти:\n• Общиетабличныевыражениямогутоптимизироватьсяотдельноотос- v.12\nновногозапроса;предложениеMATERIALIZEгарантируетименнотакое\nповедение1.\n• Запросывнутрифункций,написанныхналюбомязыке,кромеSQL,оп-\nтимизируются отдельно от основного запроса. (Тело функции на SQL\nвнекоторыхслучаяхможетподставлятьсявзапрос2.)\n• Установка параметров join_collapse_limit и from_collapse_limit в единицу\nсохраняет порядок соединений,заданный синтаксической структурой\nзапроса(что,скореевсего,слишкомнегибко).\n1 postgrespro.ru/docs/postgresql/17/queries-with.\n2 wiki.postgresql.org/wiki/Inlining_of_SQL_functions.\n321",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:54.276493"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 323,
    "chapter": null,
    "section": "16.2 Простойпротоколзапросов",
    "text": "Глава16. Этапывыполнениязапросов\nВыбор лучшего плана. Для клиента оптимальность плана зависит оттого,\nкакпредполагаетсяиспользоватьрезультат.Еслирезультатнуженцеликом\n(например,для построения отчета), план должен оптимизировать получе-\nниевсехстроквыборки.Ночтобыкакможнобыстрееполучитьпервыестро-\nки(например,длявыводанаэкран),можетпотребоватьсясовершеннодру-\nгойплан.\nPostgreSQLрешаетэтузадачу,вычисляядвекомпонентыстоимости:\n=> EXPLAIN\nSELECT schemaname, tablename\nFROM pg_tables\nWHERE tableowner = 'postgres'\nORDER BY tablename;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSort (cost=22.36..22.37 rows=1 width=128)\nSort Key: c.relname\n−> Nested Loop Left Join (cost=0.00..22.35 rows=1 width=128)\nJoin Filter: (n.oid = c.relnamespace)\n−> Seq Scan on pg_class c (cost=0.00..21.26 rows=1 width=72)\nFilter: ((relkind = ANY ('{r,p}'::\"char\"[])) AND (pg_g...\n−> Seq Scan on pg_namespace n (cost=0.00..1.04 rows=4 wid...\n(7 rows)\nПерваякомпонента(начальнаястоимость,startupcost)представляетзатра-\nты на подготовку к началу выполнения узла, а вторая (полная стоимость,\ntotalcost)—полныезатратынаполучениевсехрезультирующихстрок.\nИногдаможновстретитьутверждение,чтоначальнаястоимость—этостоимостьпо-\nлученияпервойстрокивыборки,ноэтоневполнеточно.\nЧтобы решить, каким планам отдавать предпочтение, планировщик смот-\nрит, используется ли курсор (команда SQL DECLARE или явное объявление\nкурсора в PL/pgSQL)1.Если нет,то предполагается немедленное получение\nвсехрезультирующихстрокклиентом,иизпросмотренныхплановоптими-\nзаторвыбираетпланснаименьшейполнойстоимостью.\nДля запроса, который выполняется с помощью курсора, выбирается план,\nоптимизирующийполучениеневсехстрок,атолькодоли,равнойзначению\n1 backend/optimizer/plan/planner.c,функцияstandard_planner.\n322",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:54.319528"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 324,
    "chapter": null,
    "section": "16.2 Простойпротоколзапросов",
    "text": "16.2. Простойпротоколзапросов\nпараметраcursor_tuple_fraction.Говоряточнее1,выбираетсяпланснаимень- 0.1\nшимзначениемвыражения\nstartupcost+cursor_tuple_fraction(totalcost−startupcost).\nОбщая схема вычисления оценки. Чтобы получить общую оценку плана,\nнеобходимооценитькаждыйизегоузлов.Стоимостьузлазависитоттипа\nэтогоузла(очевидно,чтостоимостьчтенияданныхизтаблицыистоимость\nсортировки отличаются) и от объема обрабатываемых этим узлом данных\n(обычночемменьше,темдешевле).Типузлаизвестен,адляпрогнозаобъ-\nема данных необходимо оценить кардинальность входных наборов (коли-\nчество строк, принимаемых узлом на входе) и селективность узла (долю\nстрок,котораяостанетсяунегонавыходе).Адляэтогонадоиметьстатис-\nтическуюинформациюоданных:размертаблиц,распределениеданныхпо с.333\nстолбцам.\nТаким образом, оптимизация зависит от корректной статистики, собирае-\nмойиобновляемойпроцессомавтоанализа.\nЕсли в каждом узле плана кардинальность оценена правильно, то и стои-\nмость обычно адекватно отражает реальные затраты. Основные ошибки\nпланировщикасвязаныименноснеправильнойоценкойкардинальностии\nселективности.Этоможетпроисходитьиз-занекорректнойилиустаревшей\nстатистики,невозможностиееиспользованияили—вменьшейстепени—\nиз-занесовершенствамоделей,лежащихвосновепланировщика.\nОценка кардинальности. Оценка кардинальности — рекурсивный процесс.\nЧтобыоценитькардинальностьузлаплана,надо:\n1) оценить кардинальность каждого из дочерних узлов и получить коли-\nчествострок,поступающихузлунавход;\n2) оценитьселективностьсамогоузла,тоестьдолювходящихстрок,кото-\nраяостанетсянавыходе.\nПроизведениеодногонадругоеидасткардинальностьузла.\n1 backend/optimizer/util/pathnode.c,функцияcompare_fractional_path_costs.\n323",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:54.353814"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 325,
    "chapter": null,
    "section": "16.2 Простойпротоколзапросов",
    "text": "Глава16. Этапывыполнениязапросов\nСелективностьпредставляетсячисломот0до1.Селективность,близкаякнулю,обыч-\nноназываетсявысокой,аблизкаякединице—низкой.Этоможетпоказатьсянелогич-\nным,носелективностьздесьпонимаетсякакизбирательность:условие,выбирающее\nмалуюдолюстрок,обладаетвысокойселективностью(избирательностью),аусловие,\nоставляющеепочтивсестроки,—низкой.\nСначала рассчитываются кардинальностилистовых узлов,в которых нахо-\nдятсяметодыдоступакданным.Дляэтогоиспользуетсястатистика,вчаст-\nностиобщийразмертаблицы.\nСелективностьусловий,наложенныхнатаблицу,зависитотвидаэтихусло-\nвий.В простейшем случае можно принять за селективность какую-то кон-\nстанту,хотя,конечно,планировщикстараетсяиспользоватьвсюдоступную\nинформациюдляуточненияоценки.Достаточноуметьоцениватьселектив-\nностьпростыхусловий,а селективностьусловий,составленныхспомощью\nлогическихопераций,рассчитываетсяпоформулам1:\nsel =sel sel ;\nxandy x y\nsel =1−(1−sel )(1−sel )=sel +sel −sel sel .\nxory x y x y x y\nс.352 Ксожалению,этиформулыпредполагаютнезависимостьпредикатов x и y.\nВслучаекоррелированныхпредикатовтакаяоценкабудетнеточной.\nДля оценки кардинальности соединений вычисляется кардинальность де-\nкартова произведения (равная произведению кардинальностей двух на-\nборов данных) и оценивается селективность условий соединения,которая\nопятьжезависитоттипаусловий.\nАналогично оценивается кардинальность и других узлов,таких как сорти-\nровкаилиагрегация.\nВажноотметить,чтоошибкарасчетакардинальности,возникшаяв нижних\nузлахплана,распространяетсявыше,приводявитогек невернойоценкеи\nвыбору неудачного плана. Этот неприятный эффект усугубляется тем,что\nпланировщикрасполагаетстатистическойинформациейтолькоотаблицах,\nнонеорезультатахсоединений.\n1 backend/optimizer/path/clausesel.c,функцииclauselist_selectivity_extиclauselist_selectivity_or.\n324",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:54.391293"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 326,
    "chapter": null,
    "section": "16.2 Простойпротоколзапросов",
    "text": "16.2. Простойпротоколзапросов\nОценкастоимости. Процессоценкистоимоститакжерекурсивен.Чтобывы-\nчислить стоимость поддерева плана,надо рассчитать стоимости дочерних\nузлов,сложитьихидобавитьстоимостьсамогоузла.\nСтоимостьработы узла рассчитывается на основе математической модели\nоперации,которуювыполняетданныйузел.Входнымиданнымидляоцен-\nкислужиткардинальность,котораяужерассчитана.Отдельнооцениваются\nначальнаяиполнаястоимости.\nНекоторые операции не требуют никакой подготовки и начинают выпол-\nняться немедленно; у таких узлов начальная стоимость будет равна нулю.\nДругие операции, наоборот, требуют выполнения предварительных дей-\nствий. Например, узел сортировки обычно должен получить от дочернего\nузла все данные,чтобы начать работу.У таких узлов начальная стоимость\nбудетотличнаотнуля—этуценупридетсязаплатить,дажеесливышестоя-\nщемуузлу(иликлиенту)потребуетсятолькооднастрокаизвсейрезульти-\nрующейвыборки.\nСтоимостьотражаетоценку планировщика и,если планировщик ошибает-\nся,можетнекоррелироватьсреальнымвременемвыполнения.Онанужна\nлишьдлятого,чтобыпланировщикмогсравниватьразныепланыодногои\nтогожезапросаводнихитехжеусловиях.Востальныхслучаяхсравнивать\nзапросы (тем более разные) по стоимости—неправильно и бессмысленно.\nНапример,стоимостьмоглабытьнедооцененаиз-занеправильнойстатис-\nтики; после актуализации статистики стоимость может вырасти, но стать\nболееадекватной,ипланнасамомделеулучшится.\nИсполнение\nПлан,построенныйвходеоптимизациизапроса,передаетсянаисполнение1.\nВпамятиобслуживающегопроцессасоздаетсяпортал2—объект,хранящий\nсостояниевыполняющегосязапроса.Состояниепредставляетсяввидедере-\nва,повторяющегоструктурудереваплана.Фактическиузлыдереваработа-\nюткакконвейер,запрашиваяипередаваядругдругустроки.\n1 postgrespro.ru/docs/postgresql/17/executor;\nbackend/executor/README.\n2 backend/utils/mmgr/portalmem.c.\n325",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:54.427481"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 327,
    "chapter": null,
    "section": "16.2 Простойпротоколзапросов",
    "text": "Глава16. Этапывыполнениязапросов\nВыполнениеначинаетсяскорня.Корне-\nвойузел(в примереэтооперациясорти-\nровкиsort)обращаетсязаданнымик до-\nSORT\nчернему узлу. Получив все строки, узел\nвыполняетсортировку и отдаетданные\nвыше,тоестьклиенту.\nNESTLOOP\nНекоторые узлы (как nestloop на рисун-\nке) соединяют данные, полученные из\nSEQSCAN SEQSCAN разных источников.Такой узел обраща-\npg_class pg_namespace ется за данными к двум дочерним уз-\nлам. Получив две строки, удовлетворя-\nющие условию соединения, узел сразу\nжепередаетрезультирующуюстрокуна-\nверх (в отличие от сортировки, которая сначала вынуждена получить все\nстроки).Наэтомвыполнениеузлапрерываетсядотехпор,покавышестоя-\nщийузелнезатребуетследующуюстроку.Такимобразом,еслинужентолько\nчастичныйрезультат(например,из-заограниченияLIMIT),операциянебу-\nдетвыполнятьсяполностью.\nДвалистовыхузладереваseqscanпредставляютобращениектаблицам.Ко-\nгда вышестоящий узел обращается за данными,листовой узел читает оче-\nреднуюстрокуизсоответствующейтаблицыивозвращаетее.\nТакимобразом,частьузловнехранитстроки,анемедленнопередаетихвы-\nшеитутжезабывает,нонекоторымузлам(например,сортировке)требуется\nсохранятьпотенциальнобольшойобъемданных.Дляэтоговпамятиобслу-\n4MB живающего процесса выделяется фрагментразмером work_mem; если этой\nпамятинехватает,данныесбрасываютсянадисквовременныйфайл1.\nВодномпланеможетбытьнесколькоузлов,которымнеобходимохранили-\nщеданных,поэтомудлязапросаможетбытьвыделенонесколькофрагмен-\nтовпамяти,каждыйразмеромwork_mem.Общийобъемоперативнойпамя-\nти,доступныйзапросу,никакнеограничен.\n1 backend/utils/sort/tuplestore.c.\n326",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:54.461950"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 328,
    "chapter": null,
    "section": "16.3 Расширенный протокол запросов",
    "text": "16.3. Расширенныйпротоколзапросов\n16.3. Расширенный протокол запросов\nПрииспользованиипростогопротоколазапросовкаждаякоманда,дажеес-\nлионаповторяетсяизразавраз,проходитвсеперечисленныевышеэтапы:\n1) разбор;\n2) трансформацию;\n3) планирование;\n4) исполнение.\nНонетникакогосмысларазбиратьодинитотжезапросзаново.Нетсмысла\nразбиратьизапросы,отличающиесятолькоконстантами,—структурадере-\nваразборанеизменится.\nЕщеоднонеудобствопростогоспособавыполнениязапросовсостоитвтом,\nчтоклиентполучаетвсювыборкусразу,сколькобыстроконанисодержала.\nВ принципе,оба ограничения можно преодолеть,используя команды SQL:\nпервое — подготавливая запрос командой PREPARE и выполняя его с по-\nмощью EXECUTE, второе — создавая курсор командой DECLARE и извлекая\nстрокиспомощьюFETCH.Новэтомслучаенаклиенталожитсяответствен-\nностьза именование создаваемых объектов,а сервер нагружаетсялишней\nработойпоразборудополнительныхкоманд.\nПоэтому расширенный клиент-серверный протокол позволяет детально\nуправлятьотдельнымиэтапамивыполненияоператоровнауровнекоманд\nсамогопротокола.\nПодготовка\nНаэтапеподготовкизапросразбираетсяитрансформируетсяобычнымоб-\nразом,нополученноедереворазборасохраняетсявпамятиобслуживающе-\nгопроцесса.\nВPostgreSQLотсутствуетглобальныйкешзапросов.Минусытакогорешения\nпонятны — каждый обслуживающий процесс вынужден разбирать все за-\nпросысамостоятельно,дажееслитакойжезапросужебылразобрандругим\n327",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:54.489801"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 329,
    "chapter": null,
    "section": "16.3 Расширенный протокол запросов",
    "text": "Глава16. Этапывыполнениязапросов\nпроцессом. Но есть и плюсы. Кеш в общей памяти легко может стать уз-\nс.295 кимместомиз-занеобходимостиблокировок.Одинклиент,выполняющий\nмножество мелких,но разных запросов (отличающихся,например,только\nконстантами),создаетбольшую нагрузку натакой кеш,что можетсказать-\nсянапроизводительностивсегоэкземпляра.ВPostgreSQLразборзапросов\nвыполняетсялокальноипоэтомуневлияетнадругиепроцессы.\nПри подготовке запроса его можно параметризовать.Вотпростой пример\nнауровнеSQL-команд(повторюсь,чтоэтонесовсемтожесамое,чтопод-\nготовка на уровне команд протокола,но в конечном счете эффекттотже):\n=> PREPARE plane(text) AS\nSELECT * FROM aircrafts WHERE aircraft_code = $1;\nПосмотретьименованныеподготовленныеоператорыможновпредставле-\nнииpg_prepared_statements:\n=> SELECT name, statement, parameter_types\nFROM pg_prepared_statements \\gx\n−[ RECORD 1 ]−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nname | plane\nstatement | PREPARE plane(text) AS +\n| SELECT * FROM aircrafts WHERE aircraft_code = $1;\nparameter_types | {text}\nУвидеть таким образом безымянные операторы (которые использует рас-\nширенныйпротоколилиPL/pgSQL)неполучится.Конечно,сеансудоступны\nтолькособственныеподготовленныеоператоры;заглянутьвпамятьдругого\nсеансаневозможно.\nПривязка параметров\nПеред выполнением подготовленного запроса выполняется привязка фак-\nтическихзначенийпараметров.\n=> EXECUTE plane('733');\naircraft_code | model | range\n−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−\n733 | Боинг 737−300 | 4200\n(1 row)\n328",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:54.526152"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 330,
    "chapter": null,
    "section": "16.3 Расширенныйпротоколзапросов",
    "text": "16.3. Расширенныйпротоколзапросов\nВозможно, чуть более наглядно этап привязки представлен при непосред- v.16\nственномиспользованиирасширенногопротоколавpsql:\n=> \\bind '733'\n=> SELECT * FROM aircrafts WHERE aircraft_code = $1;\naircraft_code | model | range\n−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−\n733 | Боинг 737−300 | 4200\n(1 row)\nПреимущество параметров подготовленных операторов перед конкатена-\nцией литералов со строкой запроса — принципиальная невозможность\nвнедренияSQL-кода,посколькуникакоезначениепараметранесможетиз-\nменить уже построенное дерево разбора. Чтобы достичь того же уровня\nбезопасностибезподготовленныхоператоров,требуетсяаккуратноэкрани-\nроватькаждоезначение,полученноеизненадежногоисточника.\nПланирование и исполнение\nКогдаделодоходитдовыполненияподготовленногооператора,происходит\nпланированиесучетомзначенийфактическихпараметров,послечегоплан\nпередаетсянаисполнение.\nУчитыватьзначенияпараметровважно,посколькуоптимальныепланыдля\nразныхзначениймогутнесовпадать.Например,поискоченьдорогихбро-\nнированийиспользуетиндекс,таккакпланировщикпредполагает,чтопод-\nходящихстрокнеоченьмного:\n=> CREATE INDEX ON bookings(total_amount);\n=> EXPLAIN SELECT * FROM bookings\nWHERE total_amount > 1000000;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on bookings (cost=81.83..9149.93 rows=4310 wid...\nRecheck Cond: (total_amount > '1000000'::numeric)\n−> Bitmap Index Scan on bookings_total_amount_idx (cost=0.00....\nIndex Cond: (total_amount > '1000000'::numeric)\n(4 rows)\n329",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:54.562433"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 331,
    "chapter": null,
    "section": "16.3 Расширенныйпротоколзапросов",
    "text": "Глава16. Этапывыполнениязапросов\nОднакоподследующееусловиепопадаютвообщевсебронирования,поэто-\nмуиндексбесполезен,итаблицапросматриваетсяцеликом:\n=> EXPLAIN SELECT * FROM bookings WHERE total_amount > 100;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on bookings (cost=0.00..39876.88 rows=2111110 width=21)\nFilter: (total_amount > '100'::numeric)\n(2 rows)\nВнекоторыхслучаяхпланировщикзапоминаетнетолькодереворазбора,но\nи план запроса,чтобы не выполнять планирование повторно.Такой план,\nпостроенный без учета значений параметров, называется общим планом\n(вотличиеотчастногоплана,учитывающегофактическиезначения)1.\nОчевидныйслучай,когдаможноперейтинаобщийпланбезущербадляэф-\nфективности,—запросбезпараметров.\nПодготовленныеоператорыспараметрамипервыепятьразвсегдаоптими-\nзируются с учетом фактических значений; при этом вычисляется средняя\nстоимостьчастныхпланов.Начинаясшестогораза,еслиобщийпланоказы-\nваетсявсреднемвыгоднее,чемчастные(сучетомтого,чточастныепланы\nнеобходимокаждыйразстроитьзаново2),планировщикзапоминаетобщий\nпланидальшеиспользуетего,уженеповторяяоптимизацию.\nПодготовленный оператор plane уже был один раз выполнен. После сле-\nдующихтрех выполнений по-прежнему используются частные планы,что\nвиднопозначениюпараметравпланезапроса:\n=> EXECUTE plane('763');\n=> EXECUTE plane('773');\n=> EXPLAIN EXECUTE plane('319');\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on aircrafts_data ml (cost=0.00..1.39 rows=1 width=52)\nFilter: ((aircraft_code)::text = '319'::text)\n(2 rows)\n1 backend/utils/cache/plancache.c,функцияchoose_custom_plan.\n2 backend/utils/cache/plancache.c,функцияcached_plan_cost.\n330",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:54.601178"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 332,
    "chapter": null,
    "section": "16.3 Расширенныйпротоколзапросов",
    "text": "16.3. Расширенныйпротоколзапросов\nПосле еще одного, пятого выполнения планировщик переключится на ис-\nпользование общего плана—он совпадает с частными планами,имеетту\nжестоимость,ноегоможнозапомнитьибольшенетратитьресурсынаоп-\nтимизацию. Команда EXPLAIN показывает теперь не значение параметра,\nаегономер:\n=> EXECUTE plane('320');\n=> EXPLAIN EXECUTE plane('321');\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on aircrafts_data ml (cost=0.00..1.39 rows=1 width=52)\nFilter: ((aircraft_code)::text = $1)\n(2 rows)\nНесложно представить ситуацию, в которой по неудачному стечению об-\nстоятельств первые несколько частных планов будут более дорогими, чем\nобщийплан,апоследующиеоказалисьбыэффективнееобщего—ноплани-\nровщик уже не будет их рассматривать.Крометого,планировщик сравни-\nваетоценкистоимостей,анефактическиересурсы,иэтотакжеможетпри-\nводитькошибкам.\nПоэтомупринеправильномавтоматическомрешенииможнопринудитель- v.12\nновыбратьобщийлибочастныйплан,установивсоответствующеезначение\nпараметраplan_cache_mode: auto\n=> SET plan_cache_mode = 'force_custom_plan';\n=> EXPLAIN EXECUTE plane('CN1');\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on aircrafts_data ml (cost=0.00..1.39 rows=1 width=52)\nFilter: ((aircraft_code)::text = 'CN1'::text)\n(2 rows)\nПредставлениеpg_prepared_statementsпоказываетвтомчислеистатис- v.14\nтикувыборапланов:\n=> SELECT name, generic_plans, custom_plans\nFROM pg_prepared_statements;\n331",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:54.637906"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 333,
    "chapter": null,
    "section": "16.3 Расширенныйпротоколзапросов",
    "text": "Глава16. Этапывыполнениязапросов\nname | generic_plans | custom_plans\n−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−\nplane | 1 | 6\n(1 row)\nПолучение результатов\nРасширенныйпротоколзапросовпозволяетклиентуполучатьневсерезуль-\nтирующиестрокисразу,авыбиратьданныепонесколькустрокзараз.Почти\nтотжеэффектдаетиспользованиеSQL-курсоров(заисключениемлишней\nработы для сервера и того факта,что планировщик оптимизирует получе-\nниеневсейвыборки,апервыхcursor_tuple_fractionстрок):\n=> BEGIN;\n=> DECLARE cur CURSOR FOR\nSELECT * FROM aircrafts ORDER BY aircraft_code;\n=> FETCH 3 FROM cur;\naircraft_code | model | range\n−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−+−−−−−−−\n319 | Аэробус A319−100 | 6700\n320 | Аэробус A320−200 | 5700\n321 | Аэробус A321−200 | 5600\n(3 rows)\n=> FETCH 2 FROM cur;\naircraft_code | model | range\n−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−\n733 | Боинг 737−300 | 4200\n763 | Боинг 767−300 | 7900\n(2 rows)\n=> COMMIT;\nЕслизапросвозвращаетмногострокиклиентунужныонивсе,тоогромное\nзначение для скорости передачи данных играет размер выборки,получае-\nмойзаодинраз.Чембольшевыборка,темменьшекоммуникационныхиз-\nдержек на обращение к серверу и получение ответа.Но с ростом выборки\nэффектсокращенияиздержекуменьшается:разницамеждуоднойстрокой\nидесятьюможетбытьколоссальной,амеждусотнейитысячей—ужепочти\nнезаметной.\n332",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:54.668540"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 334,
    "chapter": null,
    "section": "17.1 Базовая статистика",
    "text": "17\nСтатистика\n17.1. Базовая статистика\nБазовая статистика уровня отношения1 хранится в таблице pg_class си-\nстемногокаталога.Кнейотносятся:\n• числостроквотношении(reltuples);\n• размеротношения,встраницах(relpages);\n• количествостраниц,отмеченныхвкартевидимости(relallvisible). с.32\nВотэтизначениянапримеретаблицыflights:\n=> SELECT reltuples, relpages, relallvisible\nFROM pg_class WHERE relname = 'flights';\nreltuples | relpages | relallvisible\n−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−−\n214867 | 2624 | 2624\n(1 row)\nЗначениеreltuplesиспользуетсявкачествеоценкикардинальности,когда\nзапросненакладываетникакихусловийнастрокитаблицы:\n=> EXPLAIN SELECT * FROM flights;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on flights (cost=0.00..4772.67 rows=214867 width=63)\n(1 row)\n1 postgrespro.ru/docs/postgresql/17/planner-stats.\n333",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:54.690929"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 335,
    "chapter": null,
    "section": "17.1 Базовая статистика",
    "text": "Глава17. Статистика\nс.134 Статистика собирается при анализе,ручном или автоматическом1.Однако\nввиду особой важности базовая статистика рассчитывается также при вы-\nполнении некоторых операций (VACUUM FULL и CLUSTER2, CREATE INDEX и\nREINDEX3)иуточняетсяприочистке4.\n100 Для анализа случайно выбираются 300 × default_statistics_target строк. По-\nсколькуразмервыборки,достаточнойдляпостроениястатистикизаданной\nточности,слабозависитотобъемаанализируемыхданных,размертаблицы\nнеучитывается5.\nСтроки выбираются из такого же количества (300 × default_statistics_target)\nслучайных страниц6. Конечно,для небольшой таблицы количество прочи-\nтанныхстраницивыбранныхдляанализастрокможетоказатьсяменьше.\nПосколькувдостаточнобольшихтаблицахстатистикасобираетсянеповсем\nстрокам,оценкимогутнемногорасходитьсясреальностью.Этонормально:\nстатистика в любом случае не может все время бытьточной, если данные\nизменяются.Длявыбораадекватногопланаобычнодостаточнопопадания\nвпорядок.\nСоздадим копию таблицы flights с отключенной автоочисткой, чтобы\nуправлятьвременемвыполненияанализа:\n=> CREATE TABLE flights_copy(LIKE flights)\nWITH (autovacuum_enabled = false);\nДляновойтаблицыникакойстатистикиещенет:\n=> SELECT reltuples, relpages, relallvisible\nFROM pg_class WHERE relname = 'flights_copy';\nreltuples | relpages | relallvisible\n−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−−\n−1 | 0 | 0\n(1 row)\n1 backend/commands/analyze.c,функцияdo_analyze_rel.\n2 backend/commands/cluster.c,функцияcopy_table_data.\n3 backend/catalog/heap.c,функцияindex_update_stats.\n4 backend/access/heap/vacuumlazy.c,функцияheap_vacuum_rel.\n5 backend/commands/analyze.c,функцияstd_typanalyze.\n6 backend/commands/analyze.c,функцияacquire_sample_rows;\nbackend/utils/misc/sampling.c.\n334",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:54.730029"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 336,
    "chapter": null,
    "section": "17.1 Базоваястатистика",
    "text": "17.1. Базоваястатистика\nЗначениеreltuples = −1позволяетотличитьтаблицу,длякоторойстатис- v.14\nтиканиразунесобиралась,отдействительнопустойтаблицыбезстрок.\nНосбольшойвероятностьювтаблицубудутдобавленыкакие-тострокисра-\nзу после создания. Поэтому, находясь в неведении, планировщик считает,\nчтотаблицазанимает10страниц:\n=> EXPLAIN SELECT * FROM flights_copy;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on flights_copy (cost=0.00..14.10 rows=410 width=170)\n(1 row)\nКоличествострокрассчитываетсяисходяизразмераоднойстроки;онотоб-\nражаетсявпланезапросакакwidth.Обычнодляоценкииспользуетсясред-\nнее значение, вычисляемое при анализе, но в этом случае, поскольку ста-\nтистика отсутствует,размер строки вычисляется приблизительно с учетом\nтиповданныхкаждогоизстолбцов1.\nТеперьскопируемданныеизтаблицыflightsивыполниманализ:\n=> INSERT INTO flights_copy SELECT * FROM flights;\nINSERT 0 214867\n=> ANALYZE flights_copy;\nСейчасстатистикасовпадаетсреальнымколичествомстрок(размертабли-\nцытаков,чтостатистикасобираетсяпополнымданным):\n=> SELECT reltuples, relpages, relallvisible\nFROM pg_class WHERE relname = 'flights_copy';\nreltuples | relpages | relallvisible\n−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−−\n214867 | 2624 | 0\n(1 row)\nЗначение relallvisible используется при оценке стоимости сканирова- с.409\nниятолькоиндекса.Онообновляетсяприочистке:\n=> VACUUM flights_copy;\n1 backend/access/table/tableam.c,функцияtable_block_relation_estimate_size.\n335",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:54.767572"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 337,
    "chapter": null,
    "section": "17.1 Базоваястатистика",
    "text": "Глава17. Статистика\n=> SELECT relallvisible FROM pg_class WHERE relname = 'flights_copy';\nrelallvisible\n−−−−−−−−−−−−−−−\n2624\n(1 row)\nТеперьудвоимколичествострок,несобираястатистику,ипроверимоценку\nкардинальностивпланезапроса:\n=> INSERT INTO flights_copy SELECT * FROM flights;\n=> SELECT count(*) FROM flights_copy;\ncount\n−−−−−−−−\n429734\n(1 row)\n=> EXPLAIN SELECT * FROM flights_copy;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on flights_copy (cost=0.00..9545.34 rows=429734 width=63)\n(1 row)\nОценкаоказаласьточна,несмотрянаустаревшиесведениявpg_class:\n=> SELECT reltuples, relpages\nFROM pg_class WHERE relname = 'flights_copy';\nreltuples | relpages\n−−−−−−−−−−−+−−−−−−−−−−\n214867 | 2624\n(1 row)\nДеловтом,чтопланировщикповышаетточностьоценки,масштабируязна-\nчение reltuples в соответствии с отклонением реального размера файла\nданных от значения relpages1.Поскольку размер файла вырос в два раза\nпо сравнению с relpages, количество строк скорректировалось исходя из\nпредположения,чтоплотностьданныхнеизменилась:\n=> SELECT reltuples *\n(pg_relation_size('flights_copy') / 8192) / relpages AS tuples\nFROM pg_class WHERE relname = 'flights_copy';\n1 backend/access/table/tableam.c,функцияtable_block_relation_estimate_size.\n336",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:54.801325"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 338,
    "chapter": null,
    "section": "17.2 Неопределенные значения",
    "text": "17.2. Неопределенныезначения\ntuples\n−−−−−−−−\n429734\n(1 row)\nКонечно,такая корректировка работаетне всегда (например,если удалить\nчасть строк, оценка не изменится), но в ряде случаев позволяет «продер-\nжаться»доприходаанализаприкрупныхизменениях.\n17.2. Неопределенные значения\nНеопределенные значения, порицаемые теоретиками1, играют тем не ме-\nнее важную роль в реляционных базах данных как удобный способ пред-\nставлениятогофакта,чтозначениенесуществуетилинеизвестно.\nНоособоезначениетребуетиособогоксебеотношения.Помимотеоретиче-\nскихнеувязок,возникаетмножествосугубопрактическихсложностей,ско-\nторымиприходитсясчитаться.Обычнаябулевалогикапревращаетсявтрех-\nзначную, а конструкция NOT IN ведет себя неожиданно. Непонятно, долж-\nнылинеопределенныезначениясчитатьсяменьшеобычныхзначенийили\nбольше (отсюда специальные предложения NULLS FIRST и NULLS LAST для\nсортировки).Нетакужочевидно,должнылинеопределенныезначенияучи-\nтываться в агрегатных функциях. Поскольку, строго говоря, неопределен-\nныезначениявовсенеявляютсязначениями,тодляихучетапланировщику\nнеобходимадополнительнаяинформация.\nПомимосамойпростой,базовойстатистикинауровнеотношений,приана-\nлизесобираетсястатистикадлякаждогостолбцаотношения.Онахранится\nвтаблицесистемногокаталогаpg_statistic2,нозначительнопрощеполь-\nзоватьсяпредставлениемpg_stats,котороепоказываетинформациювбо-\nлееудобномвиде.\nДолянеопределенныхзначенийкакразотноситсякстатистикеуровнястолб-\nца;вычисленноеприанализезначениепоказываетатрибутnull_frac.\n1 citforum.ru/database/articles/evergreen_nulls.\n2 include/catalog/pg_statistic.h.\n337",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:55.209659"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 339,
    "chapter": null,
    "section": "17.2 Неопределенные значения",
    "text": "Глава17. Статистика\nНапример, чтобы найти еще не отправившиеся рейсы, можно воспользо-\nватьсятем,чтовремяихвылетанеопределено:\n=> EXPLAIN SELECT * FROM flights WHERE actual_departure IS NULL;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on flights (cost=0.00..4772.67 rows=16251 width=63)\nFilter: (actual_departure IS NULL)\n(2 rows)\nОценкавычисляетсякакобщеечислострок,умноженноенадолюNULL:\n=> SELECT round(reltuples * s.null_frac) AS rows\nFROM pg_class\nJOIN pg_stats s ON s.tablename = relname\nWHERE s.tablename = 'flights'\nAND s.attname = 'actual_departure';\nrows\n−−−−−−−\n16251\n(1 row)\nТочноезначение:\n=> SELECT count(*) FROM flights WHERE actual_departure IS NULL;\ncount\n−−−−−−−\n16348\n(1 row)\n17.3. Уникальные значения\nПолеn_distinctпредставленияpg_statsпоказываетколичествоуникаль-\nныхзначенийвстолбце.\nЕслизначениеn_distinctотрицательно,томодульэтогочисларавеннеко-\nличеству,адолеуникальныхзначений.Например,−1означает,чтовсезна-\nчениявстолбцеуникальны,а−3говоритотом,чтокаждоезначениевсред-\nнем встречается втрех строках.Анализатор используетдоли,когда вычис-\nленное при анализе количество уникальных значений превышает 10% от\n338",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:55.241939"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 340,
    "chapter": null,
    "section": "17.3 Уникальныезначения",
    "text": "17.3. Уникальныезначения\nnull_frac\nn_distinct\nзначения\nобщегоколичествастрок;вэтомслучаепропорция,скореевсего,сохранит-\nсяипридальнейшемизмененииданных1.\nКоличество уникальных значений используется во всех случаях, которые\nпредполагаютравномерноераспределениеданных.Например,приоценке\nкардинальностиусловия«столбец=выражение»,когдазначениевыражения\nнеизвестнонаэтапепланирования,считается,чтовыражениеможетприни-\nматьлюбоеизвозможныхзначенийстолбцасравнойвероятностью2:\n=> EXPLAIN SELECT *\nFROM flights\nWHERE departure_airport = (\nSELECT airport_code FROM airports WHERE city = 'Санкт-Петербург'\n);\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on flights (cost=30.56..5340.40 rows=2066 width=63)\nFilter: (departure_airport = (InitPlan 1).col1)\nInitPlan 1\n−> Seq Scan on airports_data ml (cost=0.00..30.56 rows=1 wi...\nFilter: ((city −>> lang()) = 'Санкт−Петербург'::text)\n(5 rows)\n1 backend/commands/analyze.c,функцияcompute_distinct_stats.\n2 backend/utils/adt/selfuncs.c,функцияvar_eq_non_const.\n339\nатотсач",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 19,
        "content": "|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T15:59:55.274689"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 341,
    "chapter": null,
    "section": "17.3 Уникальныезначения",
    "text": "Глава17. Статистика\nЗдесьузелпланаInitPlanвыполняетсяодинраз,ивычисленноезначениеис-\nпользуетсявосновномплане.\n=> SELECT round(reltuples / s.n_distinct) AS rows\nFROM pg_class\nJOIN pg_stats s ON s.tablename = relname\nWHERE s.tablename = 'flights'\nAND s.attname = 'departure_airport';\nrows\n−−−−−−\n2066\n(1 row)\nЕсликоличествоуникальныхзначенийвычисляетсяневерно(из-заограни-\nченности выборки,по которой проводится анализ),это количество можно\nуказатьдлястолбцаявно:\nALTER TABLE ... ALTER COLUMN ... SET (n_distinct = ...);\nЕслибывседанныебыливсегдараспределеныравномерно,этойинформа-\nции (дополненной минимальным и максимальным значениями) было бы\nдостаточно. Но при неравномерном распределении, которое на практике\nвстречаетсягораздочаще,такаяоценканебудетточна:\n=> SELECT min(cnt), round(avg(cnt)) avg, max(cnt) FROM (\nSELECT departure_airport, count(*) cnt\nFROM flights GROUP BY departure_airport\n) t;\nmin | avg | max\n−−−−−+−−−−−−+−−−−−−−\n113 | 2066 | 20875\n(1 row)\n17.4. Наиболее частые значения\nДляуточненияоценкипринеравномерномраспределениисобираетсяста-\nтистикапонаиболеечастовстречающимсязначениям(mostcommonvalues,\nMCV)ичастотеихпоявления.Представлениеpg_statsпоказываетдваэтих\nмассивавстолбцахmost_common_valsиmost_common_freqs.\n340",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:55.310058"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 342,
    "chapter": null,
    "section": "17.4 Наиболеечастыезначения",
    "text": "17.4. Наиболеечастыезначения\n[most_common_vals]\nnull_frac\nзначения\nВот пример такой статистики по частоте использования различных типов\nсамолетов:\n=> SELECT most_common_vals AS mcv,\nleft(most_common_freqs::text,60) || '...' AS mcf\nFROM pg_stats\nWHERE tablename = 'flights' AND attname = 'aircraft_code' \\gx\n−[ RECORD 1 ]−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nmcv | {CN1,CR2,SU9,321,733,319,763,773}\nmcf | {0.278,0.27163333,0.25873333,0.059766665,0.039566666,0.03756...\nДляоценкиселективностиусловия«столбец=значение»достаточнонайти\nзначениевмассивеmost_common_valsивзятьчастотуизэлементамассива\nmost_common_freqsстемженомером1:\n=> EXPLAIN SELECT * FROM flights WHERE aircraft_code = '733';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on flights (cost=0.00..5309.84 rows=8502 width=63)\nFilter: (aircraft_code = '733'::bpchar)\n(2 rows)\n1 backend/utils/adt/selfuncs.c,функцияvar_eq_const.\n341\nатотсач\n]sqerf_nommoc_tsom[",
    "tables": [
      {
        "table_index": 0,
        "rows": 14,
        "cols": 19,
        "content": "|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T15:59:55.346968"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 343,
    "chapter": null,
    "section": "17.4 Наиболеечастыезначения",
    "text": "Глава17. Статистика\n=> SELECT round(reltuples * s.most_common_freqs[\narray_position((s.most_common_vals::text::text[]),'733')\n])\nFROM pg_class\nJOIN pg_stats s ON s.tablename = relname\nWHERE s.tablename = 'flights'\nAND s.attname = 'aircraft_code';\nround\n−−−−−−−\n8502\n(1 row)\nОчевидно,чтотакаяоценкабудетблизкакточномузначению:\n=> SELECT count(*) FROM flights WHERE aircraft_code = '733';\ncount\n−−−−−−−\n8263\n(1 row)\nСписок частых значений используется и для оценки селективности усло-\nвийснеравенствами.Например,дляусловиявида«столбец<значение»надо\nнайти в most_common_vals все значения,меньшие искомого,и просумми-\nроватьчастотыизmost_common_freqs1.\nСтатистика частых значений отлично работает, когда количество различ-\nныхзначенийнеоченьвелико.Максимальныйразмермассивовопределя-\n100 етсятем же параметром default_statistics_target,который ограничиваетраз-\nмерслучайнойвыборкистрокдляанализа.\nВнекоторыхслучаяхможетиметьсмыслувеличитьзначениепараметрапо\nумолчанию,чтобырасширитьсписокчастыхзначенийиповыситьточность\nоценок.Этоможносделатьнауровнеотдельногостолбца:\nALTER TABLE ... ALTER COLUMN ... SET STATISTICS ...;\nПриэтомувеличитсяиразмервыборки,нотолькодляуказаннойтаблицы.\nПосколькувмассивечастыхзначенийсохраняютсясамизначения,массив\nможет занимать довольно много места. Чтобы чрезмерно не увеличивать\n1 backend/utils/adt/selfuncs.c,функцияscalarineqsel.\n342",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:55.381023"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 344,
    "chapter": null,
    "section": "17.5 Гистограмма",
    "text": "17.5. Гистограмма\npg_statisticиненагружатьпланировщикбесполезнойработой,изанали-\nзаистатистикиисключаютсязначения,размеркоторыхпревышает1Кбайт.\nКтомужетакиебольшиезначения,скореевсего,уникальныипоэтомувсе\nравнонедолжныпопастьвmost_common_vals.\n17.5. Гистограмма\nКогдачислоразличныхзначенийслишкомвелико,чтобызаписатьихвмас-\nсив,напомощьприходитгистограмма.Гистограммасостоитизнескольких\nкорзин,вкоторыепомещаютсязначения.Количествокорзинограниченовсе\nтемжепараметромdefault_statistics_target.\nШиринакорзинвыбираетсятак,чтобывкаждуюпопалопримерноодинако-\nвое количество значений (на рисунке этому свойству соответствуетодина-\nковаяплощадьбольшихзаштрихованныхпрямоугольников).Приэтомучи-\nтываютсятолькотезначения,которыенепопаливсписокнаиболеечастых.\nПритакомпостроениисуммарнаячастотазначенийодной(любой)корзины\nравна 1 .\nчислокорзин\n[mcv]\nnull_frac\nзначения\n[histogram_bounds]\n343\nатотсач\n]fcm[",
    "tables": [
      {
        "table_index": 0,
        "rows": 7,
        "cols": 8,
        "content": "|  |  |  |  |  |  | \n |  |  |  |  |  |  | \n |  |  |  |  |  |  | \n |  |  |  |  |  |  | \n |  |  |  |  |  |  | \n |  |  |  |  |  |  | \n |  |  |  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T15:59:55.406369"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 345,
    "chapter": null,
    "section": "17.5 Гистограмма",
    "text": "Глава17. Статистика\nГистограмма хранится в поле histogram_bounds представления pg_stats\nкакмассивзначений,ограничивающихкорзины:\n=> SELECT left(histogram_bounds::text,60) || '...' AS hist_bounds\nFROM pg_stats s\nWHERE s.tablename = 'boarding_passes' AND s.attname = 'seat_no';\nhist_bounds\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n{10B,10D,10D,10E,10F,11B,11E,11G,12B,12K,13H,14G,15B,16B,17B...\n(1 row)\nГистограммаиспользуется,вчастности,дляоценкиселективностиоперато-\nров«больше»или«меньше»вместесоспискомнаиболеечастыхзначений1.\nРассмотримпример—количествопосадочныхталонов,выданныхнадаль-\nниеряды:\n=> EXPLAIN SELECT * FROM boarding_passes WHERE seat_no > '30C';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on boarding_passes (cost=0.00..157381.25 rows=2981982 ...\nFilter: ((seat_no)::text > '30C'::text)\n(2 rows)\nНомерместаспециальновыбрантак,чтоонлежитточнонаграницекорзин\nгистограммы.\nОценкаселективноститакогоусловиябудетравна N ,гдеN —коли-\nчислокорзин\nчествокорзин,значениявкоторыхудовлетворяютусловию(тоестьнаходят-\nся справа отзначения).При этом необходимо учесть,что наиболее частые\nзначенияневходятвгистограмму.\nВообщеговоря,неопределенныезначениятоженевходятвгистограмму,но\nвстолбцеseat_noихнеможетбыть:\n=> SELECT s.null_frac FROM pg_stats s\nWHERE s.tablename = 'boarding_passes' AND s.attname = 'seat_no';\nnull_frac\n−−−−−−−−−−−\n0\n(1 row)\n1 backend/utils/adt/selfuncs.c,функцияineq_histogram_selectivity.\n344",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:55.445475"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 346,
    "chapter": null,
    "section": "17.5 Гистограмма",
    "text": "17.5. Гистограмма\nnull_frac\nx значения\nСначала найдем долю наиболее частых значений,которые удовлетворяют\nусловию:\n=> SELECT sum(s.most_common_freqs[\narray_position((s.most_common_vals::text::text[]),v)\n])\nFROM pg_stats s, unnest(s.most_common_vals::text::text[]) v\nWHERE s.tablename = 'boarding_passes' AND s.attname = 'seat_no'\nAND v > '30C';\nsum\n−−−−−−−−−−−−\n0.22866668\n(1 row)\nОбщаядолянаиболеечастыхзначений(неучитываемаягистограммой)со-\nставляет:\n=> SELECT sum(s.most_common_freqs[\narray_position((s.most_common_vals::text::text[]),v)\n])\nFROM pg_stats s, unnest(s.most_common_vals::text::text[]) v\nWHERE s.tablename = 'boarding_passes' AND s.attname = 'seat_no';\n345\nатотсач",
    "tables": [
      {
        "table_index": 0,
        "rows": 7,
        "cols": 8,
        "content": "|  |  |  |  |  |  | \n |  |  |  |  |  |  | \n |  |  |  |  |  |  | \n |  |  |  |  |  |  | \n |  |  |  |  |  |  | \n |  |  |  |  |  |  | \n |  |  |  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T15:59:55.470927"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 347,
    "chapter": null,
    "section": "0.22866668 -- вклад частых значений",
    "text": "Глава17. Статистика\nsum\n−−−−−−−−−−−\n0.6792334\n(1 row)\nПоскольку интервал занимаетровное количество корзин гистограммы (из\n100возможных),получаемследующуюоценку:\n=> SELECT round( reltuples * (\n0.22866668 -- вклад частых значений\n+ (1 - 0.6792334 - 0) * (46 / 100.0) -- вклад гистограммы\n))\nFROM pg_class WHERE relname = 'boarding_passes';\nround\n−−−−−−−−−\n2981982\n(1 row)\nВобщемслучае,когдазначениележитненагранице,спомощьюлинейной\nинтерполяцииучитываетсядолякорзины,вкоторойнаходитсязначение.\nТочноезначениесоставляет:\n=> SELECT count(*) FROM boarding_passes WHERE seat_no > '30C';\ncount\n−−−−−−−−−\n2986429\n(1 row)\nУвеличениепараметраdefault_statistics_targetможетулучшитьоценку,одна-\nко,какпоказываетпример,всочетаниисоспискомнаиболеечастыхзначе-\nнийгистограммаобычнодаетхорошийрезультатдажеприбольшомколи-\nчествеуникальныхзначенийвстолбце:\n=> SELECT n_distinct FROM pg_stats\nWHERE tablename = 'boarding_passes' AND attname = 'seat_no';\nn_distinct\n−−−−−−−−−−−−\n461\n(1 row)\nУвеличение точности оценки имеет смысл только в том случае, когда оно\nприводиткпостроениюболеекачественногоплана.Бездумноеувеличение\n346",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:55.500280"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 348,
    "chapter": null,
    "section": "17.6 Статистика для нескалярных типов данных",
    "text": "17.6. Статистикадлянескалярныхтиповданных\nпараметра можетзамедлитьвыполнение анализа и работу планировщика,\nничегонеулучшив.Сдругойстороны,уменьшениепараметра(вплотьдону-\nля)можетускоритьанализипланирование,номожетипослужитьпричиной\nплохихпланов.Такая«экономия»обычнонеоправданна.\n17.6. Статистика для нескалярных типов данных\nДлянескалярныхтиповданныхможетсобиратьсястатистикапораспреде-\nлениюнетолькосамихзначений,ноиэлементов,изкоторыхэтизначения\nсостоят.Этопозволяетболееточнопланироватьзапросысучастиемстолб-\nцовневпервойнормальнойформе.\n• Массивыmost_common_elemsиmost_common_elem_freqsпоказывают\nсписокнаиболеечастыхэлементовиихчастоты.\nСтатистика собирается и используется при оценке селективности для\nмассивов1итипаданныхtsvector2.\n• Массив elem_count_histogram показывает гистограмму количества\nуникальныхэлементоввзначении.\nСтатистикасобираетсяииспользуетсяприоценкеселективноститоль-\nкодлямассивов.\n• Для непустых диапазонов собираются гистограммы распределения\nнижнихиверхнихграниц(массивrange_bounds_histogram)идлины v.17\n(массив range_length_histogram). Отдельно отмечается доля пустых\nдиапазонов(столбецrange_empty_frac).Этиданныеиспользуютсядля\nоценки селективности различных операций с диапазоннымитипами3.\nТакаяжестатистикаиспользуетсяидлямногодиапазонныхтипов4. v.14\n1 postgrespro.ru/docs/postgresql/17/arrays;\nbackend/utils/adt/array_typanalyze.c;\nbackend/utils/adt/array_selfuncs.c.\n2 postgrespro.ru/docs/postgresql/17/datatype-textsearch;\nbackend/tsearch/ts_typanalyze.c;\nbackend/tsearch/ts_selfuncs.c.\n3 postgrespro.ru/docs/postgresql/17/rangetypes;\nbackend/utils/adt/rangetypes_typanalyze.c;\nbackend/utils/adt/rangetypes_selfuncs.c.\n4 backend/utils/adt/multirangetypes_selfuncs.c.\n347",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:55.536465"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 349,
    "chapter": null,
    "section": "17.7 Средний размер поля",
    "text": "Глава17. Статистика\n17.7. Средний размер поля\nПоле avg_width представления pg_stats показываетсредний размер зна-\nченийвстолбце.Конечно,длятакихтипов,какinteger илиchar(3),этот\nпоказательвсегдаодинаков,нодлятиповданныхспеременнойдлиной,та-\nкихкакtext,онможетсильноотличатьсяотстолбцакстолбцу:\n=> SELECT attname, avg_width FROM pg_stats\nWHERE (tablename, attname) IN ( VALUES\n('tickets', 'passenger_name'), ('ticket_flights','fare_conditions')\n);\nattname | avg_width\n−−−−−−−−−−−−−−−−−+−−−−−−−−−−−\nfare_conditions | 8\npassenger_name | 16\n(2 rows)\nЭтастатистикаиспользуетсядляоценкиобъемапамяти,необходимойнеко-\nторымоперациям,напримерсортировкеилихешированию.\n17.8. Корреляция\nПоле correlation представления pg_stats показывает корреляцию меж-\nду физическим расположением данных и логическим порядком в смысле\nс.526 операций сравнения.Если значения хранятся строго по возрастанию,кор-\nреляциябудетблизкакединице;еслипоубыванию—кминусединице.Чем\nболеехаотичнорасположеныданныенадиске,темближезначениекнулю.\n=> SELECT attname, correlation\nFROM pg_stats WHERE tablename = 'airports_data'\nORDER BY abs(correlation) DESC;\nattname | correlation\n−−−−−−−−−−−−−−+−−−−−−−−−−−−−\ncoordinates |\nairport_code | −0.21120238\ncity | −0.1970127\nairport_name | −0.18223621\ntimezone | 0.17961165\n(5 rows)\n348",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:55.568695"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 350,
    "chapter": null,
    "section": "17.9 Статистика по выражению",
    "text": "17.9. Статистикаповыражению\nОбратитевнимание,чтодлястолбцаcoordinatesэтастатистиканесобира-\nется,посколькудлятипаданныхpointнеопределеныоператоры«больше»\nи«меньше».\nКорреляцияиспользуетсядляоценкистоимостииндексногосканирования. с.403\n17.9. Статистика по выражению\nОбычностатистикапостолбцуможетиспользоваться,толькоесливопера-\nциисравненияслеваилисправаотоператорафигурируетсамстолбец,ане\nвыражение. Например, планировщик не знает, как изменится статистика\nпослевычисленияфункцииотстолбца,ипоэтомудляусловия«вызов-функ-\nции=константа»всегдаиспользуетфиксированнуюоценкув0,5%1:\n=> EXPLAIN SELECT * FROM flights\nWHERE extract(\nmonth FROM scheduled_departure AT TIME ZONE 'Europe/Moscow'\n) = 1;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on flights (cost=0.00..6384.17 rows=1074 width=63)\nFilter: (EXTRACT(month FROM (scheduled_departure AT TIME ZONE ...\n(2 rows)\n=> SELECT round(reltuples * 0.005)\nFROM pg_class WHERE relname = 'flights';\nround\n−−−−−−−\n1074\n(1 row)\nПланировщикунеизвестнасемантикадажестандартныхфункций.Хотянам\nиз общих соображений понятно,что рейсов,совершенных в январе,будет\nпримерно 1 от общего количества,то есть на порядок больше спрогнози-\n12\nрованногозначения.\nЧтобыисправитьситуацию,надособратьстатистикунепостолбцутаблицы,\nаповыражению.Этоможносделатьдвумяспособами.\n1 backend/utils/adt/selfuncs.c,функцияeqsel.\n349",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:55.601173"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 351,
    "chapter": null,
    "section": "17.9 Статистика по выражению",
    "text": "Глава17. Статистика\nv.14 Расширенная статистика по выражению\nПервыйвариант—использоватьрасширеннуюстатистику1повыражению.\nТакая статистика не собирается автоматически; необходимо вручную со-\nздатьобъектбазыданныхкомандойCREATESTATISTICS:\n=> CREATE STATISTICS flights_expr_stat ON (extract(\nmonth FROM scheduled_departure AT TIME ZONE 'Europe/Moscow'\n))\nFROM flights;\nПослесборастатистикиоценкаисправляется:\n=> ANALYZE flights;\n=> EXPLAIN SELECT * FROM flights\nWHERE extract(\nmonth FROM scheduled_departure AT TIME ZONE 'Europe/Moscow'\n) = 1;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on flights (cost=0.00..6384.17 rows=17325 width=63)\nFilter: (EXTRACT(month FROM (scheduled_departure AT TIME ZONE ...\n(2 rows)\nЧтобысобраннаястатистикаиспользовалась,выражениевусловиизапроса\nдолжнобытьзаписановтомжевиде,чтоивкомандеCREATE STATISTICS.\nv.13 Размер собираемой расширенной статистики можно изменить отдельно\nкомандойALTERSTATISTICS,например:\n=> ALTER STATISTICS flights_expr_stat SET STATISTICS 42;\nОбщаяинформацияорасширеннойстатистикехранитсявтаблицесистем-\nногокаталогаpg_statistic_ext,асобственнособраннаястатистика—вот-\nv.12 дельнойтаблицеpg_statistic_ext_data.Смыслтакогоразделениясосто-\nитввозможностиограничениядоступапользователейкчувствительнойин-\nформации.\n1 postgrespro.ru/docs/postgresql/17/planner-stats#PLANNER-STATS-EXTENDED;\nbackend/statistics/README.\n350",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:55.637561"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 352,
    "chapter": null,
    "section": "17.9 Статистикаповыражению",
    "text": "17.9. Статистикаповыражению\nДоступную пользователю расширенную статистику по выражению можно\nпосмотретьвболееудобномвидеспомощьюспециальногопредставления:\n=> SELECT left(expr,50) || '...' AS expr,\nnull_frac, avg_width, n_distinct,\nmost_common_vals AS mcv,\nleft(most_common_freqs::text,50) || '...' AS mcf,\ncorrelation\nFROM pg_stats_ext_exprs WHERE statistics_name = 'flights_expr_stat' \\gx\n−[ RECORD 1 ]−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nexpr | EXTRACT(month FROM (scheduled_departure AT TIME ZO...\nnull_frac | 0\navg_width | 8\nn_distinct | 12\nmcv | {8,9,10,1,12,3,4,7,6,5,11,2}\nmcf | {0.1215,0.11293333,0.081366666,0.080633335,0.0787,...\ncorrelation | 0.09482787\nСтатистика для индекса по выражению\nВторой способ исправить оценки кардинальности — воспользоваться тем,\nчтоприсозданиииндексаповыражениюдлянегособираетсяотдельнаяста- с.388\nтистика,какдлятаблицы.Этоудобно,еслииндексдействительнонужен.\n=> DROP STATISTICS flights_expr_stat;\n=> CREATE INDEX ON flights(extract(\nmonth FROM scheduled_departure AT TIME ZONE 'Europe/Moscow'\n));\n=> ANALYZE flights;\n=> EXPLAIN SELECT * FROM flights\nWHERE extract(\nmonth FROM scheduled_departure AT TIME ZONE 'Europe/Moscow'\n) = 1;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on flights (cost=326.58..3253.52 rows=17311 wi...\nRecheck Cond: (EXTRACT(month FROM (scheduled_departure AT TIME...\n−> Bitmap Index Scan on flights_extract_idx (cost=0.00..322.2...\nIndex Cond: (EXTRACT(month FROM (scheduled_departure AT TI...\n(4 rows)\n351",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:55.676265"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 353,
    "chapter": null,
    "section": "17.9 Статистикаповыражению",
    "text": "Глава17. Статистика\nСтатистикадляиндексовповыражениюхранитсятакже,какстатистикапо\nтаблице.Например,из pg_stats можно получить количество уникальных\nзначений,указаввкачествеtablenameимяиндекса:\n=> SELECT n_distinct FROM pg_stats\nWHERE tablename = 'flights_extract_idx';\nn_distinct\n−−−−−−−−−−−−\n12\n(1 row)\nv.11 Изменить точность статистики в случае индекса можно командой ALTER\nINDEX.Дляэтогосначаламожетпотребоватьсяузнать,какназываетсястол-\nбец,соответствующийвыражению.Например:\n=> SELECT attname FROM pg_attribute\nWHERE attrelid = 'flights_extract_idx'::regclass;\nattname\n−−−−−−−−−\nextract\n(1 row)\n=> ALTER INDEX flights_extract_idx\nALTER COLUMN extract SET STATISTICS 42;\n17.10. Многовариантная статистика\nPostgreSQLдаетвозможностьсобиратьмноговариантнуюстатистику,охва-\nтывающую не один,а несколько столбцовтаблицы.Для этого необходимо\nвручнуюсоздатьсоответствующуюрасширеннуюстатистику.\nРеализованотривидамноговариантнойстатистики.\nФункциональные зависимости междустолбцами\nЕсли значения в одном столбце определяются (полностью или частично)\nзначениямидругогостолбцаивзапросеуказаныусловиянаобатакихстолб-\nца,оценкакардинальностибудетзанижена.\n352",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:55.704211"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 354,
    "chapter": null,
    "section": "17.10 Многовариантнаястатистика",
    "text": "17.10. Многовариантнаястатистика\nРассмотримзапроссдвумяусловиями:\n=> SELECT count(*) FROM flights\nWHERE flight_no = 'PG0007' AND departure_airport = 'VKO';\ncount\n−−−−−−−\n396\n(1 row)\nОценкаоказываетсясильнозаниженной:\n=> EXPLAIN SELECT * FROM flights\nWHERE flight_no = 'PG0007' AND departure_airport = 'VKO';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on flights (cost=10.49..814.25 rows=15 width=63)\nRecheck Cond: (flight_no = 'PG0007'::bpchar)\nFilter: (departure_airport = 'VKO'::bpchar)\n−> Bitmap Index Scan on flights_flight_no_scheduled_departure_key\n(cost=0.00..10.48 rows=275 width=0)\nIndex Cond: (flight_no = 'PG0007'::bpchar)\n(6 rows)\nЭто известная проблема коррелированных предикатов. Планировщик пола-\nгаетсянато,чтопредикатынезависимы,ивычисляетобщуюселективность\nкак произведение селективностей условий,объединенныхлогическим «и». с.324\nЭто хорошо видно в приведенном плане: оценка в узле Bitmap Index Scan,\nполученная по условию на столбец flight_no, существенно уменьшается\nпослефильтрациипоусловиюнастолбецdeparture_airportвузлеBitmap\nHeapScan.\nОднакомыпонимаем,чтономеррейсаоднозначноопределяетаэропорты:\nфактическивтороеусловиеизбыточно(конечно,еслиаэропортуказанпра-\nвильно).Втаких случаях расширенная статистика по функциональным за-\nвисимостямможетулучшитьоценку.\nСоздадимрасширеннуюстатистикупофункциональнойзависимостимеж-\nдудвумястолбцами:\n=> CREATE STATISTICS flights_dep_stat(dependencies)\nON flight_no, departure_airport FROM flights;\n353",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:55.740957"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 355,
    "chapter": null,
    "section": "17.10 Многовариантнаястатистика",
    "text": "Глава17. Статистика\nПри очередном анализе таблицы желаемая статистика будет собрана, и\nоценкаулучшится:\n=> ANALYZE flights;\n=> EXPLAIN SELECT * FROM flights\nWHERE flight_no = 'PG0007' AND departure_airport = 'VKO';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on flights (cost=11.92..1185.77 rows=451 width...\nRecheck Cond: (flight_no = 'PG0007'::bpchar)\nFilter: (departure_airport = 'VKO'::bpchar)\n−> Bitmap Index Scan on flights_flight_no_scheduled_departure_key\n(cost=0.00..11.80 rows=451 width=0)\nIndex Cond: (flight_no = 'PG0007'::bpchar)\n(6 rows)\nВсистемномкаталогесобраннуюстатистикуможнопосмотретьследующим\nобразом:\n=> SELECT dependencies\nFROM pg_stats_ext WHERE statistics_name = 'flights_dep_stat';\ndependencies\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n{\"2 => 5\": 1.000000, \"5 => 2\": 0.010900}\n(1 row)\nЧисла 2 и 5—номера столбцовтаблицы из pg_attribute.Значения опре-\nделяютстепеньфункциональнойзависимости:от0(зависимостинет)до1\n(значениявпервомстолбцеполностьюопределяютзначениявовтором).\nМноговариантное число различных значений\nИнформация о количестве уникальных комбинаций значений из несколь-\nких столбцов позволяет точнее оценить кардинальность группировки по\nнесколькимстолбцам.\nНапример,количествовозможныхпараэропортовотправленияиприбытия\nоцениваетсяпланировщикомкакквадратколичествааэропортов,нореаль-\nноезначениесильноменьше,посколькудалеконекаждаяпарааэропортов\nсоединенапрямымрейсом:\n354",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:55.776792"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 356,
    "chapter": null,
    "section": "17.10 Многовариантнаястатистика",
    "text": "17.10. Многовариантнаястатистика\n=> SELECT count(*)\nFROM (\nSELECT DISTINCT departure_airport, arrival_airport FROM flights\n) t;\ncount\n−−−−−−−\n618\n(1 row)\n=> EXPLAIN SELECT DISTINCT departure_airport, arrival_airport\nFROM flights;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nHashAggregate (cost=5847.01..5955.16 rows=10816 width=8)\nGroup Key: departure_airport, arrival_airport\n−> Seq Scan on flights (cost=0.00..4772.67 rows=214867 width=8)\n(3 rows)\nСоздадимисоберемрасширеннуюстатистикупочислуразныхзначений:\n=> CREATE STATISTICS flights_nd_stat(ndistinct)\nON departure_airport, arrival_airport FROM flights;\n=> ANALYZE flights;\nТеперьоценкакардинальностиисправилась:\n=> EXPLAIN SELECT DISTINCT departure_airport, arrival_airport\nFROM flights;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nHashAggregate (cost=5847.01..5853.19 rows=618 width=8)\nGroup Key: departure_airport, arrival_airport\n−> Seq Scan on flights (cost=0.00..4772.67 rows=214867 width=8)\n(3 rows)\nСобраннуюстатистикуможноувидетьвсистемномкаталоге:\n=> SELECT n_distinct\nFROM pg_stats_ext WHERE statistics_name = 'flights_nd_stat';\nn_distinct\n−−−−−−−−−−−−−−−\n{\"5, 6\": 618}\n(1 row)\n355",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:55.812886"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 357,
    "chapter": null,
    "section": "17.10 Многовариантнаястатистика",
    "text": "Глава17. Статистика\nv.12 Многовариантные списки частых значений\nПри неравномерном распределении значений одноготолько знания функ-\nциональной зависимости может быть недостаточно, поскольку оценка су-\nщественнозависитотконкретнойпарызначений.Например,планировщик\nошибается,оцениваяколичестворейсовизШереметьева,выполняемыхБо-\nингом737:\n=> SELECT count(*) FROM flights\nWHERE departure_airport = 'SVO' AND aircraft_code = '733';\ncount\n−−−−−−−\n2037\n(1 row)\n=> EXPLAIN SELECT * FROM flights\nWHERE departure_airport = 'SVO' AND aircraft_code = '733';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on flights (cost=0.00..5847.00 rows=732 width=63)\nFilter: ((departure_airport = 'SVO'::bpchar) AND (aircraft_cod...\n(2 rows)\nВтакомслучаеоценкуможноуточнить,собираястатистикупомноговари-\nантнымспискамчастыхзначений1:\n=> CREATE STATISTICS flights_mcv_stat(mcv)\nON departure_airport, aircraft_code FROM flights;\n=> ANALYZE flights;\nНоваяоценкакардинальностигораздоточнее:\n=> EXPLAIN SELECT * FROM flights\nWHERE departure_airport = 'SVO' AND aircraft_code = '733';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on flights (cost=0.00..5847.00 rows=2249 width=63)\nFilter: ((departure_airport = 'SVO'::bpchar) AND (aircraft_cod...\n(2 rows)\n1 backend/statistics/README.mcv;\nbackend/statistics/mcv.c.\n356",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:55.849272"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 358,
    "chapter": null,
    "section": "17.10 Многовариантнаястатистика",
    "text": "17.10. Многовариантнаястатистика\nДляееполученияпланировщиквоспользовалсячастотой,сохраненнойвси-\nстемномкаталоге:\n=> SELECT values, frequency\nFROM pg_statistic_ext stx\nJOIN pg_statistic_ext_data stxd ON stx.oid = stxd.stxoid,\npg_mcv_list_items(stxdmcv) m\nWHERE stxname = 'flights_mcv_stat'\nAND values = '{SVO,773}';\nvalues | frequency\n−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−\n{SVO,773} | 0.006033333333333333\n(1 row)\nВ многовариантном списке, как и в обычном списке частых значений, со-\nхраняется default_statistics_target значений (если параметр задан на уровне 100\nстолбцов,тоиспользуетсянаибольшеезначение).\nКакидлярасширеннойстатистикиповыражению,принеобходимостимож- v.13\nноизменитьразмерсписка:\nALTER STATISTICS ... SET STATISTICS ...;\nВо всех примерах я использовал только два столбца,но многовариантную\nстатистикуможносоздаватьипобольшемуколичеству.\nВодномобъектеможнокомбинироватьстатистикуразныхтипов,указывая\nихчереззапятую(аеслинеуказатьтип,длязаданныхстолбцовбудутсоби-\nратьсясразувсевозможныевариантыстатистики).\nБолеетого,какивстатистикеповыражению,вмноговариантнойстатисти- v.14\nкетоже можно использоватьпроизвольные выражения,а нетолько имена\nстолбцов.\n357",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:55.876765"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 359,
    "chapter": null,
    "section": "18.1 Подключаемые движки хранения",
    "text": "18\nТабличные методы доступа\n18.1. Подключаемые движки хранения\nСпособорганизацииданныхнадиске,принятыйвPostgreSQL,неявляется\nниединственновозможным,нинаилучшимдлявсехтиповнагрузки.Следуя\nv.12 идеерасширяемости,PostgreSQLпозволяетсоздаватьиподключатьразлич-\nные табличные методы доступа (движки храненияданных),хотя в настоя-\nщеевремя«изкоробки»доступентолькоодин:\n=> SELECT amname, amhandler FROM pg_am WHERE amtype = 't';\namname | amhandler\n−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−\nheap | heap_tableam_handler\n(1 row)\nИмя движка может указываться при создании таблицы (CREATE TABLE ...\nUSING); по умолчанию используетсядвижок,определяемый значением па-\nheap раметра default_table_access_method. Впоследствии движок можно сменить\nv.15 (ALTER TABLE ... SET ACCESS METHOD),но,конечно,ценой переписывания\nвсехданных.\nЧтобыядромоглооднотипноработатьсразнымидвижками,табличныеме-\nтоды доступа должны реализовывать специальный интерфейс1. Функция,\nуказанная в столбце amhandler,возвращает интерфейсную структуру2,со-\nдержащуювсюнеобходимуюдляядраинформацию.\n1 postgrespro.ru/docs/postgresql/17/tableam.\n2 include/access/tableam.h.\n358",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:55.901820"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 360,
    "chapter": null,
    "section": "18.1 Подключаемыедвижкихранения",
    "text": "18.1. Подключаемыедвижкихранения\nБóльшаячастькомпонентовядраостаетсяобщейдлялюбыхтабличныхме-\nтодовдоступа:\n• менеджертранзакций,включаяподдержкуACIDиизоляциинаоснове\nснимков;\n• буферныйменеджер;\n• журнал,включаяподдержкуспецифичныхоперацийспомощьюмеха-\nнизмаунифицированныхжурнальныхзаписей1 илипользовательских\nменеджеровресурсов2; v.15\n• подсистемаввода-вывода;\n• TOAST;\n• оптимизаториисполнительзапросов;\n• индекснаяподдержка.\nНе все эти компоненты могут быть нужны движку, но возможность их ис-\nпользованиясохраняется.\nВсвоюочередь,движокопределяет:\n• форматверсиистрокииструктуруданных;\n• реализациюсканированиятаблицыиоценкуегостоимости;\n• реализациювставок,удалений,обновленийиблокировок;\n• правилавидимостиверсийстрок;\n• процедурыочисткиианализа.\nИсторическиPostgreSQLиспользовалединственнуюсистемухранениядан-\nных,встроенную в ядро без какого-либо определенного программного ин-\nтерфейса.Поэтомусейчаскрайнесложносоздатьудачныйинтерфейс,кото-\nрыйучитывалбывсесложившиесяособенностистандартногодвижкаипри\nэтомнемешалбыдругимметодам.\n1 postgrespro.ru/docs/postgresql/17/generic-wal.\n2 postgrespro.ru/docs/postgresql/17/custom-rmgr.\n359",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:55.925943"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 361,
    "chapter": null,
    "section": "18.1 Подключаемыедвижкихранения",
    "text": "Глава18. Табличныеметодыдоступа\nПоэтомуиянестаралсяпридерживатьсястрогогоделениямеждуядроми\nтабличными методами.Многое из сказанного в предыдущих частях книги\nформально относится не к функциям ядра,а к особенностям метода heap.\nСкорее всего, этот метод навсегда останется в PostgreSQL как универсаль-\nныйстандартныйдвижок,адругиеметодыбудутзаниматьотдельныениши,\nпозволяяоптимальнеесправлятьсясопределеннымитипаминагрузки.\nОсвоение механизматабличных методов началосьсо следующихдвижков:\nZheap былпризвансправитьсяспроблемойраздуваниятаблиц1.Дляэтого\nон реализует обновление версий строк на месте и выносит историче-\nские данные,необходимые для построения снимка,в отдельное undo-\nхранилище.Такойдвижокполезенпринагрузке,включающейактивное\nобновлениеданных.\nУстройство движка покажется знакомым пользователям Oracle, хотя\nс.381 есть и нюансы (например,интерфейс индексных методов не позволя-\nетсоздаватьиндексыссобственнойверсионностью).\nZedstore реализует колоночное хранение2 и должен быть эффективен для\nOLAP-запросов.\nДанные организованы в основное B-дерево идентификаторов версий\nстрок,а каждый столбец хранится в собственном B-дереве,связанном\nсосновным(сперспективойсохраненияводномдеревесразунесколь-\nкихстолбцовдляполучениягибридногохранилища).\nКсожалению,этидвижкинебылидоведеныдопромышленнойготовности;\nработанаднимифактическипрекратилась.Внастоящеевремяактивнораз-\nвиваютсядругиепроекты,например:\nOrioleDB — движок, спроектированный с учетом возможностей современ-\nного оборудования и особенностей облачных сервисов3. Метод досту-\nпахранитданныевтаблицах,организованныхкакдеревья,иустраняет\nраздуваниетаблицзасчетиспользованияжурналаотката.\n1 github.com/EnterpriseDB/zheap.\n2 github.com/greenplum-db/postgres/tree/zedstore.\n3 github.com/orioledb/orioledb.\n360",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:55.961204"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 362,
    "chapter": null,
    "section": "18.2 Последовательное сканирование",
    "text": "18.2. Последовательноесканирование\nИз-за недостаточно проработанного интерфейса табличных методов\nдоступа установка OrioleDB требует определенных изменений в ядре\nPostgreSQL.\nCitusColumnar реализуетклассическоеколоночноехранениеданныхсосжа-\nтием1. Этот метод доступа предназначен для аналитической нагрузки\nи хранилищ данных, он не поддерживает обновление и имеет другие\nограничения.\n18.2. Последовательное сканирование\nДвижокхраненияотвечаетзафизическуюорганизациютабличныхданных\nи предоставляет метод доступа к ним — последовательное сканирование,\nпри котором полностью читается файл (или файлы) основного слоятабли-\nцы.Накаждойпрочитаннойстраницепроверяетсявидимостькаждойвер- с.97\nсиистроки;версии,неудовлетворяющиеусловиямзапроса,отбрасываются.\nтабличная\nстраница\nверсиястроки,\nнеудовлетворяющая\nусловиям\nЧтениепроисходитчерезбуферныйкеш;чтобыбольшиетаблицыневытес- с.190\nнялиполезныеданные,дляпоследовательногосканированияиспользуется\nбуферноекольцонебольшогоразмера.Приэтомдругиепроцессы,одновре-\nменносканирующиетужетаблицу,присоединяютсяккольцуитемсамым\nэкономятоперациидисковых чтений.Поэтому в общем случае сканирова-\nниеможетстартоватьнесначалафайла.\n1 github.com/citusdata/citus/tree/main/src/backend/columnar.\n361",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 1,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 2,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 3,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 4,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T15:59:55.998119"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 363,
    "chapter": null,
    "section": "18.2 Последовательное сканирование",
    "text": "Глава18. Табличныеметодыдоступа\nПоследовательное сканирование—самый эффективный способ прочитать\nвсютаблицуилизначительнуюеечасть.Инымисловами,последовательное\nсканированиехорошоработаетпринизкойселективности.(Привысокойсе-\nлективности, когда из всей таблицы нужна только небольшая часть строк,\nс.381 болеепредпочтительнымбудетиспользованиеиндекса.)\nОценка стоимости\nВ плане выполнения запроса последовательное сканирование представля-\nетсяузломSeqScan:\n=> EXPLAIN SELECT * FROM flights;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on flights (cost=0.00..4772.67 rows=214867 width=63)\n(1 row)\nОценкаколичествастрок(rows)являетсябазовойстатистикой:\n=> SELECT reltuples FROM pg_class WHERE relname = 'flights';\nreltuples\n−−−−−−−−−−−\n214867\n(1 row)\nВ оценке стоимости оптимизатор учитываетдве составляющие:дисковый\nввод-выводиресурсыпроцессора1.\nСтоимостьввода-вывода рассчитывается как произведение числа страниц\nвтаблиценастоимостьчтенияоднойстраницы,приусловиичтостра-\nницы читаются последовательно.Когда буферный менеджер запраши-\nваету операционной системы страницуданных,физически сдиска за\nодинразчитаетсябольшийобъемданных,такчтосвысокойвероятно-\nстьюнесколькоследующихстраницужеокажутсявкешеОС.Засчетэто-\nго стоимость последовательного чтения одной страницы (которая для\n1 backend/optimizer/path/costsize.c,функцияcost_seqscan.\n362",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.031136"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 364,
    "chapter": null,
    "section": "18.2 Последовательноесканирование",
    "text": "18.2. Последовательноесканирование\nпланировщикаопределяетсязначениемпараметраseq_page_cost)полу- 1\nчается меньше, чем стоимость при случайном доступе (определяемая\nзначениемпараметраrandom_page_cost). 4\nСоотношение по умолчанию подходит для HDD-дисков; для накопи-\nтелей SSD имеет смысл существенно уменьшить значение парамет-\nра random_page_cost (значение seq_page_cost, как правило, не трогают,\nоставляяединицувкачествеопорногозначения).Посколькусоотноше-\nниезависитотхарактеристикоборудования,параметрыобычнозадают\nнауровнетабличныхпространств(ALTERTABLESPACE...SET).\n=> SELECT relpages,\ncurrent_setting('seq_page_cost') AS seq_page_cost,\nrelpages * current_setting('seq_page_cost')::real AS total\nFROM pg_class WHERE relname = 'flights';\nrelpages | seq_page_cost | total\n−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−\n2624 | 1 | 2624\n(1 row)\nПриведенная формула отчетливо показывает последствия раздувания с.165\nтаблициз-занесвоевременнойочистки:чембольшийобъемзанимает\nосновной слой таблицы, тем больше страниц придется сканировать,\nнезависимоотколичестваактуальныхверсийстроквних.\nОценкаресурсовпроцессора учитываетстоимостьобработкикаждойверсии\nстроки(котораяопределяетсядляпланировщиказначениемпараметра\ncpu_tuple_cost): 0.01\n=> SELECT reltuples,\ncurrent_setting('cpu_tuple_cost') AS cpu_tuple_cost,\nreltuples * current_setting('cpu_tuple_cost')::real AS total\nFROM pg_class WHERE relname = 'flights';\nreltuples | cpu_tuple_cost | total\n−−−−−−−−−−−+−−−−−−−−−−−−−−−−+−−−−−−−−−\n214867 | 0.01 | 2148.67\n(1 row)\nСуммадвухприведенныхоценокисоставляетполнуюстоимостьплана.\nНачальная стоимость равна нулю, поскольку последовательное скани-\nрованиенетребуетвыполненияподготовительныхдействий.\n363",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.069633"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 365,
    "chapter": null,
    "section": "18.2 Последовательноесканирование",
    "text": "Глава18. Табличныеметодыдоступа\nЕслинасканируемуютаблицуналоженыусловия,ониотображаютсявплане\nс.333 запроса под узлом Seq Scan в секции Filter. Оценка числа строк будет учи-\nтывать селективность этих условий, а оценка стоимости — затраты на их\nвычисления.\nКомандаEXPLAINANALYZEвыведетиреальнополученноеколичествострок,\nиколичествострок,отфильтрованныхусловиями:\n=> EXPLAIN (analyze, timing off, summary off)\nSELECT * FROM flights\nWHERE status = 'Scheduled';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on flights\n(cost=0.00..5309.84 rows=15383 width=63)\n(actual rows=15383 loops=1)\nFilter: ((status)::text = 'Scheduled'::text)\nRows Removed by Filter: 199484\n(5 rows)\nРассмотрим чуть более сложный пример плана выполнения с агрегацией:\n=> EXPLAIN SELECT count(*) FROM seats;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nAggregate (cost=24.74..24.75 rows=1 width=8)\n−> Seq Scan on seats (cost=0.00..21.39 rows=1339 width=0)\n(2 rows)\nПлансостоитиздвухузлов:верхнийузелAggregate,вкоторомпроисходит\nвычислениефункцииcount,получаетданныеотнижнегоузлаSeqScan,вы-\nполняющегосканированиетаблицы.\nНачальнаястоимостьузлаAggregateвключаетсамуагрегацию:невозможно\nвыдатьпервую(иединственную)строкурезультата,неполучиввсестроки\nотнижестоящего узла.Оценка вычисляется исходя из стоимости выполне-\n0.0025 нияусловнойоперацииcpu_operator_costнадкаждойвходнойстрокой1:\n1 backend/optimizer/path/costsize.c,функцияcost_agg.\n364",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.107015"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 366,
    "chapter": null,
    "section": "18.2 Последовательноесканирование",
    "text": "18.2. Последовательноесканирование\n=> SELECT reltuples,\ncurrent_setting('cpu_operator_cost') AS cpu_operator_cost,\nround((\nreltuples * current_setting('cpu_operator_cost')::real\n)::numeric, 2) AS cpu_cost\nFROM pg_class WHERE relname = 'seats';\nreltuples | cpu_operator_cost | cpu_cost\n−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−\n1339 | 0.0025 | 3.35\n(1 row)\nПолученнаяоценкадобавляетсякполнойстоимостиузлаSeqScan.\nПолнаястоимостьузлаAggregateдополнительновключаетстоимостьобра-\nботкиоднойстрокирезультатаcpu_tuple_cost: 0.01\n=> WITH t(cpu_cost) AS (\nSELECT round((\nreltuples * current_setting('cpu_operator_cost')::real\n)::numeric, 2)\nFROM pg_class WHERE relname = 'seats'\n)\nSELECT 21.39 + t.cpu_cost AS startup_cost,\nround((\n21.39 + t.cpu_cost +\n1 * current_setting('cpu_tuple_cost')::real\n)::numeric, 2) AS total_cost\nFROM t;\nstartup_cost | total_cost\n−−−−−−−−−−−−−−+−−−−−−−−−−−−\n24.74 | 24.75\n(1 row)\nТаким образом,зависимости между оценками стоимостей можно предста-\nвитьсебеследующимобразом:\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nAggregate\n(cost=24.74..24.75 rows=1 width=8)\n−> Seq Scan on seats\n(cost=0.00..21.39 rows=1339 width=0)\n(4 rows)\n365",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.140010"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 367,
    "chapter": null,
    "section": "18.3 Параллельные планы выполнения",
    "text": "Глава18. Табличныеметодыдоступа\n18.3. Параллельные планы выполнения\nPostgreSQLподдерживаетпараллельноевыполнениезапросов1.Идеясосто-\nит в том, что ведущий процесс, выполняющий запрос, порождает (с по-\nмощью postmaster) несколько рабочих процессов, которые одновременно\nвыполняютоднуитужепараллельнуючастьплана.Результатыэтоговыпол-\nнения передаются ведущему процессу,который собираетих в узле Gather2.\nВсвободноеотприемаданныхвремяведущийпроцесстакжеможетвыпол-\nнятьпараллельнуючастьплана.\nv.11 Принеобходимостиможноотключитьведущийпроцессотвыполненияпа-\non раллельной части плана с помощью параметра parallel_leader_participation.\nпоследовательная\nчастьплана\nGather\nпараллельная параллельная параллельная\nчастьплана частьплана частьплана\nрабочийпроцесс ведущийпроцесс рабочийпроцесс\nРазумеется,запуск процессов и пересылка данных требуют определенных\nресурсов,поэтомудалеконекаждыйзапросимеетсмыслвыполнятьпарал-\nлельно.\nКрометого,дажеприпараллельномвыполненииненадвсемишагамипла-\nна запроса можно работать одновременно. Часть операций может выпол-\nнятьсяведущимпроцессомв одиночку,последовательно.\nВPostgreSQLнереализовандругойтеоретическивозможныйрежимраспараллелива-\nния,прикоторомнесколькопроцессовсоставляютконвейердляобработкиданных\n(грубо говоря,отдельные узлы плана выполняются отдельными процессами).Разра-\nботчикиPostgreSQLсочлитакойрежимнеэффективным.\n1 postgrespro.ru/docs/postgresql/17/parallel-query;\nbackend/access/transam/README.parallel.\n2 backend/executor/nodeGather.c.\n366",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.175975"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 368,
    "chapter": null,
    "section": "18.4 Параллельное последовательное сканирование",
    "text": "18.4. Параллельноепоследовательноесканирование\n18.4. Параллельное последовательное сканирование\nПримеромузла,предназначенногодляпараллельноговыполнения,являет-\nсяParallelSeqScan—«параллельноепоследовательноесканирование».\nНазваниезвучитнесколькопротиворечиво(все-такипараллельноеилипо-\nследовательное?),нотемнеменееотражаетсутьоперации.Сточкизрения\nобращенийкфайлустраницытаблицычитаютсяпоследовательно,втомже\nпорядке, в котором они читались бы при обычном последовательном ска-\nнировании.Однакочтениевыполняетсянесколькимипараллельноработа-\nющимипроцессами.Процессысинхронизируютсямеждусобойспомощью\nспециально отведенного участка общей памяти,чтобы не прочитать одну\nитужестраницудважды.\nТонкиймоментсостоитвтом,чтовместообщейкартиныпоследовательно- v.14\nгосканированияоперационнаясистемавидитнесколькопроцессов,выпол-\nняющихслучайноечтение.Из-заэтогопредвыборкаданных,обычноуско-\nряющая последовательное чтение, работает плохо. Поэтому каждому про-\nцессувыделяетсядлячтениянеодна,анесколькостраниц,идущихподряд1.\nСама по себе операция параллельного сканирования не имеет большого\nсмысла,посколькук обычнымзатратамначтениестраницдобавляютсяна-\nкладныерасходынапересылкуданныхотпроцессакпроцессу.Ноеслира-\nбочиепроцессывыполняюткакую-тообработкупрочитанныхстрок(напри-\nмер,агрегацию),тосуммарноевремявыполнениязапросаможетоказаться\nсущественноменьшим.\nОценка стоимости\nРассмотрим простой запрос с агрегацией над большойтаблицей.План вы-\nполнениябудетиспользоватьпараллелизм:\n1 backend/access/heap/heapam.c,функцииtable_block_parallelscan_startblock_initиtable_block_-\nparallelscan_nextpage.\n367",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.208469"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 369,
    "chapter": null,
    "section": "18.4 Параллельное последовательное сканирование",
    "text": "Глава18. Табличныеметодыдоступа\n=> EXPLAIN SELECT count(*) FROM bookings;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nFinalize Aggregate (cost=25483.58..25483.59 rows=1 width=8)\n−> Gather (cost=25483.36..25483.57 rows=2 width=8)\nWorkers Planned: 2\n−> Partial Aggregate\n(cost=24483.36..24483.37 rows=1 width=8)\n−> Parallel Seq Scan on bookings\n(cost=0.00..22284.29 rows=879629 width=0)\n(7 rows)\nУзлы ниже Gather составляютпараллельную частьплана.Она выполняется\nв каждом из рабочих процессов (которых в данном случае запланировано\nдвештуки)и,возможно,введущемпроцессе(еслиэтонеотключенопара-\nметром parallel_leader_participation). Сам узел Gather и узлы выше него со-\nставляютпоследовательную частьплана и выполняютсятолько в ведущем\nпроцессе.\nУзел Parallel Seq Scan представляетсканированиетаблицы в параллельном\nрежиме.Вполеrowsпоказанаоценкачисластрок,которыевсреднемвыдаст\nодинпроцесс.Всегонадвыполнениемдолжнотрудитьсятрипроцесса(веду-\nщийидварабочих),новедущийпроцессбудетзадействованнеполностью:\nеговкладуменьшаетсясростомчисларабочихпроцессов1.Вданномслучае\nиспользуетсякоэффициент2,4.\n=> SELECT reltuples::numeric, round(reltuples / 2.4) AS per_process\nFROM pg_class WHERE relname = 'bookings';\nreltuples | per_process\n−−−−−−−−−−−+−−−−−−−−−−−−−\n2111110 | 879629\n(1 row)\nСтоимостьузлаParallelSeqScanоцениваетсяпочтитакже,какистоимость\nпоследовательного сканирования. Выигрыш получается за счет того, что\nкаждыйизпроцессовобрабатываетменьшееколичествострок;составляю-\nщаяввода-выводаприэтомучитываетсяполностью,посколькутаблицувсе\nравнопридетсяпрочитатьцеликом,страницазастраницей:\n1 backend/optimizer/path/costsize.c,функцияget_parallel_divisor.\n368",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.258962"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 370,
    "chapter": null,
    "section": "18.4 Параллельноепоследовательноесканирование",
    "text": "18.4. Параллельноепоследовательноесканирование\n=> SELECT round((\nrelpages * current_setting('seq_page_cost')::real +\nreltuples / 2.4 * current_setting('cpu_tuple_cost')::real\n)::numeric, 2)\nFROM pg_class WHERE relname = 'bookings';\nround\n−−−−−−−−−−\n22284.29\n(1 row)\nСледующий узел—Partial Aggregate—выполняет агрегацию данных,полу-\nченных рабочим процессом, то есть в данном случае подсчитывает коли-\nчествострок.\nОценкастоимостиагрегациивыполняетсяужеизвестнымобразомидобав-\nляетсякоценкесканированиятаблицы:\n=> WITH t(startup_cost) AS (\nSELECT 22284.29 + round((\nreltuples / 2.4 * current_setting('cpu_operator_cost')::real\n)::numeric, 2)\nFROM pg_class WHERE relname = 'bookings'\n)\nSELECT startup_cost,\nstartup_cost + round((\n1 * current_setting('cpu_tuple_cost')::real\n)::numeric, 2) AS total_cost\nFROM t;\nstartup_cost | total_cost\n−−−−−−−−−−−−−−+−−−−−−−−−−−−\n24483.36 | 24483.37\n(1 row)\nСледующийузел—Gather—выполняетсяведущимпроцессом.Этотузелот-\nвечаетзазапускрабочихпроцессовиполучениеотнихданных.\nОценка стоимости запуска процессов (независимо отих количества) опре-\nделяетсядляпланировщиказначениемпараметраparallel_setup_cost,астои- 1000\nмость пересылки каждой строки данных между процессами — значением\nparallel_tuple_cost. 0.1\nВданномслучаепреобладаетначальнаястоимость(запускпроцессов),иэто\nзначениедобавляетсякначальнойстоимостиузлаPartialAggregate.Полная\n369",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.299793"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 371,
    "chapter": null,
    "section": "24483.37 + round(",
    "text": "Глава18. Табличныеметодыдоступа\nстоимость учитывает пересылку двух строк, и это значение складывается\nсполнойстоимостьюузлаPartialAggregate1:\n=> SELECT\n24483.36 + round(\ncurrent_setting('parallel_setup_cost')::numeric,\n2) AS setup_cost,\n24483.37 + round(\ncurrent_setting('parallel_setup_cost')::numeric +\n2 * current_setting('parallel_tuple_cost')::numeric,\n2) AS total_cost;\nsetup_cost | total_cost\n−−−−−−−−−−−−+−−−−−−−−−−−−\n25483.36 | 25483.57\n(1 row)\nПоследний узел — Finalize Aggregate — агрегирует частичные суммы, полу-\nченныеузломGatherотпараллельныхпроцессов.\nЭта окончательная агрегация оценивается так же, как и обычная. Началь-\nная стоимость учитывает агрегацию трех строк; это значение складывает-\nсясполнойстоимостьюузлаGather(посколькудлявычислениярезультата\nнужнывсестроки).Кполнойстоимостидобавляетсястоимостьвыдачиод-\nнойстрокирезультата.\n=> WITH t(startup_cost) AS (\nSELECT 25483.57 + round((\n3 * current_setting('cpu_operator_cost')::real\n)::numeric, 2)\nFROM pg_class WHERE relname = 'bookings'\n)\nSELECT startup_cost,\nstartup_cost + round((\n1 * current_setting('cpu_tuple_cost')::real\n)::numeric, 2) AS total_cost\nFROM t;\nstartup_cost | total_cost\n−−−−−−−−−−−−−−+−−−−−−−−−−−−\n25483.58 | 25483.59\n(1 row)\n1 backend/optimizer/path/costsize.c,функцияcost_gather.\n370",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.330952"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 372,
    "chapter": null,
    "section": "18.5 Ограниченияпараллельноговыполнения",
    "text": "18.5. Ограниченияпараллельноговыполнения\nЗависимостимеждуоценкамистоимостейопределяютсятем,накапливает\nлиузелданныепередвыдачейрезультатоввышестоящемуузлу.Агрегация\nне можетвозвращать результатыдотех пор,пока не получитвсе входные\nстроки. Поэтому в основу начальной стоимости агрегации ложится полная\nстоимостьнижестоящегоузла.АузелGatherвыдаетстрокинаверхсразу,как\nтолькополучаетихснизу.Поэтомуначальнаястоимостьэтойоперацииза-\nвисит от начальной стоимости нижестоящего узла, а полная — от полной.\nСхематическиэтоможнопредставитьсебеследующимобразом:\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nFinalize Aggregate\n(cost=25483.58..25483.59 rows=1 width=8)\n−> Gather\n(cost=25483.36..25483.57 rows=2 width=8)\nWorkers Planned: 2\n−> Partial Aggregate\n(cost=24483.36..24483.37 rows=1 width=8)\n−> Parallel Seq Scan on bookings\n(cost=0.00..22284.29 rows=879629 width=0)\n(9 rows)\n18.5. Ограничения параллельного выполнения\nКоличество рабочих процессов\nКоличество процессов ограничивают три параметра, образующих иерар-\nхию.Максимальноечислоодновременновыполняющихсярабочихпроцес-\nсовопределяетсязначениемпараметраmax_worker_processes. 8\nНомеханизмрабочихпроцессовиспользуетсянетолькодляпараллельного\nвыполнениязапросов.Например,фоновыерабочиепроцессызадействова-\nны в логической репликации, ими могут пользоваться расширения. Коли-\nчество рабочих процессов, занимающихся именно параллельными плана-\nми,ограниченозначениемпараметраmax_parallel_workers. 8\nИз этого числа не более max_parallel_workers_per_gather процессов могутоб- 2\nслуживатьодинведущийпроцесс.\n371",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.369779"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 373,
    "chapter": null,
    "section": "18.5 Ограниченияпараллельноговыполнения",
    "text": "Глава18. Табличныеметодыдоступа\nНавыборзначенийдляэтихпараметроввлияют:\n• возможности аппаратуры — система должна располагать свободными\nядрами,незанятымидругимизадачами;\n• наличиевбазеданныхбольшихтаблиц;\n• нагрузка — должны выполняться запросы, потенциально выигрываю-\nщиеотпараллельноговыполнения.\nВбольшинствеслучаевтакимкритериямудовлетворяютOLAP-,анеOLTP-\nсистемы.\nПланировщиквообщенебудетрассматриватьпараллельноесканирование,\nесли по его оценке размер прочитанных из таблицы данных не превысит\n8MB значениеmin_parallel_table_scan_size.\nЕсли число процессов не указано длятаблицы явно в параметре хранения\nparallel_workers,оновычисляетсяпоформуле\nразмертаблицы\n1+ log .\n⌊ 3(min_parallel_table_scan_size)⌋\nОна означает,что каждое увеличениетаблицы втри раза будетдобавлять\nещеодинпараллельныйпроцесс.Например,значенияпараметровпоумол-\nчаниюдаютследующиецифры:\nТаблица, Количество\nМбайт процессов\n8 1\n24 2\n72 3\n216 4\n648 5\n1944 6\nВлюбомслучаечислопроцессовнеможетпревышатьзначенияпараметра\nmax_parallel_workers_per_gather.\nЕсли запросить информацию из небольшой таблицы размером 19 Мбайт,\nбудетзапланированизапущенодинрабочийпроцесс:\n372",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.392716"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 374,
    "chapter": null,
    "section": "18.5 Ограниченияпараллельноговыполнения",
    "text": "18.5. Ограниченияпараллельноговыполнения\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT count(*) FROM flights;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nFinalize Aggregate (actual rows=1 loops=1)\n−> Gather (actual rows=2 loops=1)\nWorkers Planned: 1\nWorkers Launched: 1\n−> Partial Aggregate (actual rows=1 loops=2)\n−> Parallel Seq Scan on flights (actual rows=107434 lo...\n(6 rows)\nПризапроседанныхизтаблицыразмером105Мбайтбудетзапланировано\nтолькодвапроцессаиз-заограниченияmax_parallel_workers_per_gather: 2\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT count(*) FROM bookings;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nFinalize Aggregate (actual rows=1 loops=1)\n−> Gather (actual rows=3 loops=1)\nWorkers Planned: 2\nWorkers Launched: 2\n−> Partial Aggregate (actual rows=1 loops=3)\n−> Parallel Seq Scan on bookings (actual rows=703703 l...\n(6 rows)\nСнявограничение,получимрасчетныетрипроцесса:\n=> ALTER SYSTEM SET max_parallel_workers_per_gather = 4;\n=> SELECT pg_reload_conf();\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT count(*) FROM bookings;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nFinalize Aggregate (actual rows=1 loops=1)\n−> Gather (actual rows=4 loops=1)\nWorkers Planned: 3\nWorkers Launched: 3\n−> Partial Aggregate (actual rows=1 loops=4)\n−> Parallel Seq Scan on bookings (actual rows=527778 l...\n(6 rows)\n373",
    "tables": [
      {
        "table_index": 0,
        "rows": 2,
        "cols": 2,
        "content": "1 | \n | 1"
      },
      {
        "table_index": 1,
        "rows": 2,
        "cols": 2,
        "content": "2 | \n | 2"
      },
      {
        "table_index": 2,
        "rows": 2,
        "cols": 2,
        "content": "3 | \n | 3"
      }
    ],
    "extracted_at": "2025-10-02T15:59:56.435912"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 375,
    "chapter": null,
    "section": "18.5 Ограниченияпараллельноговыполнения",
    "text": "Глава18. Табличныеметодыдоступа\nЕслипривыполнениизапросачислосвободныхслотовокажетсяменьшеза-\nпланированного количества процессов, будет запущено только доступное\nколичестворабочихпроцессов.\nОграничимобщееколичествопараллельныхпроцессовпятьюивыполним\nдвазапросаодновременно:\n=> ALTER SYSTEM SET max_parallel_workers = 5;\n=> SELECT pg_reload_conf();\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT count(*) FROM bookings;\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT count(*) FROM bookings;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nFinalize Aggregate (actual rows=1 loops=1)\n−> Gather (actual rows=3 loops=1)\nWorkers Planned: 3\nWorkers Launched: 2\n−> Partial Aggregate (actual rows=1 loops=3)\n−> Parallel Seq Scan on bookings (actual rows=7037...\n(6 rows)\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nFinalize Aggregate (actual rows=1 loops=1)\n−> Gather (actual rows=4 loops=1)\nWorkers Planned: 3\nWorkers Launched: 3\n−> Partial Aggregate (actual rows=1 loops=4)\n−> Parallel Seq Scan on bookings (actual rows=527778 l...\n(6 rows)\nХотя в каждом случае было запланировано три рабочих процесса, одному\nзапросудосталосьтолькодвасвободныхслота.\nВосстановимзначенияпараметровпоумолчанию:\n=> ALTER SYSTEM RESET ALL;\n=> SELECT pg_reload_conf();\n374",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.472025"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 376,
    "chapter": null,
    "section": "18.5 Ограниченияпараллельноговыполнения",
    "text": "18.5. Ограниченияпараллельноговыполнения\nНераспараллеливаемые запросы\nНе каждый запрос может выполняться в параллельном режиме1.Не могут\nраспараллеливаться:\n• Запросы, изменяющие или блокирующие данные (UPDATE, DELETE,\nSELECTFORUPDATEиподобныеим).\nЭтонекасаетсязапросов,которыеиспользуютсявкомандах:\n– CREATETABLEAS,SELECTINTO,CREATEMATERIALIZEDVIEW; v.11\n– REFRESHMATERIALIZEDVIEW. v.14\nНовставкастроквовсехэтихслучаяхвыполняетсяпоследовательно.\n• Запросы,выполнение которых может быть приостановлено.Это отно-\nситсякзапросамвкурсорах,втомчислев циклахFORPL/pgSQL.\n• Запросы,содержащие вызовы небезопасных функций,помеченных как\nPARALLELUNSAFE.Ктаковымпоумолчаниюотносятсявсепользователь-\nские функции и небольшая часть стандартных. Список небезопасных\nфункцийможнополучитьизсистемногокаталога:\nSELECT * FROM pg_proc WHERE proparallel = 'u';\n• Запросывнутрифункций,когдаэтифункциивызываютсяизраспарал-\nлеленного запроса (чтобы не допустить рекурсивного разрастания ко-\nличестварабочихпроцессов).\nЧастьэтихограниченийможетбытьснятавследующихверсияхPostgreSQL.\nТак, например, появилась возможность распараллеливания запросов на v.12\nуровнеизоляцииSerializable.\nЗапросможетневыполнятьсявпараллельномрежимепонесколькимпри-\nчинам:\n• данныйзапросвпринципенеможетбытьраспараллеленниприкаких\nобстоятельствах;\n1 postgrespro.ru/docs/postgresql/17/when-can-parallel-query-be-used.\n375",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.503101"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 377,
    "chapter": null,
    "section": "18.5 Ограниченияпараллельноговыполнения",
    "text": "Глава18. Табличныеметодыдоступа\n• параллельный план запрещен значениями конфигурационных пара-\nметров(втомчислеиз-заограничениянаразмертаблиц);\n• параллельныйпланимеетболеевысокуюстоимостьпосравнениюспо-\nследовательным.\nv.16 Чтобы проверить, может ли запрос быть распараллелен в принципе, мож-\noff нонавремявключитьпараметрdebug_parallel_query.Приэтомпланировщик\nбудетстроитьпараллельныепланывовсехслучаях,когдаэтовозможно:\n=> EXPLAIN SELECT * FROM flights;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on flights (cost=0.00..4772.67 rows=214867 width=63)\n(1 row)\n=> SET debug_parallel_query = on;\n=> EXPLAIN SELECT * FROM flights;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nGather (cost=1000.00..27259.37 rows=214867 width=63)\nWorkers Planned: 1\nSingle Copy: true\n−> Seq Scan on flights (cost=0.00..4772.67 rows=214867 width=63)\n(4 rows)\nТеперьмыпонимаем,чтопланировщикрассматривалпараллельныйплан,\nновыбралболееэффективноевданномслучаепоследовательноесканиро-\nвание.\nОграниченно распараллеливаемые запросы\nЧем большую часть плана удается выполнить параллельно, тем больший\nвозможен эффект. Однако есть ряд операций, которые в целом не препят-\nствуютраспараллеливанию,но сами могутвыполнятьсятолько последова-\nтельновведущемпроцессе1.Инымисловами,онинемогутпоявитьсявде-\nревеплананижеузлаGather.\n1 postgrespro.ru/docs/postgresql/17/parallel-safety.\n376",
    "tables": [
      {
        "table_index": 0,
        "rows": 2,
        "cols": 1,
        "content": "=> SET debug_parallel_query = on;\n=> EXPLAIN SELECT * FROM flights;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nGather (cost=1000.00..27259.37 rows=214867 width=63)\nWorkers Planned: 1\nSingle Copy: true\n−> Seq Scan on flights (cost=0.00..4772.67 rows=214867 width=63)\n(4 rows)"
      }
    ],
    "extracted_at": "2025-10-02T15:59:56.538569"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 378,
    "chapter": null,
    "section": "18.5 Ограниченияпараллельноговыполнения",
    "text": "18.5. Ограниченияпараллельноговыполнения\nОбщие табличные выражения. Не распараллеливается чтение результата\nобщеготабличноговыражения1(узелпланаCTEScan):\n=> EXPLAIN (costs off)\nWITH t AS MATERIALIZED (\nSELECT * FROM flights\n)\nSELECT count(*) FROM t;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nAggregate\nCTE t\n−> Seq Scan on flights\n−> CTE Scan on t\n(4 rows)\nЕслиобщеетабличноевыражениенематериализуется,топланнесодержит v.12\nузлаCTEScan,иэтоограничениенедействует.\nПриэтомсамообщеетабличноевыражениевполнеможетвычислятьсявпа-\nраллельномрежиме,еслиэтовыгодно:\n=> EXPLAIN (costs off)\nWITH t AS MATERIALIZED (\nSELECT count(*) FROM flights\n)\nSELECT * FROM t;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nCTE Scan on t\nCTE t\n−> Finalize Aggregate\n−> Gather\nWorkers Planned: 1\n−> Partial Aggregate\n−> Parallel Seq Scan on flights\n(7 rows)\nКоррелированные подзапросы. Некоррелированные подзапросы, вычисля-\nемыеодинразипредставленныевпланеузломInitPlan,могутучаствовать v.17\nвпараллельномплане:\n1 backend/optimizer/plan/subselect.c.\n377",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.565214"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 379,
    "chapter": null,
    "section": "18.5 Ограниченияпараллельноговыполнения",
    "text": "Глава18. Табличныеметодыдоступа\n=> EXPLAIN (costs off)\nSELECT * FROM flights f1\nWHERE f1.aircraft_code = (\nSELECT '733' -- InitPlan 1\n)\nUNION ALL\nSELECT * FROM flights f2\nWHERE f2.aircraft_code = (\nSELECT '320' -- InitPlan 2\n);\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nGather\nWorkers Planned: 2\n−> Parallel Append\n−> Parallel Seq Scan on flights f2\nFilter: ((aircraft_code)::text = (InitPlan 2).col1)\nInitPlan 2\n−> Result\n−> Parallel Seq Scan on flights f1\nFilter: ((aircraft_code)::text = (InitPlan 1).col1)\nInitPlan 1\n−> Result\n(11 rows)\nУзел Parallel Append реализует здесь параллельное выполнение команды\nUNION ALL.Рабочие процессы разбирают себе по подзапросу (если процес-\nсовбольше,чемподзапросов,несколькомогутработатьнадоднойзадачей).\nКогда все данные от подзапроса уже получены, освободившийся процесс\nподключаетсякдругомуподзапросу,покавседанныенебудутобъединены.\nАвоткоррелированныеподзапросы(узелпланаSubPlan)неучаствуютвпа-\nраллельныхпланах:\n=> EXPLAIN (costs off)\nSELECT * FROM flights f1\nWHERE f1.aircraft_code = (\nSELECT f1.aircraft_code -- SubPlan 1\n)\nUNION ALL\nSELECT * FROM flights f2\nWHERE f2.aircraft_code = (\nSELECT '320' -- InitPlan 2\n);\n378",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.597445"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 380,
    "chapter": null,
    "section": "18.5 Ограниченияпараллельноговыполнения",
    "text": "18.5. Ограниченияпараллельноговыполнения\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nAppend\n−> Seq Scan on flights f1\nFilter: (aircraft_code = (SubPlan 1))\nSubPlan 1\n−> Result\n−> Gather\nWorkers Planned: 1\nInitPlan 2\n−> Result\n−> Parallel Seq Scan on flights f2\nFilter: ((aircraft_code)::text = (InitPlan 2).col1)\n(11 rows)\nВместо Parallel Append в плане появился узел Append, в котором операция\nUNION ALL выполняетсяпоследовательно,апараллельнаячастьпланаохва-\nтываеттеперьтольковторойподзапрос,вкоторомосталсяузелInitPlan.\nВременные таблицы. Временные таблицы не могут сканироваться парал-\nлельно,посколькудоступныисключительносоздавшемуихпроцессу.Рабо-\nта со страницами временныхтаблиц ведется в локальном буферном кеше. с.199\nЧтобыразрешитьобращатьсякнемунесколькимпроцессам,потребовалось\nбыввестиблокировки,каквразделяемомкеше,аэтоуменьшилобыосталь- с.295\nныепреимущества.\n=> CREATE TEMPORARY TABLE flights_tmp\nAS SELECT * FROM flights;\n=> EXPLAIN (costs off)\nSELECT count(*) FROM flights_tmp;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nAggregate\n−> Seq Scan on flights_tmp\n(2 rows)\nОграниченнораспараллеливаемыефункции. Вызовыфункций,помеченных\nкак PARALLEL RESTRICTED, могут выполняться только в последовательной\nчастиплана.\n379",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.628963"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 381,
    "chapter": null,
    "section": "18.5 Ограниченияпараллельноговыполнения",
    "text": "Глава18. Табличныеметодыдоступа\nСписоктакихфункцийможнополучитьизсистемногокаталогазапросом\nSELECT * FROM pg_proc WHERE proparallel = 'r';\nПомечатьсобственныефункциикакPARALLELRESTRICTED(итемболеекак\nPARALLELSAFE)нужносбольшойосторожностью,внимательноизучивиме-\nющиесяограничения1.\n1 postgrespro.ru/docs/postgresql/17/parallel-safety#PARALLEL-LABELING.\n380",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.637528"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 382,
    "chapter": null,
    "section": "19.1 Индексы и расширяемость",
    "text": "19\nИндексные методы доступа\n19.1. Индексы и расширяемость\nИндексы — объекты базы данных, предназначенные в основном для уско-\nрения доступа к данным. Это вспомогательные структуры: любой индекс\nможноудалитьивосстановитьзановопоинформациивтаблице.Но,кроме\nускорения, индексы служат и для поддержки некоторых ограничений це-\nлостности.\nВядровстроенышестьиндексныхметодовдоступа(типовиндексов):\n=> SELECT amname FROM pg_am WHERE amtype = 'i';\namname\n−−−−−−−−\nbtree\nhash\ngist\ngin\nspgist\nbrin\n(6 rows)\nСледование идее расширяемости предполагает возможность добавлять и\nновые методы доступа без изменения ядра. Один такой пример (метод\nbloom)включенвстандартныйнаборрасширений.\nНесмотрянавсеразличиямеждутипамииндексов,вконечномсчетелюбой\nиз них устанавливает соответствие между ключом (например, значением\nпроиндексированного столбца) и версиями строктаблицы,в которых этот с.415\nключ встречается. В качестве ссылки используется шестибайтный иденти-\nфикаторверсиистроки(tupleid,tid).Знаяключилинекоторуюинформацию\nонем,можнобыстропрочитатьтеверсиистрок,вкоторыхможетнаходить-\nсянужнаяинформация,непросматриваявсютаблицуполностью.\n381",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.662120"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 383,
    "chapter": null,
    "section": "19.1 Индексы и расширяемость",
    "text": "Глава19. Индексныеметодыдоступа\nЧтобыновыйметоддоступаможнобылодобавитькакрасширение,выделен\nобщиймеханизминдексирования.Егоосновнойзадачейявляетсяполучение\nидентификаторовверсийстрокотметодадоступаиработасними:\n• чтениеданныхизсоответствующихверсийстроктаблицы;\nс.97 • проверкавидимостиверсийстроквснимкеданных;\n• перепроверкаусловий,еслиметоднегарантируетихвыполнения.\nМеханизминдексированияучаствуетвисполнениипланов,построенныхна\nэтапе оптимизации.Оптимизатор,перебирая и оценивая различные пути\nвыполнения запроса,должен знать свойства всех потенциально примени-\nмыхметодовдоступа:можетлиметодотдаватьданныесразувнужномпо-\nрядке или надо отдельно предусмотреть сортировку? можетли метод вер-\nнутьнесколькопервыхзначенийилитольковсювыборкусразу?итакдалее.\nИнформация о методе доступа нужна не только оптимизатору.При созда-\nниииндексанадорешить:допускаетлиметодсозданиесоставногоиндекса?\nможетлиданныйиндексобеспечитьуникальность?\nМеханизминдексированияпозволяетработатьссамымиразнымиметода-\nмидоступа;дляэтогометоддоступадолженреализоватьопределенныйин-\nтерфейс,сообщивосвоихвозможностяхиособенностях.\nВзадачиметодадоступавходят:\n• реализацияалгоритмовпостроенияиндекса,вставкииудалениястрок;\n• организацияразбиенияданныхиндексапостраницам(дляработысме-\nс.179 неджеромбуферногокеша);\nс.125 • реализацияалгоритмаочистки;\nс.295 • установкаблокировокдлякорректногоконкурентноговыполнения;\nс.201 • формированиежурналапредзаписи;\n• поискинформациивиндексепоключу;\n• оценкастоимостииспользованияиндекса.\n382",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.693861"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 384,
    "chapter": null,
    "section": "19.1 Индексыирасширяемость",
    "text": "19.1. Индексыирасширяемость\nРасширяемость проявляется и в том, что в систему могут добавляться но-\nвыетипыданных,прокоторыеметодудоступазаранееничегонеизвестно.\nПоэтомуметодыдоступаопределяютсобственныеинтерфейсыдляподклю-\nченияпроизвольныхтиповданных.\nЧтобы значения определенного типа можно было использовать с опреде-\nленнымметодомдоступа,нужнореализоватьэтотинтерфейс,предоставив\nоператоры,длякоторыхпримениминдекси,возможно,некоторыевспомо-\nгательныеопорныефункции.Такойнабороператоровифункцийназывается\nклассомоператоров.\nЧастьлогикииндексированияприэтомнаходитсявсамомметодедоступа,\nа часть оказывается вынесенной в класс операторов. Это довольно произ-\nвольноеделение:еслидляB-деревьеввсялогика«зашита»вметодедоступа,\nто некоторыеметодымогутпредоставлятьлишьосновной каркас,отдавая\nвсесущественныедеталинаоткупконкретнымклассамоператоров.Вомно-\nгихслучаяхдляодногоитогожетипаданныхсуществуетнесколькоклассов\nоператоров с отличающимсяповедением,среди которых пользовательмо-\nжетвыбратьнаиболееподходящий.\nНебольшойфрагментобщейкартиныпоказаннарисунке:\nbool_ops boolean\nint4_ops integer\nbtree\ntext_ops\ntext\nМеханизм text_pattern_ops\nиндексирования\ngist_int4_ops\ngist gist_text_ops\npoint_ops point\nметодыдоступа классыоператоров типыданных\n383",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.727399"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 385,
    "chapter": null,
    "section": "19.2 Классы и семейства операторов",
    "text": "Глава19. Индексныеметодыдоступа\n19.2. Классы и семейства операторов\nКласс операторов\nИнтерфейс метода доступа1 реализуется классом операторов2 — набором\nоператоров и опорных функций, который используется методом доступа\nдляработысконкретнымтипомданных.\nКлассы операторов хранятся в системном каталоге в таблице pg_opclass.\nПолныеданныедлярисункавышеможнобылобыполучитьзапросом:\n=> SELECT amname, opcname, opcintype::regtype\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid;\namname | opcname | opcintype\n−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nbtree | array_ops | anyarray\nhash | array_ops | anyarray\nbtree | bit_ops | bit\nbtree | bool_ops | boolean\n...\nbrin | pg_lsn_minmax_multi_ops | pg_lsn\nbrin | pg_lsn_bloom_ops | pg_lsn\nbrin | box_inclusion_ops | box\n(177 rows)\nВ большинстве случаев про классы операторов не требуется ничего знать.\nОбычно мы просто создаем индекс, и при этом используется некоторый\nклассоператоровпоумолчанию.\nНапример,вотклассыоператоровдляB-дереваитипаtext.Одинизимею-\nщихсяклассовобязательнопомечендляиспользованияпоумолчанию:\n=> SELECT opcname, opcdefault\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid\nWHERE amname = 'btree'\nAND opcintype = 'text'::regtype;\n1 postgrespro.ru/docs/postgresql/17/xindex.\n2 postgrespro.ru/docs/postgresql/17/indexes-opclass.\n384",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.762351"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 386,
    "chapter": null,
    "section": "19.2 Классыисемействаоператоров",
    "text": "19.2. Классыисемействаоператоров\nopcname | opcdefault\n−−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−\ntext_ops | t\nvarchar_ops | f\ntext_pattern_ops | f\nvarchar_pattern_ops | f\n(4 rows)\nПривычнаякомандасозданияиндексавыглядиттак:\nCREATE INDEX ON aircrafts(model, range);\nНоэтопростосокращениедляразвернутоговарианта:\nCREATE INDEX ON aircrafts\nUSING btree -- метод доступа по умолчанию\n(\nmodel text_ops, -- класс операторов по умолчанию для text\nrange int4_ops -- класс операторов по умолчанию для integer\n);\nЕслинужениндекскакого-тодругоготипаилинеобходимонестандартное\nповедение, потребуется явно указать желаемый метод доступа или класс\nоператоров.\nКласс операторов, созданный для некоторого метода доступа и некоторо-\nготипаданных,должен содержатьнабор операторов,которые принимают\nпараметрыэтоготипаиимеютсемантику,предусмотреннуюэтимметодом\nдоступа.\nНапример,методдоступаbtreeопределяетпятьобязательныхоператоров\nсравнения.Любойклассоператоровдлянегодолженсодержатьвсепять:\n=> SELECT opcname, amopstrategy, amopopr::regoperator\nFROM pg_am am\nJOIN pg_opfamily opf ON opfmethod = am.oid\nJOIN pg_opclass opc ON opcfamily = opf.oid\nJOIN pg_amop amop ON amopfamily = opcfamily\nWHERE amname = 'btree'\nAND opcname IN ('text_ops', 'text_pattern_ops')\nAND amoplefttype = 'text'::regtype\nAND amoprighttype = 'text'::regtype\nORDER BY opcname, amopstrategy;\n385",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.797562"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 387,
    "chapter": null,
    "section": "19.2 Классыисемействаоператоров",
    "text": "Глава19. Индексныеметодыдоступа\nopcname | amopstrategy | amopopr\n−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−\ntext_ops | 1 | <(text,text)\ntext_ops | 2 | <=(text,text)\ntext_ops | 3 | =(text,text)\ntext_ops | 4 | >=(text,text)\ntext_ops | 5 | >(text,text)\ntext_pattern_ops | 1 | ~<~(text,text)\ntext_pattern_ops | 2 | ~<=~(text,text)\ntext_pattern_ops | 3 | =(text,text)\ntext_pattern_ops | 4 | ~>=~(text,text)\ntext_pattern_ops | 5 | ~>~(text,text)\n(10 rows)\nСемантика оператора, подразумеваемая методом доступа, отражена в но-\nмерестратегииamopstrategy1.Например,дляbtree стратегия1означает\n«меньше»,2—«меньше или равно» итакдалее.Сами операторы при этом\nмогутиметьпроизвольныеназвания.\nВ приведенном примере обычные операторы и операторы стильдой отли-\nчаются тем, что последние не учитывают правила сортировки (collation)2\nисравниваютстрокипобайтово.Темнеменееобавариантареализуютодни\nитежесмысловыеоперациисравнения.\nКлассоператоровtext_pattern_opsпозволяетпреодолетьограничениена\nподдержку оператора ~~ (который соответствует конструкции LIKE). В ба-\nзеданныхсправиломсортировки,отличнымотC,этотоператорнеможет\nиспользоватьобычныйиндекспотекстовомуполю:\n=> SELECT datcollate FROM pg_database\nWHERE datname = current_database();\ndatcollate\n−−−−−−−−−−−−−\nen_US.UTF−8\n(1 row)\n=> CREATE INDEX ON tickets(passenger_name);\n=> EXPLAIN (costs off)\nSELECT * FROM tickets WHERE passenger_name LIKE 'ELENA%';\n1 postgrespro.ru/docs/postgresql/17/xindex#XINDEX-STRATEGIES.\n2 postgrespro.ru/docs/postgresql/17/collation;\npostgrespro.ru/docs/postgresql/17/indexes-collations.\n386",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.834527"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 388,
    "chapter": null,
    "section": "19.2 Классыисемействаоператоров",
    "text": "19.2. Классыисемействаоператоров\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on tickets\nFilter: (passenger_name ~~ 'ELENA%'::text)\n(2 rows)\nДругоедело—индекссклассомоператоровtext_pattern_ops:\n=> CREATE INDEX tickets_passenger_name_pattern_idx\nON tickets(passenger_name text_pattern_ops);\n=> EXPLAIN (costs off)\nSELECT * FROM tickets WHERE passenger_name LIKE 'ELENA%';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on tickets\nFilter: (passenger_name ~~ 'ELENA%'::text)\n−> Bitmap Index Scan on tickets_passenger_name_pattern_idx\nIndex Cond: ((passenger_name ~>=~ 'ELENA'::text) AND\n(passenger_name ~<~ 'ELENB'::text))\n(5 rows)\nОбратите внимание,как изменилосьвыражение в условии Index Cond.Для\nпоискаиспользуетсятолькопрефиксшаблонадосимвола%,алишниесовпа-\nденияотсеиваютсяприперепроверкеусловиемFilter.Классоператоровдля\nметодадоступаbtreeнесодержитоператорасравненияпошаблону,иедин-\nственныйспособиспользоватьB-дерево—переписатьусловиеспомощью\nоператоровсравнения.Операторыизклассаtext_pattern_opsдействуют\nбезучетаправилсортировки,чтоидаетвозможностьзаменитьусловиена\nэквивалентное1.\nИндексможетиспользоватьсядляускорениядоступапоусловию,если\n1) условие имеет вид «индексированный-столбец оператор выражение»\n(а если для оператора указан коммутирующий оператор2, то и «выра-\nжениеоператориндексированный-столбец»)3\n2) иоператорвходитвклассоператоров,указанныйдляиндексированного-\nстолбцаприсозданиииндекса.\n1 backend/utils/adt/like_support.c.\n2 postgrespro.ru/docs/postgresql/17/xoper-optimization#id-1.8.3.18.6.\n3 backend/optimizer/path/indxpath.c,функцияmatch_clause_to_indexcol.\n387",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.874227"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 389,
    "chapter": null,
    "section": "19.2 Классыисемействаоператоров",
    "text": "Глава19. Индексныеметодыдоступа\nНапример,такойзапросможетиспользоватьиндекс:\n=> EXPLAIN (costs off)\nSELECT * FROM tickets WHERE 'ELENA BELOVA' = passenger_name;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Scan using tickets_passenger_name_idx on tickets\nIndex Cond: (passenger_name = 'ELENA BELOVA'::text)\n(2 rows)\nОбратите внимание на то, как переставлены аргументы в условии Index\nCond: на этапе выполнения индексированное поле должно бытьлевым ар-\nгументом оператора. При перестановке оператор заменяется на коммути-\nрующий;вданномслучаеэтототжесамыйоператор,посколькуотношение\nравенствакоммутативно.\nАследующий запрос в принципе не можетиспользоватьобычный индекс,\nпосколькувместоименистолбцавусловиистоитвызовфункции:\n=> EXPLAIN (costs off)\nSELECT * FROM tickets WHERE initcap(passenger_name) = 'Elena Belova';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on tickets\nFilter: (initcap(passenger_name) = 'Elena Belova'::text)\n(2 rows)\nВтакомслучаеможноприменитьиндексповыражению1,указавприегосо-\nзданиинестолбец,апроизвольноевыражение:\n=> CREATE INDEX ON tickets( (initcap(passenger_name)) );\n=> EXPLAIN (costs off)\nSELECT * FROM tickets WHERE initcap(passenger_name) = 'Elena Belova';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on tickets\nRecheck Cond: (initcap(passenger_name) = 'Elena Belova'::text)\n−> Bitmap Index Scan on tickets_initcap_idx\nIndex Cond: (initcap(passenger_name) = 'Elena Belova'::text)\n(4 rows)\n1 postgrespro.ru/docs/postgresql/17/indexes-expressional.\n388",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.913546"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 390,
    "chapter": null,
    "section": "19.2 Классыисемействаоператоров",
    "text": "19.2. Классыисемействаоператоров\nВыражениеможетзависетьтолькоотзначенийполейвтабличнойстрокеи\nне должно зависеть ни отсостояния других данных в базе,ни отнастроек\n(например,отлокали).Иными словами,если выражение содержитвызовы\nфункций, то эти функции обязаны иметь и соблюдать категорию измен-\nчивостиIMMUTABLE1.Впротивномслучаерезультатзапроса,выполненного\nсиндекснымдоступом,можетотличатьсяотрезультататогожезапроса,вы-\nполненногополнымсканированиемтаблицы.\nКромесобственнооператоров,классоператоровможетпредоставлятьопор-\nные функции2,необходимые методу.Например,методдоступа btree опре-\nделяет пять опорных функций3,из которыхтолько первая (сравнивающая\nдвазначения)являетсянеобходимой,аостальныемогутотсутствовать:\n=> SELECT amprocnum, amproc::regproc\nFROM pg_am am\nJOIN pg_opfamily opf ON opfmethod = am.oid\nJOIN pg_opclass opc ON opcfamily = opf.oid\nJOIN pg_amproc amproc ON amprocfamily = opcfamily\nWHERE amname = 'btree'\nAND opcname = 'text_ops'\nAND amproclefttype = 'text'::regtype\nAND amprocrighttype = 'text'::regtype\nORDER BY amprocnum;\namprocnum | amproc\n−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−\n1 | bttextcmp\n2 | bttextsortsupport\n4 | btvarstrequalimage\n(3 rows)\nСемейство операторов\nКласс операторов всегда входит в какое-либо семейство операторов4 (таб-\nлицаpg_opfamilyсистемногокаталога).Приэтомводнообщеесемейство\nмогутвходитьнесколько классов,если они работаютодинаковым образом\nспохожимитипамиданных.\n1 postgrespro.ru/docs/postgresql/17/xfunc-volatility.\n2 postgrespro.ru/docs/postgresql/17/xindex#XINDEX-SUPPORT.\n3 postgrespro.ru/docs/postgresql/17/btree-support-funcs.\n4 postgrespro.ru/docs/postgresql/17/xindex#XINDEX-OPFAMILY.\n389",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.949314"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 391,
    "chapter": null,
    "section": "19.2 Классыисемействаоператоров",
    "text": "Глава19. Индексныеметодыдоступа\nНапример,семействоinteger_opsвключаетнесколькоклассовдляразных\nпоразмеру,ноодинаковыхпосмыслучисловыхтипов:\n=> SELECT opcname, opcintype::regtype\nFROM pg_am am\nJOIN pg_opfamily opf ON opfmethod = am.oid\nJOIN pg_opclass opc ON opcfamily = opf.oid\nWHERE amname = 'btree'\nAND opfname = 'integer_ops';\nopcname | opcintype\n−−−−−−−−−−+−−−−−−−−−−−\nint2_ops | smallint\nint4_ops | integer\nint8_ops | bigint\n(3 rows)\nАвсемействоdatetime_opsвходятклассыоператоровдляработысдатами:\n=> SELECT opcname, opcintype::regtype\nFROM pg_am am\nJOIN pg_opfamily opf ON opfmethod = am.oid\nJOIN pg_opclass opc ON opcfamily = opf.oid\nWHERE amname = 'btree'\nAND opfname = 'datetime_ops';\nopcname | opcintype\n−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\ndate_ops | date\ntimestamptz_ops | timestamp with time zone\ntimestamp_ops | timestamp without time zone\n(3 rows)\nКаждыйклассоператоровработаетскаким-тооднимтипом.Семействоже\nвключаетиоператоры,принимающиеразныетипыданных:\n=> SELECT opcname, amopopr::regoperator\nFROM pg_am am\nJOIN pg_opfamily opf ON opfmethod = am.oid\nJOIN pg_opclass opc ON opcfamily = opf.oid\nJOIN pg_amop amop ON amopfamily = opcfamily\nWHERE amname = 'btree'\nAND opfname = 'integer_ops'\nAND amoplefttype = 'integer'::regtype\nAND amopstrategy = 1\nORDER BY opcname;\n390",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:56.983616"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 392,
    "chapter": null,
    "section": "19.3 Интерфейсмеханизмаиндексирования",
    "text": "19.3. Интерфейсмеханизмаиндексирования\nopcname | amopopr\n−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−\nint2_ops | <(integer,bigint)\nint2_ops | <(integer,smallint)\nint2_ops | <(integer,integer)\nint4_ops | <(integer,bigint)\nint4_ops | <(integer,smallint)\nint4_ops | <(integer,integer)\nint8_ops | <(integer,bigint)\nint8_ops | <(integer,smallint)\nint8_ops | <(integer,integer)\n(9 rows)\nЗа счет группировки операторов в семейство планировщик может исполь-\nзовать индексдля условий со значениями разныхтипов,нетребуя явного\nприведения.\n19.3. Интерфейс механизма индексирования\nКак и для табличных методов доступа, столбец amhandler таблицы pg_am\nсодержитимяфункции,реализующейинтерфейс1:\n=> SELECT amname, amhandler FROM pg_am WHERE amtype = 'i';\namname | amhandler\n−−−−−−−−+−−−−−−−−−−−−−\nbtree | bthandler\nhash | hashhandler\ngist | gisthandler\ngin | ginhandler\nspgist | spghandler\nbrin | brinhandler\n(6 rows)\nФункциязаполняетинтерфейснуюструктуру2 необходимымизначениями.\nЧастьпредоставляемойинформации—этофункции,выполняющиеотдель-\nныеэлементыобщейработы(например,сканирующиеиндексивозвраща-\nющиеидентификаторыверсийстрок),ачасть—свойстваиндексногомето-\nда,окоторыхдолжензнатьмеханизминдексирования.\n1 postgrespro.ru/docs/postgresql/17/indexam.\n2 include/access/amapi.h.\n391",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:57.014219"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 393,
    "chapter": null,
    "section": "19.3 Интерфейсмеханизмаиндексирования",
    "text": "Глава19. Индексныеметодыдоступа\nВсесвойстваразделенынатриуровня1:\n• свойстваметодадоступа;\n• свойстваконкретногоиндекса;\n• свойстваотдельныхстолбцовиндекса.\nВыделениеуровнейметодадоступаииндексасделаносприцеломнабуду-\nщее: в настоящее время все индексы,созданные на основе одного метода\nдоступа,всегдабудутиметьодинаковыесвойстваэтихдвухуровней.\nСвойства метода доступа\nv.11 К свойствам метода доступа относятся следующие пять (показаны на при-\nмереB-дерева):\n=> SELECT a.amname, p.name, pg_indexam_has_property(a.oid, p.name)\nFROM pg_am a, unnest(array[\n'can_order', 'can_unique', 'can_multi_col',\n'can_exclude', 'can_include'\n]) p(name)\nWHERE a.amname = 'btree';\namname | name | pg_indexam_has_property\n−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−\nbtree | can_order | t\nbtree | can_unique | t\nbtree | can_multi_col | t\nbtree | can_exclude | t\nbtree | can_include | t\n(5 rows)\nCANORDER Возможность получать данные в отсортированном порядке2.\nВнастоящеевремяподдерживаетсятолькоB-деревьями.\nЧтобыполучитьрезультатывнужномпорядке,всегдаможнопроскани-\nроватьтаблицуиотсортироватьполученныеданные:\n1 backend/utils/adt/amutils.c,функцияindexam_property.\n2 postgrespro.ru/docs/postgresql/17/indexes-ordering.\n392",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:57.041790"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 394,
    "chapter": null,
    "section": "19.3 Интерфейсмеханизмаиндексирования",
    "text": "19.3. Интерфейсмеханизмаиндексирования\n=> EXPLAIN (costs off)\nSELECT * FROM seats ORDER BY seat_no;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−\nSort\nSort Key: seat_no\n−> Seq Scan on seats\n(3 rows)\nНоприналичиииндекса,поддерживающегоэтосвойство,можнополу-\nчитьданныесразувнужномпорядке:\n=> EXPLAIN (costs off)\nSELECT * FROM seats ORDER BY aircraft_code;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Scan using seats_pkey on seats\n(1 row)\nCANUNIQUE Поддержка ограничения уникальности и первичного ключа1.\nПрименимотолькокB-деревьям.\nПриобъявленииуникальногоилипервичногоключаавтоматическисо-\nздаетсяуникальныйиндекс,поддерживающийэтоограничениецелост-\nности.\n=> INSERT INTO bookings(book_ref, book_date, total_amount)\nVALUES ('000004', now(), 100.00);\nERROR: duplicate key value violates unique constraint\n\"bookings_pkey\"\nDETAIL: Key (book_ref)=(000004) already exists.\nСдругойстороны,еслинеобъявлятьограничениецелостностиявно,но\nсоздатьуникальныйиндекс,видимыйэффектбудеттакимже:столбец\nнебудетдопускатьдубликатов.Вчемразница?\nОграничениецелостности—декларациясвойства,котороедолжновы-\nполняться,аиндекс—тотмеханизм,которыйэтообеспечивает.Вприн-\nципе,ограничениеможетгарантироватьсяидругимисредствами.\n1 postgrespro.ru/docs/postgresql/17/indexes-unique.\n393",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:57.074548"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 395,
    "chapter": null,
    "section": "19.3 Интерфейсмеханизмаиндексирования",
    "text": "Глава19. Индексныеметодыдоступа\nНапример,PostgreSQL не позволяет создавать глобальные индексы на\nсекционированныхтаблицах,нотемнеменеепозволяетобъявитьуни-\nкальныйключ(есливнеговходитключсекционирования).Вэтомслу-\nчае глобальная уникальность обеспечивается локальными уникальны-\nми индексами на каждой секции итем фактом,что в двух секциях не\nможетбытьодинаковыхзначенийключасекционирования.\nCANMULTICOL Возможность построить составной индекс по нескольким\nстолбцам1.\nСоставной индекс позволяет ускорить поиск по нескольким условиям\nнаразныестолбцытаблицы.Например,таблицаticket_flightsимеет\nсоставнойпервичныйключи,соответственно,индекс:\n=> \\d ticket_flights_pkey\nIndex \"bookings.ticket_flights_pkey\"\nColumn | Type | Key? | Definition\n−−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−+−−−−−−−−−−−−\nticket_no | character(13) | yes | ticket_no\nflight_id | integer | yes | flight_id\nprimary key, btree, for table \"bookings.ticket_flights\"\nПоискперелетапономерубилетаиидентификаторурейсавыполняется\nспомощьюиндекса:\n=> EXPLAIN (costs off)\nSELECT * FROM ticket_flights\nWHERE ticket_no = '0005432001355' AND flight_id = 51618;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Scan using ticket_flights_pkey on ticket_flights\nIndex Cond: ((ticket_no = '0005432001355'::bpchar) AND\n(flight_id = 51618))\n(3 rows)\nКакправило,составнойиндексможетиспользоватьсяидляускорения\nвыборкипоусловиямначастьполей.ВслучаеB-деревапоискбудетэф-\nфективным,толькоеслиусловияохватываютначальныестолбцыизтех,\nпокоторымпостроениндекс:\n1 postgrespro.ru/docs/postgresql/17/indexes-multicolumn.\n394",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:57.111554"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 396,
    "chapter": null,
    "section": "19.3 Интерфейсмеханизмаиндексирования",
    "text": "19.3. Интерфейсмеханизмаиндексирования\n=> EXPLAIN (costs off)\nSELECT * FROM ticket_flights\nWHERE ticket_no = '0005432001355';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Scan using ticket_flights_pkey on ticket_flights\nIndex Cond: (ticket_no = '0005432001355'::bpchar)\n(2 rows)\nВостальныхслучаях(например,приусловиитольконаflights_id)по-\nиск фактически будет ограничен начальными столбцами (если такие\nусловия есть),а остальные условия будутиспользоватьсядля фильтра-\nцииполученныхрезультатов.Нодляиндексовдругихтиповэтоможет с.614\nбытьинетак.\nCANEXCLUDE ПоддержкаограниченияисключенияEXCLUDE1.\nОграничениеисключениягарантирует,чтоусловие,определяемоеопе-\nратором,небудетвыполнятьсядлялюбыхпарстроктаблицы.Дляпро-\nверкиограниченияавтоматическисоздаетсяиндекс;классоператоров\nметодадоступадолженсодержатьвыбранныйоператор.\nВ качестве оператора обычно используется «пересечение» &&. Напри- с.556\nмер,таким образом можно декларативно объявить, что аудитория не\nможетбытьдваждызабронировананаодноитожевремяиличтозда-\nниянакартенемогутнакладыватьсядругнадруга.\nС оператором «равно» ограничение исключения приобретает смысл\nограниченияуникальности:запрещаетсяналичиевтаблицедвухстрок\nссовпадающимизначениямиключевыхстолбцов.Темнеменееэтоне\nтожесамое,чтоограничениеуникальности:вчастности,наключогра-\nниченияисключениянельзяссылатьсявовнешнихключах,егонельзя\nиспользоватьвофразеONCONFLICT.\nCANINCLUDE Возможностьдобавитькиндексустолбцы,неявляющиесяча- v.11\nстьюиндексногоключа,чтобысделатьиндекспокрывающим. с.412\nТак,например,можнодобавитьдополнительныестолбцыкуникально-\nмуиндексу.Такойиндексбудетгарантироватьуникальностьзначений\n1 postgrespro.ru/docs/postgresql/17/ddl-constraints#DDL-CONSTRAINTS-EXCLUSION.\n395",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:57.149204"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 397,
    "chapter": null,
    "section": "19.3 Интерфейсмеханизмаиндексирования",
    "text": "Глава19. Индексныеметодыдоступа\nв ключевых столбцах,позволяя при этом получать значения дополни-\nтельныхстолбцовбезобращенияктаблице:\n=> CREATE UNIQUE INDEX ON flights(flight_id) INCLUDE (status);\n=> EXPLAIN (costs off)\nSELECT status FROM flights WHERE flight_id = 51618;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Only Scan using flights_flight_id_status_idx on flights\nIndex Cond: (flight_id = 51618)\n(2 rows)\nСвойств на самом деле гораздо больше, но многие недоступны на уровне\nSQL1.Вотнекоторыеизних:\nс.288 CANPREDLOCKS Поддержкапредикатныхблокировок.\nОтсутствует у методов доступа spgist и brin; при сканировании ин-\nдексовтакихтиповнауровнеизоляцииSerializableпредикатныеблоки-\nровкибудутустанавливатьсянавсютаблицу,какприпоследовательном\nсканировании,чтоприведеткснижениюпроизводительности.\nCANBUILDPARALLEL Возможность построения индекса несколькими про-\nv.17 цессамипараллельно.Поддерживаетсяметодамидоступаbtreeиbrin.\nСвойства индекса\nСвойства, относящиеся к индексу (показаны на примере существующего):\n=> SELECT p.name, pg_index_has_property('seats_pkey', p.name)\nFROM unnest(array[\n'clusterable', 'index_scan', 'bitmap_scan', 'backward_scan'\n]) p(name);\nname | pg_index_has_property\n−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−\nclusterable | t\nindex_scan | t\nbitmap_scan | t\nbackward_scan | t\n(4 rows)\n1 include/access/amapi.h,структураIndexAmRoutine.\n396",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:57.182927"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 398,
    "chapter": null,
    "section": "19.3 Интерфейсмеханизмаиндексирования",
    "text": "19.3. Интерфейсмеханизмаиндексирования\nCLUSTERABLE Возможность физически переместить версии строк таблицы\nв соответствии с порядком,в которомданный индекс выдаетих иден-\nтификаторыприиндексномсканировании. с.348\nЭтосвойствоопределяетдопустимостьвыполнениякомандыCLUSTER.\nINDEXSCAN Поддержкаиндексногосканирования. с.401\nСвойствоозначает,чтометоддоступаумеетвыдаватьидентификаторы\nверсийстрокпоодному.Можетпоказатьсястранным,ноневсеиндексы\nподдерживаютэтосвойство.\nBITMAPSCAN Поддержкасканированияпобитовойкарте. с.414\nСвойствоозначает,чтометоддоступаможетпостроитьивернутьбито-\nвуюкартусразуповсемидентификаторамверсийстрок.\nBACKWARDSCAN Возможность возвращать результат в порядке, обратном\nуказанномуприсозданиииндекса.\nЭто свойство актуально,только если метод доступа поддерживает ин-\nдексноесканирование.\nСвойства столбцов\nНаконец,свойствастолбцов:\n=> SELECT p.name,\npg_index_column_has_property('seats_pkey', 1, p.name)\nFROM unnest(array[\n'asc', 'desc', 'nulls_first', 'nulls_last', 'orderable',\n'distance_orderable', 'returnable', 'search_array', 'search_nulls'\n]) p(name);\nname | pg_index_column_has_property\n−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nasc | t\ndesc | f\nnulls_first | f\nnulls_last | t\norderable | t\ndistance_orderable | f\nreturnable | t\nsearch_array | t\nsearch_nulls | t\n(9 rows)\n397",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:57.213594"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 399,
    "chapter": null,
    "section": "19.3 Интерфейсмеханизмаиндексирования",
    "text": "Глава19. Индексныеметодыдоступа\nASC,DESC,NULLSFIRST,NULLSLAST Упорядоченностьзначенийстолбца.\nЭти свойства определяют, хранятся значения в порядке возрастания\nс.337 илиубыванияигденаходятсянеопределенныезначения—дообычных\nзначений или после. Все свойства из этой группы применимы только\nкB-деревьям.\nORDERABLE Возможностьупорядочиватьзначенияданногостолбцавпред-\nложенииORDERBY.\nЭтосвойствотакжеприменимотолькокB-деревьям.\nс.398 DISTANCEORDERABLE Поддержкаоператоровупорядочивания1.\nВ отличие от обычных индексных операторов,возвращающих логиче-\nское значение,операторы упорядочивания возвращаютвещественное\nчисло—«расстояние» отодного аргументадодругого.Индекс поддер-\nживаеттакиеоператорывпредложенииORDERBY.\nНапример, с помощью оператора упорядочивания <-> можно найти\nаэропорты,ближайшиекзаданнойточке:\n=> CREATE INDEX ON airports_data USING gist(coordinates);\n=> EXPLAIN (costs off)\nSELECT * FROM airports\nORDER BY coordinates <-> point (43.578,57.593)\nLIMIT 3;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nLimit\n−> Index Scan using airports_data_coordinates_idx on airpo...\nOrder By: (coordinates <−> '(43.578,57.593)'::point)\n(3 rows)\nRETURNABLE Возможность получения данных из индекса без обращения\nс.409 ктаблице,тоестьподдержкасканированиятолькоиндекса.\nСвойство определяет,позволяетли индексная структура восстановить\nпроиндексированные значения. Это возможно не всегда; например,\nнекоторыеиндексымогутсохранятьнесамизначения,аиххеш-коды.\nВтакихслучаяхнебудетработатьисвойствоCANINCLUDE.\n1 postgrespro.ru/docs/postgresql/17/xindex#XINDEX-ORDERING-OPS.\n398",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:57.251175"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 400,
    "chapter": null,
    "section": "19.3 Интерфейсмеханизмаиндексирования",
    "text": "19.3. Интерфейсмеханизмаиндексирования\nSEARCHARRAY Поддержкапоисканесколькихзначенийизмассива.\nТакая необходимость возникает не только при использовании масси-\nвовкактаковых.Например,планировщикпреобразуетконструкциюIN\n(список)впоискпомассиву:\n=> EXPLAIN (costs off)\nSELECT * FROM bookings\nWHERE book_ref IN ('C7C821', 'A5D060', 'DDE1BB');\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Scan using bookings_pkey on bookings\nIndex Cond: (book_ref = ANY\n('{C7C821,A5D060,DDE1BB}'::bpchar[]))\n(3 rows)\nЕсли индексный метод не умеет работать с такими операторами, при\nисполнениипланапотребуетсянесколькоитерацийдляпоискаодиноч-\nныхзначений(чтоможетсказатьсянаэффективности).\nSEARCHNULLS ВозможностьпоискапоусловиямISNULLиISNOTNULL.\nНадо ли индексировать неопределенные значения? Это дает возмож-\nностьиспользоватьиндексдляусловийIS[NOT]NULL,атакжевкачест-\nвепокрывающегоиндексаприполномотсутствииусловийнатаблицу\n(посколькувэтомслучаеиндексдолженвернутьданныевсехстроктаб-\nлицы, в том числе и с неопределенными значениями). Зато без NULL\nиндексможетполучитьсякомпактнее.\nРешениепринимаютразработчикиметодадоступа,нообычнонеопре-\nделенныезначениявсе-такииндексируются.\nЕсли неопределенные значения в индексе не нужны,их можно исклю-\nчить,построив частичный индекс1 только потем строкамтаблицы,ко-\nторыепредставляютинтерес.Например:\n=> CREATE INDEX ON flights(actual_arrival)\nWHERE actual_arrival IS NOT NULL;\nCREATE INDEX\n1 postgrespro.ru/docs/postgresql/17/indexes-partial.\n399",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:57.286609"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 401,
    "chapter": null,
    "section": "19.3 Интерфейсмеханизмаиндексирования",
    "text": "Глава19. Индексныеметодыдоступа\n=> EXPLAIN (costs off)\nSELECT * FROM flights\nWHERE actual_arrival = '2017-06-13 10:33:00+03';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Scan using flights_actual_arrival_idx on flights\nIndex Cond: (actual_arrival = '2017−06−13 10:33:00+03'::ti...\n(2 rows)\nЧастичныйиндексбудетменьшеполногопоразмеруинебудетобнов-\nлятьсяприизменениистрок,невходящихвиндекс.Внекоторыхслуча-\nях это можетдать ощутимый выигрыш.Конечно,условие в предложе-\nнииWHEREможетбытьлюбым(удовлетворяющимтребованиямкатего-\nрииизменчивостиIMMUTABLE),анетолькопроверкойнеопределенных\nзначений.\nПостроение частичных индексов не зависитотметода доступа и обес-\nпечиваетсямеханизмоминдексирования.\nРазумеется,интерфейсомохваченыневсевозможностииндексныхметодов\nдоступа,атолькоте,о которых необходимо знать заранее,чтобы принять\nправильное решение. Например, нет свойства, которое отражает возмож-\nность неблокирующего создания индекса (CONCURRENTLY). Такие свойства\nопределяютсякодомфункций,реализующихинтерфейс.\n400",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:57.311582"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 402,
    "chapter": null,
    "section": "20.1 Простое индексное сканирование",
    "text": "20\nИндексное сканирование\n20.1. Простое индексное сканирование\nСуществует два базовых варианта работы с идентификаторами версий\nстрок, поставляемыми индексом. Первый из них — индексное сканирова-\nние.Большинствоиндексныхметодов(ноневсе)обладаютсвойствомINDEX\nSCANиподдерживаютэтотспособ. с.397\nОперацияпредставляетсявпланезапросаузломIndexScan1:\n=> EXPLAIN SELECT * FROM bookings\nWHERE book_ref = '9AC0C6' AND total_amount = 48500.00;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Scan using bookings_pkey on bookings\n(cost=0.43..8.45 rows=1 width=21)\nIndex Cond: (book_ref = '9AC0C6'::bpchar)\nFilter: (total_amount = 48500.00)\n(4 rows)\nПрииндексномсканированииметоддоступавозвращаетидентификаторы\nверсий строк по одному за раз2. Механизм индексирования получает оче-\nредной идентификатор,обращается к табличной странице,на которую он\nуказывает,получаетверсиюстрокии,еслионаудовлетворяетправиламви-\nдимости,возвращаетнеобходимыйнаборполей.Процесспродолжается,по-\nкауметодадоступанезакончатсяидентификаторы,подходящиеподусло-\nвиязапроса.\n1 backend/executor/nodeIndexscan.c.\n2 backend/access/index/indexam.c,функцияindex_getnext_tid.\n401",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:57.337840"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 403,
    "chapter": null,
    "section": "20.1 Простое индексное сканирование",
    "text": "Глава20. Индексноесканирование\nВстрокеIndexCondуказываютсятолькотеусловия,которыемогутбытьпро-\nвереныспомощьюиндекса.Дополнительныеусловия,требующиеперепро-\nверкипотаблице,отображаютсявотдельнойстрокеFilter.\nТакимобразом,обращениякиндексуиктаблиценевыделенывдваотдель-\nныхузлаплана,авыполняютсявобщемузлеIndexScan.Хотяисуществует\nспециальныйузелTid Scan1,читающийизтаблицыверсиистрокпоизвест-\nнымидентификаторам:\n=> EXPLAIN SELECT * FROM bookings WHERE ctid = '(0,1)'::tid;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nTid Scan on bookings (cost=0.00..4.01 rows=1 width=21)\nTID Cond: (ctid = '(0,1)'::tid)\n(2 rows)\nОценка стоимости\nОценкаиндексногосканированияскладываетсяизоценкидоступакиндек-\nсуиоценкичтениятабличныхстраниц.\nОчевидно,что индексная частьоценки полностью зависитотконкретного\nметодадоступа.ВслучаеB-дереваосновныерасходыприходятсяначтение\nиндексных страниц и обработку строк в этих страницах. Сколько именно\nстраниц и строк будет прочитано, можно определить, зная общий объем\nс.323 данных и селективность условий.Доступ к индексной странице носит слу-\nчайный характер (страницы, соседствующие друг с другом логически, фи-\nзическимогутрасполагатьсянепредсказуемымобразом).Коценкамтакже\nдобавляются ресурсы процессора на спуск откорнядолистовой страницы\nинавычислениенеобходимыхвыражений2.\nТабличная часть оценки учитывает стоимостьдоступа к страницам и про-\nцессорноевремянаобработкувсехпрочитанныхверсий.Важно,чтооценка\nввода-выводазависитнетолькоотселективностииндексногодоступа,нои\n1 backend/executor/nodeTidscan.c.\n2 backend/utils/adt/selfuncs.c,функцияbtcostestimate;\npostgrespro.ru/docs/postgresql/17/index-cost-estimation.\n402",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:57.373670"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 404,
    "chapter": null,
    "section": "20.1 Простоеиндексноесканирование",
    "text": "20.1. Простоеиндексноесканирование\nот корреляции физического расположения версий строк на диске с тем по-\nрядком,вкоторомметоддоступавыдаетихидентификаторы.\nХороший случай: высокая корреляция\nЕслифизическийпорядокверсийнадискеидеальнокоррелируетслогиче-\nским порядком идентификаторов в индексе, то, читая версии строк одну\nза другой, узел Index Scan будет последовательно переходить от страницы\nкстраницеиобратитсяккаждойизнихтолькоодинраз.\nтабличная\nстраница\nверсиястроки,\nудовлетворяющая\nусловиям\nИнформацияокорреляциисобираетсякакчастьстатистики: с.348\n=> SELECT attname, correlation\nFROM pg_stats WHERE tablename = 'bookings'\nORDER BY abs(correlation) DESC;\nattname | correlation\n−−−−−−−−−−−−−−+−−−−−−−−−−−−−−\nbook_ref | 1\ntotal_amount | 0.0026738467\nbook_date | 8.02188e−05\n(3 rows)\nЗначения,близкие по модулю к единице (какдля столбца book_ref),гово-\nрятовысокойупорядоченности,аблизкиекнулю—наоборот,охаотичном\nраспределении.\nВданномслучаевысокаякорреляциядлястолбцаbook_ref вызвана,конечно,тем,\nчтоданныебылизагруженывтаблицувпорядкевозрастаниязначенийэтогостолбца\n403",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 1,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 2,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 3,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 4,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T15:59:57.408429"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 405,
    "chapter": null,
    "section": "20.1 Простоеиндексноесканирование",
    "text": "Глава20. Индексноесканирование\nи не изменялись.К такой же картине приведетвыполнение команды CLUSTER для\nиндексапоэтомустолбцу.\nНо даже наличие полной корреляции не дает никаких гарантий,что любой запрос\nбудетвозвращатьданные именнов порядкевозрастанияbook_ref.Во-первых,из-\nменение любой строки приведет к перемещению версии строки в конец таблицы.\nВо-вторых, план, использующий индексный доступ по какому-либо другому столб-\nцу,выдастданныевдругомпорядке.Идажепоследовательноесканированиеможет\nс.190 начаться не с начала таблицы.Поэтому если требуется определенный порядок,его\nнеобходимоуказатьвпредложенииORDERBY.\nВотпримериндексногосканированиябольшогоколичествастрок:\n=> EXPLAIN SELECT * FROM bookings WHERE book_ref < '100000';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Scan using bookings_pkey on bookings\n(cost=0.43..4640.91 rows=132999 width=21)\nIndex Cond: (book_ref < '100000'::bpchar)\n(3 rows)\nСелективностьусловияпооценкепланировщикасоставляет:\n=> SELECT round(132999::numeric/reltuples::numeric, 4)\nFROM pg_class WHERE relname = 'bookings';\nround\n−−−−−−−−\n0.0630\n(1 row)\nс.344 Это близко к оценке 1 ,которую можно дать из общих соображений,зная\n16\nдиапазонзначенийbook_refот000000доFFFFFF.\nИндексная часть оценки ввода-вывода для B-дерева учитывает стоимость\nчтениянеобходимогоколичествастраниц.Индексныестроки,соответству-\nющие любому условию,которое поддерживается B-деревом,упорядочены\nинаходятсявлогическисвязанныхлистовыхстраницах,поэтомуколичест-\nво прочитанных индексных страниц оценивается произведением размера\nиндексанаселективность.Нофизическиэтистраницынеупорядочены,по-\nэтомучтениеноситслучайныйхарактер.\n404",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:57.446746"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 406,
    "chapter": null,
    "section": "20.1 Простоеиндексноесканирование",
    "text": "20.1. Простоеиндексноесканирование\nРесурсы процессора тратятся на обработку всех прочитанных индексных\nстрок (стоимость обработки одной строки оценивается значением пара-\nметраcpu_index_tuple_cost)ивычислениеусловиядлякаждойизэтихстрок 0.005\n(вданномслучаеусловиесодержитодиноператор;стоимостьеговычисле-\nнияоцениваетсязначениемпараметраcpu_operator_cost). 0.0025\nТабличныйввод-выводрассматриваетсякакпоследовательноечтениенеоб-\nходимого количества страниц.При идеальной корреляции табличные вер-\nсиистрокбудутфизическисоседствоватьдругсдругом,поэтомуколичество\nстраниц оценивается произведением размера таблицы на селективность.\nК стоимости ввода-вывода добавляются затраты на обработку всех прочи-\nтанныхверсийстрок;стоимостьобработкиоднойверсииоцениваетсязна-\nчениемпараметраcpu_tuple_cost. 0.01\n=> WITH costs(idx_cost, tbl_cost) AS (\nSELECT\n( SELECT round(\ncurrent_setting('random_page_cost')::real * pages +\ncurrent_setting('cpu_index_tuple_cost')::real * tuples +\ncurrent_setting('cpu_operator_cost')::real * tuples\n)\nFROM (\nSELECT relpages * 0.0630 AS pages, reltuples * 0.0630 AS tuples\nFROM pg_class WHERE relname = 'bookings_pkey'\n) c\n),\n( SELECT round(\ncurrent_setting('seq_page_cost')::real * pages +\ncurrent_setting('cpu_tuple_cost')::real * tuples\n)\nFROM (\nSELECT relpages * 0.0630 AS pages, reltuples * 0.0630 AS tuples\nFROM pg_class WHERE relname = 'bookings'\n) c\n)\n)\nSELECT idx_cost, tbl_cost, idx_cost + tbl_cost AS total FROM costs;\nidx_cost | tbl_cost | total\n−−−−−−−−−−+−−−−−−−−−−+−−−−−−−\n2457 | 2180 | 4637\n(1 row)\n405",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:57.483008"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 407,
    "chapter": null,
    "section": "20.1 Простоеиндексноесканирование",
    "text": "Глава20. Индексноесканирование\nФормулапоказываетлогикувычислениястоимости,ирезультатхорошосо-\nответствуетоценке планировщика,хотя и не являетсяточным.Получение\nточного значения потребовало бы учетадеталей,на которых мы не будем\nостанавливаться.\nПлохой случай: низкая корреляция\nСитуация с доступом к таблице меняется, когда корреляция оказывается\nнизкой. Создадим индекс по столбцу book_date, имеющему практически\nнулевуюкорреляциюсиндексом,ипосмотримназапрос,выбирающийпри-\nблизительнотужедолюстрок,чтоивпредыдущемпримере.Индексныйдо-\nступоказываетсянастолькодорогим,чтопланировщиквыбираетего,толь-\nкоеслизапретитьемувсеальтернативы:\n=> CREATE INDEX ON bookings(book_date);\n=> SET enable_seqscan = off;\n=> SET enable_bitmapscan = off;\n=> EXPLAIN SELECT * FROM bookings\nWHERE book_date < '2016-08-23 12:00:00+03';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Scan using bookings_book_date_idx on bookings\n(cost=0.43..57121.48 rows=132403 width=21)\nIndex Cond: (book_date < '2016−08−23 12:00:00+03'::timestamp w...\n(3 rows)\nДело в том, что чем ниже корреляция, тем выше вероятность того, что\nследующая версия строки, идентификатор которой выдает метод доступа,\nокажется на другой странице. Поэтому вместо последовательного чтения\nузелIndexScan«скачет»состраницынастраницу,аколичествообращений\nкстраницамвпредельномслучаеможетдостигатьколичествавыбираемых\nверсийстрок.\nОднакобылобынекорректнымпростозаменитьвприведеннойвышефор-\nмуле seq_page_cost на random_page_cost, а relpages — на reltuples. Стои-\nмость,которую мы видим в плане,на порядок меньше полученной таким\nобразомоценки:\n406",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:57.522054"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 408,
    "chapter": null,
    "section": "20.1 Простоеиндексноесканирование",
    "text": "20.1. Простоеиндексноесканирование\n=> WITH costs(idx_cost, tbl_cost) AS (\nSELECT\n( SELECT round(\ncurrent_setting('random_page_cost')::real * pages +\ncurrent_setting('cpu_index_tuple_cost')::real * tuples +\ncurrent_setting('cpu_operator_cost')::real * tuples\n)\nFROM (\nSELECT relpages * 0.0630 AS pages, reltuples * 0.0630 AS tuples\nFROM pg_class WHERE relname = 'bookings_pkey'\n) c\n),\n( SELECT round(\ncurrent_setting('random_page_cost')::real * tuples +\ncurrent_setting('cpu_tuple_cost')::real * tuples\n)\nFROM (\nSELECT relpages * 0.0630 AS pages, reltuples * 0.0630 AS tuples\nFROM pg_class WHERE relname = 'bookings'\n) c\n)\n)\nSELECT idx_cost, tbl_cost, idx_cost + tbl_cost AS total FROM costs;\nidx_cost | tbl_cost | total\n−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−\n2457 | 533330 | 535787\n(1 row)\nДело в том, что модель дополнительно учитывает эффект кеширования.\nЧасто используемые страницы задерживаются в буферном кеше (и в ке-\nше операционной системы), поэтому чем больше кеш, тем больше веро-\nятность найти нужную страницу в нем и избежать дисковой операции.\nДля целей планирования размер кеша определяется значением парамет-\nра effective_cache_size. Чем оно меньше, тем выше оценка количества стра- 4GB\nниц,которыепридетсяпрочитать.Графикпоказываетзависимостьоценки\n407",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 1,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 2,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 3,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 4,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T15:59:57.561839"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 409,
    "chapter": null,
    "section": "20.1 Простоеиндексноесканирование",
    "text": "Глава20. Индексноесканирование\nколичествапрочитанныхстраницотразмератаблицы(дляселективности 1\n2\nислучая,когданастраницепомещаетсядесятьстрок)1:\nобращения рок 0,5\nкстраницам ичестваст sel=\nкол\n5\n0,\nколичество\nстраниц\n0,5\nколичества\nстраниц\nразмертаблицы\neffective_cache_size\nПунктиром на графике показано количество обращений,равное половине\nколичества страниц (лучшийтеоретически возможный случай при идеаль-\nнойкорреляции)иполовинеколичествастрок(худшийслучайпринулевой\nкорреляциииотсутствиикеша).\nПредполагается,чтозначениепараметраeffective_cache_sizeдолжносоответ-\nствовать общему объему памяти, доступному для кеширования (включая\nибуферныйкешPostgreSQL,икешОС).Нопосколькупараметрслужиттоль-\nкодляоценкиинеприводиткреальномувыделениюпамяти,принеобхо-\nдимостиегоможноизменятьибезоглядкинареальныецифры.\nУстановивминимальноезначениепараметра,получимоценкуплана,близ-\nкуюкнаихудшемузначению,вычисленномувышебезучетаэффектакеши-\nрования:\n1 backend/optimizer/path/costsize.c,функцияindex_pages_fetched.\n408",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:57.587669"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 410,
    "chapter": null,
    "section": "20.2 Сканированиетолькоиндекса",
    "text": "20.2. Сканированиетолькоиндекса\n=> SET effective_cache_size = '8kB';\n=> EXPLAIN SELECT * FROM bookings\nWHERE book_date < '2016-08-23 12:00:00+03';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Scan using bookings_book_date_idx on bookings\n(cost=0.43..532745.48 rows=132403 width=21)\nIndex Cond: (book_date < '2016−08−23 12:00:00+03'::timestamp w...\n(3 rows)\n=> RESET effective_cache_size;\n=> RESET enable_seqscan;\n=> RESET enable_bitmapscan;\nСтоимостьтабличноговвода-выводавычисляетсядлядвухрассмотренных\nслучаев — хорошего и плохого, а затем берется промежуточное значение\nвзависимостиотреальнойкорреляции1.\nИтак, индексное сканирование эффективно, когда требуется прочитать\nнекоторуючастьстроктаблицы.Есливерсиистроквтаблицекоррелирова-\nныспорядком,вкоторомметоддоступавыдаетидентификаторы,этачасть\nможетбытьвесьмасущественной.Еслижекорреляцияслабая,тосуменьше-\nниемселективностииндексныйдоступоченьбыстротеряетсвоюпривлека-\nтельность.\n20.2. Сканирование только индекса\nИндекс,содержащийвседанныеизтаблицы,необходимыедлявыполнения\nзапроса,называетсяпокрывающим(covering)дляданногозапроса.Принали-\nчиипокрывающегоиндексаможноизбежатьлишнихобращенийктаблице,\nполучая от метода доступа не идентификаторы версий строк, а сами дан-\nные.Такая вариация индексного сканирования называется сканированием\nтолько индекса2. Она может использоваться теми методами доступа, кото-\nрыеподдерживаютсвойствоRETURNABLE. с.398\n1 backend/optimizer/path/costsize.c,функцияcost_index.\n2 postgrespro.ru/docs/postgresql/17/indexes-index-only-scans.\n409",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:57.624629"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 411,
    "chapter": null,
    "section": "20.2 Сканированиетолькоиндекса",
    "text": "Глава20. Индексноесканирование\nОперацияпредставляетсявпланезапросаузломIndexOnlyScan1:\n=> EXPLAIN SELECT book_ref FROM bookings WHERE book_ref < '100000';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Only Scan using bookings_pkey on bookings\n(cost=0.43..3793.91 rows=132999 width=7)\nIndex Cond: (book_ref < '100000'::bpchar)\n(3 rows)\nНазвание можетнавести на мысль,что узел Index Only Scan никогда не об-\nращается к таблице, но это не так. Индексы в PostgreSQL не содержат ин-\nс.89 формации,позволяющейсудитьовидимостистрок,поэтомуметоддоступа\nвозвращаетданныеизвсех версийстрок,попадающихподусловиепоиска,\nнезависимооттого,видныонитекущейтранзакцииилинет.Видимостьза-\nтемпроверяетсямеханизмоминдексирования.\nНоеслибыприходилоськаждыйраззаглядыватьвтаблицудляопределения\nвидимости,этот метод сканирования ничем не отличался бы от обычного\nиндексногосканирования.Проблемарешаетсятем,чтоPostgreSQLподдер-\nс.32 живает для таблиц карту видимости, в которой процесс очистки отмеча-\nетстраницы,содержащиетолькотакие версии строк,которые видны всем\nтранзакциям,независимоотихснимков.Еслиидентификаторверсиистро-\nки,возвращенныйиндекснымметодом,относитсяктакойстранице,тови-\nдимостьверсииможнонепроверять.\nНа оценку сканирования только индекса влияет доля табличных страниц,\nотмеченныхвкартевидимости.Этаинформациявходитвсобираемуюста-\nтистику:\n=> SELECT relpages, relallvisible\nFROM pg_class WHERE relname = 'bookings';\nrelpages | relallvisible\n−−−−−−−−−−+−−−−−−−−−−−−−−−\n13488 | 13446\n(1 row)\n1 backend/executor/nodeIndexonlyscan.c.\n410",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:57.661191"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 412,
    "chapter": null,
    "section": "20.2 Сканированиетолькоиндекса",
    "text": "20.2. Сканированиетолькоиндекса\nОценка стоимости сканирования только индекса отличается от оценки\nобычногоиндексногосканированиятем,чтостоимостьввода-вывода,свя-\nзанная с доступом к таблице, берется пропорционально доле страниц, не\nвключенных в карту видимости. (Стоимость обработки версий строк про-\nцессоромостаетсябезизменений.)\nПоскольку в данном примере все версии строк на всех страницах видны\nвсем транзакциям, фактически из оценки стоимости полностью исключа-\nетсястоимостьтабличноговвода-вывода:\n=> WITH costs(idx_cost, tbl_cost) AS (\nSELECT\n(\nSELECT round(\ncurrent_setting('random_page_cost')::real * pages +\ncurrent_setting('cpu_index_tuple_cost')::real * tuples +\ncurrent_setting('cpu_operator_cost')::real * tuples\n)\nFROM (\nSELECT relpages * 0.0630 AS pages,\nreltuples * 0.0630 AS tuples\nFROM pg_class WHERE relname = 'bookings_pkey'\n) c\n) AS idx_cost,\n(\nSELECT round(\n(1 - frac_visible) * -- доля страниц вне карты видимости\ncurrent_setting('seq_page_cost')::real * pages +\ncurrent_setting('cpu_tuple_cost')::real * tuples\n)\nFROM (\nSELECT relpages * 0.0630 AS pages,\nreltuples * 0.0630 AS tuples,\nrelallvisible::real/relpages::real AS frac_visible\nFROM pg_class WHERE relname = 'bookings'\n) c\n) AS tbl_cost\n)\nSELECT idx_cost, tbl_cost, idx_cost + tbl_cost AS total\nFROM costs;\nidx_cost | tbl_cost | total\n−−−−−−−−−−+−−−−−−−−−−+−−−−−−−\n2457 | 1333 | 3790\n(1 row)\n411",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:57.695138"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 413,
    "chapter": null,
    "section": "20.2 Сканированиетолькоиндекса",
    "text": "Глава20. Индексноесканирование\nс.106 Наличиеизменений,ещенепопавшихзагоризонтбазыданныхинеобра-\nботанныхочисткой,увеличиваетоценкустоимостиплана(и,соответствен-\nно,уменьшаетпривлекательностьпланадля оптимизатора).Чтобы узнать\nреальноеколичествовынужденныхобращенийктаблице,можноиспользо-\nватькомандуEXPLAINANALYZE.\nВтолькочтосозданнойтаблицеперепроверяетсявидимостьвсехверсий:\n=> CREATE TEMP TABLE bookings_tmp WITH (autovacuum_enabled = off)\nAS SELECT * FROM bookings ORDER BY book_ref;\n=> ALTER TABLE bookings_tmp ADD PRIMARY KEY(book_ref);\n=> ANALYZE bookings_tmp;\n=> EXPLAIN (analyze, timing off, summary off)\nSELECT book_ref FROM bookings_tmp WHERE book_ref < '100000';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Only Scan using bookings_tmp_pkey on bookings_tmp\n(cost=0.43..4716.86 rows=135110 width=7) (actual rows=132109 l...\nIndex Cond: (book_ref < '100000'::bpchar)\nHeap Fetches: 132109\n(4 rows)\nОчисткасоздаеткартувидимости,инеобходимостьвпроверкеотпадает:\n=> VACUUM bookings_tmp;\n=> EXPLAIN (analyze, timing off, summary off)\nSELECT book_ref FROM bookings_tmp WHERE book_ref < '100000';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Only Scan using bookings_tmp_pkey on bookings_tmp\n(cost=0.43..3855.86 rows=135110 width=7) (actual rows=132109 l...\nIndex Cond: (book_ref < '100000'::bpchar)\nHeap Fetches: 0\n(4 rows)\nInclude-индексы\nВозможнаситуация,когдаиндекснельзярасширитьтак,чтобыонсодержал\nвсенеобходимыезапросустолбцы:\n412",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:57.736198"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 414,
    "chapter": null,
    "section": "20.2 Сканированиетолькоиндекса",
    "text": "20.2. Сканированиетолькоиндекса\n• для уникального индекса добавление столбца не будет гарантировать\nуникальностьисходныхстолбцов;\n• типданныхдополнительного столбца можетне иметькласса операто-\nровдляиндексногометодадоступа.\nВ этом случае можно добавить к индексу столбцы,не делая их частью ин- v.11\nдексногоключа.Поискподополнительнымстолбцам,конечно,будетневоз-\nможен,нодлязапросов,включающихэтистолбцы,индекссможетработать\nкакпокрывающий.\nПример показывает замену индекса, автоматически созданного для под-\nдержкипервичногоключа,надругой,сдополнительнымстолбцом:\n=> CREATE UNIQUE INDEX ON bookings(book_ref) INCLUDE (book_date);\n=> BEGIN;\n=> ALTER TABLE bookings DROP CONSTRAINT bookings_pkey CASCADE;\nNOTICE: drop cascades to constraint tickets_book_ref_fkey on table\ntickets\nALTER TABLE\n=> ALTER TABLE bookings ADD CONSTRAINT bookings_pkey PRIMARY KEY\nUSING INDEX bookings_book_ref_book_date_idx; -- новый индекс\nNOTICE: ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index\n\"bookings_book_ref_book_date_idx\" to \"bookings_pkey\"\nALTER TABLE\n=> ALTER TABLE tickets\nADD FOREIGN KEY (book_ref) REFERENCES bookings(book_ref);\n=> COMMIT;\n=> EXPLAIN SELECT book_ref, book_date\nFROM bookings WHERE book_ref < '100000';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Only Scan using bookings_pkey on bookings (cost=0.43..438...\nIndex Cond: (book_ref < '100000'::bpchar)\n(2 rows)\nОченьчастопокрывающиминазываютименнотакиеinclude-индексы,ноэтоневерно.\nИндексявляетсяпокрывающим,еслиегонаборстолбцовпокрываетстолбцы,необхо-\nдимыедляконкретногозапроса.Используютсялиприэтомключевыеполяилиполя,\nдобавленные с помощью предложения INCLUDE,—не играет никакой роли.Более\nтого,одинитотжеиндексможетбытьпокрывающимдляодногозапросаинебыть\nтаковымдлядругого.\n413",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:57.779000"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 415,
    "chapter": null,
    "section": "20.3 Сканирование по битовой карте",
    "text": "Глава20. Индексноесканирование\n20.3. Сканирование по битовой карте\nОграничениеиндексногосканированиясвязаностем,чтоприуменьшении\nкорреляцииувеличиваетсяколичествообращенийкстраницам,ахарактер\nчтенияменяетсяспоследовательногонаслучайный.Этоограничениемож-\nно преодолеть, получив перед обращением к таблице все идентификато-\nрыирасположивихвпорядкевозрастанияномеровстраниц1.Именнотак\nустроенвторойбазовыйспособработысидентификаторами—сканирование\nпо битовой карте. Его могут использовать методы доступа, поддерживаю-\nс.397 щиесвойствоBITMAPSCAN.\nВотличиеотобычногоиндексногосканированияоперацияпредставляется\nвпланезапросадвумяузлами:\n=> CREATE INDEX ON bookings(total_amount);\n=> EXPLAIN\nSELECT * FROM bookings WHERE total_amount = 48500.00;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on bookings (cost=54.63..7045.60 rows=2865 wid...\nRecheck Cond: (total_amount = 48500.00)\n−> Bitmap Index Scan on bookings_total_amount_idx\n(cost=0.00..53.92 rows=2865 width=0)\nIndex Cond: (total_amount = 48500.00)\n(5 rows)\nУзелBitmapIndexScan2обращаетсякметодудоступазабитовойкартойвсех\nидентификаторовверсийстрок3.\nБитовая карта состоит из фрагментов, каждый из которых соответствует\nоднойтабличной странице.Все фрагменты имеютодинаковый размер,до-\nстаточныйдлятого,чтобыохватитьвсеверсиинастранице,сколькобыих\nни было. Это количество ограничено из-за довольно крупного заголовка;\nна странице стандартного размера помещается не больше 256 версий,для\nпредставлениякоторыххватает32байт4.\n1 backend/access/index/indexam.c,функцияindex_getbitmap.\n2 backend/executor/nodeBitmapIndexscan.c.\n3 backend/access/index/indexam.c,функцияindex_getbitmap.\n4 backend/nodes/tidbitmap.c.\n414",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:57.816745"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 416,
    "chapter": null,
    "section": "20.3 Сканированиепобитовойкарте",
    "text": "20.3. Сканированиепобитовойкарте\nУзел Bitmap Heap Scan1 затем просматривает битовую карту фрагмент за\nфрагментом, читает соответствующую очередному фрагменту страницу и\nпроверяетнаэтойстраницевсеверсиистрок,отмеченныевбитовойкарте.\nТакимобразом,страницычитаютсявпорядкевозрастанияномеров,икаж-\nдаястраницачитаетсятолькоодинраз.\nНохарактерчтенияотличаетсяотпоследовательного,посколькувбольшин-\nстве случаев страницы не располагаются подряд друг за другом. Обычная\nпредвыборка операционной системы в этом случае не помогает, и поэто-\nму узел Bitmap Heap Scan — единственный из всех узлов — реализует соб-\nственную предвыборку,асинхронно читая столько страниц,сколько указа-\nно в параметре effective_io_concurrency. Работа этого механизма полагается 1\nнареализациювызоваposix_fadviseвоперационнойсистеме.Еслитакая\nфункция поддерживается,стоитнастроитьпараметр на уровнетабличных\nпространстввсоответствиисвозможностямиаппаратуры.\nАсинхроннаяпредвыборкаиспользуетсятакжеслужебнымипроцессами:\n• приудалениистрокизтаблицы—дляиндексныхстраниц2; v.13\n• прианализе(ANALYZE)—длятабличныхстраниц3; v.14\n• привосстановлениипредвыбираютсястраницыжурнала4. v.15\nГлубинапредвыборкиустанавливаетсяпараметромmaintenance_io_concurrency. 10\nТочностькарты\nЧем больше страниц охвачено версиями строк, соответствующих условию\nзапроса,тембольшеместазанимаетбитоваякарта.Онастроитсявлокаль-\nнойпамятиобслуживающегопроцессаиограниченаразмером,указанным\nв параметре work_mem. Если при построении карты размер достигает пре- 4MB\nдельногозначения,некоторыефрагментыкарты«загрубляются»такимоб-\nразом,чтобыкаждыйбитфрагментасоответствовалцелойстранице,асам\n1 backend/executor/nodeBitmapHeapscan.c.\n2 backend/access/heap/heapam.c,функцияindex_delete_prefetch_buffer.\n3 backend/commands/analyze.c,функцияacquire_sample_rows.\n4 backend/access/transam/xlogprefetch.c.\n415",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:57.853965"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 417,
    "chapter": null,
    "section": "20.3 Сканированиепобитовойкарте",
    "text": "Глава20. Индексноесканирование\nфрагмент охватывал не одну страницу, а диапазон1. Это позволяет умень-\nшитьразмербитовойкарты,пожертвовавприэтомточностью.\nКомандаEXPLAINANALYZEпоказываетточностьпостроеннойкарты:\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT * FROM bookings WHERE total_amount > 150000.00;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on bookings (actual rows=242691 loops=1)\nRecheck Cond: (total_amount > 150000.00)\nHeap Blocks: exact=13447\n−> Bitmap Index Scan on bookings_total_amount_idx (actual rows...\nIndex Cond: (total_amount > 150000.00)\n(5 rows)\nВэтомслучаеобъемапамятихватилодляточной(exact)битовойкарты.\nЕсли уменьшить значение work_mem, часть фрагментов карты будет хра-\nнитьсяспотерейточности(lossy):\n=> SET work_mem = '512kB';\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT * FROM bookings WHERE total_amount > 150000.00;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on bookings (actual rows=242691 loops=1)\nRecheck Cond: (total_amount > 150000.00)\nRows Removed by Index Recheck: 1145721\nHeap Blocks: exact=5178 lossy=8269\n−> Bitmap Index Scan on bookings_total_amount_idx (actual rows...\nIndex Cond: (total_amount > 150000.00)\n(6 rows)\n=> RESET work_mem;\nПричтениитабличнойстраницы,соответствующейгрубомуфрагментуби-\nтовойкарты,необходимоперепроверятьусловиявыборкидлякаждойвер-\nсиистрокинастранице.Условиеперепроверкивсегдаотображаетсявплане\nкак Recheck Cond — независимо от того, выполняется ли перепроверка на\nсамом деле.А количество версий строк,отфильтрованных перепроверкой,\nпоказываетсяотдельно(RowsRemovedbyIndexRecheck).\n1 backend/nodes/tidbitmap.c,функцияtbm_lossify.\n416",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:58.359279"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 418,
    "chapter": null,
    "section": "20.3 Сканированиепобитовойкарте",
    "text": "20.3. Сканированиепобитовойкарте\nПри очень большой выборке может получиться, что битовая карта, даже целиком\nсостоящая из грубых фрагментов, все равно не помещается в память размером\nwork_mem.Вэтомслучаеограничениенесоблюдается,икартазанимаетстолькомес-\nта,скольконеобходимо.Никакогодополнительногоуменьшенияточностиилисброса\nчастифрагментовнадискнепредусмотрено.\nДействия с битовыми картами\nЕсли в запросе условия наложены на несколько полей таблицы и для этих\nполейсозданыразныеиндексы,сканированиебитовойкартыпозволяетис-\nпользовать несколько индексов одновременно1. Для каждого из индексов\nстроятсябитовыекартыверсийстрок,которыезатемлибопобитовологиче-\nскиумножаются(есливыражениясоединеныусловиемAND),либологически\nскладываются(есливыражениясоединеныусловиемOR).Например:\n=> EXPLAIN (costs off)\nSELECT *\nFROM bookings\nWHERE book_date < '2016-08-28'\nAND total_amount > 250000;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on bookings\nRecheck Cond: ((total_amount > '250000'::numeric) AND (book_da...\n−> BitmapAnd\n−> Bitmap Index Scan on bookings_total_amount_idx\nIndex Cond: (total_amount > '250000'::numeric)\n−> Bitmap Index Scan on bookings_book_date_idx\nIndex Cond: (book_date < '2016−08−28 00:00:00+03'::tim...\n(7 rows)\nЗдесь узел BitmapAnd объединяет две битовые карты с помощью битовой\nоперации«и».\nПри объединении двух битовых картв одну2 точные фрагменты остаются\nточными(еслидляновойкартыхватаетместаwork_memвпамяти),ноесли\nхотя бы один из фрагментов грубый,то и результирующий фрагменттоже\nбудетиметьнизкуюточность.\n1 postgrespro.ru/docs/postgresql/17/indexes-ordering.\n2 backend/nodes/tidbitmap.c,функцииtbm_unionиtbm_intersect.\n417",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:58.397114"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 419,
    "chapter": null,
    "section": "20.3 Сканированиепобитовойкарте",
    "text": "Глава20. Индексноесканирование\nОценка стоимости\nВозьмемпримерзапросасосканированиемпобитовойкарте:\n=> EXPLAIN\nSELECT * FROM bookings WHERE total_amount = 28000.00;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on bookings (cost=599.48..14485.96 rows=31878 ...\nRecheck Cond: (total_amount = 28000.00)\n−> Bitmap Index Scan on bookings_total_amount_idx\n(cost=0.00..591.51 rows=31878 width=0)\nIndex Cond: (total_amount = 28000.00)\n(5 rows)\nЗдесьселективностьусловияпооценкепланировщикаравнапримерно\n=> SELECT round(31878::numeric/reltuples::numeric, 4)\nFROM pg_class WHERE relname = 'bookings';\nround\n−−−−−−−−\n0.0151\n(1 row)\nОценка полной стоимости узла Bitmap Index Scan вычисляется так же, как\nстоимостьобычногоиндексногодоступабезучетаобращенийктаблице:\n=> SELECT round(\ncurrent_setting('random_page_cost')::real * pages +\ncurrent_setting('cpu_index_tuple_cost')::real * tuples +\ncurrent_setting('cpu_operator_cost')::real * tuples\n)\nFROM (\nSELECT relpages * 0.0151 AS pages, reltuples * 0.0151 AS tuples\nFROM pg_class WHERE relname = 'bookings_total_amount_idx'\n) c;\nround\n−−−−−−−\n589\n(1 row)\nДляузлаBitmapHeapScanоценкаввода-выводаотличаетсяотаналогичной\nоценки в случае простого индексного сканирования при идеальной корре-\nляции.Битоваякартапозволяетчитатьтабличныестраницывпорядкевоз-\n418",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:58.433753"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 420,
    "chapter": null,
    "section": "20.3 Сканированиепобитовойкарте",
    "text": "20.3. Сканированиепобитовойкарте\nрастания номеров и без повторных обращений, но версии строк, соответ-\nствующие условию, больше не располагаются по соседству друг с другом.\nВместострогопоследовательногокомпактногодиапазона,скореевсего,по-\nтребуетсяпрочитатьнамногобольшестраниц.\nКоличествопрочитанныхстраницоцениваетсяформулой1\n2relpages⋅reltuples⋅sel\nmin ,relpages ,\n(2relpages+reltuples⋅sel )\nа стоимость чтения одной страницы — значением от seq_page_cost до\nrandom_page_cost в зависимости отдоли прочитанных страниц по отноше-\nниюкобщемуколичествустраницвтаблице:\n=> WITH t AS (\nSELECT relpages,\nleast(\n(2 * relpages * reltuples * 0.0151) /\n(2 * relpages + reltuples * 0.0151),\nrelpages\n) AS pages_fetched,\nround(reltuples * 0.0151) AS tuples_fetched,\ncurrent_setting('random_page_cost')::real AS rnd_cost,\ncurrent_setting('seq_page_cost')::real AS seq_cost\nFROM pg_class WHERE relname = 'bookings'\n)\nSELECT pages_fetched,\nrnd_cost - (rnd_cost - seq_cost) *\nsqrt(pages_fetched / relpages) AS cost_per_page,\ntuples_fetched\nFROM t;\npages_fetched | cost_per_page | tuples_fetched\n−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−\n13488 | 1 | 31878\n(1 row)\n1 backend/optimizer/path/costsize.c,функцияcompute_bitmap_pages.\n419",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 1,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 2,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 3,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 4,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T15:59:58.472236"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 421,
    "chapter": null,
    "section": "20.3 Сканированиепобитовойкарте",
    "text": "Глава20. Индексноесканирование\nКак обычно, к оценке ввода-вывода добавляется оценка обработки каж-\nдойпрочитаннойузломверсиистроки.Приточнойбитовойкартеколиче-\nствострокоцениваетсяпроизведениемобщегоколичествастроквтаблице\nна селективность условий.Но когда некоторые фрагменты битовой карты\nнеточны,приходитсяпроверятьвсеверсиистрокнасоответствующихстра-\nницах.\nнеточныйфрагментбитовойкарты точныйфрагмент\nv.11 Поэтому в оценке учитывается предполагаемая доля неточных фрагмен-\nтовбитовойкарты(которуюможнопосчитать,знаяобщееколичествострок\nввыборкеиограничениенаразмербитовойкартыwork_mem)1.\nКоценкетакжедобавляетсяполнаястоимостьперепроверкиусловий(неза-\nвисимоотточностибитовойкарты).\nОценка начальной стоимости узла Bitmap Heap Scan опирается на оценку\nполнойстоимостиузлаBitmapIndexScan,ккоторойдобавляетсястоимость\nработысбитовымикартами:\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on bookings\n(cost=599.48..14485.96 rows=31878 width=21)\nRecheck Cond: (total_amount = 28000.00)\n−> Bitmap Index Scan on bookings_total_amount_idx\n(cost=0.00..591.51 rows=31878 width=0)\nIndex Cond: (total_amount = 28000.00)\n(6 rows)\n1 backend/optimizer/path/costsize.c,функцияcompute_bitmap_pages.\n420",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 1,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 2,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 3,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 4,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T15:59:58.512049"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 422,
    "chapter": null,
    "section": "20.3 Сканированиепобитовойкарте",
    "text": "20.3. Сканированиепобитовойкарте\nВ нашем примере битовая карта полностью точна, и оценка вычисляется\nпримерноследующимобразом1:\n=> WITH t AS (\nSELECT 1 AS cost_per_page,\n13488 AS pages_fetched,\n31878 AS tuples_fetched\n),\ncosts(startup_cost, run_cost) AS (\nSELECT\n(\nSELECT round(\n589 /* оценка нижележащего узла */ +\n0.1 * current_setting('cpu_operator_cost')::real *\nreltuples * 0.0151\n)\nFROM pg_class\nWHERE relname = 'bookings_total_amount_idx'\n),\n(\nSELECT round(\ncost_per_page * pages_fetched +\ncurrent_setting('cpu_tuple_cost')::real * tuples_fetched +\ncurrent_setting('cpu_operator_cost')::real * tuples_fetched\n)\nFROM t\n)\n)\nSELECT startup_cost,\nrun_cost,\nstartup_cost + run_cost AS total_cost\nFROM costs;\nstartup_cost | run_cost | total_cost\n−−−−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−\n597 | 13886 | 14483\n(1 row)\nЕслипланзапросаиспользуетобъединениенесколькихбитовыхкарт,сумма\nстоимостейдоступа к отдельным индексам увеличивается на (небольшую)\nстоимостьсобственнообъединения2.\n1 backend/optimizer/path/costsize.c,функцияcost_bitmap_heap_scan.\n2 backend/optimizer/path/costsize.c,функцииcost_bitmap_and_nodeиcost_bitmap_or_node.\n421",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:58.541211"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 423,
    "chapter": null,
    "section": "20.4 Параллельные версии индексного сканирования",
    "text": "Глава20. Индексноесканирование\n20.4. Параллельные версии индексного сканирования\nВсеспособыиндексногосканирования—обычное,сканированиетолькоин-\nс.366 декса,сканирование по битовой карте—имеют версии для параллельных\nпланов.\nСтоимостьпараллельноговыполненияоцениваетсяаналогичнопоследова-\nтельному,но (как и в случае параллельного последовательного сканирова-\nния)ресурсыпроцессорараспределяютсямеждувсемипараллельнымипро-\nцессами, уменьшая итоговую стоимость. Составляющая ввода-вывода не\nраспределяется, поскольку чтение страниц синхронизируется между про-\nцессамиипроисходитпоследовательно.\nДальшеяпростопокажупримерыпараллельныхплановбезразбораоценок\nстоимости.\nПараллельноеиндексноесканированиеParallelIndexScan:\n=> EXPLAIN SELECT sum(total_amount)\nFROM bookings WHERE book_ref < '400000';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nFinalize Aggregate (cost=19202.81..19202.82 rows=1 width=32)\n−> Gather (cost=19202.59..19202.80 rows=2 width=32)\nWorkers Planned: 2\n−> Partial Aggregate (cost=18202.59..18202.60 rows=1 widt...\n−> Parallel Index Scan using bookings_pkey on bookings\n(cost=0.43..17652.82 rows=219907 width=6)\nIndex Cond: (book_ref < '400000'::bpchar)\n(7 rows)\nПрипараллельномсканированииB-деревавобщейпамятисерверахранит-\nся номер текущей индексной страницы.Начальное значение устанавлива-\nется процессом, который начинает сканирование: он спускается от корня\nдерева к листовой странице и запоминает ее. Рабочие процессы обраща-\nютсяпомеренеобходимостизаследующейиндекснойстраницей,изменяя\nс.514 сохраненный номер. Получив страницу, процесс обрабатывает все подхо-\nдящие строки в ней и читает соответствующие версии строк из таблицы.\nСканирование завершается, когда прочитан весь диапазон значений, удо-\nвлетворяющихусловиюзапроса.\n422",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:58.580309"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 424,
    "chapter": null,
    "section": "20.4 Параллельныеверсиииндексногосканирования",
    "text": "20.4. Параллельныеверсиииндексногосканирования\nПараллельноесканированиетолькоиндексаParallelIndexOnlyScan:\n=> EXPLAIN SELECT sum(total_amount)\nFROM bookings WHERE total_amount < 50000.00;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nFinalize Aggregate (cost=23538.60..23538.61 rows=1 width=32)\n−> Gather (cost=23538.38..23538.59 rows=2 width=32)\nWorkers Planned: 2\n−> Partial Aggregate (cost=22538.38..22538.39 rows=1 widt...\n−> Parallel Index Only Scan using bookings_total_amoun...\n(cost=0.43..21555.27 rows=393244 width=6)\nIndex Cond: (total_amount < 50000.00)\n(7 rows)\nПараллельноесканированиетолькоиндексаотличаетсялишьтем,чтонеоб-\nращаетсяктабличнымстраницам,еслиэтопозволяеткартавидимости.\nИнаконец,параллельноесканированиепобитовойкарте:\n=> EXPLAIN SELECT sum(total_amount)\nFROM bookings WHERE book_date < '2016-10-01';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nFinalize Aggregate (cost=21533.21..21533.22 rows=1 width=32)\n−> Gather (cost=21532.99..21533.20 rows=2 width=32)\nWorkers Planned: 2\n−> Partial Aggregate (cost=20532.99..20533.00 rows=1 widt...\n−> Parallel Bitmap Heap Scan on bookings\n(cost=4891.17..20174.01 rows=143588 width=6)\nRecheck Cond: (book_date < '2016−10−01 00:00:00+03...\n−> Bitmap Index Scan on bookings_book_date_idx\n(cost=0.00..4805.01 rows=344611 width=0)\nIndex Cond: (book_date < '2016−10−01 00:00:00+...\n(10 rows)\nПри сканировании по битовой карте построение карты всегда выполняет-\nся последовательно,одним ведущим процессом; поэтому к названию узла\nBitmap IndexScanнедобавляетсясловоParallel.Когдабитоваякартаготова,\nсканированиетаблицывыполняетсяпараллельновузлеParallelBitmapHeap\nScan.Рабочие процессы обращаются за очереднойтабличной страницей и\nобрабатываютее.\n423",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:58.623149"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 425,
    "chapter": null,
    "section": "20.5 Сравнение методов доступа",
    "text": "Глава20. Индексноесканирование\n20.5. Сравнение методов доступа\nЗависимостьстоимостиразличныхметодовдоступаотселективностиусло-\nвийможнопредставитьследующимобразом:\nстоимость\nin d e x\nsca n\nbitmap\nindex\nscan\nseqscan\nindex\nonly\nscan\nселективность\n0 1\nЭтотграфикимееткачественныйхарактер;конкретныечисла,разумеется,\nбудутзависетьоттаблицыиотпараметровсервера.\nПоследовательное сканирование не зависит от селективности и, начиная\nснекоторойдоливыбираемыхстрок,обычноработаетлучшеостальныхме-\nтодов.\nСтоимостьиндексногосканированиясильнозависитоткорреляциимежду\nфизическим расположением версий строк и порядком, в котором индекс-\nный метод доступа выдает их идентификаторы. При идеальной корреля-\nциииндексноесканированиеэффективнодажепридовольнобольшойдоле\nвыбираемых строк.Но при слабой корреляции (что чаще встречается в ре-\nальности)стоимостьвысокаиоченьбыстроначинаетпревышатьдажесто-\nимостьпоследовательногосканирования.Привсемэтоминдексноескани-\nрование—безусловныйлидер в оченьважном случае,когда индекс (часто\nуникальный)используетсядлявыборкиединственнойстроки.\n424",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:58.660400"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 426,
    "chapter": null,
    "section": "20.5 Сравнениеметодовдоступа",
    "text": "20.5. Сравнениеметодовдоступа\nСканированиетолькоиндекса(еслионоприменимо)можетдаватьпрекрас-\nныерезультатыивыигрыватьупоследовательногосканированиядажепри\nвыборкевсехстрок.Егопроизводительность,однако,оченьсильнозависит\nоткартывидимости,ивхудшемслучаесканированиетолькоиндексадегра-\nдируетдообычногоиндексногосканирования.\nСтоимость сканирования по битовой карте зависит от объема доступной\nпамяти, но в гораздо меньшей степени, чем стоимость индексного скани-\nрования зависит от корреляции.При слабой корреляции сканирование по\nбитовойкартесущественновыигрывает.\nКаждыйизметодовдоступапревосходитостальныевопределенныхситуа-\nциях; нет такого метода, который всегда уступал бы другим. Планиров-\nщиквыполняетсерьезнуюработупооценкеэффективностикаждогометода\nвкаждомконкретномслучае.Конечно,близостьэтихоценоккреальности\nсильнозависитотактуальностистатистическойинформации.\n425",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:58.677884"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 427,
    "chapter": null,
    "section": "21.1 Виды и способы соединений",
    "text": "21\nВложенный цикл\n21.1. Виды и способы соединений\nСоединения—ключеваявозможностьязыкаSQL,основаегогибкостиимощ-\nности. Наборы строк (полученные непосредственно из таблиц или как ре-\nзультатвыполнениядругихопераций)всегдасоединяютсяпопарно.\nСуществуетнескольковидовсоединений.\nВнутренниесоединения. Внутреннее соединение (INNER JOIN, или просто\nJOIN) включает такие пары строк из двух наборов, для которых вы-\nполняется условие соединения. Условие соединения связывает некото-\nрыестолбцыодногонаборастрокснекоторымистолбцамидругого;все\nучаствующиестолбцысоставляютключсоединения.\nЕсли условиетребуетравенства значений в столбцах одного идругого\nнаборов, соединение называют эквисоединением; это наиболее частый\nслучай.\nДекартово произведение (CROSS JOIN) двух наборов включает все воз-\nможные пары строк из обоих наборов — это частный случай внутрен-\nнегосоединениясистиннымусловием.\nВнешниесоединения. Левоевнешнеесоединение(LEFT OUTER JOIN,илипрос-\nто LEFT JOIN) добавляет к внутреннему соединению строки из левого\nнабора,длякоторыхненашлосьсоответствиявправомнаборе(столбцы\nотсутствующегоправогонабораполучаютнеопределенныезначения).\nТожеверноидляправоговнешнегосоединения(RIGHTJOIN),сточностью\nдоперестановкинаборов.\n426",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:58.703431"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 428,
    "chapter": null,
    "section": "21.1 Видыиспособысоединений",
    "text": "21.1. Видыиспособысоединений\nПолноевнешнеесоединение(FULLJOIN)объединяетлевоеиправоевнеш-\nниесоединения,добавляястрокикакизлевого,такиизправогонабо-\nров,длякоторыхненашлосьсоответствия.\nПолусоединенияиантисоединения. Полусоединениепохоженавнутреннеесо-\nединение,новключаетстрокиодногонабора,длякоторыхнашлосьсо-\nответствиевдругомнаборе(строкабудетвключенаврезультаттолько\nодинраз,дажееслисоответствийнесколько).\nАнтисоединение включает строки одного набора, для которых не на-\nшлосьпарывдругомнаборе.\nВязыкеSQLнетявныхоперацийполу-иантисоединения,нокним,на-\nпример,приводяттакиеконструкции,какEXISTSиNOTEXISTS.\nВсе это — логические операции. Например, внутреннее соединение час-\nто описывается как декартово произведение,в котором оставлены только\nстроки, удовлетворяющие условию соединения. Но физически выполнить\nвнутреннее соединение обычно можно другими, более экономными сред-\nствами.\nPostgreSQLпредоставляетнесколькоспособовсоединения:\n• соединениевложеннымциклом(nestedloop);\n• соединениехешированием(hashjoin);\n• соединениеслиянием(mergejoin).\nСпособы соединения—алгоритмы,реализующиелогические операции со-\nединения SQL.Эти базовые алгоритмы часто имеютвариации,приспособ-\nленные для конкретных видов соединений,хотя могути не поддерживать\nвсеизних.Например,вложенныйциклможетприменятьсяидлявнутрен-\nнего соединения (в этом случае он будет представлен узлом Nested Loop),\nидлялевоговнешнегосоединения(чтобудетотраженовпланеузломNested\nLoopLeftJoin),нонеможетиспользоватьсядляполногосоединения.\nБолее того, варианты тех же алгоритмов используются и для выполнения\nдругихопераций,напримерагрегации.\nВ разных ситуациях более эффективными оказываются разные способы;\nпланировщиквыбираетлучшийпостоимости.\n427",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:58.737029"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 429,
    "chapter": null,
    "section": "21.2 Соединение вложенным циклом",
    "text": "Глава21. Вложенныйцикл\n21.2. Соединение вложенным циклом\nБазовыйалгоритмсоединениявложеннымцикломустроенследующимоб-\nразом. Во внешнем цикле перебираются строки первого набора (который\nназывается внешним).Для каждойтакой строки во вложенном цикле пере-\nбираютсястрокивторогонабора(которыйназываетсявнутренним),удовле-\nтворяющие условию соединения.Каждая найденная пара немедленно воз-\nвращаетсякакчастьрезультата1.\nАлгоритмобращаетсяквнутреннемунаборустолькораз,сколькостроксо-\nдержитвнешнийнабор.Поэтомунаэффективностьсоединениявложенным\nцикломвлияетнесколькихусловий:\n• кардинальностьвнешнегонаборастрок;\n• наличиеметодадоступаковнутреннемунабору,позволяющегоэффек-\nтивнополучитьнужныестроки;\n• повторные обращения к одним итем же строкам внутреннего набора.\nДекартово произведение\nСоединениевложеннымциклом—наиболееэффективныйспособвыполне-\nниядекартовапроизведения,независимоотколичествастроквнаборах:\n=> EXPLAIN SELECT * FROM aircrafts_data a1\nCROSS JOIN aircrafts_data a2\nWHERE a2.range > 5000;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nNested Loop (cost=0.00..2.78 rows=45 width=144)\n−> Seq Scan on aircrafts_data a1\nвнешнийнабор\n(cost=0.00..1.09 rows=9 width=72)\n−> Materialize (cost=0.00..1.14 rows=5 width=72)\n−> Seq Scan on aircrafts_data a2\nвнутреннийнабор\n(cost=0.00..1.11 rows=5 width=72)\nFilter: (range > 5000)\n(7 rows)\n1 backend/executor/nodeNestloop.c.\n428",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:58.771954"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 430,
    "chapter": null,
    "section": "21.2 Соединениевложеннымциклом",
    "text": "21.2. Соединениевложеннымциклом\nУзелNestedLoopвыполняетсоединениеалгоритмомвложенногоцикла.Он\nвсегда имеет два дочерних узла. Тот, что находится выше в выводе плана,\nпредставляетвнешнийнаборстрок;тот,чтониже,—внутренний.\nВданном случае внутренний набор представлен узлом Materialize1.Факти-\nческиэтотузелвозвращаетполученныеотнижестоящегоузластроки,пред-\nварительносохраняяих(покаразмерданныхнепревышаетwork_mem,они 4MB\nнакапливаются в памяти, а затем начинают записываться на диск во вре-\nменныйфайл).Приповторномобращенииузелчитаетзапомненныеранее\nстроки, уже не обращаясь к дочернему узлу. Это позволяет не выполнять\nповторно сканирование всейтаблицы,а прочитатьтолько нужные строки,\nудовлетворяющиеусловию.\nК планутакого же вида можетпривести и запрос с обычным эквисоедине-\nнием:\n=> EXPLAIN SELECT *\nFROM tickets t\nJOIN ticket_flights tf ON tf.ticket_no = t.ticket_no\nWHERE t.ticket_no = '0005432000284';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nNested Loop (cost=0.99..25.05 rows=3 width=136)\n−> Index Scan using tickets_pkey on tickets t\n(cost=0.43..8.45 rows=1 width=104)\nIndex Cond: (ticket_no = '0005432000284'::bpchar)\n−> Index Scan using ticket_flights_pkey on ticket_flights tf\n(cost=0.56..16.57 rows=3 width=32)\nIndex Cond: (ticket_no = '0005432000284'::bpchar)\n(7 rows)\nЗдесь планировщик, понимая равенство двух значений, заменил условие\nсоединения tf.ticket_no = t.ticket_no на условие tf.ticket_no = кон-\nстанта,фактическисведяэквисоединениекдекартовупроизведению2.\nОценка кардинальности. Кардинальность декартова произведения равна\nпроизведениюкардинальностейсоединяемыхнаборов:3=1×3.\n1 backend/executor/nodeMaterial.c.\n2 backend/optimizer/path/equivclass.c.\n429",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:58.812207"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 431,
    "chapter": null,
    "section": "21.2 Соединениевложеннымциклом",
    "text": "Глава21. Вложенныйцикл\nОценка стоимости. Начальная стоимость соединения равна сумме началь-\nныхстоимостейдочернихузлов.\nПолнаястоимостьсоединениявданномслучаескладывается:\n• изстоимостиполучениявсехстроквнешнегонабора;\n• однократнойстоимостиполучениявсехстроквнутреннегонабора(по-\nсколькуоценкакардинальностивнешнегонабораравнаединице);\n• стоимостиобработкикаждойстрокирезультата.\nСхемазависимостейпривычисленииоценоквыглядиттак:\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nNested Loop (cost=0.99..25.05 rows=3 width=136)\n−> Index Scan using tickets_pkey on tickets t\n(cost=0.43..8.45 rows=1 width=104)\n×1\nIndex Cond: (ticket_no = '0005432000284'::bpchar)\n−> Index Scan using ticket_flights_pkey on ticket_flights tf\n(cost=0.56..16.57 rows=3 width=32)\nIndex Cond: (ticket_no = '0005432000284'::bpchar)\n(7 rows)\nВоткаквычисляетсястоимостьсоединениявэтомслучае:\n=> SELECT 0.43 + 0.56 AS startup_cost,\nround((\n8.45 + 16.57 +\n3 * current_setting('cpu_tuple_cost')::real\n)::numeric, 2) AS total_cost;\nstartup_cost | total_cost\n−−−−−−−−−−−−−−+−−−−−−−−−−−−\n0.99 | 25.05\n(1 row)\nВернемсятеперькпредыдущемупримеру:\n=> EXPLAIN SELECT *\nFROM aircrafts_data a1\nCROSS JOIN aircrafts_data a2\nWHERE a2.range > 5000;\n430",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:58.848656"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 432,
    "chapter": null,
    "section": "21.2 Соединениевложеннымциклом",
    "text": "21.2. Соединениевложеннымциклом\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nNested Loop (cost=0.00..2.78 rows=45 width=144)\n−> Seq Scan on aircrafts_data a1\n(cost=0.00..1.09 rows=9 width=72)\n−> Materialize (cost=0.00..1.14 rows=5 width=72)\n−> Seq Scan on aircrafts_data a2\n(cost=0.00..1.11 rows=5 width=72)\nFilter: (range > 5000)\n(7 rows)\nОнотличаетсяузломMaterialize,который,одинраззапомнивстроки,полу-\nченныеотдочернегоузла,припоследующихобращенияхотдаетихгораздо\nбыстрее.\nВобщемслучаеполнаястоимостьсоединенияскладывается1:\n• изстоимостиполучениявсехстроквнешнегонабора;\n• однократной стоимости первоначального получения всех строк внут-\nреннегонабора(входекотороговыполняетсяматериализация);\n• (N−1)-кратнойстоимостиповторногополучениястроквнутреннегона-\nбора(гдеN—числостроквовнешнемнаборе);\n• стоимостиобработкикаждойстрокирезультата.\nСхемазависимостейздесьполучаетсятакая:\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nNested Loop (cost=0.00..2.78 rows=45 width=144)\n−> Seq Scan on aircrafts_data a1\n(cost=0.00..1.09 rows=9 width=72)\n−> Materialize ×9\n(cost=0.00..1.14 rows=5 width=72)\n−> Seq Scan on aircrafts_data a2\n(cost=0.00..1.11 rows=5 width=72)\nFilter: (range > 5000)\n(8 rows)\n1 backend/optimizer/path/costsize.c,функцииinitial_cost_nestloopиfinal_cost_nestloop.\n431",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:58.890177"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 433,
    "chapter": null,
    "section": "1.09 + (1.14 + 8 * 0.0125) +",
    "text": "Глава21. Вложенныйцикл\nВ этом примере благодаря материализации повторное получение данных\nобходитсядешевле.Стоимостьпервого обращения к узлу Materialize указа-\nна в плане, но стоимость повторного обращения не выводится. Я не буду\nразбирать,каквычисляетсяэтаоценка1,новданномслучаеонасоставляет\n0,0125.\nТакимобразом,стоимостьсоединениядляэтогопримеравычисляетсятак:\n=> SELECT 0.00 + 0.00 AS startup_cost,\nround((\n1.09 + (1.14 + 8 * 0.0125) +\n45 * current_setting('cpu_tuple_cost')::real\n)::numeric, 2) AS total_cost;\nstartup_cost | total_cost\n−−−−−−−−−−−−−−+−−−−−−−−−−−−\n0.00 | 2.78\n(1 row)\nПараметризованное соединение\nРассмотримдругой,болеетипичныйпример,которыйнесводитсякпросто-\nмудекартовупроизведению:\n=> CREATE INDEX ON tickets(book_ref);\n=> EXPLAIN SELECT *\nFROM tickets t\nJOIN ticket_flights tf ON tf.ticket_no = t.ticket_no\nWHERE t.book_ref = '03A76D';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nNested Loop (cost=0.99..45.67 rows=6 width=136)\n−> Index Scan using tickets_book_ref_idx on tickets t\n(cost=0.43..12.46 rows=2 width=104)\nIndex Cond: (book_ref = '03A76D'::bpchar)\n−> Index Scan using ticket_flights_pkey on ticket_flights tf\n(cost=0.56..16.57 rows=3 width=32)\nIndex Cond: (ticket_no = t.ticket_no)\n(7 rows)\n1 backend/optimizer/path/costsize.c,функцияcost_rescan.\n432",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:58.927469"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 434,
    "chapter": null,
    "section": "21.2 Соединениевложеннымциклом",
    "text": "21.2. Соединениевложеннымциклом\nЗдесьузел Nested Loop перебираетстроки внешнего набора (билеты) идля\nкаждой такой строки обращается к строкам внутреннего набора (переле-\nты),передаваявусловиедоступаномербилетаt.ticket_noкакпараметр.\nКогда вызывается внутренний узел Index Scan, он имеет дело с условием\nticket_no=константа.\nОценка кардинальности. По оценке планировщика,условию на номер бро-\nнированияудовлетворяютдвестрокивнешнегонабора(rows=2),идлякаж-\nдойизэтихстроквовнутреннемнаборевсреднембудетнайденотристроки\n(rows=3).\nСелективностью соединения называется доля строк от декартова произве-\nдениядвухнаборов,котораяостаетсяпослесоединения.Конечно,изучета\nнадосразуисключитьстрокиобоихнаборов,содержащиенеопределенные\nзначения в столбцах, по значениям которых происходит соединение (по-\nсколькудлятакихстрокусловиеравенствазаведомонебудетвыполняться).\nКардинальностьоцениваетсякаккардинальностьдекартовапроизведения\n(то есть произведение кардинальностей двух наборов), умноженная на се-\nлективность1.\nВ данном случае имеем оценку кардинальности первого (внешнего) набо-\nра—двестроки.Никакихусловийнавторой(внутренний)набор,кромеса-\nмого условия соединения,нет.Поэтому за кардинальностьвторого набора\nпринимаетсякардинальностьтаблицыticket_flights.\nПосколькусоединяемыетаблицысвязанывнешнимключом,оценкаселек-\nтивности дается на основании того, что каждая строка дочерней таблицы\nимеет ровно одну пару в родительской таблице. За селективность в этом\nслучаепринимаетсявеличина,обратнаяразмерутаблицы,накоторуюссы-\nлаетсявнешнийключ2.\nТаким образом (учитывая,что столбцы ticket_no не имеютнеопределен-\nныхзначений),оценкасоставляет\n1 backend/optimizer/path/costsize.c,функцияcalc_joinrel_size_estimate.\n2 backend/optimizer/path/costsize.c,функцияget_foreign_key_join_selectivity.\n433",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:58.965116"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 435,
    "chapter": null,
    "section": "21.2 Соединениевложеннымциклом",
    "text": "Глава21. Вложенныйцикл\n=> SELECT round(2 * tf.reltuples * (1.0 / t.reltuples)) AS rows\nFROM pg_class t, pg_class tf\nWHERE t.relname = 'tickets'\nAND tf.relname = 'ticket_flights';\nrows\n−−−−−−\n6\n(1 row)\nРазумеется,таблицы можно соединять и без внешних ключей. Тогда в ка-\nчествеселективностисоединениябудетиспользоватьсяоценкаселективно-\nстиконкретныхусловийсоединения1.\nДля нашего случая эквисоединения «базовая» формула расчета селектив-\nности, предполагающая равномерное распределение значений, выглядит\nс.338 какmin 1 , 1 ,гдеnd —числоуникальныхзначенийключасоединения\n(nd nd ) 1\n1 2\nвпервомнаборестрок,аnd —вовтором2.\n2\nСтатистика по количеству уникальных значений показывает, что в табли-\nцеticketsномерабилетовуникальны(чтоестественно,посколькустолбец\nticket_no является первичным ключом), а в таблице ticket_flights на\nкаждыйбилетвсреднемприходитсяпримернотристроки:\n=> SELECT t.n_distinct, tf.n_distinct\nFROM pg_stats t, pg_stats tf\nWHERE t.tablename = 'tickets' AND t.attname = 'ticket_no'\nAND tf.tablename = 'ticket_flights' AND tf.attname = 'ticket_no';\nn_distinct | n_distinct\n−−−−−−−−−−−−+−−−−−−−−−−−−−\n−1 | −0.30380446\n(1 row)\nВитогеоценкасовпалабысоценкойнаосновевнешнегоключа:\n=> SELECT round(2 * tf.reltuples *\nleast(1.0/t.reltuples, 1.0/tf.reltuples/0.30380446)\n) AS rows\nFROM pg_class t, pg_class tf\nWHERE t.relname = 'tickets' AND tf.relname = 'ticket_flights';\n1 backend/optimizer/path/clausesel.c,функцияclauselist_selectivity.\n2 backend/utils/adt/selfuncs.c,функцияeqjoinsel.\n434",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:59.002967"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 436,
    "chapter": null,
    "section": "21.2 Соединениевложеннымциклом",
    "text": "21.2. Соединениевложеннымциклом\nrows\n−−−−−−\n6\n(1 row)\nПланировщикстараетсяповозможностиуточнитьбазовуюоценку.Внасто-\nящеевремяоннеиспользуетгистограммы,ноучитываетспискинаиболее\nчастых значений,еслитакая статистика собрана по ключу соединениядля с.340\nобеихтаблиц1.В этом случае можно относительноточно рассчитать селек-\nтивностьсоединениятойчастистрок,котораяпопадаетвсписки,итолько\nоставшуюсячастьоцениватьисходяизравномерногораспределения.\nТем не менее в общем случае оценка селективности соединения без внеш-\nнего ключа можетоказаться хуже оценки,когда внешний ключ определен.\nОсобенно велик риск получить сильно заниженную оценку для составных\nключейсоединения.\nСпомощьюкомандыEXPLAIN ANALYZE можнопосмотретьнетолькореаль-\nноечислострок,ноиколичествообращенийквнутреннемуциклу:\n=> EXPLAIN (analyze, timing off, summary off) SELECT *\nFROM tickets t\nJOIN ticket_flights tf ON tf.ticket_no = t.ticket_no\nWHERE t.book_ref = '03A76D';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nNested Loop (cost=0.99..45.67 rows=6 width=136)\n(actual rows=8 loops=1)\n−> Index Scan using tickets_book_ref_idx on tickets t\n(cost=0.43..12.46 rows=2 width=104) (actual rows=2 loops=1)\nIndex Cond: (book_ref = '03A76D'::bpchar)\n−> Index Scan using ticket_flights_pkey on ticket_flights tf\n(cost=0.56..16.57 rows=3 width=32) (actual rows=4 loops=2)\nIndex Cond: (ticket_no = t.ticket_no)\n(8 rows)\nВовнешнемнабореоказалосьдвестроки(actualrows=2);оценкаподтверди-\nлась.Внутренний узел Index Scan выполнялся поэтому два раза (loops=2) и\nкаждыйразвыбиралвсреднемчетырестроки(actualrows=4).Отсюдаобщее\nколичествонайденныхстрок:actualrows=8.\n1 backend/utils/adt/selfuncs.c,функцияeqjoinsel.\n435",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:59.044553"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 437,
    "chapter": null,
    "section": "21.2 Соединениевложеннымциклом",
    "text": "Глава21. Вложенныйцикл\nЯ выключаю вывод времени выполнения каждого шага плана (timing off),чтобы\nнеувеличиватьширинувывода,сильноограниченнуюразмеромкнижнойстраницы;\nктомуженанекоторыхплатформахтакойвыводможетсущественнозамедлятьвы-\nполнениезапроса.Ноесливремявсе-такиоставить,выведенноезначениетожебудет\nусредненным,как и количество строк.Чтобы получитьполное время,среднее надо\nумножитьнаколичествоитераций(loops).\nОценкастоимости. Стоимостьрассчитываетсятакже,каквужерассмотрен-\nныхпримерах.Напомнюпланзапроса:\n=> EXPLAIN SELECT * FROM tickets t\nJOIN ticket_flights tf ON tf.ticket_no = t.ticket_no\nWHERE t.book_ref = '03A76D';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nNested Loop (cost=0.99..45.67 rows=6 width=136)\n−> Index Scan using tickets_book_ref_idx on tickets t\n(cost=0.43..12.46 rows=2 width=104)\nIndex Cond: (book_ref = '03A76D'::bpchar)\n−> Index Scan using ticket_flights_pkey on ticket_flights tf\n(cost=0.56..16.57 rows=3 width=32)\nIndex Cond: (ticket_no = t.ticket_no)\n(7 rows)\nСтоимость повторного сканирования внутреннего набора строк в данном\nслучаенеотличаетсяотстоимостипервогосканирования.Витогеполучаем:\n=> SELECT 0.43 + 0.56 AS startup_cost,\nround((\n12.46 + 2 * 16.57 +\n6 * current_setting('cpu_tuple_cost')::real\n)::numeric, 2) AS total_cost;\nstartup_cost | total_cost\n−−−−−−−−−−−−−−+−−−−−−−−−−−−\n0.99 | 45.66\n(1 row)\nv.14 Кеширование (мемоизация) строк\nЕсли повторное сканирование внутреннего набора строк часто выполняет-\nсясоднимиитемижезначениямипараметраи,соответственно,приводит\n436",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:59.082114"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 438,
    "chapter": null,
    "section": "21.2 Соединениевложеннымциклом",
    "text": "21.2. Соединениевложеннымциклом\nк одним и тем же результатам, может оказаться выгодным закешировать\nстрокивнутреннегонабора.\nТакуюфункциювыполняетузелMemoize1.Онсхожсузломматериализации\nMaterialize,но рассчитан на параметризованное соединение и устроен зна-\nчительносложнее:\n• узелMaterializeпростоматериализуетвсестрокидочернегоузла,аMem-\noizeотдельнозапоминаетстрокидлякаждогозначенияпараметра;\n• при переполнении хранилище строк узла Materialize начинает сбрасы-\nватьданныенадиск,ахранилищеузлаMemoize—нет(этоуничтожило\nбывсепреимуществокеширования).\nВотпримерпланазапроса,которыйиспользуетузелMemoize:\n=> EXPLAIN SELECT *\nFROM flights f\nJOIN aircrafts_data a ON f.aircraft_code = a.aircraft_code\nWHERE f.flight_no = 'PG0003';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nNested Loop (cost=5.44..387.10 rows=113 width=135)\n−> Bitmap Heap Scan on flights f\n(cost=5.30..382.22 rows=113 width=63)\nRecheck Cond: (flight_no = 'PG0003'::bpchar)\n−> Bitmap Index Scan on flights_flight_no_scheduled_depart...\n(cost=0.00..5.27 rows=113 width=0)\nIndex Cond: (flight_no = 'PG0003'::bpchar)\n−> Memoize (cost=0.15..0.27 rows=1 width=72)\nCache Key: f.aircraft_code\nCache Mode: logical\n−> Index Scan using aircrafts_pkey on aircrafts_data a\n(cost=0.14..0.26 rows=1 width=72)\nIndex Cond: (aircraft_code = f.aircraft_code)\n(13 rows)\nДлякешированиястроквыделяетсяпамятьпроцессаразмеромwork_mem× 4MB\n×hash_mem_multiplier. Как следует из названия второго параметра, внутри 2.0\n1 backend/executor/nodeMemoize.c.\n437",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:59.120758"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 439,
    "chapter": null,
    "section": "21.2 Соединениевложеннымциклом",
    "text": "Глава21. Вложенныйцикл\nдляпоискастрокиспользуетсяхеш-таблица(вариантсоткрытойадресаци-\nей1).Ключомхеширования(CacheKey)служитзначениепараметра(илина-\nборзначенийпараметров,еслиихнесколько).Влогическомрежиме(Cache\nс.510 Mode:logical)ключисопоставляютсяоператоромравенства,авдвоичном—\nпобитово.\nКрометого,всеключихешированиясвязанывсписок,одинконецкоторого\nсчитается«холодным»(давнонеиспользованныеключи),адругой—«горя-\nчим»(ключи,использованныенедавно).\nЕсли при обращении к узлу Memoize оказывается,что строки,соответству-\nющие переданным значениям параметров, находятся в кеше, они возвра-\nщаютсяродительскомуузлу(Nested Loop)безобращениякдочернемуузлу.\nИспользованныйключхешированияпередвигаетсявгорячийконецсписка.\nЕслижевкешенетнужныхстрок,узелMemoizeполучаетстрокиотдочернего\nузла,сохраняетихвкешеивозвращаетузлувыше.Новыйключхеширова-\nниятакжестановитсягорячим.\nПока кеш заполняется новыми данными, доступная память может исчер-\nпаться.Чтобы освободить ее,из кеша удаляются строки,соответствующие\nхолодным ключам. Этот алгоритм вытеснения отличается от того, что ис-\nс.188 пользуетсявбуферномкеше,новыполняеттужезадачу.\nМожет оказаться, что каким-то значениям параметров соответствует так\nмногострок,чтоонинепомещаютсяполностьювкеш,дажеесливсеосталь-\nные строки уже вытеснены. Тогда такие параметры пропускаются — нет\nсмыслазапоминатьлишьчастьстрок,посколькувследующийразвсеравно\nпридетсяобращатьсякдочернемуузлузаполнойвыборкой.\nОценкикардинальностиистоимости. Вычислениеоценокничемрадикально\nнеотличаетсяоттого,чтомыужевиделивыше.Однакоследуетучесть,что\nстоимостьузлаMemoize,показаннаявплане,неимеетничегообщегосре-\nальностью:этопростостоимостьдочернегоузла,увеличеннаяназначение\n0.01 cpu_tuple_cost2.\n1 include/lib/simplehash.h.\n2 backend/optimizer/util/pathnode.c,функцияcreate_memoize_path.\n438",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:59.158079"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 440,
    "chapter": null,
    "section": "21.2 Соединениевложеннымциклом",
    "text": "21.2. Соединениевложеннымциклом\nНочтобыузелMemoizeимелсмысл,егостоимостьдолжнабытьнебольше,\nанаоборот,меньшестоимостидочернегоузла.Спохожейситуациеймыуже\nсталкивалисьнапримереузлаMaterialize:«настоящая»стоимостьвычисля-\nетсядляповторногосканированияузла1ивпланенеотображается.\nСтоимость повторного сканирования узла Memoize учитывает размер па-\nмяти,доступнойдлякеширования,ипредполагаемыйхарактеробращений\nк кешу. Расчет очень сильно зависит от точности оценки количества раз-\nличныхзначенийпараметров,скоторымибудетсканироватьсявнутренний\nнаборстрок2.Получивее,можноприкинутьвероятностьобнаружениястро-\nкивкешеивероятностьвытеснениястрокизкеша.Ожидаемыепопадания\nвкешуменьшаютоценкустоимости,апотенциальныевытеснения—наобо-\nрот,увеличивают.Вдеталивычислениястоимостиявдаватьсянебуду.\nРазобратьсявтом,чтонасамомделепроисходитпривыполнениизапроса,\nкакобычно,помогаеткомандаEXPLAINANALYZE:\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT * FROM flights f\nJOIN aircrafts_data a ON f.aircraft_code = a.aircraft_code\nWHERE f.flight_no = 'PG0003';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nNested Loop (actual rows=113 loops=1)\n−> Bitmap Heap Scan on flights f\n(actual rows=113 loops=1)\nRecheck Cond: (flight_no = 'PG0003'::bpchar)\nHeap Blocks: exact=2\n−> Bitmap Index Scan on flights_flight_no_scheduled_depart...\n(actual rows=113 loops=1)\nIndex Cond: (flight_no = 'PG0003'::bpchar)\n−> Memoize (actual rows=1 loops=113)\nCache Key: f.aircraft_code\nCache Mode: logical\nHits: 112 Misses: 1 Evictions: 0 Overflows: 0 Memory\nUsage: 1kB\n−> Index Scan using aircrafts_pkey on aircrafts_data a\n(actual rows=1 loops=1)\nIndex Cond: (aircraft_code = f.aircraft_code)\n(16 rows)\n1 backend/optimizer/path/costsize.c,функцияcost_memoize_rescan.\n2 backend/utils/adt/selfuncs.c,функцияestimate_num_groups.\n439",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:59.202170"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 441,
    "chapter": null,
    "section": "21.2 Соединениевложеннымциклом",
    "text": "Глава21. Вложенныйцикл\nВнашемпримеревыбираютсярейсыпоодномумаршруту,которыйобслу-\nживаетсяоднимтипомсамолета;поэтомуключхешированиясовпадаетдля\nвсехобращенийкузлуMemoize.Первыйраззанужнойстрокойприходится\nсходитьвтаблицу (Misses: 1),но все повторные обращения обслуживаются\nкешем(Hits:112).Навсепровсехватилоодногокилобайтапамяти.\nЕщедвавыведенныхзначенияравнынулю:количествовытесненийизкеша\n(Evictions)иколичествопереполненийпамятисневозможностьюсохранить\nвсестроки,относящиесякодномунаборупараметров(Overflows).Большие\nцифрыговорилибыотом,чтовыделеннойподкешпамятиоказалосьнедо-\nстаточно,скореевсего,из-занекорректнойоценкиколичестваразныхзна-\nчений параметров.Втаких условиях применение узла Memoize можетока-\nзатьсявесьмазатратным.Вкрайнемслучаеможнозапретитьпланировщи-\non куиспользоватькеш,отключивпараметрenable_memoize.\nВнешние соединения\nСоединениевложеннымцикломможетприменятьсядлялевоговнешнегосо-\nединения (узел Nested Loop Left Join).В этом примере планировщик выбрал\nнепараметризованноесоединение:\n=> EXPLAIN SELECT *\nFROM ticket_flights tf\nLEFT JOIN boarding_passes bp ON bp.ticket_no = tf.ticket_no\nAND bp.flight_id = tf.flight_id\nWHERE tf.ticket_no = '0005434026720' and tf.flight_id = 82977;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nNested Loop Left Join (cost=1.12..17.17 rows=1 width=57)\n−> Index Scan using ticket_flights_pkey on ticket_flights tf\n(cost=0.56..8.58 rows=1 width=32)\nIndex Cond: ((ticket_no = '0005434026720'::bpchar) AND\n(flight_id = 82977))\n−> Index Scan using boarding_passes_pkey on boarding_passes bp\n(cost=0.56..8.58 rows=1 width=25)\nIndex Cond: ((ticket_no = '0005434026720'::bpchar) AND\n(flight_id = 82977))\n(9 rows)\n440",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:59.243701"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 442,
    "chapter": null,
    "section": "21.2 Соединениевложеннымциклом",
    "text": "21.2. Соединениевложеннымциклом\nКардинальностьвнешнегосоединенияоцениваетсятакже,какикардиналь-\nностьвнутреннего,новкачестверезультатаберетсямаксимумизполучен-\nной оценки и кардинальности внешнего набора строк1. Иными словами,\nвнешнеесоединениеникогданеуменьшаетколичествострок(ноувеличить\nможет).\nСтоимостьоцениваетсяаналогичновнутреннемусоединению.\nПравоесоединениенеподдерживается2,посколькудляалгоритмавложенно-\nгоциклавнешнийивнутреннийнаборыстрокнеравнозначны.Внешнийна-\nборстрокпросматриваетсяполностью,аизвнутреннегоприиндексномдо-\nступечитаютсятолькостроки,удовлетворяющиеусловиюсоединения.При\nэтомчастьстрокможетостатьсянепросмотренной.\nПолноесоединениенеподдерживаетсяпотемжесоображениям.\nАнти-и полусоединения\nАнтисоединенияиполусоединенияпохожитем,чтодлякаждойстрокипер-\nвого(внешнего)наборавовтором(внутреннем)наборедостаточноискать\nлишьоднуподходящуюстроку.\nАнтисоединениевозвращаетстрокипервогонабора,еслитолькодлянихне\nнашлосьсоответствиявдругомнаборе.Инымисловами,есливовторомна-\nборенашласьоднаподходящаястрока,строкаизпервогонаборауженепо-\nпадетврезультат,идальшеможнонепроверять.\nАнтисоединениеможетиспользоватьсядлявычисленияпредикатаNOT EX-\nISTS.Найдем,например,моделисамолетов,длякоторыхнезаданаконфи-\nгурациясалона.Антисоединениевложеннымцикломотображаетсявплане\nкакузелNestedLoopAntiJoin:\n=> EXPLAIN SELECT *\nFROM aircrafts a\nWHERE NOT EXISTS (\nSELECT * FROM seats s WHERE s.aircraft_code = a.aircraft_code\n);\n1 backend/optimizer/path/costsize.c,функцияcalc_joinrel_size_estimate.\n2 backend/optimizer/path/joinpath.c,функцияmatch_unsorted_outer.\n441",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:59.281463"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 443,
    "chapter": null,
    "section": "21.2 Соединениевложеннымциклом",
    "text": "Глава21. Вложенныйцикл\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nNested Loop Anti Join (cost=0.28..4.65 rows=1 width=40)\n−> Seq Scan on aircrafts_data ml (cost=0.00..1.09 rows=9 widt...\n−> Index Only Scan using seats_pkey on seats s\n(cost=0.28..5.55 rows=149 width=4)\nIndex Cond: (aircraft_code = ml.aircraft_code)\n(5 rows)\nТотже план будетпостроен идля эквивалентного запроса без NOT EXISTS:\n=> EXPLAIN SELECT a.*\nFROM aircrafts a\nLEFT JOIN seats s ON a.aircraft_code = s.aircraft_code\nWHERE s.aircraft_code IS NULL;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nNested Loop Anti Join (cost=0.28..4.65 rows=1 width=40)\n−> Seq Scan on aircrafts_data ml (cost=0.00..1.09 rows=9 widt...\n−> Index Only Scan using seats_pkey on seats s\n(cost=0.28..5.55 rows=149 width=4)\nIndex Cond: (aircraft_code = ml.aircraft_code)\n(5 rows)\nПолусоединениевозвращаеттестрокипервогонабора,длякоторыхнашлось\nхотя бы одно соответствие во втором наборе (и снова последующие совпа-\nденияможнонепроверять—результатужеизвестен).\nПолусоединение можетиспользоватьсядля вычисленияпредиката EXISTS.\nНайдемтеперьмоделисамолетов,всалонекоторыхустановленыкресла:\n=> EXPLAIN SELECT *\nFROM aircrafts a\nWHERE EXISTS (\nSELECT * FROM seats s WHERE s.aircraft_code = a.aircraft_code\n);\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nNested Loop Semi Join (cost=0.28..6.67 rows=9 width=40)\n−> Seq Scan on aircrafts_data ml (cost=0.00..1.09 rows=9 widt...\n−> Index Only Scan using seats_pkey on seats s\n(cost=0.28..5.55 rows=149 width=4)\nIndex Cond: (aircraft_code = ml.aircraft_code)\n(5 rows)\n442",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:59.327442"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 444,
    "chapter": null,
    "section": "21.2 Соединениевложеннымциклом",
    "text": "21.2. Соединениевложеннымциклом\nПолусоединение вложенным циклом представлено узлом Nested Loop Semi\nJoin.Вэтомплане(ивпланахвышедляантисоединения)длятаблицыseats\nуказанаобычнаяоценкастрок(rows=149),хотянасамомделедостаточнопо-\nлучитьвсегоодну.Привыполнениизапроса,конечно,циклостанавливается\nпослепервойстроки:\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT * FROM aircrafts a\nWHERE EXISTS (\nSELECT * FROM seats s WHERE s.aircraft_code = a.aircraft_code\n);\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nNested Loop Semi Join (actual rows=9 loops=1)\n−> Seq Scan on aircrafts_data ml (actual rows=9 loops=1)\n−> Index Only Scan using seats_pkey on seats s\n(actual rows=1 loops=9)\nIndex Cond: (aircraft_code = ml.aircraft_code)\nHeap Fetches: 0\n(6 rows)\nОценкакардинальности. Дляполусоединениядаетсяобычнымобразом,но\nкардинальностьвнутреннегонаборастроксчитаетсяравнойединице.Адля\nантисоединения рассчитанная селективность вычитается из единицы,как\nдляотрицания1.\nОценка стоимости. Для анти-и полусоединений оценка стоимости учиты-\nвает,чтовторойнаборчитаетсянеполностью,атолькопоканебудетнай-\nденапаракстрокепервогонабора2.\nНеэквисоединения\nАлгоритмвложенногоциклапозволяетсоединятьнаборыстрокполюбому\nусловиюсоединения.\n1 backend/optimizer/path/costsize.c,функцияcalc_joinrel_size_estimate.\n2 backend/optimizer/path/costsize.c,функцияfinal_cost_nestloop.\n443",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:59.359953"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 445,
    "chapter": null,
    "section": "21.2 Соединениевложеннымциклом",
    "text": "Глава21. Вложенныйцикл\nКонечно,есливнутреннийнаборстрокявляетсябазовойтаблицей,наэтой\nс.384 таблицесозданиндексиоператорусловиясоединениявходитвклассопера-\nторовэтогоиндекса,токвнутреннемунаборустроквозможенэффективный\nдоступ.Но всегда остается вариантдекартова произведения строк с филь-\nтрациейпоусловию—ивэтомслучаеусловиеможетбытьсовершеннопро-\nизвольным.Как,например,вэтомзапросе,выбирающемпарыаэропортов,\nрасположенныхнедалекодруготдруга:\n=> CREATE EXTENSION earthdistance CASCADE;\n=> EXPLAIN (costs off) SELECT *\nFROM airports a1\nJOIN airports a2 ON a1.airport_code != a2.airport_code\nAND a1.coordinates <@> a2.coordinates < 100;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nNested Loop\nJoin Filter: ((ml.airport_code <> ml_1.airport_code) AND\n((ml.coordinates <@> ml_1.coordinates) < '100'::double precisi...\n−> Seq Scan on airports_data ml\n−> Materialize\n−> Seq Scan on airports_data ml_1\n(6 rows)\nПараллельный режим\nс.366 Соединениевложеннымцикломможетиспользоватьсявпараллельномре-\nжиме1.\nРаспараллеливание происходит только на уровне внешнего набора строк,\nкоторый может одновременно читаться несколькими рабочими процесса-\nми.Получивочереднуюстрокувнешнегонабора,каждыйпроцессзатемсам\nперебираетсоответствующиеейстрокивнутреннегонабора—ужепоследо-\nвательно.\nНижеприведенпримерзапросаснесколькимисоединениями,которыйна-\nходитпассажиров,купившихбилетынаопределенныйрейс:\n1 backend/optimizer/path/joinpath.c,функцияconsider_parallel_nestloop.\n444",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:59.394776"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 446,
    "chapter": null,
    "section": "21.2 Соединениевложеннымциклом",
    "text": "21.2. Соединениевложеннымциклом\n=> EXPLAIN (costs off) SELECT t.passenger_name\nFROM tickets t\nJOIN ticket_flights tf ON tf.ticket_no = t.ticket_no\nJOIN flights f ON f.flight_id = tf.flight_id\nWHERE f.flight_id = 12345;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nNested Loop\n−> Index Only Scan using flights_flight_id_status_idx on fligh...\nIndex Cond: (flight_id = 12345)\n−> Gather\nWorkers Planned: 2\n−> Nested Loop\n−> Parallel Seq Scan on ticket_flights tf\nFilter: (flight_id = 12345)\n−> Index Scan using tickets_pkey on tickets t\nIndex Cond: (ticket_no = tf.ticket_no)\n(10 rows)\nНа верхнем уровне соединение вложенным циклом используется в обыч-\nном,последовательном режиме.Внешний набор данных состоитиз одной\nстрокитаблицырейсовflights,полученнойпоуникальномуключу,поэто-\nмувложенныйциклоправдандажедлябольшоговнутреннегонаборастрок.\nДляполучениявнутреннегонабораиспользуетсяпараллельныйплан.Каж-\nдыйизпроцессовчитаетсвоистрокитаблицыперелетовticket_flightsи с.367\nсоединяетихвложеннымцикломсбилетамиtickets.\n445",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:59.419884"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 447,
    "chapter": null,
    "section": "22.1 Соединение хешированием",
    "text": "22\nХеширование\n22.1. Соединение хешированием\nОднопроходное соединение хешированием\nИдея соединения хешированием состоит в поиске подходящих строк с по-\nмощью заранее подготовленной хеш-таблицы. Вот пример плана, исполь-\nзующеготакоесоединение:\n=> EXPLAIN (costs off) SELECT *\nFROM tickets t\nJOIN ticket_flights tf ON tf.ticket_no = t.ticket_no;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nHash Join\nHash Cond: (tf.ticket_no = t.ticket_no)\n−> Seq Scan on ticket_flights tf\n−> Hash\n−> Seq Scan on tickets t\n(5 rows)\nНа первом этапе узел Hash Join1 обращается к узлу Hash2.Тотполучаетот\nсвоегодочернего узла весьвнутренний набор строк и помещаетего в хеш-\nтаблицу.\nХеш-таблица позволяет сохранять пары, составленные из ключа хеширова-\nния и значения, а затем искать значения по ключу за фиксированное вре-\nмя,не зависящее от размера хеш-таблицы.Для этого ключи хеширования\n1 backend/executor/nodeHashjoin.c.\n2 backend/executor/nodeHash.c.\n446",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:59.442157"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 448,
    "chapter": null,
    "section": "22.1 Соединениехешированием",
    "text": "22.1. Соединениехешированием\nраспределяютсяболееилименееравномернопоограниченномуколичест-\nву корзин (bucket). Номер корзины хеш-таблицы определяется значением\nхеш-функцииотключахеширования;посколькучислокорзинвсегдаявляет-\nсястепеньюдвойки,извычисленногозначенияберетсянужноеколичество\nдвоичныхразрядов.\nРеализацияиспользуетдинамическирасширяемуюхеш-таблицусразреше-\nниемколлизийспомощьюцепочек1,какдлябуферногокеша. с.182\nИтак,напервомэтапепоследовательночитаютсястрокивнутреннегонабо-\nра,и для каждой из них вычисляется хеш-функция.Ключом хеширования\nв данном случае являются поля,участвующие в условии соединения (Hash\nCond),авсамойхеш-таблицесохраняютсявсеполястрокиизвнутреннего\nнабора,необходимыедлязапроса.\nНаиболее эффективно — за один проход по данным — соединение хе- v.13\nшированием работает, если хеш-таблица целиком помещается в опера-\nтивную память. Отведенный ей размер ограничен значением work_mem× 4MB\n×hash_mem_multiplier. 2.0\nwork_mem×hash_mem_multiplier\nвнутренний\nнабор\nвнешний\nнабор\nВотпример,вкоторомзапросвыполненспомощьюкомандыEXPLAINANA-\nLYZE,чтобыполучитьинформациюобиспользованиипамяти:\n=> SET work_mem = '128MB';\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT *\nFROM bookings b\nJOIN tickets t ON b.book_ref = t.book_ref;\n1 backend/utils/hash/dynahash.c.\n447",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 6,
        "content": "|  |  |  |  |"
      },
      {
        "table_index": 1,
        "rows": 1,
        "cols": 6,
        "content": "|  |  |  |  |"
      },
      {
        "table_index": 2,
        "rows": 1,
        "cols": 32,
        "content": "|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T15:59:59.483977"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 449,
    "chapter": null,
    "section": "22.1 Соединениехешированием",
    "text": "Глава22. Хеширование\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nHash Join (actual rows=2949857 loops=1)\nHash Cond: (t.book_ref = b.book_ref)\n−> Seq Scan on tickets t (actual rows=2949857 loops=1)\n−> Hash (actual rows=2111110 loops=1)\nBuckets: 4194304 Batches: 1 Memory Usage: 145986kB\n−> Seq Scan on bookings b (actual rows=2111110 loops=1)\n(6 rows)\nВ отличие от соединения вложенным циклом,для которого внутренний и\nвнешний наборы существенно различаются, соединение на основе хеши-\nрования позволяетпереставлятьнаборы местами.Как правило,в качестве\nвнутреннего используется меньший набор, поскольку это уменьшает раз-\nмерпамяти,необходимыйдляхеш-таблицы.\nЗдесьобъема памяти хватилодля размещения всей хеш-таблицы,которая\nзанимает около 143 Мбайт (Memory Usage) и содержит 4М = 222 корзин\n(Buckets).Поэтомусоединениевыполняетсяводинпроход(Batches).\nОднакоеслибывзапросеиспользовалсяодинстолбец,тодляхеш-таблицы\nхватилобы111Мбайт:\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT b.book_ref\nFROM bookings b\nJOIN tickets t ON b.book_ref = t.book_ref;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nHash Join (actual rows=2949857 loops=1)\nHash Cond: (t.book_ref = b.book_ref)\n−> Index Only Scan using tickets_book_ref_idx on tickets t\n(actual rows=2949857 loops=1)\nHeap Fetches: 0\n−> Hash (actual rows=2111110 loops=1)\nBuckets: 4194304 Batches: 1 Memory Usage: 113172kB\n−> Seq Scan on bookings b (actual rows=2111110 loops=1)\n(8 rows)\n=> RESET work_mem;\nЭтоещеоднапричинанеиспользоватьвзапросахлишниеполя,втомчисле\n«звездочку».\n448",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:59.523696"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 450,
    "chapter": null,
    "section": "22.1 Соединениехешированием",
    "text": "22.1. Соединениехешированием\nКоличествокорзинхеш-таблицывыбираетсятак,чтобывполностьюзапол-\nненнойданнымитаблицекаждаякорзинасодержалавсреднемоднустроку.\nБолее плотное заполнение повысило бы вероятность хеш-коллизий и,сле-\nдовательно, снизило бы эффективность поиска, а более разреженная хеш-\nтаблица слишком неэкономно расходовала бы память.Рассчитанное коли-\nчествокорзинувеличиваетсядопервойподходящейстепенидвойки1.\n(Если, исходя из оценки средней «ширины» одной строки, размер хеш-\nтаблицы с расчетным количеством корзин превышает ограничение по па-\nмяти,используетсядвухпроходноехеширование.)\nПока хеш-таблица не построена полностью,соединение хешированием не\nможетначатьвозвращатьрезультаты.\nНавтором этапе(хеш-таблицакэтомумоментуужеготова)узелHash Join\nобращаетсяковторомудочернемуузлузавнешнимнаборомстрок.Длякаж-\nдой прочитанной строки проверяется наличие соответствующих ей строк\nв хеш-таблице. Для этого хеш-функция вычисляется от значений полей\nвнешнегонабора,входящихвусловиесоединения.\nвнешний\nнабор\nНайденныесоответствиявозвращаютсявышестоящемуузлу.\nОценка стоимости. Оценку кардинальности я уже рассматривал, и она не с.433\nзависитотспособасоединения,поэтомудальшеябудуговоритьтолькооб\nоценкестоимости.\n1 backend/executor/nodeHash.c,функцияExecChooseHashTableSize.\n449",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 6,
        "content": "|  |  |  |  |"
      },
      {
        "table_index": 1,
        "rows": 1,
        "cols": 32,
        "content": "|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T15:59:59.560640"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 451,
    "chapter": null,
    "section": "22.1 Соединениехешированием",
    "text": "Глава22. Хеширование\nВкачествестоимостиузлаHashберетсяполнаястоимостьегодочернегоуз-\nла.Этофиктивнаяцифра,просточтобыбылочтопоказатьвпланезапроса1.\nВсереальныеоценкивключенывстоимостьузлаHashJoin2.\nРассмотримпример:\n=> EXPLAIN (analyze, timing off, summary off)\nSELECT * FROM flights f\nJOIN seats s ON s.aircraft_code = f.aircraft_code;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nHash Join (cost=38.13..278507.28 rows=16518865 width=78)\n(actual rows=16518865 loops=1)\nHash Cond: (f.aircraft_code = s.aircraft_code)\n−> Seq Scan on flights f (cost=0.00..4772.67 rows=214867 widt...\n(actual rows=214867 loops=1)\n−> Hash (cost=21.39..21.39 rows=1339 width=15)\n(actual rows=1339 loops=1)\nBuckets: 2048 Batches: 1 Memory Usage: 79kB\n−> Seq Scan on seats s (cost=0.00..21.39 rows=1339 width=15)\n(actual rows=1339 loops=1)\n(10 rows)\nНачальная стоимость соединения отражает в основном создание хеш-таб-\nлицыискладывается:\n• из полной стоимости получения внутреннего набора строк, который\nнеобходимдляпостроенияхеш-таблицы;\n• стоимости вычисления хеш-функции от всех полей, входящих в ключ\nсоединения, для каждой строки внутреннего набора (одна операция\n0.0025 оцениваетсязначениемпараметраcpu_operator_cost);\n• стоимостивставкивсехстроквнутреннегонаборавхеш-таблицу(встав-\n0.01 какаждойоцениваетсязначениемпараметраcpu_tuple_cost);\n• начальной стоимости получения внешнего набора строк,без которого\nнельзяприступитьквыполнениюсоединения.\n1 backend/optimizer/plan/createplan.c,функцияcreate_hashjoin_plan.\n2 backend/optimizer/path/costsize.c,функцииinitial_cost_hashjoinиfinal_cost_hashjoin.\n450",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:59.601688"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 452,
    "chapter": null,
    "section": "22.1 Соединениехешированием",
    "text": "22.1. Соединениехешированием\nПолнаястоимостьдобавляеткначальнойоценкестоимостьсобственносо-\nединения:\n• стоимостьвычисленияхеш-функцииотвсехполей,входящихвключсо-\nединения,длякаждойстрокивнешнегонабора(cpu_operator_cost);\n• стоимостьперепроверокусловийсоединения,которыенеобходимыиз-\nзавозможныххеш-коллизий(вычислениекаждогооператораоценива-\nетсязначениемпараметраcpu_operator_cost);\n• стоимостьобработкикаждойрезультирующейстроки(cpu_tuple_cost).\nНаиболее сложной частью оценки здесь является определение количества\nперепроверок, которые потребуются в ходе соединения. Оно оценивает-\nся произведением числа строк внешнего набора на некоторуюдолю числа\nстроквнутреннегонабора(находящегосявхеш-таблице).Оценкаэтойдоли\nучитывает втом числе и возможное неравномерное распределение значе-\nний.Янебудувдаватьсявподробности1;вданномслучаеэтадоляоцени-\nваетсякак0,150112.\nИтак,длянашегопримераоценкавычисляетсяследующимобразом:\n=> WITH cost(startup) AS (\nSELECT round((\n21.39 +\ncurrent_setting('cpu_operator_cost')::real * 1339 +\ncurrent_setting('cpu_tuple_cost')::real * 1339 +\n0.00\n)::numeric, 2)\n)\nSELECT startup,\nstartup + round((\n4772.67 +\ncurrent_setting('cpu_operator_cost')::real * 214867 +\ncurrent_setting('cpu_operator_cost')::real * 214867 * 1339 *\n0.150112 +\ncurrent_setting('cpu_tuple_cost')::real * 16518865\n)::numeric, 2) AS total\nFROM cost;\n1 backend/utils/adt/selfuncs.c,функцияestimate_hash_bucket_stats.\n451",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:59.634577"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 453,
    "chapter": null,
    "section": "38.13 | 278507.26",
    "text": "Глава22. Хеширование\nstartup | total\n−−−−−−−−−+−−−−−−−−−−−\n38.13 | 278507.26\n(1 row)\nСхемузависимостейрасчетастоимостиможнопредставитьтак:\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nHash Join\n(cost=38.13..278507.28 rows=16518865 width=78)\nHash Cond: (f.aircraft_code = s.aircraft_code)\n−> Seq Scan on flights f\n(cost=0.00..4772.67 rows=214867 width=63)\n−> Hash\n(cost=21.39..21.39 rows=1339 width=15)\n−> Seq Scan on seats s\n(cost=0.00..21.39 rows=1339 width=15)\n(9 rows)\nДвухпроходное соединение хешированием\nЕслинаэтапепланированияоценкипоказывают,чтохеш-таблицанепомес-\nтитсявотведенныерамки,внутреннийнаборстрокразбиваетсянаотдель-\nныепакеты(batch),каждыйизкоторыхобрабатываетсяотдельно.Количест-\nво пакетов (как и корзин) всегда является степеньюдвойки; номер пакета\nопределяетсясоответствующимколичествомбитовхеш-значения1.\nЛюбыедвестроки,соответствующиедругдругуприсоединении,принадле-\nжатодномуитомужепакету,посколькуустрокизразныхпакетовнемогут\nсовпастьхеш-коды.\nК каждому пакету относится одинаковое количество хеш-значений. Если\nданные распределены равномерно, то и размеры всех пакетов будут при-\nмерно одинаковыми. Планировщик может управлять потреблением памя-\nти,выбираяподходящееколичествопакетов2.\n1 backend/executor/nodeHash.c,функцияExecHashGetBucketAndBatch.\n2 backend/executor/nodeHash.c,функцияExecChooseHashTableSize.\n452",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:59.671801"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 454,
    "chapter": null,
    "section": "22.1 Соединениехешированием",
    "text": "22.1. Соединениехешированием\nНапервомэтапевыполнениячитаетсявнутреннийнаборстрокистроится\nхеш-таблица.Еслиочереднаястрокавнутреннегонабораотноситсякперво-\nмупакету,онадобавляетсякхеш-таблицеиостаетсявоперативнойпамяти.\nЕслижестрокаотноситсяккакому-либодругомупакету,оназаписывается\nвовременныйфайл—свойдлякаждогоизпакетов1.\nОбъемиспользуемыхсеансомвременныхфайловнадискеможноограничить,уста-\nновив предельное значение в параметре temp_file_limit (временные таблицы в это −1\nограничениеневходят).Еслисеансисчерпаетограничение,запросбудетаварийно\nпрерван.\nвнутренний\nнабор\nвнешний\nнабор\nНа втором этапе читается внешний набор строк. Если очередная строка\nпринадлежитпервомупакету,онасопоставляетсясхеш-таблицей,которая\nкакразсодержитстрокипервогопакетавнутреннегонабора(авдругихпа-\nкетахсоответствийбытьнеможет).\nЕсли же строка принадлежитдругому пакету,она сбрасывается во времен-\nный файл—опять же свой для каждого пакета.Таким образом,при N па-\nкетах будет использоваться 2(N − 1) файлов (или меньше,если некоторые\nпакетыокажутсяпустыми).\nПосле окончания второго этапа память, занимаемая хеш-таблицей, осво-\nбождается. На этот момент уже имеется частичный результат соединения\nпоодномуизимеющихсяпакетов.\n1 backend/executor/nodeHash.c,функцияExecHashTableInsert.\n453",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 3,
        "content": "|  |"
      },
      {
        "table_index": 1,
        "rows": 1,
        "cols": 21,
        "content": "|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |"
      },
      {
        "table_index": 2,
        "rows": 1,
        "cols": 2,
        "content": "|"
      },
      {
        "table_index": 3,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 4,
        "rows": 1,
        "cols": 4,
        "content": "|  |  |"
      },
      {
        "table_index": 5,
        "rows": 1,
        "cols": 24,
        "content": "|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T15:59:59.722647"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 455,
    "chapter": null,
    "section": "22.1 Соединениехешированием",
    "text": "Глава22. Хеширование\nвнутренний\nнабор\nвнешний\nнабор\nДалее оба этапа повторяются поочередно для каждого из сохраненных на\nдискпакетов:извременногофайлавхеш-таблицупереносятсястрокивнут-\nреннего набора; строки внешнего набора, соответствующие этому же па-\nкету, считываются из другого временного файла и сопоставляются с хеш-\nтаблицей.Использованныевременныефайлыудаляются.\nвнешний\nнабор\nДвухпроходноесоединениеввыводекомандыEXPLAINотличаетсяотодно-\nпроходного количеством пакетов,большим единицы.Крометого,с ключе-\nвымсловомbuffersкомандапокажетстатистикуобменасдиском:\n=> EXPLAIN (analyze, buffers, costs off, timing off, summary off)\nSELECT *\nFROM bookings b\nJOIN tickets t ON b.book_ref = t.book_ref;\n454",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 4,
        "content": "|  |  |"
      },
      {
        "table_index": 1,
        "rows": 1,
        "cols": 7,
        "content": "|  |  |  |  |  |"
      },
      {
        "table_index": 2,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 3,
        "rows": 1,
        "cols": 4,
        "content": "|  |  |"
      },
      {
        "table_index": 4,
        "rows": 1,
        "cols": 27,
        "content": "|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |"
      },
      {
        "table_index": 5,
        "rows": 1,
        "cols": 9,
        "content": "|  |  |  |  |  |  |  |"
      },
      {
        "table_index": 6,
        "rows": 1,
        "cols": 7,
        "content": "|  |  |  |  |  |"
      },
      {
        "table_index": 7,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 8,
        "rows": 1,
        "cols": 6,
        "content": "|  |  |  |  |"
      },
      {
        "table_index": 9,
        "rows": 1,
        "cols": 4,
        "content": "|  |  |"
      },
      {
        "table_index": 10,
        "rows": 1,
        "cols": 4,
        "content": "|  |  |"
      },
      {
        "table_index": 11,
        "rows": 1,
        "cols": 8,
        "content": "|  |  |  |  |  |  |"
      },
      {
        "table_index": 12,
        "rows": 1,
        "cols": 6,
        "content": "|  |  |  |  |"
      },
      {
        "table_index": 13,
        "rows": 1,
        "cols": 6,
        "content": "|  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T15:59:59.781860"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 456,
    "chapter": null,
    "section": "22.1 Соединениехешированием",
    "text": "22.1. Соединениехешированием\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nHash Join (actual rows=2949857 loops=1)\nHash Cond: (t.book_ref = b.book_ref)\nBuffers: shared hit=7219 read=55709, temp read=54218\nwritten=54218\n−> Seq Scan on tickets t (actual rows=2949857 loops=1)\nBuffers: shared read=49440\n−> Hash (actual rows=2111110 loops=1)\nBuckets: 131072 Batches: 32 Memory Usage: 4551kB\nBuffers: shared hit=7219 read=6269, temp written=10701\n−> Seq Scan on bookings b (actual rows=2111110 loops=1)\nBuffers: shared hit=7219 read=6269\n(11 rows)\nЯужеприводилэтотпримервыше,носувеличеннымзначениемwork_mem.\nВотведенныепоумолчанию8Мбайтвсяхеш-таблицанепомещается;здесь\nзадействовано 32 пакета, хеш-таблица использует 128K = 217 корзин. На\nэтапепостроенияхеш-таблицы(узелHash)выполняетсязаписьвовремен-\nныефайлы(temp written);наэтапесоединения(узелHash Join)файлыиза-\nписываются,ичитаются(tempread,written).\nПараметр log_temp_files позволяет получать более детальную информацию −1\nовременныхфайлахвжурналесообщенийсервера.Принулевомзначении\nвжурналебудетотмеченкаждыйфайлиегоразмер(намоментудаления).\nДинамические корректировки плана\nЗапланированный ход событий могутнарушитьдве проблемы: некоррект-\nнаястатистикаинеравномерноераспределение.\nПринеравномерномраспределениизначенийвстолбцах,входящихвключ\nсоединения,разныепакетыбудутиметьразноеколичествострок.\nЕсли какой-нибудь пакет (кроме самого первого) окажется большим, все\nего строки придется сначала записать на диск, а затем прочитать с диска.\nВ основном неприятность доставляет внешний набор данных, потому что\nобычноонбольше.Поэтомуеслидлявнешнегонаборастрокдоступнаобыч-\nная,немноговариантнаястатистикапонаиболеечастымзначениям(тоесть с.356\nвнешнийнаборпредставлентаблицейисоединениевыполняетсяпоодному\n455",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:59.823450"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 457,
    "chapter": null,
    "section": "22.1 Соединениехешированием",
    "text": "Глава22. Хеширование\nстолбцу),тострокисхеш-кодами,соответствующиминесколькимнаиболее\nчастым значениям, считаются принадлежащими первому пакету1. Эта оп-\nтимизация(skewoptimization)позволяетнесколькоуменьшитьввод-вывод\nпридвухпроходномсоединении.\nОбепроблемымогутпривестиктому,чторазмернекоторых(иливсех)паке-\nтовокажетсябольшерасчетного.Тогдахеш-таблицадлянихнепоместится\nвзапланированныйразмеривыйдетзарамкиограничений.\nПоэтому если в процессе построения хеш-таблицы выясняется,что ее раз-\nмер не укладывается в ограничения, количество пакетов увеличивается\n(удваивается)налету.Фактическикаждыйпакетразделяетсянадвановых:\nпримернополовинастрок(еслипредполагатьравномерноераспределение)\nостается в хеш-таблице, а другая половина сбрасывается на диск в новый\nвременныйфайл2.\nЭто можетпроизойти и втом случае,когда планировалосьоднопроходное\nсоединение. По сути, одно- и двухпроходное соединения — один и тот же\nалгоритм, реализуемый одним и тем же кодом. Я разделяю их только для\nудобстваизложения.\nКоличествопакетовможеттолькоувеличиваться.Еслиоказывается,чтопла-\nнировщикошибсявбóльшуюсторону,пакетынеобъединяются.\nОднако при неравномерном распределении увеличение числа пакетов мо-\nжетнепомочь.Например,ключевойстолбецможетсодержатьодноитоже\nзначение во всех строках: очевидно,что все они попадут в один пакет,по-\nсколькухеш-функциябудетвозвращатьодноитожезначение.Увы,втаком\nслучаехеш-таблицабудетпросторасти,невзираяназначенияограничива-\nющихпараметров.\nТеоретическидлятакойситуацииможнобылобыприменитьмногопроходноесоеди-\nнение,рассматриваязаодинразтолькочастьпакета,ноэтонереализовано.\nДлядемонстрациидинамическогоувеличенияколичествапакетовпридет-\nс.336 сяприложитьнекоторыеусилия,чтобыобманутьпланировщик.\n1 backend/executor/nodeHash.c,функцияExecHashBuildSkewHash.\n2 backend/executor/nodeHash.c,функцияExecHashIncreaseNumBatches.\n456",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:59.859570"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 458,
    "chapter": null,
    "section": "22.1 Соединениехешированием",
    "text": "22.1. Соединениехешированием\n=> CREATE TABLE bookings_copy (LIKE bookings INCLUDING INDEXES)\nWITH (autovacuum_enabled = off);\n=> INSERT INTO bookings_copy SELECT * FROM bookings;\nINSERT 0 2111110\n=> DELETE FROM bookings_copy WHERE random() < 0.9;\nDELETE 1900300\n=> ANALYZE bookings_copy;\n=> INSERT INTO bookings_copy SELECT * FROM bookings\nON CONFLICT DO NOTHING;\nINSERT 0 1900300\n=> SELECT reltuples FROM pg_class WHERE relname = 'bookings_copy';\nreltuples\n−−−−−−−−−−−\n210810\n(1 row)\nВ результате этих манипуляций мы получили таблицу bookings_copy —\nполную копию bookings, но планировщик считает, что в ней в десять ра-\nзаменьшестрок,чемнасамомделе.Вреальностипохожаяситуацияможет\nвозникнуть,например,когда хеш-таблица строится по набору строк,полу-\nченномуврезультатедругогосоединения,длякотороговтакомслучаенет\nдостовернойстатистики.\nИз-заэтойошибкипланировщикполагает,чтобудетдостаточно4пакетов,\nновпроцессевыполнениясоединенияихчисловозрастаетдо16:\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT *\nFROM bookings_copy b\nJOIN tickets t ON b.book_ref = t.book_ref;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nHash Join (actual rows=2949857 loops=1)\nHash Cond: (t.book_ref = b.book_ref)\n−> Seq Scan on tickets t (actual rows=2949857 loops=1)\n−> Hash (actual rows=2111110 loops=1)\nBuckets: 131072 (originally 131072) Batches: 16 (originally\n4) Memory Usage: 8085kB\n−> Seq Scan on bookings_copy b (actual rows=2111110 loops=1)\n(7 rows)\n457",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:59.898231"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 459,
    "chapter": null,
    "section": "22.1 Соединениехешированием",
    "text": "Глава22. Хеширование\nОценкастоимости. Воттотжепример,накоторомяпоказывалрасчетстои-\nмости для однопроходного соединения, но теперь я предельно уменьшаю\nразмердоступнойпамяти,ипланировщиквынуждениспользоватьдвапа-\nкета.Стоимостьсоединенияприэтомувеличивается:\n=> SET work_mem = '64kB';\n=> SET hash_mem_multiplier = 1.0;\n=> EXPLAIN (analyze, timing off, summary off)\nSELECT *\nFROM flights f\nJOIN seats s ON s.aircraft_code = f.aircraft_code;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nHash Join (cost=45.13..283139.28 rows=16518865 width=78)\n(actual rows=16518865 loops=1)\nHash Cond: (f.aircraft_code = s.aircraft_code)\n−> Seq Scan on flights f (cost=0.00..4772.67 rows=214867 widt...\n(actual rows=214867 loops=1)\n−> Hash (cost=21.39..21.39 rows=1339 width=15)\n(actual rows=1339 loops=1)\nBuckets: 2048 Batches: 2 Memory Usage: 55kB\n−> Seq Scan on seats s (cost=0.00..21.39 rows=1339 width=15)\n(actual rows=1339 loops=1)\n(10 rows)\n=> RESET work_mem;\n=> RESET hash_mem_multiplier;\nРасходы второго прохода связаны с записью строк во временные файлы и\nчтениемихизфайлов.\nНачальная стоимость, рассчитанная для однопроходного соединения, уве-\nличиваетсявэтомслучаенаоценкузаписитакогоколичествастраниц,кото-\nрогохватитдлясохранениянужныхполей1 всех строквнутреннегонабора.\nХотяпервыйпакетинезаписываетсянадискприпостроениихеш-таблицы,\nэтонеучитываетсявоценке,поэтомуонанезависитотколичествапакетов.\nПолнаястоимостьувеличиваетсянаоценкучтениязаписанныхранеестрок\nвнутреннегонабораиоценкузаписиичтениястроквнешнегонабора.\nКакзапись,такичтениеоднойстраницыоцениваютсязначениемпарамет-\nраseq_page_cost,исходяизпоследовательногохарактераввода-вывода.\n1 backend/optimizer/path/costsize.c,функцияpage_size.\n458",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:59.939480"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 460,
    "chapter": null,
    "section": "278507.28 + -- полная стоимость однопроходного соединения",
    "text": "22.1. Соединениехешированием\nВданном примере количество страницдля строк внутреннего набора оце-\nнено как 7,адля внешнего—как 2309.Добавив оценки к стоимости,кото-\nраябылаполученавышедляоднопроходногосоединения,получаемцифры,\nсовпадающиесостоимостьювпланезапроса:\n=> SELECT 38.13 + -- начальная стоимость однопроходного соединения\ncurrent_setting('seq_page_cost')::real * 7\nAS startup,\n278507.28 + -- полная стоимость однопроходного соединения\ncurrent_setting('seq_page_cost')::real * 2 * (7 + 2309)\nAS total;\nstartup | total\n−−−−−−−−−+−−−−−−−−−−−\n45.13 | 283139.28\n(1 row)\nТаким образом, при нехватке оперативной памяти алгоритм соединения\nстановится двухпроходным, и эффективность его падает. Поэтому важно,\nчтобы:\n• в хеш-таблицу попадали только действительно нужные поля (обязан-\nностьавторазапроса);\n• хеш-таблицастроиласьпоменьшемунаборустрок(обязанностьплани-\nровщика).\nСоединение хешированием в параллельных планах\nСоединениехешированиемможетучаствоватьвпараллельныхпланахвтом\nвиде,вкоторомяописывалеговыше.Этоозначает,чтосначаланесколько\nпараллельныхпроцессовнезависимодруготдругастроятсобственные(со-\nвершенно одинаковые) хеш-таблицы по внутреннему наборуданных,а за-\nтемиспользуютпараллельныйдоступквнешнемунаборустрок.Выигрыш\nздесь достигается за счет того, что каждый из процессов просматривает\nтолькочастьвнешнегонаборастрок.\nВотпримерпланасучастиемобычного(вданномслучаеоднопроходного)\nсоединенияхешированием:\n459",
    "tables": [],
    "extracted_at": "2025-10-02T15:59:59.969570"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 461,
    "chapter": null,
    "section": "278507.28 + -- полная стоимость однопроходного соединения",
    "text": "Глава22. Хеширование\n=> SET work_mem = '128MB';\n=> SET enable_parallel_hash = off;\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT count(*)\nFROM bookings b\nJOIN tickets t ON t.book_ref = b.book_ref;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nFinalize Aggregate (actual rows=1 loops=1)\n−> Gather (actual rows=3 loops=1)\nWorkers Planned: 2\nWorkers Launched: 2\n−> Partial Aggregate (actual rows=1 loops=3)\n−> Hash Join (actual rows=983286 loops=3)\nHash Cond: (t.book_ref = b.book_ref)\n−> Parallel Index Only Scan using tickets_book_ref...\nHeap Fetches: 0\n−> Hash (actual rows=2111110 loops=3)\nBuckets: 4194304 Batches: 1 Memory Usage:\n113172kB\n−> Seq Scan on bookings b (actual rows=2111110...\n(13 rows)\n=> RESET enable_parallel_hash;\nЗдесь каждый процесс хеширует таблицу bookings, а затем сопоставляет\nс хеш-таблицей свою часть строк, полученную параллельным индексным\nдоступом(ParallelIndexOnlyScan).\nОграничение на память под хеш-таблицу применяется к каждому парал-\nлельномупроцессу,такчтосуммарнобудетвыделеновтриразабольшепа-\nмяти,чемэтоуказановплане(MemoryUsage).\nv.11 Параллельное однопроходное хеш-соединение\nНесмотря на то что и обычное соединение хешированием может давать\nопределеннуювыгодувпараллельныхпланах(особенновслучаенебольшо-\nговнутреннегонабора,которыйнетсмыслаобрабатыватьпараллельно),для\nбольшихнаборовданныхлучшеработаетспециальныйпараллельныйалго-\nритмхеш-соединения.\n460",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:00.004343"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 462,
    "chapter": null,
    "section": "22.1 Соединениехешированием",
    "text": "22.1. Соединениехешированием\nВажное отличие от непараллельной версии алгоритма состоит в том, что\nхеш-таблица создается не в локальной памяти процесса, а в общей дина-\nмическивыделяемойпамятиидоступнакаждомупараллельномупроцессу,\nучаствующему в соединении.Это позволяетвместо нескольких отдельных\nхеш-таблиц создатьодну общую,используя суммарный объем памяти,вы-\nделяемый всемпроцессам-участникам.Благодаряэтомуувеличиваетсяве-\nроятностьвыполнениясоединениязаодинпроход.\nНа первом этапе, представляемом в плане узлом Parallel Hash, все парал-\nлельныепроцессыстроятобщуюхеш-таблицу,используяпараллельныйдо-\nступквнутреннемунаборустрок1.\nwork_mem×hash_mem_multiplier×\n×числопроцессов\nвнутренний\nнабор\nвнешний\nнабор\nЧтобы можно былодвигатьсядальше,каждый из параллельных процессов\nдолжензавершитьсвоючастьпервогоэтапа2.\nНавторомэтапе(узелParallelHashJoin),когдахеш-таблицапостроена,каж-\nдыйпроцесссопоставляетснейсвоючастьстроквнешнегонабора,исполь-\nзуяпараллельныйдоступ3.\nвнешний\nнабор\n1 backend/executor/nodeHash.c,функцияMultiExecParallelHash.\n2 backend/storage/ipc/barrier.c.\n3 backend/executor/nodeHashjoin.c,функцияExecParallelHashJoin.\n461",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 4,
        "content": "|  |  |"
      },
      {
        "table_index": 1,
        "rows": 1,
        "cols": 6,
        "content": "|  |  |  |  |"
      },
      {
        "table_index": 2,
        "rows": 1,
        "cols": 12,
        "content": "|  |  |  |  |  |  |  |  |  |  |"
      },
      {
        "table_index": 3,
        "rows": 1,
        "cols": 16,
        "content": "|  |  |  |  |  |  |  |  |  |  |  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T16:00:00.064937"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 463,
    "chapter": null,
    "section": "22.1 Соединениехешированием",
    "text": "Глава22. Хеширование\nВотпримертакогоплана:\n=> SET work_mem = '64MB';\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT count(*)\nFROM bookings b\nJOIN tickets t ON t.book_ref = b.book_ref;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nFinalize Aggregate (actual rows=1 loops=1)\n−> Gather (actual rows=3 loops=1)\nWorkers Planned: 2\nWorkers Launched: 2\n−> Partial Aggregate (actual rows=1 loops=3)\n−> Parallel Hash Join (actual rows=983286 loops=3)\nHash Cond: (t.book_ref = b.book_ref)\n−> Parallel Index Only Scan using tickets_book_ref...\nHeap Fetches: 0\n−> Parallel Hash (actual rows=703703 loops=3)\nBuckets: 4194304 Batches: 1 Memory Usage:\n115392kB\n−> Parallel Seq Scan on bookings b (actual row...\n(13 rows)\n=> RESET work_mem;\nЭто тот же запрос, что я показывал в предыдущем разделе, но там парал-\nлельная версия хеш-соединения была специально отключена параметром\non enable_parallel_hash.\nНесмотря на то что я уменьшил объем памяти под хеш-таблицу вдвое по\nсравнению с обычным хеш-соединением из предыдущего раздела, соеди-\nнениеосталосьоднопроходнымзасчетсовместногоиспользованияпамяти\nвсехпараллельныхпроцессов(MemoryUsage).Хеш-таблицазанимаеттеперь\nнемногобольшепамяти,однакоонасуществуетвединственномэкземпля-\nре,такчтосуммарноеиспользованиепамятиуменьшилось.\nv.11 Параллельное двухпроходное хеш-соединение\nДаже совместной памяти всех параллельных процессов может не хватить\nдля размещения всей хеш-таблицы.Это можетстатьпонятно как на этапе\n462",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:00.100186"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 464,
    "chapter": null,
    "section": "22.1 Соединениехешированием",
    "text": "22.1. Соединениехешированием\nпланирования,так и позже,во время выполнения.В таком случае исполь-\nзуетсядвухпроходный алгоритм,который существенно отличается отвсех\nужерассмотренных.\nВажное отличие состоит в том, что используется не одна большая общая\nхеш-таблица,анесколькотаблицменьшегоразмера.Каждыйпроцессрабо-\nтает со своей таблицей и обрабатывает пакеты независимо отдругих про-\nцессов.(Однакоотдельныехеш-таблицытожерасполагаютсявобщейпамя-\nти,такчтодоступкнимможетполучитьлюбойпроцесс.)Еслиуженаэтапе\nпланированиястановитсяясно,чтооднимпакетомнеобойтись1,длякаждо-\nгопроцессасразусоздаетсясвояхеш-таблица.Еслирешениепринимается\nвовремявыполнения,таблицаперестраивается2.\nИтак, на первом этапе процессы параллельно читают внутренний набор\nстрок,разделяя его на пакеты и записывая эти пакеты во временные фай-\nлы3.Посколькукаждыйпроцессчитаеттолькосвоючастьстроквнутреннего\nнабора,ниодинизнихнепостроитполнуюхеш-таблицунидляодногопа-\nкета(неисключаяипервый).Полныйнаборстроклюбогопакетасобирается\nтолько в файле, запись в который ведут все параллельные процессы, син-\nхронизируясьдругсдругом4.Поэтому,вотличиеотнепараллельнойверсии\nалгоритма и от параллельной однопроходной версии, в данном случае на\nдисксбрасываютсявсепакеты,включаяпервый.\nвнутренний\nнабор\nвнешний\nнабор\n1 backend/executor/nodeHash.c,функцияExecChooseHashTableSize.\n2 backend/executor/nodeHash.c,функцияExecParallelHashIncreaseNumBatches.\n3 backend/executor/nodeHash.c,функцияMultiExecParallelHash.\n4 backend/utils/sort/sharedtuplestore.c.\n463",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 13,
        "content": "|  |  |  |  |  |  |  |  |  |  |  |"
      },
      {
        "table_index": 1,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 2,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 3,
        "rows": 1,
        "cols": 20,
        "content": "|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T16:00:00.155837"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 465,
    "chapter": null,
    "section": "22.1 Соединениехешированием",
    "text": "Глава22. Хеширование\nКогдавсепроцессызакончилихешированиевнутреннегонабора,начинает-\nсявторойэтап1.\nВслучаенепараллельнойверсииалгоритмастрокивнешнегонабора,отно-\nсящиесякпервомупакету,сразужесопоставлялисьбысхеш-таблицей.Но\nв параллельной версии готовой хеш-таблицы еще нет в памяти, и пакеты\nобрабатываются процессами независимо.Поэтому в начале второго этапа\nвнешний набор строк читается параллельно, распределяется по пакетам,\nикаждыйпакетзаписываетсявсвойвременныйфайл2.Прочитанныестро-\nкинепопадаютвхеш-таблицу(какэтопроисходитнапервомэтапе),такчто\nувеличениеколичествапакетовневозможно.\nКогда все процессы закончили чтение внешнего набора данных, на дис-\nке оказывается 2N временных файлов, содержащих пакеты внутреннего\nивнешнегонаборов.\nвнутренний\nнабор\nвнешний\nнабор\nЗатемкаждыйпроцессвыбираетодинизпакетовивыполняетсоединение:\nзагружает внутренний набор строк в свою хеш-таблицу в памяти, читает\nстрокивнешнегонабораисопоставляетихсострокамивхеш-таблице.Когда\nпроцессзавершаетобработкуодногопакета,онвыбираетследующий,еще\nнеобработанный3.\n1 backend/executor/nodeHashjoin.c,функцияExecParallelHashJoin.\n2 backend/executor/nodeHashjoin.c,функцияExecParallelHashJoinPartitionOuter.\n3 backend/executor/nodeHashjoin.c,функцияExecParallelHashJoinNewBatch.\n464",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 1,
        "rows": 1,
        "cols": 10,
        "content": "|  |  |  |  |  |  |  |  |"
      },
      {
        "table_index": 2,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 3,
        "rows": 1,
        "cols": 2,
        "content": "|"
      }
    ],
    "extracted_at": "2025-10-02T16:00:00.207912"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 466,
    "chapter": null,
    "section": "22.1 Соединениехешированием",
    "text": "22.1. Соединениехешированием\nвнутренний\nнабор\nвнешний\nнабор\nКогда необработанные пакеты заканчиваются, освободившийся процесс\nподключаетсякобработкеодногоизещенезавершенныхпакетов,пользу-\nясьтем,чтовсехеш-таблицынаходятсявразделяемойпамяти.\nвнешний\nнабор\nТакаясхемаработаетлучше,чемоднабольшаяхеш-таблица,общаядлявсех\nпроцессов: проще организовать совместную работу, меньше ресурсов тра-\nтитсянасинхронизацию.\nМодификации\nАлгоритм соединения хешированием можетиспользоваться нетолькодля\nвнутренних,ноидлялюбыхдругихтиповсоединений:левых,правыхипол-\nных внешних соединений,для полу-и антисоединений.Однако,как я уже\nговорил,вкачествеусловиясоединениядопускаетсятолькоравенство.\nЧасть операций я уже показывал на примере соединения вложенным цик- с.440\nлом.Вотпримерправоговнешнегосоединения:\n465",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 6,
        "content": "|  |  |  |  |"
      },
      {
        "table_index": 1,
        "rows": 1,
        "cols": 4,
        "content": "|  |  |"
      },
      {
        "table_index": 2,
        "rows": 1,
        "cols": 4,
        "content": "|  |  |"
      },
      {
        "table_index": 3,
        "rows": 1,
        "cols": 2,
        "content": "|"
      },
      {
        "table_index": 4,
        "rows": 1,
        "cols": 8,
        "content": "|  |  |  |  |  |  |"
      },
      {
        "table_index": 5,
        "rows": 1,
        "cols": 6,
        "content": "|  |  |  |  |"
      },
      {
        "table_index": 6,
        "rows": 1,
        "cols": 6,
        "content": "|  |  |  |  |"
      },
      {
        "table_index": 7,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T16:00:00.260741"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 467,
    "chapter": null,
    "section": "22.1 Соединениехешированием",
    "text": "Глава22. Хеширование\n=> EXPLAIN (costs off) SELECT *\nFROM bookings b\nLEFT OUTER JOIN tickets t ON t.book_ref = b.book_ref;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nHash Right Join\nHash Cond: (t.book_ref = b.book_ref)\n−> Seq Scan on tickets t\n−> Hash\n−> Seq Scan on bookings b\n(5 rows)\nОбратите внимание, как логическая операция левого соединения в SQL-\nзапросепревратиласьвфизическуюоперациюправогосоединениявплане\nвыполнения.\nНалогическомуровневнешнейтаблицей(стоящейслеваотоперациисоеди-\nнения)являютсябронирования(bookings),авнутренней—таблицабилетов\n(tickets).Поэтому в результатсоединениядолжны попастьвтом числе и\nбронированиябезбилетов.\nНафизическомуровневнешнийивнутреннийнаборыданныхопределяют-\nся не по положению в тексте запроса, а исходя из стоимости соединения.\nОбычноэтоозначает,чтовнутреннимнаборомбудеттот,чьяхеш-таблица\nменьше.Такпроисходитиздесь:вкачествевнутреннегонаборавыступает\nтаблицабронирований,ивидсоединенияменяетсяслевогонаправый.\nИнаоборот,есливзапросеуказатьправоевнешнеесоединение(желаявы-\nвестибилеты,несвязанныесбронированиями),товпланевыполнениясо-\nединениепоменяетсяналевое:\n=> EXPLAIN (costs off) SELECT *\nFROM bookings b\nRIGHT OUTER JOIN tickets t ON t.book_ref = b.book_ref;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nHash Left Join\nHash Cond: (t.book_ref = b.book_ref)\n−> Seq Scan on tickets t\n−> Hash\n−> Seq Scan on bookings b\n(5 rows)\n466",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:00.294573"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 468,
    "chapter": null,
    "section": "22.2 Группировкаиуникальныезначения",
    "text": "22.2. Группировкаиуникальныезначения\nДляполнотыкартины—примерпланасполнымвнешнимсоединением:\n=> EXPLAIN (costs off)\nSELECT *\nFROM bookings b\nFULL OUTER JOIN tickets t ON t.book_ref = b.book_ref;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nHash Full Join\nHash Cond: (t.book_ref = b.book_ref)\n−> Seq Scan on tickets t\n−> Hash\n−> Seq Scan on bookings b\n(5 rows)\nПараллельное соединение хешированием поддерживается для всех видов\nсоединений: не только для внутренних и внешних левых, но также и для\nправых и полных. В следующем примере планировщик отдает предпочте- v.16\nниеправомусоединению,чтобыпостроитьхеш-таблицуменьшегоразмера:\n=> EXPLAIN (costs off)\nSELECT sum(b.total_amount)\nFROM bookings b\nLEFT OUTER JOIN tickets t ON t.book_ref = b.book_ref;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nFinalize Aggregate\n−> Gather\nWorkers Planned: 2\n−> Partial Aggregate\n−> Parallel Hash Right Join\nHash Cond: (t.book_ref = b.book_ref)\n−> Parallel Index Only Scan using tickets_book_ref...\n−> Parallel Hash\n−> Parallel Seq Scan on bookings b\n(9 rows)\n22.2. Группировка и уникальные значения\nГруппировка значений для агрегации и устранение дубликатов могут вы-\nполнятьсяалгоритмами,схожимисалгоритмамисоединения.Одинизспо-\nсобов состоит в том, чтобы построить хеш-таблицу по нужным столбцам.\n467",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:00.327873"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 469,
    "chapter": null,
    "section": "22.2 Группировкаиуникальныезначения",
    "text": "Глава22. Хеширование\nЗначения помещаются в хеш-таблицу,только если они отсутствуют в ней.\nТаким образом,в конечном итоге в хеш-таблице собираются все уникаль-\nныезначения.\nУзел,который отвечаетза агрегацию методом хеширования,обозначается\nвпланевыполнениякакHashAggregate1.\nПриведунесколькопримеровситуаций,вкоторыхможетиспользоватьсята-\nкойузел.\nКоличествоместдлякаждогоклассаобслуживания(GROUPBY):\n=> EXPLAIN (costs off)\nSELECT fare_conditions, count(*)\nFROM seats\nGROUP BY fare_conditions;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nHashAggregate\nGroup Key: fare_conditions\n−> Seq Scan on seats\n(3 rows)\nСписокклассовобслуживания(DISTINCT):\n=> EXPLAIN (costs off)\nSELECT DISTINCT fare_conditions\nFROM seats;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nHashAggregate\nGroup Key: fare_conditions\n−> Seq Scan on seats\n(3 rows)\nКлассыобслуживанияиещеоднозначение(UNION):\n=> EXPLAIN (costs off) SELECT fare_conditions\nFROM seats\nUNION\nSELECT NULL;\n1 backend/executor/nodeAgg.c.\n468",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:00.353334"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 470,
    "chapter": null,
    "section": "22.2 Группировкаиуникальныезначения",
    "text": "22.2. Группировкаиуникальныезначения\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nHashAggregate\nGroup Key: seats.fare_conditions\n−> Append\n−> Seq Scan on seats\n−> Result\n(5 rows)\nУзелAppendсоответствуетобъединениюдвухнаборовстрок,нонеудаляет\nдубликаты,кактоготребуетоперацияUNION.Удалениевыполняетсяотдель-\nноузломHashAggregate.\nПамять, выделяемая под хеш-таблицу, ограничена значением work_mem× 4MB\n×hash_mem_multiplier,какивслучаехеш-соединения. 2.0\nЕслихеш-таблицапомещаетсявотведеннуюпамять,агрегациявыполняет-\nсязаодинпроходпонаборустрок,каквэтомпримере:\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT DISTINCT amount FROM ticket_flights;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nHashAggregate (actual rows=338 loops=1)\nGroup Key: amount\nBatches: 1 Memory Usage: 45kB\n−> Seq Scan on ticket_flights (actual rows=8391852 loops=1)\n(4 rows)\nУникальныхзначенийстоимостинетакмного,поэтомухеш-таблицазаняла\nвсего45Кбайт(MemoryUsage).\nКак только во время построения хеш-таблицы новые значения перестают v.13\nпомещаться в отведенный объем,они сбрасываются во временные файлы,\nраспределяясьпо разделам на основе нескольких битов хеш-значения.Ко-\nличестворазделовявляетсястепеньюдвойкиивыбираетсяпланировщиком\nтак,чтобыхеш-таблицадлякаждогоизнихпоместиласьцеликомвопера-\nтивную память. Конечно, эта оценка зависит от качества статистики, по-\nэтому расчетное значение умножается на полтора, чтобы дополнительно\n469",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:00.387487"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 471,
    "chapter": null,
    "section": "22.2 Группировкаиуникальныезначения",
    "text": "Глава22. Хеширование\nуменьшитьразмер разделов и увеличитьвероятностьтого,что каждый из\nнихможнобудетобработатьзаодинраз1.\nПослетогокаквесьнаборданныхпрочитан,узелвозвращаетрезультатыаг-\nрегациипотемзначениям,которыепопаливхеш-таблицу.\nЗатем хеш-таблица очищается, и каждый из разделов, записанных на\nпредыдущем шаге вовременные файлы,читается иобрабатываетсяточно\nтак же,как обычный набор строк.При неудачном стечении обстоятельств\nхеш-таблицаразделаможетснованепоместитьсявпамять;тогда«лишние»\nстроки опятьбудутразбиты на разделы и записаны надискдля последую-\nщейобработки.\nРассмотрим другой пример. Здесь количество уникальных идентификато-\nров слишком велико, чтобы хеш-таблица поместилась в память целиком,\nпоэтомупланируетсяиспользоватьчетырераздела:\n=> SET hash_mem_multiplier = 1.1;\n=> EXPLAIN\nSELECT DISTINCT flight_id FROM ticket_flights;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nHashAggregate (604941.71..671358.36 rows=85516 width=4)\nGroup Key: flight_id\nPlanned Partitions: 4\n−> Seq Scan on ticket_flights (cost=0.00..153878.70 rows=8391...\n(4 rows)\nВпроцессевыполнениязапросапотребовалосьпятьитераций:однапона-\nчальномунаборуданныхиещечетырепокаждомуиззаписанныхнадиск\nразделов.\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT DISTINCT flight_id FROM ticket_flights;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nHashAggregate (actual rows=150588 loops=1)\nGroup Key: flight_id\nBatches: 5 Memory Usage: 10289kB Disk Usage: 69384kB\n−> Seq Scan on ticket_flights (actual rows=8391852 loops=1)\n(4 rows)\n1 backend/executor/nodeAgg.c,функцияhash_choose_num_partitions.\n470",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:00.427495"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 472,
    "chapter": null,
    "section": "22.2 Группировкаиуникальныезначения",
    "text": "22.2. Группировкаиуникальныезначения\n=> RESET hash_mem_multiplier;\nВ двухпроходном алгоритме соединения хешированием наиболее частые\nзначения специальным образом переносятся в первый пакет, чтобы из-\nбежать лишнего ввода-вывода. Для агрегации такая оптимизация не нуж-\nна,поскольку на разделы разбиваются не все строки,атолькоте,которым\nне хватило отведенной памяти.Частые значения с большой вероятностью\nвстретятсявнаборестрокдостаточнорано,чтобыуспетьзанятьместо.\n471",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:00.436899"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 473,
    "chapter": null,
    "section": "23.1 Соединение слиянием",
    "text": "23\nСортировка и слияние\n23.1. Соединение слиянием\nСоединение слиянием работаетдля наборов данных, отсортированных по\nключу соединения, и возвращает отсортированный же результат. Входной\nнаборможетоказатьсяужеотсортированнымврезультатеиндексногоска-\nнирования,илионможетбытьотсортированявно1.\nСлияние отсортированных наборов\nВот пример соединения слиянием; оно представлено в плане выполнения\nузломMergeJoin2:\n=> EXPLAIN (costs off) SELECT *\nFROM tickets t\nJOIN ticket_flights tf ON tf.ticket_no = t.ticket_no\nORDER BY t.ticket_no;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nMerge Join\nMerge Cond: (t.ticket_no = tf.ticket_no)\n−> Index Scan using tickets_pkey on tickets t\n−> Index Scan using ticket_flights_pkey on ticket_flights tf\n(4 rows)\n1 backend/optimizer/path/joinpath.c,функцияgenerate_mergejoin_paths.\n2 backend/executor/nodeMergejoin.c.\n472",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:00.458508"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 474,
    "chapter": null,
    "section": "23.1 Соединениеслиянием",
    "text": "23.1. Соединениеслиянием\nЗдесь оптимизатор предпочел именно этот способ соединения, поскольку\nон возвращает результат как раз втом порядке,который указан в предло-\nжении ORDER BY.Работая с планами,оптимизатор учитывает порядок сор-\nтировкинаборовданныхиневыполняетявнуюсортировку,есливнейнет\nнеобходимости.В частности,набор строк,полученный в результате соеди-\nненияслиянием,можноиспользоватьдляследующегосоединенияслияни-\nем,еслиподходитимеющийсяпорядоксортировки:\n=> EXPLAIN (costs off) SELECT *\nFROM tickets t\nJOIN ticket_flights tf ON t.ticket_no = tf.ticket_no\nJOIN boarding_passes bp ON bp.ticket_no = tf.ticket_no\nAND bp.flight_id = tf.flight_id\nORDER BY t.ticket_no;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nMerge Join\nMerge Cond: ((t.ticket_no = tf.ticket_no) AND (bp.flight_id = ...\n−> Merge Join\nMerge Cond: (bp.ticket_no = t.ticket_no)\n−> Index Scan using boarding_passes_pkey on boarding_passe...\n−> Index Scan using tickets_pkey on tickets t\n−> Index Scan using ticket_flights_pkey on ticket_flights tf\n(7 rows)\nСначаласоединяютсястрокитаблицпосадочныхталоновboarding_passes\nибилетовtickets,прочитанныеспомощьюиндексногодоступавпорядке\nticket_no;результаттакжеотсортированпостолбцуticket_no.Получен-\nный набор соединяется со строками таблицы перелетов ticket_flights,\nвыдаваемымииндекснымсканированиемвтомжепорядке.\nСоединение выполняется за один проход по обоим наборам данных и не\nтребует дополнительной памяти. Используются два указателя на текущие\n(изначально—первые)строкивнутреннегоивнешнегонаборов.\nЕслиключидвухтекущихстрокнесовпадают,одинизуказателей—тот,что\nссылаетсянастрокусменьшимключом,—продвигаетсянаоднупозицию\nвпереддотехпор,поканебудетнайденосовпадение.Соответствующиедруг\nдругу строки возвращаются вышестоящему узлу, а указатель внутреннего\nнабораданныхпродвигаетсянаоднупозициювперед.Соединениепродол-\nжаетсядоисчерпанияодногоизнаборов.\n473",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:00.500021"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 475,
    "chapter": null,
    "section": "23.1 Соединениеслиянием",
    "text": "Глава23. Сортировкаислияние\nТакой алгоритм справляется сдубликатами ключей во внутреннем наборе\nданных, но, поскольку дубликаты могут быть и во внешнем наборе, алго-\nритм приходится немного усложнить: если после продвижения внешнего\nуказателяключостаетсяпрежним,внутреннийуказательвозвращаетсяна-\nзад на первую строку с тем же значением ключа. Таким образом, каждой\nстрокеизвнешнегонабораданныхбудутсопоставленывсестрокистемже\nключомизвнутреннегонабораданных1.\nДлявнешнегосоединенияалгоритмещенемногоменяется,нообщаяидея\nостаетсятойжесамой.\nЕдинственный оператор, на который рассчитано соединение слиянием, —\nравенство,тоестьподдерживаютсятолькоэквисоединения(хотяработанад\nподдержкойдругихусловийтожеведется2).\nОценкастоимости. Рассмотримприведенныйвышепример:\n=> EXPLAIN SELECT *\nFROM tickets t\nJOIN ticket_flights tf ON tf.ticket_no = t.ticket_no\nORDER BY t.ticket_no;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nMerge Join (cost=0.99..822508.46 rows=8391852 width=136)\nMerge Cond: (t.ticket_no = tf.ticket_no)\n−> Index Scan using tickets_pkey on tickets t\n(cost=0.43..139135.89 rows=2949857 width=104)\n−> Index Scan using ticket_flights_pkey on ticket_flights tf\n(cost=0.56..571099.78 rows=8391852 width=32)\n(6 rows)\nВ начальную стоимость соединения входят как минимум начальные стои-\nмостидочернихузлов.\nВ общем случаедля нахождения первого соответствия можетпотребовать-\nся прочитать некоторую долю внешнего или внутреннего набора данных.\n1 backend/executor/nodeMergejoin.c,функцияExecMergeJoin.\n2 Например,commitfest.postgresql.org/33/3160.\n474",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:00.535281"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 476,
    "chapter": null,
    "section": "23.1 Соединениеслиянием",
    "text": "23.1. Соединениеслиянием\nЧтобыоценитьэтудолю,можносравнить(спомощьюгистограммы)мини- с.343\nмальные значения ключа соединения вдвух наборах1.Но вданном случае\nдиапазоныномеровбилетоввобеихтаблицахсовпадают.\nПолная стоимость соединения складывается из стоимости получения дан-\nныхотдочернихузловистоимостивычислений.\nПоскольку алгоритм соединения останавливается, когда заканчивается\nодинизнаборовданных(конечно,кромеслучаявнешнегосоединения),дру-\nгой набор может быть прочитан не полностью. Оценку этой доли можно\nполучить,сравнивмаксимальныезначенияключавдвухнаборах.Внашем\nслучае оба набора будут прочитаны до конца,так что в полную стоимость\nсоединениявойдетсуммаполныхстоимостейобоихдочернихузлов.\nКрометого,приналичиидубликатовчастьстроквнутреннегонабораможет\nбытьпрочитананесколькораз.Количествоповторныхчтенийоценивается\nразностьюкардинальностейрезультатасоединенияивнутреннегонабора2.\nВнашемзапросеэтикардинальностисовпадают,чтоговоритоботсутствии\nдубликатов.\nАлгоритм сравнивает ключи соединений двух наборов. Стоимость одного\nсравнения оценивается значением параметра cpu_operator_cost, а их коли- 0.0025\nчествоможнооценитьсуммойчисластроквобоихнаборах(добавивкней\nколичество повторных чтений, вызванных дубликатами). Стоимость обра-\nботкикаждойрезультирующейстрокиоценивается,какобычно,значением\nпараметраcpu_tuple_cost. 0.01\nВитогедлянашегопримерастоимостьсоединениявычисляетсяследующим\nобразом3:\n=> SELECT 0.43 + 0.56 AS startup,\nround((\n139110.29 + 571099.78 +\ncurrent_setting('cpu_tuple_cost')::real * 8391852 +\ncurrent_setting('cpu_operator_cost')::real * (2949857 + 8391852)\n)::numeric, 2) AS total;\n1 backend/utils/adt/selfuncs.c,функцияmergejoinscansel.\n2 backend/optimizer/path/costsize.c,функцияfinal_cost_mergejoin.\n3 backend/optimizer/path/costsize.c,функцииinitial_cost_mergejoinиfinal_cost_mergejoin.\n475",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:00.573541"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 477,
    "chapter": null,
    "section": "0.99 | 822482.86",
    "text": "Глава23. Сортировкаислияние\nstartup | total\n−−−−−−−−−+−−−−−−−−−−−\n0.99 | 822482.86\n(1 row)\nПараллельный режим\nСоединениеслияниемнеимеетспециальнойпараллельнойреализации,но\nможетиспользоватьсявпараллельныхпланах1.\nСканирование внешнего набора строк выполняется рабочими процессами\nпараллельно, но внутренний набор строк каждый рабочий процесс всегда\nчитаетсамостоятельно.\nс.460 Посколькупараллельноехеш-соединениепочтивсегдавыигрываетпостои-\nмости,явременноотключуего:\n=> SET enable_hashjoin = off;\nВотпримерпараллельногоплана,использующегосоединениеслиянием:\n=> EXPLAIN (costs off)\nSELECT count(*), sum(tf.amount)\nFROM tickets t\nJOIN ticket_flights tf ON tf.ticket_no = t.ticket_no;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nFinalize Aggregate\n−> Gather\nWorkers Planned: 2\n−> Partial Aggregate\n−> Merge Join\nMerge Cond: (tf.ticket_no = t.ticket_no)\n−> Parallel Index Scan using ticket_flights_pkey o...\n−> Index Only Scan using tickets_pkey on tickets t\n(8 rows)\nПолныеиправыевнешниесоединенияслияниемвпараллельныхпланахне\nподдерживаются.\n1 backend/optimizer/path/joinpath.c,функцияconsider_parallel_mergejoin.\n476",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:00.602887"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 478,
    "chapter": null,
    "section": "23.1 Соединениеслиянием",
    "text": "23.1. Соединениеслиянием\nМодификации\nСоединение слиянием поддерживаетлюбые виды соединений.Единствен-\nное ограничение для полного и правого внешних соединений — условие\nсоединения должно содержать только выражения, подходящие для слия-\nния(равенствостолбцовизвнешнегоивнутреннегонаборовилиравенство\nстолбцаконстанте)1.Привнутреннемилевомвнешнемсоединенияхрезуль-\nтатслиянияпростофильтруетсяпонеподходящимусловиям,нодляполного\nиправогосоединенийтакаяфильтрацияневозможна.\nВотпримерполногосоединения,использующегоалгоритмслияния:\n=> EXPLAIN (costs off) SELECT *\nFROM tickets t\nFULL JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no\nORDER BY t.ticket_no;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSort\nSort Key: t.ticket_no\n−> Merge Full Join\nMerge Cond: (t.ticket_no = tf.ticket_no)\n−> Index Scan using tickets_pkey on tickets t\n−> Index Scan using ticket_flights_pkey on ticket_flights tf\n(6 rows)\nВнутреннее и левое соединения слиянием сохраняютпорядок сортировки.\nНодляполногоиправоговнешнихсоединенийэтонетак,посколькумежду\nупорядоченнымизначениямивнешнегонабораданныхмогутбытьвставле-\nнынеопределенныезначения—аэтонарушаетсортировку2.Поэтомуздесь\nпоявляется узел Sort, восстанавливающий нужный порядок. Это, конечно,\nувеличиваетстоимостьпланаиделаетхеш-соединениеболеепривлекатель-\nным,ипланировщиквыбралэтотплантолькопотому,чтохеш-соединения\nбылиотключены.\nНовследующемпримеренетиногоспособавыполнитьоперацию:вложен-\nныйциклвпринципенеподдерживаетполноесоединение,аслияниездесь\n1 backend/optimizer/path/joinpath.c,функцияselect_mergejoin_clauses.\n2 backend/optimizer/path/pathkeys.c,функцияbuild_join_pathkeys.\n477",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:00.639112"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 479,
    "chapter": null,
    "section": "23.1 Соединениеслиянием",
    "text": "Глава23. Сортировкаислияние\nнеприменимоиз-заусловиянеподходящеговида.Поэтомухеш-соединение\nиспользуется,даженесмотряназначениеenable_hashjoin:\n=> EXPLAIN (costs off) SELECT *\nFROM tickets t\nFULL JOIN ticket_flights tf ON tf.ticket_no = t.ticket_no\nAND tf.amount > 0\nORDER BY t.ticket_no;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSort\nSort Key: t.ticket_no\n−> Hash Full Join\nHash Cond: (tf.ticket_no = t.ticket_no)\nJoin Filter: (tf.amount > '0'::numeric)\n−> Seq Scan on ticket_flights tf\n−> Hash\n−> Seq Scan on tickets t\n(8 rows)\nВосстановим отключенную ранее возможность использования хеш-соеди-\nнений:\n=> RESET enable_hashjoin;\n23.2. Сортировка\nЕсли какой-то из наборов строк (а возможно, и оба) не отсортирован по\nключу соединения, перед выполнением слияния он должен быть переупо-\nрядочен.Такаяявнаясортировкапредставляетсявпланевыполненияузлом\nSort1:\n=> EXPLAIN (costs off)\nSELECT *\nFROM flights f\nJOIN airports_data dep ON f.departure_airport = dep.airport_code\nORDER BY dep.airport_code;\n1 backend/executor/nodeSort.c.\n478",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:00.667081"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 480,
    "chapter": null,
    "section": "23.2 Сортировка",
    "text": "23.2. Сортировка\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nMerge Join\nMerge Cond: (f.departure_airport = dep.airport_code)\n−> Sort\nSort Key: f.departure_airport\n−> Seq Scan on flights f\n−> Sort\nSort Key: dep.airport_code\n−> Seq Scan on airports_data dep\n(8 rows)\nТакая же сортировка можетприменяться и вне контекста соединений при\nиспользовании предложения ORDER BY,как самого по себе,так и в составе\nоконныхфункций:\n=> EXPLAIN (costs off)\nSELECT flight_id,\nrow_number() OVER (PARTITION BY flight_no ORDER BY flight_id)\nFROM flights f;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nWindowAgg\n−> Sort\nSort Key: flight_no, flight_id\n−> Seq Scan on flights f\n(4 rows)\nЗдесь узел WindowAgg1 вычисляет оконную функцию по набору данных,\nпредварительноотсортированномуузломSort.\nВарсеналепланировщикаимеетсянесколькоспособовсортировкиданных.\nВпримере,которыйяужепоказывал,используютсядваизних(SortMethod).\nКакобычно,этидеталипозволяетузнатькомандаEXPLAINANALYZE:\n=> EXPLAIN (analyze,costs off,timing off,summary off)\nSELECT *\nFROM flights f\nJOIN airports_data dep ON f.departure_airport = dep.airport_code\nORDER BY dep.airport_code;\n1 backend/executor/nodeWindowAgg.c.\n479",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:00.698671"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 481,
    "chapter": null,
    "section": "23.2 Сортировка",
    "text": "Глава23. Сортировкаислияние\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nMerge Join (actual rows=214867 loops=1)\nMerge Cond: (f.departure_airport = dep.airport_code)\n−> Sort (actual rows=214867 loops=1)\nSort Key: f.departure_airport\nSort Method: external merge Disk: 17120kB\n−> Seq Scan on flights f (actual rows=214867 loops=1)\n−> Sort (actual rows=104 loops=1)\nSort Key: dep.airport_code\nSort Method: quicksort Memory: 42kB\n−> Seq Scan on airports_data dep (actual rows=104 loops=1)\n(10 rows)\nБыстрая сортировка\nЕслисортируемыйнаборданныхпомещаетсявпамять,ограниченнуюзна-\n4MB чением параметра work_mem, применяется традиционная быстрая сорти-\nровка(quicksort).Этоталгоритмописанвовсехучебниках,такчтоянебуду\nегоповторять.\nСточки зрения реализации сортировка выполняется специальным компо-\nнентом1,которыйвыбираетнаиболееподходящийалгоритмвзависимости\nотдоступнойпамятиидругихфакторов.\nОценкастоимости. Вкачествепримеравозьмемсортировкунебольшойтаб-\nлицы.Вэтомслучаевыполняетсябыстраясортировкавпамяти:\n=> EXPLAIN SELECT *\nFROM airports_data\nORDER BY airport_code;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSort (cost=7.52..7.78 rows=104 width=145)\nSort Key: airport_code\n−> Seq Scan on airports_data (cost=0.00..4.04 rows=104 width=...\n(3 rows)\n1 backend/utils/sort/tuplesort.c.\n480",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:00.733957"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 482,
    "chapter": null,
    "section": "23.2 Сортировка",
    "text": "23.2. Сортировка\nИзвестно, что сортировка n значений имеет вычислительную сложность\nO(nlog n). Одна операция сравнения оценивается удвоенным значением\n2\nпараметра cpu_operator_cost. Поскольку результат можно получить, только 0.0025\nпрочитав и отсортировав весь набор данных, начальная стоимость сорти-\nровкиопределяетсяполнойстоимостьюдочернегоузлаистоимостьювсех\nоперацийсравнения.\nВ полную стоимостьсортировкидобавляется обработка каждой строки ре-\nзультата,котораяоцениваетсязначениемпараметраcpu_operator_cost (ане\ncpu_tuple_cost,какобычно,посколькудляузлаSortнакладныерасходыневе-\nлики)1.\nВнашемпримерестоимостьвычисляетсятак:\n=> WITH costs(startup) AS (\nSELECT 4.04 + round((\ncurrent_setting('cpu_operator_cost')::real * 2 *\n104 * log(2, 104)\n)::numeric, 2)\n)\nSELECT startup,\nstartup + round((\ncurrent_setting('cpu_operator_cost')::real * 104\n)::numeric, 2) AS total\nFROM costs;\nstartup | total\n−−−−−−−−−+−−−−−−−\n7.52 | 7.78\n(1 row)\nЧастичная пирамидальная сортировка\nЕсли нужно отсортировать не весь набор данных, а только его часть (что\nопределяется предложением LIMIT), может применяться частичная пира-\nмидальнаясортировка(top-Nheapsort).Точнее,этоталгоритмиспользуется,\nесли количество строк после сортировки уменьшается как минимум вдвое\nилиесливходнойнаборстрокнепомещаетсяцеликомвотведеннуюопера-\nтивнуюпамять(нодлявыходногонабораприэтомдостаточноместа).\n1 backend/optimizer/path/costsize.c,функцияcost_sort.\n481",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:00.765555"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 483,
    "chapter": null,
    "section": "23.2 Сортировка",
    "text": "Глава23. Сортировкаислияние\n=> EXPLAIN (analyze, timing off, summary off)\nSELECT * FROM seats\nORDER BY seat_no LIMIT 100;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nLimit (cost=72.57..72.82 rows=100 width=15)\n(actual rows=100 loops=1)\n−> Sort (cost=72.57..75.91 rows=1339 width=15)\n(actual rows=100 loops=1)\nSort Key: seat_no\nSort Method: top−N heapsort Memory: 32kB\n−> Seq Scan on seats (cost=0.00..21.39 rows=1339 width=15)\n(actual rows=1339 loops=1)\n(8 rows)\nЧтобы найти k максимальных (минимальных) значений из n, в структуру\nданных, называемую кучей,добавляются k первых строк. Затем по одной\nдобавляютсяи всеостальныестроки,но последобавления каждойследую-\nщей строки из кучи изымается одно наименьшее (наибольшее) значение.\nВрезультатевкучеостаютсяkискомыхзначений.\nКуча(heap),используемаявэтомалгоритме,являетсяструктуройданныхинеимеет\nничегообщегостаблицамибазыданных,которыечастоназываютэтимжетермином.\nОценка стоимости. СложностьалгоритмаоцениваетсякакO(nlog k),одна-\n2\nко каждая операция обходится дороже, чем в случае быстрой сортировки.\nПоэтомуформуларасчетастоимостииспользуетnlog 2k1.\n2\n=> WITH costs(startup) AS (\nSELECT 21.39 + round((\ncurrent_setting('cpu_operator_cost')::real * 2 *\n1339 * log(2, 2 * 100)\n)::numeric, 2)\n)\nSELECT startup,\nstartup + round((\ncurrent_setting('cpu_operator_cost')::real * 100\n)::numeric, 2) AS total\nFROM costs;\n1 backend/optimizer/path/costsize.c,функцияcost_sort.\n482",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:00.802208"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 484,
    "chapter": null,
    "section": "72.57 | 72.82",
    "text": "23.2. Сортировка\nstartup | total\n−−−−−−−−−+−−−−−−−\n72.57 | 72.82\n(1 row)\nВнешняя сортировка\nЕслипричтениинабораданныхвыясняется,чтоонслишкомвеликдлясор-\nтировкивоперативнойпамяти,узелсортировкипереключаетсянавнешнюю\nсортировкуслиянием(externalmerge).\nУже прочитанные строки сортируются в памяти алгоритмом быстрой сор-\nтировкиизаписываютсявовременныйфайл.\n1 2 3 4 5 1\nВосвобожденнуюпамятьчитаютсяследующиестроки,ипроцедураповто-\nряетсядотехпор,покавседанныенебудутзаписанывнесколькофайлов,\nкаждыйизкоторыхвотдельностиотсортирован.\n2 3 4 5 1 2\nДалее несколько файлов объединяются в один примерно тем же алгорит-\nмом,что используется и при соединении слиянием.Основное отличие со-\nстоитвтом,чтообъединятьсямогутболеедвухфайловодновременно.\n483",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 29,
        "content": "|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |"
      },
      {
        "table_index": 1,
        "rows": 1,
        "cols": 6,
        "content": "|  |  |  |  |"
      },
      {
        "table_index": 2,
        "rows": 1,
        "cols": 22,
        "content": "|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |"
      },
      {
        "table_index": 3,
        "rows": 1,
        "cols": 6,
        "content": "|  |  |  |  |"
      },
      {
        "table_index": 4,
        "rows": 1,
        "cols": 6,
        "content": "|  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T16:00:00.851489"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 485,
    "chapter": null,
    "section": "72.57 | 72.82",
    "text": "Глава23. Сортировкаислияние\nДля слияния нетребуется много памяти.В принципе,достаточно распола-\nгатьместомпододнустрокудлякаждогофайла.Изфайловчитаютсяпервые\nстроки,среди них выбирается минимальная (или максимальная,в зависи-\nмостиотнаправлениясортировки)ивозвращаетсякакчастьрезультата,ана\nееместочитаетсяноваястрокаизтогожефайла.\nНа практике строки читаются не по одной, а порциями по 32 страницы;\nэтоуменьшаетколичествооперацийввода-вывода.Количествофайлов,ко-\nторые объединяются за одну итерацию, определяется доступным местом\nвпамяти,номеньше шестине используетсяникогда.Сверхуэтоколичест-\nвотожеограничено(числом500),посколькуэффективностьтеряется,когда\nфайловстановитсяслишкоммного1.\nДляалгоритмовсортировкиванглийскомязыкеисторическисложиласьспециальная\nтерминология.Внешняясортировкаизначальноиспользоваланакопителинамагнит-\nной ленте,и компонент PostgreSQL,управляющий временными файлами,сохранил\nэтоназвание2.Частичноотсортированныенаборыданныхназываютсясловомrun(се-\nрия в русском переводе книги Кнута3).Количество серий,участвующих в слиянии,\nназывается merge order (порядокслияния).Я не использовал этитермины,но ихпо-\nлезнознать,чтобыпониматькодикомментарии.\nЕслиобъединитьвсеотсортированныевременныефайлызаоднуитерацию\nнеполучается,приходитсявыполнятьслияниефайловпочастямизаписы-\nватьрезультатвновыевременныефайлы.Каждаятакаяитерацияувеличи-\nвает объем записываемых и читаемых данных, поэтому чем больше опе-\nративной памяти доступно,тем эффективнее будет выполняться внешняя\nсортировка.\n1 2 3 4 5 1+2+3\n1 backend/utils/sort/tuplesort.c,функцияtuplesort_merge_order.\n2 backend/utils/sort/logtape.c.\n3 ДональдКнут.Искусствопрограммирования.Том3.Сортировкаипоиск.\n484",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 6,
        "content": "|  |  |  |  |"
      },
      {
        "table_index": 1,
        "rows": 1,
        "cols": 2,
        "content": "|"
      },
      {
        "table_index": 2,
        "rows": 1,
        "cols": 6,
        "content": "|  |  |  |  |"
      },
      {
        "table_index": 3,
        "rows": 1,
        "cols": 6,
        "content": "|  |  |  |  |"
      },
      {
        "table_index": 4,
        "rows": 1,
        "cols": 6,
        "content": "|  |  |  |  |"
      },
      {
        "table_index": 5,
        "rows": 1,
        "cols": 18,
        "content": "|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T16:00:00.908396"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 486,
    "chapter": null,
    "section": "23.2 Сортировка",
    "text": "23.2. Сортировка\n4 5 1+2+3 4+5\nНаследующейитерациислияниепродолжаетсяужесновымифайлами.\n1+2+3 4+5\nФинальноеслияниеобычнооткладываетсяивыполняетсяналету,когдавы-\nшестоящийузелпланазапрашиваетданные.\nКомандаEXPLAINANALYZEпоказываетобъемдисковойпамяти,которыйпо-\nтребовался внешней сортировке. Добавив ключевое слово buffers, мож-\nнополучитьистатистикуиспользованиябуфероввременныхфайлов(temp\nreadиwritten).Количествозаписанныхбуферовбудет(примерно)равноко-\nличествупрочитанных,иименноэтозначение,пересчитанноевкилобайты,\nпоказановпланевпозицииDisk:\n=> EXPLAIN (analyze, buffers, costs off, timing off, summary off)\nSELECT * FROM flights\nORDER BY scheduled_departure;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSort (actual rows=214867 loops=1)\nSort Key: scheduled_departure\nSort Method: external merge Disk: 17120kB\nBuffers: shared hit=2627, temp read=2140 written=2145\n−> Seq Scan on flights (actual rows=214867 loops=1)\nBuffers: shared hit=2624\n(6 rows)\n485",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 6,
        "content": "|  |  |  |  |"
      },
      {
        "table_index": 1,
        "rows": 1,
        "cols": 5,
        "content": "|  |  |  |"
      },
      {
        "table_index": 2,
        "rows": 1,
        "cols": 12,
        "content": "|  |  |  |  |  |  |  |  |  |  |"
      },
      {
        "table_index": 3,
        "rows": 1,
        "cols": 11,
        "content": "|  |  |  |  |  |  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T16:00:00.961037"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 487,
    "chapter": null,
    "section": "23.2 Сортировка",
    "text": "Глава23. Сортировкаислияние\nБолееподробнуюстатистикуиспользованиявременныхфайловможнопо-\nлучитьвжурналесообщений,установивпараметрlog_temp_files.\nОценкастоимости. Вкачествепримеравозьмемтотжеплансвнешнейсор-\nтировкой:\n=> EXPLAIN SELECT *\nFROM flights\nORDER BY scheduled_departure;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSort (cost=31883.96..32421.12 rows=214867 width=63)\nSort Key: scheduled_departure\n−> Seq Scan on flights (cost=0.00..4772.67 rows=214867 width=63)\n(3 rows)\nЗдеськобычнойстоимостисравнений(количествокоторыхостаетсятаким\nже, как и в случае быстрой сортировки в памяти) добавляется стоимость\nввода-вывода1.Все входныеданные придется сначала записатьнадиск во\nвременные файлы, а затем прочитать с диска при слиянии (причем, воз-\nможно,несколькораз,есликоличествосозданныхфайловбудетпревышать\nколичествоодновременнообъединяемыхнаборов).\nОбращениекдиску(изапись,ичтение)считаетсянатричетвертипоследо-\nвательныминаоднучетвертьслучайным.\nОбъем данных,попадающих на диск,определяется количеством сортируе-\nмых строк и числом столбцов, используемых в запросе2. В данном случае\nзапросвыводитвсестолбцытаблицыflights,поэтомунадискпопадетобъ-\nем,почти равный размеру всейтаблицы,за вычетом служебной информа-\nциивверсияхстрокистраницах(2309страницвместо2624).\nВнашемпримеренасортировкухватаетоднойитерации.\nТакимобразом,стоимостьсортировкивнашемпланевычисляетсятак:\n1 backend/optimizer/path/costsize.c,функцияcost_sort.\n2 backend/optimizer/path/costsize.c,функцияrelation_byte_size.\n486",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:00.996006"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 488,
    "chapter": null,
    "section": "23.2 Сортировка",
    "text": "23.2. Сортировка\n=> WITH costs(startup) AS (\nSELECT 4772.67 + round((\ncurrent_setting('cpu_operator_cost')::real * 2 *\n214867 * log(2, 214867) +\n(current_setting('seq_page_cost')::real * 0.75 +\ncurrent_setting('random_page_cost')::real * 0.25) *\n2 * 2309 * 1 -- одна итерация\n)::numeric, 2)\n)\nSELECT startup,\nstartup + round((\ncurrent_setting('cpu_operator_cost')::real * 214867\n)::numeric, 2) AS total\nFROM costs;\nstartup | total\n−−−−−−−−−−+−−−−−−−−−−\n31883.96 | 32421.13\n(1 row)\nИнкрементальная сортировка v.13\nЕслинаборданныхтребуетсяотсортироватьпоключамK …K …K ипри\n1 m n\nэтомизвестно,чтонаборужеотсортированпопервымmключам,тонеобя-\nзательнопересортировыватьвесьнаборзаново.Можноразбитьнабордан-\nныхнагруппы,имеющиеодинаковыезначенияначальныхключейK …K\n1 m\n(значения таких групп следуютдруг за другом), и затем отсортировать от-\nдельно каждую из групп по оставшимся ключам K …K . Такой способ\nm+1 n\nназываетсяинкрементальнойсортировкой.\nИнкрементальная сортировка уменьшает требования к памяти, разбивая\nвесьнаборнанесколькоменьшихгрупп,ипозволяетвыдаватьрезультаты\nужепослеобработкипервойгруппы,недожидаясьсортировкивсегонабора.\nРеализация1действуетболеетонко:отдельнообрабатываютсятолькоотно-\nсительнокрупныегруппыстрок,анебольшиеобъединяютсяисортируются\nполностью.Этоуменьшаетнакладныерасходынавызовсортировки2.\n1 backend/executor/nodeIncrementalSort.c.\n2 backend/utils/sort/tuplesort.c.\n487",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:01.029449"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 489,
    "chapter": null,
    "section": "23.2 Сортировка",
    "text": "Глава23. Сортировкаислияние\nВ плане выполнения инкрементальная сортировка представлена узлом\nIncrementalSort:\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT *\nFROM bookings\nORDER BY total_amount, book_date;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIncremental Sort (actual rows=2111110 loops=1)\nSort Key: total_amount, book_date\nPresorted Key: total_amount\nFull−sort Groups: 2823 Sort Method: quicksort Average\nMemory: 27kB Peak Memory: 27kB\nPre−sorted Groups: 2624 Sort Method: quicksort Average\nMemory: 1953kB Peak Memory: 2014kB\n−> Index Scan using bookings_total_amount_idx on bookings (ac...\n(8 rows)\nКак видно из плана, набор строк уже отсортирован по total_amount, по-\nскольку получен сканированием индекса, построенного по этому столб-\nцу (Presorted Key).Команда EXPLAIN ANALYZE показываеттакже статистику\nвремени выполнения.Строка Full-sort Groups относится к небольшим груп-\nпам,которые были объединены и отсортированы полностью,а строка Pre-\nsortedGroups—ккрупнымгруппам,которыедосортировывалисьпостолбцу\nbook_date.В обоих случаях использовалась быстрая сортировка в памяти.\nНаличиегруппразногоразмеравызванонеравномернымраспределением\nстоимостибронирований.\nv.14 Инкрементальная сортировка может использоваться и при вычислении\nоконныхфункций:\n=> EXPLAIN (costs off)\nSELECT row_number() OVER (ORDER BY total_amount, book_date)\nFROM bookings;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nWindowAgg\n−> Incremental Sort\nSort Key: total_amount, book_date\nPresorted Key: total_amount\n−> Index Scan using bookings_total_amount_idx on bookings\n(5 rows)\n488",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:01.068675"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 490,
    "chapter": null,
    "section": "23.2 Сортировка",
    "text": "23.2. Сортировка\nОценка стоимости. Расчет стоимости инкрементальной сортировки1 опи-\nраетсянаоценкуколичествагрупп2 иоценкусортировкигруппысреднего\nразмера(которуюмыужерассмотрели).\nНачальнаястоимостьотражаетоценкисортировкиодной(первой)группы,\nпослекоторойузелужеможетвыдаватьотсортированныестроки,аполная\nстоимостьучитываетсортировкувсехгрупп.\nПодробноостанавливатьсянавычисленииоценокянебуду.\nПараллельный режим\nСортировкаможетвыполнятьсяпараллельно.Нохотярабочиепроцессывы-\nдаютсвоючастьданныхвотсортированномвиде,узелGatherничегопроэто\nнезнаетиможетобъединятьданныетольковпорядкепоступления.Чтобы\nсохранитьсортировку,применяетсядругойузел—GatherMerge3.\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT *\nFROM flights\nORDER BY scheduled_departure\nLIMIT 10;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nLimit (actual rows=10 loops=1)\n−> Gather Merge (actual rows=10 loops=1)\nWorkers Planned: 1\nWorkers Launched: 1\n−> Sort (actual rows=9 loops=2)\nSort Key: scheduled_departure\nSort Method: top−N heapsort Memory: 27kB\nWorker 0: Sort Method: top−N heapsort Memory: 27kB\n−> Parallel Seq Scan on flights (actual rows=107434 lo...\n(9 rows)\nУзел Gather Merge использует двоичную кучу4 для упорядочения строк,\nпоступающих от нескольких процессов. По сути, он выполняет слияние\n1 backend/optimizer/path/costsize.c,функцияcost_incremental_sort.\n2 backend/utils/adt/selfuncs.c,функцияestimate_num_groups.\n3 backend/executor/nodeGatherMerge.c.\n4 backend/lib/binaryheap.c.\n489",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:01.102750"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 491,
    "chapter": null,
    "section": "23.2 Сортировка",
    "text": "Глава23. Сортировкаислияние\nнесколькихотсортированныхнаборовстрок,какпри внешнейсортировке,\nно алгоритм рассчитан на другие условия работы: на небольшое фиксиро-\nванноечислоисточниковиполучениестрокпоодной,безблочногодоступа.\nОценкастоимости. НачальнаястоимостьузлаGatherMergeопираетсянана-\nс.369 чальнуюстоимостьдочернегоузла.Кней(какидляузлаGather)добавляет-\nсястоимостьзапускапроцессов,котораяоцениваетсязначениемпараметра\n1000 parallel_setup_cost.\nСюда же добавляется оценка построения двоичной кучи, что требует сор-\nтировки n значений по числу параллельных процессов (то есть nlog n).\n2\nОдна операция сравнения оценивается удвоенным значением параметра\n0.0025 cpu_operator_cost,и общая сумма обычно пренебрежимо мала,поскольку n\nневелико.\nВ полную стоимость входят получение всех данных дочерним узлом, ко-\nторыйвыполняетсянесколькимипараллельнымипроцессами,истоимость\nпересылки строк отэтих процессов.Пересылка одной строки оценивается\n0.1 значениемпараметраparallel_tuple_cost,увеличеннымна5%,чтобыучесть\nвозможныепотериприожиданииполученияочередныхзначений.\nВ полнуюстоимостьвходиттакжеобновлениедвоичной кучи.Для каждой\nвходящей строки данных это требует log n операций сравнения и опре-\n2\nделенных вспомогательных действий (которые оцениваются значением\ncpu_operator_cost)1.\nВотещеодинпримерпланасузломGatherMerge.Онинтересентем,чтора-\nс.467 бочиепроцессывыполняютчастичнуюагрегациюспомощьюхеширования,\nзатемполученныерезультатысортируютсяузломSort(этодешево,посколь-\nкупослеагрегацииостаетсянемногострок)ипередаютсяведущемупроцес-\nсу,которыйсобираетполныйрезультатвузлеGatherMerge.Окончательная\nжеагрегациявыполняетсяпоотсортированномуспискузначений:\n=> EXPLAIN SELECT amount, count(*)\nFROM ticket_flights\nGROUP BY amount;\n1 backend/optimizer/path/costsize.c,функцияcost_gather_merge.\n490",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:01.140039"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 492,
    "chapter": null,
    "section": "23.3 Группировкаиуникальныезначения",
    "text": "23.3. Группировкаиуникальныезначения\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nFinalize GroupAggregate (cost=123426.68..123512.31 rows=338 wid...\nGroup Key: amount\n−> Gather Merge (cost=123426.68..123505.55 rows=676 width=14)\nWorkers Planned: 2\n−> Sort (cost=122426.65..122427.50 rows=338 width=14)\nSort Key: amount\n−> Partial HashAggregate (cost=122409.07..122412.46 r...\nGroup Key: amount\n−> Parallel Seq Scan on ticket_flights (cost=0.00...\n(9 rows)\nВданномслучаеколичествопараллельныхпроцессовравнотрем(включая\nосновной),истоимостьузлаGatherMergeвычисляетсятак:\n=> WITH costs(startup, run) AS (\nSELECT round((\n-- запуск процессов\ncurrent_setting('parallel_setup_cost')::real +\n-- построение кучи\ncurrent_setting('cpu_operator_cost')::real * 2 * 3 * log(2, 3)\n)::numeric, 2),\nround((\n-- передача строк\ncurrent_setting('parallel_tuple_cost')::real * 1.05 * 676 +\n-- обновление кучи\ncurrent_setting('cpu_operator_cost')::real * 2 * 676 * log(2, 3) +\ncurrent_setting('cpu_operator_cost')::real * 676\n)::numeric, 2)\n)\nSELECT 122426.65 + startup AS startup,\n122427.50 + startup + run AS total\nFROM costs;\nstartup | total\n−−−−−−−−−−−+−−−−−−−−−−−\n123426.67 | 123505.55\n(1 row)\n23.3. Группировка и уникальные значения\nКак мы только что видели, группировка значений для агрегации (и устра-\nнениядубликатов) можетвыполняться нетолько хешированием,нотакже с.468\n491",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:01.175691"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 493,
    "chapter": null,
    "section": "23.3 Группировкаиуникальныезначения",
    "text": "Глава23. Сортировкаислияние\nиспомощьюсортировки.Вотсортированномспискегруппыповторяющих-\nсязначенийэлементарновыделяютсязаодинпроход.\nВыбор уникальных значений из отсортированного списка представляется\nвпланеоченьпростымузломUnique1:\n=> EXPLAIN (costs off) SELECT DISTINCT book_ref\nFROM bookings\nORDER BY book_ref;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nResult\n−> Unique\n−> Index Only Scan using bookings_pkey on bookings\n(3 rows)\nv.15 УзелUniqueможетучаствоватьвпараллельномплане,устраняядубликаты\nвсписке,полученномотрабочихпроцессов:\n=> EXPLAIN (costs off) SELECT DISTINCT fare_conditions\nFROM ticket_flights;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nUnique\n−> Gather Merge\nWorkers Planned: 2\n−> Sort\nSort Key: fare_conditions\n−> HashAggregate\nGroup Key: fare_conditions\n−> Parallel Seq Scan on ticket_flights\n(8 rows)\nВ этом примере рабочие процессы выделяют уникальные значения в сво-\nих наборах данных с помощью хеширования в узле HashAggregate; общий\nсписок,собранный узлом Gather,сортируется в узле Sort и передается узлу\nUniqueдляокончательногоустранениядубликатов.\nДляагрегациииспользуетсядругойузел,GroupAggregate2:\n1 backend/executor/nodeUnique.c.\n2 backend/executor/nodeAgg.c,функцияagg_retrieve_direct.\n492",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:01.207506"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 494,
    "chapter": null,
    "section": "23.3 Группировкаиуникальныезначения",
    "text": "23.3. Группировкаиуникальныезначения\n=> EXPLAIN (costs off) SELECT book_ref, count(*)\nFROM bookings\nGROUP BY book_ref\nORDER BY book_ref;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nGroupAggregate\nGroup Key: book_ref\n−> Index Only Scan using bookings_pkey on bookings\n(3 rows)\nВ параллельных планахтакой узел будетназываться Partial GroupAggregate,\nаузел,завершающийагрегацию,—FinalizeGroupAggregate.\nОбестратегии—хешированиеисортировка—могутсовмещатьсяводном\nузле при группировке по нескольким наборам (в предложениях GROUPING\nSETS, CUBE или ROLLUP).Я не буду углубляться в весьма непростые детали\nалгоритма.Приведулишьодинпример,вкоторомгруппировкадолжнавы-\nчислятьсяпотремразнымстолбцам:\n=> EXPLAIN (costs off) SELECT count(*)\nFROM ticket_flights\nGROUP BY GROUPING SETS (fare_conditions, ticket_no, amount);\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nMixedAggregate\nHash Key: amount\nGroup Key: fare_conditions\nSort Key: ticket_no\nGroup Key: ticket_no\n−> Sort\nSort Key: fare_conditions\n−> Seq Scan on ticket_flights\n(8 rows)\nВотчтопроисходитпривыполненииэтогозапроса.Узелагрегации,который\nобозначен в плане как MixedAggregate, получает набор данных, отсортиро-\nванныхпостолбцуfare_conditions.\nНапервомэтапеэтотнаборсканируется,изначениягруппируютсяпостолб-\nцуfare_conditions (Group Key).Помересканированиястрокипереупоря-\nдочиваются по столбцу ticket_no (так, как это делает обычный узел Sort:\n493",
    "tables": [
      {
        "table_index": 0,
        "rows": 3,
        "cols": 1,
        "content": "Hash Key\nGroup Key\nSort Key"
      }
    ],
    "extracted_at": "2025-10-02T16:00:01.243745"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 495,
    "chapter": null,
    "section": "23.3 Группировкаиуникальныезначения",
    "text": "Глава23. Сортировкаислияние\nлибобыстройсортировкойвпамяти,еслиеедостаточно,либовнешнейсор-\nтировкой на диске) и одновременно с этим записываются в хеш-таблицу\nс ключом amount (так,как это делаетагрегация хешированием: либо в па-\nмяти,либосиспользованиемвременныхфайлов).\nНа втором этапе сканируется набор строк, отсортированный на предыду-\nщем этапе по столбцу ticket_no, и значения группируются по этому же\nстолбцу (Sort Key и вложенный Group Key).Если бытребовалась группиров-\nка сортировкой по еще одному столбцу,строки были бы пересортированы\nвнеобходимомдальшепорядке.\nНаконец,сканируетсяхеш-таблица,подготовленнаянапервомэтапе,изна-\nчениягруппируютсяпостолбцуamount(HashKey).\n23.4. Сравнение способов соединения\nИтак,для соединения двух наборов данных могут использоватьсятри раз-\nныхспособа,каждыйсосвоимидостоинствамиинедостатками.\nСоединение вложенным циклом нетребуетникакой подготовительной рабо-\nтыисразуначинаетвозвращатьрезультирующиестроки.Этоединственный\nиз способов соединения, которому не требуется просматривать внутрен-\nний набор полностью,еслидля него естьэффективный индексныйдоступ.\nЭтисвойстваделаюталгоритмвложенногоцикла(всочетаниисиндексами)\nидеальныммеханизмомдлякороткихOLTP-запросов,которыестроятсяна\nнебольшойвыборкестрок.\nНедостаток вложенного цикла проявляется с ростом объема данных. Для\nдекартова произведения этот алгоритм имеет квадратичную сложность —\nзатратыпропорциональныпроизведениюразмеровсоединяемыхнаборов\nданных.Декартовопроизведениенечастовстречаетсянапрактике;обычно\nдля каждой строки внешнего набораданных с помощью индекса просмат-\nривается некоторое количество строк внутреннего набора, и это среднее\nколичество не зависит от размера всего набора данных (например, сред-\nнееколичествобилетовводномбронированиинеменяетсясростомчисла\nбронированийикупленныхбилетов).Поэтомучасторостсложностибудет\nлинейным,анеквадратичным,хотяисбольшимкоэффициентом.\n494",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:01.282706"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 496,
    "chapter": null,
    "section": "23.4 Сравнениеспособовсоединения",
    "text": "23.4. Сравнениеспособовсоединения\nВажная особенность вложенного цикла состоит в его универсальности: он\nподдерживаетлюбыеусловиясоединения,втовремякакостальныеспосо-\nбыработаюттолькосэквисоединениями.Этодаетвозможностьвыполнять\nлюбые запросы слюбыми условиями (кроме полного соединения,которое\nнереализуетсявложеннымциклом),нонадопомнитьотом,чтонеэквисое-\nдинениебольшихобъемовпочтинавернякабудетвыполнятьсямедленнее,\nчемхотелосьбы.\nСоединение хешированием оченьэффективнодля больших наборовданных.\nПри наличии достаточного объема оперативной памяти онотребуетодно-\nкратного просмотра двух наборов данных, то есть имеет линейную слож-\nность.Всочетанииспоследовательнымсканированиемтаблицсоединение\nхешированиемчастовстречаетсявOLAP-запросах,вычисляющихрезультат\nнаоснованиибольшогообъемаданных.\nДля ситуаций, в которых время отклика важнее пропускной способности,\nхеш-соединение подходит хуже,поскольку результирующие строки не мо-\nгутвозвращаться,покахеш-таблицанепостроенаполностью.\nПрименение хеш-соединения ограничено эквисоединениями. Кроме того,\nтипданныхдолжендопускатьхеширование(этовыполняетсяпочтивсегда).\nВложенныйциклможетиногдасоставитьконкуренциюсоединениюхеши- v.14\nрованием за счет кеширования строк внутреннего набора в узле Memoize\n(такжеоснованногонахеш-таблице).Выигрышможетдостигатьсяблагода-\nрятому,чтосоединениехешированиемвсегдапросматриваетвнутренний\nнаборстрокполностью,аалгоритмвложенногоцикла—нет.\nСоединениеслияниемотличноподходитидлякороткихOLTP-запросов,идля\nдлинных запросов OLAP.Оно имеетлинейную сложность (требуется одно-\nкратный просмотр соединяемых наборов строк),нетребовательно к памя-\nтиивыдаетрезультатыбезпредварительнойподготовки—правда,наборы\nданныхдолжны бытьотсортированы в правильном порядке.Наиболее эф-\nфективныйспособдобитьсяэтого—получатьданныеотиндексногоскани-\nрования.Этоестественныйвариантдлянебольшогоколичествастрок;при\nбольшом объеме данных индексный доступтоже может быть эффективен,\nесли это только индексное сканирование с минимальными обращениями\nктаблицеиливовсебезних.\n495",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:01.322062"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 497,
    "chapter": null,
    "section": "23.4 Сравнениеспособовсоединения",
    "text": "Глава23. Сортировкаислияние\nЕсли подходящих индексов нет, то наборы данных придется сортировать,\nасортировкатребуетпамятииимеетсложностьвышелинейной:O(nlog n).\n2\nВтакомслучаесоединениеслияниемпочтивсегдапроигрываетсоединению\nхешированием—заисключениемситуации,когдарезультатнуженотсорти-\nрованным.\nПриятнымсвойствомсоединенияслияниемявляетсяравноценностьвнеш-\nнего и внутреннего наборов строк. Эффективность и вложенного цикла,\nи хеш-соединения сильно зависитоттого,правильноли планировщик вы-\nберет,какойизнаборовданныхпоставитьвнешним,акакой—внутренним.\nПрименение соединения слиянием ограничено эквисоединениями.Кроме\nс.526 того,типданныхдолжениметьклассоператоровдляB-дерева.\nНижепоказанпримерныйграфикзависимостистоимостейразличныхспо-\nсобовсоединенийотдолисоединяемыхстрок.\nстоимость\nmerge join + sort\nn\neste d lo o p\nhashjoin\nmergejoin+index\nселективность\n0 1\nСоединениевложеннымцикломпривысокойселективностииспользуетин-\nдексный доступ к обеимтаблицам; затем планировщик переключается на\nполноесканированиевнешнейтаблицы,играфикстановитсялинейным.\nСоединение хешированием используетв этом примере полное сканирова-\nние обеих таблиц. «Ступенька» на графике возникает в тот момент, когда\n496",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:01.405218"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 498,
    "chapter": null,
    "section": "23.4 Сравнениеспособовсоединения",
    "text": "23.4. Сравнениеспособовсоединения\nхеш-таблица перестаетпомещаться в оперативной памяти и пакеты начи-\nнаютсбрасыватьсянадиск.\nСоединение слиянием с использованием индекса показывает небольшой\nлинейный ростстоимости.Придостаточном объеме work_mem соединение\nхешированиемобычнооказываетсяэффективнее,нокогдаделодоходитдо\nвременныхфайлов,соединениеслияниемвыигрывает.\nВерхнийграфиксоединенияслияниемссортировкойпоказываетростсто-\nимостивситуации,когдаиндексынедоступныиданныеприходитсясорти-\nровать.Как и в случае соединения хешированием,«ступенька» на графике\nвызвана недостатком памяти и необходимостью использовать для сорти-\nровкивременныефайлы.\nЭтотолькопример;вкаждомконкретномслучаесоотношениястоимостей,\nразумеется,будутотличаться.\n497",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:01.418961"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 502,
    "chapter": null,
    "section": "24.1 Общий принцип",
    "text": "24\nХеш-индекс\n24.1. Общий принцип\nХеш-индекс1позволяетпоключуиндексированиябыстронайтиидентифи-\nкаторверсиистроки(tid).Впервомприближенииэтопростохеш-таблица,\nхранящаясянадиске.Единственнаяоперация,которуюподдерживаетхеш-\nиндекс,—поискпоусловиюравенства.\nПри вставке в индекс2 вычисляется хеш-функция от значения ключа ин-\nдексирования. Хеш-функции в PostgreSQL возвращают 32-битные или 64-\nбитныецелые,авкачественомеракорзиныиспользуютсянесколькомлад-\nшихбитовэтогозначения.Ввыбраннуюкорзинудобавляетсяидентифика-\nторверсиивместесхеш-кодомключа.Самозначениеключанесохраняется\nвиндексе,посколькуреализацииудобнееиметьделоснебольшимизначе-\nниямификсированнойдлины.\nХеш-таблицаиндексадинамическирасширяется3.Минимальноечислокор-\nзинравнодвум.Помереувеличенияколичестваиндексируемыхстрокодна\nиз корзин расщепляется на две.Для этого задействуется дополнительный\nбит хеш-кода,так что элементы перераспределяются только между двумя\nкорзинами,участвующимиврасщеплении,асоставостальныхкорзинхеш-\nтаблицынеменяется4.\n1 postgrespro.ru/docs/postgresql/17/hash-index;\nbackend/access/hash/README.\n2 backend/access/hash/hashinsert.c.\n3 backend/access/hash/hashpage.c,функция_hash_expandtable.\n4 backend/access/hash/hashpage.c,функция_hash_getbucketbuf_from_hashkey.\n501",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:01.446038"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 503,
    "chapter": null,
    "section": "24.1 Общий принцип",
    "text": "Глава24. Хеш-индекс\nПри поиске в индексе1 вычисляется хеш-функция от ключа индексирова-\nния и соответствующий этому значению номер корзины. Из всего содер-\nжимогокорзинывозвращаютсятолькотеидентификаторыверсий,которые\nсоответствуютхеш-коду ключа.Благодарятому,что элементы корзин упо-\nрядоченыпохеш-кодамключей,подходящиеидентификаторыэффективно\nнаходятсядвоичнымпоиском.\nПосколькусамозначениеключанесохраняетсявхеш-таблице,индексный\nметод может вернуть лишние идентификаторы версий строк из-за хеш-\nс.398 коллизий.Поэтомумеханизминдексированияперепроверяетвсеполучен-\nные от метода доступа результаты по таблице.По этой же причине невоз-\nможносканированиетолькоиндекса.\n24.2. Страничная организация\nВотличиеотобычнойхеш-таблицыиндексхранитсянадиске.Поэтомувся\nнеобходимая информация должна быть разложена по страницам, причем\nжелательно,чтобыоперациямнадиндексом(поиск,вставка,удаление)тре-\nбовалсядоступккакможноменьшемуколичествустраниц.\nХеш-индексиспользуетстраницычетырехвидов:\n• метастраница(metapage)—нулеваястраницас«оглавлением»индекса;\n• страницыкорзин(bucketpage)—основныестраницыиндекса,поодной\nнакаждуюкорзину;\n• страницы переполнения (overflow page) — дополнительные страницы,\nкоторые используются, когда основной страницы корзины не хватает\nдляразмещениявсехэлементов;\n• страницы битовой карты (bitmap page) — страницы с битовым масси-\nвом,вкоторомотмеченыосвободившиесяидоступныедляповторного\nиспользованиястраницыпереполнения.\n1 backend/access/hash/hashsearch.c.\n502",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:01.475891"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 504,
    "chapter": null,
    "section": "24.2 Страничнаяорганизация",
    "text": "24.2. Страничнаяорганизация\nЗаглянутьвнутрьиндексныхстраницпозволяетрасширениеpageinspect.\nНачнемспустойтаблицы:\n=> CREATE EXTENSION pageinspect;\n=> CREATE TABLE t(n integer);\n=> ANALYZE t;\n=> CREATE INDEX ON t USING hash(n);\nЯпроанализировалтаблицу,чтобыиндекссоздалсяминимальногоразмера; v.14\nиначеколичествокорзинсоответствовалобытаблицеиз10страниц1.\nСейчасвиндексечетырестраницы:метастраница,двеосновныестраницы\nкорзиниоднастраницабитовойкарты(сразусозданная«прозапас»):\n=> SELECT page, hash_page_type(get_raw_page('t_n_idx', page))\nFROM generate_series(0,3) page;\npage | hash_page_type\n−−−−−−+−−−−−−−−−−−−−−−−\n0 | metapage\n1 | bucket\n2 | bucket\n3 | bitmap\n(4 rows)\nмета- битовая\nккооррззииннаа00 ккооррззииннаа11\nстраница карта\nМетастраница содержитвсю управляющую информацию об индексе.Пока\nнасинтересуетнесколькозначений:\n=> SELECT ntuples, ffactor, maxbucket\nFROM hash_metapage_info(get_raw_page('t_n_idx', 0));\nntuples | ffactor | maxbucket\n−−−−−−−−−+−−−−−−−−−+−−−−−−−−−−−\n0 | 307 | 1\n(1 row)\n1 backend/access/table/tableam.c,функцияtable_block_relation_estimate_size.\n503",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 2,
        "content": "ккооррззииннаа00 | ккооррззииннаа11"
      }
    ],
    "extracted_at": "2025-10-02T16:00:01.506560"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 505,
    "chapter": null,
    "section": "24.2 Страничнаяорганизация",
    "text": "Глава24. Хеш-индекс\nРасчетноеколичествострокнаоднукорзинупоказановполеffactor.Это\nзначениевычисляетсяисходяизвместимостиблокаиустановленногозна-\n75 ченияпараметрахраненияfillfactor.Присовершенноравномерномраспре-\nделенииданныхиотсутствиихеш-коллизийзначениеfillfactor можнобыло\nбы и увеличить, но в реальности это повышает вероятность того, что эле-\nментыоднойкорзинынепоместятсянаоднустраницу.\nСамыйплохойдляхеш-индексаслучай—сильныйперекосвраспределении\nданных,когда один ключ повторяется много раз.Поскольку хеш-функция\nбудет выдавать одно и то же значение, все данные будут попадать в одну\nитужекорзину,иувеличениеколичествакорзинничемнепоможет.\nСейчас индекс пуст, о чем говорит значение поля ntuples. Переполним\nстраницукорзины,вставиввтаблицуопределенноеколичествостроксоди-\nнаковымзначениеминдексируемогостолбца.Виндексепоявитсястраница\nпереполнения:\n=> INSERT INTO t(n)\nSELECT 0 FROM generate_series(1,500); -- одно значение\n=> SELECT page, hash_page_type(get_raw_page('t_n_idx', page))\nFROM generate_series(0,4) page;\npage | hash_page_type\n−−−−−−+−−−−−−−−−−−−−−−−\n0 | metapage\n1 | bucket\n2 | bucket\n3 | bitmap\n4 | overflow\n(5 rows)\nпереполнение\nмета- битовая\nккооррззииннаа00 ккооррззииннаа11 ккккооооррррззззииииннннаааа1111\nстраница карта\nСводка информации по страницам показывает,что корзина 0 пуста,а все\nзначенияпопаливкорзину1:частьнаосновнуюстраницу,ате,чтонепо-\nместились,—настраницупереполнения.\n504",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 2,
        "content": "ккооррззииннаа00 | ккооррззииннаа11"
      }
    ],
    "extracted_at": "2025-10-02T16:00:01.547175"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 506,
    "chapter": null,
    "section": "24.2 Страничнаяорганизация",
    "text": "24.2. Страничнаяорганизация\n=> SELECT page, live_items, free_size, hasho_bucket\nFROM (VALUES (1), (2), (4)) p(page),\nhash_page_stats(get_raw_page('t_n_idx', page));\npage | live_items | free_size | hasho_bucket\n−−−−−−+−−−−−−−−−−−−+−−−−−−−−−−−+−−−−−−−−−−−−−−\n1 | 0 | 8148 | 0\n2 | 407 | 8 | 1\n4 | 93 | 6288 | 1\n(3 rows)\nОчевидно,чторазбросэлементоводнойкорзиныпонесколькимстраницам\nплохосказываетсянапроизводительности.Лучшиерезультатыхеш-индекс\nпоказываетнаравномернораспределенныхданных.\nПосмотримтеперь,какрасщепляетсякорзина.Этопроисходит,когдаколи-\nчествостроквиндексепревышаетрасчетноечислоffactorдляимеющихся\nкорзин.Вданномслучаепридвухкорзинахиffactor =307этопроизойдет,\nкогдавиндексбудетвставлена615-ястрока:\n=> SELECT ntuples, ffactor, maxbucket, ovflpoint\nFROM hash_metapage_info(get_raw_page('t_n_idx', 0));\nntuples | ffactor | maxbucket | ovflpoint\n−−−−−−−−−+−−−−−−−−−+−−−−−−−−−−−+−−−−−−−−−−−\n500 | 307 | 1 | 1\n(1 row)\n=> INSERT INTO t(n)\nSELECT n FROM generate_series(1,115) n; -- теперь разные\n=> SELECT ntuples, ffactor, maxbucket, ovflpoint\nFROM hash_metapage_info(get_raw_page('t_n_idx', 0));\nntuples | ffactor | maxbucket | ovflpoint\n−−−−−−−−−+−−−−−−−−−+−−−−−−−−−−−+−−−−−−−−−−−\n615 | 307 | 2 | 2\n(1 row)\nЗначение maxbucket увеличилось до двух: теперь у нас есть три корзины\nс номерами от 0 до 2. Но хотя добавилась всего одна корзина, количество\nстраницудваивается:\n=> SELECT page, hash_page_type(get_raw_page('t_n_idx', page))\nFROM generate_series(0,6) page;\n505",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:01.584643"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 507,
    "chapter": null,
    "section": "24.2 Страничнаяорганизация",
    "text": "Глава24. Хеш-индекс\npage | hash_page_type\n−−−−−−+−−−−−−−−−−−−−−−−\n0 | metapage\n1 | bucket\n2 | bucket\n3 | bitmap\n4 | overflow\n5 | bucket\n6 | unused\n(7 rows)\nмета- битовая\nккооррззииннаа00 ккооррззииннаа11 ккккооооррррззззииииннннаааа1111 ккооррззииннаа22\nстраница карта\nОднаизновыхстраницзадействованаподкорзину2,адругаяостаетсянеза-\nнятойибудетиспользованадлякорзины3,когдатапоявится.\n=> SELECT page, live_items, free_size, hasho_bucket\nFROM (VALUES (1), (2), (4), (5)) p(page),\nhash_page_stats(get_raw_page('t_n_idx', page));\npage | live_items | free_size | hasho_bucket\n−−−−−−+−−−−−−−−−−−−+−−−−−−−−−−−+−−−−−−−−−−−−−−\n1 | 27 | 7608 | 0\n2 | 407 | 8 | 1\n4 | 158 | 4988 | 1\n5 | 23 | 7688 | 2\n(4 rows)\nТакимобразом,сточкизренияоперационнойсистемыразмерхеш-индекса\nрастет скачкообразно, хотя логически хеш-таблица увеличивается посте-\nпенно.\nЧтобынемногосгладитьэтотростиневыделятьсразуслишкоммногостра-\nниц,начинаяс10-гоудвоениястраницывыделяютсяневсесразу,ачастями\nпо 1 отрасчетногоколичества.\n4\nЕщедваполяизметастраницы,представляющихсобойбитовыемаски,рас-\nкрываютдеталиадресациикорзин:\n=> SELECT maxbucket, highmask::bit(4), lowmask::bit(4)\nFROM hash_metapage_info(get_raw_page('t_n_idx', 0));\n506",
    "tables": [
      {
        "table_index": 0,
        "rows": 2,
        "cols": 1,
        "content": "bucket\nunused"
      },
      {
        "table_index": 1,
        "rows": 1,
        "cols": 2,
        "content": "ккооррззииннаа00 | ккооррззииннаа11"
      },
      {
        "table_index": 2,
        "rows": 1,
        "cols": 2,
        "content": "ккооррззииннаа22 |"
      }
    ],
    "extracted_at": "2025-10-02T16:00:01.624557"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 508,
    "chapter": null,
    "section": "24.2 Страничнаяорганизация",
    "text": "24.2. Страничнаяорганизация\nmaxbucket | highmask | lowmask\n−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−\n2 | 0011 | 0001\n(1 row)\nНомер корзины определяется битами хеш-кода,соответствующими маске\nhighmask.Но если полученный номер корзины не существует(превышает\nmaxbucket),тонадовзятьбиты,соответствующиемаскеlowmask1.Вданном\nслучаемыберемдвамладшихбита,чтодаетзначенияот0до3;ноесливы-\nпадает3,тоберемтолькоодинмладшийбит,тоестьвместотретьейкорзины\nиспользуемпервую.\nПри каждом удвоении размера новые страницы корзин всегда выделяют-\nсяоднимнепрерывнымфрагментом,астраницыпереполненияибитовой\nкарты вставляются между этими фрагментами по необходимости. Мета-\nстраницахранитколичествовставленныхстраницдлякаждогоизфрагмен-\nтоввмассивеspares,иэтодаетвозможностьпономерукорзинывычислить\nномерееосновнойстраницы2.\nВданномслучаепослепервогоудвоениябыловставленодвестраницы(би-\nтоваякартаистраницапереполнения),апослевторогопоканедобавилось\nничегонового:\n=> SELECT spares[2], spares[3]\nFROM hash_metapage_info(get_raw_page('t_n_idx', 0));\nspares | spares\n−−−−−−−−+−−−−−−−−\n2 | 2\n(1 row)\nВметастраницетакжехранитсямассивссылокнастраницыбитовойкарты:\n=> SELECT mapp[1]\nFROM hash_metapage_info(get_raw_page('t_n_idx', 0));\nmapp\n−−−−−−\n3\n(1 row)\n1 backend/access/hash/hashutil.c,функция_hash_hashkey2bucket.\n2 include/access/hash.h,макросBUCKET_TO_BLKNO.\n507",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:01.655901"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 509,
    "chapter": null,
    "section": "24.2 Страничнаяорганизация",
    "text": "Глава24. Хеш-индекс\nspares\nмета- битовая\nккооррззииннаа00 ккооррззииннаа11 ккооррззииннаа11 ккооррззииннаа22\nстраница карта\nmmap\nМесто внутри индексных страниц освобождается при удалении ссылок на\nмертвыеверсиистрок.Этопроисходитпривнутристраничнойочистке(она\nсрабатываетприпопыткевставкиэлементавполностьюзаполненнуюстра-\nницу1)илиприобычнойочистке.\nНо уменьшаться в размерах хеш-индекс не умеет,и однажды выделенные\nстраницы уже не возвращаются операционной системе.Основные страни-\nцы всегда закреплены за своими корзинами,даже если в них нетни одно-\nго элемента; опустевшие страницы переполнения отслеживаются в бито-\nвой карте и переиспользуются (возможно,ужедлядругой корзины).Един-\nственный вариант уменьшить физический размер индекса—перестроить\nс.165 егокомандойREINDEXилиVACUUMFULL.\nВпланезапросатипиндексаникакнеотмечается:\n=> CREATE INDEX ON flights USING hash(flight_no);\n=> EXPLAIN (costs off)\nSELECT *\nFROM flights\nWHERE flight_no = 'PG0001';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on flights\nRecheck Cond: (flight_no = 'PG0001'::bpchar)\n−> Bitmap Index Scan on flights_flight_no_idx\nIndex Cond: (flight_no = 'PG0001'::bpchar)\n(4 rows)\n1 backend/access/hash/hashinsert.c,функция_hash_vacuum_one_page.\n508",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 2,
        "content": "ккооррззииннаа00 | ккооррззииннаа11"
      },
      {
        "table_index": 1,
        "rows": 1,
        "cols": 2,
        "content": "ккооррззииннаа22 |"
      }
    ],
    "extracted_at": "2025-10-02T16:00:01.693885"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 510,
    "chapter": null,
    "section": "24.3 Класс операторов",
    "text": "24.3. Классоператоров\n24.3. Класс операторов\nДоверсииPostgreSQL10хеш-индексынежурналировались,тоестьнебыли\nзащищены от сбоев и не реплицировались, и, как следствие, не рекомен-\nдовались к использованию. Но даже в таком виде они представляли опре-\nделенную ценность. Дело в том, что алгоритм хеширования применяется\nочень широко (в частности,для хеш-соединений и группировок), и систе- с.446\nме требуется знать, какая хеш-функция предназначена для каждого типа\nданных.Ноэтосоответствиенестатично:егонельзязадатьразинавсегда,\nпосколькуPostgreSQLпозволяетдобавлятьновыетипыданныхналету.По-\nэтому соответствие поддерживается классом операторов для хеш-индекса с.384\nи конкретного типа данных. Собственно функция хеширования представ-\nленаопорнойфункциейкласса:\n=> SELECT opfname AS opfamily_name,\namproc::regproc AS opfamily_procedure\nFROM pg_am am\nJOIN pg_opfamily opf ON opfmethod = am.oid\nJOIN pg_amproc amproc ON amprocfamily = opf.oid\nWHERE amname = 'hash'\nAND amprocnum = 1\nORDER BY opfamily_name, opfamily_procedure;\nopfamily_name | opfamily_procedure\n−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−\naclitem_ops | hash_aclitem\narray_ops | hash_array\nbool_ops | hashchar\nbpchar_ops | hashbpchar\nbpchar_pattern_ops | hashbpchar\nbytea_ops | hashvarlena\n...\ntimestamptz_ops | timestamp_hash\ntimetz_ops | timetz_hash\nuuid_ops | uuid_hash\nxid8_ops | hashint8\nxid_ops | hashint4\n(38 rows)\nЭти функции возвращают32-битные целые числа.Хотя они и недокумен-\nтированы,ихможноиспользоватьдлявычисленияхеш-кодазначениясоот-\nветствующеготипа.\n509",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:02.238746"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 511,
    "chapter": null,
    "section": "24.3 Класс операторов",
    "text": "Глава24. Хеш-индекс\nНапример,длясемействаtext_opsиспользуетсяфункцияhashtext:\n=> SELECT hashtext('раз'), hashtext('два');\nhashtext | hashtext\n−−−−−−−−−−−+−−−−−−−−−−−\n127722028 | 345620034\n(1 row)\nВклассоператоровхеш-индексавходитодиноператор—«равно».Обычно\nименноониспользуетсядлясистемныхпроверокзначенийнаравенство.\n=> SELECT opfname AS opfamily_name,\nleft(amopopr::regoperator::text, 20) AS opfamily_operator\nFROM pg_am am\nJOIN pg_opfamily opf ON opfmethod = am.oid\nJOIN pg_amop amop ON amopfamily = opf.oid\nWHERE amname = 'hash'\nORDER BY opfamily_name, opfamily_operator;\nopfamily_name | opfamily_operator\n−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−\naclitem_ops | =(aclitem,aclitem)\narray_ops | =(anyarray,anyarray)\nbool_ops | =(boolean,boolean)\n...\nxid8_ops | =(xid8,xid8)\nxid_ops | =(xid,xid)\n(48 rows)\n24.4. Свойства\nс.391 Посмотрим свойства хеш-индекса, которые этот метод доступа сообщает\nосебесистеме.\nСвойства метода доступа\n=> SELECT a.amname, p.name, pg_indexam_has_property(a.oid, p.name)\nFROM pg_am a, unnest(array[\n'can_order', 'can_unique', 'can_multi_col',\n'can_exclude', 'can_include'\n]) p(name)\nWHERE a.amname = 'hash';\n510",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:02.271077"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 512,
    "chapter": null,
    "section": "24.4 Свойства",
    "text": "24.4. Свойства\namname | name | pg_indexam_has_property\n−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−\nhash | can_order | f\nhash | can_unique | f\nhash | can_multi_col | f\nhash | can_exclude | t\nhash | can_include | f\n(5 rows)\nОчевидно, что хеш-индексы не позволяют упорядочивать строки: хеш-\nфункцияперемешиваетданныеболееилименееслучайнымобразом.\nНе поддерживается и ограничение уникальности. Правда, хеш-индексы\nможноиспользоватьдляограниченияисключения,асединственнойфунк- с.395\nцией«равно»исключениеприобретаетсмыслуникальности:\n=> ALTER TABLE aircrafts_data\nADD CONSTRAINT unique_range EXCLUDE USING hash(range WITH =);\n=> INSERT INTO aircrafts_data\nVALUES ('744','{\"ru\": \"Боинг 747-400\"}',11100);\nERROR: conflicting key value violates exclusion constraint\n\"unique_range\"\nDETAIL: Key (range)=(11100) conflicts with existing key\n(range)=(11100).\nТакже не поддерживаются многоколоночные хеш-индексы и возможность\nдобавитькиндексудополнительныеinclude-столбцы.\nСвойства индекса\n=> SELECT p.name, pg_index_has_property('flights_flight_no_idx', p.name)\nFROM unnest(array[\n'clusterable', 'index_scan', 'bitmap_scan', 'backward_scan'\n]) p(name);\nname | pg_index_has_property\n−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−\nclusterable | f\nindex_scan | t\nbitmap_scan | t\nbackward_scan | t\n(4 rows)\n511",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:02.304032"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 513,
    "chapter": null,
    "section": "24.4 Свойства",
    "text": "Глава24. Хеш-индекс\nХеш-индекс работает как с обычным индексным сканированием,так и со\nсканированиемпобитовойкарте.\nКластеризациятаблицыпохеш-индексунепредусмотрена.Этологично,по-\nсколькусложнопредставить,зачемможетпонадобитьсяфизическиупоря-\nдочитьданныевтаблицепозначениюхеш-функции.\nСвойства столбцов\nФактическисвойствастолбцовполностьюопределенынауровнеметодадо-\nступаивсегдапринимаютодниитежезначения.\n=> SELECT p.name,\npg_index_column_has_property('flights_flight_no_idx', 1, p.name)\nFROM unnest(array[\n'asc', 'desc', 'nulls_first', 'nulls_last', 'orderable',\n'distance_orderable', 'returnable', 'search_array', 'search_nulls'\n]) p(name);\nname | pg_index_column_has_property\n−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nasc | f\ndesc | f\nnulls_first | f\nnulls_last | f\norderable | f\ndistance_orderable | f\nreturnable | f\nsearch_array | f\nsearch_nulls | f\n(9 rows)\nПоскольку хеш-функция не сохраняет отношение порядка, к хеш-индексу\nнеприменимысвойства,касающиесяупорядоченности.\nХеш-индекснеможетучаствоватьвсканированиитолькоиндекса,посколь-\nкунесохраняетключиндексацииитребуетперепроверкипотаблице.\nХеш-индекснеработаетснеопределеннымизначениями:операция«равно»\nнеимеетсмысладляNULL.\nПоискзначенийизмассиванереализован.\n512",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:02.333493"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 514,
    "chapter": null,
    "section": "25.1 Общий принцип",
    "text": "25\nB-дерево\n25.1. Общий принцип\nB-дерево (метод доступа btree) — структура данных, которая позволяет\nбыстронайтинужныйэлементвлистьяхдерева,спускаяськнемуоткорня1.\nЧтобыпутьпоискабылоднозначноопределен,элементывдереведолжны\nбытьупорядочены.B-деревопредназначенодляпорядковыхтиповданных,\nзначениякоторыхможносравниватьисортировать.\nНа схематично показанном индексе, построенном по кодам аэропортов,\nвнутренниеузлыизображеныгоризонтально,алистовые—вертикально:\nAAEERR OOVVBB\nAAEERR DDMMEE KKZZNN OOVVBB RROOVV SSVVOO\nAAEERR DDMMEE KKZZNN OOVVBB RROOVV SSVVOO\nBBZZKK HHMMAA LLEEDD OOVVSS SSGGCC SSVVXX\nKKJJAA NNUUXX PPEEEE VVKKOO\n1 postgrespro.ru/docs/postgresql/17/btree;\nbackend/access/nbtree/README.\n513",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:02.380437"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 515,
    "chapter": null,
    "section": "25.1 Общий принцип",
    "text": "Глава25. B-дерево\nКаждыйузелдеревасодержитнесколькоэлементов,состоящихизключаин-\nдексирования и ссылки.Элементы внутренних узлов дерева ссылаются на\nузлыследующегоуровня,аэлементылистовыхузлов—наверсиистроктаб-\nлицы(нарисункеэтиссылкинепоказаны).\nB-деревьяобладаютнесколькимиважнымисвойствами:\n• Онисбалансированы,тоестьвселистьянаходятсянаоднойглубине.По-\nэтомупоисклюбогозначениязанимаетодинаковоевремя.\n• Онисильноветвисты,тоестькаждыйузелсодержитмногоэлементов,\nчастосотни(нарисункеузлысостоятвсегоизтрехэлементовисключи-\nтельнодля наглядности).За счетэтого глубина B-деревьев получается\nнебольшойдажедляоченьбольшихтаблиц.\nДоподлинно неизвестно,что означает буква «B» в названии дерева.Одинако-\nвохорошоподходитиbalanced(сбалансированное),иbushy(ветвистое).Нона\nудивлениечастовстречаетсярасшифровкаbinary(двоичное),которая,конечно,\nневерна.\n• Данныевиндексеупорядоченыповозрастанию(илипоубыванию)как\nмеждуузлами,такивнутрикаждогоузла.Узлыодногоуровнясвязаны\nмеждусобойдвунаправленнымсписком,поэтомуможнополучитьупо-\nрядоченныйнаборданных,простопройдяпоспискуводнуиливдру-\nгуюсторону,неповторяякаждыйразпутьоткорня.\n25.2. Поиск и вставка\nПоиск по равенству\nРассмотримпоиск1 значениявдеревепоусловию«индексированный-стол-\nбец=выражение».Допустим,насинтересуетаэропортKJA(Красноярск).\nПоиск начинается с корневого узла, и метод доступа должен определить,\nвкакойиздочернихузловспускаться.ВыбираетсяключK,длякотороговер-\ni\nноK ⩽выражение<K .\ni i+1\n1 backend/access/nbtree/nbtsearch.c,функция_bt_search.\n514",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:02.411655"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 516,
    "chapter": null,
    "section": "25.2 Поискивставка",
    "text": "25.2. Поискивставка\nAAEERR OOVVBB\nAAEERR DDMMEE KKZZNN OOVVBB RROOVV SSVVOO\nAAEERR DDMMEE KKZZNN OOVVBB RROOVV SSVVOO\nBBZZKK HHMMAA LLEEDD OOVVSS SSGGCC SSVVXX\nKKJJAA NNUUXX PPEEEE VVKKOO\nВ корневом узле находятся ключиAER и OVB.Выполняется условиеAER ⩽\n⩽KJA<OVB,поэтому спускаться надо вдочерний узел,на который ссыла-\nетсяэлементсключомAER.\nТа же процедура повторяется рекурсивно до тех пор, пока мы не дойдем\nдолистовогоузла,изкоторогоужеможнополучитьидентификаторверсии\nстроки.ВданномслучаевдочернемузлевыполняетсяусловиеDME⩽KJA<\n<KZN,поэтомунадоспуститьсявлистовойузел,накоторыйссылаетсяэле-\nментсключомDME.\nМожно заметить,что во внутренних узлахдерева крайнийлевый ключ из-\nбыточен:чтобывыбратьдочернийузелкорня,достаточновыполненияусло-\nвияKJA<OVB.ТакиеключинехранятсявB-дереве,инаследующихрисун-\nкахябудуоставлятьсоответствующиеэлементыпустыми.\nВлистовомузленужныйэлементбыстронаходитсяпростымдвоичнымпо-\nиском.\nВреальностипроцедурапоискавовсенетакпроста,каккажетсянапервый\nвзгляд.Нужноучитывать,чтозначениявиндексемогутбытьупорядочены\nнетолько по возрастанию,как на рисунке,но и по убыванию.Даже в уни-\nкальноминдексеможетоказатьсянесколькоподходящихзначений,ипоиск с.523\nдолженвернутьихвсе.Причемодинаковыхзначенийможетоказатьсятак\n515",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:02.469689"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 517,
    "chapter": null,
    "section": "25.2 Поискивставка",
    "text": "Глава25. B-дерево\nмного,что они не поместятся в один узел,итогда поиск придется продол-\nжитьвсоседнейлистовойстранице.\nИз-затого,чтовиндексемогутнаходитьсянеуникальныезначения,правильнеебыло\nбы говорить не «по возрастанию»,а «по неубыванию» (и не «по убыванию»,а «по\nневозрастанию»).Я все-таки будупридерживаться более простого варианта.Ктому\nv.12 жеидентификаторверсиистрокиявляетсячастьюиндексногоключа,чтопозволяет\nсчитатьэлементыиндексауникальными,дажекогдазначениясовпадают.\nКромевсегопрочего,вовремяпоискадругиепроцессымогутизменятьдан-\nные,страницымогутрасщеплятьсянадве,идеревоможетперестраиваться.\nВсе алгоритмы построены таким образом, чтобы эти одновременные дей-\nствияповозможностинемешалидругдругуинетребовалилишнихблоки-\nровок.Новэтидеталиявдаватьсянебуду.\nПоиск по неравенству\nПри поиске по условию «индексированный-столбец ⩽ выражение» (или «ин-\nдексированный-столбец⩾выражение»)сначаланадонайтивиндексезначе-\nниепоусловиюравенства,азатемдвигатьсяполистовымузламвнужную\nсторонудосамогоконца.\nAAEERR OOVVBB\nAAEERR DDMMEE KKZZNN OOVVBB RROOVV SSVVOO\nAAEERR DDMMEE KKZZNN OOVVBB RROOVV SSVVOO\nBBZZKK HHMMAA LLEEDD OOVVSS SSGGCC SSVVXX\nKKJJAA NNUUXX PPEEEE VVKKOO\n516",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:02.525983"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 518,
    "chapter": null,
    "section": "25.2 Поискивставка",
    "text": "25.2. Поискивставка\nРисунок показывает процесс поиска аэропортов с кодами,меньшими или\nравнымиDME(Домодедово).\nДляоператоров«больше»и«меньше»поисквыполняетсятакже,надотоль-\nкоисключитьисходнонайденноезначение.\nПоиск по диапазону\nПри поиске подиапазону «выражение ⩽ индексированный-столбец ⩽ выра-\n1\nжение »сначаланадонайтивыражение ,азатемдвигатьсявправополисто-\n2 1\nвымузлам,поканедойдемдовыражения .\n2\nНарисункепоказанпроцесспоискааэропортовскодамиотLED(Санкт-Пе-\nтербург)доROV(Ростов-на-Дону)включительно.\nAAEERR OOVVBB\nAAEERR DDMMEE KKZZNN OOVVBB RROOVV SSVVOO\nAAEERR DDMMEE KKZZNN OOVVBB RROOVV SSVVOO\nBBZZKK HHMMAA LLEEDD OOVVSS SSGGCC SSVVXX\nKKJJAA NNUUXX PPEEEE VVKKOO\nВставка\nМесто нового элемента в листовых узлах однозначно определяется поряд-\nкомрасположенияключей.Например,привставкевтаблицуаэропортаско-\nдомRTW(Саратов)элементбудетдобавленвпредпоследнийлистовойузел\nмеждуимеющимисяROVиSGC.\n517",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:02.576998"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 519,
    "chapter": null,
    "section": "25.2 Поискивставка",
    "text": "Глава25. B-дерево\nAAEERR OOVVBB SSVVOO\nAAEERR DDMMEE KKZZNN OOVVBB RROOVV SSVVOO TTJJMM\nAAEERR DDMMEE KKZZNN OOVVBB RROOVV SSVVOO TTJJMM\nBBZZKK HHMMAA LLEEDD OOVVSS RRTTWW SSVVXX VVKKOO\nKKJJAA NNUUXX PPEEEE SSGGCC\nНо можетполучитьсятак,что влистовом узле не хватитместадля нового\nэлемента.Например(еслисчитать,чтоузелвмещаетмаксимумтриэлемен-\nта),привставкеаэропортаскодомTJM(Тюмень)последнийлистовойузел\nпереполнится.Вэтомслучаеузелрасщепляетсянадва,частьэлементовста-\nрого узла переносится в новый,а в родительский узелдобавляется ссылка\nнановогопотомка.Конечно,родительскийузелтожеможетпереполниться.\nВ таком случае и он расщепляется на два узла, и так далее. Если дело до-\nходитдо расщепления корня,над образовавшимися узлами создается еще\nодинузел,которыйстановитсяновымкорнемдерева.Вэтомслучаеглуби-\nнадереваувеличиваетсянаединицу.\nВданномпримередобавлениеаэропортаTJMпривелокрасщеплениюдвух\nузлов;новыеузлывыделенынарисунке.Чтобыможнобылорасщеплятьлю-\nбыеузлыдерева,двунаправленнымспискомсвязанынетолькоузлынижне-\nгоуровня,ноиузлыостальныхуровнейтоже.\nОписанная процедура вставок и расщеплений гарантируетсбалансирован-\nностьдерева,апосколькувреальностиколичествоэлементоввузлеобычно\nвелико,наращиваниедополнительногоуровняпроисходитредко.\nПроблема в том, что расщепленные узлы никогда не объединяются, даже\nесли после очистки в них остается мало элементов. Это ограничение не\nB-деревакакструктурыданных,ареализацииPostgreSQL.Поэтому,еслипри\n518",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:02.643753"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 520,
    "chapter": null,
    "section": "25.3 Страничная организация",
    "text": "25.3. Страничнаяорганизация\nвставкеузелоказываетсязаполнен,методдоступастараетсявпервуюоче-\nредь очистить узел отлишней информации,чтобы освободить место и не с.123\nдопуститьлишнеерасщепление.\n25.3. Страничная организация\nКаждыйузелB-деревазанимаетоднустраницу.Размерстраницыиопреде-\nляетвместимостьузла.\nРасщепленияприводятктому,чтовразныемоментывременикорнемдере-\nвамогутвыступатьразныестраницы.Ноалгоритмпоискадолженначинать\nработуименноскорня.Оннаходитномертекущейкорневойстраницывну-\nлевойстраницеиндекса(называемойметастраницей).Метастраницасодер-\nжитинекоторуюдругуюслужебнуюинформацию.\nметастраница\n2 AAEERR OOVVBB SSVVOO\n1 AAEERR DDMMEE KKZZNN OOVVBB OOVVBB RROOVV SSVVOO SSVVOO TTJJMM\nAAEERR DDMMEE KKZZNN OOVVBB RROOVV SSVVOO TTJJMM\n0 BBZZKK HHMMAA LLEEDD OOVVSS RRTTWW SSVVXX VVKKOO\nDDMMEE KKJJAA NNUUXX PPEEEE SSGGCC TTJJMM\nKKZZNN OOVVBB RROOVV SSVVOO\n519",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:02.711283"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 521,
    "chapter": null,
    "section": "25.3 Страничная организация",
    "text": "Глава25. B-дерево\nПредставление информации на индексных страницах немного отличается\nоттого,чтобылоизображеноранее.Всестраницы,кромесамыхправыхна\nсвоемуровне,содержатдополнительный«верхнийключ»,гарантированно\nнеменьшийлюбогозначениянаданнойстранице.Нарисункеверхниеклю-\nчивыделеныцветом.\nЗаглянем в страницынастоящегоиндексапо шестизначнымномерам бро-\nнированийспомощьюрасширенияpageinspect.Вметастраниценасинте-\nресуетномеркорневойстраницыимаксимальныйуровеньдерева(уровни\nнумеруютсяснуля,начинаяслистьев):\n=> SELECT root, level\nFROM bt_metap('bookings_pkey');\nroot | level\n−−−−−−+−−−−−−−\n290 | 2\n(1 row)\nКлючивиндексныхзаписяхвыводятсякакпоследовательностьбайтов,что\nнеочень-тоудобно.Вотпример:\n=> SELECT data\nFROM bt_page_items('bookings_pkey',290)\nWHERE itemoffset = 2;\ndata\n−−−−−−−−−−−−−−−−−−−−−−−−−\n0f 30 43 39 41 42 31 00\n(1 row)\nДлярасшифровкизначенийпридетсянаписатьadhoc-функцию.Онабудет\nработатьневовсехслучаяхиненавсехплатформах,ногодитсядляприме-\nроввэтойглаве:\n=> CREATE FUNCTION data_to_text(data text)\nRETURNS text\nAS $$\nDECLARE\nraw bytea := ('\\x'||replace(data,' ',''))::bytea;\npos integer := 0;\nlen integer;\nres text := '';\n520",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:02.744345"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 522,
    "chapter": null,
    "section": "25.3 Страничнаяорганизация",
    "text": "25.3. Страничнаяорганизация\nBEGIN\nWHILE (octet_length(raw) > pos) LOOP\nlen := (get_byte(raw,pos) - 3) / 2;\nEXIT WHEN len <= 0;\nIF pos > 0 THEN\nres := res || ', ';\nEND IF;\nres := res || (\nSELECT string_agg( chr(get_byte(raw, i)),'')\nFROM generate_series(pos+1,pos+len) i\n);\npos := pos + len + 1;\nEND LOOP;\nRETURN res;\nEND;\n$$ LANGUAGE plpgsql;\nТеперьмыможемпосмотретьнасодержимоекорневойстраницы:\n=> SELECT itemoffset, ctid, data_to_text(data)\nFROM bt_page_items('bookings_pkey',290);\nitemoffset | ctid | data_to_text\n−−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−\n1 | (3,0) |\n2 | (289,1) | 0C9AB1\n3 | (575,1) | 192F03\n4 | (860,1) | 25D715\n5 | (1145,1) | 32785C\n6 | (1430,1) | 3F0EB8\n...\n17 | (4565,1) | C993F6\n18 | (4850,1) | D63931\n19 | (5135,1) | E2CB14\n20 | (5420,1) | EF6FEA\n21 | (5705,1) | FC147D\n(21 rows)\nПервая запись, как я и говорил, не хранит ключ. Столбец ctid содержит\nссылкинадочерниестраницы.\nДопустим,мыищембронированиесномеромE2D725.Вэтомслучаемывы-\nбираем запись19,поскольку E2CB14 ⩽ E2D725 < EF6FEA,и спускаемся на\nстраницу5135.\n521",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:02.772725"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 523,
    "chapter": null,
    "section": "25.3 Страничнаяорганизация",
    "text": "Глава25. B-дерево\n=> SELECT itemoffset, ctid, data_to_text(data)\nFROM bt_page_items('bookings_pkey',5135);\nitemoffset | ctid | data_to_text\n−−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−\n1 | (5417,1) | EF6FEA верхнийключ\n2 | (5132,0) |\n3 | (5133,1) | E2D71D\n4 | (5134,1) | E2E2F4\n5 | (5136,1) | E2EDE7\n...\n282 | (5413,1) | EF41BE\n283 | (5414,1) | EF4D69\n284 | (5415,1) | EF58D4\n285 | (5416,1) | EF6410\n(285 rows)\nПервая запись этой страницы — несколько неожиданно — содержит верх-\nнийключ.Логическиондолженбылбырасполагатьсявконцестраницы,но\nсточкизренияреализацииудобнеедержатьеговначале,чтобынеперено-\nситькаждыйраз,когдасодержимоестраницыменяется.\nНа этой странице мы выбираем запись 3, поскольку E2D71D⩽E2D725<\n<E2E2F4,испускаемсянастраницу5133.\n=> SELECT itemoffset, ctid, data_to_text(data)\nFROM bt_page_items('bookings_pkey',5133);\nitemoffset | ctid | data_to_text\n−−−−−−−−−−−−+−−−−−−−−−−−−−+−−−−−−−−−−−−−−\n1 | (11921,1) | E2E2F4\n2 | (11919,76) | E2D71D\n3 | (11919,77) | E2D725\n4 | (11919,78) | E2D72D\n5 | (11919,79) | E2D733\n...\n364 | (11921,124) | E2E2DB\n365 | (11921,125) | E2E2DF\n366 | (11921,126) | E2E2E5\n367 | (11921,127) | E2E2ED\n(367 rows)\nЭтолистоваястраницаиндекса.Перваязапись—верхнийключ,авсеосталь-\nныезаписиссылаютсянатабличныеверсиистрок.\nВотинашебронирование:\n522",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:02.807334"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 524,
    "chapter": null,
    "section": "25.3 Страничнаяорганизация",
    "text": "25.3. Страничнаяорганизация\n=> SELECT * FROM bookings WHERE ctid = '(11919,77)';\nbook_ref | book_date | total_amount\n−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−\nE2D725 | 2017−01−25 04:10:00+03 | 28000.00\n(1 row)\nПримернотакая работа и выполняется на низком уровне,когда мы запра-\nшиваембронированиепокоду:\n=> EXPLAIN (costs off) SELECT *\nFROM bookings WHERE book_ref = 'E2D725';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Scan using bookings_pkey on bookings\nIndex Cond: (book_ref = 'E2D725'::bpchar)\n(2 rows)\nКомпактное хранение дубликатов v.13\nНеуникальныеиндексымогутсодержатьмножествоодинаковыхключейсо\nссылками на разные табличные строки. Поскольку повторяющиеся клю-\nчи занимают много места, дубликаты «схлопываются» в одну индексную\nзапись, содержащую ключ и список табличных идентификаторов1. В ряде\nслучаевэтапроцедура,называемаяисключениемдубликатов(deduplication),\nпозволяетсущественносократитьразмериндекса.\nНо и уникальные индексы могут содержать дубликаты ключей из-за мно-\nговерсионности,посколькуиндексхранитссылкинавсеверсиитабличных\nстрок.С раздуванием индекса из-за ссылок на неактуальные и обычно ко-\nроткоживущие версии помогает справиться механизм hot-обновлений,но с.111\nонработаетневсегда.Втакомслучаеисключениедубликатовпозволяетвы-\nиграть время,необходимое для очистки таблицы от неактуальных версий,\nисократитьколичествовынужденныхрасщепленийстраниц.\nЧтобынетратитьресурсынаисключениедубликатов,когдавэтомнетнеоб-\nходимости,«схлопывание»выполняется,толькокогданалистовойстранице\n1 postgrespro.ru/docs/postgresql/17/btree-implementation#BTREE-DEDUPLICATION.\n523",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:02.845495"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 525,
    "chapter": null,
    "section": "25.3 Страничнаяорганизация",
    "text": "Глава25. B-дерево\nнехватаетместадлявставкиновойстроки.Вэтомслучае1 внутристранич-\nная очистка и исключение дубликатов2 могут освободить место и предот-\nвратитьненужноерасщепление.Впрочем,еслидубликатывозникаютредко,\nмеханизм исключения можно отключить с помощью параметра хранения\ndeduplicate_items.\nИсключение дубликатов может применяться не для всех индексов. Основ-\nноеограничениесостоитвтом,чторавенствоключейдолжнопроверяться\nпростымдвоичнымсравнениемвнутреннегопредставления.Далеконевсе\nтипыданныхможносравниватьтакимобразом.Числасплавающейточкой\n(float и double precision) имеют два разных представления нуля. Чис-\nла с произвольной точностью (numeric) допускают представление одного\nи того же числа в разных масштабах, а тип jsonb используеттакие числа.\nНе годятся также текстовые типы при использовании недетерминирован-\nныхправилсортировки3,позволяющихпредставлятьодинаковыесимволы\nразными последовательностями байтов (стандартные правила сортировки\nдетерминированы).\nКрометого,внастоящеевремяисключениедубликатовневозможнодлясо-\nставныхтипов,диапазоновимассивов,атакженеработаетсinclude-индек-\nсами.\nЧтобыпроверить,поддерживаетсялиисключениедубликатовдляконкрет-\nногоиндекса,можнозаглянутьвполеallequalimageметастраницы:\n=> CREATE INDEX ON tickets(book_ref);\n=> SELECT allequalimage FROM bt_metap('tickets_book_ref_idx');\nallequalimage\n−−−−−−−−−−−−−−−\nt\n(1 row)\nВданномслучаеисключениедубликатовподдерживается.Идействительно,\nнаоднойизлистовыхстраницмывидим,чтонекоторыеиндексныезаписи\nсодержат единственный табличный идентификатор (htid), а некоторые —\nсписокидентификаторов(tids):\n1 backend/access/nbtree/nbtinsert.c,функция_bt_delete_or_dedup_one_page.\n2 backend/access/nbtree/nbtdedup.c,функция_bt_dedup_pass.\n3 postgrespro.ru/docs/postgresql/17/collation.\n524",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:02.883838"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 526,
    "chapter": null,
    "section": "25.3 Страничнаяорганизация",
    "text": "25.3. Страничнаяорганизация\n=> SELECT itemoffset, htid, left(tids::text,27) tids,\ndata_to_text(data) AS data\nFROM bt_page_items('tickets_book_ref_idx',1)\nWHERE itemoffset > 1;\nitemoffset | htid | tids | data\n−−−−−−−−−−−−+−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−+−−−−−−−−\n2 | (32965,40) | | 000004\n3 | (47429,51) | | 00000F\n4 | (3648,56) | {\"(3648,56)\",\"(3648,57)\"} | 000010\n5 | (6498,47) | | 000012\n...\n271 | (21492,46) | | 000890\n272 | (26601,55) | {\"(26601,55)\",\"(26601,56)\"} | 0008AC\n273 | (25669,37) | | 0008B6\n(272 rows)\nКомпактное хранение внутренних индексных записей v.12\nИсключениедубликатов позволяетразместитьбольше записей влистовых\nстраницах индекса. Но для предотвращения лишних расщеплений уплот-\nнениеинформациивовнутреннихстраницахиграетнеменьшуюроль.Ос-\nновной объем индекса составляют листовые страницы, но эффективность\nпоискавиндексенапрямуюзависитотглубиныдерева.\nИндексныезаписивовнутреннихстраницахсодержатключииндексирова-\nния,ноихзначенияиспользуютсятолькодляопределенияподдерева,вко-\nтороенадоспускатьсяприпоиске.Всоставныхиндексахдляэтогочастодо-\nстаточнотолькопервогоатрибутаключаилинесколькихпервых.Остальные\nатрибутымогутбытьотброшены,чтобынезаниматьместонастранице.\nТакая процедура исключения части атрибутов (suffix truncation) выполня-\nется, когда происходит расщепление листовой страницы и во внутренней\nстраниценеобходиморазместитьновуюссылку1.\nВ принципе,можно пойти еще дальше и оставлятьтолько значимую часть атрибу-\nта,напримернесколькопервыхсимволовстроки,достаточныхдляразличенияпод-\nдеревьев.Но это пока не реализовано: атрибут или целиком остается в индексной\nзаписи,илиполностьюисключаетсяизнее.\n1 backend/access/nbtree/nbtinsert.c,функция_bt_split.\n525",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:02.921663"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 527,
    "chapter": null,
    "section": "25.3 Страничнаяорганизация",
    "text": "Глава25. B-дерево\nДля примера—несколько записей корневой страницы индекса,построен-\nногонатаблицебилетовпономерубронированияиименипассажира:\n=> CREATE INDEX tickets_bref_name_idx\nON tickets(book_ref, passenger_name);\n=> SELECT itemoffset, ctid, data_to_text(data)\nFROM bt_page_items('tickets_bref_name_idx',229)\nWHERE itemoffset BETWEEN 8 AND 13;\nitemoffset | ctid | data_to_text\n−−−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n8 | (1607,1) | 1A98A0\n9 | (1833,2) | 1E57D1, SVETLANA MAKSIMOVA\n10 | (2054,1) | 220797\n11 | (2282,1) | 25DB06\n12 | (2509,2) | 299FE4, YURIY AFANASEV\n13 | (2736,1) | 2D62C9\n(6 rows)\nВидно,чтовнекоторыхиндексныхзаписяхвторойатрибутисключен.\nВ листовых страницах, конечно, должны храниться все ключевые атрибу-\nты,втомчислеизначениядополнительныхinclude-столбцов.Впротивном\nслучае индекс не мог бы использоваться в сканировании только индекса.\nИсключениесоставляет«верхнийключ»,которыйможетхранитьсянепол-\nностью.\n25.4. Класс операторов\nСемантика сравнения\nСистеме необходимо уметьнетолько хешироватьзначения,но и упорядо-\nчиватьзначенияразныхтипов,втомчислепользовательских.Этотребуется\nдля сортировок и группировок,соединения слиянием и некоторых других\nопераций.Итак же,какдля хеширования,соответствие междутипомдан-\nныхиоператорамисравнениязадаетсяклассомоператоров1.\n1 postgrespro.ru/docs/postgresql/17/btree-behavior.\n526",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:02.951700"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 528,
    "chapter": null,
    "section": "25.4 Классоператоров",
    "text": "25.4. Классоператоров\nКлассоператоровпозволяетнепривязыватьсякименам(такимкак>,<,=)\nи даже иметь несколько способов упорядочить значения одного и того же\nтипа.\nВот какие операторы сравнения должны быть заданы в любом классе опе-\nраторовметодаbtree(напримересемействаbool_ops):\n=> SELECT amopopr::regoperator AS opfamily_operator,\namopstrategy\nFROM pg_am am\nJOIN pg_opfamily opf ON opfmethod = am.oid\nJOIN pg_amop amop ON amopfamily = opf.oid\nWHERE amname = 'btree'\nAND opfname = 'bool_ops'\nORDER BY amopstrategy;\nopfamily_operator | amopstrategy\n−−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−\n<(boolean,boolean) | 1\n<=(boolean,boolean) | 2\n=(boolean,boolean) | 3\n>=(boolean,boolean) | 4\n>(boolean,boolean) | 5\n(5 rows)\nЗдесьмывидимпятьоператоровсравнения.Каждыйизнихсоответствует\nоднойизстратегий1,котораяопределяетегосемантику:\n1) меньше;\n2) меньшелиборавно;\n3) равно;\n4) большелиборавно;\n5) больше.\nКласс операторов B-дерева включает также несколько опорных функций2.\nПерваяизнихдолжнавозвращатьединицу,еслиеепервыйаргументбольше\nвторого,минусединицу,еслименьше,иноль,еслиаргументыравны.\n1 postgrespro.ru/docs/postgresql/17/xindex#XINDEX-STRATEGIES.\n2 postgrespro.ru/docs/postgresql/17/btree-support-funcs.\n527",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:02.980583"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 529,
    "chapter": null,
    "section": "25.4 Классоператоров",
    "text": "Глава25. B-дерево\nОстальныеопорныефункциинеобязательны,нопозволяютметодудоступа\nработатьболеепроизводительно.\nЧтобы лучше разобраться в этом механизме, полезно создать новый тип\nданных и установить для него порядок сортировки, отличный от порядка\nпоумолчанию.Документацияприводиттакойпримердлякомплексныхчи-\nсел1,но используетязык C.К счастью,класс операторовдля B-дерева мож-\nносоздатьиспомощьюинтерпретируемыхязыков,чемяивоспользуюсь,\nчтобысделатьэтотпримеркакможноболеепростым(хотяизаведомонеэф-\nфективным).\nСоздадимновыйсоставнойтипдляединицизмеренияинформации:\n=> CREATE TYPE capacity_units AS ENUM (\n'B', 'kB', 'MB', 'GB', 'TB', 'PB'\n);\n=> CREATE TYPE capacity AS (\namount integer,\nunit capacity_units\n);\nСоздадимтаблицусостолбцомновоготипаизаполнимееслучайнымизна-\nчениями:\n=> CREATE TABLE test AS\nSELECT ( (random()*1023)::integer, u.unit )::capacity AS cap\nFROM generate_series(1,100),\nunnest(enum_range(NULL::capacity_units)) AS u(unit);\nПо умолчанию значения составных типов сортируются в лексикографиче-\nском порядке, который в данном случае не совпадает с естественным по-\nрядком:\n=> SELECT * FROM test ORDER BY cap;\ncap\n−−−−−−−−−−−\n(1,MB)\n(2,kB)\n(3,MB)\n(7,GB)\n...\n1 postgrespro.ru/docs/postgresql/17/xindex#XINDEX-EXAMPLE.\n528",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:03.011427"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 530,
    "chapter": null,
    "section": "25.4 Классоператоров",
    "text": "25.4. Классоператоров\n(1018,TB)\n(1020,B)\n(1020,kB)\n(1021,PB)\n(600 rows)\nСозданиеклассаоператоровначнемсфункции,котораяпересчитываетобъ-\nемвбайты:\n=> CREATE FUNCTION capacity_to_bytes(a capacity) RETURNS numeric\nAS $$\nSELECT a.amount::numeric *\n1024::numeric ^ ( array_position(enum_range(a.unit), a.unit) - 1 );\n$$ LANGUAGE sql STRICT IMMUTABLE;\n=> SELECT capacity_to_bytes('(1,kB)'::capacity);\ncapacity_to_bytes\n−−−−−−−−−−−−−−−−−−−−\n1024.0000000000000\n(1 row)\nСоздадимопорнуюфункциюдлябудущегоклассаоператоров:\n=> CREATE FUNCTION capacity_cmp(a capacity, b capacity)\nRETURNS integer\nAS $$\nSELECT sign(bookings.capacity_to_bytes(a) - bookings.capacity_to_bytes(b));\n$$ LANGUAGE sql STRICT IMMUTABLE;\nТеперь с помощью опорной функции легко определить операторы сравне-\nния.Я специально использую «странные» имена,чтобы показать,что они\nмогутбытьпроизвольными:\n=> CREATE FUNCTION capacity_lt(a capacity, b capacity) RETURNS boolean\nAS $$\nBEGIN\nRETURN capacity_cmp(a,b) < 0;\nEND;\n$$ LANGUAGE plpgsql IMMUTABLE STRICT;\n=> CREATE OPERATOR #<# (\nLEFTARG = capacity,\nRIGHTARG = capacity,\nFUNCTION = capacity_lt\n);\n529",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:03.047651"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 531,
    "chapter": null,
    "section": "25.4 Классоператоров",
    "text": "Глава25. B-дерево\nОстальныечетыреоператораопределяютсяпоаналогии.\n=> CREATE FUNCTION capacity_le(a capacity, b capacity) RETURNS boolean\nAS $$\nBEGIN\nRETURN capacity_cmp(a,b) <= 0;\nEND;\n$$ LANGUAGE plpgsql IMMUTABLE STRICT;\n=> CREATE OPERATOR #<=# (\nLEFTARG = capacity,\nRIGHTARG = capacity,\nFUNCTION = capacity_le\n);\n=> CREATE FUNCTION capacity_eq(a capacity, b capacity) RETURNS boolean\nAS $$\nBEGIN\nRETURN capacity_cmp(a,b) = 0;\nEND;\n$$ LANGUAGE plpgsql IMMUTABLE STRICT;\n=> CREATE OPERATOR #=# (\nLEFTARG = capacity,\nRIGHTARG = capacity,\nFUNCTION = capacity_eq,\nMERGES -- можно использовать в соединении слиянием\n);\n=> CREATE FUNCTION capacity_ge(a capacity, b capacity) RETURNS boolean\nAS $$\nBEGIN\nRETURN capacity_cmp(a,b) >= 0;\nEND;\n$$ LANGUAGE plpgsql IMMUTABLE STRICT;\n=> CREATE OPERATOR #>=# (\nLEFTARG = capacity,\nRIGHTARG = capacity,\nFUNCTION = capacity_ge\n);\n=> CREATE FUNCTION capacity_gt(a capacity, b capacity) RETURNS boolean\nAS $$\nBEGIN\nRETURN capacity_cmp(a,b) > 0;\nEND;\n$$ LANGUAGE plpgsql IMMUTABLE STRICT;\n530",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:03.098751"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 532,
    "chapter": null,
    "section": "25.4 Классоператоров",
    "text": "25.4. Классоператоров\n=> CREATE OPERATOR #># (\nLEFTARG = capacity,\nRIGHTARG = capacity,\nFUNCTION = capacity_gt\n);\nНаэтомэтапемыужеможемправильносравниватьобъемы:\n=> SELECT (1,'MB')::capacity #># (512, 'kB')::capacity;\n?column?\n−−−−−−−−−−\nt\n(1 row)\nАпослесозданияклассаоператоровзаработаеткакнадоисортировка:\n=> CREATE OPERATOR CLASS capacity_ops\nDEFAULT FOR TYPE capacity -- будет использоваться по умолчанию\nUSING btree AS\nOPERATOR 1 #<#,\nOPERATOR 2 #<=#,\nOPERATOR 3 #=#,\nOPERATOR 4 #>=#,\nOPERATOR 5 #>#,\nFUNCTION 1 capacity_cmp(capacity,capacity);\n=> SELECT * FROM test ORDER BY cap;\ncap\n−−−−−−−−−−−\n(9,B)\n(30,B)\n(42,B)\n(47,B)\n...\n(992,PB)\n(999,PB)\n(1007,PB)\n(1015,PB)\n(1021,PB)\n(600 rows)\nНашклассоператоровиспользуетсяпоумолчаниюприсозданиииндексов,\nасозданныйиндексвозвращаетзначениявправильномпорядке:\n=> CREATE INDEX ON test(cap);\n531",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:03.124693"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 533,
    "chapter": null,
    "section": "25.4 Классоператоров",
    "text": "Глава25. B-дерево\n=> SELECT * FROM test WHERE cap #<# (100,'B')::capacity ORDER BY cap;\ncap\n−−−−−−−−\n(9,B)\n(30,B)\n(42,B)\n(47,B)\n(66,B)\n(67,B)\n(69,B)\n(97,B)\n(99,B)\n(9 rows)\n=> EXPLAIN (costs off)\nSELECT * FROM test WHERE cap #<# (100,'B')::capacity ORDER BY cap;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Only Scan using test_cap_idx on test\nIndex Cond: (cap #<# '(100,B)'::capacity)\n(2 rows)\nс.472 ПредложениеMERGES,указанноеприсозданииоператораравенства,разре-\nшаетиспользоватьсоединениеслияниемдлязначенийнашеготипа.\nСортировка и составные индексы\nСтоитподробнееостановитьсянаособенностяхсортировкивсоставныхин-\nдексах.\nВо-первых,крайне важен порядок,в котором столбцы перечисляются при\nсозданиииндекса,посколькуданныевнутристраницбудутотсортированы\nсначала по первому столбцу,затем по второму и так далее.Эффективный\nпоиск втаком индексе возможен по условиям на непрерывную последова-\nтельностьстолбцов,начинаяссамогопервого:поодномупервому,попер-\nвомуивторому,спервогопотретийитакдалее.Всеостальныеусловиямо-\nгутиспользоватьсятолькодляфильтрациизначений,найденныхподругим\nкритериям.\nВот порядок индексных записей в первой листовой странице индекса, со-\nзданного ранее на таблице билетов по номеру бронирования и по имени\nпассажира:\n532",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:03.162839"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 534,
    "chapter": null,
    "section": "25.4 Классоператоров",
    "text": "25.4. Классоператоров\n=> SELECT itemoffset, data_to_text(data)\nFROM bt_page_items('tickets_bref_name_idx',1)\nWHERE itemoffset > 1;\nitemoffset | data_to_text\n−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n2 | 000004, PETR MAKAROV\n3 | 00000F, ANNA ANTONOVA\n4 | 000010, ALEKSANDR SOKOLOV\n5 | 000010, LYUDMILA BOGDANOVA\n6 | 000012, TAMARA ZAYCEVA\n...\n188 | 00040C, ANTONINA KOROLEVA\n189 | 00040C, DMITRIY FEDOROV\n190 | 00041E, EGOR FEDOROV\n191 | 00041E, ILYA STEPANOV\n192 | 000447, VIKTOR VASILEV\n193 | 00044D, NADEZHDA KULIKOVA\n(192 rows)\nВ этом случае эффективный поиск билетов возможенлибо по номеру бро-\nнированияиименипассажира,либотолькопономерубронирования:\n=> EXPLAIN (costs off) SELECT *\nFROM tickets\nWHERE book_ref = '000010';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Scan using tickets_book_ref_idx on tickets\nIndex Cond: (book_ref = '000010'::bpchar)\n(2 rows)\n=> EXPLAIN (costs off) SELECT *\nFROM tickets\nWHERE book_ref = '000010' AND passenger_name = 'LYUDMILA BOGDANOVA';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Scan using tickets_bref_name_idx on tickets\nIndex Cond: ((book_ref = '000010'::bpchar) AND (passenger_name...\n(2 rows)\nНодля поискатолько по имени пассажира придется перебратьвсе строки:\n=> EXPLAIN (costs off) SELECT *\nFROM tickets\nWHERE passenger_name = 'LYUDMILA BOGDANOVA';\n533",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:03.200559"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 535,
    "chapter": null,
    "section": "25.4 Классоператоров",
    "text": "Глава25. B-дерево\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nGather\nWorkers Planned: 2\n−> Parallel Seq Scan on tickets\nFilter: (passenger_name = 'LYUDMILA BOGDANOVA'::text)\n(4 rows)\nДаже если планировщик и выберет индексное сканирование, фактически\nбудутпросматриватьсявсеиндексныезаписи1.Ксожалению,планнепока-\nжет,чтоусловиеиспользуетсятолькодляфильтрации.\nЕсли первый столбец имеет не слишком много уникальных значений v ,v ,…,v ,\n1 2 n\nможет оказаться выгодным выполнить несколько индексных сканирований в соот-\nветствующихподдеревьях,фактически заменяя поиск по условию col2 = значение\nсериейпоисковпоусловиям\ncol1=v ANDcol2=значение,\n1\ncol1=v ANDcol2=значение,\n2\n⋯\ncol1=v ANDcol2=значение.\nn\nТакойвидиндексногодоступаназываютсканированиемспропусками(SkipScan),но\nонпоканереализован2.\nИ наоборот, если создать индекс по именам и по номерам бронирования,\nэффективнобудутподдерживатьсязапросыпоимениилиодновременнопо\nимениипономерубронирования:\n=> CREATE INDEX tickets_name_bref_idx\nON tickets(passenger_name, book_ref);\n=> SELECT itemoffset, data_to_text(data)\nFROM bt_page_items('tickets_name_bref_idx',1)\nWHERE itemoffset > 1;\nitemoffset | data_to_text\n−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n2 | ADELINA ABRAMOVA, E37EDB\n3 | ADELINA AFANASEVA, 1133B7\n4 | ADELINA AFANASEVA, 4F3370\n5 | ADELINA AKIMOVA, 7D2881\n...\n1 backend/access/nbtree/nbtsearch.c,функция_bt_first.\n2 commitfest.postgresql.org/34/1741.\n534",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:03.240609"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 536,
    "chapter": null,
    "section": "25.4 Классоператоров",
    "text": "25.4. Классоператоров\n185 | ADELINA LEBEDEVA, 0A00E3\n186 | ADELINA LEBEDEVA, DAEADE\n187 | ADELINA LEBEDEVA, DFD7E5\n188 | ADELINA LOGINOVA, 8022F3\n189 | ADELINA LOGINOVA, EE67B9\n190 | ADELINA LUKYANOVA, 292786\n191 | ADELINA LUKYANOVA, 54D3F9\n(190 rows)\n=> EXPLAIN (costs off) SELECT * FROM tickets\nWHERE passenger_name = 'LYUDMILA BOGDANOVA';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on tickets\nRecheck Cond: (passenger_name = 'LYUDMILA BOGDANOVA'::text)\n−> Bitmap Index Scan on tickets_name_bref_idx\nIndex Cond: (passenger_name = 'LYUDMILA BOGDANOVA'::text)\n(4 rows)\nПри создании индекса нужно учитыватьнетолько порядок столбцов,но и\nпорядоксортировки.Поумолчаниюзначенияупорядоченыповозрастанию\n(ASC),но можно указать и обратный порядок (DESC).В индексе по одному\nстолбцу это не играет особой роли, поскольку индекс можно сканировать\nвлюбуюсторону.Новсоставноминдексепорядокважен.\nТолько что созданный индекс можно использоватьдля полученияданных,\nотсортированных по обоим столбцам по возрастанию или по обоим столб-\nцампоубыванию:\n=> EXPLAIN (costs off) SELECT *\nFROM tickets\nORDER BY passenger_name, book_ref;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Scan using tickets_name_bref_idx on tickets\n(1 row)\n=> EXPLAIN (costs off) SELECT *\nFROM tickets ORDER BY passenger_name DESC, book_ref DESC;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Scan Backward using tickets_name_bref_idx on tickets\n(1 row)\n535",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:03.288748"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 537,
    "chapter": null,
    "section": "25.4 Классоператоров",
    "text": "Глава25. B-дерево\nНоизэтогоиндексаневозможносразужеполучитьданные,которыепоод-\nномустолбцубудутотсортированыповозрастанию,аподругому—поубы-\nванию.Индекспоставляетчастичноупорядоченныеданные,которыезатем\nс.487 сортируются по второму атрибуту (здесьидалеедля простоты отключены\nпараллельныепланы):\n=> EXPLAIN (costs off) SELECT *\nFROM tickets ORDER BY passenger_name ASC, book_ref DESC;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIncremental Sort\nSort Key: passenger_name, book_ref DESC\nPresorted Key: passenger_name\n−> Index Scan using tickets_name_bref_idx on tickets\n(4 rows)\nНа возможность использовать индекс для сортировки влияет и располо-\nжение неопределенных значений. По умолчанию для целей сортировки\nнеопределенныезначениясчитаются«больше»обычныхзначений,тоесть\nрасполагаютсясправогоконцадереваприсортировкеповозрастаниюили\nс левого при сортировке по убыванию. Этот порядок можно менять с по-\nмощьюпредложенийNULLSLASTиNULLSFIRST.\nВ следующем примере индекс не удовлетворяет предложению ORDER BY,\nирезультатприходитсясортировать:\n=> EXPLAIN (costs off) SELECT *\nFROM tickets ORDER BY passenger_name NULLS FIRST, book_ref DESC;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSort\nSort Key: passenger_name NULLS FIRST, book_ref DESC\n−> Seq Scan on tickets\n(3 rows)\nНоеслисоздатьиндекс,соответствующийжелаемомупорядку,онбудетис-\nпользоваться:\n=> CREATE INDEX tickets_name_bref_idx2\nON tickets(passenger_name NULLS FIRST, book_ref DESC);\n536",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:03.327810"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 538,
    "chapter": null,
    "section": "25.5 Свойства",
    "text": "25.5. Свойства\n=> EXPLAIN (costs off) SELECT *\nFROM tickets ORDER BY passenger_name NULLS FIRST, book_ref DESC;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Scan using tickets_name_bref_idx2 on tickets\n(1 row)\n25.5. Свойства\nПосмотриминтерфейсныесвойстваB-деревьев. с.391\nСвойства метода доступа\n=> SELECT a.amname, p.name, pg_indexam_has_property(a.oid, p.name)\nFROM pg_am a, unnest(array[\n'can_order', 'can_unique', 'can_multi_col',\n'can_exclude', 'can_include'\n]) p(name)\nWHERE a.amname = 'btree';\namname | name | pg_indexam_has_property\n−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−\nbtree | can_order | t\nbtree | can_unique | t\nbtree | can_multi_col | t\nbtree | can_exclude | t\nbtree | can_include | t\n(5 rows)\nB-дерево можетупорядочиватьданные и поддерживаетуникальность.Это\nединственныйметоддоступа,которыйобеспечиваеттакиесвойства.\nМногиеметодыдоступапозволяютсоздаватьсоставныеиндексы,новслу-\nчае B-деревьев приходитсятщательно следитьза порядком столбцов в ин-\nдексеиз-затого,чтозначенияупорядочены.\nПоддержка ограничений исключения формально есть, но ограничивается\nоператоромравенства,чтосоответствуеттребованиюуникальности.Вместо\nтакого ограничения гораздо лучше использовать настоящее полноценное\nограничениеуникальности.\n537",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:03.358287"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 539,
    "chapter": null,
    "section": "25.5 Свойства",
    "text": "Глава25. B-дерево\nB-деревопозволяеттакжедобавлятьвиндексдополнительныестолбцы,не\nучаствующиевпоиске.\nv.11 Индекс будетстроиться в параллельном режиме, еслитаблица достаточно\nвелика. Количество рабочих процессов определяется по той же формуле,\nс.371 что идля параллельного последовательного сканирования,но ограничено\n2 сверху значением параметра max_parallel_maintenance_workers.На все рабо-\n64MB чие процессы выделяется объем памяти размером maintenance_work_mem.\nРабочиепроцессыпараллельносканируюттаблицуисортируютполученные\nданные1;результатобразуетлистовыестраницыиндекса,надкоторымиза-\nтемнадстраиваютсявнутренниестраницывплотьдокорня.\nСвойства индекса\n=> SELECT p.name, pg_index_has_property('flights_pkey', p.name)\nFROM unnest(array[\n'clusterable', 'index_scan', 'bitmap_scan', 'backward_scan'\n]) p(name);\nname | pg_index_has_property\n−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−\nclusterable | t\nindex_scan | t\nbitmap_scan | t\nbackward_scan | t\n(4 rows)\nИндекснаосновеB-дереваможноиспользоватьдлякластеризации.\nB-деревьяподдерживаютобаспособаполучениязначений:ииндексноеска-\nнирование,исканированиепобитовойкарте.Благодарятомучтолистовые\nстраницы связаны двунаправленным списком,индекс можно обходить не\nтольковпрямом,ноивобратномнаправлении,получаяпротивоположный\nпорядоксортировки:\n=> EXPLAIN (costs off) SELECT *\nFROM bookings ORDER BY book_ref DESC;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Scan Backward using bookings_pkey on bookings\n(1 row)\n1 backend/access/nbtree/nbtsort.c,функцияbtbuild.\n538",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:03.395880"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 540,
    "chapter": null,
    "section": "25.5 Свойства",
    "text": "25.5. Свойства\nСвойства столбцов\n=> SELECT p.name,\npg_index_column_has_property('flights_pkey', 1, p.name)\nFROM unnest(array[\n'asc', 'desc', 'nulls_first', 'nulls_last', 'orderable',\n'distance_orderable', 'returnable', 'search_array', 'search_nulls'\n]) p(name);\nname | pg_index_column_has_property\n−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nasc | t\ndesc | f\nnulls_first | f\nnulls_last | t\norderable | t\ndistance_orderable | f\nreturnable | t\nsearch_array | t\nsearch_nulls | t\n(9 rows)\nСвойство ORDERABLE говоритотом,что B-дерево хранитданные упорядо-\nченно, и первые четыре свойства (ASC и DESC, NULLS FIRST и NULLS LAST)\nопределяют,какименноониупорядоченыдляданногостолбца.Вэтомпри-\nмерезначениястолбцаотсортированыповозрастанию,анеопределенные\nзначениянаходятсявконце.\nСвойство SEARCH NULLS показывает возможность поиска неопределенных\nзначений.\nДля B-деревьев не реализована поддержка операторов упорядочивания\n(DISTANCEORDERABLE),хотятакиепопыткипредпринимались1.\nB-деревья поддерживают поиск нескольких значений из массива (свой-\nствоSEARCHARRAY)ипозволяютполучатьданныебезобращенияктаблице\n(RETURNABLE).\n1 commitfest.postgresql.org/27/1804.\n539",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:03.423600"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 541,
    "chapter": null,
    "section": "26.1 Общий принцип",
    "text": "26\nИндекс GiST\n26.1. Общий принцип\nМетоддоступаGiST(GeneralizedSearchTree)1—обобщениеидеисбаланси-\nрованногодеревапоискадлятиповданных,допускающихвзаимноераспо-\nложение значений.B-деревья жесткопривязаны к порядковымтипамдан-\nных,значения которых можно сравнивать(но поддержкатакихтипов реа-\nлизована максимально эффективно). А GiST позволяет задать произволь-\nныйпринципраспределенияданныхподеревувклассеоператоров.ВGiST-\nиндекс можно «уложить» R-дерево для пространственных данных или RD-\nдерево для множеств, а сигнатурное дерево можно применять для любых\nтиповданных(например,длятекстовилиизображений).\nБлагодарярасширяемостивPostgreSQLможноснулясоздатьновыйметод\nдоступа,реализовавинтерфейссмеханизмоминдексирования.Ноэтотре-\nбует не только продумывания логики индексации,но и организации стра-\nничнойструктуры,эффективнойстратегииблокирования,поддержкижур-\nналаупреждающейзаписи.Всеэтоподразумеваеточеньвысокуюквалифи-\nкацию разработчика и большуютрудоемкость.GiST упрощаетзадачу,беря\nнасебярешениенизкоуровневыхпроблемиреализуяобщуюидеюпоиска.\nЧтобыиспользоватьметодGiSTдляновоготипаданных,достаточнопредо-\nставить класс операторов,состоящий из десятка опорных функций.Такой\nкласс содержит значительную часть логики индексирования, в отличие от\nсовсемпростогоклассаоператоровB-дерева.Вэтомсмыслеможноговорить\nотом,чтоGiSTявляетсякаркасомдляпостроенияновыхметодовдоступа.\n1 postgrespro.ru/docs/postgresql/17/gist;\nbackend/access/gist/README.\n540",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:03.455886"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 542,
    "chapter": null,
    "section": "26.1 Общийпринцип",
    "text": "26.1. Общийпринцип\nКаждая запись листового узла (листовая запись) содержит, если говорить\nв самом общем виде,некий предикат (логическое условие) и идентифика-\nтортабличнойверсиистроки.Ключиндексированияобязанудовлетворять\nпредикату;приэтомневажно,входитсамключвэтузаписьилинет.\nКаждая запись внутреннего узла (внутренняя запись)также содержитпре-\nдикатиссылкунадочернийузел,причемвсеиндексированныеданныедо-\nчернего поддерева должны удовлетворять этому предикату.Иными слова-\nми,предикатвнутреннейзаписивключаетвсебяпредикатывсехдочерних\nзаписей.Этоважноесвойство,заменяющееиндексуGiSTпростуюупорядо-\nченностьB-дерева.\nПоисквдеревеGiSTиспользуетфункциюсогласованности—однуизопорных\nфункций,определяемыхклассомоператоров.\nФункция согласованности вызывается для индексной записи и опреде-\nляет, «согласуется» ли предикат данной записи с условием поиска (вида\n«индексированный-столбец оператор выражение»). Для внутренней записи\nонапоказывает,надолиспускатьсявсоответствующееподдерево,адлялис-\nтовойзаписи—удовлетворяетлиусловиюключиндексирования.\nПоиск1,какобычновдереве,начинаетсяскорневогоузла.Спомощьюфунк-\nции согласованности выясняется, в какие дочерние узлы имеет смысл за-\nходить, а в какие — нет. Затем алгоритм повторяется для каждого из най-\nденных дочерних узлов; в индексе GiST, в отличие от B-дерева, их может\nоказатьсянесколько.Записи,отобранныефункциейсогласованностивлис-\nтовыхузлах,возвращаютсявкачестверезультатов.\nПоисквсегдапроизводитсявглубину:алгоритмвпервуюочередьстарается\nдобратьсядо какого-нибудьлистового узла.Это позволяетбыстрее начать\nвозвращать результаты,что может быть важно,если пользователя интере-\nсуюттольконесколькопервыхстрок.\nДля вставки нового значения в дерево GiST функция согласованности не\nгодится, поскольку нужно выбрать один конкретный листовой узел2. Узел\nвыбираетсятак,чтобыминимизироватьстоимостьвставки,определяемую\nштрафнойфункциейклассаоператоров.\n1 backend/access/gist/gistget.c,функцияgistgettuple.\n2 backend/access/gist/gistutil.c,функцияgistchoose.\n541",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:03.495640"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 543,
    "chapter": null,
    "section": "26.1 Общийпринцип",
    "text": "Глава26. ИндексGiST\nКакивслучае B-дерева,ввыбранномузле можетнеоказатьсясвободного\nместа,чтоприводиткрасщеплению1.Дляэтоготребуютсяещедвефункции.\nОдна решает,какие записи останутся в старом узле,а какие будут перене-\nсенывновый;другаяобъединяетдвапредиката,чтобыобновитьпредикат\nродительскогоузла.\nДобавление новых значений приводит к расширению существующих пре-\nдикатов, а сужение выполняется только при расщеплении страницы либо\nприполномперестроениииндекса.Этоможетприводитькдеградациипро-\nизводительностиGiST-индексапричастыхобновлениях.\nПоскольку все эти рассуждения общего вида могутпоказаться непонятны-\nми,азначительнаячастьлогикизависитотконкретногоклассаоператоров,\nдальшеярассмотрюнесколькоконкретныхпримеров.\n26.2. R-дерево для точек\nПервыйпримеротноситсякиндексацииточек(илидругихгеометрических\nобъектов)наплоскости.ОбычноеB-деревонеподходитдлятакоготипадан-\nных, поскольку для точек не определены операторы сравнения. Конечно,\nтакие операторы можно определить самостоятельно, но при работе с гео-\nметрическими данными нас интересует индексная поддержка совсем дру-\nгихопераций,изкоторыхяподробнорассмотрюдве:поисквхождениявза-\nданнуюобластьипоискближайшихсоседей.\nИдеяR-деревасостоитвтом,чтоплоскостьразбиваетсянапрямоугольники,\nкоторые в сумме покрывают все индексируемые точки. Индексная запись\nхранит ограничивающий прямоугольник, а предикат можно сформулиро-\nватьтак:точкалежитвнутриданногоограничивающегопрямоугольника.\nКореньR-деревасодержитнесколькосамыхкрупныхпрямоугольников(воз-\nможно, даже пересекающихся). В дочерних узлах находятся меньшие по\nразмеру прямоугольники,вложенные в родительские; в совокупности они\nохватываютвсенижележащиеточки.\n1 backend/access/gist/gistsplit.c,функцияgistSplitByKey.\n542",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:03.529821"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 544,
    "chapter": null,
    "section": "26.2 R-дереводляточек",
    "text": "26.2. R-дереводляточек\nЛистовыеузлыдолжнысодержатьсамииндексируемыеточки,однакоGiST\nтребует, чтобы тип данных совпадал во всех индексных записях; поэтому\nхранятсявсетежепрямоугольники,но«схлопнутые»вточки.\nПредставить эту структуру наглядно помогут рисунки трех уровней R-де-\nрева, построенного по координатам аэропортов.Для этого примера я рас-\nширяютаблицуairportsдемобазыдопятитысячстрок1.Длянаглядности\nиндекс построен с низким значением параметра хранения fillfactor,чтобы 90\nдерево получилось глубоким; со значением по умолчанию хватает одного\nуровня.\n=> CREATE TABLE airports_big AS\nSELECT * FROM airports_data;\n=> COPY airports_big FROM\n'/home/student/internals/airports/extra_airports.copy';\n=> CREATE INDEX airports_gist_idx ON airports_big\nUSING gist(coordinates) WITH (fillfactor=10);\nНа верхнемуровне всеточкиподеленымежду несколькими(отчастипере-\nсекающимися)ограничивающимипрямоугольниками:\nНаследующемуровнебольшиепрямоугольникираспадаютсянаменьшие:\n1 Файлдоступенпоадресуedu.postgrespro.ru/internals-17/extra_airports.copy(использовались\nданныессайтаopenflights.org).\n543",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 2,
        "content": "|"
      },
      {
        "table_index": 1,
        "rows": 1,
        "cols": 3,
        "content": "|  |"
      }
    ],
    "extracted_at": "2025-10-02T16:00:04.772491"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 545,
    "chapter": null,
    "section": "26.2 R-дереводляточек",
    "text": "Глава26. ИндексGiST\nНапоследнем,внутреннемуровнедеревакаждыйограничивающийпрямо-\nугольниксодержитстолькоточек,сколькопомещаетсянаоднустраницу:\nРисункипоказываютструктуруиндекса,созданного13-йверсиейPostgreSQL.Версия\n14предварительносортируетточкивz-порядке1—этодаетсущественныйвыигрыш\nвскоростипостроенияиндекса,ноувеличиваетперекрытияпрямоугольников(исни-\nжаетэффективностьпоиска).Вверсии15алгоритмсортировкибылсущественноулуч-\nшен2,нопрежниерисункиостаютсяболеенаглядными.\n1 commitfest.postgresql.org/29/2276.\n2 commitfest.postgresql.org/37/3488.\n544",
    "tables": [
      {
        "table_index": 0,
        "rows": 2,
        "cols": 1,
        "content": ""
      },
      {
        "table_index": 1,
        "rows": 2,
        "cols": 1,
        "content": ""
      }
    ],
    "extracted_at": "2025-10-02T16:00:07.346864"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 546,
    "chapter": null,
    "section": "26.2 R-дереводляточек",
    "text": "26.2. R-дереводляточек\nВ этом индексе используется класс операторов point_ops, единственный\nдляточек.\nТочнотакжеможноиндексироватьипрямоугольники,илюбыедругиегео-\nметрическиефигуры,есливместосамойфигурысохранятьвиндексеогра-\nничивающийеепрямоугольник.\nСтраничная организация\nСодержимоестраницGiST-индексаможноизучатьспомощьюрасширения v.14\npageinspect.\nВотличиеотB-дереваиндексGiSTнеимеетметастраницы,акореньдерева\nвсегда располагается в нулевой странице.Если корневая страница расщеп-\nляется,старыйкореньпереноситсявотдельнуюстраницу,ановыйзанимает\nегоместо.\nВотсодержимоекорневойстраницы:\n=> SELECT ctid, left(keys,62) AS keys\nFROM gist_page_items(\nget_raw_page('airports_gist_idx', 0), 'airports_gist_idx'\n) \\gx\n−[ RECORD 1 ]−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nctid | (196,65535)\nkeys | (coordinates)=(\"(50.84510040283203,78.246101379395),(−7.362780\n−[ RECORD 2 ]−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nctid | (392,65535)\nkeys | (coordinates)=(\"(179.951004028,73.51780700683594),(46.95610046\n−[ RECORD 3 ]−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nctid | (195,65535)\nkeys | (coordinates)=(\"(−88.75189971923828,71.9938964844),(−179.87699\n−[ RECORD 4 ]−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nctid | (458,65535)\nkeys | (coordinates)=(\"(−3.440000057220459,82.51779937740001),(−98.22\nЭти четыре строки соответствуют четырем прямоугольникам верхнего\nуровня,показаннымнарисункенапредыдущемобороте.\n545",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:07.384787"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 547,
    "chapter": null,
    "section": "26.2 R-дереводляточек",
    "text": "Глава26. ИндексGiST\nКласс операторов\nСписокопорныхфункций,реализующихлогикупоискаивставкивдерево1,\nможнополучитьследующимзапросом:\n=> SELECT amprocnum, amproc::regproc\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid\nJOIN pg_amproc amop ON amprocfamily = opcfamily\nWHERE amname = 'gist'\nAND opcname = 'point_ops'\nORDER BY amprocnum;\namprocnum | amproc\n−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−\n1 | gist_point_consistent\n2 | gist_box_union\n3 | gist_point_compress\n5 | gist_box_penalty\n6 | gist_box_picksplit\n7 | gist_box_same\n8 | gist_point_distance\n9 | gist_point_fetch\n11 | gist_point_sortsupport\n(9 rows)\nОсновныеобязательныефункциияуженазывалвыше:\n1) функциясогласованностидляобходадереваприпоиске;\n2) функцияобъединения(обратитевниманиенаназвание:объединяются\nпрямоугольники);\n5) функцияштрафадляспускапривставке;\n6) функция,распределяющаязаписиприрасщеплении;\n7) функция,проверяющаяравенстводвухключей.\nНеобязательные функции позволяют управлять аспектами хранения дан-\nныхипроизводительности.\nКлассоператоровpoint_opsподдерживаетследующиеоператоры:\n1 postgrespro.ru/docs/postgresql/17/gist-extensibility.\n546",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:07.420886"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 548,
    "chapter": null,
    "section": "26.2 R-дереводляточек",
    "text": "26.2. R-дереводляточек\n=> SELECT amopopr::regoperator, amopstrategy AS st, oprcode::regproc,\nleft(obj_description(opr.oid, 'pg_operator'), 19) description\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid\nJOIN pg_amop amop ON amopfamily = opcfamily\nJOIN pg_operator opr ON opr.oid = amopopr\nWHERE amname = 'gist'\nAND opcname = 'point_ops'\nORDER BY amopstrategy;\namopopr | st | oprcode | description\n−−−−−−−−−−−−−−−−−−−+−−−−+−−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−\n<<(point,point) | 1 | point_left | is left of\n>>(point,point) | 5 | point_right | is right of\n~=(point,point) | 6 | point_eq | same as\n<<|(point,point) | 10 | point_below | is below\n|>>(point,point) | 11 | point_above | is above\n<−>(point,point) | 15 | point_distance | distance between\n<@(point,box) | 28 | on_pb | point inside box\n<^(point,point) | 29 | point_below | deprecated, use <<|\n>^(point,point) | 30 | point_above | deprecated, use |>>\n<@(point,polygon) | 48 | pt_contained_poly | is contained by\n<@(point,circle) | 68 | pt_contained_circle | is contained by\n(11 rows)\nПо именам операторов бывает сложно догадаться об их значении, поэто-\nмувзапросевыведеныназванияреализующихихфункцийиописание.Все\nоператорытакилииначесвязанысовзаимнымположениемобъектов(«сле-\nва»,«справа»,«выше»,«ниже»,«содержит»,«содержится в») и расстоянием\nмеждуними.\nВ отличие отB-деревьев GiST располагаетзначительно бóльшим количест-\nвомстратегий.Частьномеровстратегийобщаядлянесколькихтиповиндек-\nсов1,ачастьвычисляетсяпоформулам(например,номера28,48и68пред-\nставляют, по сути, одну стратегию: «содержится в» для прямоугольников,\nполигонов и окружностей). Кроме того, поддерживаются некоторые уста-\nревшиеназванияоператоров(<<|и|>>).\nКонкретный класс операторов может реализовывать не все из имеющих-\nся стратегий. Например, класс для точек не реализует стратегию «содер-\nжит»,нотакаястратегияприсутствуетвклассахфигур,имеющихплощадь\n(box_ops,poly_opsиcircle_ops).\n1 include/access/stratnum.h.\n547",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:07.465131"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 549,
    "chapter": null,
    "section": "26.2 R-дереводляточек",
    "text": "Глава26. ИндексGiST\nПоиск вхождения в область\nТипичный запрос, ускоряемый индексом, получает все точки, входящие\nвзаданнуюобласть.\nНапример,найдемвсеаэропорты,находящиесявпределаходногоградуса\nотцентраМосквы:\n=> SELECT airport_code, airport_name->>'en'\nFROM airports_big\nWHERE coordinates <@ '<(37.622513,55.753220),1.0>'::circle;\nairport_code | ?column?\n−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSVO | Sheremetyevo International Airport\nVKO | Vnukovo International Airport\nDME | Domodedovo International Airport\nBKA | Bykovo Airport\nZIA | Zhukovsky International Airport\nCKL | Chkalovskiy Air Base\nOSF | Ostafyevo International Airport\n(7 rows)\n=> EXPLAIN (costs off) SELECT airport_code\nFROM airports_big\nWHERE coordinates <@ '<(37.622513,55.753220),1.0>'::circle;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on airports_big\nRecheck Cond: (coordinates <@ '<(37.622513,55.75322),1>'::circle)\n−> Bitmap Index Scan on airports_gist_idx\nIndex Cond: (coordinates <@ '<(37.622513,55.75322),1>'::ci...\n(4 rows)\nОператор «содержится в» <@ определяет,лежитлиточка внутри заданного\nпрямоугольника. Функция согласованности для этого оператора1 возвра-\nщает«да»,если прямоугольник индексной записи имеетобщиеточки с за-\nданнымпрямоугольником.Длялистовыхстраниц,записикоторыхсодержат\n«схлопнутые» в точки прямоугольники,это означает,что функция опреде-\nляет,содержитсялиточкавнутризаданногопрямоугольника.\nРассмотримподробнееработуоператоранасовсемпростомпримере,пока-\nзанномнарисунке:\n1 backend/access/gist/gistproc.c,функцияgist_point_consistent.\n548",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:07.504882"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 550,
    "chapter": null,
    "section": "26.2 R-дереводляточек",
    "text": "26.2. R-дереводляточек\n9 9\n8 8\n7 7\n6 6\n5 5\n4 4\n3 3\n2 2\n1 1\n0 0\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\nСтруктураиндексапритакомразбиениивыглядитследующимобразом:\n00,,00––33,,44 55,,33––99,,99\n00,,00––33,,22 00,,33––33,,44 55,,33––88,,55 66,,66––99,,99\n00,,00 11,,22 33,,11 00,,44 33,,33 55,,33 88,,55 66,,66 88,,99 99,,77\nНапример, найдем внутренние точки прямоугольника (1,2)–(4,7), показан-\nногосправанарисункевыше.\nПоискначинаетсяскорневогоузла.Заданныйпрямоугольникпересекается\nс (0,0)–(3,4), но не пересекается с (5,3)–(9,9). Поэтому во второе поддерево\nнамспускатьсяненужно.\nНа следующем уровне заданный прямоугольник пересекается с (0,3)–(3,4)\nикасается(0,0)–(3,2),поэтомунампридетсяпроверитьобаподдерева.\nКогдамыдойдемдолистовыхузлов,останетсяперебратьвсесодержащиеся\nтамточкиивернутьте,длякоторыхвыполняетсяфункциясогласованности.\n549",
    "tables": [
      {
        "table_index": 0,
        "rows": 9,
        "cols": 9,
        "content": "|  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |"
      },
      {
        "table_index": 1,
        "rows": 9,
        "cols": 9,
        "content": "|  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T16:00:07.571965"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 551,
    "chapter": null,
    "section": "26.2 R-дереводляточек",
    "text": "Глава26. ИндексGiST\n00,,00––33,,44 55,,33––99,,99\n00,,00––33,,22 00,,33––33,,44 55,,33––88,,55 66,,66––99,,99\n00,,00 11,,22 33,,11 00,,44 33,,33 55,,33 88,,55 66,,66 88,,99 99,,77\nПоиск по В-дереву всегда однозначно выбирает дочерний узел; поиск по\nGiSTжеможетпотребоватьобходанесколькихподдеревьев,особенноесли\nихограничивающиепрямоугольникипересекаются.\nПоиск ближайших соседей\nБольшинствооператоров,поддерживаемыхиндексами(такихкак= или<@\nв предыдущем примере), можно назвать поисковыми, так как они задают\nусловияпоискавзапросе.Такиеоператорыявляютсяпредикатами,тоесть\nвозвращаютлогическоезначение.\nЕстьидругойтипоператоров—упорядочивающие,которыевозвращаютрас-\nстояниемеждуаргументами.ТакиеоператорывпредложенииORDERBYмо-\nгут поддерживаться индексами,реализующими свойство DISTANCE ORDER-\nс.398 ABLE,чтопозволяетэффективнонаходитьзаданноеколичествоближайших\nсоседей.Такойпоискизвестенкакk-NN—k-nearestneighborsearch.\nНапример,можнонайтидесятьаэропортов,ближайшихкКостроме:\n=> SELECT airport_code, airport_name->>'en'\nFROM airports_big\nORDER BY coordinates <-> '(40.926780,57.767943)'::point\nLIMIT 10;\n550",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:07.630080"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 552,
    "chapter": null,
    "section": "26.2 R-дереводляточек",
    "text": "26.2. R-дереводляточек\nairport_code | ?column?\n−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nKMW | Kostroma Sokerkino Airport\nIAR | Tunoshna Airport\nIWA | Ivanovo South Airport\nVGD | Vologda Airport\nRYB | Staroselye Airport\nGOJ | Nizhny Novgorod Strigino International Airport\nCEE | Cherepovets Airport\nCKL | Chkalovskiy Air Base\nZIA | Zhukovsky International Airport\nBKA | Bykovo Airport\n(10 rows)\n=> EXPLAIN (costs off) SELECT airport_code\nFROM airports_big\nORDER BY coordinates <-> '(40.926780,57.767943)'::point\nLIMIT 10;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nLimit\n−> Index Scan using airports_gist_idx on airports_big\nOrder By: (coordinates <−> '(40.92678,57.767943)'::point)\n(3 rows)\nЗа счеттого,что индексное сканирование выдаетрезультаты по одному и\nегоможноостановитьвлюбоймомент,поискнесколькихзначенийполуча-\nетсяоченьбыстрым.\nВотсутствиеиндекснойподдержкипостроитьэффективныйпоискбылобынепрос-\nто.Дляэтогопришлосьбыискатьточки,входящиевнекоторуюобласть,постепенно\nрасширяяее,поканебудетдостигнутозаданноеколичествонайденныхрезультатов.\nЭтопотребовалобынесколькоиндексныхсканирований,неговоряужеопроблеме\nвыбораначальногоразмераобластииееприращения.\nВ системном каталоге можно увидеть тип оператора (s — поисковый, o —\nупорядочивающий):\n=> SELECT amopopr::regoperator, amoppurpose, amopstrategy\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid\nJOIN pg_amop amop ON amopfamily = opcfamily\nWHERE amname = 'gist'\nAND opcname = 'point_ops'\nORDER BY amopstrategy;\n551",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:07.683400"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 553,
    "chapter": null,
    "section": "26.2 R-дереводляточек",
    "text": "Глава26. ИндексGiST\namopopr | amoppurpose | amopstrategy\n−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−+−−−−−−−−−−−−−−\n<<(point,point) | s | 1\n>>(point,point) | s | 5\n~=(point,point) | s | 6\n<<|(point,point) | s | 10\n|>>(point,point) | s | 11\n<−>(point,point) | o | 15\n<@(point,box) | s | 28\n<^(point,point) | s | 29\n>^(point,point) | s | 30\n<@(point,polygon) | s | 48\n<@(point,circle) | s | 68\n(11 rows)\nДляподдержкитакоговидазапросовклассоператоровдолженопределить\nдополнительнуюопорнуюфункциюрасстояния.Функциярасстояниявызы-\nваетсядляэлементаиндексаивычисляетрасстояниеотзначениявданном\nэлементедонекоторогодругогозначения.\nДля листового элемента, представляющего собой индексированное значе-\nние,функциядолжнавернутьрасстояниеотэтогозначения.Вслучаеточек1\nэтообычноеевклидоворасстояние,равное√(x −x )2+(y −y )2.\n2 1 2 1\nДлявнутреннегоэлементафункциядолжнавернутьминимальноеизрасстоя-\nний отдочернихлистовых элементов.Поскольку перебиратьвседочерние\nзаписивесьманакладно,функцияимеетправооптимистическиприумень-\nшатьрасстояние(жертвуяприэтомэффективностью),нонедолжнавозвра-\nщатьбольшеезначение—этонарушиткорректностьпоиска.\nПоэтому для внутреннего элемента, представленного ограничивающим\nпрямоугольником,расстояниедоточкипонимаетсявобычномматематиче-\nском смысле,как минимальное расстояние междуточкой ипрямоугольни-\nкомилиноль,еслиточканаходитсявнутри2.Этозначениелегковычислить,\nнеобходядочерниеточкипрямоугольника,ионогарантированнонеболь-\nшерасстояниядолюбойизних.\nРассмотримнанашемпростомпримереалгоритмпоискатрехближайших\nсоседейточки(6,8):\n1 backend/utils/adt/geo_ops.c,функцияpoint_distance.\n2 backend/utils/adt/geo_ops.c,функцияbox_closest_point.\n552",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:07.738246"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 554,
    "chapter": null,
    "section": "26.2 R-дереводляточек",
    "text": "26.2. R-дереводляточек\n9\n8\n7\n6\n5\n4\n3\n2\n1\n0\n0 1 2 3 4 5 6 7 8 9\nПоиск начинается с корневого узла, в котором имеется два ограничиваю-\nщихпрямоугольника.Зарасстояниеотточкидо(0,0)–(3,4)принимаетсярас-\nстояние до угла (3,4) прямоугольника, и оно составляет 5,0. Расстояние до\n(5,3)–(9,9)равно0,0.(Ябудуокруглятьзначениядоодногознакапослезапя-\nтой;вэтомпримеретакойточностидостаточно.)\nОбходдочернихузловпроисходитвпорядкеувеличениярасстояния.Таким\nобразом,сначаламыспускаемсявправыйдочернийузел,содержащийдва\nпрямоугольника: (5,3)–(8,5) и (6,6)–(9,9). Расстояние до первого составляет\n3,0,адовторого—0,0:\n5,0 00,,00––33,,44 55,,33––99,,99 0,0\n00,,00––33,,22 00,,33––33,,44 3,0 55,,33––88,,55 66,,66––99,,99 0,0\n00,,00 11,,22 33,,11 00,,44 33,,33 55,,33 88,,55 66,,66 88,,99 99,,77\n553",
    "tables": [
      {
        "table_index": 0,
        "rows": 9,
        "cols": 9,
        "content": "|  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T16:00:07.807133"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 555,
    "chapter": null,
    "section": "26.2 R-дереводляточек",
    "text": "Глава26. ИндексGiST\nСнова спускаемся в правое поддерево и попадаем в листовой узел, содер-\nжащийтриточки: (6,6) на расстоянии 2,0, (8,9) на расстоянии 2,2 и (9,7) на\nрасстоянии3,2.Такимобразом,унасестьпервыедветочки(6,6)и(8,9),но\nрасстояние дотретьейточки этого узла больше,чем расстояние до прямо-\nугольника(5,3)–(8,5):\n5,0 00,,00––33,,44 55,,33––99,,99 0,0\n00,,00––33,,22 00,,33––33,,44 3,0 55,,33––88,,55 66,,66––99,,99 0,0\n00,,00 11,,22 33,,11 00,,44 33,,33 55,,33 88,,55 66,,66 88,,99 99,,77\n2,0 2,2 3,2\nПоэтому теперь спускаемся в левый дочерний узел, содержащий две точ-\nки:(8,5)нарасстоянии3,6и(5,3)нарасстоянии5,1.Оказывается,точка(9,7)\nвпредыдущемдочернемузлеближе,чемлюбаяизточеклевогоподдерева,\nимыможемвернутьеевкачестветретьегорезультата:\n5,0 00,,00––33,,44 55,,33––99,,99 0,0\n00,,00––33,,22 00,,33––33,,44 3,0 55,,33––88,,55 66,,66––99,,99 0,0\n00,,00 11,,22 33,,11 00,,44 33,,33 55,,33 88,,55 66,,66 88,,99 99,,77\n5,1 3,6 2,0 2,2 3,2\n554",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:07.881983"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 556,
    "chapter": null,
    "section": "26.2 R-дереводляточек",
    "text": "26.2. R-дереводляточек\nЭтот пример поясняет требования к функции расстояния для внутренних\nзаписей.Уменьшенноерасстояние(3,0вместореальных3,6)допрямоуголь-\nника (5,3)–(8,5) ухудшило эффективность, поскольку пришлось напрасно\nпросмотреть дополнительный узел, но не нарушило правильность работы\nалгоритма.\nВставка\nПривставкеновогоключавR-деревоузелдлявставкивыбираетсянаосно-\nванииштрафнойфункциитак,чтобыплощадьохватывающегопрямоуголь-\nникаизмениласькакможноменьше1.\nНапример,точка(4,7)будетдобавленакпрямоугольнику(5,3)–(9,9),посколь-\nку его площадь при этом увеличится всего на 6 единиц, в то время как\nплощадь прямоугольника (0,0)–(3,4) пришлось бы увеличить на 12. На сле-\nдующем(листовом)уровнеизэтихжесоображенийточкабудетдобавлена\nкпрямоугольнику(6,6)–(9,9).\n9 9\n8 8\n7 7\n6 6\n5 5\n4 4\n3 3\n2 2\n1 1\n0 0\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\nЕслипредположить,чтонастраницепомещаетсянеболеетрехэлементов,\nпроизойдетрасщеплениестраницынадве,иэлементыперераспределятся\nмеждуними:\n1 backend/access/gist/gistproc.c,функцияgist_box_penalty.\n555",
    "tables": [
      {
        "table_index": 0,
        "rows": 9,
        "cols": 9,
        "content": "|  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |"
      },
      {
        "table_index": 1,
        "rows": 9,
        "cols": 9,
        "content": "|  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T16:00:07.955305"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 557,
    "chapter": null,
    "section": "26.2 R-дереводляточек",
    "text": "Глава26. ИндексGiST\n9\n8\n7\n6\n5\n4\n3\n2\n1\n0\n0 1 2 3 4 5 6 7 8 9\nВэтомпримеререзультаткажетсяочевидным,новобщемслучаевыборрас-\nпределенияпредставляетвесьманепростуюзадачу.Функциярасщепления\nвпервуюочередьпытаетсяминимизироватьпересечениеограничивающих\nпрямоугольников,отдаваяпредпочтениепрямоугольникамсменьшейпло-\nщадьюиравномерномураспределениюточекмеждустраницами1.\nОграничение исключения\nИндексGiST можетприменятьсядляподдержкиограниченийисключения\n(exclude).\nОграничениеисключениягарантирует,чтозаданныеполялюбыхдвухстрок\nтаблицынебудут«соответствовать»другдругувсмысленекоторогоопера-\nтора.Должнывыполнятьсяследующиеусловия:\n• ограничениеисключениядолжноподдерживатьсяиндекснымметодом\n(свойствоCANEXCLUDE);\n• оператордолженвходитьвклассоператоровэтогоиндексногометода;\n• оператор должен быть коммутативным, то есть должно выполняться\nусловиеaоператорb=bоператорa.\n1 backend/access/gist/gistproc.c,функцияgist_box_picksplit.\n556",
    "tables": [
      {
        "table_index": 0,
        "rows": 9,
        "cols": 9,
        "content": "|  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T16:00:07.994150"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 558,
    "chapter": null,
    "section": "26.2 R-дереводляточек",
    "text": "26.2. R-дереводляточек\nМетодыдоступаhashиbtree,рассмотренныевыше,предлагаютединствен-\nныйоператор,подходящийподусловие,—равенство.Стакимоператором\nограничениеисключениясоответствуетограничениюуникальности,чтоне с.511\nособеннополезно.\nНометодgistимеетещедвеподходящиестратегии:\n• пересечение—оператор&&;\n• примыкание—оператор-|-(определендляинтервалов).\nВкачествепримерасоздадимограничение,запрещающеерасполагатьаэро-\nпортыслишкомблизкодругкдругу.Этоусловиеможнопереформулировать\nтак:окружностинекоторогорадиусасцентрамивкоординатахаэропортов\nнедолжныпересекаться:\n=> ALTER TABLE airports_data ADD EXCLUDE\nUSING gist (circle(coordinates,0.2) WITH &&);\n=> INSERT INTO airports_data(\nairport_code, airport_name, city, coordinates, timezone\n) VALUES (\n'ZIA', '{}', '{\"en\": \"Moscow\"}', point(38.1517, 55.5533),\n'Europe/Moscow'\n);\nERROR: conflicting key value violates exclusion constraint\n\"airports_data_circle_excl\"\nDETAIL: Key (circle(coordinates, 0.2::double\nprecision))=(<(38.1517,55.5533),0.2>) conflicts with existing key\n(circle(coordinates, 0.2::double\nprecision))=(<(37.90629959106445,55.40879821777344),0.2>).\nПри создании ограничения исключения автоматически создается индекс\nдляегопроверки.ВданномпримереэтоGiST-индексповыражению.\nУсложнимзадачу.Пустьтребуетсяразрешитьблизкоесоседствоаэропортов,\nнотольковтомслучае,когдаониотносятсякодномугороду.Решениембу-\nдет создать новое ограничение целостности, которое можно сформулиро-\nвать так: не допускаются пары строк, в которых пересекаются (&&) окруж-\nности с центрами в координатах аэропортов и при этом не совпадают (!=)\nназваниягородов.\n557",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:08.031679"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 559,
    "chapter": null,
    "section": "26.2 R-дереводляточек",
    "text": "Глава26. ИндексGiST\nПопытка создать такое ограничение приводит к ошибке, поскольку не су-\nществуетклассаоператоровдлятекстовоготипаданных:\n=> ALTER TABLE airports_data\nDROP CONSTRAINT airports_data_circle_excl; -- удаляем старое\n=> ALTER TABLE airports_data ADD EXCLUDE USING gist (\ncircle(coordinates,0.2) WITH &&,\n(city->>'en') WITH !=\n);\nERROR: data type text has no default operator class for access\nmethod \"gist\"\nHINT: You must specify an operator class for the index or define a\ndefault operator class for the data type.\nНо ведь GiST работает со стратегиями вроде «находится слева», «находит-\nся справа» и «совпадает»,которые можно применить и к обычным поряд-\nковымтипамданных,таким как числа илитекстовые строки.Расширение\nbtree_gistкакразидобавляетGiST-поддержкуопераций,характерныхдля\nB-деревьев:\n=> CREATE EXTENSION btree_gist;\n=> ALTER TABLE airports_data ADD EXCLUDE USING gist (\ncircle(coordinates,0.2) WITH &&,\n(city->>'en') WITH !=\n);\nALTER TABLE\nОграничение создано.ДобавитьаэропортЖуковский в городе стем же на-\nзваниемтеперьнеполучитсяиз-заблизостимосковскихаэропортов:\n=> INSERT INTO airports_data(\nairport_code, airport_name, city, coordinates, timezone\n) VALUES (\n'ZIA', '{}', '{\"en\": \"Zhukovsky\"}', point(38.1517, 55.5533),\n'Europe/Moscow'\n);\nERROR: conflicting key value violates exclusion constraint\n\"airports_data_circle_expr_excl\"\nDETAIL: Key (circle(coordinates, 0.2::double precision), (city −>>\n'en'::text))=(<(38.1517,55.5533),0.2>, Zhukovsky) conflicts with\nexisting key (circle(coordinates, 0.2::double precision), (city −>>\n'en'::text))=(<(37.90629959106445,55.40879821777344),0.2>, Moscow).\n558",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:08.072670"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 560,
    "chapter": null,
    "section": "26.2 R-дереводляточек",
    "text": "26.2. R-дереводляточек\nНоэтоможносделать,указавгородомаэропортаМоскву:\n=> INSERT INTO airports_data(\nairport_code, airport_name, city, coordinates, timezone\n) VALUES (\n'ZIA', '{}', '{\"en\": \"Moscow\"}', point(38.1517, 55.5533),\n'Europe/Moscow'\n);\nINSERT 0 1\nВажно помнить, что хотя GiST и может работать с операциями «больше»,\n«меньше»или«равно»,ноB-деревосправляетсяснимигораздоэффектив-\nнее,особеннопридоступекдиапазонузначений.Такчтопоказанныйвпри-\nмереприемсрасширениемbtree_gistстоитиспользовать,толькоеслиин-\nдексGiSTнеобходимпосуществу.\nСвойства\nСвойства метода доступа. Вот какие свойства сообщает о себе метод gist:\n=> SELECT a.amname, p.name, pg_indexam_has_property(a.oid, p.name)\nFROM pg_am a, unnest(array[\n'can_order', 'can_unique', 'can_multi_col',\n'can_exclude', 'can_include'\n]) p(name)\nWHERE a.amname = 'gist';\namname | name | pg_indexam_has_property\n−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−\ngist | can_order | f\ngist | can_unique | f\ngist | can_multi_col | t\ngist | can_exclude | t\ngist | can_include | t\n(5 rows)\nПоддержкасортировкизначенийиуникальностиотсутствует.\nGiST-индексможносоздаватьсдополнительнымиinclude-столбцами. v.12\nИндекс,как мы видели,можно строитьпо нескольким столбцам и исполь-\nзоватьвограниченияхисключения.\n559",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:08.109817"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 561,
    "chapter": null,
    "section": "26.2 R-дереводляточек",
    "text": "Глава26. ИндексGiST\nСвойстваиндекса. Свойства,определенныенауровнеиндекса:\n=> SELECT p.name, pg_index_has_property('airports_gist_idx', p.name)\nFROM unnest(array[\n'clusterable', 'index_scan', 'bitmap_scan', 'backward_scan'\n]) p(name);\nname | pg_index_has_property\n−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−\nclusterable | t\nindex_scan | t\nbitmap_scan | t\nbackward_scan | f\n(4 rows)\nGiST-индексможноиспользоватьдлякластеризациитаблицы.\nПоддерживаютсяобаспособаполученияданных:истроказастрокой,ипо\nбитовойкарте.НообратныйпорядоксканированиядляGiSTнеопределен.\nСвойствастолбцов. Основнаячастьсвойствстолбцовопределенанауровне\nметодадоступаинеменяется:\n=> SELECT p.name,\npg_index_column_has_property('airports_gist_idx', 1, p.name)\nFROM unnest(array[\n'orderable', 'search_array', 'search_nulls'\n]) p(name);\nname | pg_index_column_has_property\n−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\norderable | f\nsearch_array | f\nsearch_nulls | t\n(3 rows)\nВсесвойства,связанныессортировкой,отключены.\nНеопределенныезначениядопускаютсяGiST-индексом,нообрабатываются\nне слишком эффективно.Считается,что неопределенное значение не рас-\nширяетограничивающийпрямоугольник;поэтомупривставкетакиезначе-\nнияпопадаютвразныеподдеревьяиндексаслучайнымобразом,иихпри-\nходитсяискатьвовсемдереве.\n560",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:08.149445"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 562,
    "chapter": null,
    "section": "26.2 R-дереводляточек",
    "text": "26.2. R-дереводляточек\nОднакопарасвойствуровнястолбцаможетменятьсявзависимостиотклас-\nсаоператоров.\n=> SELECT p.name,\npg_index_column_has_property('airports_gist_idx', 1, p.name)\nFROM unnest(array[\n'returnable', 'distance_orderable'\n]) p(name);\nname | pg_index_column_has_property\n−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nreturnable | t\ndistance_orderable | t\n(2 rows)\nИндекс может использоваться в сканировании только индекса, поскольку\nключииндексированияполностьюхранятсявлистовыхузлах.\nВданномслучае,какмывидели,классоператоровсодержитоператоррас-\nстояния для поиска ближайших соседей. Расстояние до неопределенного\nзначениясчитаетсянеопределенным;такиезначениявыдаютсяпоследни-\nми(аналогичноуказаниюNULLSLASTвB-деревьях).\nНо для диапазонных типов (которые представляют отрезки,то есть те же\nгеометрическиефигуры,тольконапрямой,аненаплоскости)операторрас-\nстояния не реализован,поэтомудля индекса потакомутипуданных свой-\nствобудетотличаться:\n=> CREATE TABLE reservations(during tsrange);\n=> CREATE INDEX ON reservations USING gist(during);\n=> SELECT p.name,\npg_index_column_has_property('reservations_during_idx', 1, p.name)\nFROM unnest(array[\n'returnable', 'distance_orderable'\n]) p(name);\nname | pg_index_column_has_property\n−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nreturnable | t\ndistance_orderable | f\n(2 rows)\n561",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:08.188614"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 563,
    "chapter": null,
    "section": "26.3 RD-дерево для полнотекстового поиска",
    "text": "Глава26. ИндексGiST\n26.3. RD-дерево для полнотекстового поиска\nПро полнотекстовый поиск\nЗадачаполнотекстовогопоиска1—выбратьизнаборадокументовте,кото-\nрыесоответствуютпоисковомузапросу.\nДляцелейпоискадокументприводитсякспециальномутипуtsvector,ко-\nторый содержит лексемы и их позиции в документе.Лексемы—это слова,\nпреобразованные к виду, удобному для поиска. Например, по умолчанию\nсловаприводятсякнижнемурегиструилишаютсяизменяемыхокончаний:\n=> SET default_text_search_config = russian;\n=> SELECT to_tsvector(\n'И встал Айболит, побежал Айболит. ' ||\n'По полям, по лесам, по лугам он бежит.'\n);\nto_tsvector\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n'айбол':3,5 'беж':13 'встал':2 'лес':9 'луг':11 'побежа':4 'пол':7\n(1 row)\nТакназываемыестоп-слова(«и»,«по»)удаляются,таккакони,предположи-\nтельно,встречаютсяслишкомчасто,чтобыпоискпонимбылосмысленным.\nРазумеется,всеэтипреобразованиянастраиваются.\nПоисковыйзапроспредставляетсядругимтипом—tsquery.Запроссостоит\nизоднойилинесколькихлексем,соединенныхлогическимисвязками:«и»\n&,«или»|,«не»!.Такжеможноиспользоватьскобкидляуточненияприори-\nтетаопераций.\n=> SELECT to_tsquery('Айболит & (побежал | пошел)');\nto_tsquery\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n'айбол' & ( 'побежа' | 'пошел' )\n(1 row)\nДля полнотекстового поиска используется единственный оператор соот-\nветствия@@:\n1 postgrespro.ru/docs/postgresql/17/textsearch.\n562",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:08.223671"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 564,
    "chapter": null,
    "section": "26.3 RD-дереводляполнотекстовогопоиска",
    "text": "26.3. RD-дереводляполнотекстовогопоиска\n=> SELECT amopopr::regoperator, oprcode::regproc, amopstrategy\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid\nJOIN pg_amop amop ON amopfamily = opcfamily\nJOIN pg_operator opr ON opr.oid = amopopr\nWHERE amname = 'gist'\nAND opcname = 'tsvector_ops'\nORDER BY amopstrategy;\namopopr | oprcode | amopstrategy\n−−−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−+−−−−−−−−−−−−−−\n@@(tsvector,tsquery) | ts_match_vq | 1\n(1 row)\nЭтотоператоропределяет,соответствуетлидокументпоисковомузапросу.\nВотпростойпример:\n=> SELECT to_tsvector('И встал Айболит, побежал Айболит.') @@\nto_tsquery('Айболит & побежать');\n?column?\n−−−−−−−−−−\nt\n(1 row)\nЭто ни в коей мере не исчерпывающее описание полнотекстового поиска, с.599\nноэтихсведенийбудетдостаточнодляпониманияиндексирования.\nИндексация tsvector\nЧтобы полнотекстовый поиск работал быстро, его нужно поддержать ин-\nдексом1. Поскольку индексируются не сами документы, а значения типа с.599\ntsvector,естьдва варианта: построить индекс по выражению,с приведе-\nниемтипа,илисоздатьотдельныйстолбецтипаtsvectorииндексировать\nего. Плюс первого варианта в том, что он не расходует место для хране-\nниязначенийtsvector,которыесамипосебеникомуненужны.Однакоон\nпроигрывает варианту со столбцом по скорости,когда механизм индекси-\nрованияперепроверяетпотаблицеидентификаторыверсий,возвращенные\nиндексным методом.Для этого приходится повторно вычислять значение\n1 postgrespro.ru/docs/postgresql/17/textsearch-indexes.\n563",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:08.266084"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 565,
    "chapter": null,
    "section": "26.3 RD-дереводляполнотекстовогопоиска",
    "text": "Глава26. ИндексGiST\ntsvector для каждой проверяемой строки,а индекс GiST,как мы увидим,\nперепроверяетвсестроки.\nПостроимнебольшойпример.Создадимтаблицусдвумястолбцами:впер-\nвом будет храниться документ, во втором — значение tsvector. Второй\nстолбец можно обновлятьтриггером1,но удобнее просто объявить его как\nv.12 генерируемый2:\n=> CREATE TABLE ts(\ndoc text,\ndoc_tsv tsvector GENERATED ALWAYS AS (\nto_tsvector('pg_catalog.russian', doc)\n) STORED\n);\n=> CREATE INDEX ts_gist_idx ON ts USING gist(doc_tsv);\nВ примерах выше я приводил функцию to_tsvector с одним параметром,пред-\nenglish варительно устанавливая конфигурацию полнотекстового поиска в параметре de-\nfault_text_search_config.Такой вариантфункции имееткатегорию изменчивости STA-\nBLE,посколькунеявнозависитотзначенияпараметра.Здесьжеиспользуетсявариант\nфункции с явным указанием конфигурации,который имеет категорию IMMUTABLE,\nподходящуюдляиспользованиявгенерирующемвыражении.\nВставимвтаблицунесколькострок:\n=> INSERT INTO ts(doc) VALUES\n('Во поле береза стояла'), ('Во поле кудрявая стояла'),\n('Люли, люли, стояла'), ('Люли, люли, стояла'),\n('Некому березу заломати'), ('Некому кудряву заломати'),\n('Люли, люли, заломати'), ('Люли, люли, заломати'),\n('Я пойду погуляю'), ('Белую березу заломаю'),\n('Люли, люли, заломаю'), ('Люли, люли, заломаю')\nRETURNING doc_tsv;\ndoc_tsv\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n'берез':3 'пол':2 'стоя':4\n'кудряв':3 'пол':2 'стоя':4\n'люл':1,2 'стоя':3\n'люл':1,2 'стоя':3\n'берез':2 'заломат':3 'нек':1\n1 postgrespro.ru/docs/postgresql/17/textsearch-features#TEXTSEARCH-UPDATE-TRIGGERS.\n2 postgrespro.ru/docs/postgresql/17/ddl-generated-columns.\n564",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:08.308620"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 566,
    "chapter": null,
    "section": "26.3 RD-дереводляполнотекстовогопоиска",
    "text": "26.3. RD-дереводляполнотекстовогопоиска\n'заломат':3 'кудряв':2 'нек':1\n'заломат':3 'люл':1,2\n'заломат':3 'люл':1,2\n'погуля':3 'пойд':2\n'бел':1 'берез':2 'залома':3\n'залома':3 'люл':1,2\n'залома':3 'люл':1,2\n(12 rows)\nINSERT 0 12\nR-дерево как таковое не годится для индексации документов, поскольку\nк ним неприменимо понятие ограничивающего прямоугольника. Исполь-\nзуется модификация этого подхода — RD-дерево (Russian Doll, матрешка).\nВместоограничивающегопрямоугольникаэтодеревоиспользуетограничи-\nвающеемножество,тоестьмножество,содержащеевсеэлементыдочерних\nмножеств.Дляполнотекстовогопоискамножествосостоитизлексемдоку-\nмента,новобщемслучаемножествоможетбытьпроизвольным.\nЕстьнесколькоспособовпредставлениямножестввиндексныхзаписях.Са-\nмыйпростой—непосредственноперечислитьвсеэлементымножества.Вот\nкакэтомоглобывыглядеть:\nббеерреезз,,ззааллооммаатт,, ббеелл,,ббеерреезз,,ззааллооммаа,,\nккууддрряявв,,ннеекк,, ззааллооммаатт,,ллююлл,,\nппоолл,,ссттоояя ппооггуулляя,,ппооййдд,,ссттоояя\nббеерреезз,,ккууддрряявв,, ббеерреезз,,ззааллооммаатт,, ббеелл,,ббеерреезз,, ззааллооммаа,,ззааллооммаатт,,\nппоолл,,ссттоояя ккууддрряявв,,ннеекк ззааллооммаа,,ппооггуулляя,,ппооййдд ллююлл,,ссттоояя\nббеерреезз,,ппоолл,,ссттоояя ббеерреезз,,ззааллооммаатт,,ннеекк ппооггуулляя,,ппооййдд ллююлл,,ссттоояя\nккууддрряявв,,ппоолл,,ссттоояя ззааллооммаатт,,ккууддрряявв,,ннеекк ббеелл,,ббеерреезз,,ззааллооммаа ззааллооммаатт,,ллююлл\nззааллооммаа,,ллююлл\n565",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:08.360765"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 567,
    "chapter": null,
    "section": "26.3 RD-дереводляполнотекстовогопоиска",
    "text": "Глава26. ИндексGiST\nТогда, например, для поиска документов, удовлетворяющих условию\ndoc_tsv @@ to_tsquery('стояла'),нужноспускатьсявузлы,длякоторых\nизвестно,чтодочерниезаписисодержатлексему«стоя»:\nббеерреезз,,ззааллооммаатт,, ббеелл,,ббеерреезз,,ззааллооммаа,,\nккууддрряявв,,ннеекк,, ззааллооммаатт,,ллююлл,,\nппоолл,,ссттоояя ппооггуулляя,,ппооййдд,,ссттоояя\nббеерреезз,,ккууддрряявв,, ббеерреезз,,ззааллооммаатт,, ббеелл,,ббеерреезз,, ззааллооммаа,,ззааллооммаатт,,\nппоолл,,ссттоояя ккууддрряявв,,ннеекк ззааллооммаа,,ппооггуулляя,,ппооййдд ллююлл,,ссттоояя\nббеерреезз,,ппоолл,,ссттоояя ббеерреезз,,ззааллооммаатт,,ннеекк ппооггуулляя,,ппооййдд ллююлл,,ссттоояя\nккууддрряявв,,ппоолл,,ссттоояя ззааллооммаатт,,ккууддрряявв,,ннеекк ббеелл,,ббеерреезз,,ззааллооммаа ззааллооммаатт,,ллююлл\nззааллооммаа,,ллююлл\nПроблемытакогопредставленияочевидны.Количестволексемвдокументе\nможетбытьогромным,аместовстраницеограничено.Дажеесливкаждом\nдокументенетакмногоуникальныхлексем,объединениемножествнаверх-\nнихуровняхдеревавсеравноможетполучитьсяоченьбольшим.\nДля полнотекстового поиска применяетсядругое,более компактное реше-\nние — сигнатурное дерево. Идея его хорошо знакома всем, кто имел дело\nс.651 сфильтромБлума.\nКаждую лексему можно представить своей сигнатурой: битовой строкой\nопределенной длины, в которой все биты равны нулю (сброшены), кроме\nодного, который равен единице (установлен). Номер установленного бита\nопределяетсязначениемхеш-функцииотлексемы.\nСигнатурой документа называется побитовое «или» сигнатур всех лексем\nдокумента.\n566",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:08.412375"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 568,
    "chapter": null,
    "section": "26.3 RD-дереводляполнотекстовогопоиска",
    "text": "26.3. RD-дереводляполнотекстовогопоиска\nДопустим,мыприсвоили бел 1000000\nнашимлексемамтакие берез 0001000\nсигнатуры: залома 0000010\nзаломат 0010000\nкудряв 0000100\nлюл 0100000\nнек 0000100\nпогуля 0000001\nпойд 0000010\nпол 0000010\nстоя 0010000\nТогдасигнатурыдокументов Во поле береза стояла 0011010\nбудутследующими: Вополекудряваястояла 0010110\nЛюли,люли,стояла 0110000\nНекомуберезузаломати 0011100\nНекомукудрявузаломати 0010100\nЛюли,люли,заломати 0110000\nЯпойдупогуляю 0000011\nБелуюберезузаломаю 1001010\nЛюли,люли,заломаю 0100010\nДеревоиндексавэтомслучаеможнопредставитьтак:\n00001111111100 11111111001111\n00001111111100 00001111110000 11000011001111 00111100001100\n00001111001100 00001111110000 00000000001111 00111100000000\n00001100111100 00001100110000 11000011001100 00111100000000 00110000001100\n567",
    "tables": [
      {
        "table_index": 0,
        "rows": 2,
        "cols": 1,
        "content": "пол\nстоя"
      },
      {
        "table_index": 1,
        "rows": 1,
        "cols": 3,
        "content": "поле | береза | стояла"
      }
    ],
    "extracted_at": "2025-10-02T16:00:08.453567"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 569,
    "chapter": null,
    "section": "26.3 RD-дереводляполнотекстовогопоиска",
    "text": "Глава26. ИндексGiST\nПреимущества такого подхода налицо: индексные записи имеют одинако-\nвыйинебольшойразмер,индексполучаетсякомпактным.Ноестьисущест-\nвенныенедостатки.Во-первых,сканированиетолькоиндексаоказывается\nневозможным, поскольку индекс больше не хранит значения ключей ин-\nдексированияикаждыйвозвращаемыйидентификатордолженперепрове-\nрятьсяпотаблице.Во-вторых,теряетсяточность:индексможетвозвращать\nмноголожных результатов,которые затем отсеиваются при перепроверке.\nРассмотримвсетожеусловиеdoc_tsv@@to_tsquery('стояла').Сигнату-\nрапоисковогозапросавычисляетсятакже,какидлядокумента,ивнашем\nслучае равна 0010000. Функция согласованности1 должна определить все\nдочерние узлы,сигнатура которых содержитустановленные биты сигнату-\nрызапроса:\n00001111111100 11111111001111\n00001111111100 00001111110000 11000011001111 00111100001100\n00001111001100 00001111110000 00000000001111 00111100000000\n00001100111100 00001100110000 11000011001100 00111100000000 00110000001100\nПо сравнению с предыдущим примером здесьперебирается больше узлов\nиз-заложноположительныхсрабатываний.Причинавтом,чтоприбольшом\nколичествелексем некоторые из них неизбежно будутполучать совпадаю-\nщиесигнатурыиз-заихограниченнойразрядности.Вэтомпримеретакими\nлексемами являются «стоя» и «заломат». Это приводит к тому, что одна и\nтажесигнатурасоответствуетразнымдокументам;вданномслучае«люли,\nлюли,стояла»и«люли,люли,заломати»имеютсигнатуру0110000.\n1 backend/utils/adt/tsgistidx.c,функцияgtsvector_consistent.\n568",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:08.507014"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 570,
    "chapter": null,
    "section": "26.3 RD-дереводляполнотекстовогопоиска",
    "text": "26.3. RD-дереводляполнотекстовогопоиска\nЛожноположительные срабатывания снижают эффективность индекса, но\nне ставят под угрозу корректность,поскольку ложноотрицательных сраба-\nтываний втакой схеме бытьне можети нужное значение гарантированно\nнебудетпропущено.\nКонечно, в реальности размер сигнатуры выбирается больше. По умолча-\nнию используются 124 байта (992 бита),так что вероятность коллизий су-\nщественноменьше,чемвпримере.Принеобходимостиможноустановить v.13\nдругой размер сигнатуры вплоть до примерно 2000 байт, используя пара-\nметрклассаоператоров:\nCREATE INDEX ... USING gist(столбец tsvector_ops(siglen = размер));\nКроме того, если значения достаточно малы1 (чуть меньше 1 страницы,\n16\nчтосоставляетоколо500байтдлястандартнойстраницы),классоператоров\ntsvector_ops хранитвлистовых страницах индекса не сигнатуры,а сами\nзначенияtsvector.\nЧтобыпосмотреть,какиндексированиеработаетнареальныхданных,возь-\nмемархиврассылкиpgsql-hackers2.Внемсодержится356125писемсдатой\nотправления,темой,именемавтораитекстом.\nДобавим столбец типа tsvector и построим индекс. Здесь я объединяю\nводинвектортризначения(тему,автораитекстписьма),чтобыпоказать,\nчто документ может формироваться динамически и не обязан храниться\nвкаком-тоодномстолбце.\n=> ALTER TABLE mail_messages ADD COLUMN tsv tsvector\nGENERATED ALWAYS AS ( to_tsvector(\n'pg_catalog.english', subject||' '||author||' '||body_plain\n) ) STORED;\nNOTICE: word is too long to be indexed\nDETAIL: Words longer than 2047 characters are ignored.\n...\nNOTICE: word is too long to be indexed\nDETAIL: Words longer than 2047 characters are ignored.\nALTER TABLE\n1 backend/utils/adt/tsgistidx.c,функцияgtsvector_compress.\n2 edu.postgrespro.ru/mail_messages.sql.gz.\n569",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:08.549598"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 571,
    "chapter": null,
    "section": "26.3 RD-дереводляполнотекстовогопоиска",
    "text": "Глава26. ИндексGiST\n=> CREATE INDEX mail_gist_idx ON mail_messages USING gist(tsv);\n=> SELECT pg_size_pretty(pg_relation_size('mail_gist_idx'));\npg_size_pretty\n−−−−−−−−−−−−−−−−\n128 MB\n(1 row)\nПризаполнениистолбцанекотороеколичествословбылоотброшеноиз-за\nслишкомбольшогоразмера,новитогеиндекспостроениготовподдержи-\nватьпоисковыезапросы:\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT *\nFROM mail_messages\nWHERE tsv @@ to_tsquery('magic & value');\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Scan using mail_gist_idx on mail_messages\n(actual rows=898 loops=1)\nIndex Cond: (tsv @@ to_tsquery('magic & value'::text))\nRows Removed by Index Recheck: 7858\n(4 rows)\nВместе с 898 строками, подходящими под условие, метод доступа вернул\nеще 7859 строк, которые были отсеяны перепроверкой по таблице.Увели-\nчив размерность сигнатуры, можно повысить точность (и, следовательно,\nэффективность),жертвуякомпактностьюиндекса:\n=> DROP INDEX mail_messages_tsv_idx;\n=> CREATE INDEX ON mail_messages\nUSING gist(tsv tsvector_ops(siglen=248));\n=> SELECT pg_size_pretty(pg_relation_size('mail_messages_tsv_idx'));\npg_size_pretty\n−−−−−−−−−−−−−−−−\n140 MB\n(1 row)\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT *\nFROM mail_messages\nWHERE tsv @@ to_tsquery('magic & value');\n570",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:08.589467"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 572,
    "chapter": null,
    "section": "26.4 Другиетипыданных",
    "text": "26.4. Другиетипыданных\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nIndex Scan using mail_messages_tsv_idx on mail_messages\n(actual rows=898 loops=1)\nIndex Cond: (tsv @@ to_tsquery('magic & value'::text))\nRows Removed by Index Recheck: 2059\n(4 rows)\nСвойства\nСвойстваметодадоступаяужепоказывал,ипобольшейчастионисовпада- с.559\nютдлявсехклассовоператоров.Вниманиязаслуживаютдвасвойствауровня\nстолбца:\n=> SELECT p.name,\npg_index_column_has_property('mail_messages_tsv_idx', 1, p.name)\nFROM unnest(array[\n'returnable', 'distance_orderable'\n]) p(name);\nname | pg_index_column_has_property\n−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nreturnable | f\ndistance_orderable | f\n(2 rows)\nИндекс потерял возможность участвовать в сканировании только индек-\nса, поскольку по сигнатуре невозможно восстановить исходное значение.\nВданномслучаевэтомнетничегострашного:значениеtsvector исполь-\nзуетсятолькодляпоиска,аинтересуетнассамдокумент.\nУпорядочивающий оператор для класса tsvector_ops тоже не определен.\n26.4. Другие типы данных\nЯрассмотрелтолькодванаиболеепоказательныхпримера.Онидемонстри-\nруют, что метод GiST, имея в основе сбалансированное дерево, может по-\nразномуприменятьсядляразныхтиповданныхзасчетразнойреализации\n571",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:08.620989"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 573,
    "chapter": null,
    "section": "26.4 Другиетипыданных",
    "text": "Глава26. ИндексGiST\nопорныхфункцийклассаоператоров.ГоворяоGiST-индексе,всегданеобхо-\nдимоуточнятьклассоператоров,посколькуонсущественновлияетнасвой-\nстваихарактеристикииндекса.\nВотещенесколькотиповданных,которыевнастоящеевремяподдерживает\nметоддоступаGiST.\nГеометрическиетипы. Крометочек,GiST-индексможетиспользоватьсяидля\nдругихгеометрическихтипов:прямоугольников,окружностей,полиго-\nнов. Любой из этих типов представляется для целей индексирования\nсвоимограничивающимпрямоугольником.\nРасширениеcubeдобавляетодноименныйтипданныхдляпредставле-\nниямногомерныхкубов,которыеиндексируютсяспомощьюR-дерева.\nВместо ограничивающих прямоугольников в индексе используются\nограничивающиепараллелепипедысоответствующейразмерности.\nДиапазонныетипы. КстандартнымтипамPostgreSQLотносятсячисловыеи\nвременны́е диапазоны, такие как int4range или tstzrange1. Можно\nопределятьисобственныедиапазонныетипыкомандойCREATETYPEAS\nRANGE.\nЛюбые диапазонные типы, как стандартные, так и пользовательские,\nподдерживаются GiST-индексом с помощью одного и того же класса\nоператоровrange_ops2.Дляиндексированияприменяетсяодномерное\nR-дерево: в данном случае ограничивающие прямоугольники превра-\nщаютсявограничивающиеотрезки.\nv.14 Мультидиапазонные типы также поддерживаются; для них использу-\nется класс операторов multirange_ops. Ограничивающий диапазон\nвэтомслучаеохватываетвседиапазоны,входящиевмультидиапазон-\nноезначение.\nРасширениеsegпредоставляетодноименныйтипданныхдляинтерва-\nловсграницами,заданнымисопределеннойточностью.Такойтипне\nотноситсякдиапазонным,нопосутиявляетсяимииндексируетсяточ-\nнотакже.\n1 postgrespro.ru/docs/postgresql/17/rangetypes.\n2 backend/utils/adt/rangetypes_gist.c.\n572",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:08.656250"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 574,
    "chapter": null,
    "section": "26.4 Другиетипыданных",
    "text": "26.4. Другиетипыданных\nПорядковыетипы. Напомню еще раз про расширение btree_gist, предо-\nставляющее классы операторов метода GiST для большого количества\nпорядковыхтиповданных,которыеобычноиндексируютсяспомощью\nB-дерева.Такие классы операторов можно использоватьдля создания\nсоставного индекса, когда тип одного из столбцов не поддерживается\nB-деревом.\nСетевыеадреса. Тип данных inet имеет встроенную GiST-поддержку, реа-\nлизованнуюклассомоператоровinet_ops1.\nЦелочисленныемассивы. Расширениеintarray делаетцелочисленныемас-\nсивы более функциональными и добавляет для них GiST-поддержку.\nИмеются два класса операторов. Для небольших массивов можно ис-\nпользовать gist__int_ops, реализующий RD-дерево с полным пред-\nставлениемключейвиндексныхзаписях.Длябольшихмассивовподой-\nдетболеекомпактное,номенееточноесигнатурноеRD-дерево,реали-\nзуемоеgist__bigint_ops.\n«Лишнее»подчеркиваниевименахклассовоператоровпоявляется,потомучто\nсподчеркиванияначинаютсяназваниямассивовбазовыхтипов.Например,для\nцелочисленного массива наряду с более привычным обозначением int4[]\nможно использоватьтип _int4.Правда,типов _int и _bigint не существует.\nДеревометок. Расширениеltree добавляетодноименныйтипданныхдля\nдревовидных структур с метками. GiST-поддержка реализована с по-\nмощьюсигнатурныхRD-деревьевипредставленаклассамиоператоров\ngist_ltree_opsдлязначенийтипаltreeиgist__ltree_opsдлямас-\nсивовзначенийтакоготипа.\nХранилище«ключ–значение». Расширение hstore предоставляет тип дан-\nных hstore для хранения пар «ключ–значение». Класс операторов\ngist_hstore_opsреализуетиндекснуюподдержкунаосновесигнатур-\nногоRD-дерева.\nТриграммы. Расширениеpg_trgmдобавляетклассgist_trgm_ops,реализу- с.616\nющийиндекснуюподдержкусравнениясхожеститекстовыхстрокипо-\nискапошаблону.\n1 backend/utils/adt/network_gist.c.\n573",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:08.694920"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 575,
    "chapter": null,
    "section": "27.1 Общий принцип",
    "text": "27\nИндекс SP-GiST\n27.1. Общий принцип\nБуквы «SP» в названии SP-GiST расшифровываются как Space Partitioning,\nтоестьразбиениепространства.Подпространствомздесьподразумевается\nпроизвольнаяобластьзначений,вкоторойпроизводитсяпоиск,анеобяза-\nтельнопространствовобыденномпонимании(например,двумернаяплос-\nкость). Ну а «GiST» намекает на определенную схожесть с этим методом:\nи GiST,и SP-GiST являются обобщеннымидеревьями поиска и служаткар-\nкасамидляиндексацииразличныхтиповданных.\nИдеяметодаSP-GiST1состоитвразбиениипространствапоискананепере-\nсекающиесяобласти,каждаяизкоторых,всвоюочередь,такжеможетбыть\nрекурсивноразбитанаподобласти.Такоеразбиениепорождаетнесбаланси-\nрованныедеревья(вотличиеотB-деревьевиметодаGiST)иможетисполь-\nзоватьсядляреализациитакихизвестныхструктур,какдеревьяквадрантов\n(quadtree),k-мерныедеревья(k-Dtree)илипрефиксныедеревья(trie).\nОбычнотакиедеревьяслабоветвятсяи,следовательно,имеютбольшуюглу-\nбину.Например,узелдереваквадрантовимеетнебольшечетырехдочерних\nузлов,аузелk-мерногодерева—толькодва.Этонепроблема,когдадерево\nнаходится в оперативной памяти,но для дискового представления прихо-\nдится решать непростую задачу эффективной упаковки узлов в страницы,\nчтобыминимизироватьоперацииввода-вывода.ДляB-деревьевиGiSTэто\nнетребуется,посколькукаждыйузелдеревазанимаетстраницуполностью.\n1 postgrespro.ru/docs/postgresql/17/spgist;\nbackend/access/spgist/README.\n574",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:08.722620"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 576,
    "chapter": null,
    "section": "27.1 Общийпринцип",
    "text": "27.1. Общийпринцип\nВнутреннийузелдереваSP-GiSTсодержитзначение,соответствующееусло-\nвию,которое выполняется для всех дочерних узлов.Такое значение часто\nназывают префиксом; оно играетту же роль, что предикат в индексе GiST.\nСсылкинадочерниеузлывSP-GiSTмогутиметьметки.\nЭлементылистовыхузловсодержатиндексируемоезначение(илиегочасть)\nиидентификаторсоответствующейверсиистроки.\nКак и GiST, метод доступа SP-GiST реализуеттолько основные алгоритмы\nи берет на себя заботу о таких низкоуровневых задачах, как организация\nконкурентногодоступа,блокирование и журналирование.Длядобавления\nновыхтиповданныхиалгоритмовразбиенияпространстванаобластиэтот\nметод предоставляет интерфейс класса операторов. Класс операторов со-\nдержит значительную часть логики и определяет многие аспекты работы\nиндекса.\nПоиск1вдеревеSP-GiSTначинаетсяскорневогоузлаипроизводитсявглу-\nбину.Узлы,вкоторыеимеетсмыслзаходить,выбираютсяспомощьюопор-\nной функции согласованности, похожей на аналогичную функцию в GiST.\nДлявнутреннегоузладереваэтафункциявозвращаетнабордочернихузлов,\nзначениякоторых«согласуются»споисковымпредикатом.Функциявыби-\nраетузлы,неспускаясьвних,аориентируясьназначенияпрефиксаиметок.\nДля листового узла функция определяет, удовлетворяет ли индексирован-\nноезначениевэтомузлепоисковомупредикату.\nВремяпоисказначенийвнесбалансированномдеревеможетотличатьсяиз-\nзаразнойглубиныветвей.\nДлявставкизначениявдеревоSP-GiSTиспользуютсядвеопорныефункции.\nВузлахдерева,начинаяскорня,функциявыборапринимаетодноизвозмож-\nных решений: отправить новое значение в существующий дочерний узел,\nсоздать для него новый дочерний узел или (если значение не согласуется\nспрефиксомузла)расщепитьтекущийузел.Ввыбраннойвитогелистовой\nстраницеиндексаможетнеоказатьсядостаточноместа,итогдафункциярас-\nщеплениярешает,какиеузлыперенестивновуюстраницу.\nДальшеярассмотрюэтиалгоритмынаконкретныхпримерах.\n1 backend/access/spgist/spgscan.c,функцияspgWalk.\n575",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:08.760579"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 577,
    "chapter": null,
    "section": "27.2 Дерево квадрантов для точек",
    "text": "Глава27. ИндексSP-GiST\n27.2. Дерево квадрантов для точек\nДерево квадрантов (quadtree) используется для индексирования точек на\nплоскости.Областьрекурсивноразбиваетсяначетыречасти(квадранта)по\nотношениюквыбраннойточке.Этаточканазываетсяцентроидомислужит\nпрефиксомузла,тоестьусловием,определяющимположениедочернихзна-\nчений.\nКорневойузелделитплоскостьначетыреквадранта.\nЗатемкаждыйизнихделитсянасобственныеквадранты.\n576",
    "tables": [
      {
        "table_index": 0,
        "rows": 2,
        "cols": 2,
        "content": "| \n |"
      },
      {
        "table_index": 1,
        "rows": 4,
        "cols": 6,
        "content": "|  |  |  |  | \n |  |  |  |  | \n |  |  |  |  | \n |  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T16:00:11.106726"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 578,
    "chapter": null,
    "section": "27.2 Деревоквадрантовдляточек",
    "text": "27.2. Деревоквадрантовдляточек\nПроцедурапродолжается,поканебудетполученоитоговоеразбиение.\nВэтомпримереиспользованиндекс,построенныйнарасширеннойтабли-\nце аэропортов. На рисунках видно, что глубина ветвей дерева отличается с.543\nв зависимости от плотноститочек в соответствующих квадрантах.Для на-\nглядности я взял небольшое значение параметра хранения fillfactor,чтобы 80\nдеревоимелобольшеуровней:\n=> CREATE INDEX airports_quad_idx ON airports_big\nUSING spgist(coordinates) WITH (fillfactor = 10);\nПоумолчаниюдляточекиспользуетсяклассоператоровquad_point_ops.\nКласс операторов\nЯ уже называл основные опорные функции SP-GiST: функцию согласован-\nностидляпоискаифункциивыбораирасщеплениядлявставки.\nНижеприведенсписокопорныхфункций1,которыереализуетклассопера-\nторовquad_point_ops2.Всеониявляютсяобязательными.\n1 postgrespro.ru/docs/postgresql/17/spgist-extensibility.\n2 backend/access/spgist/spgquadtreeproc.c.\n577",
    "tables": [
      {
        "table_index": 0,
        "rows": 13,
        "cols": 23,
        "content": "|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T16:00:12.163307"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 579,
    "chapter": null,
    "section": "27.2 Деревоквадрантовдляточек",
    "text": "Глава27. ИндексSP-GiST\n=> SELECT amprocnum, amproc::regproc\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid\nJOIN pg_amproc amop ON amprocfamily = opcfamily\nWHERE amname = 'spgist'\nAND opcname = 'quad_point_ops'\nORDER BY amprocnum;\namprocnum | amproc\n−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−\n1 | spg_quad_config\n2 | spg_quad_choose\n3 | spg_quad_picksplit\n4 | spg_quad_inner_consistent\n5 | spg_quad_leaf_consistent\n(5 rows)\nФункцииимеютследующийсмысл:\n1) настроечнаяфункция,котораясообщаетметодудоступахарактеристи-\nкиклассаоператоров;\n2) функциявыбораузладлявставкизначения;\n3) функцияраспределенияузловприрасщеплении;\n4) функциявнутреннейсогласованности,котораяопределяет,согласуется\nлизначениевовнутреннемузлеспоисковымпредикатом;\n5) функциялистовойсогласованности,определяющая,согласуетсялиспо-\nисковымпредикатомзначениевлистовомузле.\nКромеперечисленных,естьинескольконеобязательныхфункций.\nс.547 Классоператоровquad_point_opsподдерживаетстратегии,общиесGiST1:\n=> SELECT amopopr::regoperator, oprcode::regproc, amopstrategy\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid\nJOIN pg_amop amop ON amopfamily = opcfamily\nJOIN pg_operator opr ON opr.oid = amopopr\nWHERE amname = 'spgist'\nAND opcname = 'quad_point_ops'\nORDER BY amopstrategy;\n1 include/access/stratnum.h.\n578",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:12.197388"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 580,
    "chapter": null,
    "section": "27.2 Деревоквадрантовдляточек",
    "text": "27.2. Деревоквадрантовдляточек\namopopr | oprcode | amopstrategy\n−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−\n<<(point,point) | point_left | 1\n>>(point,point) | point_right | 5\n~=(point,point) | point_eq | 6\n<@(point,box) | on_pb | 8\n<<|(point,point) | point_below | 10\n|>>(point,point) | point_above | 11\n<−>(point,point) | point_distance | 15\n<^(point,point) | point_below | 29\n>^(point,point) | point_above | 30\n(9 rows)\nНапример,с помощью оператора «выше» >^ можно найти аэропорты,рас-\nположенныесевернееДиксона:\n=> SELECT airport_code, airport_name->>'en'\nFROM airports_big\nWHERE coordinates >^ '(80.3817,73.5167)'::point;\nairport_code | ?column?\n−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nTHU | Thule Air Base\nYEU | Eureka Airport\nYLT | Alert Airport\nYRB | Resolute Bay Airport\nLYR | Svalbard Airport, Longyear\nNAQ | Qaanaaq Airport\nYGZ | Grise Fiord Airport\nDKS | Dikson Airport\n(8 rows)\n=> EXPLAIN (costs off) SELECT airport_code\nFROM airports_big\nWHERE coordinates >^ '(80.3817,73.5167)'::point;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on airports_big\nRecheck Cond: (coordinates >^ '(80.3817,73.5167)'::point)\n−> Bitmap Index Scan on airports_quad_idx\nIndex Cond: (coordinates >^ '(80.3817,73.5167)'::point)\n(4 rows)\nРассмотрим теперь подробнее устройство и функционирование дерева\nквадрантовнапростомпримереснесколькимиточками,которыйнамуже\nвстречалсявглавепроGiST. с.548\n579",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:12.231882"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 581,
    "chapter": null,
    "section": "27.2 Деревоквадрантовдляточек",
    "text": "Глава27. ИндексSP-GiST\nВоткакможетвыглядетьразбиениеплоскостивэтомслучае:\n9 9\n8 8\n7 4 1 7\n6 6\n5 5\n4 4\n3 3\n3 2\n2 2\n1 1\n0 0\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\nЛевыйрисунокпоказываетнумерациюквадрантовнапримереодногоуров-\nня дерева; на следующих иллюстрациях я для определенности буду распо-\nлагать дочерние узлы слева направо именно в такой последовательности.\nТочки,лежащие на границах, относятся к квадранту с меньшим номером.\nНаправомрисункепоказаноокончательноеразбиение.\nНижеприведенавозможнаяструктураиндексадляэтогопримера.Каждый\nвнутренний узел ссылается максимум на четыре дочерних узла, и каждая\nссылкапомеченаномеромквадранта:\n5,5\n1 3\n2\n7,7 5,3 3,2\n1 3 1 4\n2 2 3\n8,9 8,5 6,6 3,3 3,1 0,0 0,4\n9,7 1,2\n580",
    "tables": [
      {
        "table_index": 0,
        "rows": 9,
        "cols": 9,
        "content": "|  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  | 4 |  |  |  | 1 |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  | 3 |  |  |  | 2 |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |"
      },
      {
        "table_index": 1,
        "rows": 9,
        "cols": 9,
        "content": "|  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T16:00:12.289958"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 582,
    "chapter": null,
    "section": "27.2 Деревоквадрантовдляточек",
    "text": "27.2. Деревоквадрантовдляточек\nСтраничная организация\nМежду узлами дерева SP-GiST и страницами нет однозначного соответ-\nствия,котороехарактернодляB-деревьевиGiST-индексов.Из-затого,что\nвнутренниеузлыобычноимеютнеоченьмногодочерних,воднустраницу\nприходится упаковывать несколько узлов.Внутренние узлы при этом хра-\nнятсянаодних(внутренних)страницах,алистовые—надругих(листовых).\nИндексные записи внутренних страниц содержат значение, используемое\nкак префикс,и набор ссылок на дочерние узлы,каждая из которых может\nсопровождатьсяметкой.\nЗаписилистовыхстраницсостоятиззначенияиидентификаторатабличной\nверсиистроки.\nВселистовыеузлы,относящиесякодномуитомужевнутреннему,хранят-\nсяводнойстраницеисвязанывсписок.Есливстраниценехватаетместа,\nсписок может быть перемещен на другую страницу1 или может произой-\nти расщепление,но влюбом случае список никогда не разрывается между\nнесколькимистраницами.\nЧтобыэкономнорасходоватьместо,алгоритмстараетсярасполагатьновые\nузлы в одних и тех же страницах, пока те не заполнятся. Номера послед-\nних использованных страниц кешируются обслуживающими процессами,\nа также периодически сохраняются в метастранице с нулевым номером.\nМетастраницане ссылаетсяна корневойузел,как этопроисходитвслучае\nB-дерева;кореньSP-GiSTвсегданаходитсявпервойстранице.\nКсожалению,вpageinspectнетфункцийдляисследованияиндексаSP-GiST,новме-\nстонегоможновоспользоватьсястороннимрасширениемgevel2.Попыткаперенести\nегофункциональностьвpageinspectпредпринималась,нонеувенчаласьуспехом3.\nВариантраспределенияузловдеревапостраницамдлянашегопримерапо-\nказаннарисункениже.Насамомделеклассоператоровquad_point_opsне\n1 backend/access/spgist/spgdoinsert.c,функцияmoveLeafs.\n2 sigaev.ru/git/gitweb.cgi?p=gevel.git.\n3 commitfest.postgresql.org/15/1207.\n581",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:12.964144"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 583,
    "chapter": null,
    "section": "27.2 Деревоквадрантовдляточек",
    "text": "Глава27. ИндексSP-GiST\nиспользует метки.Поскольку дочерних узлов не может быть больше четы-\nрех,хранится массив фиксированного размера из четырех ссылок,некото-\nрыеизкоторыхмогутбытьпустыми.\nкорневая 55,,55\ncтраница\nвнутренние 77,,77 33,,22\nстраницы\nлистовые\n88,,99 99,,77 88,,55 66,,66 55,,33 33,,33 33,,11 00,,00 11,,22 00,,44\nстраницы\nПоиск\nРассмотрим на этом же примере алгоритм поиска точек, расположенных\nвышеточки(3,7).\n9\n8\n7\n6\n5\n4\n3\n2\n1\n0\n0 1 2 3 4 5 6 7 8 9\n582",
    "tables": [
      {
        "table_index": 0,
        "rows": 9,
        "cols": 9,
        "content": "|  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T16:00:13.014421"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 584,
    "chapter": null,
    "section": "27.2 Деревоквадрантовдляточек",
    "text": "27.2. Деревоквадрантовдляточек\nПоискначинаетсяскорневогоузла.Функциявнутреннейсогласованности1\nпоказывает,вкакиедочерниеузлынадоспускаться.Точка(3,7)сравнивает-\nся с центроидом корневого узла (5,5),и выбираются квадранты,в которых\nмогут находиться искомые точки — в данном случае первый и четвертый.\nВузлесцентроидом(7,7)сновавыбираютсядочерниеузлыдляспуска.Под-\nходят первый и четвертый квардранты, но четвертый пуст, так что необ-\nходимо проверить один листовой дочерний узел. Его точки сравниваются\nс точкой (3,7) из запроса с помощью функции листовой согласованности2.\nИзнихтолько(8,9)удовлетворяетусловию«выше».\nОстается вернуться на уровень выше и проверить узел, соответствующий\nчетвертому квадранту корневого узла.Он пуст,и на этом поиск завершен.\n5,5\n1 3\n2\n7,7 5,3 3,2\n1 3 1 4\n2 2 3\n8,9 8,5 6,6 3,3 3,1 0,0 0,4\n9,7 1,2\nВставка\nПривставкезначениявдеревоSP-GiST3 каждоеследующеедействиеопре-\nделяетсяфункциейвыбора4.Вданномслучаеонапростонаправляетновую\nточкувтотизсуществующихквадрантов,ккоторомуонапринадлежит.\n1 backend/access/spgist/spgquadtreeproc.c,функцияspg_quad_inner_consistent.\n2 backend/access/spgist/spgquadtreeproc.c,функцияspg_quad_leaf_consistent.\n3 backend/access/spgist/spgdoinsert.c,функцияspgdoinsert.\n4 backend/access/spgist/spgquadtreeproc.c,функцияspg_quad_choose.\n583",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:13.053748"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 585,
    "chapter": null,
    "section": "27.2 Деревоквадрантовдляточек",
    "text": "Глава27. ИндексSP-GiST\nНапример,добавимзначение(7,1):\n9\n8\n7\n6\n5\n4\n3\n2\n1\n0\n0 1 2 3 4 5 6 7 8 9\nЗначениепринадлежитвторомуквадрантуибудетдобавленоксоответству-\nющемуузлудерева:\n5,5\n1 3\n2\n7,7 5,3 3,2\n7,1\n1 3 1 4\n2 2 3\n8,9 8,5 6,6 3,3 3,1 0,0 0,4\n9,7 1,2\nЕсли значение попадает в квадрант, список листовых узлов которого ока-\nзываетсяслишкомвелик(ондолженпомещатьсяводнойстранице),проис-\nходит расщепление. Функция расщепления1 определяет новый центроид,\nвычисляясреднеезначениекоординатвсехточек,итакимобразомраспре-\nделяетдочерние узлы по новым квадрантам более или менее равномерно.\n1 backend/access/spgist/spgquadtreeproc.c,функцияspg_quad_picksplit.\n584",
    "tables": [
      {
        "table_index": 0,
        "rows": 10,
        "cols": 10,
        "content": "|  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T16:00:13.094385"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 586,
    "chapter": null,
    "section": "27.2 Деревоквадрантовдляточек",
    "text": "27.2. Деревоквадрантовдляточек\nВ примере на рисунке ниже добавлениеточки (2,1) приводитк переполне-\nниюузла:\n9 9\n8 8\n7 7\n6 6\n5 5\n4 4\n3 3\n2 2\n1 1\n0 0\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\nВ дерево добавляется новый внутренний узел с центроидом (1,1), а точки\n(0,0),(1,2)и(2,1)распределяютсямеждуновымиквадрантами:\n5,5\n1 3\n2\n7,7 5,3 3,2\n7,1\n1 3 1 4\n2 2 3\n8,9 8,5 6,6 3,3 3,1 1,1 0,4\n9,7\n1 3\n1,2 0,0\n2,1\n585",
    "tables": [
      {
        "table_index": 0,
        "rows": 10,
        "cols": 10,
        "content": "|  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |"
      },
      {
        "table_index": 1,
        "rows": 11,
        "cols": 10,
        "content": "|  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T16:00:13.148309"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 587,
    "chapter": null,
    "section": "27.2 Деревоквадрантовдляточек",
    "text": "Глава27. ИндексSP-GiST\nСвойства\nСвойстваметодадоступа. Методspgistсообщаетосебеследующее:\n=> SELECT a.amname, p.name, pg_indexam_has_property(a.oid, p.name)\nFROM pg_am a, unnest(array[\n'can_order', 'can_unique', 'can_multi_col',\n'can_exclude', 'can_include'\n]) p(name)\nWHERE a.amname = 'spgist';\namname | name | pg_indexam_has_property\n−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−\nspgist | can_order | f\nspgist | can_unique | f\nspgist | can_multi_col | f\nspgist | can_exclude | t\nspgist | can_include | t\n(5 rows)\nПоддержкасортировкизначенийиуникальностиотсутствует.Неподдержи-\nваютсяимногоколоночныеиндексы.\nОграниченияисключенияподдерживаются,какивслучаеGiST.\nv.14 ИндексSP-GiSTможносоздаватьсдополнительнымиinclude-столбцами.\nСвойства индекса. Свойства индекса SP-GiST отличаются от свойств GiST\nтем,чтонедопускаетсякластеризация:\n=> SELECT p.name, pg_index_has_property('airports_quad_idx', p.name)\nFROM unnest(array[\n'clusterable', 'index_scan', 'bitmap_scan', 'backward_scan'\n]) p(name);\nname | pg_index_has_property\n−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−\nclusterable | f\nindex_scan | t\nbitmap_scan | t\nbackward_scan | f\n(4 rows)\nОбаспособаполученияидентификаторовверсий(поодномуибитовойкар-\nтой)поддерживаются.ОбратноесканированиеSP-GiSTнеимеетсмысла.\n586",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:13.180069"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 588,
    "chapter": null,
    "section": "27.2 Деревоквадрантовдляточек",
    "text": "27.2. Деревоквадрантовдляточек\nСвойствастолбцов. Основнаячастьсвойствстолбцовнеизменна:\n=> SELECT p.name,\npg_index_column_has_property('airports_quad_idx', 1, p.name)\nFROM unnest(array[\n'orderable', 'search_array', 'search_nulls'\n]) p(name);\nname | pg_index_column_has_property\n−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\norderable | f\nsearch_array | f\nsearch_nulls | t\n(3 rows)\nСортировканеподдерживается,ивсесвойства,связанныесней,неимеют\nсмыслаиотключены.\nДосихпоряничегонеговорилпронеопределенныезначения,но,каквидно\nизсвойствиндекса,ониподдерживаются.ВотличиеотGiSTиндексSP-GiST\nне хранит неопределенные значения в основном дереве.Для них создает-\nсяотдельноедеревоскорнемнавторойстраницеиндекса.Такимобразом,\nпервыетри страницы всегда имеютфиксированный смысл: метастраница,\nкореньосновногодереваикореньдереванеопределенныхзначений.\nЧастьсвойствуровнястолбцаможетменятьсявзависимостиотклассаопе-\nраторов:\n=> SELECT p.name,\npg_index_column_has_property('airports_quad_idx', 1, p.name)\nFROM unnest(array[\n'returnable', 'distance_orderable'\n]) p(name);\nname | pg_index_column_has_property\n−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nreturnable | t\ndistance_orderable | t\n(2 rows)\nВданномслучае(какивовсехостальныхпримерахэтойглавы)индексмо-\nжетиспользоватьсядлясканированиятолькоиндекса.\nНо в общем случае класс операторов может не хранить полное значение v.11\nв листовых страницах, выполняя вместо этого перепроверку по таблице.\n587",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:13.212939"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 589,
    "chapter": null,
    "section": "27.3 K-мерные деревья для точек",
    "text": "Глава27. ИндексSP-GiST\nЭто,например,позволяетиспользоватьиндексы SP-GiST в PostGISдля по-\nтенциальнобольшихзначенийтипаgeometry.\nv.12 Поискближайшихсоседейподдерживается;вклассеоператоровмывидели\nупорядочивающийоператор<->.\n27.3. K-мерные деревья для точек\nДляточекнаплоскостиможнопредложитьидругойспособразбиенияпро-\nстранства:делитьплоскостьненачетыречасти,анадве.Такоеразбиение\nиспользуетклассоператоровkd_point_ops1:\n=> CREATE INDEX airports_kd_idx ON airports_big\nUSING spgist(coordinates kd_point_ops);\nОбратитевнимание,чтоиндексируемыезначения,префиксыиметкимогут\nиметьразличныетипыданных.Дляэтогоклассаоператоровзначенияявля-\nютсяточками,префиксы—вещественными числами,а метки отсутствуют\n(какивquad_point_ops).\nВыберемкакую-нибудькоординатунаосиординат(впримересаэропорта-\nми—широту).Онаподелитплоскостьнадвечасти,верхнююинижнюю:\n1 backend/access/spgist/spgkdtreeproc.c.\n588",
    "tables": [
      {
        "table_index": 0,
        "rows": 2,
        "cols": 1,
        "content": ""
      }
    ],
    "extracted_at": "2025-10-02T16:00:14.256715"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 590,
    "chapter": null,
    "section": "27.3 K-мерныедеревьядляточек",
    "text": "27.3. K-мерныедеревьядляточек\nДлякаждойиздвухобластейвыберемкоординатынаосиабсцисс(долготу),\nкоторыеподелятобластинадвечасти,левуюиправую:\nБудемпродолжатьделитькаждуюизчастейпопеременнотопогоризонта-\nли,топовертикали,покавкаждойизнихнеостанетсястолькоточек,чтобы\nонипомещалисьнаоднустраницуиндекса:\nУвсех внутренних узловдерева,построенноготаким образом,будетвсего\nдвадочернихузла.Методлегкообобщаетсянаслучайпространствапроиз-\nвольной размерности, поэтому и деревья называются в литературе k-мер-\nными(k-Dtree).\n589",
    "tables": [
      {
        "table_index": 0,
        "rows": 2,
        "cols": 3,
        "content": "|  | \n |  |"
      },
      {
        "table_index": 1,
        "rows": 14,
        "cols": 20,
        "content": "|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | \n |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |"
      }
    ],
    "extracted_at": "2025-10-02T16:00:16.318417"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 591,
    "chapter": null,
    "section": "27.4 Префиксное дерево для строк",
    "text": "Глава27. ИндексSP-GiST\n27.4. Префиксное дерево для строк\nКлассоператоровtext_ops1дляSP-GiSTреализуетпрефиксноедерево(ra-\ndixtree)длястрок.Здесьпрефиксвнутреннегоузладействительноявляется\nпрефиксом,общимдлявсехстроквдочернихузлах.\nСсылкинадочерниеузлыдеревапомеченыпервымбайтомзначений,сле-\nдующихзапрефиксом.\nНарисункеядляясностипоказываюпрефикскакодинсимвол,ноэтовернотолько\nдля восьмибитных кодировок.В общем случае класс операторов работает со стро-\nкой как с последовательностью байтов.Кроме того,префикс можетприниматьеще\nнесколькозначений,имеющихспециальныйсмысл,такчтофактическиподпрефикс\nвыделенодвабайта.\nВдочернихузлаххранятсятечастизначений,которыеследуютзапрефик-\nсомиметкой.Надолюлистовыхузловостаютсятолькоокончания.\nВотпримерпрефиксногодерева,построенногопонесколькимименам:\nV\nA L\nADI\nD S M S\nL\nIM E ILISA IR LAV\nN R\nTIN IY\nTINA\n1 backend/access/spgist/spgtextproc.c.\n590",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:16.347735"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 592,
    "chapter": null,
    "section": "27.4 Префиксноедереводлястрок",
    "text": "27.4. Префиксноедереводлястрок\nПолное значение ключа индексирования влистовом узле можно восстано-\nвитьконкатенациейвсехпрефиксовиметок,следуяоткорнядеревакэтому\nузлу.За счеттого,что значения не хранятся целиком,а реконструируются\nпо мере необходимости,представление в виде префиксногодерева может\nиногдаоказатьсясущественнокомпактнееB-дерева.\nКласс операторов\nКласс операторов text_ops поддерживаетоператоры сравнения,традици-\nонныедляпорядковоготипа,которымявляетсятекстоваястрока:\n=> SELECT oprname, oprcode::regproc, amopstrategy\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid\nJOIN pg_amop amop ON amopfamily = opcfamily\nJOIN pg_operator opr ON opr.oid = amopopr\nWHERE amname = 'spgist'\nAND opcname = 'text_ops'\nORDER BY amopstrategy;\noprname | oprcode | amopstrategy\n−−−−−−−−−+−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−\n~<~ | text_pattern_lt | 1\n~<=~ | text_pattern_le | 2\n= | texteq | 3\n~>=~ | text_pattern_ge | 4\n~>~ | text_pattern_gt | 5\n< | text_lt | 11\n<= | text_le | 12\n>= | text_ge | 14\n> | text_gt | 15\n^@ | starts_with | 28\n(10 rows)\nОператорыстильдамиотличаютсяотобычныхтем,чтоработаютнессим-\nволами, а с байтами. Они не учитывают правила сортировки (аналогично\nклассу операторов text_pattern_ops для B-дерева). При использовании с.386\nв запросе обычных операторов >= и < в сочетании с правилом сортиров-\nки,отличнымот«C»,индекспрактическибесполезен,посколькуимеетдело\nсбайтами,анессимволами.\n591",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:16.378911"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 593,
    "chapter": null,
    "section": "27.4 Префиксноедереводлястрок",
    "text": "Глава27. ИндексSP-GiST\nv.11 ДляускоренияпоискапоусловиюLIKEклассоператоровподдерживаетопе-\nраторпрефиксногопоиска^@:\n=> CREATE INDEX tickets_spgist_idx ON tickets\nUSING spgist(passenger_name);\n=> EXPLAIN (costs off) SELECT *\nFROM tickets\nWHERE passenger_name LIKE 'IVAN%';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on tickets\nFilter: (passenger_name ~~ 'IVAN%'::text)\n−> Bitmap Index Scan on tickets_spgist_idx\nIndex Cond: (passenger_name ^@ 'IVAN'::text)\n(4 rows)\nПоиск\nРассмотримнапримересименамивыполнениеследующегозапроса:\nSELECT * FROM names\nWHERE name ~>=~ 'VALERIY' AND name ~<~ 'VLADISLAV';\nСначалафункциявнутреннейсогласованности1вызываетсявкорнедерева,\nионадолжнаопределить,вкакиедочерниеузлыспускаться.Функциякон-\nкатенируетпрефикс V и метки A и L.ЗначениеVAподставляется в условие\nзапроса,вкоторомстроковыеконстантыобрезаютсятак,чтобыихдлинане\nпревышала длины проверяемого значения:VA~>=~ 'VA' AND VA~<~ 'VL'.\nУсловие выполняется,так что дочерний узел с меткой A должен быть про-\nверен.АналогичнопроверяетсяизначениеVL.Онотожеподходит,поэтому\nиузелсметкойLтребуетпроверки.\nВозьмем теперь узел, соответствующий значению VA. Его префикс пуст,\nидлятрехдочернихузловфункциявнутреннейсогласованностивосстанав-\nливаетзначенияVAD,VALиVAS,конкатенируяполученноенапредыдущем\nшагеVAсметкой.УсловиеVAD~>=~'VAL'ANDVAD~<~'VER'невыполняет-\nся,нодвадругихзначенияподходят.\n1 backend/access/spgist/spgtextproc.c,функцияspg_text_inner_consistent.\n592",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:16.415359"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 594,
    "chapter": null,
    "section": "27.4 Префиксноедереводлястрок",
    "text": "27.4. Префиксноедереводлястрок\nОбходятакимобразомдеревовглубьиотбрасываянеподходящиеветви,ал-\nгоритмдобираетсядолистовыхузлов.Функциялистовойсогласованности1\nпроверяет,соответствуетли восстановленное по мере спуска значение ис-\nходному условию.Подходящие значения возвращаются в качестве резуль-\nтатаиндексногосканирования.\nV\nA L\nADI\nD S M S\nL\nIM E ILISA IR LAV\nN R\nTIN IY\nTINA\nОбратитевнимание,что,хотявзапросеиспользуютсяоператоры«больше»\nи «меньше»,обычные для B-деревьев,поиск диапазона по дереву SP-GiST\nгораздоменееэффективен.ВслучаеB-деревадостаточноспуститьсятолько\nкодномукрайнемузначениюдиапазонаизатемпрочитатьцепочкулисто-\nвыхстраниц.\nВставка\nФункциявыбораклассовоператоровдляточеквсегдаможетнаправитьно-\nвое значение в одну из существующих подобластей (квадрантили полови-\nну).Впрефиксномдеревеэтонетак:новоезначениеможетнесоответство-\nватьимеющемусяпрефиксу,итогдавнутреннийузелприходитсяразделять.\n1 backend/access/spgist/spgtextproc.c,функцияspg_text_leaf_consistent.\n593",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:16.447095"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 595,
    "chapter": null,
    "section": "27.4 Префиксноедереводлястрок",
    "text": "Глава27. ИндексSP-GiST\nВкачествепримерарассмотримдобавлениеимениVLADAкужеимеющему-\nсядереву.\nОткорнядереваспомощьюфункциивыбора1можноуспешноспуститьсяна\nодинузел(V+L),ноостатокзначенияADA несогласуетсяспрефиксомADI.\nУзел необходимо разделить на два: в одном оставить наибольший общий\nпрефикс,тоестьAD,аостатокпрефиксаперенестинауровеньниже:\nV\nL\nADI\nM S\nV\nIR LAV\nL\nAD\nI\nM S\nIR LAV\nПослеэтогофункциявыборавызываетсявтомжеузлеещераз.Префиксте-\nперьсоответствуетзначению,нонетдочернегоузласподходящейметкой\n(A),ифункцияпринимаетрешениесоздатьтакойузел.Конечныйрезультат\nпоказан на рисунке ниже; на нем выделены узлы,добавленные или изме-\nненныевходевставки.\n1 backend/access/spgist/spgtextproc.c,функцияspg_text_choose.\n594",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:16.472590"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 596,
    "chapter": null,
    "section": "27.4 Префиксноедереводлястрок",
    "text": "27.4. Префиксноедереводлястрок\nV\nA L\nAD\nD S A I\nL\nIM E ILISA\nN R M S\nTIN IY IR LAV\nTINA\nСвойства\nСвойствауровняметодадоступаииндексаяужепоказывалвыше,ионине\nменяютсяотклассакклассу.Большинствосвойствуровнястолбцатакжепо-\nстоянны.\n=> SELECT p.name,\npg_index_column_has_property('tickets_spgist_idx', 1, p.name)\nFROM unnest(array[\n'returnable', 'distance_orderable'\n]) p(name);\nname | pg_index_column_has_property\n−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nreturnable | t\ndistance_orderable | f\n(2 rows)\nХотяиндексируемыезначенияинехранятсявявномвидевдереве,скани-\nрование только индекса работает, поскольку значения восстанавливаются\nпомереспускаоткорнядолистовыхузлов.\n595",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:16.502070"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 597,
    "chapter": null,
    "section": "27.4 Префиксноедереводлястрок",
    "text": "Глава27. ИндексSP-GiST\nАвотоператоррасстояниядлястрокнеопределен,ипоискближайшихсо-\nседейнеподдерживаетсяэтимклассомоператоров.\nЭтонезначит,чтодлястрокнельзяввестипонятиерасстояния.Например,расширение\npg_trgmдобавляетоператордлярасстояниянаосноветриграмм:считается,чточем\nменьшедоляобщихтриграммудвухстрок,темдальшеонинаходятсядруготдруга.\nДругойвариант—расстояниеЛевенштейна,котороеопределяетсякакминимальное\nколичествоодносимвольныхопераций,преобразующиходнустрокувдругую.Функ-\nциядлярасчетатакогорасстоянияестьврасширенииfuzzystrmatch.Нониодно\nизрасширенийнепредоставляетклассоператоровсподдержкойSP-GiST.\n27.5. Другие типы данных\nПомимо рассмотренных примеров индексирования точек и текстовых\nстрок,реализованыидругиеклассыоператоровдляSP-GiST.\nГеометрическиетипы. Класс операторов box_ops1 реализует дерево квад-\nрантов для прямоугольников. Прямоугольники представляются точка-\nми в четырехмерном пространстве, так что область разбивается на\nшестнадцатьчастей.\nv.11 Класс операторов poly_ops позволяет индексировать полигоны. Это\nнеточный класс операторов: фактически вместо полигонов использу-\nются ограничивающие прямоугольники, как в box_ops, с перепровер-\nкойпотаблице.\nКакой из методов доступа предпочесть—GiST или SP-GiST,—сущест-\nвенно зависит от вида индексируемых данных.Например,документа-\nцияPostGISрекомендуетSP-GiSTдлясильнопересекающихсяобъектов\n(«лапши»)2.\nДиапазонныетипы. Деревоквадрантовдлядиапазоновпредоставляеткласс\nоператоров range_ops3. Интервал представляется двумерной точкой:\nнижняяграницастановитсяабсциссой,аверхняя—ординатой.\n1 backend/utils/adt/geo_spgist.c.\n2 postgis.net/docs/using_postgis_dbmanagement.html#spgist_indexes.\n3 backend/utils/adt/rangetypes_spgist.c.\n596",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:16.535487"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 598,
    "chapter": null,
    "section": "27.5 Другиетипыданных",
    "text": "27.5. Другиетипыданных\nСетевыеадреса. Длятипаданных inet класс операторов inet_ops1 реали-\nзуетпрефиксноедерево.\n1 backend/utils/adt/network_spgist.c.\n597",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:16.539980"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 599,
    "chapter": null,
    "section": "28.1 Общий принцип",
    "text": "28\nИндекс GIN\n28.1. Общий принцип\nПозадумкеавторов,GIN—неамериканскийспиртнойнапиток,амогущест-\nвенный и неустрашимыйдух1.Но естьи формальная расшифровка: Gener-\nalizedInvertedIndex,обобщенныйобратный(инвертированный)индекс.\nЭтотметоддоступаработаетстипамиданных,значениякоторыхсостоятиз\nэлементов,а не являются атомарными (так,например,в контексте полно-\nтекстовогопоискадокументысостоятизлексем).Приэтоминдексируются\nне сами значения,как мы видели в случае GiST,а только их элементы; от\nкаждогоэлементапоиндексуможноперейтиковсемзначениям,вкоторых\nэтотэлементвстречается.\nХорошая аналогиядля этого метода—предметный указательв концекни-\nги.Вуказателесобранывсеважныетермины,идлякаждогоприведенспи-\nсокстраниц,накоторыхэтоттерминупоминается.Чтобыуказателембыло\nудобнопользоваться,онсоставляетсяпоалфавиту,иначевнемневозможно\nбылобыбыстроориентироваться.ТакиGINполагаетсянато,чтоэлементы\nсоставныхзначенийможноупорядочить,ивкачествеосновнойструктуры\nс.513 данныхиспользуетB-дерево.\nРеализациядереваэлементовGINвомногомболеепроста,чем«настоящее»\nB-дерево,ноизначальнорассчитананато,чторазныезначениябудутсосто-\nятьиз относительно небольшого набора многократно повторяющихся эле-\nментов.\n1 postgrespro.ru/docs/postgresql/17/gin;\nbackend/access/gin/README.\n598",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:16.564367"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 600,
    "chapter": null,
    "section": "28.2 Индексдляполнотекстовогопоиска",
    "text": "28.2. Индексдляполнотекстовогопоиска\nИзэтогопредположенияследуютдваважныхвывода:\n• Элементывиндексеследуетхранитьвединственномэкземпляре.\nСкаждымэлементомсвязансписокидентификаторовверсий.Еслита-\nкойсписок(postinglist)неслишкомвелик,тоонхранитсявместесэле-\nментом,ноприувеличенииможетбытьвынесенвотдельноеB-дерево\n(postingtree).Упорядоченынетолькодеревья,ноиспискиидентифика-\nторов;этонеимеетзначениядляпользователя,нопозволяетускорить\nдоступиуменьшитьобъем.\n• Нетсмыслаудалятьэлементыиздерева.\nЕслинаборидентификаторовэлементаоказалсяпустым,сбольшойве-\nроятностьютотжеэлементпоявитсясновавсоставедругогозначения.\nТаким образом,индекс состоит из дерева элементов,к листовым записям\nкоторогопривязанылибоплоскиесписки,либодеревьяидентификаторов.\nКак и рассмотренные ранее методы доступа GiST и SP-GiST, GIN позволя-\nет индексировать самые разные типы данных, предоставляя упрощенный\nинтерфейс класса операторов.Обычно операторы этого класса проверяют,\nудовлетворяетлипроиндексированноесоставноезначениенекоторомуна-\nборуэлементов(как,например,вслучаеполнотекстовогопоискаоператор\n@@проверяетсоответствиедокументазапросу).\nДля работы с конкретными типами данных метод GIN должен уметь раз-\nбиватьсоставныезначенияналексемы,сортироватьлексемыипроверять,\nсоответствуетли найденное значение запросу.Эти операции реализуются\nопорнымифункциямиклассаоператоров.\n28.2. Индекс для полнотекстового поиска\nОсновная область применения GIN — ускорение полнотекстового поиска,\nпоэтомуяпродолжупример,начатыйвглавепроGiST-индекс.Понятно,что с.563\nсоставнымизначениямивэтомслучаеявляютсядокументы,аэлементами\nэтихзначений—лексемы.\n599",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:16.597135"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 601,
    "chapter": null,
    "section": "28.2 Индексдляполнотекстовогопоиска",
    "text": "Глава28. ИндексGIN\nс.564 ПостроимGIN-индекснатаблицеc«Вополебереза...»:\n=> CREATE INDEX ts_gin_idx ON ts USING gin(doc_tsv);\nВозможнаяструктуратакогоиндексапоказананарисунке:\nметастраница\nззааллооммаатт ппооггуулляя\nбел берез залома заломат кудряв люл нек погуля пойд пол стоя\n2,2 0,1 2,2 1,1 0,2 1,1 2,1 2,1 0,1 0,1\n1,1 2,3 1,2 1,2 1,2 0,2 0,2\n2,2 2,4 1,3 0,3\n1,4 0,4\n1,4\n0,3 0,4 1,3 1,4 2,3 2,4\nВ отличие от предыдущих иллюстраций здесь показаны (и выделены цве-\nтом) конкретные значения идентификаторов, поскольку они будут важны\nдля понимания алгоритмов. Значения предполагают, что строки таблицы\nимеютследующиеидентификаторы:\n600",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:16.643167"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 602,
    "chapter": null,
    "section": "28.2 Индексдляполнотекстовогопоиска",
    "text": "28.2. Индексдляполнотекстовогопоиска\n=> SELECT ctid, * FROM ts;\nctid | doc | doc_tsv\n−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n(0,1) | Во поле береза стояла | 'берез':3 'пол':2 'стоя':4\n(0,2) | Во поле кудрявая стояла | 'кудряв':3 'пол':2 'стоя':4\n(0,3) | Люли, люли, стояла | 'люл':1,2 'стоя':3\n(0,4) | Люли, люли, стояла | 'люл':1,2 'стоя':3\n(1,1) | Некому березу заломати | 'берез':2 'заломат':3 'нек':1\n(1,2) | Некому кудряву заломати | 'заломат':3 'кудряв':2 'нек':1\n(1,3) | Люли, люли, заломати | 'заломат':3 'люл':1,2\n(1,4) | Люли, люли, заломати | 'заломат':3 'люл':1,2\n(2,1) | Я пойду погуляю | 'погуля':3 'пойд':2\n(2,2) | Белую березу заломаю | 'бел':1 'берез':2 'залома':3\n(2,3) | Люли, люли, заломаю | 'залома':3 'люл':1,2\n(2,4) | Люли, люли, заломаю | 'залома':3 'люл':1,2\n(12 rows)\nОбратитевниманиенанекоторыеотличияотобычногоиндексанаоснове\nB-дерева.КрайнийлевыйключвовнутреннихузлахB-деревапустиз-заего с.519\nизбыточности; в GIN-индексе он не хранится вовсе. Из-за этого оказыва-\nются сдвинутыми и ссылки на дочерние узлы. Верхний ключ использует-\nся в обоих индексах, но в GIN он располагается на своем законном месте\nвкрайнейправойпозиции.УзлыодногоуровняB-деревасоединеныдвуна-\nправленным списком; в GIN-индексе—однонаправленным,поскольку об-\nходдеревавыполняетсявсегдатольководнусторону.\nВ нашем умозрительном примере все списки идентификаторов помести-\nлисьвобычныестраницы,заисключениемспискадлялексемы«люл».Эта\nлексемавстретиласьвцелыхшестидокументах,иееидентификаторыбыли\nперенесенывотдельноедерево.\nСтраничная организация\nС точки зрения страничной организации GIN очень похож на B-дерево.\nЗаглянуть внутрь индекса можно с помощью расширения pageinspect.\nСоздадимGIN-индекснатаблицепочтовойрассылкиpgsql-hackers: с.569\n=> CREATE INDEX mail_gin_idx ON mail_messages USING gin(tsv);\n601",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:16.683173"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 603,
    "chapter": null,
    "section": "28.2 Индексдляполнотекстовогопоиска",
    "text": "Глава28. ИндексGIN\nНулевая страница (метастраница) содержит общую статистику, такую как\nколичествоэлементовистраницдругихтипов:\n=> SELECT *\nFROM gin_metapage_info(get_raw_page('mail_gin_idx',0)) \\gx\n−[ RECORD 1 ]−−−−+−−−−−−−−−−−\npending_head | 4294967295\npending_tail | 4294967295\ntail_free_size | 0\nn_pending_pages | 0\nn_pending_tuples | 0\nn_total_pages | 23139\nn_entry_pages | 13713\nn_data_pages | 9425\nn_entries | 999189\nversion | 2\nс.76 GINиспользуетспециальнуюобластьиндексныхстраниц,например,чтобы\nсохранитьвнейбиты,определяющиетипстраницы:\n=> SELECT flags, count(*)\nFROM generate_series(0,23138) AS p, -- n_total_pages\ngin_page_opaque_info(get_raw_page('mail_gin_idx',p))\nGROUP BY flags\nORDER BY 2;\nflags | count\n−−−−−−−−−−−−−−−−−−−−−−−−+−−−−−−−\n{meta} | 1\n{} | 156\n{data} | 1524\n{data,leaf,compressed} | 7901\n{leaf} | 13557\n(5 rows)\nСтраницаспризнакомmeta—это,конечно,метастраница.Страницыспри-\nзнаком data относятся кдеревьям идентификаторов,а страницы без этого\nпризнака—кдеревьям элементов.Внутридеревьев выделяютсялистовые\nстраницы,несущиепризнакleaf.\nЕщеоднафункциярасширенияpageinspectвыдаетинформациюобиден-\nтификаторах,хранящихсявлистовыхстраницахдеревьев.Фактическикаж-\nдая запись такого дерева содержит не один идентификатор, а небольшой\nсписок:\n602",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:16.713060"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 604,
    "chapter": null,
    "section": "28.2 Индексдляполнотекстовогопоиска",
    "text": "28.2. Индексдляполнотекстовогопоиска\n=> SELECT left(tids::text,60)||'...' tids\nFROM gin_leafpage_items(get_raw_page('mail_gin_idx',26));\ntids\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n{\"(4790,2)\",\"(4790,3)\",\"(4790,4)\",\"(4791,2)\",\"(4793,1)\",\"(47...\n{\"(5024,3)\",\"(5024,5)\",\"(5026,2)\",\"(5027,6)\",\"(5028,2)\",\"(50...\n{\"(5444,6)\",\"(5446,1)\",\"(5446,3)\",\"(5446,5)\",\"(5447,3)\",\"(54...\n...\n{\"(9903,3)\",\"(9903,6)\",\"(9905,2)\",\"(9905,3)\",\"(9905,4)\",\"(99...\n{\"(10056,4)\",\"(10057,3)\",\"(10059,4)\",\"(10059,5)\",\"(10064,5)\"...\n{\"(10491,6)\",\"(10863,3)\",\"(15114,5)\",\"(16256,6)\",\"(16258,7)\"...\n(28 rows)\nИдентификаторы в списках упорядочены, что позволяет сжимать данные\n(отсюдапризнакcompressed).Вместошестибайтногозначенияtidхранится\nразность с предыдущим значением, которая кодируется переменным чис-\nломбайтов1:чемменьшеэтаразность,темменьшеместазанимаютданные.\nКласс операторов\nВотсписокопорныхфункцийдляклассовоператоровGIN2:\n=> SELECT amprocnum, amproc::regproc\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid\nJOIN pg_amproc amop ON amprocfamily = opcfamily\nWHERE amname = 'gin'\nAND opcname = 'tsvector_ops'\nORDER BY amprocnum;\namprocnum | amproc\n−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n1 | gin_cmp_tslexeme\n2 | pg_catalog.gin_extract_tsvector\n3 | pg_catalog.gin_extract_tsquery\n4 | pg_catalog.gin_tsquery_consistent\n5 | gin_cmp_prefix\n6 | gin_tsquery_triconsistent\n(6 rows)\n1 backend/access/gin/ginpostinglist.c.\n2 postgrespro.ru/docs/postgresql/17/gin-extensibility;\nbackend/utils/adt/tsginidx.c.\n603",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:16.750267"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 605,
    "chapter": null,
    "section": "28.2 Индексдляполнотекстовогопоиска",
    "text": "Глава28. ИндексGIN\nПерваяопорнаяфункциясравниваетдваэлемента,вданномслучае—лексе-\nмы.ЕслибылексемыбылипредставленыобычнымтипомSQL,длякоторого\nопределен класс операторов B-дерева,то GIN автоматически использовал\nс.526 быоператорысравненияизэтогокласса.\nПятая(необязательная)функцияиспользуетсяпричастичномпоискеипро-\nверяет частичное соответствие элемента индекса ключу запроса.В нашем\nслучаечастичныйпоиск—этопоисклексемпопрефиксу.Например,запрос\n«п:*»соответствуетвсемлексемамнабукву«п».\nВторая функция выделяетлексемы из документа,а третья—из поисково-\nгозапроса.Разныефункциинужныхотябыпотому,чтодокументизапрос\nпредставлены разными типами данных, tsvector и tsquery. К тому же\nфункциядляпоисковогозапросаопределяет,какбудетвыполнятьсяпоиск.\nЕсли запрос требует наличия в документе какой-либо лексемы, при поис-\nкебудутрассматриватьсядокументы,содержащиехотябыоднулексемуиз\nзапроса.Еслижетакогоусловиянет(например,нужныдокументы,несодер-\nжащиеопределеннуюлексему),будутрассматриватьсявседокументывооб-\nще—что,конечно,значительнодороже.\nv.13 При наличии в запросе другихключей поиска индекс сначала сканируется по ним,\nазатемполученныерезультатыперепроверяются.Этопозволяетизбежатьбесполез-\nногопросмотраиндекса.\nЧетвертая и шестая — функции согласованности, которые определяют со-\nответствиенайденногодокументапоисковомузапросу.Четвертаяфункция\nполучаетнавходточныеданныеотом,какаялексемаиззапросасодержится\nв документе, а какая — нет. Шестая функция работает в условиях неопре-\nделенности и может вызываться, когда для части лексем еще неизвестно,\nприсутствуютли они вдокументе.Класс операторов не обязан реализовы-\nватьобефункции:достаточнопредоставитьодну,новтакомслучаепоиск\nможетпроигратьвэффективности.\nКласс операторов tsvector_ops поддерживает только один оператор со-\nпоставления документа поисковому запросу1 @@ —ровно тот же,который\nвключаетиклассоператоровGiST.\n1 backend/utils/adt/tsvector_op.c,функцияts_match_vq.\n604",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:16.788235"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 606,
    "chapter": null,
    "section": "28.2 Индексдляполнотекстовогопоиска",
    "text": "28.2. Индексдляполнотекстовогопоиска\nПоиск\nРассмотрим процесс выполнения поиска по запросу «стояла | кудрявая»,\nв котором две лексемы соединены условием «или». Сначала с помощью\nопорной функции1 из поискового запроса типа tsquery выделяются от-\nдельныелексемы(ключипоиска):«стоя»и«кудряв».\nПосколькузапростребуетналичияопределенныхлексем,формируетсяспи-\nсокидентификаторовдокументов,содержащиххотябыодинключиззапро-\nса.Дляэтоговдеревелексемотыскиваютсяидентификаторы,соответствую-\nщиекаждомуключупоиска,иизнихсоставляетсяодинобщийсписок.Вин-\nдексе все идентификаторы хранятся упорядоченно,что дает возможность\nиспользовать слияние нескольких отсортированных потоков идентифика- с.472\nторовводин2.\nззааллооммаатт ппооггуулляя\nбел берез залома заломат кудряв люл нек погуля пойд пол стоя\n2,2 0,1 2,2 1,1 0,2 1,1 2,1 2,1 0,1 0,1\n1,1 2,3 1,2 1,2 1,2 0,2 0,2\n2,2 2,4 1,3 0,3\n1,4 0,4\n1,4\n0,3 0,4 1,3 1,4 2,3 2,4\nЗаметьте,чтопоканеимеетзначения,былилиключиобъединеныуслови-\nем «и»,«или» либо каким-то еще,—движок поиска по дереву работает со\nспискомключейиничегонезнаетосмыслепоисковогозапроса.\n1 backend/utils/adt/tsginidx.c,функцияgin_extract_tsquery.\n2 backend/access/gin/ginget.c,функцияkeyGetItem.\n605",
    "tables": [
      {
        "table_index": 0,
        "rows": 2,
        "cols": 1,
        "content": "1,4"
      }
    ],
    "extracted_at": "2025-10-02T16:00:16.843509"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 607,
    "chapter": null,
    "section": "28.2 Индексдляполнотекстовогопоиска",
    "text": "Глава28. ИндексGIN\nКаждыйнайденныйидентификатор,соответствующийдокументу,проверя-\nетсяопорной функциейсогласованности1.Этафункциякак разтакизнает,\nкакинтерпретироватьпоисковыйзапрос,иоставляеттолькотеидентифи-\nкаторы, которые ему соответствуют (или по крайней мере могут соответ-\nствоватьинуждаютсявперепроверкепотаблице).\nВданномслучаефункциясогласованностиоставитвсеидентификаторы:\nфункция\ntid «стоя» «кудряв» согласованности\n(0,1) (cid:51) – (cid:51)\n(0,2) (cid:51) (cid:51) (cid:51)\n(0,3) (cid:51) – (cid:51)\n(0,4) (cid:51) – (cid:51)\n(1,2) – (cid:51) (cid:51)\nВместообычнойлексемывпоисковомзапросеможетбытьуказанпрефикс.\nЭтополезновслучаях,когдапользовательприложенияможетввестивполе\nпоиска первые буквы слова, ожидая получить по ним результаты. Напри-\nмер,для запроса «залом:*» будут найдены документы с лексемами,начи-\nнающимисяна«залом»:«залома»(котораяполучиласьизслова«заломаю»)\nи«заломат»(изслова«заломати»).\nПритакомчастичномпоискепроиндексированныелексемысравниваютсяс\nключомпоискаспомощьюотдельнойопорнойфункции2,котораявобщем\nслучае может реализовать не только проверку совпадения префикса, но и\nдругуюлогикучастичногосоответствия.\nЧастые и редкие лексемы\nЕсли лексемы, использованные в поисковом запросе, встречаются часто,\nсформированныйсписокидентификаторовверсийокажетсядлинным,что,\nконечно,накладно.Ксчастью,этогозачастуюможноизбежать,есливзапро-\nсеприсутствуютиредкиелексемы.\n1 backend/utils/adt/tsginidx.c,функцияgin_tsquery_triconsistent.\n2 backend/utils/adt/tsginidx.c,функцияgin_cmp_prefix.\n606",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:16.872985"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 608,
    "chapter": null,
    "section": "28.2 Индексдляполнотекстовогопоиска",
    "text": "28.2. Индексдляполнотекстовогопоиска\nРассмотримвыполнениезапроса«люли&заломаю».Лексема«залома»встре-\nчается три раза,а «люл»—шесть.Вместо того чтобы считать обе лексемы\nравноправными и собирать полный перечень идентификаторов по обеим,\nредкая лексема «залома» считается обязательной, а более частая «люл» —\nдополнительной,поскольку(сучетомсемантикизапроса)понятно,чтодо-\nкументслексемой«люл»будетсоответствоватьзапросу,толькоесливнем\nсодержитсяилексема«залома».\nИтак,сначалапоиндексуопределяетсяпервыйдокумент,содержащий«за-\nлома»; он имеетидентификатор (2,2).Дальшетребуется определить,не со-\nдержит ли этот же документ лексему «люл», но все документы с иденти-\nфикаторами, меньшими (2,2), можно сразу пропустить. Поскольку частым\nлексемамсоответствуетмногоидентификаторов,они,скореевсего,хранят-\nся в отдельномдереве,что позволяетпропуститьчастьстраниц.Вданном\nслучаепоисквдеревелексем«люл»начинаетсяс(2,2),ипервыйнайденный\nдокументимеетидентификатор(2,3).\nПроцедураповторяетсядляследующихзначенийобязательнойлексемы.\nззааллооммаатт ппооггуулляя\nбел берез залома заломат кудряв люл нек погуля пойд пол стоя\n2,2 0,1 2,2 1,1 0,2 1,1 2,1 2,1 0,1 0,1\n1,1 2,3 1,2 1,2 1,2 0,2 0,2\n2,2 2,4 1,3 0,3\n1,4 0,4\n1,4\n0,3 0,4 1,3 1,4 2,3 2,4\n607",
    "tables": [
      {
        "table_index": 0,
        "rows": 2,
        "cols": 1,
        "content": "1,4"
      }
    ],
    "extracted_at": "2025-10-02T16:00:16.928264"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 609,
    "chapter": null,
    "section": "28.2 Индексдляполнотекстовогопоиска",
    "text": "Глава28. ИндексGIN\nДлинаспискаидентификаторовбудетравнатрем,почислувхожденийред-\nкойлексемы:\nфункция\ntid «залома» «люл» согласованности\n(2,2) (cid:51) – –\n(2,3) (cid:51) (cid:51) (cid:51)\n(2,4) (cid:51) (cid:51) (cid:51)\nс.347 Таким образом, знание частот позволяет организовать слияние наиболее\nэффективным способом, начиная с редких лексем и пропуская заведомо\nненужныедиапазоны страниц вдеревьях частыхлексем.Экономия проис-\nходитинаколичествевызововфункциисогласованности.\nТакаяоптимизацияработает,конечно,нетолькодлядвухлексем,ноивбо-\nлеесложныхслучаях.Алгоритмупорядочиваетлексемыотредкихкчастым\nизатемпооднойдобавляетихкспискуобязательныхдотехпор,покаостав-\nшиесялексемынесмогутсамипосебеобеспечитьсоответствиедокумента\nзапросу1.\nНапример,возьмемзапрос«заломати & ( некому | белую )».Самаяредкая\nлексема—«бел»—сразудобавляетсявсписокобязательных.Чтобыпрове-\nрить,могутлиоставшиесялексемысчитатьсядополнительными,вфункцию\nсогласованностипередаетсяложноезначениедляобязательнойлексемыи\nистинные—дляостальных.ФункциявозвращаетtrueAND(trueORfalse)\n=true,тоестьоставшиесялексемы«самодостаточны»,икакминимумодна\nизнихдолжнастатьобязательной.\nВсписокобязательныхдобавляетсяследующаяпочастотелексема—«нек»,\nитеперьфункциясогласованностивозвращаетtrue AND (false OR false)\n=false.Такимобразом,лексемы«бел»и«нек»становятсяобязательными,\nа«заломат»—дополнительной.\nс.569 Чтобы убедиться в эффективности этой оптимизации, используем архив\nрассылкиpgsql-hackers.Нампонадобятсядвелексемы,частаяиредкая:\n1 backend/access/gin/ginget.c,функцияstartScanKey.\n608",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:16.958802"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 610,
    "chapter": null,
    "section": "28.2 Индексдляполнотекстовогопоиска",
    "text": "28.2. Индексдляполнотекстовогопоиска\n=> SELECT word, ndoc\nFROM ts_stat('SELECT tsv FROM mail_messages')\nWHERE word IN ('wrote', 'tattoo');\nword | ndoc\n−−−−−−−−+−−−−−−−−\nwrote | 231173\ntattoo | 2\n(2 rows)\nОказывается,естьодиндокумент,вкоторомвстречаютсяобаэтихслова:\n=> \\timing on\n=> SELECT count(*) FROM mail_messages\nWHERE tsv @@ to_tsquery('wrote & tattoo');\ncount\n−−−−−−−\n1\n(1 row)\nTime: 0,456 ms\nЗапросвыполняетсяпочтитакжебыстро,какипоискодногослова«tattoo»:\n=> SELECT count(*) FROM mail_messages\nWHERE tsv @@ to_tsquery('tattoo');\ncount\n−−−−−−−\n2\n(1 row)\nTime: 0,340 ms\nАвотпоискодногослова«wrote»выполняетсясущественнодольше:\n=> SELECT count(*) FROM mail_messages\nWHERE tsv @@ to_tsquery('wrote');\ncount\n−−−−−−−−\n231173\n(1 row)\nTime: 302,089 ms\n=> \\timing off\n609",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:16.982649"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 611,
    "chapter": null,
    "section": "28.2 Индексдляполнотекстовогопоиска",
    "text": "Глава28. ИндексGIN\nВставка\nПридобавленииэлементакGIN-индексу1существующиеэлементынедуб-\nлируются; вместо этого у имеющегося элемента расширяется набор иден-\nтификаторов (список или дерево). Список идентификаторов является ча-\nстью индексной строки,которая не можетзаниматьслишком много места\nнастранице,поэтомуприпереполнениисписокпреобразуетсявдерево2.\nПривставкевдеревоновогоэлемента(илиновогоидентификатора)может\nвозникнутьпереполнениестраницы;вэтомслучаестраницарасщепляется\nнадве,иэлементыперераспределяютсямеждуними3.\nНо каждый документ обычно содержит много лексем, подлежащих индек-\nсированию. Поэтому при создании или изменении одного-единственного\nдокументаприходитсявноситьсразумножествоизмененийвдеревоиндек-\nса.Из-заэтогоGIN-индексобновляетсяотносительномедленно.\nНарисункепоказаносостояниедеревапоследобавлениявтаблицустроки\n«Некому заломати белую березу» с идентификатором (4,1).Список иденти-\nфикаторовлексем«бел»,«берез»и«нек»увеличился,асписоклексемы«за-\nломат»превысилмаксимальныйразмерибылвыделенвотдельноедерево.\nС другой стороны,если учитывать в индексе изменения сразу нескольких\nдокументов,тообщийобъемработы,вероятно,уменьшитсяпосравнению\nс последовательным изменением, поскольку часть лексем у документов,\nскореевсего,окажетсяобщей.\nТакой отложенный режим обновления включается параметром хранения\non fastupdate.Изменениявэтомрежименакапливаютсявотдельномнеупоря-\nс.286 доченномсписке,которыйфизическихранитсявнедереваэлементоввот-\nдельных страницах (list pages). Когда этот список становится достаточно\nбольшим, все накопленные изменения одномоментно вносятся в индекс,\nасписокочищается4.Максимальныйразмерспискаопределяетсяпарамет-\n4MB ромgin_pending_list_limitилиодноименнымпараметромхраненияиндекса.\n1 backend/access/gin/gininsert.c,функцияginEntryInsert.\n2 backend/access/gin/gininsert.c,функцияaddItemPointersToLeafTuple.\n3 backend/access/gin/ginbtree.c,функцияginInsertValue.\n4 backend/access/gin/ginfast.c,функцияginInsertCleanup.\n610",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.022274"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 612,
    "chapter": null,
    "section": "28.2 Индексдляполнотекстовогопоиска",
    "text": "28.2. Индексдляполнотекстовогопоиска\nззааллооммаатт ппооггуулляя\nбел берез залома заломат кудряв люл нек погуля пойд пол стоя\n2,2 0,1 2,2 0,2 1,1 2,1 2,1 0,1 0,1\n4,1 1,1 2,3 1,2 1,2 0,2 0,2\n2,2 2,4 4,1 0,3\n4,1 0,4\n1,4 1,4\n1,1 1,2 1,3 1,4 4,1 0,3 0,4 1,3 1,4 2,3 2,4\nПоумолчаниюотложенныйрежимвключен,носледуетиметьввиду,чтоон\nзамедляетпоиск:кромедереваприходитсяпросматриватьивесьнеупоря-\nдоченный список. К тому же время вставки становится менее предсказуе-\nмым, поскольку при очередном изменении список может переполниться,\nи потребуется выполнить дорогостоящую процедуру слияния. Последний\nмомент отчасти нивелируется тем, что слияние выполняется в том числе\nиприочисткеиндекса,тоестьасинхронно.\nПри создании нового индекса1 элементытоже добавляются не по одному,\nчто было бы слишком медленно, а отложенно. Вместо неупорядоченного\nсписканадискеизменениянакапливаютсявобластиоперативнойпамяти\nразмером maintenance_work_mem и сбрасываются в индекс при переполне- 64MB\nнии.Чембольшепамятибудетвыделеноподоперацию,тембыстреебудет\nпостроениндекс.\n1 backend/access/gin/gininsert.c,функцияginbuild.\n611",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.078341"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 613,
    "chapter": null,
    "section": "28.2 Индексдляполнотекстовогопоиска",
    "text": "Глава28. ИндексGIN\nПриведенныевэтомразделепримерыпозволяютубедитьсявпревосходстве\nс.563 GIN по точности поиска над сигнатурным деревом GiST. Поэтому в боль-\nшинствеслучаевименноGINиспользуетсядляподдержкиполнотекстового\nпоиска.Однако проблема медленного обновления GIN может повлиять на\nвыбориндексавпользуGiST,еслиданныеактивноизменяются.\nОграничение выборки\nМетоддоступаGINвсегдавозвращаетрезультатввидебитовойкарты;полу-\nчатьтабличныеидентификаторыпоодномуневозможно.Инымисловами,\nс.397 поддерживаетсясвойствоBITMAPSCAN,нонеINDEXSCAN.\nПричинаэтого—вналичиинеупорядоченногоспискаотложенныхизмене-\nний.При индексном доступе сначала просматривается список и формиру-\nетсябитоваякарта,азатембитоваякартаобновляетсяданнымииздерева.\nЕсли в процессе поиска неупорядоченный список будет объединен с дере-\nвом(врезультатеобновленияиндексаиливпроцессеочистки),одноитоже\nзначениеможетбытьполученодважды,чтонедопустимо.Новслучаебито-\nвой карты это не представляет проблемы: один и тот же бит просто будет\nустановлендвараза.\nКакследствие,ограничениевыборкипоGIN-индексуспомощьюпредложе-\nнияLIMITневполнеэффективно,посколькубитоваякартавлюбомслучае\nстроитсяполностью,иеепостроениеможетсоставлятьсущественнуючасть\nобщейстоимости:\n=> EXPLAIN SELECT * FROM mail_messages\nWHERE tsv @@ to_tsquery('hacker')\nLIMIT 1000;\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nLimit (cost=354.36..1856.38 rows=1000 width=1255)\n−> Bitmap Heap Scan on mail_messages\n(cost=354.36..74313.49 rows=49240 width=1255)\nRecheck Cond: (tsv @@ to_tsquery('hacker'::text))\n−> Bitmap Index Scan on mail_gin_idx\n(cost=0.00..342.05 rows=49240 width=0)\nIndex Cond: (tsv @@ to_tsquery('hacker'::text))\n(7 rows)\n612",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.115542"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 614,
    "chapter": null,
    "section": "28.2 Индексдляполнотекстовогопоиска",
    "text": "28.2. Индексдляполнотекстовогопоиска\nПоэтому метод GIN имеет специальную возможность ограничить коли-\nчество результатов, получаемых из индекса. Ограничение задается пара-\nметром gin_fuzzy_search_limit и по умолчанию не действует. Если его уста- 0\nновить,индексныйметодбудетслучайнымобразомпропускатьнекоторые\nзначения,чтобыполучитьпримерноуказанноеколичествострок1(потомуи\nfuzzy):\n=> SET gin_fuzzy_search_limit = 1000;\n=> SELECT count(*)\nFROM mail_messages\nWHERE tsv @@ to_tsquery('hacker');\ncount\n−−−−−−−\n757\n(1 row)\n=> SELECT count(*)\nFROM mail_messages\nWHERE tsv @@ to_tsquery('hacker');\ncount\n−−−−−−−\n753\n(1 row)\n=> RESET gin_fuzzy_search_limit;\nОбратитевниманиенаотсутствиепредложенияLIMITвзапросах.Этоедин-\nственный «легализованный» способ получить разные данные при индекс-\nномипритабличномдоступе.Планировщикничегонезнаетобэтойособен-\nностиGIN-индексовиникакнеучитываетзначениепараметраприрасчете\nстоимости.\nСвойства\nВсесвойстваметодадоступаgin навсехуровняходинаковыеинезависят\nотконкретногоклассаоператоров.\n1 backend/access/gin/ginget.c,макросdropItem.\n613",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.143279"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 615,
    "chapter": null,
    "section": "28.2 Индексдляполнотекстовогопоиска",
    "text": "Глава28. ИндексGIN\nСвойстваметодадоступа\n=> SELECT a.amname, p.name, pg_indexam_has_property(a.oid, p.name)\nFROM pg_am a, unnest(array[\n'can_order', 'can_unique', 'can_multi_col',\n'can_exclude', 'can_include'\n]) p(name)\nWHERE a.amname = 'gin';\namname | name | pg_indexam_has_property\n−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−\ngin | can_order | f\ngin | can_unique | f\ngin | can_multi_col | t\ngin | can_exclude | f\ngin | can_include | f\n(5 rows)\nGINнеобеспечиваетнисортировку,ниуникальностьзначений.\nСозданиесоставныхиндексовподдерживается.Интересно,чтодляGINпо-\nрядокстолбцоввиндексенеимеетникакогозначения.Вотличиеотобыч-\nного B-дерева многоколоночный индекс GIN хранит не составные ключи,\nаотдельныеэлементы,дополненныеуказаниемномерастолбца.\nОграничениеисключениянеподдерживаетсябезсвойстваINDEXSCAN.\nДополнительныеinclude-столбцыдляGINнереализованы.Внихинетболь-\nшого смысла, поскольку GIN-индекс вряд ли получится использовать как\nпокрывающий: индексируемое значение хранится в таблице, а индекс со-\nдержиттолькоэлементыэтогозначения.\nСвойстваиндекса\n=> SELECT p.name, pg_index_has_property('mail_gin_idx', p.name)\nFROM unnest(array[\n'clusterable', 'index_scan', 'bitmap_scan', 'backward_scan'\n]) p(name);\nname | pg_index_has_property\n−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−\nclusterable | f\nindex_scan | f\nbitmap_scan | t\nbackward_scan | f\n(4 rows)\n614",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.174989"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 616,
    "chapter": null,
    "section": "28.2 Индексдляполнотекстовогопоиска",
    "text": "28.2. Индексдляполнотекстовогопоиска\nВыдачарезультатовпоодномунеподдерживается,индексныйдоступвсегда\nвозвращаетбитовуюкартурезультатов.\nПоэтомуинетсмыславупорядочиваниитаблицыпоGIN-индексу:битовая\nкарта по определению соответствует физическому расположению данных\nвтаблице,какоебыононибыло.\nСканированиеGIN-индексавобратнуюсторонунеподдерживается:этавоз-\nможностьактуальнадляиндексногосканирования,нонедлясканирования\nпобитовойкарте.\nСвойствастолбцов\n=> SELECT p.name,\npg_index_column_has_property('mail_gin_idx', 1, p.name)\nFROM unnest(array[\n'orderable', 'search_array', 'search_nulls',\n'returnable', 'distance_orderable'\n]) p(name);\nname | pg_index_column_has_property\n−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\norderable | f\nsearch_array | f\nsearch_nulls | f\nreturnable | f\ndistance_orderable | f\n(5 rows)\nНиодноизсвойствуровнястолбцанедоступно:нисортировка(чтопонят-\nно),нииспользованиеиндексавкачествепокрывающего(посколькусамдо-\nкументнехранитсявиндексе),ниработаснеопределеннымизначениями\n(неимеетсмысладляэлементовнеатомарныхтипов).\nОграничения GIN и RUM-индекс\nПри всем своем могуществе GIN не решает всех проблем полнотекстового\nпоиска.Втипеданныхtsvectorприсутствуютпозициилексем,новиндекс\nонинепопадают.ЭтонепозволяетэффективноиспользоватьGINдляуско-\nрения фразового поиска,при котором учитывается близостьлексем.Кроме\n615",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.204812"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 617,
    "chapter": null,
    "section": "28.2 Индексдляполнотекстовогопоиска",
    "text": "Глава28. ИндексGIN\nтого, поисковые системы обычно возвращают результаты в порядке реле-\nвантности(чтобыниозначалэтоттермин).ПосколькуGINнеподдержива-\nет упорядочивающие операторы, единственный выход — вычислять функ-\nциюранжированиядлякаждойстрокирезультата,что,конечно,медленно.\nЭтинедостаткиустраненывиндексномметодеRUM,названиекоторогоза-\nставляет усомниться в искренности разработчиков относительно смысла,\nвкладываемого в аббревиатуру GIN.Это сторонний метод доступа; расши-\nрениедоступноикакпакетврепозиторииPGDG1,ивисходныхкодах2.\nRUM создан на основе GIN и отличается отнего двумя принципиальными\nсвойствами.Во-первых,внемотказалисьототложенногорежимаобновле-\nния;засчетэтогопоявиласьподдержканетолькосканированияпобитовой\nкарте,ноиобычногоиндексногосканирования,атакжебылиреализованы\nупорядочивающие операторы.Во-вторых,к ключам индекса можнодобав-\nлять вспомогательную информацию. Это отчасти похоже на дополнитель-\nныеinclude-столбцы,ноинформацияпривязываетсякконкретномуключу.\nВконтекстеполнотекстовогопоискаклассоператоровRUMсвязываетвхож-\nдения лексем с их позициями в документе,что позволяет ускорять фразо-\nвыйпоискивыдачурезультатоввпорядкеранжирования.\nНедостатком такого подхода является медленное обновление и увеличен-\nный объем индекса. Кроме того, являясь расширением, индексный метод\nrumпользуетсямеханизмомунифицированныхжурнальныхзаписей3,кото-\nрыйработаетмедленнеевстроенноговядрожурналированияигенерирует\nбольшийобъемWAL.\n28.3. Индекс для триграмм\nРасширение pg_trgm4 позволяет определять схожесть слов, сравнивая ко-\nличество совпадающих последовательностей изтрех букв (триграмм). Его\n1 postgresql.org/download.\n2 github.com/postgrespro/rum.\n3 postgrespro.ru/docs/postgresql/17/generic-wal.\n4 postgrespro.ru/docs/postgresql/17/pgtrgm.\n616",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.239835"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 618,
    "chapter": null,
    "section": "28.3 Индексдлятриграмм",
    "text": "28.3. Индексдлятриграмм\nможноиспользоватьвместесполнотекстовымпоиском,чтобынаходитьва-\nриантыдажепривводесловсопечатками.\nКласс операторов gin_trgm_ops реализует индексирование текстовых\nстрок, но в качестве элементов текстовых значений выделяются не слова\nили лексемы, а всевозможные трехсимвольные подстроки (используются\nтолькобуквыицифры,остальныесимволыигнорируются).Внутрииндекса\nтриграммы представляются целыми числами: для русских букв, занимаю-\nщихдвабайтавкодировкеUTF-8,такоекодированиенепозволяетрасшиф-\nроватьисходныесимволы.Поэтомуяпокажу,какформируютсятриграммы,\nвбазеданныхсвосьмибитнойкодировкой:\n=> CREATE DATABASE eightbit\nWITH ENCODING 'KOI8R'\nLC_CTYPE='ru_RU.koi8r'\nLC_COLLATE='ru_RU.koi8r'\nTEMPLATE=template0; -- кодировки базы и кластера не совпадают\n=> \\c eightbit\n=> CREATE EXTENSION pg_trgm;\n=> SET client_encoding = 'UTF8';\n=> SELECT unnest(show_trgm('заломаю')),\nunnest(show_trgm('заломати'));\nunnest | unnest\n−−−−−−−−+−−−−−−−−\nаю | ало\nало | ати\nлом | лом\nмаю | мат\nома | ома\nзал | ти\nза | зал\nз | за\n| з\n(9 rows)\nКлассоператоровподдерживаетоператорыточногоинечеткогосравнения\nстрокислов.\n=> CREATE EXTENSION pg_trgm;\n617",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.270473"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 619,
    "chapter": null,
    "section": "28.3 Индексдлятриграмм",
    "text": "Глава28. ИндексGIN\n=> SELECT amopopr::regoperator, oprcode::regproc\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid\nJOIN pg_amop amop ON amopfamily = opcfamily\nJOIN pg_operator opr ON opr.oid = amopopr\nWHERE amname = 'gin'\nAND opcname = 'gin_trgm_ops'\nORDER BY amopstrategy;\namopopr | oprcode\n−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n%(text,text) | similarity_op\n~~(text,text) | textlike\nLIKEиILIKE\n~~*(text,text) | texticlike\n~(text,text) | textregexeq\nрегулярныевыражения\n~*(text,text) | texticregexeq\n%>(text,text) | word_similarity_commutator_op\n%>>(text,text) | strict_word_similarity_commutator_op\n=(text,text) | texteq\n(8 rows)\nДля нечеткого сравнения можно определить расстояние между строка-\nми как отношение числа совпадающих триграмм к их общему количеству\nв строке-запросе. Но, как я уже показывал, индекс GIN не поддерживает\nупорядочивающиеоператоры,такчтовсеоператорывкласседолжныбыть\nбулевыми. Поэтому для операторов %, %> и %>>, реализующих стратегии\nнечеткогосравнения,функциясогласованностивычисляетрасстояниеида-\nет положительный вердикт, если оно не превышает установленный порог.\nДляоператоров= иLIKE функциясогласованноститребует,чтобывзначе-\nнии присутствовали всетриграммы из строки-запроса.Соответствие регу-\nлярномувыражениюпроверяетсясущественноболеесложно.\nВлюбомслучаепоискпотриграммамявляетсянеточнымивсегдаперепро-\nверяетсяпотаблице.\n28.4. Индекс для массивов\nДругойпримерподходящеготипаданных—массив.GIN-индекспоэлемен-\nтам массива позволяет быстрее находить пересечения массивов и вхожде-\nнияодногомассивавдругой:\n618",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.308590"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 620,
    "chapter": null,
    "section": "28.4 Индексдлямассивов",
    "text": "28.4. Индексдлямассивов\n=> SELECT amopopr::regoperator, oprcode::regproc, amopstrategy\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid\nJOIN pg_amop amop ON amopfamily = opcfamily\nJOIN pg_operator opr ON opr.oid = amopopr\nWHERE amname = 'gin'\nAND opcname = 'array_ops'\nORDER BY amopstrategy;\namopopr | oprcode | amopstrategy\n−−−−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−\n&&(anyarray,anyarray) | arrayoverlap | 1\n@>(anyarray,anyarray) | arraycontains | 2\n<@(anyarray,anyarray) | arraycontained | 3\n=(anyarray,anyarray) | array_eq | 4\n(4 rows)\nВ качестве примера возьмем представление routes демобазы с информа-\nциейорейсах.Столбецdays_of_weekхранитмассивномеровднейнедели,\nпо которым выполняются рейсы. Конечно, чтобы построить индекс, пред-\nставлениепридется«материализовать»:\n=> CREATE TABLE routes_tbl\nAS SELECT * FROM routes;\nSELECT 710\n=> CREATE INDEX ON routes_tbl USING gin(days_of_week);\nСпомощьюсозданногоиндексаможно,например,отобратьрейсы,отправ-\nляющиеся по вторникам,четвергам и воскресеньям.Я отключаю последо-\nвательноесканирование,посколькуиначепланировщикнебудетиспользо-\nватьиндексдлятакойнебольшойтаблицы:\n=> SET enable_seqscan = off;\n=> EXPLAIN (costs off) SELECT *\nFROM routes_tbl\nWHERE days_of_week = ARRAY[2,4,7];\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on routes_tbl\nRecheck Cond: (days_of_week = '{2,4,7}'::integer[])\n−> Bitmap Index Scan on routes_tbl_days_of_week_idx\nIndex Cond: (days_of_week = '{2,4,7}'::integer[])\n(4 rows)\n619",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.347880"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 621,
    "chapter": null,
    "section": "28.4 Индексдлямассивов",
    "text": "Глава28. ИндексGIN\nОказывается,естьодиннадцатьтакихрейсов:\n=> SELECT flight_no, departure_airport_name AS departure,\narrival_airport_name AS arrival, days_of_week\nFROM routes_tbl\nWHERE days_of_week = ARRAY[2,4,7];\nflight_no | departure | arrival | days_of_week\n−−−−−−−−−−−+−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−\nPG0023 | Орск | Курган | {2,4,7}\nPG0123 | Бегишево | Ростов−на−Дону | {2,4,7}\n...\nPG0482 | Домодедово | Кемерово | {2,4,7}\nPG0651 | Усть−Илимск | Хабаровск−Новый | {2,4,7}\n(11 rows)\nПостроенныйиндекссодержитвсегосемьэлементов:целыечислаот1до7,\nпредставляющиеднинедели.\nЗапросвыполняетсяпримернотакже,какяпоказывалвышедляполнотек-\nстового поиска.Поисковый запрос вданном случае представлен не специ-\nальным типом данных, а обычным массивом; такой запрос подразумева-\nет,чтовиндексированноммассиведолжнывстретитьсявсеперечисленные\nэлементы.Важноеотличиесостоитвтом,чтоусловиеравенстватребуеттак-\nже, чтобы индексированный массив не содержал никаких других элемен-\nтов.Функциясогласованности1 знаетобэтойособенностиблагодаряноме-\nрустратегии,нонеможетудостоверитьсявотсутствиилишнихэлементов\nи поэтому просит механизм индексирования перепроверить результаты:\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT * FROM routes_tbl\nWHERE days_of_week = ARRAY[2,4,7];\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on routes_tbl (actual rows=11 loops=1)\nRecheck Cond: (days_of_week = '{2,4,7}'::integer[])\nRows Removed by Index Recheck: 482\nHeap Blocks: exact=17\n−> Bitmap Index Scan on routes_tbl_days_of_week_idx (actual ro...\nIndex Cond: (days_of_week = '{2,4,7}'::integer[])\n(6 rows)\n1 backend/access/gin/ginarrayproc.c,функцияginarrayconsistent.\n620",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.388763"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 622,
    "chapter": null,
    "section": "28.4 Индексдлямассивов",
    "text": "28.4. Индексдлямассивов\nМожет оказаться полезным расширить GIN-индекс,добавив в него другие\nстолбцы.Например,дляпоискарейсов,отправляющихсяповторникам,чет-\nвергам и воскресеньям из Москвы, в индексе не хватает столбца depar-\nture_city.Однакодляобычныхскалярныхтиповданныхклассыоперато-\nровнепредусмотрены:\n=> CREATE INDEX ON routes_tbl USING gin(days_of_week, departure_city);\nERROR: data type text has no default operator class for access\nmethod \"gin\"\nHINT: You must specify an operator class for the index or define a\ndefault operator class for the data type.\nВ таких случаях помогает расширение btree_gin. Оно добавляет классы с.558\nоператоровGIN,имитирующиеработуобычногоB-дерева,представляяска-\nлярноезначениекаксоставное,носодержащееодинэлемент.\n=> CREATE EXTENSION btree_gin;\n=> CREATE INDEX ON routes_tbl USING gin(days_of_week,departure_city);\n=> EXPLAIN (costs off)\nSELECT * FROM routes_tbl\nWHERE days_of_week = ARRAY[2,4,7]\nAND departure_city = 'Москва';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on routes_tbl\nRecheck Cond: ((days_of_week = '{2,4,7}'::integer[]) AND\n(departure_city = 'Москва'::text))\n−> Bitmap Index Scan on routes_tbl_days_of_week_departure_city...\nIndex Cond: ((days_of_week = '{2,4,7}'::integer[]) AND\n(departure_city = 'Москва'::text))\n(6 rows)\n=> RESET enable_seqscan;\nПо-прежнемуостаетсясправедливымзамечание,котороеяужеделалвот-\nношениирасширенияbtree_gist:B-деревогораздоэффективнеесправля-\nетсясподдержкойоперацийсравнения,такчтоиспользоватьрасширение\nимеет смысл лишь в тех случаях,когда GIN-индекс действительно необхо-\nдим.Например,поискпоусловиям«меньше»или«меньшеилиравно»вы-\nполняетсявB-деревесканированиемлистовыхстраницвобратнуюсторону,\nавGINтакаявозможностьотсутствует.\n621",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.430070"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 623,
    "chapter": null,
    "section": "28.5 Индекс для JSON",
    "text": "Глава28. ИндексGIN\n28.5. Индекс для JSON\nЕще один неатомарный тип данных, для которого есть встроенная GIN-\nподдержка, — jsonb1. Для работы с JSON предусмотрен целый ряд опера-\nторов,частьизкоторыхможетбытьускоренаспомощьюGIN-индекса.\nСуществуетдва класса операторов,которые выделяют разные наборы эле-\nментовиздокументаJSON:\n=> SELECT opcname\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid\nWHERE amname = 'gin'\nAND opcintype = 'jsonb'::regtype;\nopcname\n−−−−−−−−−−−−−−−−\njsonb_ops\njsonb_path_ops\n(2 rows)\nКласс операторов jsonb_ops\nПервыйклассоператоров,jsonb_ops,используетсяпоумолчанию.Виндекс\nвкачествеэлементовпопадаютвсеключи,всезначенияивсеэлементымас-\nсивов исходного документа JSON2.Это позволяет ускорять запросы с усло-\nвиями включения JSON-значения (@>), существования ключей (?, ?| и ?&)\nисопоставленияпутейJSON(@?и@@):\n=> SELECT amopopr::regoperator, oprcode::regproc, amopstrategy\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid\nJOIN pg_amop amop ON amopfamily = opcfamily\nJOIN pg_operator opr ON opr.oid = amopopr\nWHERE amname = 'gin'\nAND opcname = 'jsonb_ops'\nORDER BY amopstrategy;\n1 postgrespro.ru/docs/postgresql/17/datatype-json.\n2 backend/utils/adt/jsonb_gin.c,функцияgin_extract_jsonb.\n622",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.460262"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 624,
    "chapter": null,
    "section": "28.5 ИндексдляJSON",
    "text": "28.5. ИндексдляJSON\namopopr | oprcode | amopstrategy\n−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−\n@>(jsonb,jsonb) | jsonb_contains | 7\n?(jsonb,text) | jsonb_exists | 9\n?|(jsonb,text[]) | jsonb_exists_any | 10\n?&(jsonb,text[]) | jsonb_exists_all | 11\n@?(jsonb,jsonpath) | jsonb_path_exists_opr | 15\n@@(jsonb,jsonpath) | jsonb_path_match_opr | 16\n(6 rows)\nДляпримерапредставимнесколькострокизroutesввидеJSON:\n=> CREATE TABLE routes_jsonb AS\nSELECT to_jsonb(t) route\nFROM (\nSELECT departure_airport_name, arrival_airport_name, days_of_week\nFROM routes\nORDER BY flight_no\nLIMIT 4\n) t;\n=> SELECT ctid, jsonb_pretty(route) FROM routes_jsonb;\nctid | jsonb_pretty\n−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n(0,1) | { +\n| \"days_of_week\": [ +\n| 6 +\n| ], +\n| \"arrival_airport_name\": \"Сургут\", +\n| \"departure_airport_name\": \"Усть−Илимск\" +\n| }\n(0,2) | { +\n| \"days_of_week\": [ +\n| 7 +\n| ], +\n| \"arrival_airport_name\": \"Усть−Илимск\", +\n| \"departure_airport_name\": \"Сургут\" +\n| }\n(0,3) | { +\n| \"days_of_week\": [ +\n| 2, +\n| 6 +\n| ], +\n| \"arrival_airport_name\": \"Сочи\", +\n| \"departure_airport_name\": \"Иваново−Южный\"+\n| }\n623",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.489274"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 625,
    "chapter": null,
    "section": "28.5 ИндексдляJSON",
    "text": "Глава28. ИндексGIN\n(0,4) | { +\n| \"days_of_week\": [ +\n| 3, +\n| 7 +\n| ], +\n| \"arrival_airport_name\": \"Иваново−Южный\", +\n| \"departure_airport_name\": \"Сочи\" +\n| }\n(4 rows)\n=> CREATE INDEX ON routes_jsonb USING gin(route);\nСозданныйиндексможнопредставитьследующимобразом:\naarrrriivvaall__aaiirrppoorrtt__nnaammee ИИввааннооввоо--ЮЮжжнныыйй\n0,3 0,4 0,1 0,2 0,1 0,1 0,1 0,3 0,3 0,1 0,1\n0,3 0,4 0,2 0,2 0,2 0,4 0,4 0,2 0,2\n0,3 0,3 0,3\n0,4 0,4 0,4\nРассмотрим запрос по условию route @> '{\"days_of_week\": [6]}',кото-\nроеотбираетдокументыJSON,содержащиеуказанныйпуть(тоестьрейсы,\nсовершаемыепосубботам).\nОпорная функция1 выделяетиз поискового запроса,представленного зна-\nчениемJSON,ключипоиска:«days_of_week»и«6».Этиключиищутсявдере-\nве элементов,идокументы,содержащие по крайней мере один ключ,про-\n1 backend/utils/adt/jsonb_gin.c,функцияgin_extract_jsonb_query.\n624\n2 3 6 7\neman_tropria_lavirra\nkeew_fo_syad\neman_tropria_erutraped\nйынжЮ-овонавИ\nичоС\nтугруС\nксмилИ-ьтсУ",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.535041"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 626,
    "chapter": null,
    "section": "28.5 ИндексдляJSON",
    "text": "28.5. ИндексдляJSON\nверяются функцией согласованности1. Для стратегии «содержит» функция\nтребуетналичиявсехключейизпоисковогозапроса,норезультатывсерав-\nно должны перепроверяться по таблице, поскольку с точки зрения индек-\nса указанный путь соответствует,например,документу {\"days_of_week\":\n[2],\"foo\":[6]}.\nКласс операторов jsonb_path_ops\nВторойклассjsonb_path_opsсодержитменьшеоператоров:\n=> SELECT amopopr::regoperator, oprcode::regproc, amopstrategy\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid\nJOIN pg_amop amop ON amopfamily = opcfamily\nJOIN pg_operator opr ON opr.oid = amopopr\nWHERE amname = 'gin'\nAND opcname = 'jsonb_path_ops'\nORDER BY amopstrategy;\namopopr | oprcode | amopstrategy\n−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−\n@>(jsonb,jsonb) | jsonb_contains | 7\n@?(jsonb,jsonpath) | jsonb_path_exists_opr | 15\n@@(jsonb,jsonpath) | jsonb_path_match_opr | 16\n(3 rows)\nВэтомслучаевиндекспопадаютнеразрозненныефрагментыJSON,апути\nоткорнядокументадовсехзначенийивсехэлементовмассивов2.Этоделает\nпоискгораздоболееточнымиэффективным,хотяинепозволяетускорять\nоперации,аргументамикоторыхявляютсянепути,аотдельныеключи.\nПоскольку путь может быть достаточно длинным, фактически индексиру-\nютсянесамипути,азначенияхеш-функцийотних.\nСоздадиминдекссэтимклассомоператоровдлятойжетаблицы:\n=> CREATE INDEX ON routes_jsonb USING gin(route jsonb_path_ops);\n1 backend/utils/adt/jsonb_gin.c,функцияgin_consistent_jsonb.\n2 backend/utils/adt/jsonb_gin.c,функцияgin_extract_jsonb_path.\n625",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.570197"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 627,
    "chapter": null,
    "section": "28.5 ИндексдляJSON",
    "text": "Глава28. ИндексGIN\nВоткакможнопредставитьдеревосозданногоиндекса:\nHHAASSHH((......)) HHAASSHH((......))\n0,3 0,4 0,1 0,2 0,4 0,1 0,3 0,2 0,2 0,4 0,1 0,3\n0,4 0,3\nПри выполнении запроса с тем же условием route @> '{\"days_of_week\":\n[6]}' опорная функция1 выделит из поискового запроса не отдельные\nфрагменты, а весь путь «days_of_week, 6». В дереве элементов сразу же бу-\nдутнайденыидентификаторыдвухподходящихдокументов.\nКонечно, и в этом случае найденные записи будут проверены функци-\nейсогласованности2 изатемперепроверенымеханизмоминдексирования\nпо таблице (как минимум из-за возможных хеш-коллизий). Но поиск по\nдереву выполняется намного эффективнее, так что стоит выбирать класс\njsonb_path_ops всегда,когдавходящихвнегооператоровдостаточнодля\nиндекснойподдержкизапросов.\n1 backend/utils/adt/jsonb_gin.c,функцияgin_extract_jsonb_query_path.\n2 backend/utils/adt/jsonb_gin.c,функцияgin_consistent_jsonb_path.\n626\n)йынжЮ-овонавИ,eman_tropria_erutraped(HSAH\n)ичоС,eman_tropria_erutraped(HSAH\n)ксмилИ-ьтсУ,eman_tropria_erutraped(HSAH\n)тугруС,eman_tropria_erutraped(HSAH\n)3,keew_fo_syad(HSAH\n)тугруС,eman_tropria_lavirra(HSAH\n)ичоС,eman_tropria_lavirra(HSAH\n)ксмилИ-ьтсУ,eman_tropria_lavirra(HSAH\n)7,keew_fo_syad(HSAH\n)йынжЮ-овонавИ,eman_tropria_lavirra(HSAH\n)6,keew_fo_syad(HSAH )2,keew_fo_syad(HSAH",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.615621"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 628,
    "chapter": null,
    "section": "28.6 Другие типы данных",
    "text": "28.6. Другиетипыданных\n28.6. Другие типы данных\nВот еще несколько расширений,добавляющих поддержку GIN для некото-\nрыхтиповданных.\nЦелочисленныемассивы. Расширениеintarrayдобавляетклассоператоров\ngin__int_ops для целочисленных массивов. Он практически иденти-\nченстандартномуклассуоператоровarray_ops,ноподдерживаетопе-\nраторсопоставленияспоисковымзапросом@@.\nХранилище«ключ–значение». Расширение hstore реализует хранилище\nпар«ключ–значение»ипредлагаетклассоператоровgin_hstore_ops.\nИндексируютсяиключи,изначения.\nЯзыкзапросовJSON. Стороннее расширение jsquery предоставляет соб-\nственныйязыкзапросовиподдержкуGIN-индексовдляJSON.\nС принятием стандарта SQL:2016 и реализацией в PostgreSQL языка v.12\nпутейSQL/JSONстандартныевозможностивыглядятболеепредпочти-\nтельными.\n627",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.631839"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 629,
    "chapter": null,
    "section": "29.1 Общий принцип",
    "text": "29\nИндекс BRIN\n29.1. Общий принцип\nВотличиеотостальныхиндексовBRIN1предназначеннедлябыстрогопоис-\nканужныхстрок,адлятого,чтобыизбежатьпросмотразаведомоненужных.\nЭтотметоддоступасоздавалсяврасчетенатаблицыразмеромвединицыи\nдесяткитерабайт,так что меньшему объему отдается предпочтение перед\nточностьюпоиска.\nДля ускорения поиска вся таблица разбивается на зоны (range) размером\nвнесколькостраниц—отсюдаиназвание:BlockRangeIndex,BRIN.Индекс\nнехранитидентификаторыверсий,аограничиваетсялишьсводнойинфор-\nмациейоданныхвкаждойзоне.Дляпорядковыхтиповданныхвпростом\nслучаеэтоминимальноеимаксимальноезначения,норазныеклассыопе-\nраторовмогутсобиратьразнуюинформациюозначенияхвзоне.\nКоличествостраницвзонеустанавливаетсяприсозданиииндексапарамет-\n128 ромхраненияpages_per_range.\nПри выполнении запроса, содержащего условие на проиндексированный\nстолбец, можно целиком пропустить все зоны, значения в которых гаран-\nтированно не попадаютпод условие запроса.Все страницы остальных зон\nс.415 возвращаютсяиндексомввиденеточнойбитовойкарты;всестрокинаэтих\nстраницахпроверяютсянавыполнениеусловия.\nТаким образом, BRIN хорошо работает для столбцов, значения в которых\nлокализованы, то есть когда значения, хранящиеся рядом, имеют схожие\n1 postgrespro.ru/docs/postgresql/17/brin;\nbackend/access/brin/README.\n628",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.657278"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 630,
    "chapter": null,
    "section": "29.2 Пример",
    "text": "29.2. Пример\n(в смысле сводной информации) свойства. Для порядковых типов данных\nэто означает,что значениядолжны бытьфизически расположены втабли-\nцевпорядкевозрастанияилиубывания,тоестьиметьвысокуюкорреляцию с.348\nмеждуфизическимрасположениемилогическимпорядком,определяемым\nоперациями«больше»и«меньше».Длядругихтиповсводнойинформации\nтребованияк«схожимсвойствам»могутотличаться.\nНебудетошибкойрассматриватьBRINнекакиндексвобычномпонимании,\nакакускорительпоследовательногосканированиятаблицы.Можнопосмот-\nреть на него и как на аналог секционирования,если каждую зону считать\nотдельной«виртуальной»секцией.\n29.2. Пример\nВдемонстрационнойбазеданныхнетдостаточнобольшихдляBRINтаблиц,\nно можно представить,чтодля нужд аналитической отчетноститребуется\nденормализованнаятаблицасинформациейовылетевшихизаэропортаи\nприземлившихсяваэропортурейсахсточностьюдоместавсалоне.Данные\nпокаждомуаэропортудобавляютсявтаблицуразвсутки,кактольковсоот-\nветствующемчасовомпоясенаступаетполночь.Последобавленияданные\nнеизменяютсяинеудаляются.\nТаблицаимеетследующийвид:\nCREATE TABLE flights_bi(\nairport_code char(3), -- код аэропорта\nairport_coord point, -- координаты аэропорта\nairport_utc_offset interval, -- часовой пояс\nflight_no char(6), -- номер рейса\nflight_type text, -- тип рейса: вылет или прилет\nscheduled_time timestamptz, -- вылет/прилет по расписанию\nactual_time timestamptz, -- реальное время\naircraft_code char(3), -- код воздушного судна\nseat_no varchar(4), -- номер места\nfare_conditions varchar(10), -- класс обслуживания\npassenger_id varchar(20), -- номер документа пассажира\npassenger_name text -- имя пассажира\n);\n629",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.690953"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 631,
    "chapter": null,
    "section": "29.2 Пример",
    "text": "Глава29. ИндексBRIN\nПроцедуру загрузки данных можно имитировать вложенными циклами1:\nвнешний—подням(вдемобазехранятсяданныезагод),внутренний—по\nчасовымпоясам.Врезультатетакогозаполненияданныевтаблицеокажут-\nсяболееилименееупорядоченыкакминимумповремениипогеографии\nаэропортов,несмотрянаотсутствиесортировкивзапросевнутрицикла.\nЯ сразу загружу готовую копиютаблицы,занимающую примерно 4 Гбайта\nисодержащуюоколо30млнстрок2:\npostgres$ pg_restore -d demo -c flights_bi.dump\n=> ANALYZE flights_bi;\n=> SELECT count(*) FROM flights_bi;\ncount\n−−−−−−−−−−\n30517076\n(1 row)\n=> SELECT pg_size_pretty(pg_total_relation_size('flights_bi'));\npg_size_pretty\n−−−−−−−−−−−−−−−−\n4130 MB\n(1 row)\nТакойобъемданныхсложноназватьбольшим,ноегобудетдостаточно,что-\nбыизучитьработуметодаBRIN.Одининдексясоздамзаранее:\n=> CREATE INDEX ON flights_bi USING brin(scheduled_time);\n=> SELECT pg_size_pretty(pg_total_relation_size(\n'flights_bi_scheduled_time_idx'\n));\npg_size_pretty\n−−−−−−−−−−−−−−−−\n184 kB\n(1 row)\nСпараметрамипоумолчаниюонзанимаетсовсеммаломеста.\nv.13 Индекс на основе B-дерева, даже с учетом компактного хранения дубли-\nкатов,оказывается втысячу раз больше.Конечно,и эффективностьтакого\n1 edu.postgrespro.ru/internals-17/flights_bi.sql.\n2 edu.postgrespro.ru/internals-17/flights_bi.dump.\n630",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.722630"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 632,
    "chapter": null,
    "section": "29.3 Страничнаяорганизация",
    "text": "29.3. Страничнаяорганизация\nиндекса существенно выше, но для действительно больших таблиц допол-\nнительныйобъемможетоказатьсянепозволительнойроскошью.\n=> CREATE INDEX flights_bi_btree_idx ON flights_bi(scheduled_time);\n=> SELECT pg_size_pretty(pg_total_relation_size(\n'flights_bi_btree_idx'\n));\npg_size_pretty\n−−−−−−−−−−−−−−−−\n210 MB\n(1 row)\n=> DROP INDEX flights_bi_btree_idx;\n29.3. Страничная организация\nНулевая страница BRIN-индекса—метастраница с информацией о струк-\nтуреиндекса.\nС некоторым отступом от метаданных находятся страницы со сводной ин-\nформацией.Каждаяиндекснаястроканатакойстраницесодержитсводкупо\nкакой-тооднойзоне.\nМеждуметастраницейисводнымиданнымирасполагаетсякартазон(range\nmap),котораяиногданазываетсяобратнойкартой(reverserangemap,отсю-\nдапринятоесокращениеrevmap).Посути,этомассивуказателейнасоответ-\nствующиеиндексныестроки;номерпозициивмассиверавенномерузоны.\nметастраница\nrevmap\n11....1100 1111....2200 2211....3300 7711....8800 3311....4400 4411....5500 5511....6600 6611....7700\n631",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.766857"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 633,
    "chapter": null,
    "section": "29.3 Страничнаяорганизация",
    "text": "Глава29. ИндексBRIN\nПрирасширениитаблицыразмеркартызонувеличивается.Есликартапере-\nстаетпомещатьсявотведенныеейстраницы,оназахватываетследующую,\nавсеиндексныестроки,которыетамбыли,переносятсянадругиестраницы.\nПосколькунастраницепомещаетсямногоуказателей,такиеперестановки\nслучаютсяредко.\nСтраницы BRIN-индекса можно изучать,как обычно,с помощью расшире-\nнияpageinspect.Метаинформацияпоказываетразмерзоныиколичество\nстраниц,отведенныхподкартузон:\n=> SELECT pagesperrange, lastrevmappage\nFROM brin_metapage_info(get_raw_page(\n'flights_bi_scheduled_time_idx', 0\n));\npagesperrange | lastrevmappage\n−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−\n128 | 4\n(1 row)\nЗдеськартазонзанимаетчетырестраницы,спервойпочетвертую.Можно\nполучитьссылкинаиндексныезаписиосводныхданных:\n=> SELECT *\nFROM brin_revmap_data(get_raw_page(\n'flights_bi_scheduled_time_idx', 1\n));\npages\n−−−−−−−−−−\n(6,197)\n(6,198)\n(6,199)\n(6,200)\n(6,201)\n...\n(6,193)\n(6,194)\n(6,195)\n(6,196)\n(1360 rows)\nЕслизонаещенеобобщена(тоестьдлянеенетсводнойинформации),ука-\nзательвкартезонбудетпустым.\n632",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.792599"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 634,
    "chapter": null,
    "section": "29.4 Поиск",
    "text": "29.4. Поиск\nВотисамисводныеданныедлянесколькихпервыхзон:\n=> SELECT itemoffset, blknum, value\nFROM brin_page_items(\nget_raw_page('flights_bi_scheduled_time_idx', 6),\n'flights_bi_scheduled_time_idx'\n)\nORDER BY blknum\nLIMIT 3 \\gx\n−[ RECORD 1 ]−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nitemoffset | 197\nblknum | 0\nvalue | {2016−08−15 02:45:00+03 .. 2016−08−15 16:20:00+03}\n−[ RECORD 2 ]−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nitemoffset | 198\nblknum | 128\nvalue | {2016−08−15 05:50:00+03 .. 2016−08−15 18:55:00+03}\n−[ RECORD 3 ]−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nitemoffset | 199\nblknum | 256\nvalue | {2016−08−15 07:15:00+03 .. 2016−08−15 18:50:00+03}\n29.4. Поиск\nПрипоискепоусловию,котороеподдерживаетсяиндексомBRIN1,просмат-\nривается карта зон и сводная информация по каждой зоне. Если данные\nвзонемогутсоответствоватьключупоиска,всестраницызоныдобавляют-\nсякбитовойкарте.Посколькуиндекснехранитидентификаторыотдельных\nстрок,битоваякартаизначальностроитсясточностьюдостраниц.\nСоответствие данных ключу определяется с помощью опорной функции\nсогласованности,которая понимает смысл сводной информации.Конечно,\nзоныбезсводнойинформациивсегдадобавляютсякбитовойкарте.\nПолучившаясявитогебитоваякартаиспользуетсядлясканированиятабли-\nцы обычным образом.Важно,чтотабличные страницы читаются последо- с.414\nвательнымифрагментамиииспользуетсяпредвыборка.\n1 backend/access/brin/brin.c,функцияbringetbitmap.\n633",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.825678"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 635,
    "chapter": null,
    "section": "29.5 Обновление сводной информации",
    "text": "Глава29. ИндексBRIN\n29.5. Обновление сводной информации\nВставка значений\nПри добавлении новой версии строки в табличную страницу обновляется\nсводная информация в соответствующей зоне индекса1. Номер зоны вы-\nчисляется по номеру страницы простыми арифметическими действиями,\nиспомощьюкартызончитаетсясводнаяинформация.\nНужно ли расширять имеющуюся сводную информацию, решает опорная\nфункциядобавлениязначения.Еслирасширениенеобходимо,онопроисходит\nпоместу(безсозданияновойиндекснойстроки)приналичиинастранице\nдостаточногопространства.\nПусть,например,настранице13появиласьверсиястрокисозначением42.\nНомерзоны(начинаяснуля)вычисляетсяцелочисленнымделениемномера\nстраницынаразмерзоны.Считая,чторазмерзоныравенчетыремстрани-\nцам,получаемзону№3,ивкартезонберемчетвертыйпосчетууказатель.\nМинимальноезначениедляэтойзоны—31,максимальное—40.Новоезна-\nчениевыходитзаэтипределы,имаксимальноезначениеобновляется:\nметастраница\nrevmap\n11....1100 1111....2200 2211....3300 7711....8800 3311....4422 4411....5500 5511....6600 6611....7700\nЕслиобновлениепоместуневозможно,создаетсяноваястрока,итогдакар-\nтазонизменяется.\n1 backend/access/brin/brin.c,функцияbrininsert.\n634",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.869984"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 636,
    "chapter": null,
    "section": "29.5 Обновлениесводнойинформации",
    "text": "29.5. Обновлениесводнойинформации\nОбобщение зоны\nВсесказанноекасаетсяслучая,когдановаяверсиястрокипоявляетсявзоне,\nдлякоторойужеестьсводнаяинформация.Припостроениииндексаобоб-\nщаютсявсесуществующиезоны,нопридальнейшемростетаблицымогут\nпоявитьсяновыестраницы,выходящиезаэтотдиапазон.\nЕсли создать индекс с параметром хранения autosummarize,то новая зона off\nбудетобобщатьсянемедленно.Нопосколькуобычновхранилищахданных\nстрокидобавляютсянепоодной,абольшимипакетами,такойрежимможет\nсильнозамедлятьвставку.\nПо умолчанию немедленного обобщения новых зон не происходит. Это\nне нарушает корректность работы индекса, поскольку зоны без сводной\nинформации просматриваются полностью. Обобщение выполняется асин-\nхронно при очисткетаблицы,либо его можно инициировать вручную,вы- с.138\nзвав функцию brin_summarize_new_values или brin_summarize_range\n(дляотдельнойзоны).\nОбобщениезоны1неблокируетизменениеданныхвтаблице.Сначалавин-\nдекс вставляется строка-пустышка (placeholder).Если во время сканирова-\nниязоныданныепоменяются,пустышкаобновитсяибудетсодержатьсвод-\nнуюинформациюпослучившимсяизменениям.Затемданныеизэтойстро-\nкиобъединяютсясвычисленнойсводнойинформациейпозонеспомощью\nопорнойфункцииобъединения.\nПриудалениистрокизтаблицывнекоторыхслучаяхсводнаяинформация\nмоглабысжаться.НоесливGiST-индексепересчетпроисходитхотябыпри с.542\nразделении страницы, в индексах BRIN сводная информация только рас-\nширяетсяиникогданесжимается.Обычноэтогоинетребуется,поскольку\nхранилищаданныхиспользуются,какправило,толькодлядобавлениядан-\nных.Конечно,можновручнуюудалитьсводнуюинформацию,вызвавфунк-\nцию brin_desummarize_range,и заново обобщить зону.Однако нетника-\nкойподсказки,длякакихзонтакойпересчетможетбытьполезен.\n1 backend/access/brin/brin.c,функцияsummarize_range.\n635",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.905607"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 637,
    "chapter": null,
    "section": "29.6 Диапазоны значений (minmax)",
    "text": "Глава29. ИндексBRIN\nТакимобразом,BRINвпервуюочередьрассчитаннатаблицыоченьбольшо-\nгоразмера,которыелибонеобновляются,либообновляютсяоченьнезначи-\nтельно,и,соответственно,новыестрокивнихдобавляютсяпреимуществен-\nновконецфайла.Основнаяобластьегоприменения—хранилищаданных\nианалитическаяотчетность.\n29.6. Диапазоны значений (minmax)\nДлятиповданных,значениякоторыхможносравниватьмеждусобой,свод-\nная информация в самом простом случае состоитиз минимального и мак-\nсимальногозначений.Соответствующиеклассыоператоровсодержатвна-\nзваниисловоminmax1:\n=> SELECT opcname\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid\nWHERE amname = 'brin'\nAND opcname LIKE '%minmax_ops'\nORDER BY opcname;\nopcname\n−−−−−−−−−−−−−−−−−−−−−−−−\nbit_minmax_ops\nbpchar_minmax_ops\n...\ntimetz_minmax_ops\nuuid_minmax_ops\nvarbit_minmax_ops\n(26 rows)\nОпорныефункцииэтихклассовоператоров:\n=> SELECT amprocnum, amproc::regproc\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid\nJOIN pg_amproc amop ON amprocfamily = opcfamily\nWHERE amname = 'brin'\nAND opcname = 'numeric_minmax_ops'\nORDER BY amprocnum;\n1 backend/access/brin/brin_minmax.c.\n636",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.932623"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 638,
    "chapter": null,
    "section": "29.6 Диапазонызначений(minmax)",
    "text": "29.6. Диапазонызначений(minmax)\namprocnum | amproc\n−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−\n1 | brin_minmax_opcinfo\n2 | brin_minmax_add_value\n3 | brin_minmax_consistent\n4 | brin_minmax_union\n(4 rows)\nПерваяфункциявозвращаетслужебнуюинформациюоклассеоператоров,\nаостальныеяужеописывал:этофункциидобавлениязначения,согласован-\nностииобъединения.\nВклассminmaxвходяттежеоператорысравнения,чтоиспользуютсяиB-де-\nревом: с.526\n=> SELECT amopopr::regoperator, oprcode::regproc, amopstrategy\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid\nJOIN pg_amop amop ON amopfamily = opcfamily\nJOIN pg_operator opr ON opr.oid = amopopr\nWHERE amname = 'brin'\nAND opcname = 'numeric_minmax_ops'\nORDER BY amopstrategy;\namopopr | oprcode | amopstrategy\n−−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−+−−−−−−−−−−−−−−\n<(numeric,numeric) | numeric_lt | 1\n<=(numeric,numeric) | numeric_le | 2\n=(numeric,numeric) | numeric_eq | 3\n>=(numeric,numeric) | numeric_ge | 4\n>(numeric,numeric) | numeric_gt | 5\n(5 rows)\nВыбор столбцов для индексирования\nПокакимстолбцамимеетсмыслстроитьBRIN-индексстакимклассомопе-\nраторов?Яужеговорил,чтоиндексбудетхорошоработать,еслифизическое\nрасположениестроккоррелируетслогическимпорядкомзначений.\nПроверимэтонаподготовленномвышепримере.\n637",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.962888"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 639,
    "chapter": null,
    "section": "29.6 Диапазонызначений(minmax)",
    "text": "Глава29. ИндексBRIN\n=> SELECT attname, correlation, n_distinct\nFROM pg_stats\nWHERE tablename = 'flights_bi'\nORDER BY correlation DESC NULLS LAST;\nattname | correlation | n_distinct\n−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−\nactual_time | 0.9999948 | 33774\nscheduled_time | 0.9999948 | 25659\nfare_conditions | 0.79976535 | 3\nflight_type | 0.5026036 | 2\nairport_utc_offset | 0.4540325 | 11\naircraft_code | 0.16700844 | 8\nairport_code | 0.049405675 | 104\npassenger_name | 0.008537361 | 8375\npassenger_id | 0.0071185734 | 2.729408e+06\nseat_no | 0.005471666 | 460\nflight_no | −0.0002795685 | 707\nairport_coord | | 0\n(12 rows)\nДанныеупорядоченыповремени(какпоплановому,такипореальному—\nразницаеслииесть,тонесущественная),посколькудобавляютсявхроноло-\nгическомпорядке,авотсутствиеудаленийиобновленийстрокиукладыва-\nс.29 ютсявфайлосновногослоятаблицыпоследовательно,одназадругой.\nСтолбцыfare_conditions,flight_typeиairport_utc_offsetпоказыва-\nютотносительновысокуюкорреляцию,новнихслишкоммалоуникальных\nзначений.\nКорреляция остальных столбцов слишком мала,чтобы их индексирование\nспомощьюдиапазонногоклассаоператоровпредставлялоинтерес.\nРазмер зоны и эффективностьпоиска\nПодсказкойдляопределенияподходящегоразмеразоныможетпослужить\nколичествостраниц,накоторыхвстречаютсязначения.\nРассмотримвремяпорасписаниюscheduled_timeипредположим,чтоза-\nпросы выбираютданные по рейсам за сутки. Посчитаем,сколько страниц\nзанимаютвтаблицеоднисутки.\n638",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:17.995831"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 640,
    "chapter": null,
    "section": "29.6 Диапазонызначений(minmax)",
    "text": "29.6. Диапазонызначений(minmax)\nДляэтогомывоспользуемсятем,чтоидентификаторверсиистрокисостоит\nизномерастраницыисмещения.Ксожалению,нетштатногоспособаразло-\nжитьидентификаторнадвеегосоставляющие,поэтомупридетсянаписать\nнекрасивую функцию, приводящую типы через текстовое представление:\n=> CREATE FUNCTION tid2page(t tid) RETURNS integer\nLANGUAGE sql\nRETURN (t::text::point)[0]::integer;\nТеперьможнопосмотретьраспределениесутокпотаблице:\n=> SELECT min(numblk), round(avg(numblk)) avg, max(numblk)\nFROM (\nSELECT count(distinct tid2page(ctid)) numblk\nFROM flights_bi\nGROUP BY scheduled_time::date\n) t;\nmin | avg | max\n−−−−−−+−−−−−−+−−−−−−\n1195 | 1456 | 1554\n(1 row)\nВидно,чтораспределениенесовсемравномерное.Пристандартномразме-\nре зоны в 128 страниц каждые сутки будут занимать от 9 до 12 зон. Полу-\nчаяинформациюзаоднисутки,сканированиезахватиткакнужныестроки,\nтакичастьстрок,относящихсякдругимсуткам,нопопавшихвтежезоны.\nЧем больше размер зоны,тем больше будет прочитано лишних погранич-\nных значений; уменьшая или увеличивая размер зоны, можно увеличить\nилиуменьшитьихколичество.\nПопробуем выполнить запрос, взяв какой-нибудь один день (индекс с па-\nраметрами по умолчанию я уже создал выше). Для упрощения картины я\nотключупараллельноевыполнение:\n=> SET max_parallel_workers_per_gather = 0;\n=> \\set d '2016-08-15 02:45:00+03'\n=> EXPLAIN (analyze, buffers, costs off, timing off, summary off)\nSELECT *\nFROM flights_bi\nWHERE scheduled_time >= :'d'::timestamptz\nAND scheduled_time < :'d'::timestamptz + interval '1 day';\n639",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.031399"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 641,
    "chapter": null,
    "section": "29.6 Диапазонызначений(minmax)",
    "text": "Глава29. ИндексBRIN\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on flights_bi (actual rows=81964 loops=1)\nRecheck Cond: ((scheduled_time >= '2016−08−15 02:45:00+03'::ti...\nRows Removed by Index Recheck: 11606\nHeap Blocks: lossy=1536\nBuffers: shared hit=1561\n−> Bitmap Index Scan on flights_bi_scheduled_time_idx\n(actual rows=15360 loops=1)\nIndex Cond: ((scheduled_time >= '2016−08−15 02:45:00+03'::...\nBuffers: shared hit=25\nPlanning:\nBuffers: shared hit=1\n(11 rows)\nМожно определить коэффициент полезного действия BRIN-индекса для\nнекоторого запроса как отношение количества страниц, которые удалось\nпропустить при индексном сканировании, к общему количеству страниц\nв таблице.При нулевом КПД индексный доступ вырождается в последова-\nс.424 тельное сканирование (если не учитывать накладные расходы).Чем выше\nКПД,тем меньше страниц приходится читать. Но часть страниц содержат\nискомые данные, которые никак нельзя пропустить, поэтому КПД всегда\nменьшеединицы.\nВданномслучаеКПДсоставляет528417−1561 ≈0,997,где528417—количество\n528417\nстраницвтаблице.\nОднако бессмысленноделатькакие-то выводы по одному значению.Даже\nпри равномерных исходных данных и идеальной корреляции эффектив-\nностьбудетотличатьсякакминимумиз-затого,чтограницызонбудутрас-\nположены по-разному.Полную картину можно получить,лишьрассматри-\nваяКПДкакслучайнуювеличинуиизучаяеераспределение.\nДля нашего примера можно взять все различные сутки за год, проверить\nпланвыполнениядлякаждогозначенияирассчитатьстатистическиепока-\nзателипополучившейсявыборке.Процесснетрудноавтоматизировать,вос-\nпользовавшисьтем,чтокомандаEXPLAIN можетвыдаватьрезультатвфор-\nматеJSON,удобномдляобработки.Янебудуприводитьполныйкод,носле-\nдующийнебольшойфрагментсодержитвсесущественныедетали.\n640",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.069280"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 642,
    "chapter": null,
    "section": "29.6 Диапазонызначений(minmax)",
    "text": "29.6. Диапазонызначений(minmax)\n=> DO $$\nDECLARE\nplan jsonb;\nBEGIN\nEXECUTE\n'EXPLAIN (analyze, buffers, timing off, costs off, format json)\nSELECT * FROM flights_bi\nWHERE scheduled_time >= $1\nAND scheduled_time < $1 + interval ''1 day'''\nUSING '2016-08-15 02:45:00+03'::timestamptz\nINTO plan;\nRAISE NOTICE 'shared hit=%, read=%',\nplan -> 0 -> 'Plan' ->> 'Shared Hit Blocks',\nplan -> 0 -> 'Plan' ->> 'Shared Read Blocks';\nEND;\n$$;\nNOTICE: shared hit=1561, read=0\nDO\nРезультаты можно представить наглядно с помощью диаграммы размаха,\nименуемой также «ящиком с усами». Усы обозначают первый и четвер-\nтый квартиль (то есть в правый ус попадают 25% наибольших значений,\nавлевый—25%наименьших).Ящиксоставляютоставшиеся50%значений;\nвнемтакжеотмеченамедиана.Чтоважно,такоекомпактноеизображение\nпозволяетнаглядно сравниватьмежду собой результаты.На рисунке пока-\nзанораспределениеКПДкакдляразмеразоныпоумолчанию,такидлядвух\nдругихзначений,отличающихсяотнеговчетырераза:\n32с./зону,\n529Кб\n128с./зону,\n184Кб\n512с./зону,\n72Кб\nКПД\n0,990 0,992 0,994 0,996 0,998 1,000\nКакиследовалоожидать,точностьиэффективностьпоискавысокидажедля\nдовольнобольшойзоны.\n641",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.099708"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 643,
    "chapter": null,
    "section": "29.6 Диапазонызначений(minmax)",
    "text": "Глава29. ИндексBRIN\nНарисункепунктиромотмеченосреднеезначениемаксимальновозможно-\nгоКПДдляэтогозапросаисходяизтого,чтооднисуткизанимаютпримерно\n1 частьтаблицы.\n365\nОбратитевнимание,чтоэффективностьрастетнебесплатно:вместесней\nувеличиваетсяиразмериндекса.BRINдовольногибкопозволяетнаходить\nкомпромиссмеждуоднимидругим.\nСвойства\nСвойства BRIN постоянны и не зависят от конкретного класса операторов.\nСвойстваметодадоступа\n=> SELECT a.amname, p.name, pg_indexam_has_property(a.oid, p.name)\nFROM pg_am a, unnest(array[\n'can_order', 'can_unique', 'can_multi_col',\n'can_exclude', 'can_include'\n]) p(name)\nWHERE a.amname = 'brin';\namname | name | pg_indexam_has_property\n−−−−−−−−+−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−\nbrin | can_order | f\nbrin | can_unique | f\nbrin | can_multi_col | t\nbrin | can_exclude | f\nbrin | can_include | f\n(5 rows)\nСортировкаиподдержкауникальности,разумеется,отсутствуют.Из-затого,\nчтоиндексBRINвсегдавозвращаетбитовуюкарту,нетподдержкииограни-\nченийисключения.Дополнительныеinclude-столбцытожелишенысмысла,\nпосколькувиндексенехранятсядажесамиключииндексирования.\nАвотсоздатьсоставнойBRIN-индексможно.Вэтомслучаесводнаяинфор-\nмацияпокаждомустолбцусобираетсяисохраняетсявотдельнойиндексной\nстроке,нопривязкакзонамостаетсяобщей.Такойиндексимеетсмысл,ес-\nлидлявсехстолбцовподходитодинитотжеразмерзоны.\nВкачествеальтернативысоставномуиндексуможносоздатьBRIN-индексы\nс.417 поотдельнымстолбцамипользоватьсятем,чтобитовыекартымогутком-\nбинироваться.\n642",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.131514"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 644,
    "chapter": null,
    "section": "29.6 Диапазонызначений(minmax)",
    "text": "29.6. Диапазонызначений(minmax)\nНапример:\n=> CREATE INDEX ON flights_bi USING brin(airport_utc_offset);\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT *\nFROM flights_bi\nWHERE scheduled_time >= :'d'::timestamptz\nAND scheduled_time < :'d'::timestamptz + interval '1 day'\nAND airport_utc_offset = '08:00:00';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on flights_bi (actual rows=1658 loops=1)\nRecheck Cond: ((scheduled_time >= '2016−08−15 02:45:00+03'::ti...\nRows Removed by Index Recheck: 14077\nHeap Blocks: lossy=256\n−> BitmapAnd (actual rows=0 loops=1)\n−> Bitmap Index Scan on flights_bi_scheduled_time_idx (act...\nIndex Cond: ((scheduled_time >= '2016−08−15 02:45:00+0...\n−> Bitmap Index Scan on flights_bi_airport_utc_offset_idx ...\nIndex Cond: (airport_utc_offset = '08:00:00'::interval)\n(9 rows)\nНарядусB-деревьямиBRIN-индексыдлябольшихтаблицмогутсоздаваться v.17\nпараллельно. Таблица сканируется несколькими процессами,которые рас- с.538\nсчитываютсводнуюинформациюпосвоейчастиданных.Этаинформация\nсортируетсяпозонам(выделяетсяпамятьразмеромmaintenance_work_mem), 64MB\nзатемведущийпроцессагрегируетееиформируетиндекс1.\nСвойстваиндекса\n=> SELECT p.name, pg_index_has_property(\n'flights_bi_scheduled_time_idx', p.name\n)\nFROM unnest(array[\n'clusterable', 'index_scan', 'bitmap_scan', 'backward_scan'\n]) p(name);\nname | pg_index_has_property\n−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−\nclusterable | f\nindex_scan | f\nbitmap_scan | t\nbackward_scan | f\n(4 rows)\n1 backend/access/brin/brin.c,функцияbrinbuild.\n643",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.169658"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 645,
    "chapter": null,
    "section": "29.6 Диапазонызначений(minmax)",
    "text": "Глава29. ИндексBRIN\nОчевидно,чтоподдерживаетсятолькосканированиепобитовойкарте.\nОтсутствиекластеризацииможетвызватьнекотороенедоумение.Казалось\nбы,разBRIN-индексчувствителенкфизическомупорядкустрок,тологич-\nнобылобыиуметьперестраиватьпорядок,максимизируяэффективность\nиндекса.Новлюбомслучаекластеризациябольшихтаблиц—слишкомдо-\nрогоеудовольствие,учитываяобъемнеобходимойработыирасходместана\nдискенавремяперестроения.Ктомуже,какпоказываетпримерстаблицей\nflights_bi,некотораяупорядоченностьвхранилищахданныхможетвоз-\nникатьестественнымобразом.\nСвойствастолбцов\n=> SELECT p.name, pg_index_column_has_property(\n'flights_bi_scheduled_time_idx', 1, p.name\n)\nFROM unnest(array[\n'orderable', 'distance_orderable', 'returnable',\n'search_array', 'search_nulls'\n]) p(name);\nname | pg_index_column_has_property\n−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\norderable | f\ndistance_orderable | f\nreturnable | f\nsearch_array | f\nsearch_nulls | t\n(5 rows)\nИзсвойствуровнястолбцанедоступноничего,кромевозможностиработы\nснеопределеннымизначениями.НаличиеNULLвзонеучитываетсяотдель-\nнымпризнакомвсводнойинформации:\n=> SELECT hasnulls, allnulls, value\nFROM brin_page_items(\nget_raw_page('flights_bi_airport_utc_offset_idx', 6),\n'flights_bi_airport_utc_offset_idx'\n)\nWHERE itemoffset= 1;\nhasnulls | allnulls | value\n−−−−−−−−−−+−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−\nf | f | {03:00:00 .. 03:00:00}\n(1 row)\n644",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.203293"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 646,
    "chapter": null,
    "section": "29.7 Мультидиапазоны значений (minmax-multi)",
    "text": "29.7. Мультидиапазонызначений(minmax-multi)\n29.7. Мультидиапазоны значений (minmax-multi)\nv.14\nСложившуюсякорреляциюлегконарушить,изменяяданные.Делоздесьне\nв изменении какого-то конкретного значения,а в устройстве многоверси-\nонности:стараяверсиястрокиудаляетсянаоднойстранице,ановаяможет с.80\nбытьвставленакудаугодно,гденайдетсясвободноеместо.Из-заэтогопри\nобновленияхверсиистрокперемешиваются.\nОтчасти с этим явлением можно бороться,уменьшая значение параметра\nхраненияfillfactor,чтобыоставитьзапасместанастраницеподбудущиеоб-\nновления.Воттолькозахочетсялиувеличиватьобъемибезтогоогромной\nтаблицы? Ктому же остаются удаления,которые освобождаютместо внут-\nри существующих страниц итаким образом готовят«ловушки» для новых\nстрок,которыеиначепопалибывконецфайла.\nТакуюситуациюнесложносмоделировать.Сначалаудалим0,1%случайных\nстрокивыполнимочистку,чтобыосвободитьместодляновыхверсий:\n=> WITH t AS (\nSELECT ctid\nFROM flights_bi TABLESAMPLE BERNOULLI(0.1) REPEATABLE(0)\n)\nDELETE FROM flights_bi\nWHERE ctid IN (SELECT ctid FROM t);\nDELETE 30122\n=> VACUUM flights_bi;\nЗатемдобавимвтаблицуновыйденьдляодногоизчасовыхпоясов.Япросто\nскопируюданныепредыдущихсуток,увеличивденьнаединицу:\n=> INSERT INTO flights_bi\nSELECT airport_code, airport_coord, airport_utc_offset,\nflight_no, flight_type, scheduled_time + interval '1 day',\nactual_time + interval '1 day', aircraft_code, seat_no,\nfare_conditions, passenger_id, passenger_name\nFROM flights_bi\nWHERE date_trunc('day', scheduled_time) = '2017-08-15'\nAND airport_utc_offset = '03:00:00';\nINSERT 0 40531\n645",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.240905"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 647,
    "chapter": null,
    "section": "29.7 Мультидиапазоны значений (minmax-multi)",
    "text": "Глава29. ИндексBRIN\nКоличества удаленных строк достаточно, чтобы в каждой или почти каж-\nдойзонеоказалисьсвободныеместа.Новыестроки,попадаявовнутренние\nстраницы,автоматическирасширилидиапазонызначений.Вотсводнаяин-\nформация по первой зоне,и если раньше она охватывала неполные сутки,\nтотеперь—целыйгод:\n=> SELECT value\nFROM brin_page_items(\nget_raw_page('flights_bi_scheduled_time_idx', 6),\n'flights_bi_scheduled_time_idx'\n)\nWHERE blknum = 0;\nvalue\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n{2016−08−15 02:45:00+03 .. 2017−08−16 16:15:00+03}\n(1 row)\nЧем меньшедата,используемая в запросе,тем больше зон придется пере-\nбрать.Диаграммапоказываетмасштаббедствия:\n128с./зону,\n248Кб\nКПД\n0 0,1 0,2 0,3 0,4 0,5 0,6 0,7 0,8 0,9 1\nДлярешенияэтойпроблемынеобходимоусложнитьсводнуюинформацию:\nвместо одного непрерывного диапазона хранить несколько, суммарно по-\nкрывающихвсезначения.Тогдаодиндиапазонсможетохватитьосновной\nнаборданных,адругие—отдельныевыбросы.\nИменно такую возможность и реализуют классы операторов, содержащих\nвсвоемназванииminmax_multi1:\n=> SELECT opcname\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid\nWHERE amname = 'brin'\nAND opcname LIKE '%minmax_multi_ops'\nORDER BY opcname;\n1 backend/access/brin/brin_minmax_multi.c.\n646",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 2,
        "content": "|"
      }
    ],
    "extracted_at": "2025-10-02T16:00:18.277776"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 648,
    "chapter": null,
    "section": "29.7 Мультидиапазонызначений(minmax-multi)",
    "text": "29.7. Мультидиапазонызначений(minmax-multi)\nopcname\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\ndate_minmax_multi_ops\nfloat4_minmax_multi_ops\nfloat8_minmax_multi_ops\n...\ntimestamp_minmax_multi_ops\ntimestamptz_minmax_multi_ops\ntimetz_minmax_multi_ops\nuuid_minmax_multi_ops\n(19 rows)\nПосравнениюсклассамиоператоровminmaxкопорнымфункциямдобав-\nляетсяещеоднадлявычислениярасстояниямеждудвумязначениями—она\nнеобходимадляопределениядлиныдиапазона,которуюклассоператоров\nстараетсяминимизировать:\n=> SELECT amprocnum, amproc::regproc\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid\nJOIN pg_amproc amop ON amprocfamily = opcfamily\nWHERE amname = 'brin'\nAND opcname = 'numeric_minmax_multi_ops'\nORDER BY amprocnum;\namprocnum | amproc\n−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\n1 | brin_minmax_multi_opcinfo\n2 | brin_minmax_multi_add_value\n3 | brin_minmax_multi_consistent\n4 | brin_minmax_multi_union\n5 | brin_minmax_multi_options\n11 | brin_minmax_multi_distance_numeric\n(6 rows)\nСамиоператоры,составляющиетакиеклассы,ровнотеже,чтоидляклассов\nminmax.\nМультидиапазонные классы могут принимать параметр values_per_range, 32\nопределяющиймаксимальноеколичествосводныхзначенийдляоднойзо-\nны.Дляпредставлениядиапазонатребуетсядвазначения,адляотдельной\nточки — одно. При нехватке значений часть интервалов «схлопывается»1.\n1 backend/access/brin/brin_minmax_multi.c,функцияreduce_expanded_ranges.\n647",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.311503"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 649,
    "chapter": null,
    "section": "29.7 Мультидиапазонызначений(minmax-multi)",
    "text": "Глава29. ИндексBRIN\nПостроиммультидиапазонныйиндексвместосуществующего.Дляпримера\nограничимся16своднымизначениями:\n=> DROP INDEX flights_bi_scheduled_time_idx;\n=> CREATE INDEX ON flights_bi USING brin(\nscheduled_time timestamptz_minmax_multi_ops(\nvalues_per_range = 16\n)\n);\nДиаграмма показывает,что эффективностьпоиска с новым индексом вер-\nнуласькстарымзначениям—конечно,ценойувеличенияразмераиндекса:\nminmax-multi\n656Кб\nminmax\n184Кб\nКПД\n0,990 0,992 0,994 0,996 0,998 1,000\n29.8. Охватывающие значения (inclusion)\nРазница между диапазонными и охватывающими классами операторов\nпримернотакая же,как между B-деревьями и GiST: последние предназна-\nченыдлятиповданных,ккоторымнеприменимыоперациисравнения,но\nдля которых имеет смысл взаимное расположение. Сводная информация\nохватывающих классов операторов представлена областью, ограничиваю-\nщейвсевходящиевзонузначения.\nВотэтиклассыоператоров,ихнемного:\n=> SELECT opcname\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid\nWHERE amname = 'brin'\nAND opcname LIKE '%inclusion_ops'\nORDER BY opcname;\n648",
    "tables": [
      {
        "table_index": 0,
        "rows": 1,
        "cols": 2,
        "content": "|"
      }
    ],
    "extracted_at": "2025-10-02T16:00:18.342620"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 650,
    "chapter": null,
    "section": "29.8 Охватывающиезначения(inclusion)",
    "text": "29.8. Охватывающиезначения(inclusion)\nopcname\n−−−−−−−−−−−−−−−−−−−−−\nbox_inclusion_ops\ninet_inclusion_ops\nrange_inclusion_ops\n(3 rows)\nКопорнымфункциямдобавляетсяфункцияслияниядвухзначенийинеко-\nтороеколичествонеобязательныхфункций:\n=> SELECT amprocnum, amproc::regproc\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid\nJOIN pg_amproc amop ON amprocfamily = opcfamily\nWHERE amname = 'brin'\nAND opcname = 'box_inclusion_ops'\nORDER BY amprocnum;\namprocnum | amproc\n−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−\n1 | brin_inclusion_opcinfo\n2 | brin_inclusion_add_value\n3 | brin_inclusion_consistent\n4 | brin_inclusion_union\n11 | bound_box\n13 | box_contain\n(6 rows)\nЕсли про значения, совместимые с операторами сравнения, мы могли де-\nлатьвыводынаосновестатистикипокорреляции,тодлядругихтиповдан-\nныхтакая статистика не собирается1.Поэтому сложно заранее спрогнози-\nровать,насколькохорошобудетработатьохватывающийBRIN-индекс.\nХуже того, от корреляции существенно зависит оценка стоимости индекс-\nногосканирования.Еслитакаястатистикаотсутствует,онасчитаетсяравной\nнулю2.Поэтомусейчаспланировщикникакнеразличаетточныеинеточные\ninclusion-индексыи,какправило,отказываетсяотихиспользования.\nPostGISсобираетстатистикупокорреляциидляпространственныхданных. v.3.1.1\n1 backend/commands/analyze.c,функцияcompute_scalar_stats.\n2 backend/utils/adt/selfuncs.c,функцияbrincostestimate.\n649",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.373311"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 651,
    "chapter": null,
    "section": "29.8 Охватывающиезначения(inclusion)",
    "text": "Глава29. ИндексBRIN\nВ нашем примере мы можем предположить, что индекс по координатам\nаэропортов имеетсмысл,поскольку долгота должна коррелировать с часо-\nвымпоясом.\nВотличиеотпредикатовGiSTсводныезначенияBRINимеюттотжетип,что\nииндексируемыеданные,поэтомупростотакнеудастсяпостроитьиндекс\nдляточек.Номыможемсоздатьиндексповыражению,преобразовавточки\nввырожденныепрямоугольники:\n=> CREATE INDEX ON flights_bi USING brin(box(airport_coord))\nWITH (pages_per_range = 8);\n=> SELECT pg_size_pretty(pg_total_relation_size(\n'flights_bi_box_idx'\n));\npg_size_pretty\n−−−−−−−−−−−−−−−−\n3816 kB\n(1 row)\nИндекспочасовымпоясамсзонойтакогожеразмеразанимаетпримерно\nтотжеобъем—3288Кбайт.\nОператоры, входящие в класс, соответствуют операторам GiST-классов.\nНапример,спомощьюиндексаможноускорятьпоискточеквзаданнойоб-\nласти:\n=> SELECT airport_code, airport_name\nFROM airports\nWHERE box(coordinates) <@ box '135,45,140,50';\nairport_code | airport_name\n−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−\nKHV | Хабаровск−Новый\n(1 row)\nНо,какяиговорил,планировщикотказываетсяиспользоватьиндексбезот-\nключенияпоследовательногосканирования:\n=> EXPLAIN (costs off)\nSELECT *\nFROM flights_bi\nWHERE box(airport_coord) <@ box '135,45,140,50';\n650",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.404079"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 652,
    "chapter": null,
    "section": "29.9 ФильтрыБлума(bloom)",
    "text": "29.9. ФильтрыБлума(bloom)\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nSeq Scan on flights_bi\nFilter: (box(airport_coord) <@ '(140,50),(135,45)'::box)\n(2 rows)\n=> SET enable_seqscan = off;\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT *\nFROM flights_bi\nWHERE box(airport_coord) <@ box '135,45,140,50';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on flights_bi (actual rows=511404 loops=1)\nRecheck Cond: (box(airport_coord) <@ '(140,50),(135,45)'::box)\nRows Removed by Index Recheck: 721565\nHeap Blocks: lossy=21216\n−> Bitmap Index Scan on flights_bi_box_idx (actual rows=212160...\nIndex Cond: (box(airport_coord) <@ '(140,50),(135,45)'::box)\n(6 rows)\n=> RESET enable_seqscan;\n29.9. Фильтры Блума (bloom)\nv.14\nКлассы операторов, построенные на фильтрах Блума, позволяют исполь-\nзовать BRIN с любымитипами данных,для которых определена операция\n«равно» и имеется хеш-функция.Пригодятся они и для обычных порядко-\nвыхтиповвситуациях,когдазначениялокализованывотдельныхзонах,но\nприэтомрасположениенекоррелируетслогическимпорядком.\nНазваниятакихклассовоператоровсодержатсловоbloom1:\n=> SELECT opcname\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid\nWHERE amname = 'brin'\nAND opcname LIKE '%bloom_ops'\nORDER BY opcname;\n1 backend/access/brin/brin_bloom.c.\n651",
    "tables": [
      {
        "table_index": 0,
        "rows": 3,
        "cols": 1,
        "content": "=> SET enable_seqscan = off;\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT *\nFROM flights_bi\nWHERE box(airport_coord) <@ box '135,45,140,50';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on flights_bi (actual rows=511404 loops=1)\nRecheck Cond: (box(airport_coord) <@ '(140,50),(135,45)'::box)\nRows Removed by Index Recheck: 721565\nHeap Blocks: lossy=21216\n−> Bitmap Index Scan on flights_bi_box_idx (actual rows=212160...\nIndex Cond: (box(airport_coord) <@ '(140,50),(135,45)'::box)\n(6 rows)\n=> RESET enable_seqscan;"
      }
    ],
    "extracted_at": "2025-10-02T16:00:18.441504"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 653,
    "chapter": null,
    "section": "29.9 ФильтрыБлума(bloom)",
    "text": "Глава29. ИндексBRIN\nopcname\n−−−−−−−−−−−−−−−−−−−−−−−\nbpchar_bloom_ops\nbytea_bloom_ops\nchar_bloom_ops\n...\ntimestamptz_bloom_ops\ntimetz_bloom_ops\nuuid_bloom_ops\n(24 rows)\nКлассическийфильтрБлума—структураданных,позволяющаябыстропро-\nверить принадлежность элемента множеству.Фильтр очень компактен,но\nдопускаетложноположительныесрабатывания(falsepositive),тоестьможет\nприписать множеству лишние элементы.Важно,что ложноотрицательных\nсрабатываний(falsenegative)бытьнеможет:фильтрнеимеетправарешить,\nчтоэлементанетвмножестве,еслинасамомделеонтамприсутствует.\nФильтр представляет собой битовый массив (называемый также сигнату-\nрой)длинойmбит,изначальнозаполненныйнулями.Выбираютсяkразлич-\nных хеш-функций,которые отображаютлюбой элементмножества в k бит\nсигнатуры.Добавлениеэлементакмножествусводитсякустановкевсигна-\nтурекаждогоизэтихбитоввединицу.Следовательно,есливсесоответству-\nющие элементу биты установлены в единицу,элемент может присутство-\nватьв множестве; если хотя бы один из этих битов равен нулю—элемент\nточноотсутствует.\nВ случае BRIN-индекса фильтр работает с множеством значений индекси-\nруемогостолбца,содержащихсявопределеннойзоне;своднаяинформация\nэтойзоныпредставляетсяпостроеннымфильтромБлума.\nРасширение bloom1 предоставляет самостоятельный индексный метод доступа,ос-\nнованный на фильтрах Блума. В нем фильтр строится для каждой строки табли-\nцы и работаетс множеством значений столбцов этой строки.Такой индекс рассчи-\nтаннаиндексациюсразунесколькихстолбцовиполезендляadhoc-запросов,когда\nнеизвестно,накакиеименностолбцыбудутнакладыватьсяусловия.BRIN-индексто-\nже можно создатьпо нескольким столбцам,но в этом случае сводная информация\nбудетсодержать несколько независимыхфильтров Блума для каждого из столбцов.\n1 postgrespro.ru/docs/postgresql/17/bloom.\n652",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.477979"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 654,
    "chapter": null,
    "section": "29.9 ФильтрыБлума(bloom)",
    "text": "29.9. ФильтрыБлума(bloom)\nТочностьфильтра Блума зависитотдлины сигнатуры.Теория говорит,что\nоптимальноеколичествобитовсигнатурыможнооценитькакm =\n−nlog 2p\n,\nln2\nгдеn—числоэлементовмножества,аp—вероятностьложногосрабатыва-\nнияфильтра.\nЭтидвазначенияивынесенывпараметрыклассаоператоров:\n• n_distinct_per_range—число элементов множества; в нашем случае это −0.1\nколичество уникальных значений индексируемого столбца в одной\nзоне.Значения интерпретируются так же,как статистика уникальных\nзначений:отрицательныечислапоказываютдолюотчисластроквзоне, с.338\nанеабсолютноеколичество.\n• false_positive_rate—вероятностьложноположительныхсрабатываний. 0.01\nВероятность, близкая к нулю, говорит о том, что индексное сканиро-\nваниенебудетзаглядыватьвзоны,гденетискомыхзначений.Ноона\nне гарантируетточность поиска,поскольку в просматриваемых зонах,\nпомимо нужных значений, будут находиться и «лишние» строки. Это\nопределяется не свойствами фильтра,а шириной зоны и физическим\nрасположениемданных.\nКопорнымфункциямклассаоператоровдобавляетсяфункциявычисления\nхеш-кода:\n=> SELECT amprocnum, amproc::regproc\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid\nJOIN pg_amproc amop ON amprocfamily = opcfamily\nWHERE amname = 'brin'\nAND opcname = 'numeric_bloom_ops'\nORDER BY amprocnum;\namprocnum | amproc\n−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−\n1 | brin_bloom_opcinfo\n2 | brin_bloom_add_value\n3 | brin_bloom_consistent\n4 | brin_bloom_union\n5 | brin_bloom_options\n11 | hash_numeric\n(6 rows)\n653",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.511210"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 655,
    "chapter": null,
    "section": "29.9 ФильтрыБлума(bloom)",
    "text": "Глава29. ИндексBRIN\nПоскольку фильтр Блума основан на хешировании,единственный поддер-\nживаемыйоператор—операторравенства:\n=> SELECT amopopr::regoperator, oprcode::regproc, amopstrategy\nFROM pg_am am\nJOIN pg_opclass opc ON opcmethod = am.oid\nJOIN pg_amop amop ON amopfamily = opcfamily\nJOIN pg_operator opr ON opr.oid = amopopr\nWHERE amname = 'brin'\nAND opcname = 'numeric_bloom_ops'\nORDER BY amopstrategy;\namopopr | oprcode | amopstrategy\n−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−+−−−−−−−−−−−−−−\n=(numeric,numeric) | numeric_eq | 1\n(1 row)\nВкачествепримеравозьмемстолбецсномеромрейсаflight_no,имеющий\nоколонулевуюкорреляциюипоэтомубезнадежныйдляобычногодиапазон-\nногоклассаоператоров.Настройкувероятностиложногосрабатыванияме-\nнятьнебудем,аколичествоуникальныхзначенийвзонеможновычислить.\nНапример,длявосьмистраничнойзоныполучим:\n=> SELECT max(nd)\nFROM (\nSELECT count(distinct flight_no) nd\nFROM flights_bi\nGROUP BY tid2page(ctid) / 8\n) t;\nmax\n−−−−−\n26\n(1 row)\nДлязонменьшегоразмераэтоколичествобудетещеменьше(влюбомслу-\nчаеклассоператоровнепринимаетзначения,меньшие16).\nОстаетсясоздатьиндексипроверитьпланвыполнениязапроса:\n=> CREATE INDEX ON flights_bi USING brin(\nflight_no bpchar_bloom_ops(\nn_distinct_per_range = 22)\n)\nWITH (pages_per_range = 8);\n654",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.542865"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 656,
    "chapter": null,
    "section": "29.9 ФильтрыБлума(bloom)",
    "text": "29.9. ФильтрыБлума(bloom)\n=> EXPLAIN (analyze, costs off, timing off, summary off)\nSELECT *\nFROM flights_bi\nWHERE flight_no = 'PG0001';\nQUERY PLAN\n−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−\nBitmap Heap Scan on flights_bi (actual rows=5197 loops=1)\nRecheck Cond: (flight_no = 'PG0001'::bpchar)\nRows Removed by Index Recheck: 127510\nHeap Blocks: lossy=2240\n−> Bitmap Index Scan on flights_bi_flight_no_idx (actual rows=...\nIndex Cond: (flight_no = 'PG0001'::bpchar)\n(6 rows)\n=> RESET max_parallel_workers_per_gather;\nИз диаграммы видно,что для некоторых номеров рейсов (показанных от-\nдельнымиточкамивнеусов)индексработаетнеоченьхорошо,новцелом\nегоэффективностьдовольновысока:\n2с./зону,\n14,8Мб\n4с./зону,\n7,4Мб\n8с./зону,\n3,7Мб\nКПД\n0,70 0,75 0,80 0,85 0,90 0,95 1,00\n655",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.571772"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 657,
    "chapter": null,
    "section": "29.9 ФильтрыБлума(bloom)",
    "text": "Заключение\nЧто ж,пришло время подвести черту.Надеюсь,эта книга оказалась полез-\nнойилихотябыинтересной.Возможно,выузналиизнеечто-тоновое(во\nвсякомслучаея,покаписал,узналмногое).\nХотябо́льшаячастьинформации,скореевсего,будетактуальнаещедоволь-\nнодолго,отдельныедетали устареваютс неумолимой быстротой.Поэтому\nнаиболее ценным из того,что можно вынести из этой книги,я считаю не\nнабор конкретных фактов, а подход к изучению системы. Не надо верить\nна слово ни мне,ни даже документации.Обдумывайте,экспериментируй-\nте,проверяйтевсесведениясамостоятельно.ВPostgreSQLдляэтогоестьвсе\nинструменты,иястаралсяпоказать,какимипользоваться.Вбольшинстве\nслучаевэтонесложнее,чемзадатьвопросвчатеилипогуглитьответ,зато\nнамногонадежнееиполезнее.\nС этой же целью я хотел побудитьвас заглядыватьв код.Открытый исход-\nныйкод—огромноеблаго,непренебрегайтеэтойвозможностью.Непере-\nживайте,чтоничегонепоймете,простопопробуйте.\nБудурад,есливыподелитесьсвоимивпечатлениямиизамечаниями.Пиши-\nте на edu@postgrespro.ru.Я планирую регулярно обновлять книгу,так что\nваши комментарии могут помочь улучшить ее.Самая свежая электронная\nверсия книги находится в свободном доступе на postgrespro.ru/education/\nbooks/internals.\nУдачи!\n656",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.594739"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 658,
    "chapter": null,
    "section": "29.9 ФильтрыБлума(bloom)",
    "text": "Предметный указатель\nA autovacuum_vacuum_scale_factor\nAggregate 364–365 137\nAppend 379,469 autovacuum_vacuum_threshold 137\nautoprewarmleader 197–199 autovacuum_work_mem 136\nautoprewarmmaster 197\nB\nautoprewarmworker 199\nbgwriter 216,240\nautosummarize 635\nbgwriter_delay 220\nautovacuum 135\nbgwriter_lru_maxpages 220,222\nautovacuumlauncher 135–136\nbgwriter_lru_multiplier. 220\nautovacuumworker 135\nBison 310\nautovacuum_analyze_scale_factor\nBitmapHeapScan 353,415,418,420\n138–139\nBitmapIndexScan 353,414,418,\nautovacuum_analyze_threshold\n420,423\n138–139\nBitmapAnd 417\nautovacuum_enabled 126,136\nbloom 652\nautovacuum_freeze_max_age 155,\nBRIN 628\n160–162\nклассоператоров 633,636,\nautovacuum_freeze_min_age 161\n646,649–650,653\nautovacuum_freeze_table_age 161\nКПД 640\nautovacuum_max_workers 135–136,\nсвойства 642\n145,148\nстраницы 631\nautovacuum_multixact_freeze_max_age\nbtree_gin 621\n264\nbtree_gist 558,573\nautovacuum_naptime 135–136\nB-дерево 513,558,598,601,621\nautovacuum_vacuum_cost_delay\nклассоператоров 526,604,\n144–145,148,161\n637\nautovacuum_vacuum_cost_limit\nсвойства 537\n144–145,148\nстраницы 519\nautovacuum_vacuum_insert_scale_factor\n138 C\nautovacuum_vacuum_insert_threshold checkpoint_completion_target\n138 217–218\n657",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.619543"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 659,
    "chapter": null,
    "section": "29.9 ФильтрыБлума(bloom)",
    "text": "Предметныйуказатель\ncheckpointer 209 E\ncheckpoint_timeout 217–218,222 effective_cache_size 407–408\ncheckpoint_warning 221 effective_io_concurrency 415\nclient_encoding 617 enable_bitmapscan 406\nClog 85,161,202,206,209 enable_hashjoin 476,478\ncminиcmax 104 enable_memoize 440\nenable_parallel_hash 459,462\ncommit_delay 225\nenable_seqscan 280,406,619,650\ncommit_siblings 225\ncpu_index_tuple_cost 405\nF\ncpu_operator_cost 364,405,\nfalse_positive_rate 653\n450–451,475,481,490\nfastupdate 286,610\ncpu_tuple_cost 363,365,405,438,\nfdatasync 230\n450–451,475,481\nfillfactor 111–112,119,123,152,\nCTEScan 377\n155,166,290,504,543,\nctid 78,116\n577,645\ncube 572\nFinalizeAggregate 370\ncursor_tuple_fraction 323,332 FinalizeGroupAggregate 493\nFlex 310\nfrom_collapse_limit 318–321\nD\nfsync 230\ndata_checksums 231\nfull_page_writes 233,236\ndeadlock_timeout 277,285,300\nfuzzystrmatch 596\ndebug_io_direct 180\ndebug_parallel_query 376\nG\ndebug_print_parse 311\nGather 366,368–371,376,489–492\ndebug_print_plan 314\nGatherMerge 489–491\ndebug_print_rewritten 312\ngeqo 320\ndeduplicate_items 524\ngeqo_threshold 320\nDeduplication см.исключение gevel 581\nдубликатов GIN 598\ndefault_statistics_target 334, классоператоров 599,603,\n342–343,346,357 618,622\ndefault_table_access_method 358 отложенноеобновление 286,\ndefault_text_search_config 564 610\ndefault_toast_compression 36 свойства 613\ndefault_transaction_isolation 73 страницы 601\n658",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.648439"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 660,
    "chapter": null,
    "section": "29.9 ФильтрыБлума(bloom)",
    "text": "Предметныйуказатель\ngin_fuzzy_search_limit 613 L\ngin_pending_list_limit 610 lock_timeout 275\nGiST 540,648 log_autovacuum_min_duration 148\nклассоператоров 541,546, log_checkpoints 221\n650 logical 237,241\nсвойства 559,571 log_lock_waits 300\nстраницы 545 log_temp_files 455,486\nGroupAggregate 492 ltree 573\nH\nM\nHash 446,450,455,501\nmaintenance_io_concurrency 415\nклассоператоров 509\nmaintenance_work_mem 131,136,\nсвойства 510\n145,147,538,611,643\nстраницы 502\nMaterialize 429,431–432,437,439\nHashJoin 446,449–450,455\nmax_connections 248,292\nHashAggregate 468–469,492\nmax_locks_per_transaction 248\nhash_mem_multiplier 437,447,461,\nmax_parallel_maintenance_workers\n469\n538\nHOT-обновление 116,523\nmax_parallel_processes 197\nhstore 573,627\nmax_parallel_workers 371\nI max_parallel_workers_per_gather\nidle_in_transaction_session_timeout 371–373\n173 max_pred_locks_per_page 292\nignore_checksum_failure 232 max_pred_locks_per_relation 293\nIncrementalSort 488 max_pred_locks_per_transaction\nIndexOnlyScan 410 292–293\nIndexScan 401–403,406,433,435 max_wal_senders 237\nInitPlan 340,377,379 max_wal_size 218,222\nintarray 573,627 max_worker_processes 135,371\nMemoize 437–440,495\nJ\nMergeJoin 472\njoin_collapse_limit 318–321\nminimal 229,237,241\nJSON 622,627\nmin_parallel_index_scan_size 132\njsquery 627\nmin_parallel_table_scan_size 372\nK min_wal_size 219\nk-мерноедерево 588 MixedAggregate 493\n659",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.677062"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 661,
    "chapter": null,
    "section": "29.9 ФильтрыБлума(bloom)",
    "text": "Предметныйуказатель\nmultixact_member_buffers 262 PGDATA 23\nmultixact_offset_buffers 262 pg_dump 109\npg_prewarm 197\nN pg_prewarm.autoprewarm 197\nn_distinct_per_range 653 pg_prewarm.autoprewarm_interval\nNestedLoop 314,427,429,433,438 197\nNestedLoopAntiJoin 441 pg_rewind 203\nNestedLoopLeftJoin 427,440 pgrowlocks 263,281\nNestedLoopSemiJoin 443 pgstattuple 166–167\nNULL см.неопределенное pg_test_fsync 230\nзначение pg_trgm 573,596,616\npg_visibility 127,154\nO\npg_wait_sampling 302\nOID 25\npg_wait_sampling.profile_period 303\npg_waldump 207,216,234\nP\npg_walinspect 207,234,238\npageinspect 75,79,83,90,153,205,\nplan_cache_mode 331\n260,503,545,581,601,632\npostgres 39\npages_per_range 628\npostmaster 39–41,135,213,215,\nParallelAppend 378–379\n366\nParallelBitmapHeapScan 423\nProcArray 85,99\nParallelHash 461\npsql 17,21,25,96,301,307\nParallelHashJoin 461\nParallelIndexOnlyScan 423,460\nQ\nParallelIndexScan 422\nQuadtree 576\nParallelSeqScan 367–368\nparallel_leader_participation 366, R\n368 random_page_cost 363,406,419\nparallel_setup_cost 369,490 RD-дерево 565\nparallel_tuple_cost 369,490 ReadCommitted 51–56,59–60,63,\nparallel_workers 372 65,73–74,97,105–106,\nPartialAggregate 369–370 110,128,269\nPartialGroupAggregate 493 ReadUncommitted 51–54\npgbench 227,233,303 RepeatableRead 52–54,63–65,\npg_buffercache 181,195 67–68,70,72–74,97,106,\npg_checksums 230 110,163,269,289\npg_controldata 213 replica 237,240–241\n660",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.706512"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 662,
    "chapter": null,
    "section": "29.9 ФильтрыБлума(bloom)",
    "text": "Предметныйуказатель\nRTE 311 transaction_timeout 173\nRUM 616\nR-дерево 542 U\nUnique 492\nS\nsearch_path 26 V\nseg 572 vacuum_buffer_usage_limit 191\nSeqScan 314,362,364–365 vacuum_cost_delay 144,161\nseq_page_cost 363,406,419,458 vacuum_cost_limit 144–145\nSerializable 52–53,70,72–74,97, vacuum_cost_page_dirty 144\n106,110,269,289,294, vacuum_cost_page_hit 144\n375,396 vacuum_cost_page_miss 144\nshared_buffers 194 vacuum_failsafe_age 155,162\nshared_preload_libraries 197,302 vacuum_freeze_min_age 154–156,\nSort 477–479,481,490,492–493 159,162\nSP-GiST 574 vacuum_freeze_table_age 155,\nклассоператоров 575,577, 157–159\n591 vacuum_index_cleanup 162\nсвойства 586,595 vacuum_multixact_failsafe_age 264\nстраницы 581 vacuum_multixact_freeze_min_age\nstartup 213–214 264\nstatement_timeout 275 vacuum_multixact_freeze_table_age\nSubPlan 378 264\nsubtransaction_buffers 92 vacuum_truncate 133\nSuffixtruncation см.исключение values_per_range 647\nчастиатрибутов\nW\nsynchronous_commit 225–227\nWAL см.журналпредзаписи\nT wal_buffers 204\ntemp_buffers 200 wal_compression 233\ntemp_file_limit 200,453 wal_keep_size 220\nTidScan 402 wal_level 237\nTOAST 25,33,90,191 wal_log_hints 233\ntrack_commit_timestamp 99 wal_recycle 219\ntrack_counts 135 wal_segment_size 206\ntrack_io_timing 188 walsender 224,237\ntransaction_buffers 85 wal_skip_threshold 237–238\n661",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.734656"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 663,
    "chapter": null,
    "section": "29.9 ФильтрыБлума(bloom)",
    "text": "Предметныйуказатель\nwal_sync_method 230 Блок см.страница\nwalwriter 226 Блокировка 53,245,382\nwal_writer_delay 226 безожидания 174,274\nwal_writer_flush_after 226 впамяти 181\nWindowAgg 479 версиистроки 265\nwork_mem 20,326,415–417,420, легкая 296\n429,437,447,455,459, неотношения 283\n461–462,469,480 номератранзакции 249\nотношения 133,166,171,239,\nX\n251\nxminиxmax 78,80,84,87,98,150,\nочередь 254,264,271\n258,264\nповышениеуровня 258,292\nА предикатная 288\nАгрегация 364,369 расширенияотношения 285\nсортировкой 490 рекомендательная 286\nхешированием 468,490 спин 295\nАнализ 134,334,415,503\nстраницы 286\nАномалия\nстроки 174,258\nгрязногочтения 48,50,55\nтранш 297\nнеповторяющегосячтения\nтяжелая 248,259\n51,56,63\nБуферноекольцо 190,361\nнесогласованногочтения 58,\nБуферныйкеш 40,179,202,209,\n61,65\n296,361,382,407\nнесогласованнойзаписи 67,\nвытеснение 188\n70,289\nлокальный 199,379\nпотерянногообновления 50,\nнастройка 194\n61–62\nтолькочитающей\nВ\nтранзакции 68,71,289\nВерсиястроки 77\nфантомногочтения 51,63,\nтолькодобавление 132,138\n288\nВерхнийключ 520,522,601\nАтомарность 49,94\nВетвьвремени 207\nБ Взаимоблокировка 248,276,\nБазаданных 23 285–286\nБиты-подсказки см. Видимость 98,104,361,382,401,\nинформационныебиты 410\n662",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.760610"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 664,
    "chapter": null,
    "section": "29.9 ФильтрыБлума(bloom)",
    "text": "Предметныйуказатель\nВиртуальнаятранзакция 91,106, З\n250 Заголовок\nВложеннаятранзакция 92,209 версии 78,258\nВнедрениеSQL-кода 329 страницы 75,127\nВнешнийключ 260–261,433 Закреплениебуфера 181,184,298\nВосстановление 213 Замо́к см.блокировка\nВыравнивание 79 Заморозка 151,170,185,264\nВытеснение 188,205,217 вручную 162\n«Звездочка»,причиныне\nГ использовать 38,448,486\nГистограмма 343\nГоризонт 105–106,111,128,173, И\n412 Идентификаторверсии 77,381,\nГранулярность 246 600\nГрафожиданий 276 Изменчивостьфункций 60,389,\nГруппировка 467,492 400\nГрязноечтение 48,50,55 Изоляция 49\nнаосновеснимков 54,70,97,\nД 258\nДекартовопроизведение 426,428 Индекс 381,387\nДемобаза 307,543,629 версионность 89\nДерево обеспечениецелостности\nнесбалансированное 574 393,395,511,537,556,\nплана 314 559,586\nпрефиксное 131,590 очистка 123,508,519,524,611\nразбора 310 повыражению 351,388,650\nсбалансированное 514,518, покрывающий 395,409,412,\n540,598 538,559,586\nсигнатурное 566 составной 394,532,536–537,\nДиаграммаразмаха 641 559,614,642\nДолговечность 49 статистика 351\nуникальный 260,393,395,\nЖ 516,523,537\nЖурналпредзаписи 41,201,298, упорядоченность 392,398,\n359,382 513,528,532,536–537\nуровни 236 частичный 399\n663",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.784104"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 665,
    "chapter": null,
    "section": "29.9 ФильтрыБлума(bloom)",
    "text": "Предметныйуказатель\nИндексированиямеханизм 382, М\n391 Массив 573,618,627\nИнформационныебиты 78,83, Материализация 377,429,437\n86,98,233,258 Методдоступа\nИсключение индексный 381,444\nдубликатов 523,599 свойства 391\nчастиатрибутов 525 табличный 358\nИсполнениезапроса 325,329 Многоверсионность 54,77,123,\n523\nМультитранзакция 262\nК\nпереполнениесчетчика 264\nКардинальность 323,333,408\nсоединения 433\nКарта Н\nбитовая 131,414,502,628, Неопределенноезначение 78,\n633,642 337,399,536,539,560,\nвидимости 32,112,125,154, 587,644\n156,170,410 Неповторяющеесячтение 51,56,\nзаморозки 32,154,158,170 63\nНеравномерноераспределение\nнеопределенныхзначений\n340,455,504\n78\nНесогласованнаязапись 67,70,\nсвободногопространства 31,\n289\n112,125\nНесогласованноечтение 58,61,\nКлассоператоров 384,444,599\n65\nопорнаяфункция 389\nпараметры 569,647,653\nКластербазданных 23 О\nКомбо-номер 104 Обрывтранзакции 88,92,94,268,\nКонтрольнаяточка 209,229 289\nмониторинг 221 Ограничениецелостности 47\nнастройка 217 Ожидание 300\nКоррелированныепредикаты неучтенноевремя 301,304\n324,353 семплирование 302\nКорреляция 348,403,414,629, Опорнаяфункция 389\n637,649 Оптимизация см.планирование\nКурсор 104,185,322,332,375 Отношение 28\n664",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.807599"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 666,
    "chapter": null,
    "section": "29.9 ФильтрыБлума(bloom)",
    "text": "Предметныйуказатель\nОчистка 106,185,334,382,412, Потерянноеобновление 50,\n508,635 61–62\nавтоматическая 134,277 Правило\nагрессивныйрежим 157 перезаписи 313\nвнутристраничная 111,119, сортировки 386,591\n123,519,524 Привязкапараметров 328\nмониторинг 145,168 Протоколзапросов 42\nобычная 125 простой 310\nполная 166 расширенный 327\nэтапы 131 Процесс 39\nобслуживающий 41\nП Путьпоиска 26\nПакетнаяобработка 174,275\nПараллельноевыполнение 366, Р\n371,422,444,459,476, Разборзапроса 310\n489,492 Раздувание 108,123,173,360,\nограничения 375 363,508,518,523,542\nПереписывание см. Расщепление\nтрансформация корзины 501,505\nПереполнениесчетчика страницы 516,518,555,584,\nтранзакций 150,159 610\nПерепроверка 382,402,416,563, Ресурсноеголодание 265,271\n570,587,620\nПланвыполнения 314 С\nобщийичастный 330 Сегмент 28,206\nПланирование 314,329 Селективность 323,362\nПодготовказапроса 327 соединения 433\nПоискближайшихсоседей 398, Семействооператоров 389\n550,561,588 Семплированиеожиданий 302\nПолнотекстовыйпоиск 562 Сервер 23\nиндексирование 563,599 Сигнатура 566,652\nранжирование 616 Синхронизация 225,229\nфразовый 615 Системныйкаталог 24,239,311\nчастичный 606 Сканирование\nПолучениерезультата 332 индексное 291,397,401,512,\nПортал 325 538,560,586\n665",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.831692"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 667,
    "chapter": null,
    "section": "29.9 ФильтрыБлума(bloom)",
    "text": "Предметныйуказатель\nоценкастоимости 362,367, слиянием 472,532\n402,411,418,649 сравнениеспособов 494\nпараллельноеиндексное 422 хешированием 446,452\nпараллельное Сортировка 398,472–473,478,\nпоследовательное 367 513,528,532,536\nпобитовойкарте 397,414, быстрая 480\n512,538,560,586,612,644 внешняя 483\nпоследовательное 290,361\nинкрементальная 487\nспропусками 534\nпараллельная 489\nсравнениеметодов 424\nпирамидальная 481\nтолькоиндекса 335,398,409,\nСпециальнаяобласть 76\n561,568,587,595\nСтатистика 134,323\nСлияние 472,483,489\nбазовая 333,410\nСлой 28\nгистограмма 343,475\nвидимости 32,112,125,154,\nдлянескалярныхтипов 347\n156,170,410\nдоляNULL 337\nинициализации 30\nкорреляция 348,403,637,649\nосновной 29,77,638\nмноговариантная 352\nсвободногопространства 31,\nповыражению 349,357\n112,125\nразмерполя 348\nСнимок 97,100,239\nрасширенная 350\nдлякаталога 108\nуникальныезначения 338,\nэкспорт 109\n354,638\nСогласованность 47,49\nчастыезначения 340,356,\nСоединение\n435,455\nанти-иполу- 427,441\nСтоимость 316,322,325\nвложеннымциклом 428\nСтраница 33,502\nвнешнее 426,440,474\nгрязная 181\nвнутреннее 426\nоценкастоимости 430,436, заголовок 163,170\n438,449,458,474,480, полныйобраз 213\n482,486,489–490 предвыборка 415\nпараллельным расщепление 123,516,518,\nхешированием 460,462 555,584,610\nпараметризованное 432 фрагментация 78,113\nпорядок 314,316,448,474 Схема 25\n666",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.858245"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 668,
    "chapter": null,
    "section": "29.9 ФильтрыБлума(bloom)",
    "text": "Предметныйуказатель\nТ Усечение 133\nТабличноепространство 26\nФ\nТолькочитающейтранзакции\nФантомноечтение 51,63,288\nаномалия 68,71,289\nФиксациятранзакции 85,205,\nТочкасохранения 92\n269\nТранзакция 48,81,97\nасинхронная 226\nблокировканомера 249\nсинхронная 225\nвиртуальная 91,106,250\nФильтрБлума 566,651\nвложенная 92,209\nФоноваязапись 216\nвозраст 150\nнастройка 220\nобрыв 88,92,94,289\nФоновыйрабочийпроцесс 132,\nпереполнениесчетчика 150,\n135,371\n159\nстатус 99,206\nХ\nфиксация 85,205,269\nХеш-индекс см.Hash\nТрансформация 312\nХеш-таблица 182,296,298,438,\nТриграммы 616\n446,501\nТупик см.взаимоблокировка\nЭ\nУ Эквисоединение 426,465,474,\nУказательнаверсиюстроки 77, 501\n113,127 Экземплярсервера 23\n667",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.873397"
  },
  {
    "pdf_file": "postgresql_internals-17.pdf",
    "page_number": 669,
    "chapter": null,
    "section": "29.9 ФильтрыБлума(bloom)",
    "text": "Книгииздательства«ДМКПресс»\nможнокупитьоптомиврозницунаскладеиздательства\nпоадресу:г.Москва,ул.Электродная,д.2,стр.12,офис7,\nтел.+7(499)322-19-38,\nатакжезаказатьнасайтеwww.dmkpress.com\nсдоставкойвлюбойрегионРФ.\nРоговЕгорВалерьевич\nPostgreSQL 17 изнутри\nПриподдержкеPostgresProfessional\nhttps://postgrespro.ru\nГлавныйредактор МовчанД.А.\nЗам.главногоредактора ЯценковВ.С.\neditor@dmkpress.com\nЛитературныйредактор МантроваЛ.В.\nКорректор СиняеваГ.И.\nФормат70×1001/ .Печатьцифровая.\n16\nГарнитурыПТ(Паратайп)иДвеКруглых(ЮрийГордон).\nУсл.печ.л.54,3.Тираж200экз.\nВеб-сайтиздательства:www.dmkpress.com",
    "tables": [],
    "extracted_at": "2025-10-02T16:00:18.886623"
  }
]