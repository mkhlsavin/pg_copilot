{
  "test_name": "Core Agents Test - 30 Questions",
  "total_questions": 30,
  "valid_queries": 30,
  "validity_rate": 100.0,
  "avg_generation_time": 4.110315910975138,
  "avg_enrichment_coverage": 0.44166666666666665,
  "total_test_time": 125.1068115234375,
  "query_patterns": {
    "has_tag_filter": 14,
    "has_name_filter": 24,
    "has_file_filter": 7,
    "has_where_clause": 0,
    "uses_method": 10,
    "uses_call": 13,
    "uses_file": 6,
    "has_artifacts": 0,
    "avg_query_length": 84.6
  },
  "results": [
    {
      "question": "How does PostgreSQL handle visibility checks for BRIN index entries to ensure consistency with MVCC semantics?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "mvcc",
        "keywords": [
          "index",
          "visibility",
          "brin",
          "BRIN",
          "mvcc",
          "MVCC"
        ],
        "confidence": 0.8400000000000001,
        "question_length": 110,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.7628448406855265,
        "avg_cpgql_similarity": 0.2798998863356356,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.75,
      "query": "cpg.call.name(\"brin*\").tag.nameExact(\"function-purpose\").valueExact(\"transaction-management\").l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0010395050048828125,
        "retrieval": 0.3546133041381836,
        "enrichment": 0.0,
        "generation": 5.611006259918213
      }
    },
    {
      "question": "What mechanism in PostgreSQL's elog.c handles assertion failures during execution, and how does it interact with error reporting?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "wal",
        "keywords": [
          "execution",
          "log"
        ],
        "confidence": 0.52,
        "question_length": 129,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.8856585621833801,
        "avg_cpgql_similarity": 0.26794863279410946,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.75,
      "query": "cpg.method.name(\"elog\").tag.nameExact(\"function-purpose\").valueExact(\"logging\").l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0,
        "retrieval": 0.0782461166381836,
        "enrichment": 0.0,
        "generation": 3.783968687057495
      }
    },
    {
      "question": "How does transactional invalidation for pg_class differ from non-transactional invalidation, and why is it critical?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "mvcc",
        "keywords": [
          "transaction",
          "pg_class"
        ],
        "confidence": 0.52,
        "question_length": 116,
        "has_code_terms": true
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.7158522804578146,
        "avg_cpgql_similarity": 0.17005464501009185,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.75,
      "query": "cpg.method.name(\"transactional_invalidation\").call.name(\"pg_class\").argument.isIdentifier.l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0,
        "retrieval": 0.025148868560791016,
        "enrichment": 0.0005197525024414062,
        "generation": 3.6891467571258545
      }
    },
    {
      "question": "What specific code changes were made to the bgw_library_name field definition in PostgreSQL 17?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "general",
        "keywords": [
          "bgw_library_name"
        ],
        "confidence": 0.22999999999999998,
        "question_length": 95,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.7482446233431498,
        "avg_cpgql_similarity": 0.2110586258086875,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.0,
      "query": "cpg.call.name(\"define\").argument.order(1).codeExact(\"bgw_library_name\").l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0,
        "retrieval": 0.01978588104248047,
        "enrichment": 0.0,
        "generation": 3.2547926902770996
      }
    },
    {
      "question": "What code-level optimizations were introduced to track catalog-modifying transactions more efficiently in PostgreSQL 17?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "wal",
        "keywords": [
          "optimization",
          "transaction",
          "log"
        ],
        "confidence": 0.5700000000000001,
        "question_length": 120,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.7415331403414408,
        "avg_cpgql_similarity": 0.3064536929130554,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.75,
      "query": "cpg.method.name(\".*transaction.*\").tag.nameExact(\"function-purpose\").valueExact(\"logging\").code(\".*catalog.*\").l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0,
        "retrieval": 0.0253140926361084,
        "enrichment": 0.0,
        "generation": 4.1723997592926025
      }
    },
    {
      "question": "What role does parse_type.c play in resolving SQL type specifications to internal TypeIds during query parsing in PostgreSQL?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "security",
        "keywords": [
          "parse_type",
          "role",
          "SQL"
        ],
        "confidence": 0.5700000000000001,
        "question_length": 125,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.8628300428390503,
        "avg_cpgql_similarity": 0.3118204556416694,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.125,
      "query": "cpg.file.name(\"parse_type.c\").method.name(\".*resolve.*type.*\").call.name(\".*TypeId.*\").l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0005197525024414062,
        "retrieval": 0.0628666877746582,
        "enrichment": 0.0,
        "generation": 3.9199397563934326
      }
    },
    {
      "question": "What modifications were made to PostgreSQL's write-ahead logging (WAL) system in version 17 to improve crash recovery performance?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "wal",
        "keywords": [
          "gin",
          "performance",
          "write-ahead",
          "wal",
          "recovery",
          "log",
          "WAL"
        ],
        "confidence": 0.8999999999999999,
        "question_length": 130,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.8577894767125448,
        "avg_cpgql_similarity": 0.23667667797198635,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.75,
      "query": "cpg.method.name(\".*wal.*\").tag.nameExact(\"function-purpose\").valueExact(\"logging\").l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0,
        "retrieval": 0.022002220153808594,
        "enrichment": 0.0,
        "generation": 5.6839375495910645
      }
    },
    {
      "question": "Why do test failures occur when modifying psql's output format without updating `parallel_schedule`?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "parallel",
        "keywords": [
          "parallel",
          "parallel_schedule"
        ],
        "confidence": 0.52,
        "question_length": 100,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.6715785463651022,
        "avg_cpgql_similarity": 0.27630254101770196,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.75,
      "query": "cpg.method.name(\"parallel_schedule\").parameter.l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0,
        "retrieval": 0.025636911392211914,
        "enrichment": 0.0,
        "generation": 3.0538439750671387
      }
    },
    {
      "question": "What role does line 206 in `backend/access/gist/gistget.c` play in PostgreSQL's GIST index scan traversal logic?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "indexes",
        "keywords": [
          "index",
          "gist",
          "role",
          "GIST",
          "log"
        ],
        "confidence": 0.79,
        "question_length": 112,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.8369337916374207,
        "avg_cpgql_similarity": 0.28365633487701414,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.875,
      "query": "cpg.file(\"backend/access/gist/gistget.c\").line(206).tag.nameExact(\"function-purpose\").valueExact(\"indexing\").l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0,
        "retrieval": 0.08201169967651367,
        "enrichment": 0.0,
        "generation": 4.475359678268433
      }
    },
    {
      "question": "What is the purpose of the MultiXact insert member operation at backend/access/transam/multixact.c:423, and how does it handle transaction ID conflicts?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "mvcc",
        "keywords": [
          "ID",
          "transaction"
        ],
        "confidence": 0.52,
        "question_length": 152,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.8062892953554789,
        "avg_cpgql_similarity": 0.10691643953323364,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.75,
      "query": "cpg.method.name(\"MultiXactInsertMember\").call.name(\"TransactionIdSet\").argument.filter(_.code.startsWith(\"TransactionId\")).toList",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0019838809967041016,
        "retrieval": 0.0830378532409668,
        "enrichment": 0.0,
        "generation": 4.276408433914185
      }
    },
    {
      "question": "How does PostgreSQL's partition pruning work during query planning?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "partition",
        "keywords": [
          "partition",
          "pruning",
          "plan"
        ],
        "confidence": 0.6900000000000001,
        "question_length": 67,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.9228565891583761,
        "avg_cpgql_similarity": 0.1483004743237173,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.125,
      "query": "cpg.call.name(\"pg_partition_prune\").argument.codeExact(\"relation\").l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0,
        "retrieval": 0.025283098220825195,
        "enrichment": 0.0,
        "generation": 3.059293270111084
      }
    },
    {
      "question": "In PostgreSQL 17's `pg_rewind` utility, how does `file_ops.c:303` handle reconciliation of data files between diverged clusters?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "general",
        "keywords": [
          "pg_rewind",
          "file_ops"
        ],
        "confidence": 0.28,
        "question_length": 128,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.8388442198435465,
        "avg_cpgql_similarity": 0.2537057876586914,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.0,
      "query": "cpg.call(\"pg_rewind\").file(\"file_ops.c\").line(303).method.name(\"reconcile_data_files\").argument.isIdentifier.l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0,
        "retrieval": 0.04303479194641113,
        "enrichment": 0.0,
        "generation": 4.216825723648071
      }
    },
    {
      "question": "How are parallel workers managed across different phases of the vacuum process (e.g., heap scan, index bulk-delete)?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "parallel",
        "keywords": [
          "index",
          "parallel",
          "worker",
          "vacuum",
          "heap"
        ],
        "confidence": 0.79,
        "question_length": 116,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.7770278851191202,
        "avg_cpgql_similarity": 0.20844857698519528,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.75,
      "query": "cpg.method.name(\"vacuum\").tag.nameExact(\"function-purpose\").valueExact(\"parallel-processing\").call.name(\"heap_scan\").l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0,
        "retrieval": 0.13297104835510254,
        "enrichment": 0.0,
        "generation": 6.137781858444214
      }
    },
    {
      "question": "What are the key differences between initial and subsequent HOT chain pruning operations?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "partition",
        "keywords": [
          "pruning",
          "HOT"
        ],
        "confidence": 0.52,
        "question_length": 89,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.478890319665273,
        "avg_cpgql_similarity": 0.11749638781553695,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.125,
      "query": "cpg.call.name(\"HOT_chain_pruning\").argument.l.tag.nameExact(\"Feature\").valueExact(\"Partitioning\").l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0005071163177490234,
        "retrieval": 0.03290557861328125,
        "enrichment": 0.0,
        "generation": 3.8459267616271973
      }
    },
    {
      "question": "What code modifications were required in PostgreSQL 17 to support the `%S` prompt token for `search_path`?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "general",
        "keywords": [
          "search_path"
        ],
        "confidence": 0.22999999999999998,
        "question_length": 106,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.7780759731928507,
        "avg_cpgql_similarity": 0.2776801109313965,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.0,
      "query": "cpg.call.name(\"set_config\").argument.code(\"search_path\").code(\"'%S'\").l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0,
        "retrieval": 0.07800555229187012,
        "enrichment": 0.0,
        "generation": 5.18870735168457
      }
    },
    {
      "question": "How does PostgreSQL handle 64-bit integer type portability across platforms like Illumos?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "general",
        "keywords": [],
        "confidence": 0.18,
        "question_length": 89,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.8303338487943014,
        "avg_cpgql_similarity": 0.2958322882652283,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.0,
      "query": "cpg.type.name(\"int64\").ast.isLiteral.code(\"64\").l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0010151863098144531,
        "retrieval": 0.028899669647216797,
        "enrichment": 0.0,
        "generation": 4.767884969711304
      }
    },
    {
      "question": "How does PostgreSQL 17 implement partition pruning logic during query planning using the `partprune.c` module?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "partition",
        "keywords": [
          "partition",
          "pruning",
          "plan",
          "log"
        ],
        "confidence": 0.74,
        "question_length": 110,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.913374662399292,
        "avg_cpgql_similarity": 0.21318278103828064,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.125,
      "query": "cpg.call.name(\"partprune\").method.tag.nameExact(\"Feature\").valueExact(\"Partitioning\").l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0,
        "retrieval": 0.040903568267822266,
        "enrichment": 0.0,
        "generation": 3.573320150375366
      }
    },
    {
      "question": "What is the purpose of the `geo_ops.c` file in PostgreSQL's source code, and how does it contribute to geometric data type operations?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "extension",
        "keywords": [
          "geo_ops",
          "contrib"
        ],
        "confidence": 0.52,
        "question_length": 134,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.8415853381156921,
        "avg_cpgql_similarity": 0.16904699802398682,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.0,
      "query": "cpg.file.name(\"geo_ops.c\").l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0,
        "retrieval": 0.05773425102233887,
        "enrichment": 0.0,
        "generation": 4.072375059127808
      }
    },
    {
      "question": "How does PostgreSQL's add_paths_to_append_rel function handle startup costs for append relations in version 17?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "query-planning",
        "keywords": [
          "relation",
          "add_paths_to_append_rel",
          "cost"
        ],
        "confidence": 0.5700000000000001,
        "question_length": 111,
        "has_code_terms": true
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.8051136136054993,
        "avg_cpgql_similarity": 0.18474854354990006,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.875,
      "query": "cpg.method.name(\"add_paths_to_append_rel\").tag.nameExact(\"function-purpose\").valueExact(\"query-optimization\").l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0009968280792236328,
        "retrieval": 0.07302141189575195,
        "enrichment": 0.0,
        "generation": 3.7252988815307617
      }
    },
    {
      "question": "What is the role of `heapam.c:3418` in handling heap table scans for partitioned tables during query execution?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "query-planning",
        "keywords": [
          "execution",
          "partition",
          "role",
          "heap"
        ],
        "confidence": 0.62,
        "question_length": 111,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.8547554612159729,
        "avg_cpgql_similarity": 0.2540421962738037,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.875,
      "query": "cpg.call(\"heapam.c:3418\").tag.nameExact(\"function-purpose\").valueExact(\"query-optimization\").l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0,
        "retrieval": 0.02024054527282715,
        "enrichment": 0.0,
        "generation": 4.199578523635864
      }
    },
    {
      "question": "What specific arithmetic operation or data type handling logic occurs at backend/utils/adt/numeric.c:6538 in PostgreSQL 17?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "wal",
        "keywords": [
          "log"
        ],
        "confidence": 0.47,
        "question_length": 123,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.856233020623525,
        "avg_cpgql_similarity": 0.34500529766082766,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.75,
      "query": "cpg.file(\"backend/utils/adt/numeric.c\").line(6538).astChildren.codeExact(\"arith\").l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0005354881286621094,
        "retrieval": 0.026476144790649414,
        "enrichment": 0.0,
        "generation": 4.009775400161743
      }
    },
    {
      "question": "What is the significance of runtime partition pruning in PostgreSQL's EXPLAIN output model?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "partition",
        "keywords": [
          "partition",
          "pruning",
          "EXPLAIN"
        ],
        "confidence": 0.6900000000000001,
        "question_length": 91,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.7727916240692139,
        "avg_cpgql_similarity": 0.1400092465268235,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.125,
      "query": "cpg.call.name(\"EXPLAIN\").tag.nameExact(\"Feature\").valueExact(\"Partitioning\").l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0,
        "retrieval": 0.044615983963012695,
        "enrichment": 0.0,
        "generation": 3.641740322113037
      }
    },
    {
      "question": "What is the role of line 1732 in bufmgr.c for buffer replacement policy in PostgreSQL 17?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "memory",
        "keywords": [
          "role",
          "buffer"
        ],
        "confidence": 0.52,
        "question_length": 89,
        "has_code_terms": true
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.7703987161318461,
        "avg_cpgql_similarity": 0.30096615050661607,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.625,
      "query": "cpg.file(\"bufmgr.c\").line(1732).call.tag.nameExact(\"function-purpose\").valueExact(\"memory-management\").l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0,
        "retrieval": 0.025806188583374023,
        "enrichment": 0.0,
        "generation": 4.016417026519775
      }
    },
    {
      "question": "Why is it important to add CHECK_FOR_INTERRUPTS() in BuildRelationExtStatistics during ANALYZE operations?",
      "analysis": {
        "intent": "code-analysis",
        "domain": "vacuum",
        "keywords": [
          "analyze",
          "relation",
          "ANALYZE",
          "statistics"
        ],
        "confidence": 0.72,
        "question_length": 106,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.7333211898803711,
        "avg_cpgql_similarity": 0.319606626033783,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.875,
      "query": "cpg.call.name(\"BuildRelationExtStatistics\").tag.nameExact(\"function-purpose\").valueExact(\"maintenance\").l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0005238056182861328,
        "retrieval": 0.02478766441345215,
        "enrichment": 0.0,
        "generation": 3.6904115676879883
      }
    },
    {
      "question": "Why was `time_to_stop` retained in the archiver's loop despite simplifications?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "background",
        "keywords": [
          "archiver",
          "time_to_stop"
        ],
        "confidence": 0.52,
        "question_length": 79,
        "has_code_terms": true
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.6957456270853678,
        "avg_cpgql_similarity": 0.14452544450759888,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.25,
      "query": "cpg.method.name(\"archiver_loop\").ast.isCall.name(\"time_to_stop\").l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0,
        "retrieval": 0.07479310035705566,
        "enrichment": 0.0,
        "generation": 3.2441298961639404
      }
    },
    {
      "question": "What role does `parse_utilcmd.c:969` play in handling partition-related utility commands during table creation or modification?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "parallel",
        "keywords": [
          "partition",
          "parse_utilcmd",
          "role"
        ],
        "confidence": 0.5700000000000001,
        "question_length": 127,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.8818108042081197,
        "avg_cpgql_similarity": 0.15638320731170147,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.75,
      "query": "cpg.call(\"parse_utilcmd.c:969\").tag.nameExact(\"function-purpose\").valueExact(\"parallel-processing\").l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0005245208740234375,
        "retrieval": 0.04148983955383301,
        "enrichment": 0.0,
        "generation": 3.9383418560028076
      }
    },
    {
      "question": "How does PostgreSQL 17's libpq handle connection attempts when multiple hosts with weights are specified in a connection string?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "general",
        "keywords": [],
        "confidence": 0.18,
        "question_length": 128,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.7765886584917704,
        "avg_cpgql_similarity": 0.2615894801175842,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.0,
      "query": "cpg.call.name(\"PQconnectdb\").argument.l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0,
        "retrieval": 0.06502938270568848,
        "enrichment": 0.0,
        "generation": 4.153662919998169
      }
    },
    {
      "question": "What mechanisms does PostgreSQL 17 use to optimize query performance for partitioned tables?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "parallel",
        "keywords": [
          "partition",
          "performance"
        ],
        "confidence": 0.52,
        "question_length": 92,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.8965582450230917,
        "avg_cpgql_similarity": 0.1276428568230612,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.75,
      "query": "cpg.call.methodFullName(\"pg_partition_ancestor\").argument.l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0005211830139160156,
        "retrieval": 0.08291125297546387,
        "enrichment": 0.0,
        "generation": 3.2564337253570557
      }
    },
    {
      "question": "What is the purpose of the `pgevent.c` file in PostgreSQL 17's source tree, and how does it interface with event-driven mechanisms?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "general",
        "keywords": [],
        "confidence": 0.18,
        "question_length": 131,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.755557914574941,
        "avg_cpgql_similarity": 0.2437563123242869,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.0,
      "query": "cpg.file.name(\"pgevent.c\").astParent.isFunction.name(\"pg_event_register\").parameter.head.code(\"event_type\").l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0006144046783447266,
        "retrieval": 0.023144245147705078,
        "enrichment": 0.0,
        "generation": 3.822007894515991
      }
    },
    {
      "question": "Why is the correct VARATT macro critical for amcheck's integrity verification?",
      "analysis": {
        "intent": "explain-concept",
        "domain": "general",
        "keywords": [
          "VARATT"
        ],
        "confidence": 0.22999999999999998,
        "question_length": 78,
        "has_code_terms": false
      },
      "retrieval_stats": {
        "qa_retrieved": 3,
        "cpgql_retrieved": 5,
        "avg_qa_similarity": 0.6564089258511862,
        "avg_cpgql_similarity": 0.2948294758796692,
        "domain_filtered": false
      },
      "enrichment_coverage": 0.0,
      "query": "cpg.method.name(\"amcheck\").call.name(\"VARATT\").l",
      "valid": true,
      "error": "",
      "times": {
        "analysis": 0.0,
        "retrieval": 0.06628227233886719,
        "enrichment": 0.0,
        "generation": 4.828760623931885
      }
    }
  ]
}