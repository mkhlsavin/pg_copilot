{
  "total_questions": 10,
  "total_time": 174.60340213775635,
  "avg_time_per_question": 17.460225820541382,
  "validity_rate": 1.0,
  "tag_usage_rate": 0.8,
  "avg_enrichment_coverage": 0.5458333333333333,
  "results": [
    {
      "question": "How does PostgreSQL handle visibility checks for BRIN index entries to ensure consistency with MVCC semantics?",
      "domain": "mvcc",
      "query": "cpg.call.name(\"brin*\").tag.nameExact(\"function-purpose\").valueExact(\"transaction-management\").l",
      "valid": true,
      "enrichment_coverage": 0.75,
      "elapsed": 34.00571012496948
    },
    {
      "question": "What mechanism in PostgreSQL's elog.c handles assertion failures during execution, and how does it interact with error reporting?",
      "domain": "wal",
      "query": "cpg.method.name(\"elog\").tag.nameExact(\"function-purpose\").valueExact(\"logging\").l",
      "valid": true,
      "enrichment_coverage": 0.75,
      "elapsed": 15.521703481674194
    },
    {
      "question": "How does transactional invalidation for pg_class differ from non-transactional invalidation, and why is it critical?",
      "domain": "mvcc",
      "query": "cpg.method.name(\"transactional_invalidation\").call.name(\"pg_class\").argument.isIdentifier.l",
      "valid": true,
      "enrichment_coverage": 0.75,
      "elapsed": 15.758195877075195
    },
    {
      "question": "How does PostgreSQL 17's normalization infrastructure handle multiple stages of query processing?",
      "domain": "general",
      "query": "cpg.call.name(\"normalize\").argument.l.tag.nameExact(\"function-purpose\").valueExact(\"initialization\").l",
      "valid": true,
      "enrichment_coverage": 0.1111111111111111,
      "elapsed": 15.719780206680298
    },
    {
      "question": "What specific code changes were made to the bgw_library_name field definition in PostgreSQL 17?",
      "domain": "general",
      "query": "cpg.call.name(\"bgw_library_name\").tag.nameExact(\"function-purpose\").valueExact(\"initialization\").l",
      "valid": true,
      "enrichment_coverage": 0.1111111111111111,
      "elapsed": 15.68201231956482
    },
    {
      "question": "What code-level optimizations were introduced to track catalog-modifying transactions more efficiently in PostgreSQL 17?",
      "domain": "wal",
      "query": "cpg.call.name(\"Transaction\").code(\".*\").tag.nameExact(\"function-purpose\").valueExact(\"logging\").l",
      "valid": true,
      "enrichment_coverage": 0.75,
      "elapsed": 15.70727276802063
    },
    {
      "question": "What role does parse_type.c play in resolving SQL type specifications to internal TypeIds during query parsing in PostgreSQL?",
      "domain": "security",
      "query": "cpg.call.name(\"parse_type\").method.tag.nameExact(\"function-purpose\").valueExact(\"authentication\").l",
      "valid": true,
      "enrichment_coverage": 0.625,
      "elapsed": 15.835858583450317
    },
    {
      "question": "What modifications were made to PostgreSQL's write-ahead logging (WAL) system in version 17 to improve crash recovery performance?",
      "domain": "wal",
      "query": "cpg.method.name(\".*wal.*\").tag.nameExact(\"function-purpose\").valueExact(\"logging\").l",
      "valid": true,
      "enrichment_coverage": 0.75,
      "elapsed": 15.83014988899231
    },
    {
      "question": "How does PostgreSQL 17's pgoutput handle proto_version compatibility across server versions?",
      "domain": "general",
      "query": "cpg.call.name(\"pgoutput\").tag.nameExact(\"proto_version\").value.l",
      "valid": true,
      "enrichment_coverage": 0.1111111111111111,
      "elapsed": 15.443907976150513
    },
    {
      "question": "Why do test failures occur when modifying psql's output format without updating `parallel_schedule`?",
      "domain": "parallel",
      "query": "cpg.method.name(\"parallel_schedule\").parameter.l",
      "valid": true,
      "enrichment_coverage": 0.75,
      "elapsed": 15.09766697883606
    }
  ]
}