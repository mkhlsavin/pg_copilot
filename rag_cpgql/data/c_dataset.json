[
  {
    "question": "List all source files in the project.",
    "answer": "cpg.file.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show all header files.",
    "answer": "cpg.file.name(\".*\\.h\").l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find the names of all functions.",
    "answer": "cpg.method.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify all type declarations.",
    "answer": "cpg.typeDecl.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve all comments in the codebase.",
    "answer": "cpg.comment.code.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate all literal values in the project.",
    "answer": "cpg.literal.code.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display all local variables.",
    "answer": "cpg.local.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get all identifiers.",
    "answer": "cpg.identifier.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List all control structures.",
    "answer": "cpg.controlStructure.code.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show all namespaces.",
    "answer": "cpg.namespace.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find all source files in the project.",
    "answer": "cpg.file.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify all header files.",
    "answer": "cpg.file.name(\".*\\.h\").l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve the names of all functions.",
    "answer": "cpg.method.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate all type declarations.",
    "answer": "cpg.typeDecl.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display all comments in the codebase.",
    "answer": "cpg.comment.code.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get all literal values in the project.",
    "answer": "cpg.literal.code.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List all local variables.",
    "answer": "cpg.local.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show all identifiers.",
    "answer": "cpg.identifier.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find all control structures.",
    "answer": "cpg.controlStructure.code.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify all namespaces.",
    "answer": "cpg.namespace.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve all source files in the project.",
    "answer": "cpg.file.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate all header files.",
    "answer": "cpg.file.name(\".*\\.h\").l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display the names of all functions.",
    "answer": "cpg.method.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get all type declarations.",
    "answer": "cpg.typeDecl.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List all comments in the codebase.",
    "answer": "cpg.comment.code.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show all literal values in the project.",
    "answer": "cpg.literal.code.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find all local variables.",
    "answer": "cpg.local.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify all identifiers.",
    "answer": "cpg.identifier.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve all control structures.",
    "answer": "cpg.controlStructure.code.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate all namespaces.",
    "answer": "cpg.namespace.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display all source files in the project.",
    "answer": "cpg.file.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get all header files.",
    "answer": "cpg.file.name(\".*\\.h\").l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List the names of all functions.",
    "answer": "cpg.method.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show all type declarations.",
    "answer": "cpg.typeDecl.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find all comments in the codebase.",
    "answer": "cpg.comment.code.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify all literal values in the project.",
    "answer": "cpg.literal.code.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve all local variables.",
    "answer": "cpg.local.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate all identifiers.",
    "answer": "cpg.identifier.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display all control structures.",
    "answer": "cpg.controlStructure.code.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get all namespaces.",
    "answer": "cpg.namespace.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List the number of functions per file.",
    "answer": "cpg.file.map(f => (f.name, f.method.size)).l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show files that define more than 10 functions.",
    "answer": "cpg.file.where(_.method.size > 10).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find methods defined in the 'src/utils' directory.",
    "answer": "cpg.file.name(\"src/utils/.*\").method.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify functions with more than three parameters.",
    "answer": "cpg.method.filter(_.parameter.size > 3).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve functions that call 'malloc'.",
    "answer": "cpg.method.where(_.call.name(\"malloc\").nonEmpty).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate functions whose names start with 'get'.",
    "answer": "cpg.method.name(\"^get.*\").l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display methods declared in header files.",
    "answer": "cpg.file.name(\".*\\.h\").method.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get the number of parameters for each method.",
    "answer": "cpg.method.map(m => (m.name, m.parameter.size)).l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List methods together with the number of calls to them.",
    "answer": "cpg.method.map(m => (m.name, m.callIn.size)).l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show the number of functions per file.",
    "answer": "cpg.file.map(f => (f.name, f.method.size)).l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find files that define more than 10 functions.",
    "answer": "cpg.file.where(_.method.size > 10).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify methods defined in the 'src/utils' directory.",
    "answer": "cpg.file.name(\"src/utils/.*\").method.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve functions with more than three parameters.",
    "answer": "cpg.method.filter(_.parameter.size > 3).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate functions that call 'malloc'.",
    "answer": "cpg.method.where(_.call.name(\"malloc\").nonEmpty).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display functions whose names start with 'get'.",
    "answer": "cpg.method.name(\"^get.*\").l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get methods declared in header files.",
    "answer": "cpg.file.name(\".*\\.h\").method.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List the number of parameters for each method.",
    "answer": "cpg.method.map(m => (m.name, m.parameter.size)).l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show methods together with the number of calls to them.",
    "answer": "cpg.method.map(m => (m.name, m.callIn.size)).l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find the number of functions per file.",
    "answer": "cpg.file.map(f => (f.name, f.method.size)).l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify files that define more than 10 functions.",
    "answer": "cpg.file.where(_.method.size > 10).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve methods defined in the 'src/utils' directory.",
    "answer": "cpg.file.name(\"src/utils/.*\").method.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate functions with more than three parameters.",
    "answer": "cpg.method.filter(_.parameter.size > 3).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display functions that call 'malloc'.",
    "answer": "cpg.method.where(_.call.name(\"malloc\").nonEmpty).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get functions whose names start with 'get'.",
    "answer": "cpg.method.name(\"^get.*\").l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List methods declared in header files.",
    "answer": "cpg.file.name(\".*\\.h\").method.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show the number of parameters for each method.",
    "answer": "cpg.method.map(m => (m.name, m.parameter.size)).l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find methods together with the number of calls to them.",
    "answer": "cpg.method.map(m => (m.name, m.callIn.size)).l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify the number of functions per file.",
    "answer": "cpg.file.map(f => (f.name, f.method.size)).l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve files that define more than 10 functions.",
    "answer": "cpg.file.where(_.method.size > 10).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate methods defined in the 'src/utils' directory.",
    "answer": "cpg.file.name(\"src/utils/.*\").method.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display functions with more than three parameters.",
    "answer": "cpg.method.filter(_.parameter.size > 3).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get functions that call 'malloc'.",
    "answer": "cpg.method.where(_.call.name(\"malloc\").nonEmpty).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions whose names start with 'get'.",
    "answer": "cpg.method.name(\"^get.*\").l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show methods declared in header files.",
    "answer": "cpg.file.name(\".*\\.h\").method.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find the number of parameters for each method.",
    "answer": "cpg.method.map(m => (m.name, m.parameter.size)).l",
    "scenario": 1,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions that are never called.",
    "answer": "cpg.method.where(_.caller.l.isEmpty).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show the call chain starting from 'main'.",
    "answer": "cpg.method.name(\"main\").repeat(_.callee).emit.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find functions involved in recursive call cycles.",
    "answer": "cpg.method.where(m => m.reachableBy(m).nonEmpty).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify functions that call functions defined in different files.",
    "answer": "cpg.method.where(_.call.callee.file.name.not(_ == _.file.name)).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve the functions reachable from the 'init' function.",
    "answer": "cpg.method.name(\"init\").repeat(_.callee).emit.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate functions that are never called.",
    "answer": "cpg.method.where(_.caller.l.isEmpty).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display the call chain starting from 'main'.",
    "answer": "cpg.method.name(\"main\").repeat(_.callee).emit.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get functions involved in recursive call cycles.",
    "answer": "cpg.method.where(m => m.reachableBy(m).nonEmpty).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List functions that call functions defined in different files.",
    "answer": "cpg.method.where(_.call.callee.file.name.not(_ == _.file.name)).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show the functions reachable from the 'init' function.",
    "answer": "cpg.method.name(\"init\").repeat(_.callee).emit.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find functions that are never called.",
    "answer": "cpg.method.where(_.caller.l.isEmpty).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify the call chain starting from 'main'.",
    "answer": "cpg.method.name(\"main\").repeat(_.callee).emit.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve functions involved in recursive call cycles.",
    "answer": "cpg.method.where(m => m.reachableBy(m).nonEmpty).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate functions that call functions defined in different files.",
    "answer": "cpg.method.where(_.call.callee.file.name.not(_ == _.file.name)).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display the functions reachable from the 'init' function.",
    "answer": "cpg.method.name(\"init\").repeat(_.callee).emit.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get functions that are never called.",
    "answer": "cpg.method.where(_.caller.l.isEmpty).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List the call chain starting from 'main'.",
    "answer": "cpg.method.name(\"main\").repeat(_.callee).emit.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show functions involved in recursive call cycles.",
    "answer": "cpg.method.where(m => m.reachableBy(m).nonEmpty).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find functions that call functions defined in different files.",
    "answer": "cpg.method.where(_.call.callee.file.name.not(_ == _.file.name)).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify the functions reachable from the 'init' function.",
    "answer": "cpg.method.name(\"init\").repeat(_.callee).emit.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve functions that are never called.",
    "answer": "cpg.method.where(_.caller.l.isEmpty).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate the call chain starting from 'main'.",
    "answer": "cpg.method.name(\"main\").repeat(_.callee).emit.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display functions involved in recursive call cycles.",
    "answer": "cpg.method.where(m => m.reachableBy(m).nonEmpty).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get functions that call functions defined in different files.",
    "answer": "cpg.method.where(_.call.callee.file.name.not(_ == _.file.name)).name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List the functions reachable from the 'init' function.",
    "answer": "cpg.method.name(\"init\").repeat(_.callee).emit.name.l",
    "scenario": 1,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List calls to 'strcpy'.",
    "answer": "cpg.call.name(\"strcpy\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show calls to 'gets'.",
    "answer": "cpg.call.name(\"gets\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find uses of 'memcpy'.",
    "answer": "cpg.call.name(\"memcpy\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify calls to 'system'.",
    "answer": "cpg.call.name(\"system\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve functions that call 'exec'.",
    "answer": "cpg.method.where(_.call.name(\"exec\").nonEmpty).name.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate uses of 'rand'.",
    "answer": "cpg.call.name(\"rand\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display calls to deprecated SSL functions.",
    "answer": "cpg.call.name(\"ssl3_.*\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get calls to 'strcat'.",
    "answer": "cpg.call.name(\"strcat\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List uses of 'bzero'.",
    "answer": "cpg.call.name(\"bzero\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show calls to 'atoi'.",
    "answer": "cpg.call.name(\"atoi\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find calls to 'strcpy'.",
    "answer": "cpg.call.name(\"strcpy\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify calls to 'gets'.",
    "answer": "cpg.call.name(\"gets\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve uses of 'memcpy'.",
    "answer": "cpg.call.name(\"memcpy\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate calls to 'system'.",
    "answer": "cpg.call.name(\"system\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display functions that call 'exec'.",
    "answer": "cpg.method.where(_.call.name(\"exec\").nonEmpty).name.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get uses of 'rand'.",
    "answer": "cpg.call.name(\"rand\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List calls to deprecated SSL functions.",
    "answer": "cpg.call.name(\"ssl3_.*\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show calls to 'strcat'.",
    "answer": "cpg.call.name(\"strcat\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find uses of 'bzero'.",
    "answer": "cpg.call.name(\"bzero\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify calls to 'atoi'.",
    "answer": "cpg.call.name(\"atoi\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve calls to 'strcpy'.",
    "answer": "cpg.call.name(\"strcpy\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate calls to 'gets'.",
    "answer": "cpg.call.name(\"gets\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display uses of 'memcpy'.",
    "answer": "cpg.call.name(\"memcpy\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get calls to 'system'.",
    "answer": "cpg.call.name(\"system\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List functions that call 'exec'.",
    "answer": "cpg.method.where(_.call.name(\"exec\").nonEmpty).name.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show uses of 'rand'.",
    "answer": "cpg.call.name(\"rand\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find calls to deprecated SSL functions.",
    "answer": "cpg.call.name(\"ssl3_.*\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify calls to 'strcat'.",
    "answer": "cpg.call.name(\"strcat\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve uses of 'bzero'.",
    "answer": "cpg.call.name(\"bzero\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate calls to 'atoi'.",
    "answer": "cpg.call.name(\"atoi\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display calls to 'strcpy'.",
    "answer": "cpg.call.name(\"strcpy\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get calls to 'gets'.",
    "answer": "cpg.call.name(\"gets\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List uses of 'memcpy'.",
    "answer": "cpg.call.name(\"memcpy\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show calls to 'system'.",
    "answer": "cpg.call.name(\"system\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find functions that call 'exec'.",
    "answer": "cpg.method.where(_.call.name(\"exec\").nonEmpty).name.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify uses of 'rand'.",
    "answer": "cpg.call.name(\"rand\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve calls to deprecated SSL functions.",
    "answer": "cpg.call.name(\"ssl3_.*\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate calls to 'strcat'.",
    "answer": "cpg.call.name(\"strcat\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display uses of 'bzero'.",
    "answer": "cpg.call.name(\"bzero\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get calls to 'atoi'.",
    "answer": "cpg.call.name(\"atoi\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List data flows from input functions to unsafe copy functions.",
    "answer": "cpg.call.name(\"strcpy|strcat\").where(_.argument.reachableBy(cpg.call.name(\"gets|fgets\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show calls to 'strcpy' without conditional checks.",
    "answer": "cpg.call.name(\"strcpy\").whereNot(_.inControlStructure).l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find malloc calls without null pointer checks.",
    "answer": "cpg.call.name(\"malloc\").where(_.caller.whereNot(_.call.name(\"free\").nonEmpty)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify integer additions that might overflow.",
    "answer": "cpg.call.name(\"<operator>.addition\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve functions allocating memory but not freeing it.",
    "answer": "cpg.call.name(\"malloc\").method.whereNot(_.call.name(\"free\").nonEmpty).name.l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate uses of insecure hashing algorithms like MD5 or SHA1.",
    "answer": "cpg.call.name(\"md5|MD5|sha1|SHA1\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display uses of insecure HTTP URLs.",
    "answer": "cpg.literal.code(\"http://.*\").l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get loops writing to arrays without bounds checks.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"strcpy\").nonEmpty).code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List calls to 'sprintf' without length specification.",
    "answer": "cpg.call.name(\"sprintf\").where(_.argument.size < 3).code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show data flows from input functions to unsafe copy functions.",
    "answer": "cpg.call.name(\"strcpy|strcat\").where(_.argument.reachableBy(cpg.call.name(\"gets|fgets\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find calls to 'strcpy' without conditional checks.",
    "answer": "cpg.call.name(\"strcpy\").whereNot(_.inControlStructure).l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify malloc calls without null pointer checks.",
    "answer": "cpg.call.name(\"malloc\").where(_.caller.whereNot(_.call.name(\"free\").nonEmpty)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve integer additions that might overflow.",
    "answer": "cpg.call.name(\"<operator>.addition\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate functions allocating memory but not freeing it.",
    "answer": "cpg.call.name(\"malloc\").method.whereNot(_.call.name(\"free\").nonEmpty).name.l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display uses of insecure hashing algorithms like MD5 or SHA1.",
    "answer": "cpg.call.name(\"md5|MD5|sha1|SHA1\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get uses of insecure HTTP URLs.",
    "answer": "cpg.literal.code(\"http://.*\").l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List loops writing to arrays without bounds checks.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"strcpy\").nonEmpty).code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show calls to 'sprintf' without length specification.",
    "answer": "cpg.call.name(\"sprintf\").where(_.argument.size < 3).code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find data flows from input functions to unsafe copy functions.",
    "answer": "cpg.call.name(\"strcpy|strcat\").where(_.argument.reachableBy(cpg.call.name(\"gets|fgets\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify calls to 'strcpy' without conditional checks.",
    "answer": "cpg.call.name(\"strcpy\").whereNot(_.inControlStructure).l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve malloc calls without null pointer checks.",
    "answer": "cpg.call.name(\"malloc\").where(_.caller.whereNot(_.call.name(\"free\").nonEmpty)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate integer additions that might overflow.",
    "answer": "cpg.call.name(\"<operator>.addition\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display functions allocating memory but not freeing it.",
    "answer": "cpg.call.name(\"malloc\").method.whereNot(_.call.name(\"free\").nonEmpty).name.l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get uses of insecure hashing algorithms like MD5 or SHA1.",
    "answer": "cpg.call.name(\"md5|MD5|sha1|SHA1\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List uses of insecure HTTP URLs.",
    "answer": "cpg.literal.code(\"http://.*\").l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show loops writing to arrays without bounds checks.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"strcpy\").nonEmpty).code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find calls to 'sprintf' without length specification.",
    "answer": "cpg.call.name(\"sprintf\").where(_.argument.size < 3).code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify data flows from input functions to unsafe copy functions.",
    "answer": "cpg.call.name(\"strcpy|strcat\").where(_.argument.reachableBy(cpg.call.name(\"gets|fgets\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve calls to 'strcpy' without conditional checks.",
    "answer": "cpg.call.name(\"strcpy\").whereNot(_.inControlStructure).l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate malloc calls without null pointer checks.",
    "answer": "cpg.call.name(\"malloc\").where(_.caller.whereNot(_.call.name(\"free\").nonEmpty)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display integer additions that might overflow.",
    "answer": "cpg.call.name(\"<operator>.addition\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get functions allocating memory but not freeing it.",
    "answer": "cpg.call.name(\"malloc\").method.whereNot(_.call.name(\"free\").nonEmpty).name.l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List uses of insecure hashing algorithms like MD5 or SHA1.",
    "answer": "cpg.call.name(\"md5|MD5|sha1|SHA1\").code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show uses of insecure HTTP URLs.",
    "answer": "cpg.literal.code(\"http://.*\").l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find loops writing to arrays without bounds checks.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"strcpy\").nonEmpty).code.l",
    "scenario": 2,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List tainted flows from network input to system commands.",
    "answer": "cpg.call.name(\"system\").where(_.argument.reachableBy(cpg.call.name(\"recv|read|gets\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show buffer overflows via user input reaching memcpy size argument.",
    "answer": "cpg.call.name(\"memcpy\").where(_.argument.argumentIndex(3).reachableBy(cpg.call.name(\"gets|recv\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find SQL injection flows from input to query execution.",
    "answer": "cpg.call.name(\"sqlite3_exec|mysql_query\").where(_.argument.reachableBy(cpg.call.name(\"scanf|fgets\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify command injection via exec functions with tainted arguments.",
    "answer": "cpg.call.name(\"execl|execvp\").where(_.argument.reachableBy(cpg.call.name(\"getenv|gets\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve flows of environment variables to file operations.",
    "answer": "cpg.call.name(\"open|fopen\").where(_.argument.reachableBy(cpg.call.name(\"getenv\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate tainted flows from network input to system commands.",
    "answer": "cpg.call.name(\"system\").where(_.argument.reachableBy(cpg.call.name(\"recv|read|gets\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display buffer overflows via user input reaching memcpy size argument.",
    "answer": "cpg.call.name(\"memcpy\").where(_.argument.argumentIndex(3).reachableBy(cpg.call.name(\"gets|recv\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get SQL injection flows from input to query execution.",
    "answer": "cpg.call.name(\"sqlite3_exec|mysql_query\").where(_.argument.reachableBy(cpg.call.name(\"scanf|fgets\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List command injection via exec functions with tainted arguments.",
    "answer": "cpg.call.name(\"execl|execvp\").where(_.argument.reachableBy(cpg.call.name(\"getenv|gets\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show flows of environment variables to file operations.",
    "answer": "cpg.call.name(\"open|fopen\").where(_.argument.reachableBy(cpg.call.name(\"getenv\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find tainted flows from network input to system commands.",
    "answer": "cpg.call.name(\"system\").where(_.argument.reachableBy(cpg.call.name(\"recv|read|gets\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify buffer overflows via user input reaching memcpy size argument.",
    "answer": "cpg.call.name(\"memcpy\").where(_.argument.argumentIndex(3).reachableBy(cpg.call.name(\"gets|recv\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve SQL injection flows from input to query execution.",
    "answer": "cpg.call.name(\"sqlite3_exec|mysql_query\").where(_.argument.reachableBy(cpg.call.name(\"scanf|fgets\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate command injection via exec functions with tainted arguments.",
    "answer": "cpg.call.name(\"execl|execvp\").where(_.argument.reachableBy(cpg.call.name(\"getenv|gets\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display flows of environment variables to file operations.",
    "answer": "cpg.call.name(\"open|fopen\").where(_.argument.reachableBy(cpg.call.name(\"getenv\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get tainted flows from network input to system commands.",
    "answer": "cpg.call.name(\"system\").where(_.argument.reachableBy(cpg.call.name(\"recv|read|gets\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List buffer overflows via user input reaching memcpy size argument.",
    "answer": "cpg.call.name(\"memcpy\").where(_.argument.argumentIndex(3).reachableBy(cpg.call.name(\"gets|recv\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show SQL injection flows from input to query execution.",
    "answer": "cpg.call.name(\"sqlite3_exec|mysql_query\").where(_.argument.reachableBy(cpg.call.name(\"scanf|fgets\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find command injection via exec functions with tainted arguments.",
    "answer": "cpg.call.name(\"execl|execvp\").where(_.argument.reachableBy(cpg.call.name(\"getenv|gets\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify flows of environment variables to file operations.",
    "answer": "cpg.call.name(\"open|fopen\").where(_.argument.reachableBy(cpg.call.name(\"getenv\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve tainted flows from network input to system commands.",
    "answer": "cpg.call.name(\"system\").where(_.argument.reachableBy(cpg.call.name(\"recv|read|gets\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate buffer overflows via user input reaching memcpy size argument.",
    "answer": "cpg.call.name(\"memcpy\").where(_.argument.argumentIndex(3).reachableBy(cpg.call.name(\"gets|recv\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display SQL injection flows from input to query execution.",
    "answer": "cpg.call.name(\"sqlite3_exec|mysql_query\").where(_.argument.reachableBy(cpg.call.name(\"scanf|fgets\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get command injection via exec functions with tainted arguments.",
    "answer": "cpg.call.name(\"execl|execvp\").where(_.argument.reachableBy(cpg.call.name(\"getenv|gets\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List flows of environment variables to file operations.",
    "answer": "cpg.call.name(\"open|fopen\").where(_.argument.reachableBy(cpg.call.name(\"getenv\").argument)).l",
    "scenario": 2,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List all function signatures.",
    "answer": "cpg.method.signature.l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show names and return types of all functions.",
    "answer": "cpg.method.map(m => (m.name, m.methodReturn.typeFullName)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find all parameters of each function.",
    "answer": "cpg.method.parameter.name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify comments associated with functions.",
    "answer": "cpg.method.comment.code.l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve TODO comments.",
    "answer": "cpg.comment.code(\".*TODO.*\").l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate all formal return parameters.",
    "answer": "cpg.methodReturn.name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display all namespaces and their methods.",
    "answer": "cpg.namespace.map(n => (n.name, n.method.name.l)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get all type declarations with their kinds.",
    "answer": "cpg.typeDecl.map(t => (t.name, t.kind)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List the number of parameters for each function.",
    "answer": "cpg.method.map(m => (m.name, m.parameter.size)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show all literal strings used in comments.",
    "answer": "cpg.comment.literal.code.l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find all function signatures.",
    "answer": "cpg.method.signature.l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify names and return types of all functions.",
    "answer": "cpg.method.map(m => (m.name, m.methodReturn.typeFullName)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve all parameters of each function.",
    "answer": "cpg.method.parameter.name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate comments associated with functions.",
    "answer": "cpg.method.comment.code.l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display TODO comments.",
    "answer": "cpg.comment.code(\".*TODO.*\").l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get all formal return parameters.",
    "answer": "cpg.methodReturn.name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List all namespaces and their methods.",
    "answer": "cpg.namespace.map(n => (n.name, n.method.name.l)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show all type declarations with their kinds.",
    "answer": "cpg.typeDecl.map(t => (t.name, t.kind)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find the number of parameters for each function.",
    "answer": "cpg.method.map(m => (m.name, m.parameter.size)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify all literal strings used in comments.",
    "answer": "cpg.comment.literal.code.l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve all function signatures.",
    "answer": "cpg.method.signature.l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate names and return types of all functions.",
    "answer": "cpg.method.map(m => (m.name, m.methodReturn.typeFullName)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display all parameters of each function.",
    "answer": "cpg.method.parameter.name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get comments associated with functions.",
    "answer": "cpg.method.comment.code.l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List TODO comments.",
    "answer": "cpg.comment.code(\".*TODO.*\").l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show all formal return parameters.",
    "answer": "cpg.methodReturn.name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find all namespaces and their methods.",
    "answer": "cpg.namespace.map(n => (n.name, n.method.name.l)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify all type declarations with their kinds.",
    "answer": "cpg.typeDecl.map(t => (t.name, t.kind)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve the number of parameters for each function.",
    "answer": "cpg.method.map(m => (m.name, m.parameter.size)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate all literal strings used in comments.",
    "answer": "cpg.comment.literal.code.l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display all function signatures.",
    "answer": "cpg.method.signature.l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get names and return types of all functions.",
    "answer": "cpg.method.map(m => (m.name, m.methodReturn.typeFullName)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List all parameters of each function.",
    "answer": "cpg.method.parameter.name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show comments associated with functions.",
    "answer": "cpg.method.comment.code.l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find TODO comments.",
    "answer": "cpg.comment.code(\".*TODO.*\").l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify all formal return parameters.",
    "answer": "cpg.methodReturn.name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve all namespaces and their methods.",
    "answer": "cpg.namespace.map(n => (n.name, n.method.name.l)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate all type declarations with their kinds.",
    "answer": "cpg.typeDecl.map(t => (t.name, t.kind)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display the number of parameters for each function.",
    "answer": "cpg.method.map(m => (m.name, m.parameter.size)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get all literal strings used in comments.",
    "answer": "cpg.comment.literal.code.l",
    "scenario": 3,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List functions missing documentation comments.",
    "answer": "cpg.method.where(_.comment.isEmpty).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show functions with their line counts.",
    "answer": "cpg.method.map(m => (m.name, m.lineNumberEnd - m.lineNumberStart)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find functions that have duplicate names in different files.",
    "answer": "cpg.method.groupBy(_.name).filter(_._2.size > 1).map(_._1).l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify functions and the number of functions they call.",
    "answer": "cpg.method.map(m => (m.name, m.callee.size)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve modules with the highest number of functions.",
    "answer": "cpg.file.map(f => (f.name, f.method.size)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate methods defined in header files.",
    "answer": "cpg.file.name(\".*\\.h\").method.name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display functions with more than five parameters.",
    "answer": "cpg.method.where(_.parameter.size > 5).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get functions that do not call any other functions.",
    "answer": "cpg.method.where(_.callee.isEmpty).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions along with the number of literals they contain.",
    "answer": "cpg.method.map(m => (m.name, m.literal.size)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show functions missing documentation comments.",
    "answer": "cpg.method.where(_.comment.isEmpty).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find functions with their line counts.",
    "answer": "cpg.method.map(m => (m.name, m.lineNumberEnd - m.lineNumberStart)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify functions that have duplicate names in different files.",
    "answer": "cpg.method.groupBy(_.name).filter(_._2.size > 1).map(_._1).l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve functions and the number of functions they call.",
    "answer": "cpg.method.map(m => (m.name, m.callee.size)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate modules with the highest number of functions.",
    "answer": "cpg.file.map(f => (f.name, f.method.size)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display methods defined in header files.",
    "answer": "cpg.file.name(\".*\\.h\").method.name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get functions with more than five parameters.",
    "answer": "cpg.method.where(_.parameter.size > 5).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions that do not call any other functions.",
    "answer": "cpg.method.where(_.callee.isEmpty).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show functions along with the number of literals they contain.",
    "answer": "cpg.method.map(m => (m.name, m.literal.size)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find functions missing documentation comments.",
    "answer": "cpg.method.where(_.comment.isEmpty).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify functions with their line counts.",
    "answer": "cpg.method.map(m => (m.name, m.lineNumberEnd - m.lineNumberStart)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve functions that have duplicate names in different files.",
    "answer": "cpg.method.groupBy(_.name).filter(_._2.size > 1).map(_._1).l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate functions and the number of functions they call.",
    "answer": "cpg.method.map(m => (m.name, m.callee.size)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display modules with the highest number of functions.",
    "answer": "cpg.file.map(f => (f.name, f.method.size)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get methods defined in header files.",
    "answer": "cpg.file.name(\".*\\.h\").method.name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions with more than five parameters.",
    "answer": "cpg.method.where(_.parameter.size > 5).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show functions that do not call any other functions.",
    "answer": "cpg.method.where(_.callee.isEmpty).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find functions along with the number of literals they contain.",
    "answer": "cpg.method.map(m => (m.name, m.literal.size)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify functions missing documentation comments.",
    "answer": "cpg.method.where(_.comment.isEmpty).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve functions with their line counts.",
    "answer": "cpg.method.map(m => (m.name, m.lineNumberEnd - m.lineNumberStart)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate functions that have duplicate names in different files.",
    "answer": "cpg.method.groupBy(_.name).filter(_._2.size > 1).map(_._1).l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display functions and the number of functions they call.",
    "answer": "cpg.method.map(m => (m.name, m.callee.size)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get modules with the highest number of functions.",
    "answer": "cpg.file.map(f => (f.name, f.method.size)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List methods defined in header files.",
    "answer": "cpg.file.name(\".*\\.h\").method.name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show functions with more than five parameters.",
    "answer": "cpg.method.where(_.parameter.size > 5).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find functions that do not call any other functions.",
    "answer": "cpg.method.where(_.callee.isEmpty).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List the function call graph for the entire project.",
    "answer": "cpg.call.map(call => (call.method.name, call.callee.name)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show public API functions that are never referenced internally.",
    "answer": "cpg.method.isPublic.where(_.caller.isEmpty).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find functions with the deepest call chains.",
    "answer": "cpg.method.map(m => (m.name, m.callee.repeat(_.callee).emit.size)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify functions whose parameters are not mentioned in their comments.",
    "answer": "cpg.method.where(m => m.parameter.name.exists(p => !m.comment.code.contains(p))).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve functions that both call and are called by many functions.",
    "answer": "cpg.method.where(m => m.callee.size > 5 && m.caller.size > 5).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate the function call graph for the entire project.",
    "answer": "cpg.call.map(call => (call.method.name, call.callee.name)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display public API functions that are never referenced internally.",
    "answer": "cpg.method.isPublic.where(_.caller.isEmpty).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get functions with the deepest call chains.",
    "answer": "cpg.method.map(m => (m.name, m.callee.repeat(_.callee).emit.size)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List functions whose parameters are not mentioned in their comments.",
    "answer": "cpg.method.where(m => m.parameter.name.exists(p => !m.comment.code.contains(p))).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show functions that both call and are called by many functions.",
    "answer": "cpg.method.where(m => m.callee.size > 5 && m.caller.size > 5).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find the function call graph for the entire project.",
    "answer": "cpg.call.map(call => (call.method.name, call.callee.name)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify public API functions that are never referenced internally.",
    "answer": "cpg.method.isPublic.where(_.caller.isEmpty).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve functions with the deepest call chains.",
    "answer": "cpg.method.map(m => (m.name, m.callee.repeat(_.callee).emit.size)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate functions whose parameters are not mentioned in their comments.",
    "answer": "cpg.method.where(m => m.parameter.name.exists(p => !m.comment.code.contains(p))).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display functions that both call and are called by many functions.",
    "answer": "cpg.method.where(m => m.callee.size > 5 && m.caller.size > 5).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get the function call graph for the entire project.",
    "answer": "cpg.call.map(call => (call.method.name, call.callee.name)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List public API functions that are never referenced internally.",
    "answer": "cpg.method.isPublic.where(_.caller.isEmpty).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show functions with the deepest call chains.",
    "answer": "cpg.method.map(m => (m.name, m.callee.repeat(_.callee).emit.size)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find functions whose parameters are not mentioned in their comments.",
    "answer": "cpg.method.where(m => m.parameter.name.exists(p => !m.comment.code.contains(p))).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify functions that both call and are called by many functions.",
    "answer": "cpg.method.where(m => m.callee.size > 5 && m.caller.size > 5).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve the function call graph for the entire project.",
    "answer": "cpg.call.map(call => (call.method.name, call.callee.name)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate public API functions that are never referenced internally.",
    "answer": "cpg.method.isPublic.where(_.caller.isEmpty).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display functions with the deepest call chains.",
    "answer": "cpg.method.map(m => (m.name, m.callee.repeat(_.callee).emit.size)).l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get functions whose parameters are not mentioned in their comments.",
    "answer": "cpg.method.where(m => m.parameter.name.exists(p => !m.comment.code.contains(p))).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List functions that both call and are called by many functions.",
    "answer": "cpg.method.where(m => m.callee.size > 5 && m.caller.size > 5).name.l",
    "scenario": 3,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List types related to 'Network'.",
    "answer": "cpg.typeDecl.name(\".*Network.*\").l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show functions interacting with the file system.",
    "answer": "cpg.call.name(\"open|fopen|read|write\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find references to the 'Node' data structure.",
    "answer": "cpg.typeRef.name(\"Node\").l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify methods implementing the 'Serializer' interface.",
    "answer": "cpg.typeDecl.inheritsFromType.fullName(\".*Serializer.*\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve modules using the libcurl API.",
    "answer": "cpg.call.name(\"curl_easy_.*\").file.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate calls to configuration getters.",
    "answer": "cpg.call.name(\"getConfig|configGet\").code.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display functions handling user input.",
    "answer": "cpg.call.name(\"scanf|fgets\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get functions returning pointers.",
    "answer": "cpg.method.where(_.methodReturn.typeFullName.endsWith(\"*\")).name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List occurrences of the 'Message' struct.",
    "answer": "cpg.typeDecl.name(\"Message\").referencingMembers.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show uses of the 'Plugin' interface.",
    "answer": "cpg.typeDecl.name(\"Plugin\").referencingMembers.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find types related to 'Network'.",
    "answer": "cpg.typeDecl.name(\".*Network.*\").l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify functions interacting with the file system.",
    "answer": "cpg.call.name(\"open|fopen|read|write\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve references to the 'Node' data structure.",
    "answer": "cpg.typeRef.name(\"Node\").l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate methods implementing the 'Serializer' interface.",
    "answer": "cpg.typeDecl.inheritsFromType.fullName(\".*Serializer.*\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display modules using the libcurl API.",
    "answer": "cpg.call.name(\"curl_easy_.*\").file.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get calls to configuration getters.",
    "answer": "cpg.call.name(\"getConfig|configGet\").code.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List functions handling user input.",
    "answer": "cpg.call.name(\"scanf|fgets\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show functions returning pointers.",
    "answer": "cpg.method.where(_.methodReturn.typeFullName.endsWith(\"*\")).name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find occurrences of the 'Message' struct.",
    "answer": "cpg.typeDecl.name(\"Message\").referencingMembers.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify uses of the 'Plugin' interface.",
    "answer": "cpg.typeDecl.name(\"Plugin\").referencingMembers.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve types related to 'Network'.",
    "answer": "cpg.typeDecl.name(\".*Network.*\").l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate functions interacting with the file system.",
    "answer": "cpg.call.name(\"open|fopen|read|write\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display references to the 'Node' data structure.",
    "answer": "cpg.typeRef.name(\"Node\").l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get methods implementing the 'Serializer' interface.",
    "answer": "cpg.typeDecl.inheritsFromType.fullName(\".*Serializer.*\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List modules using the libcurl API.",
    "answer": "cpg.call.name(\"curl_easy_.*\").file.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show calls to configuration getters.",
    "answer": "cpg.call.name(\"getConfig|configGet\").code.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find functions handling user input.",
    "answer": "cpg.call.name(\"scanf|fgets\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify functions returning pointers.",
    "answer": "cpg.method.where(_.methodReturn.typeFullName.endsWith(\"*\")).name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve occurrences of the 'Message' struct.",
    "answer": "cpg.typeDecl.name(\"Message\").referencingMembers.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate uses of the 'Plugin' interface.",
    "answer": "cpg.typeDecl.name(\"Plugin\").referencingMembers.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display types related to 'Network'.",
    "answer": "cpg.typeDecl.name(\".*Network.*\").l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get functions interacting with the file system.",
    "answer": "cpg.call.name(\"open|fopen|read|write\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List references to the 'Node' data structure.",
    "answer": "cpg.typeRef.name(\"Node\").l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show methods implementing the 'Serializer' interface.",
    "answer": "cpg.typeDecl.inheritsFromType.fullName(\".*Serializer.*\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find modules using the libcurl API.",
    "answer": "cpg.call.name(\"curl_easy_.*\").file.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify calls to configuration getters.",
    "answer": "cpg.call.name(\"getConfig|configGet\").code.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve functions handling user input.",
    "answer": "cpg.call.name(\"scanf|fgets\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate functions returning pointers.",
    "answer": "cpg.method.where(_.methodReturn.typeFullName.endsWith(\"*\")).name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display occurrences of the 'Message' struct.",
    "answer": "cpg.typeDecl.name(\"Message\").referencingMembers.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get uses of the 'Plugin' interface.",
    "answer": "cpg.typeDecl.name(\"Plugin\").referencingMembers.l",
    "scenario": 4,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List calls to 'process' with missing arguments.",
    "answer": "cpg.call.name(\"process\").where(_.argument.size < _.callee.parameter.size).location.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show functions allocating memory without freeing it.",
    "answer": "cpg.call.name(\"malloc\").method.whereNot(_.call.name(\"free\").nonEmpty).name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find references to configuration options in the codebase.",
    "answer": "cpg.identifier.name(\"config|option\").l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify functions performing authentication.",
    "answer": "cpg.call.name(\"authenticate|login\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve usages of struct 'Message' across files.",
    "answer": "cpg.typeDecl.name(\"Message\").method.referencingMembers.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate functions that allocate arrays based on input size.",
    "answer": "cpg.call.name(\"malloc|calloc\").where(_.argument.reachableBy(cpg.method.parameter)).method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display methods that open sockets.",
    "answer": "cpg.call.name(\"socket\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get methods that enqueue tasks.",
    "answer": "cpg.call.name(\"queue_push|enqueue\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions that parse command-line arguments.",
    "answer": "cpg.call.name(\"getopt|getopt_long\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show calls to 'process' with missing arguments.",
    "answer": "cpg.call.name(\"process\").where(_.argument.size < _.callee.parameter.size).location.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find functions allocating memory without freeing it.",
    "answer": "cpg.call.name(\"malloc\").method.whereNot(_.call.name(\"free\").nonEmpty).name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify references to configuration options in the codebase.",
    "answer": "cpg.identifier.name(\"config|option\").l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve functions performing authentication.",
    "answer": "cpg.call.name(\"authenticate|login\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate usages of struct 'Message' across files.",
    "answer": "cpg.typeDecl.name(\"Message\").method.referencingMembers.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display functions that allocate arrays based on input size.",
    "answer": "cpg.call.name(\"malloc|calloc\").where(_.argument.reachableBy(cpg.method.parameter)).method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get methods that open sockets.",
    "answer": "cpg.call.name(\"socket\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List methods that enqueue tasks.",
    "answer": "cpg.call.name(\"queue_push|enqueue\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show functions that parse command-line arguments.",
    "answer": "cpg.call.name(\"getopt|getopt_long\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find calls to 'process' with missing arguments.",
    "answer": "cpg.call.name(\"process\").where(_.argument.size < _.callee.parameter.size).location.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify functions allocating memory without freeing it.",
    "answer": "cpg.call.name(\"malloc\").method.whereNot(_.call.name(\"free\").nonEmpty).name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve references to configuration options in the codebase.",
    "answer": "cpg.identifier.name(\"config|option\").l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate functions performing authentication.",
    "answer": "cpg.call.name(\"authenticate|login\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display usages of struct 'Message' across files.",
    "answer": "cpg.typeDecl.name(\"Message\").method.referencingMembers.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get functions that allocate arrays based on input size.",
    "answer": "cpg.call.name(\"malloc|calloc\").where(_.argument.reachableBy(cpg.method.parameter)).method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List methods that open sockets.",
    "answer": "cpg.call.name(\"socket\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show methods that enqueue tasks.",
    "answer": "cpg.call.name(\"queue_push|enqueue\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find functions that parse command-line arguments.",
    "answer": "cpg.call.name(\"getopt|getopt_long\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify calls to 'process' with missing arguments.",
    "answer": "cpg.call.name(\"process\").where(_.argument.size < _.callee.parameter.size).location.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve functions allocating memory without freeing it.",
    "answer": "cpg.call.name(\"malloc\").method.whereNot(_.call.name(\"free\").nonEmpty).name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate references to configuration options in the codebase.",
    "answer": "cpg.identifier.name(\"config|option\").l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display functions performing authentication.",
    "answer": "cpg.call.name(\"authenticate|login\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get usages of struct 'Message' across files.",
    "answer": "cpg.typeDecl.name(\"Message\").method.referencingMembers.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions that allocate arrays based on input size.",
    "answer": "cpg.call.name(\"malloc|calloc\").where(_.argument.reachableBy(cpg.method.parameter)).method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show methods that open sockets.",
    "answer": "cpg.call.name(\"socket\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find methods that enqueue tasks.",
    "answer": "cpg.call.name(\"queue_push|enqueue\").method.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List data flows from function inputs to encryption routines.",
    "answer": "cpg.call.name(\"encrypt\").where(_.argument.reachableBy(cpg.method.parameter)).l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show propagation of callbacks through asynchronous handlers.",
    "answer": "cpg.method.name(\"callback\").caller.repeat(_.caller).emit.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find concurrency patterns using pthreads.",
    "answer": "cpg.call.name(\"pthread_create\").callee.repeat(_.callee).l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify cross-module interactions for the 'Plugin' interface.",
    "answer": "cpg.typeDecl.name(\"Plugin\").callers.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve registration and invocation pairs for event handlers.",
    "answer": "cpg.call.name(\"registerListener\").map(r => (r.argument(1), r.callee.caller.name)).l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate data flows from function inputs to encryption routines.",
    "answer": "cpg.call.name(\"encrypt\").where(_.argument.reachableBy(cpg.method.parameter)).l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display propagation of callbacks through asynchronous handlers.",
    "answer": "cpg.method.name(\"callback\").caller.repeat(_.caller).emit.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get concurrency patterns using pthreads.",
    "answer": "cpg.call.name(\"pthread_create\").callee.repeat(_.callee).l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List cross-module interactions for the 'Plugin' interface.",
    "answer": "cpg.typeDecl.name(\"Plugin\").callers.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show registration and invocation pairs for event handlers.",
    "answer": "cpg.call.name(\"registerListener\").map(r => (r.argument(1), r.callee.caller.name)).l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find data flows from function inputs to encryption routines.",
    "answer": "cpg.call.name(\"encrypt\").where(_.argument.reachableBy(cpg.method.parameter)).l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify propagation of callbacks through asynchronous handlers.",
    "answer": "cpg.method.name(\"callback\").caller.repeat(_.caller).emit.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve concurrency patterns using pthreads.",
    "answer": "cpg.call.name(\"pthread_create\").callee.repeat(_.callee).l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate cross-module interactions for the 'Plugin' interface.",
    "answer": "cpg.typeDecl.name(\"Plugin\").callers.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display registration and invocation pairs for event handlers.",
    "answer": "cpg.call.name(\"registerListener\").map(r => (r.argument(1), r.callee.caller.name)).l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get data flows from function inputs to encryption routines.",
    "answer": "cpg.call.name(\"encrypt\").where(_.argument.reachableBy(cpg.method.parameter)).l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List propagation of callbacks through asynchronous handlers.",
    "answer": "cpg.method.name(\"callback\").caller.repeat(_.caller).emit.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show concurrency patterns using pthreads.",
    "answer": "cpg.call.name(\"pthread_create\").callee.repeat(_.callee).l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find cross-module interactions for the 'Plugin' interface.",
    "answer": "cpg.typeDecl.name(\"Plugin\").callers.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify registration and invocation pairs for event handlers.",
    "answer": "cpg.call.name(\"registerListener\").map(r => (r.argument(1), r.callee.caller.name)).l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve data flows from function inputs to encryption routines.",
    "answer": "cpg.call.name(\"encrypt\").where(_.argument.reachableBy(cpg.method.parameter)).l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate propagation of callbacks through asynchronous handlers.",
    "answer": "cpg.method.name(\"callback\").caller.repeat(_.caller).emit.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display concurrency patterns using pthreads.",
    "answer": "cpg.call.name(\"pthread_create\").callee.repeat(_.callee).l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get cross-module interactions for the 'Plugin' interface.",
    "answer": "cpg.typeDecl.name(\"Plugin\").callers.name.l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List registration and invocation pairs for event handlers.",
    "answer": "cpg.call.name(\"registerListener\").map(r => (r.argument(1), r.callee.caller.name)).l",
    "scenario": 4,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List functions longer than 100 lines.",
    "answer": "cpg.method.where(_.lineNumberEnd - _.lineNumberStart > 100).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show methods with more than five parameters.",
    "answer": "cpg.method.where(_.parameter.size > 5).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find files with more than ten functions.",
    "answer": "cpg.file.where(_.method.size > 10).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify variables with names shorter than three characters.",
    "answer": "cpg.local.name(\"^\\w{1,2}$\").l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve functions containing nested if statements.",
    "answer": "cpg.method.where(_.controlStructure.where(_.astParent.isControlStructure).nonEmpty).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate duplicate function names across files.",
    "answer": "cpg.method.groupBy(_.name).filter(_._2.size > 1).map(_._1).l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display methods with no parameters.",
    "answer": "cpg.method.where(_.parameter.isEmpty).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get functions with very few local variables.",
    "answer": "cpg.method.where(_.local.size < 2).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List files containing header guards.",
    "answer": "cpg.file.comment.code(\".*#ifndef.*#define.*#endif.*\").l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show control structures deeper than two levels.",
    "answer": "cpg.controlStructure.where(_.astParent.astParent.isControlStructure).code.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find functions longer than 100 lines.",
    "answer": "cpg.method.where(_.lineNumberEnd - _.lineNumberStart > 100).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify methods with more than five parameters.",
    "answer": "cpg.method.where(_.parameter.size > 5).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve files with more than ten functions.",
    "answer": "cpg.file.where(_.method.size > 10).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate variables with names shorter than three characters.",
    "answer": "cpg.local.name(\"^\\w{1,2}$\").l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display functions containing nested if statements.",
    "answer": "cpg.method.where(_.controlStructure.where(_.astParent.isControlStructure).nonEmpty).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get duplicate function names across files.",
    "answer": "cpg.method.groupBy(_.name).filter(_._2.size > 1).map(_._1).l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List methods with no parameters.",
    "answer": "cpg.method.where(_.parameter.isEmpty).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show functions with very few local variables.",
    "answer": "cpg.method.where(_.local.size < 2).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find files containing header guards.",
    "answer": "cpg.file.comment.code(\".*#ifndef.*#define.*#endif.*\").l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify control structures deeper than two levels.",
    "answer": "cpg.controlStructure.where(_.astParent.astParent.isControlStructure).code.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve functions longer than 100 lines.",
    "answer": "cpg.method.where(_.lineNumberEnd - _.lineNumberStart > 100).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate methods with more than five parameters.",
    "answer": "cpg.method.where(_.parameter.size > 5).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display files with more than ten functions.",
    "answer": "cpg.file.where(_.method.size > 10).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get variables with names shorter than three characters.",
    "answer": "cpg.local.name(\"^\\w{1,2}$\").l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List functions containing nested if statements.",
    "answer": "cpg.method.where(_.controlStructure.where(_.astParent.isControlStructure).nonEmpty).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show duplicate function names across files.",
    "answer": "cpg.method.groupBy(_.name).filter(_._2.size > 1).map(_._1).l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find methods with no parameters.",
    "answer": "cpg.method.where(_.parameter.isEmpty).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify functions with very few local variables.",
    "answer": "cpg.method.where(_.local.size < 2).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve files containing header guards.",
    "answer": "cpg.file.comment.code(\".*#ifndef.*#define.*#endif.*\").l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate control structures deeper than two levels.",
    "answer": "cpg.controlStructure.where(_.astParent.astParent.isControlStructure).code.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display functions longer than 100 lines.",
    "answer": "cpg.method.where(_.lineNumberEnd - _.lineNumberStart > 100).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get methods with more than five parameters.",
    "answer": "cpg.method.where(_.parameter.size > 5).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List files with more than ten functions.",
    "answer": "cpg.file.where(_.method.size > 10).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show variables with names shorter than three characters.",
    "answer": "cpg.local.name(\"^\\w{1,2}$\").l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find functions containing nested if statements.",
    "answer": "cpg.method.where(_.controlStructure.where(_.astParent.isControlStructure).nonEmpty).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify duplicate function names across files.",
    "answer": "cpg.method.groupBy(_.name).filter(_._2.size > 1).map(_._1).l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve methods with no parameters.",
    "answer": "cpg.method.where(_.parameter.isEmpty).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate functions with very few local variables.",
    "answer": "cpg.method.where(_.local.size < 2).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display files containing header guards.",
    "answer": "cpg.file.comment.code(\".*#ifndef.*#define.*#endif.*\").l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get control structures deeper than two levels.",
    "answer": "cpg.controlStructure.where(_.astParent.astParent.isControlStructure).code.l",
    "scenario": 5,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List methods exceeding cyclomatic complexity of 15.",
    "answer": "cpg.method.where(_.cyclomaticComplexity > 15).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show mutually recursive functions.",
    "answer": "cpg.method.where(m => m.callee.name(m.name)).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find functions with unused local variables.",
    "answer": "cpg.method.where(_.local.where(l => l.reference.isEmpty).nonEmpty).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify methods that could be inlined (small and called once).",
    "answer": "cpg.method.where(_.caller.size == 1 && _.lineNumberEnd - _.lineNumberStart < 10).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve modules with circular dependencies.",
    "answer": "cpg.method.where(_.callee.callee.contains(_.method)).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate functions with deep nesting levels.",
    "answer": "cpg.method.where(_.controlStructure.size > 10).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display unused global variables.",
    "answer": "cpg.member.where(_.reference.isEmpty).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get functions containing code clones.",
    "answer": "cpg.method.where(_.isDuplicateOf.nonEmpty).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions missing return statements.",
    "answer": "cpg.method.where(_.methodReturn.isEmpty).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show methods exceeding cyclomatic complexity of 15.",
    "answer": "cpg.method.where(_.cyclomaticComplexity > 15).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find mutually recursive functions.",
    "answer": "cpg.method.where(m => m.callee.name(m.name)).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify functions with unused local variables.",
    "answer": "cpg.method.where(_.local.where(l => l.reference.isEmpty).nonEmpty).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve methods that could be inlined (small and called once).",
    "answer": "cpg.method.where(_.caller.size == 1 && _.lineNumberEnd - _.lineNumberStart < 10).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate modules with circular dependencies.",
    "answer": "cpg.method.where(_.callee.callee.contains(_.method)).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display functions with deep nesting levels.",
    "answer": "cpg.method.where(_.controlStructure.size > 10).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get unused global variables.",
    "answer": "cpg.member.where(_.reference.isEmpty).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions containing code clones.",
    "answer": "cpg.method.where(_.isDuplicateOf.nonEmpty).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show functions missing return statements.",
    "answer": "cpg.method.where(_.methodReturn.isEmpty).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find methods exceeding cyclomatic complexity of 15.",
    "answer": "cpg.method.where(_.cyclomaticComplexity > 15).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify mutually recursive functions.",
    "answer": "cpg.method.where(m => m.callee.name(m.name)).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve functions with unused local variables.",
    "answer": "cpg.method.where(_.local.where(l => l.reference.isEmpty).nonEmpty).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate methods that could be inlined (small and called once).",
    "answer": "cpg.method.where(_.caller.size == 1 && _.lineNumberEnd - _.lineNumberStart < 10).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display modules with circular dependencies.",
    "answer": "cpg.method.where(_.callee.callee.contains(_.method)).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get functions with deep nesting levels.",
    "answer": "cpg.method.where(_.controlStructure.size > 10).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List unused global variables.",
    "answer": "cpg.member.where(_.reference.isEmpty).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show functions containing code clones.",
    "answer": "cpg.method.where(_.isDuplicateOf.nonEmpty).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find functions missing return statements.",
    "answer": "cpg.method.where(_.methodReturn.isEmpty).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify methods exceeding cyclomatic complexity of 15.",
    "answer": "cpg.method.where(_.cyclomaticComplexity > 15).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve mutually recursive functions.",
    "answer": "cpg.method.where(m => m.callee.name(m.name)).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate functions with unused local variables.",
    "answer": "cpg.method.where(_.local.where(l => l.reference.isEmpty).nonEmpty).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display methods that could be inlined (small and called once).",
    "answer": "cpg.method.where(_.caller.size == 1 && _.lineNumberEnd - _.lineNumberStart < 10).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get modules with circular dependencies.",
    "answer": "cpg.method.where(_.callee.callee.contains(_.method)).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions with deep nesting levels.",
    "answer": "cpg.method.where(_.controlStructure.size > 10).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show unused global variables.",
    "answer": "cpg.member.where(_.reference.isEmpty).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find functions containing code clones.",
    "answer": "cpg.method.where(_.isDuplicateOf.nonEmpty).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List modules with high coupling to other modules.",
    "answer": "cpg.file.map(f => (f.name, f.method.callee.file.distinct.size)).l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show functions responsible for multiple tasks (many locals and control structures).",
    "answer": "cpg.method.where(_.controlStructure.size > 10 && _.local.size > 10).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find functions using switch statements repeatedly (candidate for polymorphism).",
    "answer": "cpg.method.where(_.controlStructure.code.contains(\"switch\")).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify side effects of refactoring a global variable to a parameter.",
    "answer": "cpg.local.name(\"globalVar\").caller.repeat(_.caller).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve types with too many methods.",
    "answer": "cpg.typeDecl.where(_.method.size > 10).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate modules with high coupling to other modules.",
    "answer": "cpg.file.map(f => (f.name, f.method.callee.file.distinct.size)).l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display functions responsible for multiple tasks (many locals and control structures).",
    "answer": "cpg.method.where(_.controlStructure.size > 10 && _.local.size > 10).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get functions using switch statements repeatedly (candidate for polymorphism).",
    "answer": "cpg.method.where(_.controlStructure.code.contains(\"switch\")).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List side effects of refactoring a global variable to a parameter.",
    "answer": "cpg.local.name(\"globalVar\").caller.repeat(_.caller).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show types with too many methods.",
    "answer": "cpg.typeDecl.where(_.method.size > 10).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find modules with high coupling to other modules.",
    "answer": "cpg.file.map(f => (f.name, f.method.callee.file.distinct.size)).l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify functions responsible for multiple tasks (many locals and control structures).",
    "answer": "cpg.method.where(_.controlStructure.size > 10 && _.local.size > 10).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve functions using switch statements repeatedly (candidate for polymorphism).",
    "answer": "cpg.method.where(_.controlStructure.code.contains(\"switch\")).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate side effects of refactoring a global variable to a parameter.",
    "answer": "cpg.local.name(\"globalVar\").caller.repeat(_.caller).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display types with too many methods.",
    "answer": "cpg.typeDecl.where(_.method.size > 10).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get modules with high coupling to other modules.",
    "answer": "cpg.file.map(f => (f.name, f.method.callee.file.distinct.size)).l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List functions responsible for multiple tasks (many locals and control structures).",
    "answer": "cpg.method.where(_.controlStructure.size > 10 && _.local.size > 10).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show functions using switch statements repeatedly (candidate for polymorphism).",
    "answer": "cpg.method.where(_.controlStructure.code.contains(\"switch\")).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find side effects of refactoring a global variable to a parameter.",
    "answer": "cpg.local.name(\"globalVar\").caller.repeat(_.caller).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify types with too many methods.",
    "answer": "cpg.typeDecl.where(_.method.size > 10).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve modules with high coupling to other modules.",
    "answer": "cpg.file.map(f => (f.name, f.method.callee.file.distinct.size)).l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate functions responsible for multiple tasks (many locals and control structures).",
    "answer": "cpg.method.where(_.controlStructure.size > 10 && _.local.size > 10).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display functions using switch statements repeatedly (candidate for polymorphism).",
    "answer": "cpg.method.where(_.controlStructure.code.contains(\"switch\")).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get side effects of refactoring a global variable to a parameter.",
    "answer": "cpg.local.name(\"globalVar\").caller.repeat(_.caller).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List types with too many methods.",
    "answer": "cpg.typeDecl.where(_.method.size > 10).name.l",
    "scenario": 5,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List all loops in the code.",
    "answer": "cpg.controlStructure.loopType.code.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show recursive functions.",
    "answer": "cpg.method.where(_.isRecursive).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find calls to 'sleep'.",
    "answer": "cpg.call.name(\"sleep\").code.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify functions allocating memory inside loops.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"malloc\").nonEmpty).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve functions containing nested loops.",
    "answer": "cpg.method.where(_.controlStructure.loopType.size > 1).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate calls to 'usleep'.",
    "answer": "cpg.call.name(\"usleep\").code.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display functions that call 'free'.",
    "answer": "cpg.method.where(_.call.name(\"free\").nonEmpty).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get functions performing recursion without base case.",
    "answer": "cpg.method.where(_.isRecursive && _.call.name(\"<operator>.equals\").isEmpty).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List loops iterating over arrays.",
    "answer": "cpg.controlStructure.loopType.where(_.code.contains(\"[]\")).code.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show methods that call 'printf' inside loops.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"printf\").nonEmpty).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find all loops in the code.",
    "answer": "cpg.controlStructure.loopType.code.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify recursive functions.",
    "answer": "cpg.method.where(_.isRecursive).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve calls to 'sleep'.",
    "answer": "cpg.call.name(\"sleep\").code.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate functions allocating memory inside loops.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"malloc\").nonEmpty).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display functions containing nested loops.",
    "answer": "cpg.method.where(_.controlStructure.loopType.size > 1).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get calls to 'usleep'.",
    "answer": "cpg.call.name(\"usleep\").code.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List functions that call 'free'.",
    "answer": "cpg.method.where(_.call.name(\"free\").nonEmpty).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show functions performing recursion without base case.",
    "answer": "cpg.method.where(_.isRecursive && _.call.name(\"<operator>.equals\").isEmpty).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find loops iterating over arrays.",
    "answer": "cpg.controlStructure.loopType.where(_.code.contains(\"[]\")).code.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify methods that call 'printf' inside loops.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"printf\").nonEmpty).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve all loops in the code.",
    "answer": "cpg.controlStructure.loopType.code.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate recursive functions.",
    "answer": "cpg.method.where(_.isRecursive).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display calls to 'sleep'.",
    "answer": "cpg.call.name(\"sleep\").code.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get functions allocating memory inside loops.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"malloc\").nonEmpty).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List functions containing nested loops.",
    "answer": "cpg.method.where(_.controlStructure.loopType.size > 1).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show calls to 'usleep'.",
    "answer": "cpg.call.name(\"usleep\").code.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find functions that call 'free'.",
    "answer": "cpg.method.where(_.call.name(\"free\").nonEmpty).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify functions performing recursion without base case.",
    "answer": "cpg.method.where(_.isRecursive && _.call.name(\"<operator>.equals\").isEmpty).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve loops iterating over arrays.",
    "answer": "cpg.controlStructure.loopType.where(_.code.contains(\"[]\")).code.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate methods that call 'printf' inside loops.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"printf\").nonEmpty).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display all loops in the code.",
    "answer": "cpg.controlStructure.loopType.code.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get recursive functions.",
    "answer": "cpg.method.where(_.isRecursive).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List calls to 'sleep'.",
    "answer": "cpg.call.name(\"sleep\").code.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show functions allocating memory inside loops.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"malloc\").nonEmpty).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find functions containing nested loops.",
    "answer": "cpg.method.where(_.controlStructure.loopType.size > 1).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify calls to 'usleep'.",
    "answer": "cpg.call.name(\"usleep\").code.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve functions that call 'free'.",
    "answer": "cpg.method.where(_.call.name(\"free\").nonEmpty).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate functions performing recursion without base case.",
    "answer": "cpg.method.where(_.isRecursive && _.call.name(\"<operator>.equals\").isEmpty).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display loops iterating over arrays.",
    "answer": "cpg.controlStructure.loopType.where(_.code.contains(\"[]\")).code.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get methods that call 'printf' inside loops.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"printf\").nonEmpty).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List loops with bounds larger than one million.",
    "answer": "cpg.controlStructure.loopType.where(_.condition.code.matches(\".*< 1000000.*\")).code.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show methods with cyclomatic complexity over 20.",
    "answer": "cpg.method.where(_.cyclomaticComplexity > 20).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find recursive functions with no loop alternative.",
    "answer": "cpg.method.where(_.isRecursive && _.controlStructure.loopType.isEmpty).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify functions that frequently allocate and free memory.",
    "answer": "cpg.method.where(_.call.name(\"malloc|free\").size > 5).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve loops without body content (busy waiting).",
    "answer": "cpg.controlStructure.loopType.where(_.astChildren.isEmpty).code.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate methods containing nested loops with I/O operations.",
    "answer": "cpg.method.where(_.controlStructure.loopType.where(_.call.name(\"read|write\").nonEmpty).size > 1).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display functions that call 'sleep' inside loops.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"sleep\").nonEmpty).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get methods with deep recursion (call depth >5).",
    "answer": "cpg.method.where(_.isRecursive && _.caller.size > 5).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions using global variables inside loops.",
    "answer": "cpg.controlStructure.loopType.where(_.identifier.name(\"global\").nonEmpty).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show loops with bounds larger than one million.",
    "answer": "cpg.controlStructure.loopType.where(_.condition.code.matches(\".*< 1000000.*\")).code.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find methods with cyclomatic complexity over 20.",
    "answer": "cpg.method.where(_.cyclomaticComplexity > 20).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify recursive functions with no loop alternative.",
    "answer": "cpg.method.where(_.isRecursive && _.controlStructure.loopType.isEmpty).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve functions that frequently allocate and free memory.",
    "answer": "cpg.method.where(_.call.name(\"malloc|free\").size > 5).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate loops without body content (busy waiting).",
    "answer": "cpg.controlStructure.loopType.where(_.astChildren.isEmpty).code.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display methods containing nested loops with I/O operations.",
    "answer": "cpg.method.where(_.controlStructure.loopType.where(_.call.name(\"read|write\").nonEmpty).size > 1).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get functions that call 'sleep' inside loops.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"sleep\").nonEmpty).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List methods with deep recursion (call depth >5).",
    "answer": "cpg.method.where(_.isRecursive && _.caller.size > 5).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show functions using global variables inside loops.",
    "answer": "cpg.controlStructure.loopType.where(_.identifier.name(\"global\").nonEmpty).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find loops with bounds larger than one million.",
    "answer": "cpg.controlStructure.loopType.where(_.condition.code.matches(\".*< 1000000.*\")).code.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify methods with cyclomatic complexity over 20.",
    "answer": "cpg.method.where(_.cyclomaticComplexity > 20).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve recursive functions with no loop alternative.",
    "answer": "cpg.method.where(_.isRecursive && _.controlStructure.loopType.isEmpty).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate functions that frequently allocate and free memory.",
    "answer": "cpg.method.where(_.call.name(\"malloc|free\").size > 5).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display loops without body content (busy waiting).",
    "answer": "cpg.controlStructure.loopType.where(_.astChildren.isEmpty).code.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get methods containing nested loops with I/O operations.",
    "answer": "cpg.method.where(_.controlStructure.loopType.where(_.call.name(\"read|write\").nonEmpty).size > 1).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions that call 'sleep' inside loops.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"sleep\").nonEmpty).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show methods with deep recursion (call depth >5).",
    "answer": "cpg.method.where(_.isRecursive && _.caller.size > 5).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find functions using global variables inside loops.",
    "answer": "cpg.controlStructure.loopType.where(_.identifier.name(\"global\").nonEmpty).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify loops with bounds larger than one million.",
    "answer": "cpg.controlStructure.loopType.where(_.condition.code.matches(\".*< 1000000.*\")).code.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve methods with cyclomatic complexity over 20.",
    "answer": "cpg.method.where(_.cyclomaticComplexity > 20).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate recursive functions with no loop alternative.",
    "answer": "cpg.method.where(_.isRecursive && _.controlStructure.loopType.isEmpty).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display functions that frequently allocate and free memory.",
    "answer": "cpg.method.where(_.call.name(\"malloc|free\").size > 5).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get loops without body content (busy waiting).",
    "answer": "cpg.controlStructure.loopType.where(_.astChildren.isEmpty).code.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List methods containing nested loops with I/O operations.",
    "answer": "cpg.method.where(_.controlStructure.loopType.where(_.call.name(\"read|write\").nonEmpty).size > 1).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show functions that call 'sleep' inside loops.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"sleep\").nonEmpty).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find methods with deep recursion (call depth >5).",
    "answer": "cpg.method.where(_.isRecursive && _.caller.size > 5).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List nested loops performing repeated system calls.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"read|write\").nonEmpty).method.where(_.controlStructure.loopType.size > 1).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show recursive methods with large call depth.",
    "answer": "cpg.method.where(_.isRecursive && _.caller.size > 10).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find loops allocating memory without deallocation.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"malloc\").nonEmpty && _.call.name(\"free\").isEmpty).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify nested loops executing database queries.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"db_query\").nonEmpty).method.where(_.controlStructure.loopType.size > 1).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve loops performing expensive operations without caching.",
    "answer": "cpg.controlStructure.loopType.call.where(_.signature.contains(\"expensive\")).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate nested loops performing repeated system calls.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"read|write\").nonEmpty).method.where(_.controlStructure.loopType.size > 1).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display recursive methods with large call depth.",
    "answer": "cpg.method.where(_.isRecursive && _.caller.size > 10).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get loops allocating memory without deallocation.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"malloc\").nonEmpty && _.call.name(\"free\").isEmpty).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List nested loops executing database queries.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"db_query\").nonEmpty).method.where(_.controlStructure.loopType.size > 1).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show loops performing expensive operations without caching.",
    "answer": "cpg.controlStructure.loopType.call.where(_.signature.contains(\"expensive\")).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find nested loops performing repeated system calls.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"read|write\").nonEmpty).method.where(_.controlStructure.loopType.size > 1).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify recursive methods with large call depth.",
    "answer": "cpg.method.where(_.isRecursive && _.caller.size > 10).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve loops allocating memory without deallocation.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"malloc\").nonEmpty && _.call.name(\"free\").isEmpty).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate nested loops executing database queries.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"db_query\").nonEmpty).method.where(_.controlStructure.loopType.size > 1).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display loops performing expensive operations without caching.",
    "answer": "cpg.controlStructure.loopType.call.where(_.signature.contains(\"expensive\")).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get nested loops performing repeated system calls.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"read|write\").nonEmpty).method.where(_.controlStructure.loopType.size > 1).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List recursive methods with large call depth.",
    "answer": "cpg.method.where(_.isRecursive && _.caller.size > 10).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show loops allocating memory without deallocation.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"malloc\").nonEmpty && _.call.name(\"free\").isEmpty).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find nested loops executing database queries.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"db_query\").nonEmpty).method.where(_.controlStructure.loopType.size > 1).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify loops performing expensive operations without caching.",
    "answer": "cpg.controlStructure.loopType.call.where(_.signature.contains(\"expensive\")).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve nested loops performing repeated system calls.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"read|write\").nonEmpty).method.where(_.controlStructure.loopType.size > 1).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate recursive methods with large call depth.",
    "answer": "cpg.method.where(_.isRecursive && _.caller.size > 10).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display loops allocating memory without deallocation.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"malloc\").nonEmpty && _.call.name(\"free\").isEmpty).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get nested loops executing database queries.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"db_query\").nonEmpty).method.where(_.controlStructure.loopType.size > 1).name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List loops performing expensive operations without caching.",
    "answer": "cpg.controlStructure.loopType.call.where(_.signature.contains(\"expensive\")).method.name.l",
    "scenario": 6,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List all test files.",
    "answer": "cpg.file.name(\".*test.*\").l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show functions defined in test files.",
    "answer": "cpg.file.name(\".*test.*\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find test functions that call 'main'.",
    "answer": "cpg.file.name(\".*test.*\").method.where(_.call.name(\"main\").nonEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify methods whose names start with 'test'.",
    "answer": "cpg.method.name(\"^test.*\").l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve test cases using 'assert'.",
    "answer": "cpg.call.name(\"assert\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate test functions using mocks.",
    "answer": "cpg.call.name(\"mock\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display test functions reading from files.",
    "answer": "cpg.file.name(\".*test.*\").method.where(_.call.name(\"fopen|open\").nonEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get test functions using environment variables.",
    "answer": "cpg.file.name(\".*test.*\").method.where(_.call.name(\"getenv\").nonEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List test cases with setup functions.",
    "answer": "cpg.call.name(\"setup\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show test functions that have teardown calls.",
    "answer": "cpg.call.name(\"teardown\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find all test files.",
    "answer": "cpg.file.name(\".*test.*\").l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify functions defined in test files.",
    "answer": "cpg.file.name(\".*test.*\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve test functions that call 'main'.",
    "answer": "cpg.file.name(\".*test.*\").method.where(_.call.name(\"main\").nonEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate methods whose names start with 'test'.",
    "answer": "cpg.method.name(\"^test.*\").l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display test cases using 'assert'.",
    "answer": "cpg.call.name(\"assert\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get test functions using mocks.",
    "answer": "cpg.call.name(\"mock\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List test functions reading from files.",
    "answer": "cpg.file.name(\".*test.*\").method.where(_.call.name(\"fopen|open\").nonEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show test functions using environment variables.",
    "answer": "cpg.file.name(\".*test.*\").method.where(_.call.name(\"getenv\").nonEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find test cases with setup functions.",
    "answer": "cpg.call.name(\"setup\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify test functions that have teardown calls.",
    "answer": "cpg.call.name(\"teardown\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve all test files.",
    "answer": "cpg.file.name(\".*test.*\").l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate functions defined in test files.",
    "answer": "cpg.file.name(\".*test.*\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display test functions that call 'main'.",
    "answer": "cpg.file.name(\".*test.*\").method.where(_.call.name(\"main\").nonEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get methods whose names start with 'test'.",
    "answer": "cpg.method.name(\"^test.*\").l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List test cases using 'assert'.",
    "answer": "cpg.call.name(\"assert\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show test functions using mocks.",
    "answer": "cpg.call.name(\"mock\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find test functions reading from files.",
    "answer": "cpg.file.name(\".*test.*\").method.where(_.call.name(\"fopen|open\").nonEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify test functions using environment variables.",
    "answer": "cpg.file.name(\".*test.*\").method.where(_.call.name(\"getenv\").nonEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve test cases with setup functions.",
    "answer": "cpg.call.name(\"setup\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate test functions that have teardown calls.",
    "answer": "cpg.call.name(\"teardown\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display all test files.",
    "answer": "cpg.file.name(\".*test.*\").l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get functions defined in test files.",
    "answer": "cpg.file.name(\".*test.*\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List test functions that call 'main'.",
    "answer": "cpg.file.name(\".*test.*\").method.where(_.call.name(\"main\").nonEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show methods whose names start with 'test'.",
    "answer": "cpg.method.name(\"^test.*\").l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find test cases using 'assert'.",
    "answer": "cpg.call.name(\"assert\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify test functions using mocks.",
    "answer": "cpg.call.name(\"mock\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve test functions reading from files.",
    "answer": "cpg.file.name(\".*test.*\").method.where(_.call.name(\"fopen|open\").nonEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate test functions using environment variables.",
    "answer": "cpg.file.name(\".*test.*\").method.where(_.call.name(\"getenv\").nonEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display test cases with setup functions.",
    "answer": "cpg.call.name(\"setup\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get test functions that have teardown calls.",
    "answer": "cpg.call.name(\"teardown\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List production functions not called by any test.",
    "answer": "cpg.method.where(_.file.name.not(\".*test.*\") && _.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show tests covering the 'compute' function.",
    "answer": "cpg.method.name(\"compute\").caller.file.name(\".*test.*\").name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find methods covered by tests.",
    "answer": "cpg.file.name(\".*test.*\").callee.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify test functions without any assertions.",
    "answer": "cpg.file.name(\".*test.*\").method.where(_.call.name(\"assert\").isEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve tests using data providers.",
    "answer": "cpg.file.name(\".*test.*\").call.name(\"dataProvider\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate tests invoking performance benchmarks.",
    "answer": "cpg.file.name(\".*test.*\").call.name(\"benchmark\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display test cases that mock network calls.",
    "answer": "cpg.file.name(\".*test.*\").call.name(\"mockNetwork\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get tests that call deprecated functions.",
    "answer": "cpg.file.name(\".*test.*\").call.where(_.callee.isDeprecated).method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List tests that cover error handling paths.",
    "answer": "cpg.file.name(\".*test.*\").method.where(_.call.name(\"perror|exit\").nonEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show production functions not called by any test.",
    "answer": "cpg.method.where(_.file.name.not(\".*test.*\") && _.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find tests covering the 'compute' function.",
    "answer": "cpg.method.name(\"compute\").caller.file.name(\".*test.*\").name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify methods covered by tests.",
    "answer": "cpg.file.name(\".*test.*\").callee.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve test functions without any assertions.",
    "answer": "cpg.file.name(\".*test.*\").method.where(_.call.name(\"assert\").isEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate tests using data providers.",
    "answer": "cpg.file.name(\".*test.*\").call.name(\"dataProvider\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display tests invoking performance benchmarks.",
    "answer": "cpg.file.name(\".*test.*\").call.name(\"benchmark\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get test cases that mock network calls.",
    "answer": "cpg.file.name(\".*test.*\").call.name(\"mockNetwork\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List tests that call deprecated functions.",
    "answer": "cpg.file.name(\".*test.*\").call.where(_.callee.isDeprecated).method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show tests that cover error handling paths.",
    "answer": "cpg.file.name(\".*test.*\").method.where(_.call.name(\"perror|exit\").nonEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find production functions not called by any test.",
    "answer": "cpg.method.where(_.file.name.not(\".*test.*\") && _.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify tests covering the 'compute' function.",
    "answer": "cpg.method.name(\"compute\").caller.file.name(\".*test.*\").name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve methods covered by tests.",
    "answer": "cpg.file.name(\".*test.*\").callee.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate test functions without any assertions.",
    "answer": "cpg.file.name(\".*test.*\").method.where(_.call.name(\"assert\").isEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display tests using data providers.",
    "answer": "cpg.file.name(\".*test.*\").call.name(\"dataProvider\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get tests invoking performance benchmarks.",
    "answer": "cpg.file.name(\".*test.*\").call.name(\"benchmark\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List test cases that mock network calls.",
    "answer": "cpg.file.name(\".*test.*\").call.name(\"mockNetwork\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show tests that call deprecated functions.",
    "answer": "cpg.file.name(\".*test.*\").call.where(_.callee.isDeprecated).method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find tests that cover error handling paths.",
    "answer": "cpg.file.name(\".*test.*\").method.where(_.call.name(\"perror|exit\").nonEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify production functions not called by any test.",
    "answer": "cpg.method.where(_.file.name.not(\".*test.*\") && _.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve tests covering the 'compute' function.",
    "answer": "cpg.method.name(\"compute\").caller.file.name(\".*test.*\").name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate methods covered by tests.",
    "answer": "cpg.file.name(\".*test.*\").callee.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display test functions without any assertions.",
    "answer": "cpg.file.name(\".*test.*\").method.where(_.call.name(\"assert\").isEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get tests using data providers.",
    "answer": "cpg.file.name(\".*test.*\").call.name(\"dataProvider\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List tests invoking performance benchmarks.",
    "answer": "cpg.file.name(\".*test.*\").call.name(\"benchmark\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show test cases that mock network calls.",
    "answer": "cpg.file.name(\".*test.*\").call.name(\"mockNetwork\").method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find tests that call deprecated functions.",
    "answer": "cpg.file.name(\".*test.*\").call.where(_.callee.isDeprecated).method.name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List code areas not covered by any test.",
    "answer": "cpg.method.where(_.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show public API functions without test coverage.",
    "answer": "cpg.method.isPublic.where(_.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find data flows from test inputs to function outputs.",
    "answer": "cpg.file.name(\".*test.*\").call.argument.reachableByFlows(cpg.method.parameter).locations.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify functions where negative branches are untested.",
    "answer": "cpg.method.where(_.controlStructure.size > 0 && _.caller.file.name(\".*test.*\").size < 2).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve benchmark-critical functions without coverage.",
    "answer": "cpg.method.where(_.annotation(\"Benchmark\").isDefined && _.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate code areas not covered by any test.",
    "answer": "cpg.method.where(_.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display public API functions without test coverage.",
    "answer": "cpg.method.isPublic.where(_.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get data flows from test inputs to function outputs.",
    "answer": "cpg.file.name(\".*test.*\").call.argument.reachableByFlows(cpg.method.parameter).locations.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List functions where negative branches are untested.",
    "answer": "cpg.method.where(_.controlStructure.size > 0 && _.caller.file.name(\".*test.*\").size < 2).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show benchmark-critical functions without coverage.",
    "answer": "cpg.method.where(_.annotation(\"Benchmark\").isDefined && _.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find code areas not covered by any test.",
    "answer": "cpg.method.where(_.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify public API functions without test coverage.",
    "answer": "cpg.method.isPublic.where(_.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve data flows from test inputs to function outputs.",
    "answer": "cpg.file.name(\".*test.*\").call.argument.reachableByFlows(cpg.method.parameter).locations.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate functions where negative branches are untested.",
    "answer": "cpg.method.where(_.controlStructure.size > 0 && _.caller.file.name(\".*test.*\").size < 2).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display benchmark-critical functions without coverage.",
    "answer": "cpg.method.where(_.annotation(\"Benchmark\").isDefined && _.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get code areas not covered by any test.",
    "answer": "cpg.method.where(_.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List public API functions without test coverage.",
    "answer": "cpg.method.isPublic.where(_.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show data flows from test inputs to function outputs.",
    "answer": "cpg.file.name(\".*test.*\").call.argument.reachableByFlows(cpg.method.parameter).locations.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find functions where negative branches are untested.",
    "answer": "cpg.method.where(_.controlStructure.size > 0 && _.caller.file.name(\".*test.*\").size < 2).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify benchmark-critical functions without coverage.",
    "answer": "cpg.method.where(_.annotation(\"Benchmark\").isDefined && _.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve code areas not covered by any test.",
    "answer": "cpg.method.where(_.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate public API functions without test coverage.",
    "answer": "cpg.method.isPublic.where(_.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display data flows from test inputs to function outputs.",
    "answer": "cpg.file.name(\".*test.*\").call.argument.reachableByFlows(cpg.method.parameter).locations.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get functions where negative branches are untested.",
    "answer": "cpg.method.where(_.controlStructure.size > 0 && _.caller.file.name(\".*test.*\").size < 2).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List benchmark-critical functions without coverage.",
    "answer": "cpg.method.where(_.annotation(\"Benchmark\").isDefined && _.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 7,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List calls to cryptographic functions MD5 or SHA1.",
    "answer": "cpg.call.name(\"MD5|md5|SHA1|sha1\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show uses of the 'rand' random number generator.",
    "answer": "cpg.call.name(\"rand\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find hardcoded credentials in strings.",
    "answer": "cpg.literal.code(\"\"[A-Za-z0-9]{8,}\"\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify TLS or SSL protocol versions used.",
    "answer": "cpg.literal.code(\"TLSv1.0|SSLv3\").l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve functions that disable certificate validation.",
    "answer": "cpg.call.name(\"SSL_CTX_set_verify\").where(_.argument.code.contains(\"SSL_VERIFY_NONE\")).method.name.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate uses of DES encryption functions.",
    "answer": "cpg.call.name(\"DES_.*\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display calls to 'strcpy' into fixed-size buffers.",
    "answer": "cpg.call.name(\"strcpy\").where(_.argument(1).code.contains(\"[\")).code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get insecure HTTP URLs in literals.",
    "answer": "cpg.literal.code(\"http://.*\").l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List uses of insecure hashing algorithms.",
    "answer": "cpg.call.name(\"MD4|md4|ripemd\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show calls to 'strdup' that might leak memory.",
    "answer": "cpg.call.name(\"strdup\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find calls to cryptographic functions MD5 or SHA1.",
    "answer": "cpg.call.name(\"MD5|md5|SHA1|sha1\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify uses of the 'rand' random number generator.",
    "answer": "cpg.call.name(\"rand\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve hardcoded credentials in strings.",
    "answer": "cpg.literal.code(\"\"[A-Za-z0-9]{8,}\"\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate TLS or SSL protocol versions used.",
    "answer": "cpg.literal.code(\"TLSv1.0|SSLv3\").l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display functions that disable certificate validation.",
    "answer": "cpg.call.name(\"SSL_CTX_set_verify\").where(_.argument.code.contains(\"SSL_VERIFY_NONE\")).method.name.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get uses of DES encryption functions.",
    "answer": "cpg.call.name(\"DES_.*\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List calls to 'strcpy' into fixed-size buffers.",
    "answer": "cpg.call.name(\"strcpy\").where(_.argument(1).code.contains(\"[\")).code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show insecure HTTP URLs in literals.",
    "answer": "cpg.literal.code(\"http://.*\").l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find uses of insecure hashing algorithms.",
    "answer": "cpg.call.name(\"MD4|md4|ripemd\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify calls to 'strdup' that might leak memory.",
    "answer": "cpg.call.name(\"strdup\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve calls to cryptographic functions MD5 or SHA1.",
    "answer": "cpg.call.name(\"MD5|md5|SHA1|sha1\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate uses of the 'rand' random number generator.",
    "answer": "cpg.call.name(\"rand\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display hardcoded credentials in strings.",
    "answer": "cpg.literal.code(\"\"[A-Za-z0-9]{8,}\"\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get TLS or SSL protocol versions used.",
    "answer": "cpg.literal.code(\"TLSv1.0|SSLv3\").l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List functions that disable certificate validation.",
    "answer": "cpg.call.name(\"SSL_CTX_set_verify\").where(_.argument.code.contains(\"SSL_VERIFY_NONE\")).method.name.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show uses of DES encryption functions.",
    "answer": "cpg.call.name(\"DES_.*\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find calls to 'strcpy' into fixed-size buffers.",
    "answer": "cpg.call.name(\"strcpy\").where(_.argument(1).code.contains(\"[\")).code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify insecure HTTP URLs in literals.",
    "answer": "cpg.literal.code(\"http://.*\").l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve uses of insecure hashing algorithms.",
    "answer": "cpg.call.name(\"MD4|md4|ripemd\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate calls to 'strdup' that might leak memory.",
    "answer": "cpg.call.name(\"strdup\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display calls to cryptographic functions MD5 or SHA1.",
    "answer": "cpg.call.name(\"MD5|md5|SHA1|sha1\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get uses of the 'rand' random number generator.",
    "answer": "cpg.call.name(\"rand\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List hardcoded credentials in strings.",
    "answer": "cpg.literal.code(\"\"[A-Za-z0-9]{8,}\"\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show TLS or SSL protocol versions used.",
    "answer": "cpg.literal.code(\"TLSv1.0|SSLv3\").l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find functions that disable certificate validation.",
    "answer": "cpg.call.name(\"SSL_CTX_set_verify\").where(_.argument.code.contains(\"SSL_VERIFY_NONE\")).method.name.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify uses of DES encryption functions.",
    "answer": "cpg.call.name(\"DES_.*\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve calls to 'strcpy' into fixed-size buffers.",
    "answer": "cpg.call.name(\"strcpy\").where(_.argument(1).code.contains(\"[\")).code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate insecure HTTP URLs in literals.",
    "answer": "cpg.literal.code(\"http://.*\").l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display uses of insecure hashing algorithms.",
    "answer": "cpg.call.name(\"MD4|md4|ripemd\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get calls to 'strdup' that might leak memory.",
    "answer": "cpg.call.name(\"strdup\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List encryption functions used with ECB mode.",
    "answer": "cpg.call.name(\"AES_set_encrypt_key\").where(_.argument.code.contains(\"ECB\")).method.name.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show personal data flowing to logging functions.",
    "answer": "cpg.call.name(\"printf|fprintf\").where(_.argument.reachableBy(cpg.identifier.name(\"password|ssn\")).nonEmpty).l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find uses of insecure hashing functions like MD4 or RIPEMD.",
    "answer": "cpg.call.name(\"MD4|md4|ripemd\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify copies using 'strcpy' into arrays.",
    "answer": "cpg.call.name(\"strcpy\").where(_.argument(1).code.contains(\"[\")).code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve insecure HTTP protocol usages in network calls.",
    "answer": "cpg.literal.code(\"http://.*\").l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate uses of insecure random functions for cryptographic tokens.",
    "answer": "cpg.call.name(\"rand\").method.name.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display functions that log sensitive data.",
    "answer": "cpg.call.name(\"log\").where(_.argument.reachableBy(cpg.identifier.name(\"password|secret\")).nonEmpty).method.name.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get calls to 'sprintf' that may overflow.",
    "answer": "cpg.call.name(\"sprintf\").where(_.argument.size < 3).code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List insecure hashing within loops.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"MD5|SHA1\").nonEmpty).code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show encryption functions used with ECB mode.",
    "answer": "cpg.call.name(\"AES_set_encrypt_key\").where(_.argument.code.contains(\"ECB\")).method.name.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find personal data flowing to logging functions.",
    "answer": "cpg.call.name(\"printf|fprintf\").where(_.argument.reachableBy(cpg.identifier.name(\"password|ssn\")).nonEmpty).l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify uses of insecure hashing functions like MD4 or RIPEMD.",
    "answer": "cpg.call.name(\"MD4|md4|ripemd\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve copies using 'strcpy' into arrays.",
    "answer": "cpg.call.name(\"strcpy\").where(_.argument(1).code.contains(\"[\")).code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate insecure HTTP protocol usages in network calls.",
    "answer": "cpg.literal.code(\"http://.*\").l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display uses of insecure random functions for cryptographic tokens.",
    "answer": "cpg.call.name(\"rand\").method.name.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get functions that log sensitive data.",
    "answer": "cpg.call.name(\"log\").where(_.argument.reachableBy(cpg.identifier.name(\"password|secret\")).nonEmpty).method.name.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List calls to 'sprintf' that may overflow.",
    "answer": "cpg.call.name(\"sprintf\").where(_.argument.size < 3).code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show insecure hashing within loops.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"MD5|SHA1\").nonEmpty).code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find encryption functions used with ECB mode.",
    "answer": "cpg.call.name(\"AES_set_encrypt_key\").where(_.argument.code.contains(\"ECB\")).method.name.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify personal data flowing to logging functions.",
    "answer": "cpg.call.name(\"printf|fprintf\").where(_.argument.reachableBy(cpg.identifier.name(\"password|ssn\")).nonEmpty).l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve uses of insecure hashing functions like MD4 or RIPEMD.",
    "answer": "cpg.call.name(\"MD4|md4|ripemd\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate copies using 'strcpy' into arrays.",
    "answer": "cpg.call.name(\"strcpy\").where(_.argument(1).code.contains(\"[\")).code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display insecure HTTP protocol usages in network calls.",
    "answer": "cpg.literal.code(\"http://.*\").l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get uses of insecure random functions for cryptographic tokens.",
    "answer": "cpg.call.name(\"rand\").method.name.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions that log sensitive data.",
    "answer": "cpg.call.name(\"log\").where(_.argument.reachableBy(cpg.identifier.name(\"password|secret\")).nonEmpty).method.name.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show calls to 'sprintf' that may overflow.",
    "answer": "cpg.call.name(\"sprintf\").where(_.argument.size < 3).code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find insecure hashing within loops.",
    "answer": "cpg.controlStructure.loopType.where(_.call.name(\"MD5|SHA1\").nonEmpty).code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify encryption functions used with ECB mode.",
    "answer": "cpg.call.name(\"AES_set_encrypt_key\").where(_.argument.code.contains(\"ECB\")).method.name.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve personal data flowing to logging functions.",
    "answer": "cpg.call.name(\"printf|fprintf\").where(_.argument.reachableBy(cpg.identifier.name(\"password|ssn\")).nonEmpty).l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate uses of insecure hashing functions like MD4 or RIPEMD.",
    "answer": "cpg.call.name(\"MD4|md4|ripemd\").code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display copies using 'strcpy' into arrays.",
    "answer": "cpg.call.name(\"strcpy\").where(_.argument(1).code.contains(\"[\")).code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get insecure HTTP protocol usages in network calls.",
    "answer": "cpg.literal.code(\"http://.*\").l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List uses of insecure random functions for cryptographic tokens.",
    "answer": "cpg.call.name(\"rand\").method.name.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show functions that log sensitive data.",
    "answer": "cpg.call.name(\"log\").where(_.argument.reachableBy(cpg.identifier.name(\"password|secret\")).nonEmpty).method.name.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find calls to 'sprintf' that may overflow.",
    "answer": "cpg.call.name(\"sprintf\").where(_.argument.size < 3).code.l",
    "scenario": 8,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List sensitive data flowing to printf.",
    "answer": "cpg.call.name(\"printf\").where(_.argument.reachableBy(cpg.identifier.name(\"password\")).nonEmpty).l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show insecure cryptography usage across modules.",
    "answer": "cpg.call.name(\"DES_.*|des_.*\").where(_.method.file.name.not(\".*test.*\")).l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find credentials sent over network.",
    "answer": "cpg.call.name(\"send|write\").where(_.argument.reachableBy(cpg.identifier.name(\"user|password\")).nonEmpty).l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify personal data written to files.",
    "answer": "cpg.call.name(\"fwrite|write\").where(_.argument.reachableBy(cpg.identifier.name(\"ssn|creditCard\")).nonEmpty).l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve deprecated SSL protocols usage in the call graph.",
    "answer": "cpg.call.name(\"SSLv2|SSLv3|TLSv1\").caller.repeat(_.caller).name.l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate sensitive data flowing to printf.",
    "answer": "cpg.call.name(\"printf\").where(_.argument.reachableBy(cpg.identifier.name(\"password\")).nonEmpty).l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display insecure cryptography usage across modules.",
    "answer": "cpg.call.name(\"DES_.*|des_.*\").where(_.method.file.name.not(\".*test.*\")).l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get credentials sent over network.",
    "answer": "cpg.call.name(\"send|write\").where(_.argument.reachableBy(cpg.identifier.name(\"user|password\")).nonEmpty).l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List personal data written to files.",
    "answer": "cpg.call.name(\"fwrite|write\").where(_.argument.reachableBy(cpg.identifier.name(\"ssn|creditCard\")).nonEmpty).l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show deprecated SSL protocols usage in the call graph.",
    "answer": "cpg.call.name(\"SSLv2|SSLv3|TLSv1\").caller.repeat(_.caller).name.l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find sensitive data flowing to printf.",
    "answer": "cpg.call.name(\"printf\").where(_.argument.reachableBy(cpg.identifier.name(\"password\")).nonEmpty).l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify insecure cryptography usage across modules.",
    "answer": "cpg.call.name(\"DES_.*|des_.*\").where(_.method.file.name.not(\".*test.*\")).l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve credentials sent over network.",
    "answer": "cpg.call.name(\"send|write\").where(_.argument.reachableBy(cpg.identifier.name(\"user|password\")).nonEmpty).l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate personal data written to files.",
    "answer": "cpg.call.name(\"fwrite|write\").where(_.argument.reachableBy(cpg.identifier.name(\"ssn|creditCard\")).nonEmpty).l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display deprecated SSL protocols usage in the call graph.",
    "answer": "cpg.call.name(\"SSLv2|SSLv3|TLSv1\").caller.repeat(_.caller).name.l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get sensitive data flowing to printf.",
    "answer": "cpg.call.name(\"printf\").where(_.argument.reachableBy(cpg.identifier.name(\"password\")).nonEmpty).l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List insecure cryptography usage across modules.",
    "answer": "cpg.call.name(\"DES_.*|des_.*\").where(_.method.file.name.not(\".*test.*\")).l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show credentials sent over network.",
    "answer": "cpg.call.name(\"send|write\").where(_.argument.reachableBy(cpg.identifier.name(\"user|password\")).nonEmpty).l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find personal data written to files.",
    "answer": "cpg.call.name(\"fwrite|write\").where(_.argument.reachableBy(cpg.identifier.name(\"ssn|creditCard\")).nonEmpty).l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify deprecated SSL protocols usage in the call graph.",
    "answer": "cpg.call.name(\"SSLv2|SSLv3|TLSv1\").caller.repeat(_.caller).name.l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve sensitive data flowing to printf.",
    "answer": "cpg.call.name(\"printf\").where(_.argument.reachableBy(cpg.identifier.name(\"password\")).nonEmpty).l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate insecure cryptography usage across modules.",
    "answer": "cpg.call.name(\"DES_.*|des_.*\").where(_.method.file.name.not(\".*test.*\")).l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display credentials sent over network.",
    "answer": "cpg.call.name(\"send|write\").where(_.argument.reachableBy(cpg.identifier.name(\"user|password\")).nonEmpty).l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get personal data written to files.",
    "answer": "cpg.call.name(\"fwrite|write\").where(_.argument.reachableBy(cpg.identifier.name(\"ssn|creditCard\")).nonEmpty).l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List deprecated SSL protocols usage in the call graph.",
    "answer": "cpg.call.name(\"SSLv2|SSLv3|TLSv1\").caller.repeat(_.caller).name.l",
    "scenario": 8,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List recently changed files.",
    "answer": "cpg.file.where(_.tagList.contains(\"recent-change\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show functions with TODO comments.",
    "answer": "cpg.method.comment.code(\".*TODO.*\").method.name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find functions modified in the last commit.",
    "answer": "cpg.method.where(_.tagList.contains(\"modified\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify functions with high change frequency.",
    "answer": "cpg.method.where(_.tagList.count(_ == \"change\") > 5).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve new public methods added recently.",
    "answer": "cpg.method.isPublic.where(_.tagList.contains(\"recent-change\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate lines modified by formatting changes.",
    "answer": "cpg.method.where(_.tagList.contains(\"format-change\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display functions changed by multiple developers.",
    "answer": "cpg.method.where(_.tagList.contains(\"multi-author\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get deprecated functions used in recent changes.",
    "answer": "cpg.call.where(_.tagList.contains(\"recent-change\") && _.callee.isDeprecated).code.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List recently added functions without comments.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\") && _.comment.isEmpty).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show files with large modifications in one commit.",
    "answer": "cpg.file.where(_.tagList.contains(\"big-change\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find recently changed files.",
    "answer": "cpg.file.where(_.tagList.contains(\"recent-change\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify functions with TODO comments.",
    "answer": "cpg.method.comment.code(\".*TODO.*\").method.name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve functions modified in the last commit.",
    "answer": "cpg.method.where(_.tagList.contains(\"modified\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate functions with high change frequency.",
    "answer": "cpg.method.where(_.tagList.count(_ == \"change\") > 5).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display new public methods added recently.",
    "answer": "cpg.method.isPublic.where(_.tagList.contains(\"recent-change\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get lines modified by formatting changes.",
    "answer": "cpg.method.where(_.tagList.contains(\"format-change\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List functions changed by multiple developers.",
    "answer": "cpg.method.where(_.tagList.contains(\"multi-author\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show deprecated functions used in recent changes.",
    "answer": "cpg.call.where(_.tagList.contains(\"recent-change\") && _.callee.isDeprecated).code.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find recently added functions without comments.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\") && _.comment.isEmpty).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify files with large modifications in one commit.",
    "answer": "cpg.file.where(_.tagList.contains(\"big-change\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve recently changed files.",
    "answer": "cpg.file.where(_.tagList.contains(\"recent-change\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate functions with TODO comments.",
    "answer": "cpg.method.comment.code(\".*TODO.*\").method.name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display functions modified in the last commit.",
    "answer": "cpg.method.where(_.tagList.contains(\"modified\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get functions with high change frequency.",
    "answer": "cpg.method.where(_.tagList.count(_ == \"change\") > 5).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List new public methods added recently.",
    "answer": "cpg.method.isPublic.where(_.tagList.contains(\"recent-change\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show lines modified by formatting changes.",
    "answer": "cpg.method.where(_.tagList.contains(\"format-change\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find functions changed by multiple developers.",
    "answer": "cpg.method.where(_.tagList.contains(\"multi-author\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify deprecated functions used in recent changes.",
    "answer": "cpg.call.where(_.tagList.contains(\"recent-change\") && _.callee.isDeprecated).code.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve recently added functions without comments.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\") && _.comment.isEmpty).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate files with large modifications in one commit.",
    "answer": "cpg.file.where(_.tagList.contains(\"big-change\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display recently changed files.",
    "answer": "cpg.file.where(_.tagList.contains(\"recent-change\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get functions with TODO comments.",
    "answer": "cpg.method.comment.code(\".*TODO.*\").method.name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List functions modified in the last commit.",
    "answer": "cpg.method.where(_.tagList.contains(\"modified\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show functions with high change frequency.",
    "answer": "cpg.method.where(_.tagList.count(_ == \"change\") > 5).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find new public methods added recently.",
    "answer": "cpg.method.isPublic.where(_.tagList.contains(\"recent-change\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify lines modified by formatting changes.",
    "answer": "cpg.method.where(_.tagList.contains(\"format-change\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve functions changed by multiple developers.",
    "answer": "cpg.method.where(_.tagList.contains(\"multi-author\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate deprecated functions used in recent changes.",
    "answer": "cpg.call.where(_.tagList.contains(\"recent-change\") && _.callee.isDeprecated).code.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display recently added functions without comments.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\") && _.comment.isEmpty).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get files with large modifications in one commit.",
    "answer": "cpg.file.where(_.tagList.contains(\"big-change\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List new functions that lack unit tests.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\") && _.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show functions with indentation changes.",
    "answer": "cpg.method.where(_.tagList.contains(\"format-change\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find code blocks modified by more than one author.",
    "answer": "cpg.method.where(_.tagList.contains(\"multi-author\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify recently changed functions that call deprecated functions.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\") && _.call.where(_.callee.isDeprecated).nonEmpty).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve tests missing for newly added public APIs.",
    "answer": "cpg.method.isPublic.where(_.tagList.contains(\"recent-change\") && _.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate functions with high churn rate.",
    "answer": "cpg.method.where(_.tagList.count(_ == \"change\") > 10).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display recently added functions that use global variables.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\") && _.local.name(\"global\").nonEmpty).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get methods introduced in refactors that cross modules.",
    "answer": "cpg.method.where(_.tagList.contains(\"refactor\") && _.caller.file.size > 1).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List recently changed functions with no parameter validation.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\") && _.call.name(\"assert\").isEmpty).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show new functions that lack unit tests.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\") && _.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find functions with indentation changes.",
    "answer": "cpg.method.where(_.tagList.contains(\"format-change\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify code blocks modified by more than one author.",
    "answer": "cpg.method.where(_.tagList.contains(\"multi-author\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve recently changed functions that call deprecated functions.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\") && _.call.where(_.callee.isDeprecated).nonEmpty).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate tests missing for newly added public APIs.",
    "answer": "cpg.method.isPublic.where(_.tagList.contains(\"recent-change\") && _.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display functions with high churn rate.",
    "answer": "cpg.method.where(_.tagList.count(_ == \"change\") > 10).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get recently added functions that use global variables.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\") && _.local.name(\"global\").nonEmpty).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List methods introduced in refactors that cross modules.",
    "answer": "cpg.method.where(_.tagList.contains(\"refactor\") && _.caller.file.size > 1).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show recently changed functions with no parameter validation.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\") && _.call.name(\"assert\").isEmpty).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find new functions that lack unit tests.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\") && _.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify functions with indentation changes.",
    "answer": "cpg.method.where(_.tagList.contains(\"format-change\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve code blocks modified by more than one author.",
    "answer": "cpg.method.where(_.tagList.contains(\"multi-author\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate recently changed functions that call deprecated functions.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\") && _.call.where(_.callee.isDeprecated).nonEmpty).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display tests missing for newly added public APIs.",
    "answer": "cpg.method.isPublic.where(_.tagList.contains(\"recent-change\") && _.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get functions with high churn rate.",
    "answer": "cpg.method.where(_.tagList.count(_ == \"change\") > 10).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List recently added functions that use global variables.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\") && _.local.name(\"global\").nonEmpty).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show methods introduced in refactors that cross modules.",
    "answer": "cpg.method.where(_.tagList.contains(\"refactor\") && _.caller.file.size > 1).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find recently changed functions with no parameter validation.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\") && _.call.name(\"assert\").isEmpty).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify new functions that lack unit tests.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\") && _.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve functions with indentation changes.",
    "answer": "cpg.method.where(_.tagList.contains(\"format-change\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate code blocks modified by more than one author.",
    "answer": "cpg.method.where(_.tagList.contains(\"multi-author\")).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display recently changed functions that call deprecated functions.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\") && _.call.where(_.callee.isDeprecated).nonEmpty).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get tests missing for newly added public APIs.",
    "answer": "cpg.method.isPublic.where(_.tagList.contains(\"recent-change\") && _.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions with high churn rate.",
    "answer": "cpg.method.where(_.tagList.count(_ == \"change\") > 10).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show recently added functions that use global variables.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\") && _.local.name(\"global\").nonEmpty).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find methods introduced in refactors that cross modules.",
    "answer": "cpg.method.where(_.tagList.contains(\"refactor\") && _.caller.file.size > 1).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List impact of changes to the 'coreFunc' function.",
    "answer": "cpg.method.name(\"coreFunc\").caller.repeat(_.caller).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show possible regressions from modifying global variables.",
    "answer": "cpg.tag.name(\"recent-change\").method.where(_.local.name(\"globalVar\")).caller.name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find changed functions leading to security-critical sinks.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\")).call.name(\"system|exec|open\").code.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify new data flows introduced by recent changes.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\")).argument.reachableByFlows(cpg.call.name(\"recv|read\")).locations.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve cross-module dependencies created during refactorings.",
    "answer": "cpg.method.where(_.tagList.contains(\"refactor\")).caller.caller.name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate impact of changes to the 'coreFunc' function.",
    "answer": "cpg.method.name(\"coreFunc\").caller.repeat(_.caller).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display possible regressions from modifying global variables.",
    "answer": "cpg.tag.name(\"recent-change\").method.where(_.local.name(\"globalVar\")).caller.name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get changed functions leading to security-critical sinks.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\")).call.name(\"system|exec|open\").code.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List new data flows introduced by recent changes.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\")).argument.reachableByFlows(cpg.call.name(\"recv|read\")).locations.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show cross-module dependencies created during refactorings.",
    "answer": "cpg.method.where(_.tagList.contains(\"refactor\")).caller.caller.name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find impact of changes to the 'coreFunc' function.",
    "answer": "cpg.method.name(\"coreFunc\").caller.repeat(_.caller).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify possible regressions from modifying global variables.",
    "answer": "cpg.tag.name(\"recent-change\").method.where(_.local.name(\"globalVar\")).caller.name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve changed functions leading to security-critical sinks.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\")).call.name(\"system|exec|open\").code.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate new data flows introduced by recent changes.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\")).argument.reachableByFlows(cpg.call.name(\"recv|read\")).locations.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display cross-module dependencies created during refactorings.",
    "answer": "cpg.method.where(_.tagList.contains(\"refactor\")).caller.caller.name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get impact of changes to the 'coreFunc' function.",
    "answer": "cpg.method.name(\"coreFunc\").caller.repeat(_.caller).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List possible regressions from modifying global variables.",
    "answer": "cpg.tag.name(\"recent-change\").method.where(_.local.name(\"globalVar\")).caller.name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show changed functions leading to security-critical sinks.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\")).call.name(\"system|exec|open\").code.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find new data flows introduced by recent changes.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\")).argument.reachableByFlows(cpg.call.name(\"recv|read\")).locations.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify cross-module dependencies created during refactorings.",
    "answer": "cpg.method.where(_.tagList.contains(\"refactor\")).caller.caller.name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve impact of changes to the 'coreFunc' function.",
    "answer": "cpg.method.name(\"coreFunc\").caller.repeat(_.caller).name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate possible regressions from modifying global variables.",
    "answer": "cpg.tag.name(\"recent-change\").method.where(_.local.name(\"globalVar\")).caller.name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display changed functions leading to security-critical sinks.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\")).call.name(\"system|exec|open\").code.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get new data flows introduced by recent changes.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\")).argument.reachableByFlows(cpg.call.name(\"recv|read\")).locations.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List cross-module dependencies created during refactorings.",
    "answer": "cpg.method.where(_.tagList.contains(\"refactor\")).caller.caller.name.l",
    "scenario": 9,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List functions with the same name across repositories.",
    "answer": "cpg.method.groupBy(_.name).filter(_._2.size > 1).map(_._1).l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show calls to functions defined in a different repository.",
    "answer": "cpg.call.where(_.method.file != _.callee.file).code.l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find shared type declarations across repositories.",
    "answer": "cpg.typeDecl.groupBy(_.name).filter(_._2.size > 1).map(_._1).l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify files imported from external repositories.",
    "answer": "cpg.file.name(\"^../\").l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve functions from repoA used in repoB.",
    "answer": "cpg.method.where(_.file.name.startsWith(\"repoA\")).callee.where(_.file.name.startsWith(\"repoB\")).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate calls crossing repository boundaries.",
    "answer": "cpg.call.where(_.callee.file.name != _.file.name).code.l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display types defined in one repository and used in another.",
    "answer": "cpg.typeDecl.where(_.referencingMembers.file.name.distinct.size > 1).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get functions defined outside the current repository.",
    "answer": "cpg.method.where(_.file.name.startsWith(\"../\")).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List duplicated functions across repositories.",
    "answer": "cpg.method.groupBy(_.signature).filter(_._2.size > 1).map(_._1).l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show calls into external APIs.",
    "answer": "cpg.call.where(_.callee.fullName.startsWith(\"external::\")).code.l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find functions with the same name across repositories.",
    "answer": "cpg.method.groupBy(_.name).filter(_._2.size > 1).map(_._1).l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify calls to functions defined in a different repository.",
    "answer": "cpg.call.where(_.method.file != _.callee.file).code.l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve shared type declarations across repositories.",
    "answer": "cpg.typeDecl.groupBy(_.name).filter(_._2.size > 1).map(_._1).l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate files imported from external repositories.",
    "answer": "cpg.file.name(\"^../\").l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display functions from repoA used in repoB.",
    "answer": "cpg.method.where(_.file.name.startsWith(\"repoA\")).callee.where(_.file.name.startsWith(\"repoB\")).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get calls crossing repository boundaries.",
    "answer": "cpg.call.where(_.callee.file.name != _.file.name).code.l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List types defined in one repository and used in another.",
    "answer": "cpg.typeDecl.where(_.referencingMembers.file.name.distinct.size > 1).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show functions defined outside the current repository.",
    "answer": "cpg.method.where(_.file.name.startsWith(\"../\")).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find duplicated functions across repositories.",
    "answer": "cpg.method.groupBy(_.signature).filter(_._2.size > 1).map(_._1).l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify calls into external APIs.",
    "answer": "cpg.call.where(_.callee.fullName.startsWith(\"external::\")).code.l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve functions with the same name across repositories.",
    "answer": "cpg.method.groupBy(_.name).filter(_._2.size > 1).map(_._1).l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate calls to functions defined in a different repository.",
    "answer": "cpg.call.where(_.method.file != _.callee.file).code.l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display shared type declarations across repositories.",
    "answer": "cpg.typeDecl.groupBy(_.name).filter(_._2.size > 1).map(_._1).l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get files imported from external repositories.",
    "answer": "cpg.file.name(\"^../\").l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List functions from repoA used in repoB.",
    "answer": "cpg.method.where(_.file.name.startsWith(\"repoA\")).callee.where(_.file.name.startsWith(\"repoB\")).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show calls crossing repository boundaries.",
    "answer": "cpg.call.where(_.callee.file.name != _.file.name).code.l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find types defined in one repository and used in another.",
    "answer": "cpg.typeDecl.where(_.referencingMembers.file.name.distinct.size > 1).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify functions defined outside the current repository.",
    "answer": "cpg.method.where(_.file.name.startsWith(\"../\")).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve duplicated functions across repositories.",
    "answer": "cpg.method.groupBy(_.signature).filter(_._2.size > 1).map(_._1).l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate calls into external APIs.",
    "answer": "cpg.call.where(_.callee.fullName.startsWith(\"external::\")).code.l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display functions with the same name across repositories.",
    "answer": "cpg.method.groupBy(_.name).filter(_._2.size > 1).map(_._1).l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get calls to functions defined in a different repository.",
    "answer": "cpg.call.where(_.method.file != _.callee.file).code.l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List shared type declarations across repositories.",
    "answer": "cpg.typeDecl.groupBy(_.name).filter(_._2.size > 1).map(_._1).l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show files imported from external repositories.",
    "answer": "cpg.file.name(\"^../\").l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find functions from repoA used in repoB.",
    "answer": "cpg.method.where(_.file.name.startsWith(\"repoA\")).callee.where(_.file.name.startsWith(\"repoB\")).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify calls crossing repository boundaries.",
    "answer": "cpg.call.where(_.callee.file.name != _.file.name).code.l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve types defined in one repository and used in another.",
    "answer": "cpg.typeDecl.where(_.referencingMembers.file.name.distinct.size > 1).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate functions defined outside the current repository.",
    "answer": "cpg.method.where(_.file.name.startsWith(\"../\")).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display duplicated functions across repositories.",
    "answer": "cpg.method.groupBy(_.signature).filter(_._2.size > 1).map(_._1).l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get calls into external APIs.",
    "answer": "cpg.call.where(_.callee.fullName.startsWith(\"external::\")).code.l",
    "scenario": 10,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List cross-repository functions called by multiple repositories.",
    "answer": "cpg.method.where(_.caller.file.name.distinct.size > 1).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show types defined in one repository and extended in others.",
    "answer": "cpg.typeDecl.where(_.inheritsFromType.nonEmpty && _.inheritsFromType.file.name != _.file.name).map(t => (t.name, t.inheritsFromType.name)).l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find functions changed in one repository breaking dependencies in others.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\") && _.caller.file.name.contains(\"otherRepo\")).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify data flows across repository boundaries.",
    "answer": "cpg.call.where(_.callee.file.name.startsWith(\"../\")).argument.reachableByFlows(cpg.method.parameter).locations.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve shared global variables used in multiple repositories.",
    "answer": "cpg.member.where(_.file.name.distinct.size > 1).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate functions referencing types from other repositories.",
    "answer": "cpg.method.where(_.typeRef.file.name != _.file.name).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display external API functions wrapped in local code.",
    "answer": "cpg.method.where(_.call.name.startsWith(\"external_\")).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get files that import modules from other repositories.",
    "answer": "cpg.file.where(_.importedModules.nonEmpty && _.importedModules.file.name != _.file.name).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List cross-repository calls introduced by recent changes.",
    "answer": "cpg.call.where(_.tagList.contains(\"recent-change\") && _.callee.file.name != _.file.name).code.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show cross-repository functions called by multiple repositories.",
    "answer": "cpg.method.where(_.caller.file.name.distinct.size > 1).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find types defined in one repository and extended in others.",
    "answer": "cpg.typeDecl.where(_.inheritsFromType.nonEmpty && _.inheritsFromType.file.name != _.file.name).map(t => (t.name, t.inheritsFromType.name)).l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify functions changed in one repository breaking dependencies in others.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\") && _.caller.file.name.contains(\"otherRepo\")).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve data flows across repository boundaries.",
    "answer": "cpg.call.where(_.callee.file.name.startsWith(\"../\")).argument.reachableByFlows(cpg.method.parameter).locations.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate shared global variables used in multiple repositories.",
    "answer": "cpg.member.where(_.file.name.distinct.size > 1).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display functions referencing types from other repositories.",
    "answer": "cpg.method.where(_.typeRef.file.name != _.file.name).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get external API functions wrapped in local code.",
    "answer": "cpg.method.where(_.call.name.startsWith(\"external_\")).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List files that import modules from other repositories.",
    "answer": "cpg.file.where(_.importedModules.nonEmpty && _.importedModules.file.name != _.file.name).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show cross-repository calls introduced by recent changes.",
    "answer": "cpg.call.where(_.tagList.contains(\"recent-change\") && _.callee.file.name != _.file.name).code.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find cross-repository functions called by multiple repositories.",
    "answer": "cpg.method.where(_.caller.file.name.distinct.size > 1).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify types defined in one repository and extended in others.",
    "answer": "cpg.typeDecl.where(_.inheritsFromType.nonEmpty && _.inheritsFromType.file.name != _.file.name).map(t => (t.name, t.inheritsFromType.name)).l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve functions changed in one repository breaking dependencies in others.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\") && _.caller.file.name.contains(\"otherRepo\")).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate data flows across repository boundaries.",
    "answer": "cpg.call.where(_.callee.file.name.startsWith(\"../\")).argument.reachableByFlows(cpg.method.parameter).locations.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display shared global variables used in multiple repositories.",
    "answer": "cpg.member.where(_.file.name.distinct.size > 1).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get functions referencing types from other repositories.",
    "answer": "cpg.method.where(_.typeRef.file.name != _.file.name).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List external API functions wrapped in local code.",
    "answer": "cpg.method.where(_.call.name.startsWith(\"external_\")).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show files that import modules from other repositories.",
    "answer": "cpg.file.where(_.importedModules.nonEmpty && _.importedModules.file.name != _.file.name).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find cross-repository calls introduced by recent changes.",
    "answer": "cpg.call.where(_.tagList.contains(\"recent-change\") && _.callee.file.name != _.file.name).code.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify cross-repository functions called by multiple repositories.",
    "answer": "cpg.method.where(_.caller.file.name.distinct.size > 1).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve types defined in one repository and extended in others.",
    "answer": "cpg.typeDecl.where(_.inheritsFromType.nonEmpty && _.inheritsFromType.file.name != _.file.name).map(t => (t.name, t.inheritsFromType.name)).l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate functions changed in one repository breaking dependencies in others.",
    "answer": "cpg.method.where(_.tagList.contains(\"recent-change\") && _.caller.file.name.contains(\"otherRepo\")).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display data flows across repository boundaries.",
    "answer": "cpg.call.where(_.callee.file.name.startsWith(\"../\")).argument.reachableByFlows(cpg.method.parameter).locations.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get shared global variables used in multiple repositories.",
    "answer": "cpg.member.where(_.file.name.distinct.size > 1).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions referencing types from other repositories.",
    "answer": "cpg.method.where(_.typeRef.file.name != _.file.name).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show external API functions wrapped in local code.",
    "answer": "cpg.method.where(_.call.name.startsWith(\"external_\")).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find files that import modules from other repositories.",
    "answer": "cpg.file.where(_.importedModules.nonEmpty && _.importedModules.file.name != _.file.name).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List the dependency graph between repositories.",
    "answer": "cpg.method.map(m => (m.file.name, m.callee.file.name)).l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show sensitive data flows across repositories.",
    "answer": "cpg.call.where(_.callee.file.name != _.file.name).argument.reachableBy(cpg.identifier.name(\"password|token\")).l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find circular dependencies between repositories.",
    "answer": "cpg.method.where(_.file.name != _.callee.file.name && _.callee.file.name != _.method.file.name).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify cross-repository API usages introduced recently.",
    "answer": "cpg.call.where(_.tagList.contains(\"recent-change\") && _.callee.file.name != _.file.name).code.l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve functions impacted by changes in shared types.",
    "answer": "cpg.typeDecl.where(_.tagList.contains(\"recent-change\")).referencingMembers.method.name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate the dependency graph between repositories.",
    "answer": "cpg.method.map(m => (m.file.name, m.callee.file.name)).l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display sensitive data flows across repositories.",
    "answer": "cpg.call.where(_.callee.file.name != _.file.name).argument.reachableBy(cpg.identifier.name(\"password|token\")).l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get circular dependencies between repositories.",
    "answer": "cpg.method.where(_.file.name != _.callee.file.name && _.callee.file.name != _.method.file.name).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List cross-repository API usages introduced recently.",
    "answer": "cpg.call.where(_.tagList.contains(\"recent-change\") && _.callee.file.name != _.file.name).code.l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show functions impacted by changes in shared types.",
    "answer": "cpg.typeDecl.where(_.tagList.contains(\"recent-change\")).referencingMembers.method.name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find the dependency graph between repositories.",
    "answer": "cpg.method.map(m => (m.file.name, m.callee.file.name)).l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify sensitive data flows across repositories.",
    "answer": "cpg.call.where(_.callee.file.name != _.file.name).argument.reachableBy(cpg.identifier.name(\"password|token\")).l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve circular dependencies between repositories.",
    "answer": "cpg.method.where(_.file.name != _.callee.file.name && _.callee.file.name != _.method.file.name).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate cross-repository API usages introduced recently.",
    "answer": "cpg.call.where(_.tagList.contains(\"recent-change\") && _.callee.file.name != _.file.name).code.l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display functions impacted by changes in shared types.",
    "answer": "cpg.typeDecl.where(_.tagList.contains(\"recent-change\")).referencingMembers.method.name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get the dependency graph between repositories.",
    "answer": "cpg.method.map(m => (m.file.name, m.callee.file.name)).l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List sensitive data flows across repositories.",
    "answer": "cpg.call.where(_.callee.file.name != _.file.name).argument.reachableBy(cpg.identifier.name(\"password|token\")).l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show circular dependencies between repositories.",
    "answer": "cpg.method.where(_.file.name != _.callee.file.name && _.callee.file.name != _.method.file.name).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find cross-repository API usages introduced recently.",
    "answer": "cpg.call.where(_.tagList.contains(\"recent-change\") && _.callee.file.name != _.file.name).code.l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify functions impacted by changes in shared types.",
    "answer": "cpg.typeDecl.where(_.tagList.contains(\"recent-change\")).referencingMembers.method.name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve the dependency graph between repositories.",
    "answer": "cpg.method.map(m => (m.file.name, m.callee.file.name)).l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate sensitive data flows across repositories.",
    "answer": "cpg.call.where(_.callee.file.name != _.file.name).argument.reachableBy(cpg.identifier.name(\"password|token\")).l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display circular dependencies between repositories.",
    "answer": "cpg.method.where(_.file.name != _.callee.file.name && _.callee.file.name != _.method.file.name).name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get cross-repository API usages introduced recently.",
    "answer": "cpg.call.where(_.tagList.contains(\"recent-change\") && _.callee.file.name != _.file.name).code.l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List functions impacted by changes in shared types.",
    "answer": "cpg.typeDecl.where(_.tagList.contains(\"recent-change\")).referencingMembers.method.name.l",
    "scenario": 10,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List all namespaces in the project.",
    "answer": "cpg.namespace.name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show the number of functions in each namespace.",
    "answer": "cpg.namespace.map(n => (n.name, n.method.size)).l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find all type declarations with their kind.",
    "answer": "cpg.typeDecl.map(t => (t.name, t.kind)).l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify dependencies between namespaces.",
    "answer": "cpg.namespaceBlock.call.callee.namespaceBlock.name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve include directives per file.",
    "answer": "cpg.file.preprocessorDirective.code.l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate all namespace blocks.",
    "answer": "cpg.namespaceBlock.name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display the count of methods per namespace.",
    "answer": "cpg.namespace.map(n => (n.name, n.method.size)).l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get types and the number of methods in them.",
    "answer": "cpg.typeDecl.map(t => (t.name, t.method.size)).l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List files belonging to each namespace.",
    "answer": "cpg.namespaceBlock.file.name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show functions defined outside any namespace.",
    "answer": "cpg.method.where(_.namespace.isEmpty).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find all namespaces in the project.",
    "answer": "cpg.namespace.name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify the number of functions in each namespace.",
    "answer": "cpg.namespace.map(n => (n.name, n.method.size)).l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve all type declarations with their kind.",
    "answer": "cpg.typeDecl.map(t => (t.name, t.kind)).l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate dependencies between namespaces.",
    "answer": "cpg.namespaceBlock.call.callee.namespaceBlock.name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display include directives per file.",
    "answer": "cpg.file.preprocessorDirective.code.l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get all namespace blocks.",
    "answer": "cpg.namespaceBlock.name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List the count of methods per namespace.",
    "answer": "cpg.namespace.map(n => (n.name, n.method.size)).l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show types and the number of methods in them.",
    "answer": "cpg.typeDecl.map(t => (t.name, t.method.size)).l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find files belonging to each namespace.",
    "answer": "cpg.namespaceBlock.file.name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify functions defined outside any namespace.",
    "answer": "cpg.method.where(_.namespace.isEmpty).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve all namespaces in the project.",
    "answer": "cpg.namespace.name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate the number of functions in each namespace.",
    "answer": "cpg.namespace.map(n => (n.name, n.method.size)).l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display all type declarations with their kind.",
    "answer": "cpg.typeDecl.map(t => (t.name, t.kind)).l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get dependencies between namespaces.",
    "answer": "cpg.namespaceBlock.call.callee.namespaceBlock.name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List include directives per file.",
    "answer": "cpg.file.preprocessorDirective.code.l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show all namespace blocks.",
    "answer": "cpg.namespaceBlock.name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find the count of methods per namespace.",
    "answer": "cpg.namespace.map(n => (n.name, n.method.size)).l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify types and the number of methods in them.",
    "answer": "cpg.typeDecl.map(t => (t.name, t.method.size)).l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve files belonging to each namespace.",
    "answer": "cpg.namespaceBlock.file.name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate functions defined outside any namespace.",
    "answer": "cpg.method.where(_.namespace.isEmpty).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display all namespaces in the project.",
    "answer": "cpg.namespace.name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get the number of functions in each namespace.",
    "answer": "cpg.namespace.map(n => (n.name, n.method.size)).l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List all type declarations with their kind.",
    "answer": "cpg.typeDecl.map(t => (t.name, t.kind)).l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show dependencies between namespaces.",
    "answer": "cpg.namespaceBlock.call.callee.namespaceBlock.name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find include directives per file.",
    "answer": "cpg.file.preprocessorDirective.code.l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify all namespace blocks.",
    "answer": "cpg.namespaceBlock.name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve the count of methods per namespace.",
    "answer": "cpg.namespace.map(n => (n.name, n.method.size)).l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate types and the number of methods in them.",
    "answer": "cpg.typeDecl.map(t => (t.name, t.method.size)).l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display files belonging to each namespace.",
    "answer": "cpg.namespaceBlock.file.name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get functions defined outside any namespace.",
    "answer": "cpg.method.where(_.namespace.isEmpty).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List modules with circular dependencies.",
    "answer": "cpg.namespaceBlock.where(_.call.callee.namespaceBlock == _.namespaceBlock).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show layers violating dependency direction.",
    "answer": "cpg.call.where(_.callee.namespace.name.startsWith(\"UI\") && _.method.namespace.name.startsWith(\"Core\")).code.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find namespaces with high fan-in and fan-out.",
    "answer": "cpg.namespace.map(n => (n.name, n.method.caller.size, n.method.callee.size)).l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify type declarations unused by other modules.",
    "answer": "cpg.typeDecl.where(_.method.referencingMembers.isEmpty).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve functions crossing namespace boundaries.",
    "answer": "cpg.method.where(_.callee.namespace != _.namespace).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate files referencing types in other namespaces.",
    "answer": "cpg.file.where(_.typeRef.namespace != _.namespace).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display namespaces with few types but many functions.",
    "answer": "cpg.namespace.where(_.typeDecl.size < 2 && _.method.size > 10).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get cross-layer calls from UI to DAO.",
    "answer": "cpg.call.where(_.method.namespace.name.matches(\".*UI.*\") && _.callee.namespace.name.matches(\".*DAO.*\")).code.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List layers that depend on unstable APIs.",
    "answer": "cpg.call.where(_.callee.tagList.contains(\"unstable-api\")).method.namespace.name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show modules with circular dependencies.",
    "answer": "cpg.namespaceBlock.where(_.call.callee.namespaceBlock == _.namespaceBlock).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find layers violating dependency direction.",
    "answer": "cpg.call.where(_.callee.namespace.name.startsWith(\"UI\") && _.method.namespace.name.startsWith(\"Core\")).code.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify namespaces with high fan-in and fan-out.",
    "answer": "cpg.namespace.map(n => (n.name, n.method.caller.size, n.method.callee.size)).l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve type declarations unused by other modules.",
    "answer": "cpg.typeDecl.where(_.method.referencingMembers.isEmpty).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate functions crossing namespace boundaries.",
    "answer": "cpg.method.where(_.callee.namespace != _.namespace).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display files referencing types in other namespaces.",
    "answer": "cpg.file.where(_.typeRef.namespace != _.namespace).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get namespaces with few types but many functions.",
    "answer": "cpg.namespace.where(_.typeDecl.size < 2 && _.method.size > 10).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List cross-layer calls from UI to DAO.",
    "answer": "cpg.call.where(_.method.namespace.name.matches(\".*UI.*\") && _.callee.namespace.name.matches(\".*DAO.*\")).code.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show layers that depend on unstable APIs.",
    "answer": "cpg.call.where(_.callee.tagList.contains(\"unstable-api\")).method.namespace.name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find modules with circular dependencies.",
    "answer": "cpg.namespaceBlock.where(_.call.callee.namespaceBlock == _.namespaceBlock).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify layers violating dependency direction.",
    "answer": "cpg.call.where(_.callee.namespace.name.startsWith(\"UI\") && _.method.namespace.name.startsWith(\"Core\")).code.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve namespaces with high fan-in and fan-out.",
    "answer": "cpg.namespace.map(n => (n.name, n.method.caller.size, n.method.callee.size)).l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate type declarations unused by other modules.",
    "answer": "cpg.typeDecl.where(_.method.referencingMembers.isEmpty).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display functions crossing namespace boundaries.",
    "answer": "cpg.method.where(_.callee.namespace != _.namespace).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get files referencing types in other namespaces.",
    "answer": "cpg.file.where(_.typeRef.namespace != _.namespace).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List namespaces with few types but many functions.",
    "answer": "cpg.namespace.where(_.typeDecl.size < 2 && _.method.size > 10).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show cross-layer calls from UI to DAO.",
    "answer": "cpg.call.where(_.method.namespace.name.matches(\".*UI.*\") && _.callee.namespace.name.matches(\".*DAO.*\")).code.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find layers that depend on unstable APIs.",
    "answer": "cpg.call.where(_.callee.tagList.contains(\"unstable-api\")).method.namespace.name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify modules with circular dependencies.",
    "answer": "cpg.namespaceBlock.where(_.call.callee.namespaceBlock == _.namespaceBlock).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve layers violating dependency direction.",
    "answer": "cpg.call.where(_.callee.namespace.name.startsWith(\"UI\") && _.method.namespace.name.startsWith(\"Core\")).code.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate namespaces with high fan-in and fan-out.",
    "answer": "cpg.namespace.map(n => (n.name, n.method.caller.size, n.method.callee.size)).l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display type declarations unused by other modules.",
    "answer": "cpg.typeDecl.where(_.method.referencingMembers.isEmpty).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get functions crossing namespace boundaries.",
    "answer": "cpg.method.where(_.callee.namespace != _.namespace).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List files referencing types in other namespaces.",
    "answer": "cpg.file.where(_.typeRef.namespace != _.namespace).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show namespaces with few types but many functions.",
    "answer": "cpg.namespace.where(_.typeDecl.size < 2 && _.method.size > 10).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find cross-layer calls from UI to DAO.",
    "answer": "cpg.call.where(_.method.namespace.name.matches(\".*UI.*\") && _.callee.namespace.name.matches(\".*DAO.*\")).code.l",
    "scenario": 11,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List direct calls skipping architecture layers.",
    "answer": "cpg.call.where(_.method.namespace.name.matches(\".*UI.*\") && _.callee.namespace.name.matches(\".*DAO.*\")).code.l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show cyclic dependencies indicating architectural decay.",
    "answer": "cpg.namespaceBlock.where(_.call.callee.namespaceBlock == _.namespaceBlock).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find functions that bypass services and access data access layer directly.",
    "answer": "cpg.call.where(_.callee.namespace.name.matches(\".*DAO.*\") && _.method.namespace.name.matches(\".*Controller.*\")).code.l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify data flows crossing multiple architectural layers.",
    "answer": "cpg.call.where(_.callee.namespace.name.matches(\".*DAO.*\")).argument.reachableBy(cpg.identifier.name(\"request|data\")).l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve modules depending on unstable APIs.",
    "answer": "cpg.call.where(_.callee.tagList.contains(\"unstable-api\")).method.namespace.name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate direct calls skipping architecture layers.",
    "answer": "cpg.call.where(_.method.namespace.name.matches(\".*UI.*\") && _.callee.namespace.name.matches(\".*DAO.*\")).code.l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display cyclic dependencies indicating architectural decay.",
    "answer": "cpg.namespaceBlock.where(_.call.callee.namespaceBlock == _.namespaceBlock).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get functions that bypass services and access data access layer directly.",
    "answer": "cpg.call.where(_.callee.namespace.name.matches(\".*DAO.*\") && _.method.namespace.name.matches(\".*Controller.*\")).code.l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List data flows crossing multiple architectural layers.",
    "answer": "cpg.call.where(_.callee.namespace.name.matches(\".*DAO.*\")).argument.reachableBy(cpg.identifier.name(\"request|data\")).l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show modules depending on unstable APIs.",
    "answer": "cpg.call.where(_.callee.tagList.contains(\"unstable-api\")).method.namespace.name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find direct calls skipping architecture layers.",
    "answer": "cpg.call.where(_.method.namespace.name.matches(\".*UI.*\") && _.callee.namespace.name.matches(\".*DAO.*\")).code.l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify cyclic dependencies indicating architectural decay.",
    "answer": "cpg.namespaceBlock.where(_.call.callee.namespaceBlock == _.namespaceBlock).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve functions that bypass services and access data access layer directly.",
    "answer": "cpg.call.where(_.callee.namespace.name.matches(\".*DAO.*\") && _.method.namespace.name.matches(\".*Controller.*\")).code.l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate data flows crossing multiple architectural layers.",
    "answer": "cpg.call.where(_.callee.namespace.name.matches(\".*DAO.*\")).argument.reachableBy(cpg.identifier.name(\"request|data\")).l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display modules depending on unstable APIs.",
    "answer": "cpg.call.where(_.callee.tagList.contains(\"unstable-api\")).method.namespace.name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get direct calls skipping architecture layers.",
    "answer": "cpg.call.where(_.method.namespace.name.matches(\".*UI.*\") && _.callee.namespace.name.matches(\".*DAO.*\")).code.l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List cyclic dependencies indicating architectural decay.",
    "answer": "cpg.namespaceBlock.where(_.call.callee.namespaceBlock == _.namespaceBlock).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show functions that bypass services and access data access layer directly.",
    "answer": "cpg.call.where(_.callee.namespace.name.matches(\".*DAO.*\") && _.method.namespace.name.matches(\".*Controller.*\")).code.l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find data flows crossing multiple architectural layers.",
    "answer": "cpg.call.where(_.callee.namespace.name.matches(\".*DAO.*\")).argument.reachableBy(cpg.identifier.name(\"request|data\")).l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify modules depending on unstable APIs.",
    "answer": "cpg.call.where(_.callee.tagList.contains(\"unstable-api\")).method.namespace.name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve direct calls skipping architecture layers.",
    "answer": "cpg.call.where(_.method.namespace.name.matches(\".*UI.*\") && _.callee.namespace.name.matches(\".*DAO.*\")).code.l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate cyclic dependencies indicating architectural decay.",
    "answer": "cpg.namespaceBlock.where(_.call.callee.namespaceBlock == _.namespaceBlock).name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display functions that bypass services and access data access layer directly.",
    "answer": "cpg.call.where(_.callee.namespace.name.matches(\".*DAO.*\") && _.method.namespace.name.matches(\".*Controller.*\")).code.l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get data flows crossing multiple architectural layers.",
    "answer": "cpg.call.where(_.callee.namespace.name.matches(\".*DAO.*\")).argument.reachableBy(cpg.identifier.name(\"request|data\")).l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List modules depending on unstable APIs.",
    "answer": "cpg.call.where(_.callee.tagList.contains(\"unstable-api\")).method.namespace.name.l",
    "scenario": 11,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List functions with TODO or FIXME comments.",
    "answer": "cpg.comment.code(\".*TODO|FIXME.*\").method.name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show methods with long parameter lists.",
    "answer": "cpg.method.where(_.parameter.size > 5).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find files and their number of comments.",
    "answer": "cpg.file.map(f => (f.name, f.comment.size)).l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify nested control structures per method.",
    "answer": "cpg.method.map(m => (m.name, m.controlStructure.size)).l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve functions with complex expressions.",
    "answer": "cpg.call.name(\"<operator>.*\").method.name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate functions with many locals.",
    "answer": "cpg.method.where(_.local.size > 10).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display methods with no comments.",
    "answer": "cpg.method.where(_.comment.isEmpty).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get small functions (less than ten lines).",
    "answer": "cpg.method.where(_.lineNumberEnd - _.lineNumberStart < 10).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List files with large numbers of lines.",
    "answer": "cpg.file.where(_.lineNumberEnd - _.lineNumberStart > 500).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show functions containing magic numbers.",
    "answer": "cpg.literal.code(\"\\d+\").method.name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find functions with TODO or FIXME comments.",
    "answer": "cpg.comment.code(\".*TODO|FIXME.*\").method.name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify methods with long parameter lists.",
    "answer": "cpg.method.where(_.parameter.size > 5).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve files and their number of comments.",
    "answer": "cpg.file.map(f => (f.name, f.comment.size)).l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate nested control structures per method.",
    "answer": "cpg.method.map(m => (m.name, m.controlStructure.size)).l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display functions with complex expressions.",
    "answer": "cpg.call.name(\"<operator>.*\").method.name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get functions with many locals.",
    "answer": "cpg.method.where(_.local.size > 10).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List methods with no comments.",
    "answer": "cpg.method.where(_.comment.isEmpty).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show small functions (less than ten lines).",
    "answer": "cpg.method.where(_.lineNumberEnd - _.lineNumberStart < 10).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find files with large numbers of lines.",
    "answer": "cpg.file.where(_.lineNumberEnd - _.lineNumberStart > 500).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify functions containing magic numbers.",
    "answer": "cpg.literal.code(\"\\d+\").method.name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve functions with TODO or FIXME comments.",
    "answer": "cpg.comment.code(\".*TODO|FIXME.*\").method.name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate methods with long parameter lists.",
    "answer": "cpg.method.where(_.parameter.size > 5).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display files and their number of comments.",
    "answer": "cpg.file.map(f => (f.name, f.comment.size)).l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get nested control structures per method.",
    "answer": "cpg.method.map(m => (m.name, m.controlStructure.size)).l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List functions with complex expressions.",
    "answer": "cpg.call.name(\"<operator>.*\").method.name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show functions with many locals.",
    "answer": "cpg.method.where(_.local.size > 10).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find methods with no comments.",
    "answer": "cpg.method.where(_.comment.isEmpty).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify small functions (less than ten lines).",
    "answer": "cpg.method.where(_.lineNumberEnd - _.lineNumberStart < 10).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve files with large numbers of lines.",
    "answer": "cpg.file.where(_.lineNumberEnd - _.lineNumberStart > 500).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate functions containing magic numbers.",
    "answer": "cpg.literal.code(\"\\d+\").method.name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display functions with TODO or FIXME comments.",
    "answer": "cpg.comment.code(\".*TODO|FIXME.*\").method.name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get methods with long parameter lists.",
    "answer": "cpg.method.where(_.parameter.size > 5).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List files and their number of comments.",
    "answer": "cpg.file.map(f => (f.name, f.comment.size)).l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show nested control structures per method.",
    "answer": "cpg.method.map(m => (m.name, m.controlStructure.size)).l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find functions with complex expressions.",
    "answer": "cpg.call.name(\"<operator>.*\").method.name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify functions with many locals.",
    "answer": "cpg.method.where(_.local.size > 10).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve methods with no comments.",
    "answer": "cpg.method.where(_.comment.isEmpty).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate small functions (less than ten lines).",
    "answer": "cpg.method.where(_.lineNumberEnd - _.lineNumberStart < 10).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display files with large numbers of lines.",
    "answer": "cpg.file.where(_.lineNumberEnd - _.lineNumberStart > 500).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get functions containing magic numbers.",
    "answer": "cpg.literal.code(\"\\d+\").method.name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List modules with high average cyclomatic complexity.",
    "answer": "cpg.namespace.map(ns => (ns.name, ns.method.cyclomaticComplexity.avg)).l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show functions with deep call chains.",
    "answer": "cpg.method.where(_.callee.callee.callee.nonEmpty).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find number of exception handling statements per method.",
    "answer": "cpg.method.map(m => (m.name, m.controlStructure.where(_.code.contains(\"try\")).size)).l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify functions with high fan-out.",
    "answer": "cpg.method.where(_.callee.size > 10).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve methods with many local variables.",
    "answer": "cpg.method.where(_.local.size > 10).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate functions with high fan-in.",
    "answer": "cpg.method.where(_.caller.size > 10).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display functions with a large number of literals.",
    "answer": "cpg.method.where(_.literal.size > 10).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get modules with increasing debt (changes without tests).",
    "answer": "cpg.file.where(_.tagList.contains(\"recent-change\") && _.method.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions with nested ternary operators.",
    "answer": "cpg.call.name(\"<operator>.conditional\").method.name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show modules with high average cyclomatic complexity.",
    "answer": "cpg.namespace.map(ns => (ns.name, ns.method.cyclomaticComplexity.avg)).l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find functions with deep call chains.",
    "answer": "cpg.method.where(_.callee.callee.callee.nonEmpty).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify number of exception handling statements per method.",
    "answer": "cpg.method.map(m => (m.name, m.controlStructure.where(_.code.contains(\"try\")).size)).l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve functions with high fan-out.",
    "answer": "cpg.method.where(_.callee.size > 10).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate methods with many local variables.",
    "answer": "cpg.method.where(_.local.size > 10).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display functions with high fan-in.",
    "answer": "cpg.method.where(_.caller.size > 10).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get functions with a large number of literals.",
    "answer": "cpg.method.where(_.literal.size > 10).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List modules with increasing debt (changes without tests).",
    "answer": "cpg.file.where(_.tagList.contains(\"recent-change\") && _.method.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show functions with nested ternary operators.",
    "answer": "cpg.call.name(\"<operator>.conditional\").method.name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find modules with high average cyclomatic complexity.",
    "answer": "cpg.namespace.map(ns => (ns.name, ns.method.cyclomaticComplexity.avg)).l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify functions with deep call chains.",
    "answer": "cpg.method.where(_.callee.callee.callee.nonEmpty).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve number of exception handling statements per method.",
    "answer": "cpg.method.map(m => (m.name, m.controlStructure.where(_.code.contains(\"try\")).size)).l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate functions with high fan-out.",
    "answer": "cpg.method.where(_.callee.size > 10).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display methods with many local variables.",
    "answer": "cpg.method.where(_.local.size > 10).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get functions with high fan-in.",
    "answer": "cpg.method.where(_.caller.size > 10).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions with a large number of literals.",
    "answer": "cpg.method.where(_.literal.size > 10).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show modules with increasing debt (changes without tests).",
    "answer": "cpg.file.where(_.tagList.contains(\"recent-change\") && _.method.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find functions with nested ternary operators.",
    "answer": "cpg.call.name(\"<operator>.conditional\").method.name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify modules with high average cyclomatic complexity.",
    "answer": "cpg.namespace.map(ns => (ns.name, ns.method.cyclomaticComplexity.avg)).l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve functions with deep call chains.",
    "answer": "cpg.method.where(_.callee.callee.callee.nonEmpty).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate number of exception handling statements per method.",
    "answer": "cpg.method.map(m => (m.name, m.controlStructure.where(_.code.contains(\"try\")).size)).l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display functions with high fan-out.",
    "answer": "cpg.method.where(_.callee.size > 10).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get methods with many local variables.",
    "answer": "cpg.method.where(_.local.size > 10).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions with high fan-in.",
    "answer": "cpg.method.where(_.caller.size > 10).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show functions with a large number of literals.",
    "answer": "cpg.method.where(_.literal.size > 10).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find modules with increasing debt (changes without tests).",
    "answer": "cpg.file.where(_.tagList.contains(\"recent-change\") && _.method.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List technical debt index based on complexity and size.",
    "answer": "cpg.method.map(m => (m.name, m.cyclomaticComplexity + m.local.size)).l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show functions with high coupling and low cohesion.",
    "answer": "cpg.method.where(_.callee.size > 10 && _.local.size < 2).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find modules accruing debt due to changes without tests.",
    "answer": "cpg.file.where(_.tagList.contains(\"recent-change\") && _.method.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify duplicated logic across methods.",
    "answer": "cpg.method.where(_.isDuplicateOf.nonEmpty).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve distribution of code complexity across the project.",
    "answer": "cpg.method.map(_.cyclomaticComplexity).l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate technical debt index based on complexity and size.",
    "answer": "cpg.method.map(m => (m.name, m.cyclomaticComplexity + m.local.size)).l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display functions with high coupling and low cohesion.",
    "answer": "cpg.method.where(_.callee.size > 10 && _.local.size < 2).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get modules accruing debt due to changes without tests.",
    "answer": "cpg.file.where(_.tagList.contains(\"recent-change\") && _.method.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List duplicated logic across methods.",
    "answer": "cpg.method.where(_.isDuplicateOf.nonEmpty).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show distribution of code complexity across the project.",
    "answer": "cpg.method.map(_.cyclomaticComplexity).l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find technical debt index based on complexity and size.",
    "answer": "cpg.method.map(m => (m.name, m.cyclomaticComplexity + m.local.size)).l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify functions with high coupling and low cohesion.",
    "answer": "cpg.method.where(_.callee.size > 10 && _.local.size < 2).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve modules accruing debt due to changes without tests.",
    "answer": "cpg.file.where(_.tagList.contains(\"recent-change\") && _.method.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate duplicated logic across methods.",
    "answer": "cpg.method.where(_.isDuplicateOf.nonEmpty).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display distribution of code complexity across the project.",
    "answer": "cpg.method.map(_.cyclomaticComplexity).l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get technical debt index based on complexity and size.",
    "answer": "cpg.method.map(m => (m.name, m.cyclomaticComplexity + m.local.size)).l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List functions with high coupling and low cohesion.",
    "answer": "cpg.method.where(_.callee.size > 10 && _.local.size < 2).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show modules accruing debt due to changes without tests.",
    "answer": "cpg.file.where(_.tagList.contains(\"recent-change\") && _.method.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find duplicated logic across methods.",
    "answer": "cpg.method.where(_.isDuplicateOf.nonEmpty).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify distribution of code complexity across the project.",
    "answer": "cpg.method.map(_.cyclomaticComplexity).l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve technical debt index based on complexity and size.",
    "answer": "cpg.method.map(m => (m.name, m.cyclomaticComplexity + m.local.size)).l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate functions with high coupling and low cohesion.",
    "answer": "cpg.method.where(_.callee.size > 10 && _.local.size < 2).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display modules accruing debt due to changes without tests.",
    "answer": "cpg.file.where(_.tagList.contains(\"recent-change\") && _.method.caller.file.name(\".*test.*\").isEmpty).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get duplicated logic across methods.",
    "answer": "cpg.method.where(_.isDuplicateOf.nonEmpty).name.l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List distribution of code complexity across the project.",
    "answer": "cpg.method.map(_.cyclomaticComplexity).l",
    "scenario": 12,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List calls matching 'oldFunction'.",
    "answer": "cpg.call.name(\"oldFunction\").code.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show locations to replace deprecated API 'oldFunc'.",
    "answer": "cpg.call.name(\"oldFunc\").location.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find instantiations of a specific struct.",
    "answer": "cpg.call.name(\"<operator>.assignment\").where(_.argument.code.contains(\"structType\")).code.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify usages of a macro.",
    "answer": "cpg.call.name(\"MACRO_NAME\").code.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve casts to a specific type.",
    "answer": "cpg.call.name(\"<operator>.cast\").where(_.argument.typeFullName(\"myType\")).code.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate calls to deprecated functions.",
    "answer": "cpg.call.where(_.callee.isDeprecated).code.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display functions that can be simplified.",
    "answer": "cpg.method.where(_.call.size < 2).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get occurrences of repetitive code patterns.",
    "answer": "cpg.method.where(_.isDuplicateOf.nonEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List functions that return void but could return a value.",
    "answer": "cpg.method.where(_.methodReturn.typeFullName == \"void\").name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show uses of the 'goto' statement.",
    "answer": "cpg.controlStructure.code(\"goto .*\").l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find calls matching 'oldFunction'.",
    "answer": "cpg.call.name(\"oldFunction\").code.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify locations to replace deprecated API 'oldFunc'.",
    "answer": "cpg.call.name(\"oldFunc\").location.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve instantiations of a specific struct.",
    "answer": "cpg.call.name(\"<operator>.assignment\").where(_.argument.code.contains(\"structType\")).code.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate usages of a macro.",
    "answer": "cpg.call.name(\"MACRO_NAME\").code.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display casts to a specific type.",
    "answer": "cpg.call.name(\"<operator>.cast\").where(_.argument.typeFullName(\"myType\")).code.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get calls to deprecated functions.",
    "answer": "cpg.call.where(_.callee.isDeprecated).code.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List functions that can be simplified.",
    "answer": "cpg.method.where(_.call.size < 2).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show occurrences of repetitive code patterns.",
    "answer": "cpg.method.where(_.isDuplicateOf.nonEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find functions that return void but could return a value.",
    "answer": "cpg.method.where(_.methodReturn.typeFullName == \"void\").name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify uses of the 'goto' statement.",
    "answer": "cpg.controlStructure.code(\"goto .*\").l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve calls matching 'oldFunction'.",
    "answer": "cpg.call.name(\"oldFunction\").code.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate locations to replace deprecated API 'oldFunc'.",
    "answer": "cpg.call.name(\"oldFunc\").location.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display instantiations of a specific struct.",
    "answer": "cpg.call.name(\"<operator>.assignment\").where(_.argument.code.contains(\"structType\")).code.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get usages of a macro.",
    "answer": "cpg.call.name(\"MACRO_NAME\").code.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List casts to a specific type.",
    "answer": "cpg.call.name(\"<operator>.cast\").where(_.argument.typeFullName(\"myType\")).code.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show calls to deprecated functions.",
    "answer": "cpg.call.where(_.callee.isDeprecated).code.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find functions that can be simplified.",
    "answer": "cpg.method.where(_.call.size < 2).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify occurrences of repetitive code patterns.",
    "answer": "cpg.method.where(_.isDuplicateOf.nonEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve functions that return void but could return a value.",
    "answer": "cpg.method.where(_.methodReturn.typeFullName == \"void\").name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate uses of the 'goto' statement.",
    "answer": "cpg.controlStructure.code(\"goto .*\").l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display calls matching 'oldFunction'.",
    "answer": "cpg.call.name(\"oldFunction\").code.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get locations to replace deprecated API 'oldFunc'.",
    "answer": "cpg.call.name(\"oldFunc\").location.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List instantiations of a specific struct.",
    "answer": "cpg.call.name(\"<operator>.assignment\").where(_.argument.code.contains(\"structType\")).code.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show usages of a macro.",
    "answer": "cpg.call.name(\"MACRO_NAME\").code.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find casts to a specific type.",
    "answer": "cpg.call.name(\"<operator>.cast\").where(_.argument.typeFullName(\"myType\")).code.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify calls to deprecated functions.",
    "answer": "cpg.call.where(_.callee.isDeprecated).code.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve functions that can be simplified.",
    "answer": "cpg.method.where(_.call.size < 2).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate occurrences of repetitive code patterns.",
    "answer": "cpg.method.where(_.isDuplicateOf.nonEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display functions that return void but could return a value.",
    "answer": "cpg.method.where(_.methodReturn.typeFullName == \"void\").name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get uses of the 'goto' statement.",
    "answer": "cpg.controlStructure.code(\"goto .*\").l",
    "scenario": 13,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List functions that always call another function suitable for inlining.",
    "answer": "cpg.method.where(_.callee.size == 1).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show places where a global variable could be passed as an argument.",
    "answer": "cpg.method.where(_.call.name(\"globalVar\").nonEmpty && _.parameter.name(\"globalVar\").isEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find loops that could be refactored into for-each loops.",
    "answer": "cpg.controlStructure.loopType.where(_.code.matches(\"for\\(.*;.*;.*\\)\")).code.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify functions that only read struct members.",
    "answer": "cpg.method.where(_.call.name(\"<operator>.fieldAccess\").size > 0 && _.call.name(\"<operator>.assignment\").isEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve switch statements with many cases.",
    "answer": "cpg.controlStructure.type(\"SWITCH\").where(_.case.size > 3).method.name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate functions that could be converted to templates.",
    "answer": "cpg.method.where(_.typeParameter.nonEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display functions that return error codes manually.",
    "answer": "cpg.method.where(_.call.name(\"return\").nonEmpty && _.call.name(\"throw\").isEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get functions that could be replaced by standard library functions.",
    "answer": "cpg.method.where(_.call.name(\"memcpy\").isEmpty && _.call.name(\"copy\").nonEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List methods that wrap a single API call.",
    "answer": "cpg.method.where(_.call.size == 1).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show functions that always call another function suitable for inlining.",
    "answer": "cpg.method.where(_.callee.size == 1).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find places where a global variable could be passed as an argument.",
    "answer": "cpg.method.where(_.call.name(\"globalVar\").nonEmpty && _.parameter.name(\"globalVar\").isEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify loops that could be refactored into for-each loops.",
    "answer": "cpg.controlStructure.loopType.where(_.code.matches(\"for\\(.*;.*;.*\\)\")).code.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve functions that only read struct members.",
    "answer": "cpg.method.where(_.call.name(\"<operator>.fieldAccess\").size > 0 && _.call.name(\"<operator>.assignment\").isEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate switch statements with many cases.",
    "answer": "cpg.controlStructure.type(\"SWITCH\").where(_.case.size > 3).method.name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display functions that could be converted to templates.",
    "answer": "cpg.method.where(_.typeParameter.nonEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get functions that return error codes manually.",
    "answer": "cpg.method.where(_.call.name(\"return\").nonEmpty && _.call.name(\"throw\").isEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions that could be replaced by standard library functions.",
    "answer": "cpg.method.where(_.call.name(\"memcpy\").isEmpty && _.call.name(\"copy\").nonEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show methods that wrap a single API call.",
    "answer": "cpg.method.where(_.call.size == 1).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find functions that always call another function suitable for inlining.",
    "answer": "cpg.method.where(_.callee.size == 1).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify places where a global variable could be passed as an argument.",
    "answer": "cpg.method.where(_.call.name(\"globalVar\").nonEmpty && _.parameter.name(\"globalVar\").isEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve loops that could be refactored into for-each loops.",
    "answer": "cpg.controlStructure.loopType.where(_.code.matches(\"for\\(.*;.*;.*\\)\")).code.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate functions that only read struct members.",
    "answer": "cpg.method.where(_.call.name(\"<operator>.fieldAccess\").size > 0 && _.call.name(\"<operator>.assignment\").isEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display switch statements with many cases.",
    "answer": "cpg.controlStructure.type(\"SWITCH\").where(_.case.size > 3).method.name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get functions that could be converted to templates.",
    "answer": "cpg.method.where(_.typeParameter.nonEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions that return error codes manually.",
    "answer": "cpg.method.where(_.call.name(\"return\").nonEmpty && _.call.name(\"throw\").isEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show functions that could be replaced by standard library functions.",
    "answer": "cpg.method.where(_.call.name(\"memcpy\").isEmpty && _.call.name(\"copy\").nonEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find methods that wrap a single API call.",
    "answer": "cpg.method.where(_.call.size == 1).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify functions that always call another function suitable for inlining.",
    "answer": "cpg.method.where(_.callee.size == 1).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve places where a global variable could be passed as an argument.",
    "answer": "cpg.method.where(_.call.name(\"globalVar\").nonEmpty && _.parameter.name(\"globalVar\").isEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate loops that could be refactored into for-each loops.",
    "answer": "cpg.controlStructure.loopType.where(_.code.matches(\"for\\(.*;.*;.*\\)\")).code.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display functions that only read struct members.",
    "answer": "cpg.method.where(_.call.name(\"<operator>.fieldAccess\").size > 0 && _.call.name(\"<operator>.assignment\").isEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get switch statements with many cases.",
    "answer": "cpg.controlStructure.type(\"SWITCH\").where(_.case.size > 3).method.name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions that could be converted to templates.",
    "answer": "cpg.method.where(_.typeParameter.nonEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show functions that return error codes manually.",
    "answer": "cpg.method.where(_.call.name(\"return\").nonEmpty && _.call.name(\"throw\").isEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find functions that could be replaced by standard library functions.",
    "answer": "cpg.method.where(_.call.name(\"memcpy\").isEmpty && _.call.name(\"copy\").nonEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions implementing logging and business logic together.",
    "answer": "cpg.method.where(_.call.name(\"log\").size > 0 && _.call.name(\"business\").size > 0).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show functions similar enough to be merged.",
    "answer": "cpg.method.where(_.similarityScore > 0.8).map(m => (m.name, m.similarMethods.name)).l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find data flow patterns suitable for helper functions.",
    "answer": "cpg.call.where(_.argument.reachableBy(cpg.call.name(\"validate\")).nonEmpty).method.name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify repeated initialization code across functions.",
    "answer": "cpg.method.where(_.code.startsWith(\"init\") && _.caller.size > 1).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve functions handling errors similarly.",
    "answer": "cpg.method.where(_.call.name(\"perror|exit\").size > 0 && _.call.name(\"cleanup\").isEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate functions implementing logging and business logic together.",
    "answer": "cpg.method.where(_.call.name(\"log\").size > 0 && _.call.name(\"business\").size > 0).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display functions similar enough to be merged.",
    "answer": "cpg.method.where(_.similarityScore > 0.8).map(m => (m.name, m.similarMethods.name)).l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get data flow patterns suitable for helper functions.",
    "answer": "cpg.call.where(_.argument.reachableBy(cpg.call.name(\"validate\")).nonEmpty).method.name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List repeated initialization code across functions.",
    "answer": "cpg.method.where(_.code.startsWith(\"init\") && _.caller.size > 1).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show functions handling errors similarly.",
    "answer": "cpg.method.where(_.call.name(\"perror|exit\").size > 0 && _.call.name(\"cleanup\").isEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find functions implementing logging and business logic together.",
    "answer": "cpg.method.where(_.call.name(\"log\").size > 0 && _.call.name(\"business\").size > 0).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify functions similar enough to be merged.",
    "answer": "cpg.method.where(_.similarityScore > 0.8).map(m => (m.name, m.similarMethods.name)).l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve data flow patterns suitable for helper functions.",
    "answer": "cpg.call.where(_.argument.reachableBy(cpg.call.name(\"validate\")).nonEmpty).method.name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate repeated initialization code across functions.",
    "answer": "cpg.method.where(_.code.startsWith(\"init\") && _.caller.size > 1).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display functions handling errors similarly.",
    "answer": "cpg.method.where(_.call.name(\"perror|exit\").size > 0 && _.call.name(\"cleanup\").isEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get functions implementing logging and business logic together.",
    "answer": "cpg.method.where(_.call.name(\"log\").size > 0 && _.call.name(\"business\").size > 0).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List functions similar enough to be merged.",
    "answer": "cpg.method.where(_.similarityScore > 0.8).map(m => (m.name, m.similarMethods.name)).l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show data flow patterns suitable for helper functions.",
    "answer": "cpg.call.where(_.argument.reachableBy(cpg.call.name(\"validate\")).nonEmpty).method.name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find repeated initialization code across functions.",
    "answer": "cpg.method.where(_.code.startsWith(\"init\") && _.caller.size > 1).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify functions handling errors similarly.",
    "answer": "cpg.method.where(_.call.name(\"perror|exit\").size > 0 && _.call.name(\"cleanup\").isEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve functions implementing logging and business logic together.",
    "answer": "cpg.method.where(_.call.name(\"log\").size > 0 && _.call.name(\"business\").size > 0).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate functions similar enough to be merged.",
    "answer": "cpg.method.where(_.similarityScore > 0.8).map(m => (m.name, m.similarMethods.name)).l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display data flow patterns suitable for helper functions.",
    "answer": "cpg.call.where(_.argument.reachableBy(cpg.call.name(\"validate\")).nonEmpty).method.name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get repeated initialization code across functions.",
    "answer": "cpg.method.where(_.code.startsWith(\"init\") && _.caller.size > 1).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List functions handling errors similarly.",
    "answer": "cpg.method.where(_.call.name(\"perror|exit\").size > 0 && _.call.name(\"cleanup\").isEmpty).name.l",
    "scenario": 13,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List functions that write to log files.",
    "answer": "cpg.call.name(\"fprintf|log|syslog\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show system calls executed in the code.",
    "answer": "cpg.call.name(\"exec|system|fork\").code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find network calls to internal addresses.",
    "answer": "cpg.literal.code(\"192.168.|10.0.\").l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify functions handling user authentication.",
    "answer": "cpg.call.name(\"authenticate|login\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve functions reading environment variables.",
    "answer": "cpg.call.name(\"getenv\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate calls to 'chmod'.",
    "answer": "cpg.call.name(\"chmod\").code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display functions that open network sockets.",
    "answer": "cpg.call.name(\"socket\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get reads from /proc.",
    "answer": "cpg.call.name(\"open\").where(_.argument.code.contains(\"/proc\")).code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List functions that read user tokens.",
    "answer": "cpg.identifier.name(\"token\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show functions that handle login tokens.",
    "answer": "cpg.call.name(\"token\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find functions that write to log files.",
    "answer": "cpg.call.name(\"fprintf|log|syslog\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify system calls executed in the code.",
    "answer": "cpg.call.name(\"exec|system|fork\").code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve network calls to internal addresses.",
    "answer": "cpg.literal.code(\"192.168.|10.0.\").l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate functions handling user authentication.",
    "answer": "cpg.call.name(\"authenticate|login\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display functions reading environment variables.",
    "answer": "cpg.call.name(\"getenv\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get calls to 'chmod'.",
    "answer": "cpg.call.name(\"chmod\").code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List functions that open network sockets.",
    "answer": "cpg.call.name(\"socket\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show reads from /proc.",
    "answer": "cpg.call.name(\"open\").where(_.argument.code.contains(\"/proc\")).code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find functions that read user tokens.",
    "answer": "cpg.identifier.name(\"token\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify functions that handle login tokens.",
    "answer": "cpg.call.name(\"token\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve functions that write to log files.",
    "answer": "cpg.call.name(\"fprintf|log|syslog\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate system calls executed in the code.",
    "answer": "cpg.call.name(\"exec|system|fork\").code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display network calls to internal addresses.",
    "answer": "cpg.literal.code(\"192.168.|10.0.\").l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get functions handling user authentication.",
    "answer": "cpg.call.name(\"authenticate|login\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List functions reading environment variables.",
    "answer": "cpg.call.name(\"getenv\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show calls to 'chmod'.",
    "answer": "cpg.call.name(\"chmod\").code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find functions that open network sockets.",
    "answer": "cpg.call.name(\"socket\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify reads from /proc.",
    "answer": "cpg.call.name(\"open\").where(_.argument.code.contains(\"/proc\")).code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve functions that read user tokens.",
    "answer": "cpg.identifier.name(\"token\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate functions that handle login tokens.",
    "answer": "cpg.call.name(\"token\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display functions that write to log files.",
    "answer": "cpg.call.name(\"fprintf|log|syslog\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get system calls executed in the code.",
    "answer": "cpg.call.name(\"exec|system|fork\").code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List network calls to internal addresses.",
    "answer": "cpg.literal.code(\"192.168.|10.0.\").l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Show functions handling user authentication.",
    "answer": "cpg.call.name(\"authenticate|login\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Find functions reading environment variables.",
    "answer": "cpg.call.name(\"getenv\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Identify calls to 'chmod'.",
    "answer": "cpg.call.name(\"chmod\").code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Retrieve functions that open network sockets.",
    "answer": "cpg.call.name(\"socket\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Enumerate reads from /proc.",
    "answer": "cpg.call.name(\"open\").where(_.argument.code.contains(\"/proc\")).code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Display functions that read user tokens.",
    "answer": "cpg.identifier.name(\"token\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "Get functions that handle login tokens.",
    "answer": "cpg.call.name(\"token\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "low"
    }
  },
  {
    "question": "List input handling without sanitization.",
    "answer": "cpg.call.name(\"scanf|gets|fgets\").whereNot(_.caller.call.name(\"sanitize|validate\").nonEmpty).code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show functions writing sensitive data to external sockets.",
    "answer": "cpg.call.name(\"send|write\").where(_.argument.reachableBy(cpg.identifier.name(\"password|token\")).nonEmpty).code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find credential storage to disk.",
    "answer": "cpg.call.name(\"fwrite|write\").where(_.argument.reachableBy(cpg.identifier.name(\"password|secret\")).nonEmpty).method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify unencrypted network transmission of sensitive data.",
    "answer": "cpg.call.name(\"send\").where(_.argument.code.matches(\".*HTTP/1.0.*\") && _.argument.reachableBy(cpg.identifier.name(\"password\")).nonEmpty).code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve functions that log stack traces.",
    "answer": "cpg.call.name(\"backtrace|stackTrace\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate functions that read from proc and write to logs.",
    "answer": "cpg.method.where(_.call.name(\"open\").where(_.argument.code.contains(\"/proc\")).nonEmpty && _.call.name(\"log\").nonEmpty).name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display functions performing privilege checks.",
    "answer": "cpg.call.name(\"check_permission|authz\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get functions storing secrets in memory.",
    "answer": "cpg.method.where(_.local.name(\"secret\").nonEmpty).name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions reading configuration files for security settings.",
    "answer": "cpg.call.name(\"fopen\").where(_.argument.code.contains(\"config\")).method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show input handling without sanitization.",
    "answer": "cpg.call.name(\"scanf|gets|fgets\").whereNot(_.caller.call.name(\"sanitize|validate\").nonEmpty).code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find functions writing sensitive data to external sockets.",
    "answer": "cpg.call.name(\"send|write\").where(_.argument.reachableBy(cpg.identifier.name(\"password|token\")).nonEmpty).code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify credential storage to disk.",
    "answer": "cpg.call.name(\"fwrite|write\").where(_.argument.reachableBy(cpg.identifier.name(\"password|secret\")).nonEmpty).method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve unencrypted network transmission of sensitive data.",
    "answer": "cpg.call.name(\"send\").where(_.argument.code.matches(\".*HTTP/1.0.*\") && _.argument.reachableBy(cpg.identifier.name(\"password\")).nonEmpty).code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate functions that log stack traces.",
    "answer": "cpg.call.name(\"backtrace|stackTrace\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display functions that read from proc and write to logs.",
    "answer": "cpg.method.where(_.call.name(\"open\").where(_.argument.code.contains(\"/proc\")).nonEmpty && _.call.name(\"log\").nonEmpty).name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get functions performing privilege checks.",
    "answer": "cpg.call.name(\"check_permission|authz\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions storing secrets in memory.",
    "answer": "cpg.method.where(_.local.name(\"secret\").nonEmpty).name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show functions reading configuration files for security settings.",
    "answer": "cpg.call.name(\"fopen\").where(_.argument.code.contains(\"config\")).method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find input handling without sanitization.",
    "answer": "cpg.call.name(\"scanf|gets|fgets\").whereNot(_.caller.call.name(\"sanitize|validate\").nonEmpty).code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify functions writing sensitive data to external sockets.",
    "answer": "cpg.call.name(\"send|write\").where(_.argument.reachableBy(cpg.identifier.name(\"password|token\")).nonEmpty).code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve credential storage to disk.",
    "answer": "cpg.call.name(\"fwrite|write\").where(_.argument.reachableBy(cpg.identifier.name(\"password|secret\")).nonEmpty).method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate unencrypted network transmission of sensitive data.",
    "answer": "cpg.call.name(\"send\").where(_.argument.code.matches(\".*HTTP/1.0.*\") && _.argument.reachableBy(cpg.identifier.name(\"password\")).nonEmpty).code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display functions that log stack traces.",
    "answer": "cpg.call.name(\"backtrace|stackTrace\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get functions that read from proc and write to logs.",
    "answer": "cpg.method.where(_.call.name(\"open\").where(_.argument.code.contains(\"/proc\")).nonEmpty && _.call.name(\"log\").nonEmpty).name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions performing privilege checks.",
    "answer": "cpg.call.name(\"check_permission|authz\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show functions storing secrets in memory.",
    "answer": "cpg.method.where(_.local.name(\"secret\").nonEmpty).name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find functions reading configuration files for security settings.",
    "answer": "cpg.call.name(\"fopen\").where(_.argument.code.contains(\"config\")).method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Identify input handling without sanitization.",
    "answer": "cpg.call.name(\"scanf|gets|fgets\").whereNot(_.caller.call.name(\"sanitize|validate\").nonEmpty).code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Retrieve functions writing sensitive data to external sockets.",
    "answer": "cpg.call.name(\"send|write\").where(_.argument.reachableBy(cpg.identifier.name(\"password|token\")).nonEmpty).code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Enumerate credential storage to disk.",
    "answer": "cpg.call.name(\"fwrite|write\").where(_.argument.reachableBy(cpg.identifier.name(\"password|secret\")).nonEmpty).method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Display unencrypted network transmission of sensitive data.",
    "answer": "cpg.call.name(\"send\").where(_.argument.code.matches(\".*HTTP/1.0.*\") && _.argument.reachableBy(cpg.identifier.name(\"password\")).nonEmpty).code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Get functions that log stack traces.",
    "answer": "cpg.call.name(\"backtrace|stackTrace\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List functions that read from proc and write to logs.",
    "answer": "cpg.method.where(_.call.name(\"open\").where(_.argument.code.contains(\"/proc\")).nonEmpty && _.call.name(\"log\").nonEmpty).name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Show functions performing privilege checks.",
    "answer": "cpg.call.name(\"check_permission|authz\").method.name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "Find functions storing secrets in memory.",
    "answer": "cpg.method.where(_.local.name(\"secret\").nonEmpty).name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "medium"
    }
  },
  {
    "question": "List attacker-controlled data reaching system calls.",
    "answer": "cpg.call.name(\"exec|system\").where(_.argument.reachableBy(cpg.call.name(\"recv|read|gets\").argument)).l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show secrets sent to remote endpoints.",
    "answer": "cpg.call.name(\"send|write\").where(_.argument.reachableBy(cpg.identifier.name(\"secret|key\")).nonEmpty).locations.l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find authentication functions using insecure random tokens.",
    "answer": "cpg.method.where(_.call.name(\"authenticate|login\").nonEmpty && _.call.name(\"rand\").nonEmpty).name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify flows from environment variables to file writes.",
    "answer": "cpg.call.name(\"fwrite|write\").where(_.argument.reachableBy(cpg.call.name(\"getenv\").argument)).l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve execution of base64 decoded user input.",
    "answer": "cpg.call.name(\"base64_decode\").where(_.argument.reachableBy(cpg.call.name(\"recv|read\")).nonEmpty).caller.call.name(\"exec\").code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate attacker-controlled data reaching system calls.",
    "answer": "cpg.call.name(\"exec|system\").where(_.argument.reachableBy(cpg.call.name(\"recv|read|gets\").argument)).l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display secrets sent to remote endpoints.",
    "answer": "cpg.call.name(\"send|write\").where(_.argument.reachableBy(cpg.identifier.name(\"secret|key\")).nonEmpty).locations.l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get authentication functions using insecure random tokens.",
    "answer": "cpg.method.where(_.call.name(\"authenticate|login\").nonEmpty && _.call.name(\"rand\").nonEmpty).name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List flows from environment variables to file writes.",
    "answer": "cpg.call.name(\"fwrite|write\").where(_.argument.reachableBy(cpg.call.name(\"getenv\").argument)).l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show execution of base64 decoded user input.",
    "answer": "cpg.call.name(\"base64_decode\").where(_.argument.reachableBy(cpg.call.name(\"recv|read\")).nonEmpty).caller.call.name(\"exec\").code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find attacker-controlled data reaching system calls.",
    "answer": "cpg.call.name(\"exec|system\").where(_.argument.reachableBy(cpg.call.name(\"recv|read|gets\").argument)).l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify secrets sent to remote endpoints.",
    "answer": "cpg.call.name(\"send|write\").where(_.argument.reachableBy(cpg.identifier.name(\"secret|key\")).nonEmpty).locations.l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve authentication functions using insecure random tokens.",
    "answer": "cpg.method.where(_.call.name(\"authenticate|login\").nonEmpty && _.call.name(\"rand\").nonEmpty).name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate flows from environment variables to file writes.",
    "answer": "cpg.call.name(\"fwrite|write\").where(_.argument.reachableBy(cpg.call.name(\"getenv\").argument)).l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display execution of base64 decoded user input.",
    "answer": "cpg.call.name(\"base64_decode\").where(_.argument.reachableBy(cpg.call.name(\"recv|read\")).nonEmpty).caller.call.name(\"exec\").code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get attacker-controlled data reaching system calls.",
    "answer": "cpg.call.name(\"exec|system\").where(_.argument.reachableBy(cpg.call.name(\"recv|read|gets\").argument)).l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List secrets sent to remote endpoints.",
    "answer": "cpg.call.name(\"send|write\").where(_.argument.reachableBy(cpg.identifier.name(\"secret|key\")).nonEmpty).locations.l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Show authentication functions using insecure random tokens.",
    "answer": "cpg.method.where(_.call.name(\"authenticate|login\").nonEmpty && _.call.name(\"rand\").nonEmpty).name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Find flows from environment variables to file writes.",
    "answer": "cpg.call.name(\"fwrite|write\").where(_.argument.reachableBy(cpg.call.name(\"getenv\").argument)).l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Identify execution of base64 decoded user input.",
    "answer": "cpg.call.name(\"base64_decode\").where(_.argument.reachableBy(cpg.call.name(\"recv|read\")).nonEmpty).caller.call.name(\"exec\").code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Retrieve attacker-controlled data reaching system calls.",
    "answer": "cpg.call.name(\"exec|system\").where(_.argument.reachableBy(cpg.call.name(\"recv|read|gets\").argument)).l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Enumerate secrets sent to remote endpoints.",
    "answer": "cpg.call.name(\"send|write\").where(_.argument.reachableBy(cpg.identifier.name(\"secret|key\")).nonEmpty).locations.l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Display authentication functions using insecure random tokens.",
    "answer": "cpg.method.where(_.call.name(\"authenticate|login\").nonEmpty && _.call.name(\"rand\").nonEmpty).name.l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "Get flows from environment variables to file writes.",
    "answer": "cpg.call.name(\"fwrite|write\").where(_.argument.reachableBy(cpg.call.name(\"getenv\").argument)).l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  },
  {
    "question": "List execution of base64 decoded user input.",
    "answer": "cpg.call.name(\"base64_decode\").where(_.argument.reachableBy(cpg.call.name(\"recv|read\")).nonEmpty).caller.call.name(\"exec\").code.l",
    "scenario": 14,
    "metadata": {
      "complexity": "high"
    }
  }
]