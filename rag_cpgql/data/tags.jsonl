{"summary":{"total_tags":1892841,"distinct_names":38},"names":[{"name":"function-purpose","total":228030},{"name":"cyclomatic-complexity","total":209212},{"name":"lines-of-code","total":209212},{"name":"refactor-priority","total":209212},{"name":"test-count","total":207632},{"name":"test-coverage","total":207632},{"name":"api-caller-count","total":57520},{"name":"api-typical-usage","total":57520},{"name":"api-public","total":50496},{"name":"loop-depth","total":43296},{"name":"perf-hotspot","total":43296},{"name":"api-example","total":43140},{"name":"data-structure","total":38778},{"name":"algorithm-class","total":38451},{"name":"trust-boundary","total":30948},{"name":"code-smell","total":30852},{"name":"domain-concept","total":24312},{"name":"tested-by","total":19376},{"name":"risk-severity","total":18032},{"name":"sanitization-point","total":18032},{"name":"security-risk","total":18032},{"name":"arch-layer","total":10984},{"name":"arch-layer-depth","total":10984},{"name":"arch-layer-description","total":10984},{"name":"coupling-score","total":9016},{"name":"module-layer","total":9016},{"name":"expensive-op","total":8464},{"name":"module-depends-on","total":5608},{"name":"Feature","total":4929},{"name":"subsystem-desc","total":3560},{"name":"subsystem-name","total":3560},{"name":"subsystem-path","total":3560},{"name":"extensibility","total":3312},{"name":"extension-point","total":3312},{"name":"io-bound","total":1024},{"name":"privilege-level","total":664},{"name":"allocation-heavy","total":624},{"name":"arch-sublayer","total":229}],"pairs":[{"name":"test-count","value":"0","count":188256},{"name":"test-coverage","value":"untested","count":188256},{"name":"refactor-priority","value":"low","count":186656},{"name":"cyclomatic-complexity","value":"1","count":141500},{"name":"lines-of-code","value":"1","count":83532},{"name":"api-public","value":"true","count":50496},{"name":"function-purpose","value":"statistics","count":45255},{"name":"perf-hotspot","value":"hot","count":43192},{"name":"function-purpose","value":"utilities","count":42510},{"name":"function-purpose","value":"general","count":39288},{"name":"trust-boundary","value":"user-input","count":25904},{"name":"test-coverage","value":"covered","count":19376},{"name":"sanitization-point","value":"none","count":18032},{"name":"refactor-priority","value":"critical","count":15804},{"name":"function-purpose","value":"memory-management","count":15756},{"name":"code-smell","value":"long-method","count":15340},{"name":"data-structure","value":"linked-list","count":13716},{"name":"code-smell","value":"deep-nesting","count":12864},{"name":"function-purpose","value":"parsing","count":11532},{"name":"algorithm-class","value":"searching","count":11136},{"name":"lines-of-code","value":"5","count":10584},{"name":"function-purpose","value":"storage-access","count":10404},{"name":"function-purpose","value":"type-system","count":10086},{"name":"security-risk","value":"format-string","count":9076},{"name":"module-layer","value":"unknown","count":9016},{"name":"function-purpose","value":"wal-logging","count":8967},{"name":"arch-layer","value":"unknown","count":8712},{"name":"arch-layer-depth","value":"99","count":8712},{"name":"arch-layer-description","value":"Unclassified files","count":8712},{"name":"data-structure","value":"relation","count":8679},{"name":"lines-of-code","value":"2","count":8424},{"name":"domain-concept","value":"replication","count":8298},{"name":"cyclomatic-complexity","value":"3","count":8112},{"name":"function-purpose","value":"networking","count":8022},{"name":"cyclomatic-complexity","value":"2","count":8008},{"name":"risk-severity","value":"medium","count":7776},{"name":"security-risk","value":"buffer-overflow","count":7708},{"name":"function-purpose","value":"error-handling","count":7269},{"name":"function-purpose","value":"concurrency-control","count":7107},{"name":"algorithm-class","value":"sorting","count":6990},{"name":"loop-depth","value":"8","count":6576},{"name":"loop-depth","value":"9","count":6556},{"name":"function-purpose","value":"query-planning","count":6501},{"name":"function-purpose","value":"transaction-control","count":6357},{"name":"risk-severity","value":"high","count":6196},{"name":"test-count","value":"1","count":6068},{"name":"cyclomatic-complexity","value":"5","count":5824},{"name":"expensive-op","value":"memory-alloc","count":5764},{"name":"cyclomatic-complexity","value":"4","count":5292},{"name":"lines-of-code","value":"8","count":5132},{"name":"api-caller-count","value":"5","count":5084},{"name":"loop-depth","value":"7","count":5052},{"name":"data-structure","value":"array","count":4995},{"name":"data-structure","value":"hash-table","count":4914},{"name":"refactor-priority","value":"medium","count":4816},{"name":"algorithm-class","value":"hashing","count":4794},{"name":"function-purpose","value":"query-execution","count":4785},{"name":"algorithm-class","value":"caching","count":4671},{"name":"trust-boundary","value":"file-input","count":4624},{"name":"lines-of-code","value":"7","count":4408},{"name":"lines-of-code","value":"4","count":4392},{"name":"cyclomatic-complexity","value":"6","count":4252},{"name":"api-caller-count","value":"6","count":4240},{"name":"function-purpose","value":"catalog-access","count":4191},{"name":"lines-of-code","value":"6","count":4096},{"name":"domain-concept","value":"parallelism","count":3828},{"name":"loop-depth","value":"10","count":3792},{"name":"algorithm-class","value":"parsing","count":3681},{"name":"lines-of-code","value":"9","count":3608},{"name":"domain-concept","value":"extension","count":3552},{"name":"cyclomatic-complexity","value":"7","count":3476},{"name":"api-caller-count","value":"7","count":3460},{"name":"lines-of-code","value":"10","count":2948},{"name":"coupling-score","value":"0","count":2936},{"name":"lines-of-code","value":"3","count":2916},{"name":"algorithm-class","value":"compression","count":2898},{"name":"loop-depth","value":"11","count":2836},{"name":"cyclomatic-complexity","value":"9","count":2752},{"name":"lines-of-code","value":"11","count":2740},{"name":"algorithm-class","value":"aggregation","count":2691},{"name":"cyclomatic-complexity","value":"8","count":2676},{"name":"extension-point","value":"plugin-api","count":2676},{"name":"lines-of-code","value":"13","count":2676},{"name":"code-smell","value":"too-many-params","count":2648},{"name":"loop-depth","value":"12","count":2600},{"name":"lines-of-code","value":"14","count":2584},{"name":"api-typical-usage","value":"Often called from: <global>","count":2544},{"name":"data-structure","value":"buffer","count":2514},{"name":"extensibility","value":"sealed","count":2512},{"name":"api-caller-count","value":"8","count":2496},{"name":"test-count","value":"2","count":2488},{"name":"lines-of-code","value":"12","count":2416},{"name":"risk-severity","value":"critical","count":2332},{"name":"domain-concept","value":"mvcc","count":2328},{"name":"lines-of-code","value":"15","count":2312},{"name":"cyclomatic-complexity","value":"10","count":2132},{"name":"domain-concept","value":"partitioning","count":2046},{"name":"cyclomatic-complexity","value":"11","count":2008},{"name":"api-caller-count","value":"9","count":2000},{"name":"lines-of-code","value":"17","count":1980},{"name":"lines-of-code","value":"16","count":1964},{"name":"data-structure","value":"bitmap","count":1956},{"name":"refactor-priority","value":"high","count":1936},{"name":"loop-depth","value":"5","count":1924},{"name":"cyclomatic-complexity","value":"12","count":1868},{"name":"api-caller-count","value":"10","count":1840},{"name":"api-caller-count","value":"11","count":1828},{"name":"loop-depth","value":"13","count":1760},{"name":"lines-of-code","value":"18","count":1756},{"name":"loop-depth","value":"14","count":1728},{"name":"risk-severity","value":"low","count":1728},{"name":"lines-of-code","value":"19","count":1712},{"name":"lines-of-code","value":"21","count":1704},{"name":"domain-concept","value":"vacuum","count":1686},{"name":"expensive-op","value":"sync-lock","count":1676},{"name":"lines-of-code","value":"20","count":1648},{"name":"domain-concept","value":"jit","count":1620},{"name":"test-count","value":"3","count":1600},{"name":"algorithm-class","value":"optimization","count":1590},{"name":"cyclomatic-complexity","value":"13","count":1580},{"name":"loop-depth","value":"6","count":1524},{"name":"lines-of-code","value":"23","count":1504},{"name":"loop-depth","value":"16","count":1480},{"name":"lines-of-code","value":"22","count":1452},{"name":"api-typical-usage","value":"Often called from: main","count":1348},{"name":"lines-of-code","value":"24","count":1348},{"name":"api-typical-usage","value":"Often called from: getObjectIdentityParts","count":1344},{"name":"lines-of-code","value":"26","count":1340},{"name":"loop-depth","value":"15","count":1340},{"name":"api-caller-count","value":"12","count":1308},{"name":"cyclomatic-complexity","value":"14","count":1280},{"name":"lines-of-code","value":"25","count":1252},{"name":"cyclomatic-complexity","value":"15","count":1212},{"name":"lines-of-code","value":"28","count":1124},{"name":"arch-layer","value":"include","count":1101},{"name":"arch-layer-depth","value":"10","count":1101},{"name":"arch-layer-description","value":"Header files","count":1101},{"name":"loop-depth","value":"17","count":1100},{"name":"lines-of-code","value":"29","count":1092},{"name":"lines-of-code","value":"27","count":1088},{"name":"data-structure","value":"queue","count":1074},{"name":"cyclomatic-complexity","value":"17","count":1056},{"name":"lines-of-code","value":"30","count":1048},{"name":"api-example","value":"Datum brinhandler(PG_FUNCTION_ARGS) { IndexAmRoutine *amroutine = makeNode(IndexAmRoutine); amroutine->amstrategies = 0; amroutine->amsupport = BRIN_LAST_OPTIONAL_PROCNUM; amroutine->amoptsprocnum = B...","count":1035},{"name":"security-risk","value":"path-traversal","count":1028},{"name":"expensive-op","value":"io","count":1024},{"name":"io-bound","value":"true","count":1024},{"name":"test-count","value":"32","count":1016},{"name":"api-caller-count","value":"13","count":1008},{"name":"cyclomatic-complexity","value":"16","count":1000},{"name":"domain-concept","value":"foreign-data","count":954},{"name":"lines-of-code","value":"33","count":948},{"name":"api-example","value":"bool brininsert(Relation idxRel, Datum *values, bool *nulls, ItemPointer heaptid, Relation heapRel, IndexUniqueCheck checkUnique, bool indexUnchanged, IndexInfo *indexInfo) { BlockNumber pagesPerRange...","count":945},{"name":"lines-of-code","value":"34","count":944},{"name":"api-caller-count","value":"16","count":936},{"name":"api-caller-count","value":"14","count":932},{"name":"data-structure","value":"binary-tree","count":930},{"name":"lines-of-code","value":"31","count":920},{"name":"lines-of-code","value":"32","count":896},{"name":"test-count","value":"5","count":888},{"name":"loop-depth","value":"18","count":880},{"name":"api-caller-count","value":"15","count":876},{"name":"cyclomatic-complexity","value":"18","count":856},{"name":"api-caller-count","value":"18","count":852},{"name":"lines-of-code","value":"38","count":852},{"name":"api-example","value":"int64 bringetbitmap(IndexScanDesc scan, TIDBitmap *tbm) { Relation\tidxRel = scan->indexRelation; Buffer\t\tbuf = InvalidBuffer; BrinDesc   *bdesc; Oid\t\t\theapOid; Relation\theapRel; BrinOpaque *opaque; Bl...","count":846},{"name":"coupling-score","value":"1","count":832},{"name":"api-caller-count","value":"17","count":828},{"name":"module-depends-on","value":"<unknown>","count":824},{"name":"test-count","value":"17","count":820},{"name":"cyclomatic-complexity","value":"19","count":816},{"name":"loop-depth","value":"4","count":808},{"name":"lines-of-code","value":"35","count":776},{"name":"lines-of-code","value":"36","count":776},{"name":"test-count","value":"7","count":756},{"name":"lines-of-code","value":"37","count":728},{"name":"api-caller-count","value":"21","count":724},{"name":"subsystem-desc","value":"src/port/README\n\nlibpgport\n=========\n\nlibpgport must have special behavior.  It supplies functions to both\nlibraries and applications.  However, there are two complexities:\n\n1)  Libraries need to use object files that are compiled with exactly\nthe same flags as the library.  libpgport might not use the same flags,\nso it is necessary to recompile the object files for individual\nlibraries.  This is done by removing -lpgport from the link line:\n\n        # Need to recompile any libpgport object files\n        LIBS := $(filter-out -lpgport, $(LIBS))\n\nand adding infrastructure to recompile the object files:\n\n        OBJS= execute.o typename.o descriptor.o data.o error.o prepare.o memory.o \\\n                connect.o misc.o path.o exec.o \\\n                $(filter strlcat.o, $(LIBOBJS))\n\nThe problem is that there is no testing of which object files need to be\nadded, but missing functions usually show up when linking user\napplications.\n\n2) For applications, we use -lpgport before -lpq, so the static files\nfrom libpgport are linked first.  This avoids having applications\ndependent on symbols that are _used_ by libpq, but not intended to be\nexported by libpq.  libpq's libpgport usage changes over time, so such a\ndependency is a problem.  Windows, Linux, and macOS use an export\nlist to control the symbols exported by libpq.","count":710},{"name":"subsystem-name","value":"port","count":710},{"name":"subsystem-path","value":"port/readme","count":710},{"name":"lines-of-code","value":"41","count":708},{"name":"test-count","value":"4","count":684},{"name":"lines-of-code","value":"39","count":680},{"name":"lines-of-code","value":"43","count":680},{"name":"lines-of-code","value":"40","count":668},{"name":"api-example","value":"bool brinvalidate(Oid opclassoid) { bool\t\tresult = true; HeapTuple\tclasstup; Form_pg_opclass classform; Oid\t\t\topfamilyoid; Oid\t\t\topcintype; char\t   *opclassname; HeapTuple\tfamilytup; Form_pg_opfamily ...","count":663},{"name":"api-typical-usage","value":"Often called from: ExecInitExprRec","count":660},{"name":"loop-depth","value":"19","count":656},{"name":"cyclomatic-complexity","value":"20","count":648},{"name":"cyclomatic-complexity","value":"21","count":644},{"name":"lines-of-code","value":"46","count":632},{"name":"cyclomatic-complexity","value":"22","count":628},{"name":"allocation-heavy","value":"true","count":624},{"name":"extension-point","value":"hook","count":624},{"name":"cyclomatic-complexity","value":"23","count":604},{"name":"lines-of-code","value":"44","count":600},{"name":"lines-of-code","value":"49","count":592},{"name":"lines-of-code","value":"42","count":588},{"name":"api-typical-usage","value":"Often called from: find_expr_references_walker","count":568},{"name":"lines-of-code","value":"47","count":568},{"name":"lines-of-code","value":"51","count":568},{"name":"loop-depth","value":"20","count":568},{"name":"lines-of-code","value":"48","count":560},{"name":"lines-of-code","value":"50","count":560},{"name":"api-caller-count","value":"24","count":544},{"name":"api-typical-usage","value":"Often called from: add_paths_to_append_rel","count":536},{"name":"privilege-level","value":"user","count":536},{"name":"api-example","value":"BrinDesc * brin_build_desc(Relation rel) { BrinOpcInfo **opcinfo; BrinDesc   *bdesc; TupleDesc\ttupdesc; int\t\t\ttotalstored = 0; int\t\t\tkeyno; long\t\ttotalsize; MemoryContext cxt; MemoryContext oldcxt; cx...","count":534},{"name":"api-typical-usage","value":"Often called from: enforce_generic_type_consistency","count":532},{"name":"lines-of-code","value":"45","count":532},{"name":"api-caller-count","value":"2524","count":520},{"name":"tested-by","value":"heap_truncate_check_FKs, heap_truncate_check_FKs, heap_truncate_check_FKs, check_publications, check_publications_origin, check_sql_fn_statements, check_sql_fn_retval, check_sql_fn_retval, check_sql_f","count":520},{"name":"extensibility","value":"internal-hook","count":516},{"name":"api-caller-count","value":"1682","count":492},{"name":"tested-by","value":"check_wal_consistency_checking, heap_truncate_check_FKs, check_functional_grouping, check_temp_tablespaces, check_createrole_self_grant, check_datestyle, check_sql_fn_retval, check_sql_fn_retval, chec","count":492},{"name":"api-caller-count","value":"22","count":480},{"name":"api-caller-count","value":"270","count":480},{"name":"lines-of-code","value":"52","count":480},{"name":"api-typical-usage","value":"Often called from: DeconstructFkConstraintRow","count":472},{"name":"api-caller-count","value":"20","count":468},{"name":"api-caller-count","value":"25","count":460},{"name":"cyclomatic-complexity","value":"25","count":460},{"name":"api-caller-count","value":"967","count":456},{"name":"lines-of-code","value":"54","count":456},{"name":"lines-of-code","value":"61","count":456},{"name":"api-caller-count","value":"23","count":448},{"name":"cyclomatic-complexity","value":"26","count":448},{"name":"test-count","value":"13","count":448},{"name":"api-caller-count","value":"19","count":444},{"name":"api-caller-count","value":"37","count":444},{"name":"api-example","value":"IndexBuildResult * brinbuild(Relation heap, Relation index, IndexInfo *indexInfo) { IndexBuildResult *result; double\t\treltuples; double\t\tidxtuples; BrinRevmap *revmap; BrinBuildState *state; Buffer\t\tm...","count":444},{"name":"test-count","value":"44","count":444},{"name":"lines-of-code","value":"53","count":440},{"name":"lines-of-code","value":"59","count":440},{"name":"tested-by","value":"json_unique_check_init","count":440},{"name":"api-caller-count","value":"93","count":432},{"name":"api-typical-usage","value":"Often called from: _PG_init","count":432},{"name":"api-typical-usage","value":"Often called from: ReindexRelationConcurrently","count":420},{"name":"api-typical-usage","value":"Often called from: get_func_sql_syntax","count":420},{"name":"trust-boundary","value":"network-input","count":420},{"name":"lines-of-code","value":"56","count":416},{"name":"lines-of-code","value":"67","count":416},{"name":"api-caller-count","value":"29","count":412},{"name":"lines-of-code","value":"66","count":408},{"name":"lines-of-code","value":"58","count":404},{"name":"lines-of-code","value":"60","count":404},{"name":"api-caller-count","value":"11083","count":396},{"name":"test-count","value":"307","count":396},{"name":"tested-by","value":"check_null_keys, check_attrmap_match, check_hash_func_signature, test_lockmode_for_conflict, lazy_check_wraparound_failsafe, lazy_check_wraparound_failsafe, lazy_check_wraparound_failsafe, check_ampro","count":396},{"name":"tested-by","value":"check_object_ownership, check_object_ownership","count":396},{"name":"api-example","value":"void init_local_reloptions(local_relopts *relopts, Size relopt_struct_size) { relopts->options = NIL; relopts->validators = NIL; relopts->relopt_struct_size = relopt_struct_size; }","count":390},{"name":"api-caller-count","value":"13548","count":388},{"name":"lines-of-code","value":"55","count":388},{"name":"lines-of-code","value":"57","count":388},{"name":"test-count","value":"382","count":388},{"name":"tested-by","value":"check_null_keys, check_null_keys, check_null_keys, check_attrmap_match, check_attrmap_match, check_attrmap_match, check_hash_func_signature, check_hash_func_signature, check_hash_func_signature, test_","count":388},{"name":"api-caller-count","value":"27","count":380},{"name":"api-typical-usage","value":"Often called from: does_not_exist_skipping","count":376},{"name":"cyclomatic-complexity","value":"29","count":376},{"name":"cyclomatic-complexity","value":"27","count":372},{"name":"coupling-score","value":"3","count":368},{"name":"api-example","value":"static GISTInsertStack * gistFindPath(Relation r, BlockNumber child, OffsetNumber *downlinkoffnum) { Page\t\tpage; Buffer\t\tbuffer; OffsetNumber i, maxoff; ItemId\t\tiid; IndexTuple\tidxtuple; List\t   *fifo...","count":363},{"name":"api-caller-count","value":"379","count":360},{"name":"api-typical-usage","value":"Often called from: exec_move_row_from_fields","count":360},{"name":"coupling-score","value":"5","count":360},{"name":"cyclomatic-complexity","value":"24","count":360},{"name":"lines-of-code","value":"63","count":360},{"name":"lines-of-code","value":"65","count":360},{"name":"tested-by","value":"check_attrmap_match, check_attrmap_match, check_sql_fn_retval, check_sql_fn_retval, check_domain_for_new_field, hypothetical_check_argtypes, hypothetical_check_argtypes","count":360},{"name":"api-caller-count","value":"267","count":356},{"name":"api-caller-count","value":"8459","count":352},{"name":"api-typical-usage","value":"Often called from: GetTableAmRoutine","count":352},{"name":"lines-of-code","value":"62","count":352},{"name":"test-count","value":"78","count":352},{"name":"tested-by","value":"check_null_keys, heap_get_latest_tid, index_delete_check_htid, index_delete_check_htid, systable_recheck_tuple, _bt_check_unique, _bt_check_unique, _bt_check_unique, _bt_check_unique, _bt_check_unique","count":352},{"name":"test-count","value":"6","count":344},{"name":"api-caller-count","value":"1457","count":340},{"name":"api-caller-count","value":"38","count":340},{"name":"lines-of-code","value":"64","count":340},{"name":"tested-by","value":"check_default_partition_contents","count":340},{"name":"tested-by","value":"check_nested_generated_walker, check_functional_grouping, check_simple_rowfilter_expr_walker, check_sql_fn_statements, check_constant_qual, check_and_push_window_quals, check_and_push_window_quals, ch","count":340},{"name":"api-example","value":"Datum brin_summarize_range(PG_FUNCTION_ARGS) { Oid\t\t\tindexoid = PG_GETARG_OID(0); int64\t\theapBlk64 = PG_GETARG_INT64(1); BlockNumber heapBlk; Oid\t\t\theapoid; Relation\tindexRel; Relation\theapRel; Oid\t\t\t...","count":339},{"name":"arch-layer-depth","value":"1","count":338},{"name":"loop-depth","value":"21","count":336},{"name":"arch-layer","value":"infrastructure","count":334},{"name":"arch-layer-description","value":"Process management and IPC","count":334},{"name":"api-example","value":"static void init_missing_cache() { HASHCTL\t\thash_ctl; hash_ctl.keysize = sizeof(missing_cache_key); hash_ctl.entrysize = sizeof(missing_cache_key); hash_ctl.hcxt = TopMemoryContext; hash_ctl.hash = mi...","count":330},{"name":"api-caller-count","value":"30","count":328},{"name":"api-typical-usage","value":"Often called from: <clinit>","count":328},{"name":"api-typical-usage","value":"Often called from: eval_const_expressions_mutator","count":328},{"name":"cyclomatic-complexity","value":"30","count":328},{"name":"lines-of-code","value":"69","count":328},{"name":"subsystem-desc","value":"src/backend/executor/README\n\nThe Postgres Executor\n=====================\n\nThe executor processes a tree of \"plan nodes\".  The plan tree is essentially\na demand-pull pipeline of tuple processing operations.  Each node, when\ncalled, will produce the next tuple in its output sequence, or NULL if no\nmore tuples are available.  If the node is not a primitive relation-scanning\nnode, it will have child node(s) that it calls in turn to obtain input\ntuples.\n\nRefinements on this basic model include:\n\n* Choice of scan direction (forwards or backwards).  Caution: this is not\ncurrently well-supported.  It works for primitive scan nodes, but not very\nwell for joins, aggregates, etc.\n\n* Rescan command to reset a node and make it generate its output sequence\nover again.\n\n* Parameters that can alter a node's results.  After adjusting a parameter,\nthe rescan command must be applied to that node and all nodes above it.\nThere is a moderately intelligent scheme to avoid rescanning nodes\nunnecessarily (for example, Sort does not rescan its input if no parameters\nof the input have changed, since it can just reread its stored sorted data).\n\nFor a SELECT, it is only necessary to deliver the top-level result tuples\nto the client.  For INSERT/UPDATE/DELETE/MERGE, the actual table modification\noperations happen in a top-level ModifyTable plan node.  If the query\nincludes a RETURNING clause, the ModifyTable node delivers the computed\nRETURNING rows as output, otherwise it returns nothing.  Handling INSERT\nis pretty straightforward: the tuples returned from the plan tree below\nModifyTable are inserted into the correct result relation.  For UPDATE,\nthe plan tree returns the new values of the updated columns, plus \"junk\"\n(hidden) column(s) identifying which table row is to be updated.  The\nModifyTable node must fetch that row to extract values for the unchanged\ncolumns, combine the values into a new row, and apply the update.  (For a\nheap table, the row-identity junk column is a CTID, but other things may\nbe used for other table types.)  For DELETE, the plan tree need only deliver\njunk row-identity column(s), and the ModifyTable node visits each of those\nrows and marks the row deleted.  MERGE is described below.\n\nXXX a great deal more documentation needs to be written here...\n\n\nPlan Trees and State Trees\n--------------------------\n\nThe plan tree delivered by the planner contains a tree of Plan nodes (struct\ntypes derived from struct Plan).  During executor startup we build a parallel\ntree of identical structure containing executor state nodes --- generally,\nevery plan node type has a corresponding executor state node type.  Each node\nin the state tree has a pointer to its corresponding node in the plan tree,\nplus executor state data as needed to implement that node type.  This\narrangement allows the plan tree to be completely read-only so far as the\nexecutor is concerned: all data that is modified during execution is in the\nstate tree.  Read-only plan trees make life much simpler for plan caching and\nreuse.\n\nA corresponding executor state node may not be created during executor startup\nif the executor determines that an entire subplan is not required due to\nexecution time partition pruning determining that no matching records will be\nfound there.  This currently only occurs for Append and MergeAppend nodes.  In\nthis case the non-required subplans are ignored and the executor state's\nsubnode array will become out of sequence to the plan's subplan list.\n\nEach Plan node may have expression trees associated with it, to represent\nits target list, qualification conditions, etc.  These trees are also\nread-only to the executor, but the executor state for expression evaluation\ndoes not mirror the Plan expression's tree shape, as explained below.\nRather, there's just one ExprState node per expression tree, although this\nmay have sub-nodes for some complex expression node types.\n\nAltogether there are four classes of nodes used in these trees: Plan nodes,\ntheir corresponding PlanState nodes, Expr nodes, and ExprState nodes.\n(Actually, there are also List nodes, which are used as \"glue\" in all\nthree tree-based representations.)\n\n\nExpression Trees and ExprState nodes\n------------------------------------\n\nExpression trees, in contrast to Plan trees, are not mirrored into a\ncorresponding tree of state nodes.  Instead each separately executable\nexpression tree (e.g. a Plan's qual or targetlist) is represented by one\nExprState node.  The ExprState node contains the information needed to\nevaluate the expression in a compact, linear form.  That compact form is\nstored as a flat array in ExprState->steps[] (an array of ExprEvalStep,\nnot ExprEvalStep *).\n\nThe reasons for choosing such a representation include:\n- commonly the amount of work needed to evaluate one Expr-type node is\n  small enough that the overhead of having to perform a tree-walk\n  during evaluation is significant.\n- the flat representation can be evaluated non-recursively within a single\n  function, reducing stack depth and function call overhead.\n- such a representation is usable both for fast interpreted execution,\n  and for compiling into native code.\n\nThe Plan-tree representation of an expression is compiled into an\nExprState node by ExecInitExpr().  As much complexity as possible should\nbe handled by ExecInitExpr() (and helpers), instead of execution time\nwhere both interpreted and compiled versions would need to deal with the\ncomplexity.  Besides duplicating effort between execution approaches,\nruntime initialization checks also have a small but noticeable cost every\ntime the expression is evaluated.  Therefore, we allow ExecInitExpr() to\nprecompute information that we do not expect to vary across execution of a\nsingle query, for example the set of CHECK constraint expressions to be\napplied to a domain type.  This could not be done at plan time without\ngreatly increasing the number of events that require plan invalidation.\n(Previously, some information of this kind was rechecked on each\nexpression evaluation, but that seems like unnecessary overhead.)\n\n\nExpression Initialization\n-------------------------\n\nDuring ExecInitExpr() and similar routines, Expr trees are converted\ninto the flat representation.  Each Expr node might be represented by\nzero, one, or more ExprEvalSteps.\n\nEach ExprEvalStep's work is determined by its opcode (of enum ExprEvalOp)\nand it stores the result of its work into the Datum variable and boolean\nnull flag variable pointed to by ExprEvalStep->resvalue/resnull.\nComplex expressions are performed by chaining together several steps.\nFor example, \"a + b\" (one OpExpr, with two Var expressions) would be\nrepresented as two steps to fetch the Var values, and one step for the\nevaluation of the function underlying the + operator.  The steps for the\nVars would have their resvalue/resnull pointing directly to the appropriate\nargs[].value .isnull elements in the FunctionCallInfoBaseData struct that\nis used by the function evaluation step, thus avoiding extra work to copy\nthe result values around.\n\nThe last entry in a completed ExprState->steps array is always an\nEEOP_DONE step; this removes the need to test for end-of-array while\niterating.  Also, if the expression contains any variable references (to\nuser columns of the ExprContext's INNER, OUTER, or SCAN tuples), the steps\narray begins with EEOP_*_FETCHSOME steps that ensure that the relevant\ntuples have been deconstructed to make the required columns directly\navailable (cf. slot_getsomeattrs()).  This allows individual Var-fetching\nsteps to be little more than an array lookup.\n\nMost of ExecInitExpr()'s work is done by the recursive function\nExecInitExprRec() and its subroutines.  ExecInitExprRec() maps one Expr\nnode into the steps required for execution, recursing as needed for\nsub-expressions.\n\nEach ExecInitExprRec() call has to specify where that subexpression's\nresults are to be stored (via the resv/resnull parameters).  This allows\nthe above scenario of evaluating a (sub-)expression directly into\nfcinfo->args[].value/isnull, but also requires some care: target Datum/isnull\nvariables may not be shared with another ExecInitExprRec() unless the\nresults are only needed by steps executing before further usages of those\ntarget Datum/isnull variables.  Due to the non-recursiveness of the\nExprEvalStep representation that's usually easy to guarantee.\n\nExecInitExprRec() pushes new operations into the ExprState->steps array\nusing ExprEvalPushStep().  To keep the steps as a consecutively laid out\narray, ExprEvalPushStep() has to repalloc the entire array when there's\nnot enough space.  Because of that it is *not* allowed to point directly\ninto any of the steps during expression initialization.  Therefore, the\nresv/resnull for a subexpression usually point to some storage that is\npalloc'd separately from the steps array.  For instance, the\nFunctionCallInfoBaseData for a function call step is separately allocated\nrather than being part of the ExprEvalStep array.  The overall result\nof a complete expression is typically returned into the resvalue/resnull\nfields of the ExprState node itself.\n\nSome steps, e.g. boolean expressions, allow skipping evaluation of\ncertain subexpressions.  In the flat representation this amounts to\njumping to some later step rather than just continuing consecutively\nwith the next step.  The target for such a jump is represented by\nthe integer index in the ExprState->steps array of the step to execute\nnext.  (Compare the EEO_NEXT and EEO_JUMP macros in execExprInterp.c.)\n\nTypically, ExecInitExprRec() has to push a jumping step into the steps\narray, then recursively generate steps for the subexpression that might\nget skipped over, then go back and fix up the jump target index using\nthe now-known length of the subexpression's steps.  This is handled by\nadjust_jumps lists in execExpr.c.\n\nThe last step in constructing an ExprState is to apply ExecReadyExpr(),\nwhich readies it for execution using whichever execution method has been\nselected.\n\n\nExpression Evaluation\n---------------------\n\nTo allow for different methods of expression evaluation, and for\nbetter branch/jump target prediction, expressions are evaluated by\ncalling ExprState->evalfunc (via ExecEvalExpr() and friends).\n\nExecReadyExpr() can choose the method of interpretation by setting\nevalfunc to an appropriate function.  The default execution function,\nExecInterpExpr, is implemented in execExprInterp.c; see its header\ncomment for details.  Special-case evalfuncs are used for certain\nespecially-simple expressions.\n\nNote that a lot of the more complex expression evaluation steps, which are\nless performance-critical than the simpler ones, are implemented as\nseparate functions outside the fast-path of expression execution, allowing\ntheir implementation to be shared between interpreted and compiled\nexpression evaluation.  This means that these helper functions are not\nallowed to perform expression step dispatch themselves, as the method of\ndispatch will vary based on the caller.  The helpers therefore cannot call\nfor the execution of subexpressions; all subexpression results they need\nmust be computed by earlier steps.  And dispatch to the following\nexpression step must be performed after returning from the helper.\n\n\nTargetlist Evaluation\n---------------------\n\nExecBuildProjectionInfo builds an ExprState that has the effect of\nevaluating a targetlist into ExprState->resultslot.  A generic targetlist\nexpression is executed by evaluating it as discussed above (storing the\nresult into the ExprState's resvalue/resnull fields) and then using an\nEEOP_ASSIGN_TMP step to move the result into the appropriate tts_values[]\nand tts_isnull[] array elements of the result slot.  There are special\nfast-path step types (EEOP_ASSIGN_*_VAR) to handle targetlist entries that\nare simple Vars using only one step instead of two.\n\n\nMERGE\n-----\n\nMERGE is a multiple-table, multiple-action command: It specifies a target\ntable and a source relation, and can contain multiple WHEN MATCHED and\nWHEN NOT MATCHED clauses, each of which specifies one UPDATE, INSERT,\nDELETE, or DO NOTHING actions.  The target table is modified by MERGE,\nand the source relation supplies additional data for the actions.  Each action\noptionally specifies a qualifying expression that is evaluated for each tuple.\n\nIn the planner, transform_MERGE_to_join constructs a join between the target\ntable and the source relation, with row-identifying junk columns from the target\ntable.  This join is an outer join if the MERGE command contains any WHEN NOT\nMATCHED clauses; the ModifyTable node fetches tuples from the plan tree of that\njoin.  If the row-identifying columns in the fetched tuple are NULL, then the\nsource relation contains a tuple that is not matched by any tuples in the\ntarget table, so the qualifying expression for each WHEN NOT MATCHED clause is\nevaluated given that tuple as returned by the plan.  If the expression returns\ntrue, the action indicated by the clause is executed, and no further clauses\nare evaluated.  On the other hand, if the row-identifying columns are not\nNULL, then the matching tuple from the target table can be fetched; qualifying\nexpression of each WHEN MATCHED clause is evaluated given both the fetched\ntuple and the tuple returned by the plan.\n\nIf no WHEN NOT MATCHED clauses are present, then the join constructed by\nthe planner is an inner join, and the row-identifying junk columns are\nalways non NULL.\n\nIf WHEN MATCHED ends up processing a row that is concurrently updated or deleted,\nEvalPlanQual (see below) is used to find the latest version of the row, and\nthat is re-fetched; if it exists, the search for a matching WHEN MATCHED clause\nto use starts at the top.\n\nMERGE does not allow its own type of triggers, but instead fires UPDATE, DELETE,\nand INSERT triggers: row triggers are fired for each row when an action is\nexecuted for that row.  Statement triggers are fired always, regardless of\nwhether any rows match the corresponding clauses.\n\n\nMemory Management\n-----------------\n\nA \"per query\" memory context is created during CreateExecutorState();\nall storage allocated during an executor invocation is allocated in that\ncontext or a child context.  This allows easy reclamation of storage\nduring executor shutdown --- rather than messing with retail pfree's and\nprobable storage leaks, we just destroy the memory context.\n\nIn particular, the plan state trees and expression state trees described\nin the previous section are allocated in the per-query memory context.\n\nTo avoid intra-query memory leaks, most processing while a query runs\nis done in \"per tuple\" memory contexts, which are so-called because they\nare typically reset to empty once per tuple.  Per-tuple contexts are usually\nassociated with ExprContexts, and commonly each PlanState node has its own\nExprContext to evaluate its qual and targetlist expressions in.\n\n\nQuery Processing Control Flow\n-----------------------------\n\nThis is a sketch of control flow for full query processing:\n\n\tCreateQueryDesc\n\n\tExecutorStart\n\t\tCreateExecutorState\n\t\t\tcreates per-query context\n\t\tswitch to per-query context to run ExecInitNode\n\t\tAfterTriggerBeginQuery\n\t\tExecInitNode --- recursively scans plan tree\n\t\t\tExecInitNode\n\t\t\t\trecurse into subsidiary nodes\n\t\t\tCreateExprContext\n\t\t\t\tcreates per-tuple context\n\t\t\tExecInitExpr\n\n\tExecutorRun\n\t\tExecProcNode --- recursively called in per-query context\n\t\t\tExecEvalExpr --- called in per-tuple context\n\t\t\tResetExprContext --- to free memory\n\n\tExecutorFinish\n\t\tExecPostprocessPlan --- run any unfinished ModifyTable nodes\n\t\tAfterTriggerEndQuery\n\n\tExecutorEnd\n\t\tExecEndNode --- recursively releases resources\n\t\tFreeExecutorState\n\t\t\tfrees per-query context and child contexts\n\n\tFreeQueryDesc\n\nPer above comments, it's not really critical for ExecEndNode to free any\nmemory; it'll all go away in FreeExecutorState anyway.  However, we do need to\nbe careful to close relations, drop buffer pins, etc, so we do need to scan\nthe plan state tree to find these sorts of resources.\n\n\nThe executor can also be used to evaluate simple expressions without any Plan\ntree (\"simple\" meaning \"no aggregates and no sub-selects\", though such might\nbe hidden inside function calls).  This case has a flow of control like\n\n\tCreateExecutorState\n\t\tcreates per-query context\n\n\tCreateExprContext\t-- or use GetPerTupleExprContext(estate)\n\t\tcreates per-tuple context\n\n\tExecPrepareExpr\n\t\ttemporarily switch to per-query context\n\t\trun the expression through expression_planner\n\t\tExecInitExpr\n\n\tRepeatedly do:\n\t\tExecEvalExprSwitchContext\n\t\t\tExecEvalExpr --- called in per-tuple context\n\t\tResetExprContext --- to free memory\n\n\tFreeExecutorState\n\t\tfrees per-query context, as well as ExprContext\n\t\t(a separate FreeExprContext call is not necessary)\n\n\nEvalPlanQual (READ COMMITTED Update Checking)\n---------------------------------------------\n\nFor simple SELECTs, the executor need only pay attention to tuples that are\nvalid according to the snapshot seen by the current transaction (ie, they\nwere inserted by a previously committed transaction, and not deleted by any\npreviously committed transaction).  However, for UPDATE, DELETE, and MERGE it\nis not cool to modify or delete a tuple that's been modified by an open or\nconcurrently-committed transaction.  If we are running in SERIALIZABLE\nisolation level then we just raise an error when this condition is seen to\noccur.  In READ COMMITTED isolation level, we must work a lot harder.\n\nThe basic idea in READ COMMITTED mode is to take the modified tuple\ncommitted by the concurrent transaction (after waiting for it to commit,\nif need be) and re-evaluate the query qualifications to see if it would\nstill meet the quals.  If so, we regenerate the updated tuple (if we are\ndoing an UPDATE) from the modified tuple, and finally update/delete the\nmodified tuple.  SELECT FOR UPDATE/SHARE behaves similarly, except that its\naction is just to lock the modified tuple and return results based on that\nversion of the tuple.\n\nTo implement this checking, we actually re-run the query from scratch for\neach modified tuple (or set of tuples, for SELECT FOR UPDATE), with the\nrelation scan nodes tweaked to return only the current tuples --- either\nthe original ones, or the updated (and now locked) versions of the modified\ntuple(s).  If this query returns a tuple, then the modified tuple(s) pass\nthe quals (and the query output is the suitably modified update tuple, if\nwe're doing UPDATE).  If no tuple is returned, then the modified tuple(s)\nfail the quals, so we ignore the current result tuple and continue the\noriginal query.\n\nIn UPDATE/DELETE/MERGE, only the target relation needs to be handled this way.\nIn SELECT FOR UPDATE, there may be multiple relations flagged FOR UPDATE,\nso we obtain lock on the current tuple version in each such relation before\nexecuting the recheck.\n\nIt is also possible that there are relations in the query that are not\nto be locked (they are neither the UPDATE/DELETE/MERGE target nor specified\nto be locked in SELECT FOR UPDATE/SHARE).  When re-running the test query\nwe want to use the same rows from these relations that were joined to\nthe locked rows.  For ordinary relations this can be implemented relatively\ncheaply by including the row TID in the join outputs and re-fetching that\nTID.  (The re-fetch is expensive, but we're trying to optimize the normal\ncase where no re-test is needed.)  We have also to consider non-table\nrelations, such as a ValuesScan or FunctionScan.  For these, since there\nis no equivalent of TID, the only practical solution seems to be to include\nthe entire row value in the join output row.\n\nWe disallow set-returning functions in the targetlist of SELECT FOR UPDATE,\nso as to ensure that at most one tuple can be returned for any particular\nset of scan tuples.  Otherwise we'd get duplicates due to the original\nquery returning the same set of scan tuples multiple times.  Likewise,\nSRFs are disallowed in an UPDATE's targetlist.  There, they would have the\neffect of the same row being updated multiple times, which is not very\nuseful --- and updates after the first would have no effect anyway.\n\n\nAsynchronous Execution\n----------------------\n\nIn cases where a node is waiting on an event external to the database system,\nsuch as a ForeignScan awaiting network I/O, it's desirable for the node to\nindicate that it cannot return any tuple immediately but may be able to do so\nat a later time.  A process which discovers this type of situation can always\nhandle it simply by blocking, but this may waste time that could be spent\nexecuting some other part of the plan tree where progress could be made\nimmediately.  This is particularly likely to occur when the plan tree contains\nan Append node.  Asynchronous execution runs multiple parts of an Append node\nconcurrently rather than serially to improve performance.\n\nFor asynchronous execution, an Append node must first request a tuple from an\nasync-capable child node using ExecAsyncRequest.  Next, it must execute the\nasynchronous event loop using ExecAppendAsyncEventWait.  Eventually, when a\nchild node to which an asynchronous request has been made produces a tuple,\nthe Append node will receive it from the event loop via ExecAsyncResponse.  In\nthe current implementation of asynchronous execution, the only node type that\nrequests tuples from an async-capable child node is an Append, while the only\nnode type that might be async-capable is a ForeignScan.\n\nTypically, the ExecAsyncResponse callback is the only one required for nodes\nthat wish to request tuples asynchronously.  On the other hand, async-capable\nnodes generally need to implement three methods:\n\n1. When an asynchronous request is made, the node's ExecAsyncRequest callback\n   will be invoked; it should use ExecAsyncRequestPending to indicate that the\n   request is pending for a callback described below.  Alternatively, it can\n   instead use ExecAsyncRequestDone if a result is available immediately.\n\n2. When the event loop wishes to wait or poll for file descriptor events, the\n   node's ExecAsyncConfigureWait callback will be invoked to configure the\n   file descriptor event for which the node wishes to wait.\n\n3. When the file descriptor becomes ready, the node's ExecAsyncNotify callback\n   will be invoked; like #1, it should use ExecAsyncRequestPending for another\n   callback or ExecAsyncRequestDone to return a result immediately.","count":325},{"name":"subsystem-name","value":"executor","count":325},{"name":"subsystem-path","value":"backend/executor/readme","count":325},{"name":"lines-of-code","value":"74","count":324},{"name":"api-example","value":"<clinit>","count":315},{"name":"api-caller-count","value":"42","count":312},{"name":"api-caller-count","value":"84","count":312},{"name":"cyclomatic-complexity","value":"31","count":312},{"name":"cyclomatic-complexity","value":"28","count":308},{"name":"lines-of-code","value":"70","count":308},{"name":"lines-of-code","value":"78","count":308},{"name":"api-caller-count","value":"28","count":300},{"name":"lines-of-code","value":"72","count":300},{"name":"lines-of-code","value":"80","count":296},{"name":"tested-by","value":"check_hash_func_signature, check_amproc_signature, check_amop_signature, pg_attribute_aclcheck_all_ext, pg_attribute_aclcheck_all_ext, index_check_primary_key, check_object_ownership, check_for_column","count":296},{"name":"api-caller-count","value":"3618","count":292},{"name":"api-caller-count","value":"6188","count":292},{"name":"lines-of-code","value":"71","count":292},{"name":"lines-of-code","value":"75","count":292},{"name":"test-count","value":"166","count":292},{"name":"tested-by","value":"check_hash_func_signature, check_hash_func_signature, check_amproc_signature, check_amop_signature, _bt_check_unique, _bt_check_rowcompare, _bt_check_third_page, spgInnerTest, spgTestLeafTuple, table_","count":292},{"name":"tested-by","value":"index_delete_check_htid, index_delete_check_htid, index_delete_check_htid, lazy_check_wraparound_failsafe, _bt_check_unique, _bt_check_unique, _bt_check_third_page, table_tuple_get_latest_tid, check_d","count":292},{"name":"api-caller-count","value":"40","count":288},{"name":"test-count","value":"10","count":288},{"name":"api-caller-count","value":"633","count":284},{"name":"extensibility","value":"public-api","count":284},{"name":"loop-depth","value":"22","count":284},{"name":"tested-by","value":"check_sql_fn_retval, check_sql_fn_retval, check_sql_fn_retval, make_nulltest_from_distinct, add_with_check_options, add_with_check_options, add_with_check_options","count":284},{"name":"api-typical-usage","value":"Often called from: llvm_compile_expr","count":280},{"name":"lines-of-code","value":"73","count":280},{"name":"api-caller-count","value":"31","count":276},{"name":"tested-by","value":"pq_check_connection","count":276},{"name":"api-caller-count","value":"245","count":272},{"name":"api-caller-count","value":"43","count":272},{"name":"cyclomatic-complexity","value":"33","count":272},{"name":"lines-of-code","value":"68","count":272},{"name":"lines-of-code","value":"76","count":272},{"name":"lines-of-code","value":"82","count":272},{"name":"cyclomatic-complexity","value":"32","count":268},{"name":"api-example","value":"<global>","count":267},{"name":"api-caller-count","value":"352","count":264},{"name":"api-caller-count","value":"39","count":264},{"name":"api-typical-usage","value":"Often called from: _bt_preprocess_keys","count":264},{"name":"tested-by","value":"_bt_check_rowcompare","count":264},{"name":"tested-by","value":"check_sql_fn_retval, check_sql_fn_retval, check_and_push_window_quals, check_mergejoinable, check_hashjoinable, check_memoizable, test_opexpr_is_hashable, check_new_partition_bound, add_with_check_opt","count":264},{"name":"api-caller-count","value":"99","count":260},{"name":"lines-of-code","value":"79","count":260},{"name":"lines-of-code","value":"81","count":260},{"name":"loop-depth","value":"3","count":260},{"name":"test-count","value":"9","count":260},{"name":"api-typical-usage","value":"Often called from: ExecInitPartitionInfo","count":256},{"name":"tested-by","value":"heap_get_latest_tid","count":256},{"name":"api-example","value":"IndexAmRoutine * GetIndexAmRoutine(Oid amhandler) { Datum\t\tdatum; IndexAmRoutine *routine; datum = OidFunctionCall0(amhandler); routine = (IndexAmRoutine *) DatumGetPointer(datum); if (routine == NULL...","count":255},{"name":"api-example","value":"bool brin_doupdate(Relation idxrel, BlockNumber pagesPerRange, BrinRevmap *revmap, BlockNumber heapBlk, Buffer oldbuf, OffsetNumber oldoff, const BrinTuple *origtup, Size origsz, const BrinTuple *newt...","count":255},{"name":"api-example","value":"static FmgrInfo * inclusion_get_strategy_procinfo(BrinDesc *bdesc, uint16 attno, Oid subtype, uint16 strategynum) { InclusionOpaque *opaque; Assert(strategynum >= 1 && strategynum <= RTMaxStrategyNumb...","count":255},{"name":"subsystem-desc","value":"src/backend/snowball/README\n\nSnowball-Based Stemming\n=======================\n\nThis module uses the word stemming code developed by the Snowball project,\nhttp://snowballstem.org (formerly http://snowball.tartarus.org)\nwhich is released by them under a BSD-style license.\n\nThe Snowball project does not often make formal releases; it's best\nto pull from their git repository\n\ngit clone https://github.com/snowballstem/snowball.git\n\nand then building the derived files is as simple as\n\ncd snowball\nmake\n\nAt least on Linux, no platform-specific adjustment is needed.\n\nPostgres' files under src/backend/snowball/libstemmer/ and\nsrc/include/snowball/libstemmer/ are taken directly from the Snowball\nfiles, with only some minor adjustments of file inclusions.  Note\nthat most of these files are in fact derived files, not original source.\nThe original sources are in the Snowball language, and are built using\nthe Snowball-to-C compiler that is also part of the Snowball project.\nWe choose to include the derived files in the PostgreSQL distribution\nbecause most installations will not have the Snowball compiler available.\n\nWe are currently synced with the Snowball git commit\n48a67a2831005f49c48ec29a5837640e23e54e6b (tag v2.2.0)\nof 2021-11-10.\n\nTo update the PostgreSQL sources from a new Snowball version:\n\n0. If you didn't do it already, \"make -C snowball\".\n\n1. Copy the *.c files in snowball/src_c/ to src/backend/snowball/libstemmer\nwith replacement of \"../runtime/header.h\" by \"header.h\", for example\n\nfor f in .../snowball/src_c/*.c\ndo\n    sed 's|\\.\\./runtime/header\\.h|header.h|' $f >libstemmer/`basename $f`\ndone\n\nDo not copy stemmers that are listed in libstemmer/modules.txt as\nnonstandard, such as \"german2\" or \"lovins\".\n\n2. Copy the *.c files in snowball/runtime/ to\nsrc/backend/snowball/libstemmer, and edit them to remove direct inclusions\nof system headers such as <stdio.h> --- they should only include \"header.h\".\n(This removal avoids portability problems on some platforms where <stdio.h>\nis sensitive to largefile compilation options.)\n\n3. Copy the *.h files in snowball/src_c/ and snowball/runtime/\nto src/include/snowball/libstemmer.  At this writing the header files\ndo not require any changes.\n\n4. Check whether any stemmer modules have been added or removed.  If so, edit\nthe OBJS list in Makefile, the list of #include's in dict_snowball.c, and the\nstemmer_modules[] table in dict_snowball.c, as well as the list in the\ndocumentation in textsearch.sgml.  You might also need to change\nthe LANGUAGES list in Makefile and tsearch_config_languages in initdb.c.\n\n5. The various stopword files in stopwords/ must be downloaded\nindividually from pages on the snowballstem.org website.\nBe careful that these files must be stored in UTF-8 encoding.","count":255},{"name":"subsystem-name","value":"snowball","count":255},{"name":"subsystem-path","value":"backend/snowball/readme","count":255},{"name":"api-caller-count","value":"87","count":252},{"name":"lines-of-code","value":"77","count":252},{"name":"api-example","value":"static AclMode string_to_privilege(const char *privname) { if (strcmp(privname, \"insert\") == 0) return ACL_INSERT; if (strcmp(privname, \"select\") == 0) return ACL_SELECT; if (strcmp(privname, \"update\"...","count":249},{"name":"api-example","value":"static void _brin_begin_parallel(BrinBuildState *buildstate, Relation heap, Relation index, bool isconcurrent, int request) { ParallelContext *pcxt; int\t\t\tscantuplesortstates; Snapshot\tsnapshot; Size\t...","count":243},{"name":"api-caller-count","value":"41","count":240},{"name":"api-caller-count","value":"438","count":240},{"name":"api-caller-count","value":"73","count":240},{"name":"test-count","value":"8","count":240},{"name":"api-caller-count","value":"26","count":236},{"name":"api-caller-count","value":"34","count":236},{"name":"cyclomatic-complexity","value":"34","count":236},{"name":"lines-of-code","value":"87","count":236},{"name":"test-count","value":"25","count":236},{"name":"api-caller-count","value":"1729","count":232},{"name":"lines-of-code","value":"85","count":232},{"name":"lines-of-code","value":"88","count":232},{"name":"tested-by","value":"check_default_table_access_method, check_search_path, check_default_tablespace, check_temp_tablespaces, check_temp_tablespaces, check_temp_tablespaces, check_temp_tablespaces, check_role, check_exclus","count":232},{"name":"api-caller-count","value":"274","count":228},{"name":"api-caller-count","value":"44","count":228},{"name":"lines-of-code","value":"89","count":228},{"name":"loop-depth","value":"23","count":228},{"name":"api-caller-count","value":"190","count":224},{"name":"api-typical-usage","value":"Often called from: ExecHashTableCreate","count":224},{"name":"api-example","value":"void CheckPointLogicalRewriteHeap(void) { XLogRecPtr\tcutoff; XLogRecPtr\tredo; DIR\t\t   *mappings_dir; struct dirent *mapping_de; char\t\tpath[MAXPGPATH + 20]; * We start of with a minimum of the last red...","count":222},{"name":"api-caller-count","value":"36","count":220},{"name":"api-typical-usage","value":"Often called from: ExecChooseHashTableSize","count":220},{"name":"api-typical-usage","value":"Often called from: xact_redo","count":220},{"name":"lines-of-code","value":"86","count":220},{"name":"tested-by","value":"check_agg_arguments","count":220},{"name":"api-example","value":"FuncCandidateList FuncnameGetCandidates(List *names, int nargs, List *argnames, bool expand_variadic, bool expand_defaults, bool include_out_arguments, bool missing_ok) { FuncCandidateList resultList ...","count":219},{"name":"api-example","value":"static void lazy_truncate_heap(LVRelState *vacrel) { BlockNumber orig_rel_pages = vacrel->rel_pages; BlockNumber new_rel_pages; bool\t\tlock_waiter_detected; int\t\t\tlock_retry; pgstat_progress_update_par...","count":219},{"name":"api-caller-count","value":"321","count":216},{"name":"api-example","value":"void heap_vacuum_rel(Relation rel, VacuumParams *params, BufferAccessStrategy bstrategy) { LVRelState *vacrel; bool\t\tverbose, instrument, skipwithvm, frozenxid_updated, minmulti_updated; BlockNumber o...","count":216},{"name":"coupling-score","value":"2","count":216},{"name":"cyclomatic-complexity","value":"35","count":216},{"name":"lines-of-code","value":"94","count":216},{"name":"subsystem-desc","value":"src/backend/optimizer/README\n\nOptimizer\n=========\n\nThese directories take the Query structure returned by the parser, and\ngenerate a plan used by the executor.  The /plan directory generates the\nactual output plan, the /path code generates all possible ways to join the\ntables, and /prep handles various preprocessing steps for special cases.\n/util is utility stuff.  /geqo is the separate \"genetic optimization\" planner\n--- it does a semi-random search through the join tree space, rather than\nexhaustively considering all possible join trees.  (But each join considered\nby /geqo is given to /path to create paths for, so we consider all possible\nimplementation paths for each specific join pair even in GEQO mode.)\n\n\nPaths and Join Pairs\n--------------------\n\nDuring the planning/optimizing process, we build \"Path\" trees representing\nthe different ways of doing a query.  We select the cheapest Path that\ngenerates the desired relation and turn it into a Plan to pass to the\nexecutor.  (There is pretty nearly a one-to-one correspondence between the\nPath and Plan trees, but Path nodes omit info that won't be needed during\nplanning, and include info needed for planning that won't be needed by the\nexecutor.)\n\nThe optimizer builds a RelOptInfo structure for each base relation used in\nthe query.  Base rels are either primitive tables, or subquery subselects\nthat are planned via a separate recursive invocation of the planner.  A\nRelOptInfo is also built for each join relation that is considered during\nplanning.  A join rel is simply a combination of base rels.  There is only\none join RelOptInfo for any given set of baserels --- for example, the join\n{A B C} is represented by the same RelOptInfo no matter whether we build it\nby joining A and B first and then adding C, or joining B and C first and\nthen adding A, etc.  These different means of building the joinrel are\nrepresented as Paths.  For each RelOptInfo we build a list of Paths that\nrepresent plausible ways to implement the scan or join of that relation.\nOnce we've considered all the plausible Paths for a rel, we select the one\nthat is cheapest according to the planner's cost estimates.  The final plan\nis derived from the cheapest Path for the RelOptInfo that includes all the\nbase rels of the query.\n\nPossible Paths for a primitive table relation include plain old sequential\nscan, plus index scans for any indexes that exist on the table, plus bitmap\nindex scans using one or more indexes.  Specialized RTE types, such as\nfunction RTEs, may have only one possible Path.\n\nJoins always occur using two RelOptInfos.  One is outer, the other inner.\nOuters drive lookups of values in the inner.  In a nested loop, lookups of\nvalues in the inner occur by scanning the inner path once per outer tuple\nto find each matching inner row.  In a mergejoin, inner and outer rows are\nordered, and are accessed in order, so only one scan is required to perform\nthe entire join: both inner and outer paths are scanned in-sync.  (There's\nnot a lot of difference between inner and outer in a mergejoin...)  In a\nhashjoin, the inner is scanned first and all its rows are entered in a\nhashtable, then the outer is scanned and for each row we lookup the join\nkey in the hashtable.\n\nA Path for a join relation is actually a tree structure, with the topmost\nPath node representing the last-applied join method.  It has left and right\nsubpaths that represent the scan or join methods used for the two input\nrelations.\n\n\nJoin Tree Construction\n----------------------\n\nThe optimizer generates optimal query plans by doing a more-or-less\nexhaustive search through the ways of executing the query.  The best Path\ntree is found by a recursive process:\n\n1) Take each base relation in the query, and make a RelOptInfo structure\nfor it.  Find each potentially useful way of accessing the relation,\nincluding sequential and index scans, and make Paths representing those\nways.  All the Paths made for a given relation are placed in its\nRelOptInfo.pathlist.  (Actually, we discard Paths that are obviously\ninferior alternatives before they ever get into the pathlist --- what\nends up in the pathlist is the cheapest way of generating each potentially\nuseful sort ordering and parameterization of the relation.)  Also create a\nRelOptInfo.joininfo list including all the join clauses that involve this\nrelation.  For example, the WHERE clause \"tab1.col1 = tab2.col1\" generates\nentries in both tab1 and tab2's joininfo lists.\n\nIf we have only a single base relation in the query, we are done.\nOtherwise we have to figure out how to join the base relations into a\nsingle join relation.\n\n2) Normally, any explicit JOIN clauses are \"flattened\" so that we just\nhave a list of relations to join.  However, FULL OUTER JOIN clauses are\nnever flattened, and other kinds of JOIN might not be either, if the\nflattening process is stopped by join_collapse_limit or from_collapse_limit\nrestrictions.  Therefore, we end up with a planning problem that contains\nlists of relations to be joined in any order, where any individual item\nmight be a sub-list that has to be joined together before we can consider\njoining it to its siblings.  We process these sub-problems recursively,\nbottom up.  Note that the join list structure constrains the possible join\norders, but it doesn't constrain the join implementation method at each\njoin (nestloop, merge, hash), nor does it say which rel is considered outer\nor inner at each join.  We consider all these possibilities in building\nPaths. We generate a Path for each feasible join method, and select the\ncheapest Path.\n\nFor each planning problem, therefore, we will have a list of relations\nthat are either base rels or joinrels constructed per sub-join-lists.\nWe can join these rels together in any order the planner sees fit.\nThe standard (non-GEQO) planner does this as follows:\n\nConsider joining each RelOptInfo to each other RelOptInfo for which there\nis a usable joinclause, and generate a Path for each possible join method\nfor each such pair.  (If we have a RelOptInfo with no join clauses, we have\nno choice but to generate a clauseless Cartesian-product join; so we\nconsider joining that rel to each other available rel.  But in the presence\nof join clauses we will only consider joins that use available join\nclauses.  Note that join-order restrictions induced by outer joins and\nIN/EXISTS clauses are also checked, to ensure that we find a workable join\norder in cases where those restrictions force a clauseless join to be done.)\n\nIf we only had two relations in the list, we are done: we just pick\nthe cheapest path for the join RelOptInfo.  If we had more than two, we now\nneed to consider ways of joining join RelOptInfos to each other to make\njoin RelOptInfos that represent more than two list items.\n\nThe join tree is constructed using a \"dynamic programming\" algorithm:\nin the first pass (already described) we consider ways to create join rels\nrepresenting exactly two list items.  The second pass considers ways\nto make join rels that represent exactly three list items; the next pass,\nfour items, etc.  The last pass considers how to make the final join\nrelation that includes all list items --- obviously there can be only one\njoin rel at this top level, whereas there can be more than one join rel\nat lower levels.  At each level we use joins that follow available join\nclauses, if possible, just as described for the first level.\n\nFor example:\n\n    SELECT  *\n    FROM    tab1, tab2, tab3, tab4\n    WHERE   tab1.col = tab2.col AND\n        tab2.col = tab3.col AND\n        tab3.col = tab4.col\n\n    Tables 1, 2, 3, and 4 are joined as:\n    {1 2},{2 3},{3 4}\n    {1 2 3},{2 3 4}\n    {1 2 3 4}\n    (other possibilities will be excluded for lack of join clauses)\n\n    SELECT  *\n    FROM    tab1, tab2, tab3, tab4\n    WHERE   tab1.col = tab2.col AND\n        tab1.col = tab3.col AND\n        tab1.col = tab4.col\n\n    Tables 1, 2, 3, and 4 are joined as:\n    {1 2},{1 3},{1 4}\n    {1 2 3},{1 3 4},{1 2 4}\n    {1 2 3 4}\n\nWe consider left-handed plans (the outer rel of an upper join is a joinrel,\nbut the inner is always a single list item); right-handed plans (outer rel\nis always a single item); and bushy plans (both inner and outer can be\njoins themselves).  For example, when building {1 2 3 4} we consider\njoining {1 2 3} to {4} (left-handed), {4} to {1 2 3} (right-handed), and\n{1 2} to {3 4} (bushy), among other choices.  Although the jointree\nscanning code produces these potential join combinations one at a time,\nall the ways to produce the same set of joined base rels will share the\nsame RelOptInfo, so the paths produced from different join combinations\nthat produce equivalent joinrels will compete in add_path().\n\nThe dynamic-programming approach has an important property that's not\nimmediately obvious: we will finish constructing all paths for a given\nrelation before we construct any paths for relations containing that rel.\nThis means that we can reliably identify the \"cheapest path\" for each rel\nbefore higher-level relations need to know that.  Also, we can safely\ndiscard a path when we find that another path for the same rel is better,\nwithout worrying that maybe there is already a reference to that path in\nsome higher-level join path.  Without this, memory management for paths\nwould be much more complicated.\n\nOnce we have built the final join rel, we use either the cheapest path\nfor it or the cheapest path with the desired ordering (if that's cheaper\nthan applying a sort to the cheapest other path).\n\nIf the query contains one-sided outer joins (LEFT or RIGHT joins), or\nIN or EXISTS WHERE clauses that were converted to semijoins or antijoins,\nthen some of the possible join orders may be illegal.  These are excluded\nby having join_is_legal consult a side list of such \"special\" joins to see\nwhether a proposed join is illegal.  (The same consultation allows it to\nsee which join style should be applied for a valid join, ie, JOIN_INNER,\nJOIN_LEFT, etc.)\n\n\nValid OUTER JOIN Optimizations\n------------------------------\n\nThe planner's treatment of outer join reordering is based on the following\nidentities:\n\n1.\t(A leftjoin B on (Pab)) innerjoin C on (Pac)\n\t= (A innerjoin C on (Pac)) leftjoin B on (Pab)\n\nwhere Pac is a predicate referencing A and C, etc (in this case, clearly\nPac cannot reference B, or the transformation is nonsensical).\n\n2.\t(A leftjoin B on (Pab)) leftjoin C on (Pac)\n\t= (A leftjoin C on (Pac)) leftjoin B on (Pab)\n\n3.\t(A leftjoin B on (Pab)) leftjoin C on (Pbc)\n\t= A leftjoin (B leftjoin C on (Pbc)) on (Pab)\n\nIdentity 3 only holds if predicate Pbc must fail for all-null B rows\n(that is, Pbc is strict for at least one column of B).  If Pbc is not\nstrict, the first form might produce some rows with nonnull C columns\nwhere the second form would make those entries null.\n\nRIGHT JOIN is equivalent to LEFT JOIN after switching the two input\ntables, so the same identities work for right joins.\n\nAn example of a case that does *not* work is moving an innerjoin into or\nout of the nullable side of an outer join:\n\n\tA leftjoin (B join C on (Pbc)) on (Pab)\n\t!= (A leftjoin B on (Pab)) join C on (Pbc)\n\nSEMI joins work a little bit differently.  A semijoin can be reassociated\ninto or out of the lefthand side of another semijoin, left join, or\nantijoin, but not into or out of the righthand side.  Likewise, an inner\njoin, left join, or antijoin can be reassociated into or out of the\nlefthand side of a semijoin, but not into or out of the righthand side.\n\nANTI joins work approximately like LEFT joins, except that identity 3\nfails if the join to C is an antijoin (even if Pbc is strict, and in\nboth the cases where the other join is a leftjoin and where it is an\nantijoin).  So we can't reorder antijoins into or out of the RHS of a\nleftjoin or antijoin, even if the relevant clause is strict.\n\nThe current code does not attempt to re-order FULL JOINs at all.\nFULL JOIN ordering is enforced by not collapsing FULL JOIN nodes when\ntranslating the jointree to \"joinlist\" representation.  Other types of\nJOIN nodes are normally collapsed so that they participate fully in the\njoin order search.  To avoid generating illegal join orders, the planner\ncreates a SpecialJoinInfo node for each non-inner join, and join_is_legal\nchecks this list to decide if a proposed join is legal.\n\nWhat we store in SpecialJoinInfo nodes are the minimum sets of Relids\nrequired on each side of the join to form the outer join.  Note that\nthese are minimums; there's no explicit maximum, since joining other\nrels to the OJ's syntactic rels may be legal.  Per identities 1 and 2,\nnon-FULL joins can be freely associated into the lefthand side of an\nOJ, but in some cases they can't be associated into the righthand side.\nSo the restriction enforced by join_is_legal is that a proposed join\ncan't join a rel within or partly within an RHS boundary to one outside\nthe boundary, unless the proposed join is a LEFT join that can associate\ninto the SpecialJoinInfo's RHS using identity 3.\n\nThe use of minimum Relid sets has some pitfalls; consider a query like\n\tA leftjoin (B leftjoin (C innerjoin D) on (Pbcd)) on Pa\nwhere Pa doesn't mention B/C/D at all.  In this case a naive computation\nwould give the upper leftjoin's min LHS as {A} and min RHS as {C,D} (since\nwe know that the innerjoin can't associate out of the leftjoin's RHS, and\nenforce that by including its relids in the leftjoin's min RHS).  And the\nlower leftjoin has min LHS of {B} and min RHS of {C,D}.  Given such\ninformation, join_is_legal would think it's okay to associate the upper\njoin into the lower join's RHS, transforming the query to\n\tB leftjoin (A leftjoin (C innerjoin D) on Pa) on (Pbcd)\nwhich yields totally wrong answers.  We prevent that by forcing the min RHS\nfor the upper join to include B.  This is perhaps overly restrictive, but\nsuch cases don't arise often so it's not clear that it's worth developing a\nmore complicated system.\n\n\nPulling Up Subqueries\n---------------------\n\nAs we described above, a subquery appearing in the range table is planned\nindependently and treated as a \"black box\" during planning of the outer\nquery.  This is necessary when the subquery uses features such as\naggregates, GROUP, or DISTINCT.  But if the subquery is just a simple\nscan or join, treating the subquery as a black box may produce a poor plan\ncompared to considering it as part of the entire plan search space.\nTherefore, at the start of the planning process the planner looks for\nsimple subqueries and pulls them up into the main query's jointree.\n\nPulling up a subquery may result in FROM-list joins appearing below the top\nof the join tree.  Each FROM-list is planned using the dynamic-programming\nsearch method described above.\n\nIf pulling up a subquery produces a FROM-list as a direct child of another\nFROM-list, then we can merge the two FROM-lists together.  Once that's\ndone, the subquery is an absolutely integral part of the outer query and\nwill not constrain the join tree search space at all.  However, that could\nresult in unpleasant growth of planning time, since the dynamic-programming\nsearch has runtime exponential in the number of FROM-items considered.\nTherefore, we don't merge FROM-lists if the result would have too many\nFROM-items in one list.\n\n\nVars and PlaceHolderVars\n------------------------\n\nA Var node is simply the parse-tree representation of a table column\nreference.  However, in the presence of outer joins, that concept is\nmore subtle than it might seem.  We need to distinguish the values of\na Var \"above\" and \"below\" any outer join that could force the Var to\nnull.  As an example, consider\n\n\tSELECT * FROM t1 LEFT JOIN t2 ON (t1.x = t2.y) WHERE foo(t2.z)\n\n(Assume foo() is not strict, so that we can't reduce the left join to\na plain join.)  A naive implementation might try to push the foo(t2.z)\ncall down to the scan of t2, but that is not correct because\n(a) what foo() should actually see for a null-extended join row is NULL,\nand (b) if foo() returns false, we should suppress the t1 row from the\njoin altogether, not emit it with a null-extended t2 row.  On the other\nhand, it *would* be correct (and desirable) to push that call down to\nthe scan level if the query were\n\n\tSELECT * FROM t1 LEFT JOIN t2 ON (t1.x = t2.y AND foo(t2.z))\n\nThis motivates considering \"t2.z\" within the left join's ON clause\nto be a different value from \"t2.z\" outside the JOIN clause.  The\nformer can be identified with t2.z as seen at the relation scan level,\nbut the latter can't.\n\nAnother example occurs in connection with EquivalenceClasses (discussed\nbelow).  Given\n\n\tSELECT * FROM t1 LEFT JOIN t2 ON (t1.x = t2.y) WHERE t1.x = 42\n\nwe would like to use the EquivalenceClass mechanisms to derive \"t2.y = 42\"\nto use as a restriction clause for the scan of t2.  (That works, because t2\nrows having y different from 42 cannot affect the query result.)  However,\nit'd be wrong to conclude that t2.y will be equal to t1.x in every joined\nrow.  Part of the solution to this problem is to deem that \"t2.y\" in the\nON clause refers to the relation-scan-level value of t2.y, but not to the\nvalue that y will have in joined rows, where it might be NULL rather than\nequal to t1.x.\n\nTherefore, Var nodes are decorated with \"varnullingrels\", which are sets\nof the rangetable indexes of outer joins that potentially null the Var\nat the point where it appears in the query.  (Using a set, not an ordered\nlist, is fine since it doesn't matter which join forced the value to null;\nand that avoids having to change the representation when we consider\ndifferent outer-join orders.)  In the examples above, all occurrences of\nt1.x would have empty varnullingrels, since the left join doesn't null t1.\nThe t2 references within the JOIN ON clauses would also have empty\nvarnullingrels.  But outside the JOIN clauses, any Vars referencing t2\nwould have varnullingrels containing the index of the JOIN's rangetable\nentry (RTE), so that they'd be understood as potentially different from\nthe t2 values seen at scan level.  Labeling t2.z in the WHERE clause with\nthe JOIN's RT index lets us recognize that that occurrence of foo(t2.z)\ncannot be pushed down to the t2 scan level: we cannot evaluate that value\nat the scan level, but only after the join has been done.\n\nFor LEFT and RIGHT outer joins, only Vars coming from the nullable side\nof the join are marked with that join's RT index.  For FULL joins, Vars\nfrom both inputs are marked.  (Such marking doesn't let us tell which\nside of the full join a Var came from; but that information can be found\nelsewhere at need.)\n\nNotionally, a Var having nonempty varnullingrels can be thought of as\n\tCASE WHEN any-of-these-outer-joins-produced-a-null-extended-row\n\t  THEN NULL\n\t  ELSE the-scan-level-value-of-the-column\n\t  END\nIt's only notional, because no such calculation is ever done explicitly.\nIn a finished plan, Vars occurring in scan-level plan nodes represent\nthe actual table column values, but upper-level Vars are always\nreferences to outputs of lower-level plan nodes.  When a join node emits\na null-extended row, it just returns nulls for the relevant output\ncolumns rather than copying up values from its input.  Because we don't\never have to do this calculation explicitly, it's not necessary to\ndistinguish which side of an outer join got null-extended, which'd\notherwise be essential information for FULL JOIN cases.\n\nOuter join identity 3 (discussed above) complicates this picture\na bit.  In the form\n\tA leftjoin (B leftjoin C on (Pbc)) on (Pab)\nall of the Vars in clauses Pbc and Pab will have empty varnullingrels,\nbut if we start with\n\t(A leftjoin B on (Pab)) leftjoin C on (Pbc)\nthen the parser will have marked Pbc's B Vars with the A/B join's\nRT index, making this form artificially different from the first.\nFor discussion's sake, let's denote this marking with a star:\n\t(A leftjoin B on (Pab)) leftjoin C on (Pb*c)\nTo cope with this, once we have detected that commuting these joins\nis legal, we generate both the Pbc and Pb*c forms of that ON clause,\nby either removing or adding the first join's RT index in the B Vars\nthat the parser created.  While generating paths for a plan step that\njoins B and C, we include as a relevant join qual only the form that\nis appropriate depending on whether A has already been joined to B.\n\nIt's also worth noting that identity 3 makes \"the left join's RT index\"\nitself a bit of a fuzzy concept, since the syntactic scope of each join\nRTE will depend on which form was produced by the parser.  We resolve\nthis by considering that a left join's identity is determined by its\nminimum set of right-hand-side input relations.  In both forms allowed\nby identity 3, we can identify the first join as having minimum RHS B\nand the second join as having minimum RHS C.\n\nAnother thing to notice is that C Vars appearing outside the nested\nJOIN clauses will be marked as nulled by both left joins if the\noriginal parser input was in the first form of identity 3, but if the\nparser input was in the second form, such Vars will only be marked as\nnulled by the second join.  This is not really a semantic problem:\nsuch Vars will be marked the same way throughout the upper part of the\nquery, so they will all look equal() which is correct; and they will not\nlook equal() to any C Var appearing in the JOIN ON clause or below these\njoins.  However, when building Vars representing the outputs of join\nrelations, we need to ensure that their varnullingrels are set to\nvalues consistent with the syntactic join order, so that they will\nappear equal() to pre-existing Vars in the upper part of the query.\n\nOuter joins also complicate handling of subquery pull-up.  Consider\n\n\tSELECT ..., ss.x FROM tab1\n\t  LEFT JOIN (SELECT *, 42 AS x FROM tab2) ss ON ...\n\nWe want to be able to pull up the subquery as discussed previously,\nbut we can't just replace the \"ss.x\" Var in the top-level SELECT list\nwith the constant 42.  That'd result in always emitting 42, rather\nthan emitting NULL in null-extended join rows.\n\nTo solve this, we introduce the concept of PlaceHolderVars.\nA PlaceHolderVar is somewhat like a Var, in that its value originates\nat a relation scan level and can then be forced to null by higher-level\nouter joins; hence PlaceHolderVars carry a set of nulling rel IDs just\nlike Vars.  Unlike a Var, whose original value comes from a table,\na PlaceHolderVar's original value is defined by a query-determined\nexpression (\"42\" in this example); so we represent the PlaceHolderVar\nas a node with that expression as child.  We insert a PlaceHolderVar\nwhenever subquery pullup needs to replace a subquery-referencing Var\nthat has nonempty varnullingrels with an expression that is not simply a\nVar.  (When the replacement expression is a pulled-up Var, we can just\nadd the replaced Var's varnullingrels to its set.  Also, if the replaced\nVar has empty varnullingrels, we don't need a PlaceHolderVar: there is\nnothing that'd force the value to null, so the pulled-up expression is\nfine to use as-is.)  In a finished plan, a PlaceHolderVar becomes just\nthe contained expression at whatever plan level it's supposed to be\nevaluated at, and then upper-level occurrences are replaced by Var\nreferences to that output column of the lower plan level.  That causes\nthe value to go to null when appropriate at an outer join, in the same\nway as for normal Vars.  Thus, PlaceHolderVars are never seen outside\nthe planner.\n\nPlaceHolderVars (PHVs) are more complicated than Vars in another way:\ntheir original value might need to be calculated at a join, not a\nbase-level relation scan.  This can happen when a pulled-up subquery\ncontains a join.  Because of this, a PHV can create a join order\nconstraint that wouldn't otherwise exist, to ensure that it can\nbe calculated before it is used.  A PHV's expression can also contain\nLATERAL references, adding complications that are discussed below.\n\n\nRelation Identification and Qual Clause Placement\n-------------------------------------------------\n\nA qual clause obtained from WHERE or JOIN/ON can be enforced at the lowest\nscan or join level that includes all relations used in the clause.  For\nthis purpose we consider that outer joins listed in varnullingrels or\nphnullingrels are used in the clause, since we can't compute the qual's\nresult correctly until we know whether such Vars have gone to null.\n\nThe one exception to this general rule is that a non-degenerate outer\nJOIN/ON qual (one that references the non-nullable side of the join)\ncannot be enforced below that join, even if it doesn't reference the\nnullable side.  Pushing it down into the non-nullable side would result\nin rows disappearing from the join's result, rather than appearing as\nnull-extended rows.  To handle that, when we identify such a qual we\nartificially add the join's minimum input relid set to the set of\nrelations it is considered to use, forcing it to be evaluated exactly at\nthat join level.  The same happens for outer-join quals that mention no\nrelations at all.\n\nWhen attaching a qual clause to a join plan node that is performing an\nouter join, the qual clause is considered a \"join clause\" (that is, it is\napplied before the join performs null-extension) if it does not reference\nthat outer join in any varnullingrels or phnullingrels set, or a \"filter\nclause\" (applied after null-extension) if it does reference that outer\njoin.  A qual clause that originally appeared in that outer join's JOIN/ON\nwill fall into the first category, since the parser would not have marked\nany of its Vars as referencing the outer join.  A qual clause that\noriginally came from some upper ON clause or WHERE clause will be seen as\nreferencing the outer join if it references any of the nullable side's\nVars, since those Vars will be so marked by the parser.  But, if such a\nqual does not reference any nullable-side Vars, it's okay to push it down\ninto the non-nullable side, so it won't get attached to the join node in\nthe first place.\n\nThese things lead us to identify join relations within the planner\nby the sets of base relation RT indexes plus outer join RT indexes\nthat they include.  In that way, the sets of relations used by qual\nclauses can be directly compared to join relations' relid sets to\nsee where to place the clauses.  These identifying sets are unique\nbecause, for any given collection of base relations, there is only\none valid set of outer joins to have performed along the way to\njoining that set of base relations (although the order of applying\nthem could vary, as discussed above).\n\nSEMI joins do not have RT indexes, because they are artifacts made by\nthe planner rather than the parser.  (We could create rangetable\nentries for them, but there seems no need at present.)  This does not\ncause a problem for qual placement, because the nullable side of a\nsemijoin is not referenceable from above the join, so there is never a\nneed to cite it in varnullingrels or phnullingrels.  It does not cause a\nproblem for join relation identification either, since whether a semijoin\nhas been completed is again implicit in the set of base relations\nincluded in the join.\n\nAs usual, outer join identity 3 complicates matters.  If we start with\n\t(A leftjoin B on (Pab)) leftjoin C on (Pbc)\nthen the parser will have marked any C Vars appearing above these joins\nwith the RT index of the B/C join.  If we now transform to\n\tA leftjoin (B leftjoin C on (Pbc)) on (Pab)\nthen it would appear that a clause using only such Vars could be pushed\ndown and applied as a filter clause (not a join clause) at the lower\nB/C join.  But *this might not give the right answer* since the clause\nmight see a non-null value for the C Var that will be replaced by null\nonce the A/B join is performed.  We handle this by saying that the\npushed-down join hasn't completely performed the work of the B/C join\nand hence is not entitled to include that outer join relid in its\nrelid set.  When we form the A/B join, both outer joins' relids will\nbe added to its relid set, and then the upper clause will be applied\nat the correct join level.  (Note there is no problem when identity 3\nis applied in the other direction: if we started with the second form\nthen upper C Vars are marked with both outer join relids, so they\ncannot drop below whichever join is applied second.)  Similarly,\nVars representing the output of a pushed-down join do not acquire\nnullingrel bits for that join until after the upper join is performed.\n\nThere is one additional complication for qual clause placement, which\noccurs when we have made multiple versions of an outer-join clause as\ndescribed previously (that is, we have both \"Pbc\" and \"Pb*c\" forms of\nthe same clause seen in outer join identity 3).  When forming an outer\njoin we only want to apply one of the redundant versions of the clause.\nIf we are forming the B/C join without having yet computed the A/B\njoin, it's easy to reject the \"Pb*c\" form since its required relid\nset includes the A/B join relid which is not in the input.  However,\nif we form B/C after A/B, then both forms of the clause are applicable\nso far as that test can tell.  We have to look more closely to notice\nthat the \"Pbc\" clause form refers to relation B which is no longer\ndirectly accessible.  While such a check could be performed using the\nper-relation RelOptInfo.nulling_relids data, it would be annoyingly\nexpensive to do over and over as we consider different join paths.\nTo make this simple and reliable, we compute an \"incompatible_relids\"\nset for each variant version (clone) of a redundant clause.  A clone\nclause should not be applied if any of the outer-join relids listed in\nincompatible_relids has already been computed below the current join.\n\n\nOptimizer Functions\n-------------------\n\nThe primary entry point is planner().\n\nplanner()\nset up for recursive handling of subqueries\n-subquery_planner()\n pull up sublinks and subqueries from rangetable, if possible\n canonicalize qual\n     Attempt to simplify WHERE clause to the most useful form; this includes\n     flattening nested AND/ORs and detecting clauses that are duplicated in\n     different branches of an OR.\n simplify constant expressions\n process sublinks\n convert Vars of outer query levels into Params\n--grouping_planner()\n  preprocess target list for non-SELECT queries\n  handle UNION/INTERSECT/EXCEPT, GROUP BY, HAVING, aggregates,\n\tORDER BY, DISTINCT, LIMIT\n---query_planner()\n   make list of base relations used in query\n   split up the qual into restrictions (a=1) and joins (b=c)\n   find qual clauses that enable merge and hash joins\n----make_one_rel()\n     set_base_rel_pathlists()\n      find seqscan and all index paths for each base relation\n      find selectivity of columns used in joins\n     make_rel_from_joinlist()\n      hand off join subproblems to a plugin, GEQO, or standard_join_search()\n------standard_join_search()\n      call join_search_one_level() for each level of join tree needed\n      join_search_one_level():\n        For each joinrel of the prior level, do make_rels_by_clause_joins()\n        if it has join clauses, or make_rels_by_clauseless_joins() if not.\n        Also generate \"bushy plan\" joins between joinrels of lower levels.\n      Back at standard_join_search(), generate gather paths if needed for\n      each newly constructed joinrel, then apply set_cheapest() to extract\n      the cheapest path for it.\n      Loop back if this wasn't the top join level.\n  Back at grouping_planner:\n  do grouping (GROUP BY) and aggregation\n  do window functions\n  make unique (DISTINCT)\n  do sorting (ORDER BY)\n  do limit (LIMIT/OFFSET)\nBack at planner():\nconvert finished Path tree into a Plan tree\ndo final cleanup after planning\n\n\nOptimizer Data Structures\n-------------------------\n\nPlannerGlobal   - global information for a single planner invocation\n\nPlannerInfo     - information for planning a particular Query (we make\n                  a separate PlannerInfo node for each sub-Query)\n\nRelOptInfo      - a relation or joined relations\n\n RestrictInfo   - WHERE clauses, like \"x = 3\" or \"y = z\"\n                  (note the same structure is used for restriction and\n                   join clauses)\n\n Path           - every way to generate a RelOptInfo(sequential,index,joins)\n  A plain Path node can represent several simple plans, per its pathtype:\n    T_SeqScan   - sequential scan\n    T_SampleScan - tablesample scan\n    T_FunctionScan - function-in-FROM scan\n    T_TableFuncScan - table function scan\n    T_ValuesScan - VALUES scan\n    T_CteScan   - CTE (WITH) scan\n    T_NamedTuplestoreScan - ENR scan\n    T_WorkTableScan - scan worktable of a recursive CTE\n    T_Result    - childless Result plan node (used for FROM-less SELECT)\n  IndexPath     - index scan\n  BitmapHeapPath - top of a bitmapped index scan\n  TidPath       - scan by CTID\n  TidRangePath  - scan a contiguous range of CTIDs\n  SubqueryScanPath - scan a subquery-in-FROM\n  ForeignPath   - scan a foreign table, foreign join or foreign upper-relation\n  CustomPath    - for custom scan providers\n  AppendPath    - append multiple subpaths together\n  MergeAppendPath - merge multiple subpaths, preserving their common sort order\n  GroupResultPath - childless Result plan node (used for degenerate grouping)\n  MaterialPath  - a Material plan node\n  MemoizePath   - a Memoize plan node for caching tuples from sub-paths\n  UniquePath    - remove duplicate rows (either by hashing or sorting)\n  GatherPath    - collect the results of parallel workers\n  GatherMergePath - collect parallel results, preserving their common sort order\n  ProjectionPath - a Result plan node with child (used for projection)\n  ProjectSetPath - a ProjectSet plan node applied to some sub-path\n  SortPath      - a Sort plan node applied to some sub-path\n  IncrementalSortPath - an IncrementalSort plan node applied to some sub-path\n  GroupPath     - a Group plan node applied to some sub-path\n  UpperUniquePath - a Unique plan node applied to some sub-path\n  AggPath       - an Agg plan node applied to some sub-path\n  GroupingSetsPath - an Agg plan node used to implement GROUPING SETS\n  MinMaxAggPath - a Result plan node with subplans performing MIN/MAX\n  WindowAggPath - a WindowAgg plan node applied to some sub-path\n  SetOpPath     - a SetOp plan node applied to some sub-path\n  RecursiveUnionPath - a RecursiveUnion plan node applied to two sub-paths\n  LockRowsPath  - a LockRows plan node applied to some sub-path\n  ModifyTablePath - a ModifyTable plan node applied to some sub-path(s)\n  LimitPath     - a Limit plan node applied to some sub-path\n  NestPath      - nested-loop joins\n  MergePath     - merge joins\n  HashPath      - hash joins\n\n EquivalenceClass - a data structure representing a set of values known equal\n\n PathKey        - a data structure representing the sort ordering of a path\n\nThe optimizer spends a good deal of its time worrying about the ordering\nof the tuples returned by a path.  The reason this is useful is that by\nknowing the sort ordering of a path, we may be able to use that path as\nthe left or right input of a mergejoin and avoid an explicit sort step.\nNestloops and hash joins don't really care what the order of their inputs\nis, but mergejoin needs suitably ordered inputs.  Therefore, all paths\ngenerated during the optimization process are marked with their sort order\n(to the extent that it is known) for possible use by a higher-level merge.\n\nIt is also possible to avoid an explicit sort step to implement a user's\nORDER BY clause if the final path has the right ordering already, so the\nsort ordering is of interest even at the top level.  grouping_planner() will\nlook for the cheapest path with a sort order matching the desired order,\nthen compare its cost to the cost of using the cheapest-overall path and\ndoing an explicit sort on that.\n\nWhen we are generating paths for a particular RelOptInfo, we discard a path\nif it is more expensive than another known path that has the same or better\nsort order.  We will never discard a path that is the only known way to\nachieve a given sort order (without an explicit sort, that is).  In this\nway, the next level up will have the maximum freedom to build mergejoins\nwithout sorting, since it can pick from any of the paths retained for its\ninputs.\n\n\nEquivalenceClasses\n------------------\n\nDuring the deconstruct_jointree() scan of the query's qual clauses, we\nlook for mergejoinable equality clauses A = B.  When we find one, we\ncreate an EquivalenceClass containing the expressions A and B to record\nthat they are equal.  If we later find another equivalence clause B = C,\nwe add C to the existing EquivalenceClass for {A B}; this may require\nmerging two existing EquivalenceClasses.  At the end of the scan, we have\nsets of values that are known all transitively equal to each other.  We can\ntherefore use a comparison of any pair of the values as a restriction or\njoin clause (when these values are available at the scan or join, of\ncourse); furthermore, we need test only one such comparison, not all of\nthem.  Therefore, equivalence clauses are removed from the standard qual\ndistribution process.  Instead, when preparing a restriction or join clause\nlist, we examine each EquivalenceClass to see if it can contribute a\nclause, and if so we select an appropriate pair of values to compare.  For\nexample, if we are trying to join A's relation to C's, we can generate the\nclause A = C, even though this appeared nowhere explicitly in the original\nquery.  This may allow us to explore join paths that otherwise would have\nbeen rejected as requiring Cartesian-product joins.\n\nSometimes an EquivalenceClass may contain a pseudo-constant expression\n(i.e., one not containing Vars or Aggs of the current query level, nor\nvolatile functions).  In this case we do not follow the policy of\ndynamically generating join clauses: instead, we dynamically generate\nrestriction clauses \"var = const\" wherever one of the variable members of\nthe class can first be computed.  For example, if we have A = B and B = 42,\nwe effectively generate the restriction clauses A = 42 and B = 42, and then\nwe need not bother with explicitly testing the join clause A = B when the\nrelations are joined.  In effect, all the class members can be tested at\nrelation-scan level and there's never a need for join tests.\n\nThe precise technical interpretation of an EquivalenceClass is that it\nasserts that at any plan node where more than one of its member values\ncan be computed, output rows in which the values are not all equal may\nbe discarded without affecting the query result.  (We require all levels\nof the plan to enforce EquivalenceClasses, hence a join need not recheck\nequality of values that were computable by one of its children.)\n\nOuter joins complicate this picture quite a bit, however.  While we could\ntheoretically use mergejoinable equality clauses that appear in outer-join\nconditions as sources of EquivalenceClasses, there's a serious difficulty:\nthe resulting deductions are not valid everywhere.  For example, given\n\n\tSELECT * FROM a LEFT JOIN b ON (a.x = b.y AND a.x = 42);\n\nwe can safely derive b.y = 42 and use that in the scan of B, because B\nrows not having b.y = 42 will not contribute to the join result.  However,\nwe cannot apply a.x = 42 at the scan of A, or we will remove rows that\nshould appear in the join result.  We could apply a.x = 42 as an outer join\ncondition (and then it would be unnecessary to also check a.x = b.y).\nThis is not yet implemented, however.\n\nA related issue is that constants appearing below an outer join are\nless constant than they appear.  Ordinarily, if we find \"A = 1\" and\n\"B = 1\", it's okay to put A and B into the same EquivalenceClass.\nBut consider\n\n\tSELECT * FROM a\n\t  LEFT JOIN (SELECT * FROM b WHERE b.z = 1) b ON (a.x = b.y)\n\tWHERE a.x = 1;\n\nIt would be a serious error to conclude that a.x = b.z, so we cannot\nform a single EquivalenceClass {a.x b.z 1}.\n\nThis leads to considering EquivalenceClasses as applying within \"join\ndomains\", which are sets of relations that are inner-joined to each other.\n(We can treat semijoins as if they were inner joins for this purpose.)\nThere is a top-level join domain, and then each outer join in the query\ncreates a new join domain comprising its nullable side.  Full joins create\ntwo join domains, one for each side.  EquivalenceClasses generated from\nWHERE are associated with the top-level join domain.  EquivalenceClasses\ngenerated from the ON clause of an outer join are associated with the\ndomain created by that outer join.  EquivalenceClasses generated from the\nON clause of an inner or semi join are associated with the syntactically\nmost closely nested join domain.\n\nHaving defined these domains, we can fix the not-so-constant-constants\nproblem by considering that constants only match EquivalenceClass members\nwhen they come from clauses within the same join domain.  In the above\nexample, this means we keep {a.x 1} and {b.z 1} as separate\nEquivalenceClasses and don't erroneously merge them.  We don't have to\nworry about this for Vars (or expressions containing Vars), because\nreferences to the \"same\" column from different join domains will have\ndifferent varnullingrels and thus won't be equal() anyway.\n\nIn the future, the join-domain concept may allow us to treat mergejoinable\nouter-join conditions as sources of EquivalenceClasses.  The idea would be\nthat conditions derived from such classes could only be enforced at scans\nor joins that are within the appropriate join domain.  This is not\nimplemented yet, however, as the details are trickier than they appear.\n\nAnother instructive example is:\n\n\tSELECT *\n\t  FROM a LEFT JOIN\n\t       (SELECT * FROM b JOIN c ON b.y = c.z WHERE b.y = 10) ss\n\t       ON a.x = ss.y\n\t  ORDER BY ss.y;\n\nWe can form the EquivalenceClass {b.y c.z 10} and thereby apply c.z = 10\nwhile scanning C, as well as b.y = 10 while scanning B, so that no clause\nneeds to be checked at the inner join.  The left-join clause \"a.x = ss.y\"\n(really \"a.x = b.y\") is not considered an equivalence clause, so we do\nnot insert a.x into that same EquivalenceClass; if we did, we'd falsely\nconclude a.x = 10.  In the future though we might be able to do that,\nif we can keep from applying a.x = 10 at the scan of A, which in principle\nwe could do by noting that the EquivalenceClass only applies within the\n{B,C} join domain.\n\nAlso notice that ss.y in the ORDER BY is really b.y* (that is, the\npossibly-nulled form of b.y), so we will not confuse it with the b.y member\nof the lower EquivalenceClass.  Thus, we won't mistakenly conclude that\nthat ss.y is equal to a constant, which if true would lead us to think that\nsorting for the ORDER BY is unnecessary (see discussion of PathKeys below).\nInstead, there will be a separate EquivalenceClass containing only b.y*,\nwhich will form the basis for the PathKey describing the required sort\norder.\n\nAlso consider this variant:\n\n\tSELECT *\n\t  FROM a LEFT JOIN\n\t       (SELECT * FROM b JOIN c ON b.y = c.z WHERE b.y = 10) ss\n\t       ON a.x = ss.y\n\t  WHERE a.x = 42;\n\nWe still form the EquivalenceClass {b.y c.z 10}, and additionally\nwe have an EquivalenceClass {a.x 42} belonging to a different join domain.\nWe cannot use \"a.x = b.y\" to merge these classes.  However, we can compare\nthat outer join clause to the existing EquivalenceClasses and form the\nderived clause \"b.y = 42\", which we can treat as a valid equivalence\nwithin the lower join domain (since no row of that domain not having\nb.y = 42 can contribute to the outer-join result).  That makes the lower\nEquivalenceClass {42 b.y c.z 10}, resulting in the contradiction 10 = 42,\nwhich lets the planner deduce that the B/C join need not be computed at\nall: the result of that whole join domain can be forced to empty.\n(This gets implemented as a gating Result filter, since more usually the\npotential contradiction involves Param values rather than just Consts, and\nthus it has to be checked at runtime.  We can use the join domain to\ndetermine the join level at which to place the gating condition.)\n\nThere is an additional complication when re-ordering outer joins according\nto identity 3.  Recall that the two choices we consider for such joins are\n\n\tA leftjoin (B leftjoin C on (Pbc)) on (Pab)\n\t(A leftjoin B on (Pab)) leftjoin C on (Pb*c)\n\nwhere the star denotes varnullingrels markers on B's Vars.  When Pbc\nis (or includes) a mergejoinable clause, we have something like\n\n\tA leftjoin (B leftjoin C on (b.b = c.c)) on (Pab)\n\t(A leftjoin B on (Pab)) leftjoin C on (b.b* = c.c)\n\nWe could generate an EquivalenceClause linking b.b and c.c, but if we\nthen also try to link b.b* and c.c, we end with a nonsensical conclusion\nthat b.b and b.b* are equal (at least in some parts of the plan tree).\nIn any case, the conclusions we could derive from such a thing would be\nlargely duplicative.  Conditions involving b.b* can't be computed below\nthis join nest, while any conditions that can be computed would be\nduplicative of what we'd get from the b.b/c.c combination.  Therefore,\nwe choose to generate an EquivalenceClause linking b.b and c.c, but\n\"b.b* = c.c\" is handled as just an ordinary clause.\n\nTo aid in determining the sort ordering(s) that can work with a mergejoin,\nwe mark each mergejoinable clause with the EquivalenceClasses of its left\nand right inputs.  For an equivalence clause, these are of course the same\nEquivalenceClass.  For a non-equivalence mergejoinable clause (such as an\nouter-join qualification), we generate two separate EquivalenceClasses for\nthe left and right inputs.  This may result in creating single-item\nequivalence \"classes\", though of course these are still subject to merging\nif other equivalence clauses are later found to bear on the same\nexpressions.\n\nAnother way that we may form a single-item EquivalenceClass is in creation\nof a PathKey to represent a desired sort order (see below).  This happens\nif an ORDER BY or GROUP BY key is not mentioned in any equivalence\nclause.  We need to reason about sort orders in such queries, and our\nrepresentation of sort ordering is a PathKey which depends on an\nEquivalenceClass, so we have to make an EquivalenceClass.  This is a bit\ndifferent from the above cases because such an EquivalenceClass might\ncontain an aggregate function or volatile expression.  (A clause containing\na volatile function will never be considered mergejoinable, even if its top\noperator is mergejoinable, so there is no way for a volatile expression to\nget into EquivalenceClasses otherwise.  Aggregates are disallowed in WHERE\naltogether, so will never be found in a mergejoinable clause.)  This is just\na convenience to maintain a uniform PathKey representation: such an\nEquivalenceClass will never be merged with any other.  Note in particular\nthat a single-item EquivalenceClass {a.x} is *not* meant to imply an\nassertion that a.x = a.x; the practical effect of this is that a.x could\nbe NULL.\n\nAn EquivalenceClass also contains a list of btree opfamily OIDs, which\ndetermines what the equalities it represents actually \"mean\".  All the\nequivalence clauses that contribute to an EquivalenceClass must have\nequality operators that belong to the same set of opfamilies.  (Note: most\nof the time, a particular equality operator belongs to only one family, but\nit's possible that it belongs to more than one.  We keep track of all the\nfamilies to ensure that we can make use of an index belonging to any one of\nthe families for mergejoin purposes.)\n\nFor the same sort of reason, an EquivalenceClass is also associated\nwith a particular collation, if its datatype(s) care about collation.\n\nAn EquivalenceClass can contain \"em_is_child\" members, which are copies\nof members that contain appendrel parent relation Vars, transposed to\ncontain the equivalent child-relation variables or expressions.  These\nmembers are *not* full-fledged members of the EquivalenceClass and do not\naffect the class's overall properties at all.  They are kept only to\nsimplify matching of child-relation expressions to EquivalenceClasses.\nMost operations on EquivalenceClasses should ignore child members.\n\n\nPathKeys\n--------\n\nThe PathKeys data structure represents what is known about the sort order\nof the tuples generated by a particular Path.  A path's pathkeys field is a\nlist of PathKey nodes, where the n'th item represents the n'th sort key of\nthe result.  Each PathKey contains these fields:\n\n\t* a reference to an EquivalenceClass\n\t* a btree opfamily OID (must match one of those in the EC)\n\t* a sort direction (ascending or descending)\n\t* a nulls-first-or-last flag\n\nThe EquivalenceClass represents the value being sorted on.  Since the\nvarious members of an EquivalenceClass are known equal according to the\nopfamily, we can consider a path sorted by any one of them to be sorted by\nany other too; this is what justifies referencing the whole\nEquivalenceClass rather than just one member of it.\n\nIn single/base relation RelOptInfo's, the Paths represent various ways\nof scanning the relation and the resulting ordering of the tuples.\nSequential scan Paths have NIL pathkeys, indicating no known ordering.\nIndex scans have Path.pathkeys that represent the chosen index's ordering,\nif any.  A single-key index would create a single-PathKey list, while a\nmulti-column index generates a list with one element per key index column.\nNon-key columns specified in the INCLUDE clause of covering indexes don't\nhave corresponding PathKeys in the list, because they have no influence on\nindex ordering.  (Actually, since an index can be scanned either forward or\nbackward, there are two possible sort orders and two possible PathKey lists\nit can generate.)\n\nNote that a bitmap scan has NIL pathkeys since we can say nothing about\nthe overall order of its result.  Also, an indexscan on an unordered type\nof index generates NIL pathkeys.  However, we can always create a pathkey\nby doing an explicit sort.  The pathkeys for a Sort plan's output just\nrepresent the sort key fields and the ordering operators used.\n\nThings get more interesting when we consider joins.  Suppose we do a\nmergejoin between A and B using the mergeclause A.X = B.Y.  The output\nof the mergejoin is sorted by X --- but it is also sorted by Y.  Again,\nthis can be represented by a PathKey referencing an EquivalenceClass\ncontaining both X and Y.\n\nWith a little further thought, it becomes apparent that nestloop joins\ncan also produce sorted output.  For example, if we do a nestloop join\nbetween outer relation A and inner relation B, then any pathkeys relevant\nto A are still valid for the join result: we have not altered the order of\nthe tuples from A.  Even more interesting, if there was an equivalence clause\nA.X=B.Y, and A.X was a pathkey for the outer relation A, then we can assert\nthat B.Y is a pathkey for the join result; X was ordered before and still\nis, and the joined values of Y are equal to the joined values of X, so Y\nmust now be ordered too.  This is true even though we used neither an\nexplicit sort nor a mergejoin on Y.  (Note: hash joins cannot be counted\non to preserve the order of their outer relation, because the executor\nmight decide to \"batch\" the join, so we always set pathkeys to NIL for\na hashjoin path.)\n\nAn outer join doesn't preserve the ordering of its nullable input\nrelation(s), because it might insert nulls at random points in the\nordering.  We don't need to think about this explicitly in the PathKey\nrepresentation, because a PathKey representing a post-join variable\nwill contain varnullingrel bits, making it not equal to a PathKey\nrepresenting the pre-join value.\n\nIn general, we can justify using EquivalenceClasses as the basis for\npathkeys because, whenever we scan a relation containing multiple\nEquivalenceClass members or join two relations each containing\nEquivalenceClass members, we apply restriction or join clauses derived from\nthe EquivalenceClass.  This guarantees that any two values listed in the\nEquivalenceClass are in fact equal in all tuples emitted by the scan or\njoin, and therefore that if the tuples are sorted by one of the values,\nthey can be considered sorted by any other as well.  It does not matter\nwhether the test clause is used as a mergeclause, or merely enforced\nafter-the-fact as a qpqual filter.\n\nNote that there is no particular difficulty in labeling a path's sort\norder with a PathKey referencing an EquivalenceClass that contains\nvariables not yet joined into the path's output.  We can simply ignore\nsuch entries as not being relevant (yet).  This makes it possible to\nuse the same EquivalenceClasses throughout the join planning process.\nIn fact, by being careful not to generate multiple identical PathKey\nobjects, we can reduce comparison of EquivalenceClasses and PathKeys\nto simple pointer comparison, which is a huge savings because add_path\nhas to make a large number of PathKey comparisons in deciding whether\ncompeting Paths are equivalently sorted.\n\nPathkeys are also useful to represent an ordering that we wish to achieve,\nsince they are easily compared to the pathkeys of a potential candidate\npath.  So, SortGroupClause lists are turned into pathkeys lists for use\ninside the optimizer.\n\nAn additional refinement we can make is to insist that canonical pathkey\nlists (sort orderings) do not mention the same EquivalenceClass more than\nonce.  For example, in all these cases the second sort column is redundant,\nbecause it cannot distinguish values that are the same according to the\nfirst sort column:\n\tSELECT ... ORDER BY x, x\n\tSELECT ... ORDER BY x, x DESC\n\tSELECT ... WHERE x = y ORDER BY x, y\nAlthough a user probably wouldn't write \"ORDER BY x,x\" directly, such\nredundancies are more probable once equivalence classes have been\nconsidered.  Also, the system may generate redundant pathkey lists when\ncomputing the sort ordering needed for a mergejoin.  By eliminating the\nredundancy, we save time and improve planning, since the planner will more\neasily recognize equivalent orderings as being equivalent.\n\nAnother interesting property is that if the underlying EquivalenceClass\ncontains a constant, then the pathkey is completely redundant and need not\nbe sorted by at all!  Every interesting row must contain the same value,\nso there's no need to sort.  This might seem pointless because users\nare unlikely to write \"... WHERE x = 42 ORDER BY x\", but it allows us to\nrecognize when particular index columns are irrelevant to the sort order:\nif we have \"... WHERE x = 42 ORDER BY y\", scanning an index on (x,y)\nproduces correctly ordered data without a sort step.  We used to have very\nugly ad-hoc code to recognize that in limited contexts, but discarding\nconstant ECs from pathkeys makes it happen cleanly and automatically.\n\n\nOrder of processing for EquivalenceClasses and PathKeys\n-------------------------------------------------------\n\nAs alluded to above, there is a specific sequence of phases in the\nprocessing of EquivalenceClasses and PathKeys during planning.  During the\ninitial scanning of the query's quals (deconstruct_jointree followed by\nreconsider_outer_join_clauses), we construct EquivalenceClasses based on\nmergejoinable clauses found in the quals.  At the end of this process,\nwe know all we can know about equivalence of different variables, so\nsubsequently there will be no further merging of EquivalenceClasses.\nAt that point it is possible to consider the EquivalenceClasses as\n\"canonical\" and build canonical PathKeys that reference them.  At this\ntime we construct PathKeys for the query's ORDER BY and related clauses.\n(Any ordering expressions that do not appear elsewhere will result in\nthe creation of new EquivalenceClasses, but this cannot result in merging\nexisting classes, so canonical-ness is not lost.)\n\nBecause all the EquivalenceClasses are known before we begin path\ngeneration, we can use them as a guide to which indexes are of interest:\nif an index's column is not mentioned in any EquivalenceClass then that\nindex's sort order cannot possibly be helpful for the query.  This allows\nshort-circuiting of much of the processing of create_index_paths() for\nirrelevant indexes.\n\nThere are some cases where planner.c constructs additional\nEquivalenceClasses and PathKeys after query_planner has completed.\nIn these cases, the extra ECs/PKs are needed to represent sort orders\nthat were not considered during query_planner.  Such situations should be\nminimized since it is impossible for query_planner to return a plan\nproducing such a sort order, meaning an explicit sort will always be needed.\nCurrently this happens only for queries involving multiple window functions\nwith different orderings, for which extra sorts are needed anyway.\n\n\nParameterized Paths\n-------------------\n\nThe naive way to join two relations using a clause like WHERE A.X = B.Y\nis to generate a nestloop plan like this:\n\n\tNestLoop\n\t\tFilter: A.X = B.Y\n\t\t-> Seq Scan on A\n\t\t-> Seq Scan on B\n\nWe can make this better by using a merge or hash join, but it still\nrequires scanning all of both input relations.  If A is very small and B is\nvery large, but there is an index on B.Y, it can be enormously better to do\nsomething like this:\n\n\tNestLoop\n\t\t-> Seq Scan on A\n\t\t-> Index Scan using B_Y_IDX on B\n\t\t\tIndex Condition: B.Y = A.X\n\nHere, we are expecting that for each row scanned from A, the nestloop\nplan node will pass down the current value of A.X into the scan of B.\nThat allows the indexscan to treat A.X as a constant for any one\ninvocation, and thereby use it as an index key.  This is the only plan type\nthat can avoid fetching all of B, and for small numbers of rows coming from\nA, that will dominate every other consideration.  (As A gets larger, this\ngets less attractive, and eventually a merge or hash join will win instead.\nSo we have to cost out all the alternatives to decide what to do.)\n\nIt can be useful for the parameter value to be passed down through\nintermediate layers of joins, for example:\n\n\tNestLoop\n\t\t-> Seq Scan on A\n\t\tHash Join\n\t\t\tJoin Condition: B.Y = C.W\n\t\t\t-> Seq Scan on B\n\t\t\t-> Index Scan using C_Z_IDX on C\n\t\t\t\tIndex Condition: C.Z = A.X\n\nIf all joins are plain inner joins then this is usually unnecessary,\nbecause it's possible to reorder the joins so that a parameter is used\nimmediately below the nestloop node that provides it.  But in the\npresence of outer joins, such join reordering may not be possible.\n\nAlso, the bottom-level scan might require parameters from more than one\nother relation.  In principle we could join the other relations first\nso that all the parameters are supplied from a single nestloop level.\nBut if those other relations have no join clause in common (which is\ncommon in star-schema queries for instance), the planner won't consider\njoining them directly to each other.  In such a case we need to be able\nto create a plan like\n\n    NestLoop\n        -> Seq Scan on SmallTable1 A\n        NestLoop\n            -> Seq Scan on SmallTable2 B\n            -> Index Scan using XYIndex on LargeTable C\n                 Index Condition: C.X = A.AID and C.Y = B.BID\n\nso we should be willing to pass down A.AID through a join even though\nthere is no join order constraint forcing the plan to look like this.\n\nBefore version 9.2, Postgres used ad-hoc methods for planning and\nexecuting nestloop queries of this kind, and those methods could not\nhandle passing parameters down through multiple join levels.\n\nTo plan such queries, we now use a notion of a \"parameterized path\",\nwhich is a path that makes use of a join clause to a relation that's not\nscanned by the path.  In the example two above, we would construct a\npath representing the possibility of doing this:\n\n\t-> Index Scan using C_Z_IDX on C\n\t\tIndex Condition: C.Z = A.X\n\nThis path will be marked as being parameterized by relation A.  (Note that\nthis is only one of the possible access paths for C; we'd still have a\nplain unparameterized seqscan, and perhaps other possibilities.)  The\nparameterization marker does not prevent joining the path to B, so one of\nthe paths generated for the joinrel {B C} will represent\n\n\tHash Join\n\t\tJoin Condition: B.Y = C.W\n\t\t-> Seq Scan on B\n\t\t-> Index Scan using C_Z_IDX on C\n\t\t\tIndex Condition: C.Z = A.X\n\nThis path is still marked as being parameterized by A.  When we attempt to\njoin {B C} to A to form the complete join tree, such a path can only be\nused as the inner side of a nestloop join: it will be ignored for other\npossible join types.  So we will form a join path representing the query\nplan shown above, and it will compete in the usual way with paths built\nfrom non-parameterized scans.\n\nWhile all ordinary paths for a particular relation generate the same set\nof rows (since they must all apply the same set of restriction clauses),\nparameterized paths typically generate fewer rows than less-parameterized\npaths, since they have additional clauses to work with.  This means we\nmust consider the number of rows generated as an additional figure of\nmerit.  A path that costs more than another, but generates fewer rows,\nmust be kept since the smaller number of rows might save work at some\nintermediate join level.  (It would not save anything if joined\nimmediately to the source of the parameters.)\n\nTo keep cost estimation rules relatively simple, we make an implementation\nrestriction that all paths for a given relation of the same parameterization\n(i.e., the same set of outer relations supplying parameters) must have the\nsame rowcount estimate.  This is justified by insisting that each such path\napply *all* join clauses that are available with the named outer relations.\nDifferent paths might, for instance, choose different join clauses to use\nas index clauses; but they must then apply any other join clauses available\nfrom the same outer relations as filter conditions, so that the set of rows\nreturned is held constant.  This restriction doesn't degrade the quality of\nthe finished plan: it amounts to saying that we should always push down\nmovable join clauses to the lowest possible evaluation level, which is a\ngood thing anyway.  The restriction is useful in particular to support\npre-filtering of join paths in add_path_precheck.  Without this rule we\ncould never reject a parameterized path in advance of computing its rowcount\nestimate, which would greatly reduce the value of the pre-filter mechanism.\n\nTo limit planning time, we have to avoid generating an unreasonably large\nnumber of parameterized paths.  We do this by only generating parameterized\nrelation scan paths for index scans, and then only for indexes for which\nsuitable join clauses are available.  There are also heuristics in join\nplanning that try to limit the number of parameterized paths considered.\n\nIn particular, there's been a deliberate policy decision to favor hash\njoins over merge joins for parameterized join steps (those occurring below\na nestloop that provides parameters to the lower join's inputs).  While we\ndo not ignore merge joins entirely, joinpath.c does not fully explore the\nspace of potential merge joins with parameterized inputs.  Also, add_path\ntreats parameterized paths as having no pathkeys, so that they compete\nonly on cost and rowcount; they don't get preference for producing a\nspecial sort order.  This creates additional bias against merge joins,\nsince we might discard a path that could have been useful for performing\na merge without an explicit sort step.  Since a parameterized path must\nultimately be used on the inside of a nestloop, where its sort order is\nuninteresting, these choices do not affect any requirement for the final\noutput order of a query --- they only make it harder to use a merge join\nat a lower level.  The savings in planning work justifies that.\n\nSimilarly, parameterized paths do not normally get preference in add_path\nfor having cheap startup cost; that's seldom of much value when on the\ninside of a nestloop, so it seems not worth keeping extra paths solely for\nthat.  An exception occurs for parameterized paths for the RHS relation of\na SEMI or ANTI join: in those cases, we can stop the inner scan after the\nfirst match, so it's primarily startup not total cost that we care about.\n\n\nLATERAL subqueries\n------------------\n\nAs of 9.3 we support SQL-standard LATERAL references from subqueries in\nFROM (and also functions in FROM).  The planner implements these by\ngenerating parameterized paths for any RTE that contains lateral\nreferences.  In such cases, *all* paths for that relation will be\nparameterized by at least the set of relations used in its lateral\nreferences.  (And in turn, join relations including such a subquery might\nnot have any unparameterized paths.)  All the other comments made above for\nparameterized paths still apply, though; in particular, each such path is\nstill expected to enforce any join clauses that can be pushed down to it,\nso that all paths of the same parameterization have the same rowcount.\n\nWe also allow LATERAL subqueries to be flattened (pulled up into the parent\nquery) by the optimizer, but only when this does not introduce lateral\nreferences into JOIN/ON quals that would refer to relations outside the\nlowest outer join at/above that qual.  The semantics of such a qual would\nbe unclear.  Note that even with this restriction, pullup of a LATERAL\nsubquery can result in creating PlaceHolderVars that contain lateral\nreferences to relations outside their syntactic scope.  We still evaluate\nsuch PHVs at their syntactic location or lower, but the presence of such a\nPHV in the quals or targetlist of a plan node requires that node to appear\non the inside of a nestloop join relative to the rel(s) supplying the\nlateral reference.  (Perhaps now that that stuff works, we could relax the\npullup restriction?)\n\n\nSecurity-level constraints on qual clauses\n------------------------------------------\n\nTo support row-level security and security-barrier views efficiently,\nwe mark qual clauses (RestrictInfo nodes) with a \"security_level\" field.\nThe basic concept is that a qual with a lower security_level must be\nevaluated before one with a higher security_level.  This ensures that\n\"leaky\" quals that might expose sensitive data are not evaluated until\nafter the security barrier quals that are supposed to filter out\nsecurity-sensitive rows.  However, many qual conditions are \"leakproof\",\nthat is we trust the functions they use to not expose data.  To avoid\nunnecessarily inefficient plans, a leakproof qual is not delayed by\nsecurity-level considerations, even if it has a higher syntactic\nsecurity_level than another qual.\n\nIn a query that contains no use of RLS or security-barrier views, all\nquals will have security_level zero, so that none of these restrictions\nkick in; we don't even need to check leakproofness of qual conditions.\n\nIf there are security-barrier quals, they get security_level zero (and\npossibly higher, if there are multiple layers of barriers).  Regular quals\ncoming from the query text get a security_level one more than the highest\nlevel used for barrier quals.\n\nWhen new qual clauses are generated by EquivalenceClass processing,\nthey must be assigned a security_level.  This is trickier than it seems.\nOne's first instinct is that it would be safe to use the largest level\nfound among the source quals for the EquivalenceClass, but that isn't\nsafe at all, because it allows unwanted delays of security-barrier quals.\nConsider a barrier qual \"t.x = t.y\" plus a query qual \"t.x = constant\",\nand suppose there is another query qual \"leaky_function(t.z)\" that\nwe mustn't evaluate before the barrier qual has been checked.\nWe will have an EC {t.x, t.y, constant} which will lead us to replace\nthe EC quals with \"t.x = constant AND t.y = constant\".  (We do not want\nto give up that behavior, either, since the latter condition could allow\nuse of an index on t.y, which we would never discover from the original\nquals.)  If these generated quals are assigned the same security_level as\nthe query quals, then it's possible for the leaky_function qual to be\nevaluated first, allowing leaky_function to see data from rows that\npossibly don't pass the barrier condition.\n\nInstead, our handling of security levels with ECs works like this:\n* Quals are not accepted as source clauses for ECs in the first place\nunless they are leakproof or have security_level zero.\n* EC-derived quals are assigned the minimum (not maximum) security_level\nfound among the EC's source clauses.\n* If the maximum security_level found among the EC's source clauses is\nabove zero, then the equality operators selected for derived quals must\nbe leakproof.  When no such operator can be found, the EC is treated as\n\"broken\" and we fall back to emitting its source clauses without any\nadditional derived quals.\n\nThese rules together ensure that an untrusted qual clause (one with\nsecurity_level above zero) cannot cause an EC to generate a leaky derived\nclause.  This makes it safe to use the minimum not maximum security_level\nfor derived clauses.  The rules could result in poor plans due to not\nbeing able to generate derived clauses at all, but the risk of that is\nsmall in practice because most btree equality operators are leakproof.\nAlso, by making exceptions for level-zero quals, we ensure that there is\nno plan degradation when no barrier quals are present.\n\nOnce we have security levels assigned to all clauses, enforcement\nof barrier-qual ordering restrictions boils down to two rules:\n\n* Table scan plan nodes must not select quals for early execution\n(for example, use them as index qualifiers in an indexscan) unless\nthey are leakproof or have security_level no higher than any other\nqual that is due to be executed at the same plan node.  (Use the\nutility function restriction_is_securely_promotable() to check\nwhether it's okay to select a qual for early execution.)\n\n* Normal execution of a list of quals must execute them in an order\nthat satisfies the same security rule, ie higher security_levels must\nbe evaluated later unless leakproof.  (This is handled in a single place\nby order_qual_clauses() in createplan.c.)\n\norder_qual_clauses() uses a heuristic to decide exactly what to do with\nleakproof clauses.  Normally it sorts clauses by security_level then cost,\nbeing careful that the sort is stable so that we don't reorder clauses\nwithout a clear reason.  But this could result in a very expensive qual\nbeing done before a cheaper one that is of higher security_level.\nIf the cheaper qual is leaky we have no choice, but if it is leakproof\nwe could put it first.  We choose to sort leakproof quals as if they\nhave security_level zero, but only when their cost is less than 10X\ncpu_operator_cost; that restriction alleviates the opposite problem of\ndoing expensive quals first just because they're leakproof.\n\nAdditional rules will be needed to support safe handling of join quals\nwhen there is a mix of security levels among join quals; for example, it\nwill be necessary to prevent leaky higher-security-level quals from being\nevaluated at a lower join level than other quals of lower security level.\nCurrently there is no need to consider that since security-prioritized\nquals can only be single-table restriction quals coming from RLS policies\nor security-barrier views, and security-barrier view subqueries are never\nflattened into the parent query.  Hence enforcement of security-prioritized\nquals only happens at the table scan level.  With extra rules for safe\nhandling of security levels among join quals, it should be possible to let\nsecurity-barrier views be flattened into the parent query, allowing more\nflexibility of planning while still preserving required ordering of qual\nevaluation.  But that will come later.\n\n\nPost scan/join planning\n-----------------------\n\nSo far we have discussed only scan/join planning, that is, implementation\nof the FROM and WHERE clauses of a SQL query.  But the planner must also\ndetermine how to deal with GROUP BY, aggregation, and other higher-level\nfeatures of queries; and in many cases there are multiple ways to do these\nsteps and thus opportunities for optimization choices.  These steps, like\nscan/join planning, are handled by constructing Paths representing the\ndifferent ways to do a step, then choosing the cheapest Path.\n\nSince all Paths require a RelOptInfo as \"parent\", we create RelOptInfos\nrepresenting the outputs of these upper-level processing steps.  These\nRelOptInfos are mostly dummy, but their pathlist lists hold all the Paths\nconsidered useful for each step.  Currently, we may create these types of\nadditional RelOptInfos during upper-level planning:\n\nUPPERREL_SETOP\t\tresult of UNION/INTERSECT/EXCEPT, if any\nUPPERREL_PARTIAL_GROUP_AGG\tresult of partial grouping/aggregation, if any\nUPPERREL_GROUP_AGG\tresult of grouping/aggregation, if any\nUPPERREL_WINDOW\t\tresult of window functions, if any\nUPPERREL_PARTIAL_DISTINCT\tresult of partial \"SELECT DISTINCT\", if any\nUPPERREL_DISTINCT\tresult of \"SELECT DISTINCT\", if any\nUPPERREL_ORDERED\tresult of ORDER BY, if any\nUPPERREL_FINAL\t\tresult of any remaining top-level actions\n\nUPPERREL_FINAL is used to represent any final processing steps, currently\nLockRows (SELECT FOR UPDATE), LIMIT/OFFSET, and ModifyTable.  There is no\nflexibility about the order in which these steps are done, and thus no need\nto subdivide this stage more finely.\n\nThese \"upper relations\" are identified by the UPPERREL enum values shown\nabove, plus a relids set, which allows there to be more than one upperrel\nof the same kind.  We use NULL for the relids if there's no need for more\nthan one upperrel of the same kind.  Currently, in fact, the relids set\nis vestigial because it's always NULL, but that's expected to change in\nthe future.  For example, in planning set operations, we might need the\nrelids to denote which subset of the leaf SELECTs has been combined in a\nparticular group of Paths that are competing with each other.\n\nThe result of subquery_planner() is always returned as a set of Paths\nstored in the UPPERREL_FINAL rel with NULL relids.  The other types of\nupperrels are created only if needed for the particular query.\n\n\nParallel Query and Partial Paths\n--------------------------------\n\nParallel query involves dividing up the work that needs to be performed\neither by an entire query or some portion of the query in such a way that\nsome of that work can be done by one or more worker processes, which are\ncalled parallel workers.  Parallel workers are a subtype of dynamic\nbackground workers; see src/backend/access/transam/README.parallel for a\nfuller description.  The academic literature on parallel query suggests\nthat parallel execution strategies can be divided into essentially two\ncategories: pipelined parallelism, where the execution of the query is\ndivided into multiple stages and each stage is handled by a separate\nprocess; and partitioning parallelism, where the data is split between\nmultiple processes and each process handles a subset of it.  The\nliterature, however, suggests that gains from pipeline parallelism are\noften very limited due to the difficulty of avoiding pipeline stalls.\nConsequently, we do not currently attempt to generate query plans that\nuse this technique.\n\nInstead, we focus on partitioning parallelism, which does not require\nthat the underlying table be partitioned.  It only requires that (1)\nthere is some method of dividing the data from at least one of the base\ntables involved in the relation across multiple processes, (2) allowing\neach process to handle its own portion of the data, and then (3)\ncollecting the results.  Requirements (2) and (3) are satisfied by the\nexecutor node Gather (or GatherMerge), which launches any number of worker\nprocesses and executes its single child plan in all of them, and perhaps\nin the leader also, if the children aren't generating enough data to keep\nthe leader busy.  Requirement (1) is handled by the table scan node: when\ninvoked with parallel_aware = true, this node will, in effect, partition\nthe table on a block by block basis, returning a subset of the tuples from\nthe relation in each worker where that scan node is executed.\n\nJust as we do for non-parallel access methods, we build Paths to\nrepresent access strategies that can be used in a parallel plan.  These\nare, in essence, the same strategies that are available in the\nnon-parallel plan, but there is an important difference: a path that\nwill run beneath a Gather node returns only a subset of the query\nresults in each worker, not all of them.  To form a path that can\nactually be executed, the (rather large) cost of the Gather node must be\naccounted for.  For this reason among others, paths intended to run\nbeneath a Gather node - which we call \"partial\" paths since they return\nonly a subset of the results in each worker - must be kept separate from\nordinary paths (see RelOptInfo's partial_pathlist and the function\nadd_partial_path).\n\nOne of the keys to making parallel query effective is to run as much of\nthe query in parallel as possible.  Therefore, we expect it to generally\nbe desirable to postpone the Gather stage until as near to the top of the\nplan as possible.  Expanding the range of cases in which more work can be\npushed below the Gather (and costing them accurately) is likely to keep us\nbusy for a long time to come.\n\nPartitionwise joins\n-------------------\n\nA join between two similarly partitioned tables can be broken down into joins\nbetween their matching partitions if there exists an equi-join condition\nbetween the partition keys of the joining tables. The equi-join between\npartition keys implies that all join partners for a given row in one\npartitioned table must be in the corresponding partition of the other\npartitioned table. Because of this the join between partitioned tables to be\nbroken into joins between the matching partitions. The resultant join is\npartitioned in the same way as the joining relations, thus allowing an N-way\njoin between similarly partitioned tables having equi-join condition between\ntheir partition keys to be broken down into N-way joins between their matching\npartitions. This technique of breaking down a join between partitioned tables\ninto joins between their partitions is called partitionwise join. We will use\nterm \"partitioned relation\" for either a partitioned table or a join between\ncompatibly partitioned tables.\n\nEven if the joining relations don't have exactly the same partition bounds,\npartitionwise join can still be applied by using an advanced\npartition-matching algorithm.  For both the joining relations, the algorithm\nchecks whether every partition of one joining relation only matches one\npartition of the other joining relation at most.  In such a case the join\nbetween the joining relations can be broken down into joins between the\nmatching partitions.  The join relation can then be considered partitioned.\nThe algorithm produces the pairs of the matching partitions, plus the\npartition bounds for the join relation, to allow partitionwise join for\ncomputing the join.  The algorithm is implemented in partition_bounds_merge().\nFor an N-way join relation considered partitioned this way, not every pair of\njoining relations can use partitionwise join.  For example:\n\n\t(A leftjoin B on (Pab)) innerjoin C on (Pac)\n\nwhere A, B, and C are partitioned tables, and A has an extra partition\ncompared to B and C.  When considering partitionwise join for the join {A B},\nthe extra partition of A doesn't have a matching partition on the nullable\nside, which is the case that the current implementation of partitionwise join\ncan't handle.  So {A B} is not considered partitioned, and the pair of {A B}\nand C considered for the 3-way join can't use partitionwise join.  On the\nother hand, the pair of {A C} and B can use partitionwise join because {A C}\nis considered partitioned by eliminating the extra partition (see identity 1\non outer join reordering).  Whether an N-way join can use partitionwise join\nis determined based on the first pair of joining relations that are both\npartitioned and can use partitionwise join.\n\nThe partitioning properties of a partitioned relation are stored in its\nRelOptInfo.  The information about data types of partition keys are stored in\nPartitionSchemeData structure. The planner maintains a list of canonical\npartition schemes (distinct PartitionSchemeData objects) so that RelOptInfo of\nany two partitioned relations with same partitioning scheme point to the same\nPartitionSchemeData object.  This reduces memory consumed by\nPartitionSchemeData objects and makes it easy to compare the partition schemes\nof joining relations.\n\nPartitionwise aggregates/grouping\n---------------------------------\n\nIf the GROUP BY clause contains all of the partition keys, all the rows\nthat belong to a given group must come from a single partition; therefore,\naggregation can be done completely separately for each partition. Otherwise,\npartial aggregates can be computed for each partition, and then finalized\nafter appending the results from the individual partitions.  This technique of\nbreaking down aggregation or grouping over a partitioned relation into\naggregation or grouping over its partitions is called partitionwise\naggregation.  Especially when the partition keys match the GROUP BY clause,\nthis can be significantly faster than the regular method.","count":215},{"name":"subsystem-name","value":"optimizer","count":215},{"name":"subsystem-path","value":"backend/optimizer/readme","count":215},{"name":"api-example","value":"List * AddRelationNewConstraints(Relation rel, List *newColDefaults, List *newConstraints, bool allow_merge, bool is_local, bool is_internal, const char *queryString) { List\t   *cookedConstraints = NI...","count":213},{"name":"api-caller-count","value":"33","count":212},{"name":"arch-layer-depth","value":"4","count":209},{"name":"api-caller-count","value":"108","count":208},{"name":"api-caller-count","value":"50","count":208},{"name":"api-typical-usage","value":"Often called from: subquery_planner","count":208},{"name":"test-count","value":"24","count":208},{"name":"api-caller-count","value":"220","count":204},{"name":"api-caller-count","value":"32","count":204},{"name":"api-example","value":"int main(int argc, char *argv[]) { static struct option long_options[] = { {\"pgdata\", required_argument, NULL, 'D'}, {\"encoding\", required_argument, NULL, 'E'}, {\"locale\", required_argument, NULL, 1},...","count":204},{"name":"api-typical-usage","value":"Often called from: describeDumpableObject","count":204},{"name":"lines-of-code","value":"83","count":204},{"name":"lines-of-code","value":"84","count":204},{"name":"lines-of-code","value":"91","count":204},{"name":"tested-by","value":"check_sql_fn_retval, check_sql_fn_retval, check_ident_usermap, check_ident_usermap, check_index_predicates","count":204},{"name":"api-caller-count","value":"1361","count":200},{"name":"api-caller-count","value":"35","count":200},{"name":"api-caller-count","value":"385","count":200},{"name":"api-caller-count","value":"56","count":200},{"name":"coupling-score","value":"7","count":200},{"name":"cyclomatic-complexity","value":"37","count":200},{"name":"cyclomatic-complexity","value":"39","count":200},{"name":"loop-depth","value":"24","count":200},{"name":"test-count","value":"38","count":200},{"name":"tested-by","value":"_bt_check_unique, RI_FKey_pk_upd_check_required, RI_FKey_fk_upd_check_required","count":200},{"name":"tested-by","value":"check_default_table_access_method, check_nested_generated_walker, check_default_tablespace, check_role_grantor, check_role_grantor, check_memoizable, check_memoizable, check_memoizable, check_memoizab","count":200},{"name":"api-example","value":"struct varlena * detoast_attr(struct varlena *attr) { if (VARATT_IS_EXTERNAL_ONDISK(attr)) { * This is an externally stored datum --- fetch it back from there */ attr = toast_fetch_datum(attr); if (VA...","count":198},{"name":"api-caller-count","value":"432","count":196},{"name":"api-typical-usage","value":"Often called from: WalReceiverMain","count":196},{"name":"coupling-score","value":"4","count":196},{"name":"lines-of-code","value":"92","count":196},{"name":"tested-by","value":"check_log_duration, check_file_excluded, check_for_data_types_usage, check_proper_datallowconn, check_for_isn_and_int8_passing_mismatch, check_for_user_defined_postfix_ops, check_for_incompatible_poly","count":196},{"name":"tested-by","value":"check_simple_rowfilter_expr_walker, check_simple_rowfilter_expr_walker, check_simple_rowfilter_expr_walker, check_simple_rowfilter_expr_walker, check_simple_rowfilter_expr_walker, check_simple_rowfilt","count":196},{"name":"tested-by","value":"check_sql_fn_statements, check_sql_fn_statements, check_sql_fn_retval, check_sql_fn_retval, check_new_partition_bound","count":196},{"name":"cyclomatic-complexity","value":"36","count":192},{"name":"cyclomatic-complexity","value":"40","count":192},{"name":"arch-layer","value":"utils","count":191},{"name":"arch-layer-depth","value":"7","count":191},{"name":"arch-layer-description","value":"Utility functions and data structures","count":191},{"name":"api-caller-count","value":"192","count":188},{"name":"api-caller-count","value":"252","count":188},{"name":"api-caller-count","value":"58","count":188},{"name":"api-typical-usage","value":"Often called from: EncodeDateTime","count":188},{"name":"api-typical-usage","value":"Often called from: describeOneTableDetails","count":188},{"name":"api-typical-usage","value":"Often called from: make_build_data","count":188},{"name":"api-typical-usage","value":"Often called from: process_directory_recursively","count":188},{"name":"api-typical-usage","value":"Often called from: spg_text_picksplit","count":188},{"name":"cyclomatic-complexity","value":"38","count":188},{"name":"tested-by","value":"check_replace_text_has_escape","count":188},{"name":"api-caller-count","value":"49","count":184},{"name":"api-caller-count","value":"589","count":184},{"name":"api-typical-usage","value":"Often called from: RelationGetBufferForTuple","count":184},{"name":"lines-of-code","value":"105","count":184},{"name":"lines-of-code","value":"93","count":184},{"name":"lines-of-code","value":"96","count":184},{"name":"tested-by","value":"check_data_directory, check_data_directory, check_backup_label_files, check_backup_label_files, check_backup_label_files, check_file_excluded, check_for_data_types_usage, check_for_new_tablespace_dir,","count":184},{"name":"api-example","value":"BrinTuple * brin_form_tuple(BrinDesc *brdesc, BlockNumber blkno, BrinMemTuple *tuple, Size *size) { Datum\t   *values; bool\t   *nulls; bool\t\tanynulls = false; BrinTuple  *rettuple; int\t\t\tkeyno; int\t\t\ti...","count":183},{"name":"api-caller-count","value":"162","count":180},{"name":"module-depends-on","value":"<unknown>, backend\\snowball\\libstemmer\\utilities.c, backend\\snowball\\libstemmer\\api.c","count":180},{"name":"tested-by","value":"check_hash_func_signature, check_amproc_signature, check_amop_signature, pg_attribute_aclcheck_all_ext, pg_attribute_aclcheck_all_ext, index_check_primary_key, check_object_ownership, check_db_file_co","count":180},{"name":"api-example","value":"Datum brin_minmax_consistent(PG_FUNCTION_ARGS) { BrinDesc   *bdesc = (BrinDesc *) PG_GETARG_POINTER(0); BrinValues *column = (BrinValues *) PG_GETARG_POINTER(1); ScanKey\t\tkey = (ScanKey) PG_GETARG_POI...","count":177},{"name":"api-example","value":"static double _brin_parallel_heapscan(BrinBuildState *state) { BrinShared *brinshared = state->bs_leader->brinshared; int\t\t\tnparticipanttuplesorts; nparticipanttuplesorts = state->bs_leader->nparticip...","count":177},{"name":"api-typical-usage","value":"Often called from: brin_inclusion_consistent","count":176},{"name":"coupling-score","value":"13","count":176},{"name":"api-caller-count","value":"106","count":172},{"name":"api-caller-count","value":"69","count":172},{"name":"api-typical-usage","value":"Often called from: HeapTupleSatisfiesVacuumHorizon","count":172},{"name":"coupling-score","value":"14","count":172},{"name":"lines-of-code","value":"111","count":172},{"name":"lines-of-code","value":"98","count":172},{"name":"tested-by","value":"heap_truncate_check_FKs, heap_truncate_check_FKs, check_simple_rowfilter_expr_walker, check_functions_in_node, check_default_partition_contents","count":172},{"name":"api-example","value":"void ExecuteCallStmt(CallStmt *stmt, ParamListInfo params, bool atomic, DestReceiver *dest) { LOCAL_FCINFO(fcinfo, FUNC_MAX_ARGS); ListCell   *lc; FuncExpr   *fexpr; int\t\t\tnargs; int\t\t\ti; AclResult\tac...","count":171},{"name":"arch-layer","value":"frontend","count":171},{"name":"arch-layer-depth","value":"0","count":171},{"name":"arch-layer-description","value":"Client-side tools and libraries (psql, libpq, ecpg)","count":171},{"name":"api-caller-count","value":"457","count":168},{"name":"api-caller-count","value":"57","count":168},{"name":"api-example","value":"bool printsimple(TupleTableSlot *slot, DestReceiver *self) { TupleDesc\ttupdesc = slot->tts_tupleDescriptor; StringInfoData buf; int\t\t\ti; slot_getallattrs(slot); pq_beginmessage(&buf, PqMsg_DataRow); p...","count":168},{"name":"api-example","value":"static void logical_rewrite_log_mapping(RewriteState state, TransactionId xid, LogicalRewriteMappingData *map) { RewriteMappingFile *src; RewriteMappingDataEntry *pmap; Oid\t\t\trelid; bool\t\tfound; relid...","count":168},{"name":"api-typical-usage","value":"Often called from: RemoveInheritance","count":168},{"name":"api-typical-usage","value":"Often called from: add_abs","count":168},{"name":"api-typical-usage","value":"Often called from: plpgsql_validator","count":168},{"name":"cyclomatic-complexity","value":"44","count":168},{"name":"lines-of-code","value":"104","count":168},{"name":"lines-of-code","value":"108","count":168},{"name":"lines-of-code","value":"110","count":168},{"name":"tested-by","value":"heap_get_latest_tid, systable_recheck_tuple, heap_truncate_check_FKs, index_check_primary_key, check_object_ownership, check_index_is_clusterable, check_for_column_name_collision, check_default_partit","count":168},{"name":"api-example","value":"TupleDesc BuildDescFromLists(const List *names, const List *types, const List *typmods, const List *collations) { int\t\t\tnatts; AttrNumber\tattnum; ListCell   *l1; ListCell   *l2; ListCell   *l3; ListCe...","count":165},{"name":"api-example","value":"static bool TransactionGroupUpdateXidStatus(TransactionId xid, XidStatus status, XLogRecPtr lsn, int64 pageno) { volatile PROC_HDR *procglobal = ProcGlobal; PGPROC\t   *proc = MyProc; uint32\t\tnextidx; ...","count":165},{"name":"subsystem-desc","value":"src/backend/utils/mb/README\n\nEncodings\n=========\n\nconv.c:\t\tstatic functions and a public table for code conversion\nmbutils.c:\tpublic functions for the backend only.\nstringinfo_mb.c: public backend-only multibyte-aware stringinfo functions\nwstrcmp.c:\tstrcmp for mb\nwstrncmp.c:\tstrncmp for mb\nwin866.c:\ta tool to generate KOI8 <--> CP866 conversion table\niso.c:\t\ta tool to generate KOI8 <--> ISO8859-5 conversion table\nwin1251.c:\ta tool to generate KOI8 <--> CP1251 conversion table\n\nSee also in src/common/:\n\nencnames.c:\tpublic functions for encoding names\nwchar.c:\tmostly static functions and a public table for mb string and\n\t\tmultibyte conversion\n\nIntroduction\n------------\n\thttp://www.cprogramming.com/tutorial/unicode.html","count":165},{"name":"subsystem-name","value":"mb","count":165},{"name":"subsystem-path","value":"backend/utils/mb/readme","count":165},{"name":"lines-of-code","value":"100","count":164},{"name":"lines-of-code","value":"109","count":164},{"name":"lines-of-code","value":"90","count":164},{"name":"tested-by","value":"check_role_for_policy, check_float8_array, pg_isolation_test_session_is_blocked, pg_isolation_test_session_is_blocked","count":164},{"name":"api-example","value":"Datum brin_inclusion_consistent(PG_FUNCTION_ARGS) { BrinDesc   *bdesc = (BrinDesc *) PG_GETARG_POINTER(0); BrinValues *column = (BrinValues *) PG_GETARG_POINTER(1); ScanKey\t\tkey = (ScanKey) PG_GETARG_...","count":162},{"name":"api-caller-count","value":"181","count":160},{"name":"api-caller-count","value":"80","count":160},{"name":"api-typical-usage","value":"Often called from: SPI_cursor_open_internal","count":160},{"name":"api-typical-usage","value":"Often called from: adjust_appendrel_attrs_mutator","count":160},{"name":"coupling-score","value":"10","count":160},{"name":"coupling-score","value":"18","count":160},{"name":"tested-by","value":"check_wal_consistency_checking","count":160},{"name":"tested-by","value":"convert_testexpr_mutator, add_with_check_options, add_with_check_options","count":160},{"name":"tested-by","value":"pg_isolation_test_session_is_blocked","count":160},{"name":"api-example","value":"static void gistprunepage(Relation rel, Page page, Buffer buffer, Relation heapRel) { OffsetNumber deletable[MaxIndexTuplesPerPage]; int\t\t\tndeletable = 0; OffsetNumber offnum, maxoff; Assert(GistPageI...","count":159},{"name":"api-caller-count","value":"47","count":156},{"name":"api-caller-count","value":"59","count":156},{"name":"api-caller-count","value":"907","count":156},{"name":"api-example","value":"Datum extract_date(PG_FUNCTION_ARGS) { text\t   *units = PG_GETARG_TEXT_PP(0); DateADT\t\tdate = PG_GETARG_DATEADT(1); int64\t\tintresult; int\t\t\ttype, val; char\t   *lowunits; int\t\t\tyear, mon, mday; lowunit...","count":156},{"name":"api-example","value":"void _brin_parallel_build_main(dsm_segment *seg, shm_toc *toc) { char\t   *sharedquery; BrinShared *brinshared; Sharedsort *sharedsort; BrinBuildState *buildstate; Relation\theapRel; Relation\tindexRel; ...","count":156},{"name":"api-typical-usage","value":"Often called from: lookup_type_cache","count":156},{"name":"api-typical-usage","value":"Often called from: spg_box_quad_picksplit","count":156},{"name":"coupling-score","value":"16","count":156},{"name":"coupling-score","value":"17","count":156},{"name":"coupling-score","value":"9","count":156},{"name":"lines-of-code","value":"95","count":156},{"name":"test-count","value":"86","count":156},{"name":"tested-by","value":"check_backup_label_files","count":156},{"name":"tested-by","value":"check_loadable_libraries","count":156},{"name":"api-example","value":"void LaunchParallelWorkers(ParallelContext *pcxt) { MemoryContext oldcontext; BackgroundWorker worker; int\t\t\ti; bool\t\tany_registrations_failed = false; if (pcxt->nworkers == 0 || pcxt->nworkers_to_lau...","count":153},{"name":"api-caller-count","value":"241","count":152},{"name":"api-typical-usage","value":"Often called from: ExplainNode","count":152},{"name":"api-typical-usage","value":"Often called from: help","count":152},{"name":"cyclomatic-complexity","value":"42","count":152},{"name":"tested-by","value":"test_config_settings, test_config_settings, test_config_settings, test_config_settings, test_config_settings, test_config_settings, test_config_settings, test_config_settings, test_config_settings, ch","count":152},{"name":"api-caller-count","value":"381","count":148},{"name":"api-caller-count","value":"46","count":148},{"name":"api-caller-count","value":"55","count":148},{"name":"api-typical-usage","value":"Often called from: mergejoinscansel","count":148},{"name":"coupling-score","value":"15","count":148},{"name":"lines-of-code","value":"97","count":148},{"name":"tested-by","value":"_bt_check_third_page","count":148},{"name":"tested-by","value":"_bt_check_unique","count":148},{"name":"api-example","value":"char * BuildIndexValueDescription(Relation indexRelation, const Datum *values, const bool *isnull) { StringInfoData buf; Form_pg_index idxrec; int\t\t\tindnkeyatts; int\t\t\ti; int\t\t\tkeyno; Oid\t\t\tindexrelid...","count":147},{"name":"api-example","value":"static ObjectAddress get_object_address_opf_member(ObjectType objtype, List *object, bool missing_ok) { ObjectAddress famaddr; ObjectAddress address; ListCell   *cell; List\t   *copy; TypeName   *typen...","count":147},{"name":"subsystem-desc","value":"src/interfaces/libpq/README\n\nThis directory contains the C version of Libpq, the POSTGRES frontend library.","count":145},{"name":"subsystem-name","value":"libpq","count":145},{"name":"subsystem-path","value":"interfaces/libpq/readme","count":145},{"name":"api-caller-count","value":"1563","count":144},{"name":"api-caller-count","value":"77","count":144},{"name":"api-example","value":"int DecodeDateTime(char **field, int *ftype, int nf, int *dtype, struct pg_tm *tm, fsec_t *fsec, int *tzp, DateTimeErrorExtra *extra) { int\t\t\tfmask = 0, tmask, type; int\t\t\tptype = 0;\t\t/* \"prefix type\"...","count":144},{"name":"api-typical-usage","value":"Often called from: test_file_descriptor_sync","count":144},{"name":"cyclomatic-complexity","value":"41","count":144},{"name":"lines-of-code","value":"99","count":144},{"name":"api-example","value":"Relation relation_open(Oid relationId, LOCKMODE lockmode) { Relation\tr; Assert(lockmode >= NoLock && lockmode < MAX_LOCKMODES); if (lockmode != NoLock) LockRelationOid(relationId, lockmode); r = Relat...","count":141},{"name":"api-example","value":"static void gistInitParentMap(GISTBuildState *buildstate) { HASHCTL\t\thashCtl; hashCtl.keysize = sizeof(BlockNumber); hashCtl.entrysize = sizeof(ParentMapEntry); hashCtl.hcxt = CurrentMemoryContext; bu...","count":141},{"name":"api-example","value":"void xlog_desc(StringInfo buf, XLogReaderState *record) { char\t   *rec = XLogRecGetData(record); uint8\t\tinfo = XLogRecGetInfo(record) & ~XLR_INFO_MASK; if (info == XLOG_CHECKPOINT_SHUTDOWN || info == ...","count":141},{"name":"api-caller-count","value":"117","count":140},{"name":"api-caller-count","value":"126","count":140},{"name":"api-typical-usage","value":"Often called from: _hash_splitbucket","count":140},{"name":"api-typical-usage","value":"Often called from: doPickSplit","count":140},{"name":"lines-of-code","value":"102","count":140},{"name":"tested-by","value":"check_simple_rowfilter_expr_walker","count":140},{"name":"tested-by","value":"heap_get_latest_tid, _bt_check_unique, _bt_check_unique","count":140},{"name":"api-example","value":"static int brin_bloom_get_ndistinct(BrinDesc *bdesc, BloomOptions *opts) { double\t\tndistinct; double\t\tmaxtuples; BlockNumber pagesPerRange; pagesPerRange = BrinGetPagesPerRange(bdesc->bd_index); ndist...","count":138},{"name":"api-caller-count","value":"314","count":136},{"name":"api-typical-usage","value":"Often called from: DCH_to_char","count":136},{"name":"api-typical-usage","value":"Often called from: ginPlaceToPage","count":136},{"name":"api-typical-usage","value":"Often called from: ginvacuumcleanup","count":136},{"name":"api-typical-usage","value":"Often called from: record_image_eq","count":136},{"name":"security-risk","value":"command-injection","count":136},{"name":"tested-by","value":"_bt_check_compare","count":136},{"name":"tested-by","value":"check_index_predicates","count":136},{"name":"api-example","value":"int toast_open_indexes(Relation toastrel, LOCKMODE lock, Relation **toastidxs, int *num_indexes) { int\t\t\ti = 0; int\t\t\tres = 0; bool\t\tfound = false; List\t   *indexlist; ListCell   *lc; indexlist = Rela...","count":135},{"name":"api-example","value":"void pq_parse_errornotice(StringInfo msg, ErrorData *edata) { MemSet(edata, 0, sizeof(ErrorData)); edata->elevel = ERROR; edata->assoc_context = CurrentMemoryContext; for (;;) { char\t\tcode = pq_getmsg...","count":135},{"name":"api-caller-count","value":"112","count":132},{"name":"api-caller-count","value":"262","count":132},{"name":"api-typical-usage","value":"Often called from: ReleasePredicateLocks","count":132},{"name":"api-typical-usage","value":"Often called from: refresh_by_match_merge","count":132},{"name":"coupling-score","value":"19","count":132},{"name":"coupling-score","value":"20","count":132},{"name":"coupling-score","value":"6","count":132},{"name":"api-example","value":"ObjectAddress get_object_address(ObjectType objtype, Node *object, Relation *relp, LOCKMODE lockmode, bool missing_ok) { ObjectAddress address = {InvalidOid, InvalidOid, 0}; ObjectAddress old_address ...","count":129},{"name":"api-example","value":"static DistanceValue * build_distances(FmgrInfo *distanceFn, Oid colloid, ExpandedRange *eranges, int neranges) { int\t\t\ti; int\t\t\tndistances; DistanceValue *distances; Assert(neranges > 0); if (nerange...","count":129},{"name":"api-example","value":"static void brinsummarize(Relation index, Relation heapRel, BlockNumber pageRange, bool include_partial, double *numSummarized, double *numExisting) { BrinRevmap *revmap; BrinBuildState *state = NULL;...","count":129},{"name":"api-example","value":"void xact_desc(StringInfo buf, XLogReaderState *record) { char\t   *rec = XLogRecGetData(record); uint8\t\tinfo = XLogRecGetInfo(record) & XLOG_XACT_OPMASK; if (info == XLOG_XACT_COMMIT || info == XLOG_X...","count":129},{"name":"api-caller-count","value":"105","count":128},{"name":"api-caller-count","value":"116","count":128},{"name":"api-caller-count","value":"367","count":128},{"name":"api-caller-count","value":"453","count":128},{"name":"api-caller-count","value":"72","count":128},{"name":"api-typical-usage","value":"Often called from: _bt_split","count":128},{"name":"api-typical-usage","value":"Often called from: index_concurrently_swap","count":128},{"name":"api-typical-usage","value":"Often called from: parseqatom","count":128},{"name":"api-typical-usage","value":"Often called from: pg_strtoint16_safe","count":128},{"name":"coupling-score","value":"12","count":128},{"name":"cyclomatic-complexity","value":"52","count":128},{"name":"lines-of-code","value":"116","count":128},{"name":"lines-of-code","value":"134","count":128},{"name":"loop-depth","value":"25","count":128},{"name":"privilege-level","value":"admin","count":128},{"name":"tested-by","value":"check_acl, check_float8_array","count":128},{"name":"tested-by","value":"index_delete_check_htid, index_delete_check_htid, index_delete_check_htid, lazy_check_wraparound_failsafe, table_tuple_get_latest_tid, s_check_valid, check_domain_for_new_field, check_for_freed_segmen","count":128},{"name":"tested-by","value":"truncate_check_rel, truncate_check_perms, check_default_text_search_config","count":128},{"name":"api-example","value":"Datum pg_get_multixact_members(PG_FUNCTION_ARGS) { typedef struct { MultiXactMember *members; int\t\t\tnmembers; int\t\t\titer; } mxact; MultiXactId mxid = PG_GETARG_TRANSACTIONID(0); mxact\t   *multi; FuncC...","count":126},{"name":"subsystem-desc","value":"This directory contains a general purpose data structures, for use anywhere\nin the backend:\n\nbinaryheap.c - a binary heap\n\nbipartite_match.c - Hopcroft-Karp maximum cardinality algorithm for bipartite graphs\n\nbloomfilter.c - probabilistic, space-efficient set membership testing\n\ndshash.c - concurrent hash tables backed by dynamic shared memory areas\n\nhyperloglog.c - a streaming cardinality estimator\n\nilist.c - single and double-linked lists\n\nintegerset.c - a data structure for holding large set of integers\n\nknapsack.c - knapsack problem solver\n\npairingheap.c - a pairing heap\n\nrbtree.c - a red-black tree\n\nstringinfo.c - an extensible string type\n\n\nAside from the inherent characteristics of the data structures, there are a\nfew practical differences between the binary heap and the pairing heap. The\nbinary heap is fully allocated at creation, and cannot be expanded beyond the\nallocated size. The pairing heap on the other hand has no inherent maximum\nsize, but the caller needs to allocate each element being stored in the heap,\nwhile the binary heap works with plain Datums or pointers.\n\nThe linked-lists in ilist.c can be embedded directly into other structs, as\nopposed to the List interface in nodes/pg_list.h.","count":125},{"name":"subsystem-name","value":"lib","count":125},{"name":"subsystem-path","value":"backend/lib/readme","count":125},{"name":"api-typical-usage","value":"Often called from: begin_heap_rewrite","count":124},{"name":"coupling-score","value":"11","count":124},{"name":"coupling-score","value":"8","count":124},{"name":"lines-of-code","value":"127","count":124},{"name":"tested-by","value":"check_and_push_window_quals, check_memoizable, test_opexpr_is_hashable","count":124},{"name":"api-example","value":"Datum transformRelOptions(Datum oldOptions, List *defList, const char *namspace, char *validnsps[], bool acceptOidsOff, bool isReset) { Datum\t\tresult; ArrayBuildState *astate; ListCell   *cell; if (de...","count":123},{"name":"api-example","value":"static char * ReadTwoPhaseFile(TransactionId xid, bool missing_ok) { char\t\tpath[MAXPGPATH]; char\t   *buf; TwoPhaseFileHeader *hdr; int\t\t\tfd; struct stat stat; uint32\t\tcrc_offset; pg_crc32c\tcalc_crc, f...","count":123},{"name":"api-caller-count","value":"148","count":120},{"name":"api-example","value":"static bool find_expr_references_walker(Node *node, find_expr_references_context *context) { if (node == NULL) return false; if (IsA(node, Var)) { Var\t\t   *var = (Var *) node; List\t   *rtable; RangeTb...","count":120},{"name":"api-example","value":"void ScanKeyEntryInitialize(ScanKey entry, int flags, AttrNumber attributeNumber, StrategyNumber strategy, Oid subtype, Oid collation, RegProcedure procedure, Datum argument) { entry->sk_flags = flags...","count":120},{"name":"api-example","value":"void index_register(Oid heap, Oid ind, const IndexInfo *indexInfo) { IndexList  *newind; MemoryContext oldcxt; * XXX mao 10/31/92 -- don't gc index reldescs, associated info at * bootstrap time.  we'l...","count":120},{"name":"api-typical-usage","value":"Often called from: ReplicationSlotsComputeRequiredXmin","count":120},{"name":"api-typical-usage","value":"Often called from: synchronize_one_slot","count":120},{"name":"api-typical-usage","value":"Often called from: vacuumLeafPage","count":120},{"name":"coupling-score","value":"23","count":120},{"name":"cyclomatic-complexity","value":"47","count":120},{"name":"lines-of-code","value":"101","count":120},{"name":"subsystem-desc","value":"src/backend/access/transam/README\n\nThe Transaction System\n======================\n\nPostgreSQL's transaction system is a three-layer system.  The bottom layer\nimplements low-level transactions and subtransactions, on top of which rests\nthe mainloop's control code, which in turn implements user-visible\ntransactions and savepoints.\n\nThe middle layer of code is called by postgres.c before and after the\nprocessing of each query, or after detecting an error:\n\n\t\tStartTransactionCommand\n\t\tCommitTransactionCommand\n\t\tAbortCurrentTransaction\n\nMeanwhile, the user can alter the system's state by issuing the SQL commands\nBEGIN, COMMIT, ROLLBACK, SAVEPOINT, ROLLBACK TO or RELEASE.  The traffic cop\nredirects these calls to the toplevel routines\n\n\t\tBeginTransactionBlock\n\t\tEndTransactionBlock\n\t\tUserAbortTransactionBlock\n\t\tDefineSavepoint\n\t\tRollbackToSavepoint\n\t\tReleaseSavepoint\n\nrespectively.  Depending on the current state of the system, these functions\ncall low level functions to activate the real transaction system:\n\n\t\tStartTransaction\n\t\tCommitTransaction\n\t\tAbortTransaction\n\t\tCleanupTransaction\n\t\tStartSubTransaction\n\t\tCommitSubTransaction\n\t\tAbortSubTransaction\n\t\tCleanupSubTransaction\n\nAdditionally, within a transaction, CommandCounterIncrement is called to\nincrement the command counter, which allows future commands to \"see\" the\neffects of previous commands within the same transaction.  Note that this is\ndone automatically by CommitTransactionCommand after each query inside a\ntransaction block, but some utility functions also do it internally to allow\nsome operations (usually in the system catalogs) to be seen by future\noperations in the same utility command.  (For example, in DefineRelation it is\ndone after creating the heap so the pg_class row is visible, to be able to\nlock it.)\n\n\nFor example, consider the following sequence of user commands:\n\n1)\t\tBEGIN\n2)\t\tSELECT * FROM foo\n3)\t\tINSERT INTO foo VALUES (...)\n4)\t\tCOMMIT\n\nIn the main processing loop, this results in the following function call\nsequence:\n\n     /  StartTransactionCommand;\n    /       StartTransaction;\n1) <    ProcessUtility;                 << BEGIN\n    \\       BeginTransactionBlock;\n     \\  CommitTransactionCommand;\n\n    /   StartTransactionCommand;\n2) /    PortalRunSelect;                << SELECT ...\n   \\    CommitTransactionCommand;\n    \\       CommandCounterIncrement;\n\n    /   StartTransactionCommand;\n3) /    ProcessQuery;                   << INSERT ...\n   \\    CommitTransactionCommand;\n    \\       CommandCounterIncrement;\n\n     /  StartTransactionCommand;\n    /   ProcessUtility;                 << COMMIT\n4) <        EndTransactionBlock;\n    \\   CommitTransactionCommand;\n     \\      CommitTransaction;\n\nThe point of this example is to demonstrate the need for\nStartTransactionCommand and CommitTransactionCommand to be state smart -- they\nshould call CommandCounterIncrement between the calls to BeginTransactionBlock\nand EndTransactionBlock and outside these calls they need to do normal start,\ncommit or abort processing.\n\nFurthermore, suppose the \"SELECT * FROM foo\" caused an abort condition. In\nthis case AbortCurrentTransaction is called, and the transaction is put in\naborted state.  In this state, any user input is ignored except for\ntransaction-termination statements, or ROLLBACK TO <savepoint> commands.\n\nTransaction aborts can occur in two ways:\n\n1) system dies from some internal cause  (syntax error, etc)\n2) user types ROLLBACK\n\nThe reason we have to distinguish them is illustrated by the following two\nsituations:\n\n        case 1                                  case 2\n        ------                                  ------\n1) user types BEGIN                     1) user types BEGIN\n2) user does something                  2) user does something\n3) user does not like what              3) system aborts for some reason\n   she sees and types ABORT                (syntax error, etc)\n\nIn case 1, we want to abort the transaction and return to the default state.\nIn case 2, there may be more commands coming our way which are part of the\nsame transaction block; we have to ignore these commands until we see a COMMIT\nor ROLLBACK.\n\nInternal aborts are handled by AbortCurrentTransaction, while user aborts are\nhandled by UserAbortTransactionBlock.  Both of them rely on AbortTransaction\nto do all the real work.  The only difference is what state we enter after\nAbortTransaction does its work:\n\n* AbortCurrentTransaction leaves us in TBLOCK_ABORT,\n* UserAbortTransactionBlock leaves us in TBLOCK_ABORT_END\n\nLow-level transaction abort handling is divided in two phases:\n* AbortTransaction executes as soon as we realize the transaction has\n  failed.  It should release all shared resources (locks etc) so that we do\n  not delay other backends unnecessarily.\n* CleanupTransaction executes when we finally see a user COMMIT\n  or ROLLBACK command; it cleans things up and gets us out of the transaction\n  completely.  In particular, we mustn't destroy TopTransactionContext until\n  this point.\n\nAlso, note that when a transaction is committed, we don't close it right away.\nRather it's put in TBLOCK_END state, which means that when\nCommitTransactionCommand is called after the query has finished processing,\nthe transaction has to be closed.  The distinction is subtle but important,\nbecause it means that control will leave the xact.c code with the transaction\nopen, and the main loop will be able to keep processing inside the same\ntransaction.  So, in a sense, transaction commit is also handled in two\nphases, the first at EndTransactionBlock and the second at\nCommitTransactionCommand (which is where CommitTransaction is actually\ncalled).\n\nThe rest of the code in xact.c are routines to support the creation and\nfinishing of transactions and subtransactions.  For example, AtStart_Memory\ntakes care of initializing the memory subsystem at main transaction start.\n\n\nSubtransaction Handling\n-----------------------\n\nSubtransactions are implemented using a stack of TransactionState structures,\neach of which has a pointer to its parent transaction's struct.  When a new\nsubtransaction is to be opened, PushTransaction is called, which creates a new\nTransactionState, with its parent link pointing to the current transaction.\nStartSubTransaction is in charge of initializing the new TransactionState to\nsane values, and properly initializing other subsystems (AtSubStart routines).\n\nWhen closing a subtransaction, either CommitSubTransaction has to be called\n(if the subtransaction is committing), or AbortSubTransaction and\nCleanupSubTransaction (if it's aborting).  In either case, PopTransaction is\ncalled so the system returns to the parent transaction.\n\nOne important point regarding subtransaction handling is that several may need\nto be closed in response to a single user command.  That's because savepoints\nhave names, and we allow to commit or rollback a savepoint by name, which is\nnot necessarily the one that was last opened.  Also a COMMIT or ROLLBACK\ncommand must be able to close out the entire stack.  We handle this by having\nthe utility command subroutine mark all the state stack entries as commit-\npending or abort-pending, and then when the main loop reaches\nCommitTransactionCommand, the real work is done.  The main point of doing\nthings this way is that if we get an error while popping state stack entries,\nthe remaining stack entries still show what we need to do to finish up.\n\nIn the case of ROLLBACK TO <savepoint>, we abort all the subtransactions up\nthrough the one identified by the savepoint name, and then re-create that\nsubtransaction level with the same name.  So it's a completely new\nsubtransaction as far as the internals are concerned.\n\nOther subsystems are allowed to start \"internal\" subtransactions, which are\nhandled by BeginInternalSubTransaction.  This is to allow implementing\nexception handling, e.g. in PL/pgSQL.  ReleaseCurrentSubTransaction and\nRollbackAndReleaseCurrentSubTransaction allows the subsystem to close said\nsubtransactions.  The main difference between this and the savepoint/release\npath is that we execute the complete state transition immediately in each\nsubroutine, rather than deferring some work until CommitTransactionCommand.\nAnother difference is that BeginInternalSubTransaction is allowed when no\nexplicit transaction block has been established, while DefineSavepoint is not.\n\n\nTransaction and Subtransaction Numbering\n----------------------------------------\n\nTransactions and subtransactions are assigned permanent XIDs only when/if\nthey first do something that requires one --- typically, insert/update/delete\na tuple, though there are a few other places that need an XID assigned.\nIf a subtransaction requires an XID, we always first assign one to its\nparent.  This maintains the invariant that child transactions have XIDs later\nthan their parents, which is assumed in a number of places.\n\nThe subsidiary actions of obtaining a lock on the XID and entering it into\npg_subtrans and PGPROC are done at the time it is assigned.\n\nA transaction that has no XID still needs to be identified for various\npurposes, notably holding locks.  For this purpose we assign a \"virtual\ntransaction ID\" or VXID to each top-level transaction.  VXIDs are formed from\ntwo fields, the procNumber and a backend-local counter; this arrangement\nallows assignment of a new VXID at transaction start without any contention\nfor shared memory.  To ensure that a VXID isn't re-used too soon after backend\nexit, we store the last local counter value into shared memory at backend\nexit, and initialize it from the previous value for the same PGPROC slot at\nbackend start.  All these counters go back to zero at shared memory\nre-initialization, but that's OK because VXIDs never appear anywhere on-disk.\n\nInternally, a backend needs a way to identify subtransactions whether or not\nthey have XIDs; but this need only lasts as long as the parent top transaction\nendures.  Therefore, we have SubTransactionId, which is somewhat like\nCommandId in that it's generated from a counter that we reset at the start of\neach top transaction.  The top-level transaction itself has SubTransactionId 1,\nand subtransactions have IDs 2 and up.  (Zero is reserved for\nInvalidSubTransactionId.)  Note that subtransactions do not have their\nown VXIDs; they use the parent top transaction's VXID.\n\n\nInterlocking Transaction Begin, Transaction End, and Snapshots\n--------------------------------------------------------------\n\nWe try hard to minimize the amount of overhead and lock contention involved\nin the frequent activities of beginning/ending a transaction and taking a\nsnapshot.  Unfortunately, we must have some interlocking for this, because\nwe must ensure consistency about the commit order of transactions.\nFor example, suppose an UPDATE in xact A is blocked by xact B's prior\nupdate of the same row, and xact B is doing commit while xact C gets a\nsnapshot.  Xact A can complete and commit as soon as B releases its locks.\nIf xact C's GetSnapshotData sees xact B as still running, then it had\nbetter see xact A as still running as well, or it will be able to see two\ntuple versions - one deleted by xact B and one inserted by xact A.  Another\nreason why this would be bad is that C would see (in the row inserted by A)\nearlier changes by B, and it would be inconsistent for C not to see any\nof B's changes elsewhere in the database.\n\nFormally, the correctness requirement is \"if a snapshot A considers\ntransaction X as committed, and any of transaction X's snapshots considered\ntransaction Y as committed, then snapshot A must consider transaction Y as\ncommitted\".\n\nWhat we actually enforce is strict serialization of commits and rollbacks\nwith snapshot-taking: we do not allow any transaction to exit the set of\nrunning transactions while a snapshot is being taken.  (This rule is\nstronger than necessary for consistency, but is relatively simple to\nenforce, and it assists with some other issues as explained below.)  The\nimplementation of this is that GetSnapshotData takes the ProcArrayLock in\nshared mode (so that multiple backends can take snapshots in parallel),\nbut ProcArrayEndTransaction must take the ProcArrayLock in exclusive mode\nwhile clearing the ProcGlobal->xids[] entry at transaction end (either\ncommit or abort). (To reduce context switching, when multiple transactions\ncommit nearly simultaneously, we have one backend take ProcArrayLock and\nclear the XIDs of multiple processes at once.)\n\nProcArrayEndTransaction also holds the lock while advancing the shared\nlatestCompletedXid variable.  This allows GetSnapshotData to use\nlatestCompletedXid + 1 as xmax for its snapshot: there can be no\ntransaction >= this xid value that the snapshot needs to consider as\ncompleted.\n\nIn short, then, the rule is that no transaction may exit the set of\ncurrently-running transactions between the time we fetch latestCompletedXid\nand the time we finish building our snapshot.  However, this restriction\nonly applies to transactions that have an XID --- read-only transactions\ncan end without acquiring ProcArrayLock, since they don't affect anyone\nelse's snapshot nor latestCompletedXid.\n\nTransaction start, per se, doesn't have any interlocking with these\nconsiderations, since we no longer assign an XID immediately at transaction\nstart.  But when we do decide to allocate an XID, GetNewTransactionId must\nstore the new XID into the shared ProcArray before releasing XidGenLock.\nThis ensures that all top-level XIDs <= latestCompletedXid are either\npresent in the ProcArray, or not running anymore.  (This guarantee doesn't\napply to subtransaction XIDs, because of the possibility that there's not\nroom for them in the subxid array; instead we guarantee that they are\npresent or the overflow flag is set.)  If a backend released XidGenLock\nbefore storing its XID into ProcGlobal->xids[], then it would be possible for\nanother backend to allocate and commit a later XID, causing latestCompletedXid\nto pass the first backend's XID, before that value became visible in the\nProcArray.  That would break ComputeXidHorizons, as discussed below.\n\nWe allow GetNewTransactionId to store the XID into ProcGlobal->xids[] (or the\nsubxid array) without taking ProcArrayLock.  This was once necessary to\navoid deadlock; while that is no longer the case, it's still beneficial for\nperformance.  We are thereby relying on fetch/store of an XID to be atomic,\nelse other backends might see a partially-set XID.  This also means that\nreaders of the ProcArray xid fields must be careful to fetch a value only\nonce, rather than assume they can read it multiple times and get the same\nanswer each time.  (Use volatile-qualified pointers when doing this, to\nensure that the C compiler does exactly what you tell it to.)\n\nAnother important activity that uses the shared ProcArray is\nComputeXidHorizons, which must determine a lower bound for the oldest xmin\nof any active MVCC snapshot, system-wide.  Each individual backend\nadvertises the smallest xmin of its own snapshots in MyProc->xmin, or zero\nif it currently has no live snapshots (eg, if it's between transactions or\nhasn't yet set a snapshot for a new transaction).  ComputeXidHorizons takes\nthe MIN() of the valid xmin fields.  It does this with only shared lock on\nProcArrayLock, which means there is a potential race condition against other\nbackends doing GetSnapshotData concurrently: we must be certain that a\nconcurrent backend that is about to set its xmin does not compute an xmin\nless than what ComputeXidHorizons determines.  We ensure that by including\nall the active XIDs into the MIN() calculation, along with the valid xmins.\nThe rule that transactions can't exit without taking exclusive ProcArrayLock\nensures that concurrent holders of shared ProcArrayLock will compute the\nsame minimum of currently-active XIDs: no xact, in particular not the\noldest, can exit while we hold shared ProcArrayLock.  So\nComputeXidHorizons's view of the minimum active XID will be the same as that\nof any concurrent GetSnapshotData, and so it can't produce an overestimate.\nIf there is no active transaction at all, ComputeXidHorizons uses\nlatestCompletedXid + 1, which is a lower bound for the xmin that might\nbe computed by concurrent or later GetSnapshotData calls.  (We know that no\nXID less than this could be about to appear in the ProcArray, because of the\nXidGenLock interlock discussed above.)\n\nAs GetSnapshotData is performance critical, it does not perform an accurate\noldest-xmin calculation (it used to, until v14). The contents of a snapshot\nonly depend on the xids of other backends, not their xmin. As backend's xmin\nchanges much more often than its xid, having GetSnapshotData look at xmins\ncan lead to a lot of unnecessary cacheline ping-pong.  Instead\nGetSnapshotData updates approximate thresholds (one that guarantees that all\ndeleted rows older than it can be removed, another determining that deleted\nrows newer than it can not be removed). GlobalVisTest* uses those thresholds\nto make invisibility decision, falling back to ComputeXidHorizons if\nnecessary.\n\nNote that while it is certain that two concurrent executions of\nGetSnapshotData will compute the same xmin for their own snapshots, there is\nno such guarantee for the horizons computed by ComputeXidHorizons.  This is\nbecause we allow XID-less transactions to clear their MyProc->xmin\nasynchronously (without taking ProcArrayLock), so one execution might see\nwhat had been the oldest xmin, and another not.  This is OK since the\nthresholds need only be a valid lower bound.  As noted above, we are already\nassuming that fetch/store of the xid fields is atomic, so assuming it for\nxmin as well is no extra risk.\n\n\npg_xact and pg_subtrans\n-----------------------\n\npg_xact and pg_subtrans are permanent (on-disk) storage of transaction related\ninformation.  There is a limited number of pages of each kept in memory, so\nin many cases there is no need to actually read from disk.  However, if\nthere's a long running transaction or a backend sitting idle with an open\ntransaction, it may be necessary to be able to read and write this information\nfrom disk.  They also allow information to be permanent across server restarts.\n\npg_xact records the commit status for each transaction that has been assigned\nan XID.  A transaction can be in progress, committed, aborted, or\n\"sub-committed\".  This last state means that it's a subtransaction that's no\nlonger running, but its parent has not updated its state yet.  It is not\nnecessary to update a subtransaction's transaction status to subcommit, so we\ncan just defer it until main transaction commit.  The main role of marking\ntransactions as sub-committed is to provide an atomic commit protocol when\ntransaction status is spread across multiple clog pages. As a result, whenever\ntransaction status spreads across multiple pages we must use a two-phase commit\nprotocol: the first phase is to mark the subtransactions as sub-committed, then\nwe mark the top level transaction and all its subtransactions committed (in\nthat order).  Thus, subtransactions that have not aborted appear as in-progress\neven when they have already finished, and the subcommit status appears as a\nvery short transitory state during main transaction commit.  Subtransaction\nabort is always marked in clog as soon as it occurs.  When the transaction\nstatus all fit in a single CLOG page, we atomically mark them all as committed\nwithout bothering with the intermediate sub-commit state.\n\nSavepoints are implemented using subtransactions.  A subtransaction is a\ntransaction inside a transaction; its commit or abort status is not only\ndependent on whether it committed itself, but also whether its parent\ntransaction committed.  To implement multiple savepoints in a transaction we\nallow unlimited transaction nesting depth, so any particular subtransaction's\ncommit state is dependent on the commit status of each and every ancestor\ntransaction.\n\nThe \"subtransaction parent\" (pg_subtrans) mechanism records, for each\ntransaction with an XID, the TransactionId of its parent transaction.  This\ninformation is stored as soon as the subtransaction is assigned an XID.\nTop-level transactions do not have a parent, so they leave their pg_subtrans\nentries set to the default value of zero (InvalidTransactionId).\n\npg_subtrans is used to check whether the transaction in question is still\nrunning --- the main Xid of a transaction is recorded in ProcGlobal->xids[],\nwith a copy in PGPROC->xid, but since we allow arbitrary nesting of\nsubtransactions, we can't fit all Xids in shared memory, so we have to store\nthem on disk.  Note, however, that for each transaction we keep a \"cache\" of\nXids that are known to be part of the transaction tree, so we can skip looking\nat pg_subtrans unless we know the cache has been overflowed.  See\nstorage/ipc/procarray.c for the gory details.\n\nslru.c is the supporting mechanism for both pg_xact and pg_subtrans.  It\nimplements the LRU policy for in-memory buffer pages.  The high-level routines\nfor pg_xact are implemented in transam.c, while the low-level functions are in\nclog.c.  pg_subtrans is contained completely in subtrans.c.\n\n\nWrite-Ahead Log Coding\n----------------------\n\nThe WAL subsystem (also called XLOG in the code) exists to guarantee crash\nrecovery.  It can also be used to provide point-in-time recovery, as well as\nhot-standby replication via log shipping.  Here are some notes about\nnon-obvious aspects of its design.\n\nA basic assumption of a write AHEAD log is that log entries must reach stable\nstorage before the data-page changes they describe.  This ensures that\nreplaying the log to its end will bring us to a consistent state where there\nare no partially-performed transactions.  To guarantee this, each data page\n(either heap or index) is marked with the LSN (log sequence number --- in\npractice, a WAL file location) of the latest XLOG record affecting the page.\nBefore the bufmgr can write out a dirty page, it must ensure that xlog has\nbeen flushed to disk at least up to the page's LSN.  This low-level\ninteraction improves performance by not waiting for XLOG I/O until necessary.\nThe LSN check exists only in the shared-buffer manager, not in the local\nbuffer manager used for temp tables; hence operations on temp tables must not\nbe WAL-logged.\n\nDuring WAL replay, we can check the LSN of a page to detect whether the change\nrecorded by the current log entry is already applied (it has been, if the page\nLSN is >= the log entry's WAL location).\n\nUsually, log entries contain just enough information to redo a single\nincremental update on a page (or small group of pages).  This will work only\nif the filesystem and hardware implement data page writes as atomic actions,\nso that a page is never left in a corrupt partly-written state.  Since that's\noften an untenable assumption in practice, we log additional information to\nallow complete reconstruction of modified pages.  The first WAL record\naffecting a given page after a checkpoint is made to contain a copy of the\nentire page, and we implement replay by restoring that page copy instead of\nredoing the update.  (This is more reliable than the data storage itself would\nbe because we can check the validity of the WAL record's CRC.)  We can detect\nthe \"first change after checkpoint\" by noting whether the page's old LSN\nprecedes the end of WAL as of the last checkpoint (the RedoRecPtr).\n\nThe general schema for executing a WAL-logged action is\n\n1. Pin and exclusive-lock the shared buffer(s) containing the data page(s)\nto be modified.\n\n2. START_CRIT_SECTION()  (Any error during the next three steps must cause a\nPANIC because the shared buffers will contain unlogged changes, which we\nhave to ensure don't get to disk.  Obviously, you should check conditions\nsuch as whether there's enough free space on the page before you start the\ncritical section.)\n\n3. Apply the required changes to the shared buffer(s).\n\n4. Mark the shared buffer(s) as dirty with MarkBufferDirty().  (This must\nhappen before the WAL record is inserted; see notes in SyncOneBuffer().)\nNote that marking a buffer dirty with MarkBufferDirty() should only\nhappen iff you write a WAL record; see Writing Hints below.\n\n5. If the relation requires WAL-logging, build a WAL record using\nXLogBeginInsert and XLogRegister* functions, and insert it.  (See\n\"Constructing a WAL record\" below).  Then update the page's LSN using the\nreturned XLOG location.  For instance,\n\n\t\tXLogBeginInsert();\n\t\tXLogRegisterBuffer(...)\n\t\tXLogRegisterData(...)\n\t\trecptr = XLogInsert(rmgr_id, info);\n\n\t\tPageSetLSN(dp, recptr);\n\n6. END_CRIT_SECTION()\n\n7. Unlock and unpin the buffer(s).\n\nComplex changes (such as a multilevel index insertion) normally need to be\ndescribed by a series of atomic-action WAL records.  The intermediate states\nmust be self-consistent, so that if the replay is interrupted between any\ntwo actions, the system is fully functional.  In btree indexes, for example,\na page split requires a new page to be allocated, and an insertion of a new\nkey in the parent btree level, but for locking reasons this has to be\nreflected by two separate WAL records.  Replaying the first record, to\nallocate the new page and move tuples to it, sets a flag on the page to\nindicate that the key has not been inserted to the parent yet.  Replaying the\nsecond record clears the flag.  This intermediate state is never seen by\nother backends during normal operation, because the lock on the child page\nis held across the two actions, but will be seen if the operation is\ninterrupted before writing the second WAL record.  The search algorithm works\nwith the intermediate state as normal, but if an insertion encounters a page\nwith the incomplete-split flag set, it will finish the interrupted split by\ninserting the key to the parent, before proceeding.\n\n\nConstructing a WAL record\n-------------------------\n\nA WAL record consists of a header common to all WAL record types,\nrecord-specific data, and information about the data blocks modified.  Each\nmodified data block is identified by an ID number, and can optionally have\nmore record-specific data associated with the block.  If XLogInsert decides\nthat a full-page image of a block needs to be taken, the data associated\nwith that block is not included.\n\nThe API for constructing a WAL record consists of five functions:\nXLogBeginInsert, XLogRegisterBuffer, XLogRegisterData, XLogRegisterBufData,\nand XLogInsert.  First, call XLogBeginInsert().  Then register all the buffers\nmodified, and data needed to replay the changes, using XLogRegister*\nfunctions.  Finally, insert the constructed record to the WAL by calling\nXLogInsert().\n\n\tXLogBeginInsert();\n\n\t/* register buffers modified as part of this WAL-logged action */\n\tXLogRegisterBuffer(0, lbuffer, REGBUF_STANDARD);\n\tXLogRegisterBuffer(1, rbuffer, REGBUF_STANDARD);\n\n\t/* register data that is always included in the WAL record */\n\tXLogRegisterData(&xlrec, SizeOfFictionalAction);\n\n\t/*\n\t * register data associated with a buffer. This will not be included\n\t * in the record if a full-page image is taken.\n\t */\n\tXLogRegisterBufData(0, tuple->data, tuple->len);\n\n\t/* more data associated with the buffer */\n\tXLogRegisterBufData(0, data2, len2);\n\n\t/*\n\t * Ok, all the data and buffers to include in the WAL record have\n\t * been registered. Insert the record.\n\t */\n\trecptr = XLogInsert(RM_FOO_ID, XLOG_FOOBAR_DO_STUFF);\n\nDetails of the API functions:\n\nvoid XLogBeginInsert(void)\n\n    Must be called before XLogRegisterBuffer and XLogRegisterData.\n\nvoid XLogResetInsertion(void)\n\n    Clear any currently registered data and buffers from the WAL record\n    construction workspace.  This is only needed if you have already called\n    XLogBeginInsert(), but decide to not insert the record after all.\n\nvoid XLogEnsureRecordSpace(int max_block_id, int ndatas)\n\n    Normally, the WAL record construction buffers have the following limits:\n\n    * highest block ID that can be used is 4 (allowing five block references)\n    * Max 20 chunks of registered data\n\n    These default limits are enough for most record types that change some\n    on-disk structures.  For the odd case that requires more data, or needs to\n    modify more buffers, these limits can be raised by calling\n    XLogEnsureRecordSpace().  XLogEnsureRecordSpace() must be called before\n    XLogBeginInsert(), and outside a critical section.\n\nvoid XLogRegisterBuffer(uint8 block_id, Buffer buf, uint8 flags);\n\n    XLogRegisterBuffer adds information about a data block to the WAL record.\n    block_id is an arbitrary number used to identify this page reference in\n    the redo routine.  The information needed to re-find the page at redo -\n    relfilelocator, fork, and block number - are included in the WAL record.\n\n    XLogInsert will automatically include a full copy of the page contents, if\n    this is the first modification of the buffer since the last checkpoint.\n    It is important to register every buffer modified by the action with\n    XLogRegisterBuffer, to avoid torn-page hazards.\n\n    The flags control when and how the buffer contents are included in the\n    WAL record.  Normally, a full-page image is taken only if the page has not\n    been modified since the last checkpoint, and only if full_page_writes=on\n    or an online backup is in progress.  The REGBUF_FORCE_IMAGE flag can be\n    used to force a full-page image to always be included; that is useful\n    e.g. for an operation that rewrites most of the page, so that tracking the\n    details is not worth it.  For the rare case where it is not necessary to\n    protect from torn pages, REGBUF_NO_IMAGE flag can be used to suppress\n    full page image from being taken.  REGBUF_WILL_INIT also suppresses a full\n    page image, but the redo routine must re-generate the page from scratch,\n    without looking at the old page contents.  Re-initializing the page\n    protects from torn page hazards like a full page image does.\n\n    The REGBUF_STANDARD flag can be specified together with the other flags to\n    indicate that the page follows the standard page layout.  It causes the\n    area between pd_lower and pd_upper to be left out from the image, reducing\n    WAL volume.\n\n    If the REGBUF_KEEP_DATA flag is given, any per-buffer data registered with\n    XLogRegisterBufData() is included in the WAL record even if a full-page\n    image is taken.\n\nvoid XLogRegisterData(char *data, int len);\n\n    XLogRegisterData is used to include arbitrary data in the WAL record.  If\n    XLogRegisterData() is called multiple times, the data are appended, and\n    will be made available to the redo routine as one contiguous chunk.\n\nvoid XLogRegisterBufData(uint8 block_id, char *data, int len);\n\n    XLogRegisterBufData is used to include data associated with a particular\n    buffer that was registered earlier with XLogRegisterBuffer().  If\n    XLogRegisterBufData() is called multiple times with the same block ID, the\n    data are appended, and will be made available to the redo routine as one\n    contiguous chunk.\n\n    If a full-page image of the buffer is taken at insertion, the data is not\n    included in the WAL record, unless the REGBUF_KEEP_DATA flag is used.\n\n\nWriting a REDO routine\n----------------------\n\nA REDO routine uses the data and page references included in the WAL record\nto reconstruct the new state of the page.  The record decoding functions\nand macros in xlogreader.c/h can be used to extract the data from the record.\n\nWhen replaying a WAL record that describes changes on multiple pages, you\nmust be careful to lock the pages properly to prevent concurrent Hot Standby\nqueries from seeing an inconsistent state.  If this requires that two\nor more buffer locks be held concurrently, you must lock the pages in\nappropriate order, and not release the locks until all the changes are done.\n\nNote that we must only use PageSetLSN/PageGetLSN() when we know the action\nis serialised. Only Startup process may modify data blocks during recovery,\nso Startup process may execute PageGetLSN() without fear of serialisation\nproblems. All other processes must only call PageSet/GetLSN when holding\neither an exclusive buffer lock or a shared lock plus buffer header lock,\nor be writing the data block directly rather than through shared buffers\nwhile holding AccessExclusiveLock on the relation.\n\n\nWriting Hints\n-------------\n\nIn some cases, we write additional information to data blocks without\nwriting a preceding WAL record. This should only happen iff the data can\nbe reconstructed later following a crash and the action is simply a way\nof optimising for performance. When a hint is written we use\nMarkBufferDirtyHint() to mark the block dirty.\n\nIf the buffer is clean and checksums are in use then MarkBufferDirtyHint()\ninserts an XLOG_FPI_FOR_HINT record to ensure that we take a full page image\nthat includes the hint. We do this to avoid a partial page write, when we\nwrite the dirtied page. WAL is not written during recovery, so we simply skip\ndirtying blocks because of hints when in recovery.\n\nIf you do decide to optimise away a WAL record, then any calls to\nMarkBufferDirty() must be replaced by MarkBufferDirtyHint(),\notherwise you will expose the risk of partial page writes.\n\nThe all-visible hint in a heap page (PD_ALL_VISIBLE) is a special\ncase, because it is treated like a durable change in some respects and\na hint in other respects. It must satisfy the invariant that, if a\nheap page's associated visibilitymap (VM) bit is set, then\nPD_ALL_VISIBLE is set on the heap page itself. Clearing of\nPD_ALL_VISIBLE is always treated like a fully-durable change to\nmaintain this invariant. Additionally, if checksums or wal_log_hints\nare enabled, setting PD_ALL_VISIBLE is also treated like a\nfully-durable change to protect against torn pages.\n\nBut, if neither checksums nor wal_log_hints are enabled, torn pages\nare of no consequence if the only change is to PD_ALL_VISIBLE; so no\nfull heap page image is taken, and the heap page's LSN is not\nupdated. NB: it would be incorrect to update the heap page's LSN when\napplying this optimization, even though there is an associated WAL\nrecord, because subsequent modifiers (e.g. an unrelated UPDATE) of the\npage may falsely believe that a full page image is not required.\n\nWrite-Ahead Logging for Filesystem Actions\n------------------------------------------\n\nThe previous section described how to WAL-log actions that only change page\ncontents within shared buffers.  For that type of action it is generally\npossible to check all likely error cases (such as insufficient space on the\npage) before beginning to make the actual change.  Therefore we can make\nthe change and the creation of the associated WAL log record \"atomic\" by\nwrapping them into a critical section --- the odds of failure partway\nthrough are low enough that PANIC is acceptable if it does happen.\n\nClearly, that approach doesn't work for cases where there's a significant\nprobability of failure within the action to be logged, such as creation\nof a new file or database.  We don't want to PANIC, and we especially don't\nwant to PANIC after having already written a WAL record that says we did\nthe action --- if we did, replay of the record would probably fail again\nand PANIC again, making the failure unrecoverable.  This means that the\nordinary WAL rule of \"write WAL before the changes it describes\" doesn't\nwork, and we need a different design for such cases.\n\nThere are several basic types of filesystem actions that have this\nissue.  Here is how we deal with each:\n\n1. Adding a disk page to an existing table.\n\nThis action isn't WAL-logged at all.  We extend a table by writing a page\nof zeroes at its end.  We must actually do this write so that we are sure\nthe filesystem has allocated the space.  If the write fails we can just\nerror out normally.  Once the space is known allocated, we can initialize\nand fill the page via one or more normal WAL-logged actions.  Because it's\npossible that we crash between extending the file and writing out the WAL\nentries, we have to treat discovery of an all-zeroes page in a table or\nindex as being a non-error condition.  In such cases we can just reclaim\nthe space for re-use.\n\n2. Creating a new table, which requires a new file in the filesystem.\n\nWe try to create the file, and if successful we make a WAL record saying\nwe did it.  If not successful, we can just throw an error.  Notice that\nthere is a window where we have created the file but not yet written any\nWAL about it to disk.  If we crash during this window, the file remains\non disk as an \"orphan\".  It would be possible to clean up such orphans\nby having database restart search for files that don't have any committed\nentry in pg_class, but that currently isn't done because of the possibility\nof deleting data that is useful for forensic analysis of the crash.\nOrphan files are harmless --- at worst they waste a bit of disk space ---\nbecause we check for on-disk collisions when allocating new relfilenumber\nOIDs.  So cleaning up isn't really necessary.\n\n3. Deleting a table, which requires an unlink() that could fail.\n\nOur approach here is to WAL-log the operation first, but to treat failure\nof the actual unlink() call as a warning rather than error condition.\nAgain, this can leave an orphan file behind, but that's cheap compared to\nthe alternatives.  Since we can't actually do the unlink() until after\nwe've committed the DROP TABLE transaction, throwing an error would be out\nof the question anyway.  (It may be worth noting that the WAL entry about\nthe file deletion is actually part of the commit record for the dropping\ntransaction.)\n\n4. Creating and deleting databases and tablespaces, which requires creating\nand deleting directories and entire directory trees.\n\nThese cases are handled similarly to creating individual files, ie, we\ntry to do the action first and then write a WAL entry if it succeeded.\nThe potential amount of wasted disk space is rather larger, of course.\nIn the creation case we try to delete the directory tree again if creation\nfails, so as to reduce the risk of wasted space.  Failure partway through\na deletion operation results in a corrupt database: the DROP failed, but\nsome of the data is gone anyway.  There is little we can do about that,\nthough, and in any case it was presumably data the user no longer wants.\n\nIn all of these cases, if WAL replay fails to redo the original action\nwe must panic and abort recovery.  The DBA will have to manually clean up\n(for instance, free up some disk space or fix directory permissions) and\nthen restart recovery.  This is part of the reason for not writing a WAL\nentry until we've successfully done the original action.\n\n\nSkipping WAL for New RelFileLocator\n--------------------------------\n\nUnder wal_level=minimal, if a change modifies a relfilenumber that ROLLBACK\nwould unlink, in-tree access methods write no WAL for that change.  Code that\nwrites WAL without calling RelationNeedsWAL() must check for this case.  This\nskipping is mandatory.  If a WAL-writing change preceded a WAL-skipping change\nfor the same block, REDO could overwrite the WAL-skipping change.  If a\nWAL-writing change followed a WAL-skipping change for the same block, a\nrelated problem would arise.  When a WAL record contains no full-page image,\nREDO expects the page to match its contents from just before record insertion.\nA WAL-skipping change may not reach disk at all, violating REDO's expectation\nunder full_page_writes=off.  For any access method, CommitTransaction() writes\nand fsyncs affected blocks before recording the commit.\n\nPrefer to do the same in future access methods.  However, two other approaches\ncan work.  First, an access method can irreversibly transition a given fork\nfrom WAL-skipping to WAL-writing by calling FlushRelationBuffers() and\nsmgrimmedsync().  Second, an access method can opt to write WAL\nunconditionally for permanent relations.  Under these approaches, the access\nmethod callbacks must not call functions that react to RelationNeedsWAL().\n\nThis applies only to WAL records whose replay would modify bytes stored in the\nnew relfilenumber.  It does not apply to other records about the relfilenumber,\nsuch as XLOG_SMGR_CREATE.  Because it operates at the level of individual\nrelfilenumbers, RelationNeedsWAL() can differ for tightly-coupled relations.\nConsider \"CREATE TABLE t (); BEGIN; ALTER TABLE t ADD c text; ...\" in which\nALTER TABLE adds a TOAST relation.  The TOAST relation will skip WAL, while\nthe table owning it will not.  ALTER TABLE SET TABLESPACE will cause a table\nto skip WAL, but that won't affect its indexes.\n\n\nAsynchronous Commit\n-------------------\n\nAs of PostgreSQL 8.3 it is possible to perform asynchronous commits - i.e.,\nwe don't wait while the WAL record for the commit is fsync'ed.\nWe perform an asynchronous commit when synchronous_commit = off.  Instead\nof performing an XLogFlush() up to the LSN of the commit, we merely note\nthe LSN in shared memory.  The backend then continues with other work.\nWe record the LSN only for an asynchronous commit, not an abort; there's\nnever any need to flush an abort record, since the presumption after a\ncrash would be that the transaction aborted anyway.\n\nWe always force synchronous commit when the transaction is deleting\nrelations, to ensure the commit record is down to disk before the relations\nare removed from the filesystem.  Also, certain utility commands that have\nnon-roll-backable side effects (such as filesystem changes) force sync\ncommit to minimize the window in which the filesystem change has been made\nbut the transaction isn't guaranteed committed.\n\nThe walwriter regularly wakes up (via wal_writer_delay) or is woken up\n(via its latch, which is set by backends committing asynchronously) and\nperforms an XLogBackgroundFlush().  This checks the location of the last\ncompletely filled WAL page.  If that has moved forwards, then we write all\nthe changed buffers up to that point, so that under full load we write\nonly whole buffers.  If there has been a break in activity and the current\nWAL page is the same as before, then we find out the LSN of the most\nrecent asynchronous commit, and write up to that point, if required (i.e.\nif it's in the current WAL page).  If more than wal_writer_delay has\npassed, or more than wal_writer_flush_after blocks have been written, since\nthe last flush, WAL is also flushed up to the current location.  This\narrangement in itself would guarantee that an async commit record reaches\ndisk after at most two times wal_writer_delay after the transaction\ncompletes. However, we also allow XLogFlush to write/flush full buffers\n\"flexibly\" (ie, not wrapping around at the end of the circular WAL buffer\narea), so as to minimize the number of writes issued under high load when\nmultiple WAL pages are filled per walwriter cycle. This makes the worst-case\ndelay three wal_writer_delay cycles.\n\nThere are some other subtle points to consider with asynchronous commits.\nFirst, for each page of CLOG we must remember the LSN of the latest commit\naffecting the page, so that we can enforce the same flush-WAL-before-write\nrule that we do for ordinary relation pages.  Otherwise the record of the\ncommit might reach disk before the WAL record does.  Again, abort records\nneed not factor into this consideration.\n\nIn fact, we store more than one LSN for each clog page.  This relates to\nthe way we set transaction status hint bits during visibility tests.\nWe must not set a transaction-committed hint bit on a relation page and\nhave that record make it to disk prior to the WAL record of the commit.\nSince visibility tests are normally made while holding buffer share locks,\nwe do not have the option of changing the page's LSN to guarantee WAL\nsynchronization.  Instead, we defer the setting of the hint bit if we have\nnot yet flushed WAL as far as the LSN associated with the transaction.\nThis requires tracking the LSN of each unflushed async commit.  It is\nconvenient to associate this data with clog buffers: because we will flush\nWAL before writing a clog page, we know that we do not need to remember a\ntransaction's LSN longer than the clog page holding its commit status\nremains in memory.  However, the naive approach of storing an LSN for each\nclog position is unattractive: the LSNs are 32x bigger than the two-bit\ncommit status fields, and so we'd need 256K of additional shared memory for\neach 8K clog buffer page.  We choose instead to store a smaller number of\nLSNs per page, where each LSN is the highest LSN associated with any\ntransaction commit in a contiguous range of transaction IDs on that page.\nThis saves storage at the price of some possibly-unnecessary delay in\nsetting transaction hint bits.\n\nHow many transactions should share the same cached LSN (N)?  If the\nsystem's workload consists only of small async-commit transactions, then\nit's reasonable to have N similar to the number of transactions per\nwalwriter cycle, since that is the granularity with which transactions will\nbecome truly committed (and thus hintable) anyway.  The worst case is where\na sync-commit xact shares a cached LSN with an async-commit xact that\ncommits a bit later; even though we paid to sync the first xact to disk,\nwe won't be able to hint its outputs until the second xact is sync'd, up to\nthree walwriter cycles later.  This argues for keeping N (the group size)\nas small as possible.  For the moment we are setting the group size to 32,\nwhich makes the LSN cache space the same size as the actual clog buffer\nspace (independently of BLCKSZ).\n\nIt is useful that we can run both synchronous and asynchronous commit\ntransactions concurrently, but the safety of this is perhaps not\nimmediately obvious.  Assume we have two transactions, T1 and T2.  The Log\nSequence Number (LSN) is the point in the WAL sequence where a transaction\ncommit is recorded, so LSN1 and LSN2 are the commit records of those\ntransactions.  If T2 can see changes made by T1 then when T2 commits it\nmust be true that LSN2 follows LSN1.  Thus when T2 commits it is certain\nthat all of the changes made by T1 are also now recorded in the WAL.  This\nis true whether T1 was asynchronous or synchronous.  As a result, it is\nsafe for asynchronous commits and synchronous commits to work concurrently\nwithout endangering data written by synchronous commits.  Sub-transactions\nare not important here since the final write to disk only occurs at the\ncommit of the top level transaction.\n\nChanges to data blocks cannot reach disk unless WAL is flushed up to the\npoint of the LSN of the data blocks.  Any attempt to write unsafe data to\ndisk will trigger a write which ensures the safety of all data written by\nthat and prior transactions.  Data blocks and clog pages are both protected\nby LSNs.\n\nChanges to a temp table are not WAL-logged, hence could reach disk in\nadvance of T1's commit, but we don't care since temp table contents don't\nsurvive crashes anyway.\n\nDatabase writes that skip WAL for new relfilenumbers are also safe.  In these\ncases it's entirely possible for the data to reach disk before T1's commit,\nbecause T1 will fsync it down to disk without any sort of interlock.  However,\nall these paths are designed to write data that no other transaction can see\nuntil after T1 commits.  The situation is thus not different from ordinary\nWAL-logged updates.\n\nTransaction Emulation during Recovery\n-------------------------------------\n\nDuring Recovery we replay transaction changes in the order they occurred.\nAs part of this replay we emulate some transactional behaviour, so that\nread only backends can take MVCC snapshots. We do this by maintaining a\nlist of XIDs belonging to transactions that are being replayed, so that\neach transaction that has recorded WAL records for database writes exist\nin the array until it commits. Further details are given in comments in\nprocarray.c.\n\nMany actions write no WAL records at all, for example read only transactions.\nThese have no effect on MVCC in recovery and we can pretend they never\noccurred at all. Subtransaction commit does not write a WAL record either\nand has very little effect, since lock waiters need to wait for the\nparent transaction to complete.\n\nNot all transactional behaviour is emulated, for example we do not insert\na transaction entry into the lock table, nor do we maintain the transaction\nstack in memory. Clog, multixact and commit_ts entries are made normally.\nSubtrans is maintained during recovery but the details of the transaction\ntree are ignored and all subtransactions reference the top-level TransactionId\ndirectly. Since commit is atomic this provides correct lock wait behaviour\nyet simplifies emulation of subtransactions considerably.\n\nFurther details on locking mechanics in recovery are given in comments\nwith the Lock rmgr code.","count":120},{"name":"subsystem-name","value":"transam","count":120},{"name":"subsystem-path","value":"backend/access/transam/readme","count":120},{"name":"tested-by","value":"check_simple_rowfilter_expr_walker, check_functions_in_node","count":120},{"name":"tested-by","value":"heap_get_latest_tid, _bt_check_unique, _bt_check_unique, check_exclusion_or_unique_constraint, check_exclusion_or_unique_constraint, GlobalVisTestShouldUpdate","count":120},{"name":"api-caller-count","value":"512","count":116},{"name":"api-caller-count","value":"65","count":116},{"name":"api-typical-usage","value":"Often called from: AlterObjectRename_internal","count":116},{"name":"api-typical-usage","value":"Often called from: get_controlfile_by_exact_path","count":116},{"name":"api-typical-usage","value":"Often called from: gist_box_picksplit","count":116},{"name":"cyclomatic-complexity","value":"48","count":116},{"name":"cyclomatic-complexity","value":"51","count":116},{"name":"lines-of-code","value":"113","count":116},{"name":"tested-by","value":"check_db_file_conflict, check_db_file_conflict, check_of_type","count":116},{"name":"tested-by","value":"check_index_is_clusterable, check_of_type, check_default_partition_contents, check_default_partition_contents, check_default_partition_contents, check_default_partition_contents","count":116},{"name":"tested-by","value":"pg_atomic_test_set_flag_impl, check_and_set_sync_info","count":116},{"name":"api-example","value":"bytea * brinoptions(Datum reloptions, bool validate) { static const relopt_parse_elt tab[] = { {\"pages_per_range\", RELOPT_TYPE_INT, offsetof(BrinOptions, pagesPerRange)}, {\"autosummarize\", RELOPT_TYPE...","count":114},{"name":"api-example","value":"static void printatt(unsigned attributeId, Form_pg_attribute attributeP, char *value) { printf(\"\\t%2d: %s%s%s%s\\t(typeid = %u, len = %d, typmod = %d, byval = %c)\\n\", attributeId, NameStr(attributeP->a...","count":114},{"name":"api-caller-count","value":"48","count":112},{"name":"api-caller-count","value":"61","count":112},{"name":"api-typical-usage","value":"Often called from: AddWaitEventToSet","count":112},{"name":"api-typical-usage","value":"Often called from: DecodeInterval","count":112},{"name":"api-typical-usage","value":"Often called from: InitWalRecovery","count":112},{"name":"api-typical-usage","value":"Often called from: TransactionGroupUpdateXidStatus","count":112},{"name":"api-typical-usage","value":"Often called from: pg_class_aclmask_ext","count":112},{"name":"api-typical-usage","value":"Often called from: silly_cmp_tsvector","count":112},{"name":"arch-layer","value":"query-executor","count":112},{"name":"arch-layer-description","value":"Query execution and commands","count":112},{"name":"coupling-score","value":"21","count":112},{"name":"cyclomatic-complexity","value":"45","count":112},{"name":"lines-of-code","value":"103","count":112},{"name":"lines-of-code","value":"106","count":112},{"name":"lines-of-code","value":"125","count":112},{"name":"tested-by","value":"check_default_table_access_method, check_default_table_access_method","count":112},{"name":"tested-by","value":"is_bounding_box_test_exact","count":112},{"name":"tested-by","value":"pg_atomic_test_set_flag_impl, check_and_set_sync_info, check_and_set_sync_info, check_and_set_sync_info","count":112},{"name":"api-example","value":"TM_Result heap_delete(Relation relation, ItemPointer tid, CommandId cid, Snapshot crosscheck, bool wait, TM_FailureData *tmfd, bool changingPart) { TM_Result\tresult; TransactionId xid = GetCurrentTran...","count":111},{"name":"api-example","value":"static BlockNumber count_nondeletable_pages(LVRelState *vacrel, bool *lock_waiter_detected) { BlockNumber blkno; BlockNumber prefetchedUntil; instr_time\tstarttime; INSTR_TIME_SET_CURRENT(starttime); *...","count":111},{"name":"api-example","value":"void writeTimeLineHistory(TimeLineID newTLI, TimeLineID parentTLI, XLogRecPtr switchpoint, char *reason) { char\t\tpath[MAXPGPATH]; char\t\ttmppath[MAXPGPATH]; char\t\thistfname[MAXFNAMELEN]; char\t\tbuffer[B...","count":111},{"name":"subsystem-desc","value":"src/backend/access/rmgrdesc/README\n\nWAL resource manager description functions\n==========================================\n\nFor debugging purposes, there is a \"description function\", or rmgrdesc\nfunction, for each WAL resource manager. The rmgrdesc function parses the WAL\nrecord and prints the contents of the WAL record in a somewhat human-readable\nformat.\n\nThe rmgrdesc functions for all resource managers are gathered in this\ndirectory, because they are also used in the stand-alone pg_waldump program.\nThey could potentially be used by out-of-tree debugging tools too, although\nneither the description functions nor the output format should be considered\npart of a stable API\n\nGuidelines for rmgrdesc output format\n-------------------------------------\n\nThe goal of these guidelines is to avoid gratuitous inconsistencies across\neach rmgr, and to allow users to parse desc output strings without too much\ndifficulty.  This is not an API specification or an interchange format.\n(Only heapam and nbtree desc routines follow these guidelines at present, in\nany case.)\n\nRecord descriptions are similar to JSON style key/value objects.  However,\nthere is no explicit \"string\" type/string escaping.  Top-level { } brackets\nshould be omitted.  For example:\n\nsnapshotConflictHorizon: 0, flags: 0x03\n\nRecord descriptions may contain variable-length arrays.  For example:\n\nnunused: 5, unused: [1, 2, 3, 4, 5]\n\nNested objects are supported via { } brackets.  They generally appear inside\nvariable-length arrays.  For example:\n\nndeleted: 0, nupdated: 1, deleted: [], updated: [{ off: 45, nptids: 1, ptids: [0] }]\n\nTry to output things in an order that faithfully represents the order of\nfields from the underlying physical WAL record struct.  Key names should be\nunique (at the same nesting level) to make parsing easy.  It's a good idea if\nthe number of items in the array appears before the array.\n\nIt's okay for individual WAL record types to invent their own conventions.\nFor example, Heap2's PRUNE record descriptions use a custom array format for\nthe record's \"redirected\" field:\n\n... redirected: [1->4, 5->9], dead: [10, 11], unused: [3, 7, 8]\n\nArguably the desc routine should be using object notation for this instead.\nHowever, there is value in using a custom format when it conveys useful\ninformation about the underlying physical data structures.\n\nThis ad-hoc format has the advantage of being close to the format used for\nthe \"dead\" and \"unused\" arrays (which follow the standard desc convention for\npage offset number arrays).  It suggests that the \"redirected\" elements shown\nare just pairs of page offset numbers (which is how it really works).\n\nrmgrdesc_utils.c contains some helper functions to print data in this format.","count":110},{"name":"subsystem-desc","value":"src/backend/replication/README\n\nWalreceiver - libpqwalreceiver API\n----------------------------------\n\nThe transport-specific part of walreceiver, responsible for connecting to\nthe primary server, receiving WAL files and sending messages, is loaded\ndynamically to avoid having to link the main server binary with libpq.\nThe dynamically loaded module is in libpqwalreceiver subdirectory.\n\nThe dynamically loaded module implements a set of functions with details\nabout each one of them provided in src/include/replication/walreceiver.h.\n\nThis API should be considered internal at the moment, but we could open it\nup for 3rd party replacements of libpqwalreceiver in the future, allowing\npluggable methods for receiving WAL.\n\nWalreceiver IPC\n---------------\n\nWhen the WAL replay in startup process has reached the end of archived WAL,\nrestorable using restore_command, it starts up the walreceiver process\nto fetch more WAL (if streaming replication is configured).\n\nWalreceiver is a postmaster subprocess, so the startup process can't fork it\ndirectly. Instead, it sends a signal to postmaster, asking postmaster to launch\nit. Before that, however, startup process fills in WalRcvData->conninfo\nand WalRcvData->slotname, and initializes the starting point in\nWalRcvData->receiveStart.\n\nAs walreceiver receives WAL from the primary server, and writes and flushes\nit to disk (in pg_wal), it updates WalRcvData->flushedUpto and signals\nthe startup process to know how far WAL replay can advance.\n\nWalreceiver sends information about replication progress to the primary server\nwhenever it either writes or flushes new WAL, or the specified interval elapses.\nThis is used for reporting purpose.\n\nWalsender IPC\n-------------\n\nAt shutdown, postmaster handles walsender processes differently from regular\nbackends. It waits for regular backends to die before writing the\nshutdown checkpoint and terminating pgarch and other auxiliary processes, but\nthat's not desirable for walsenders, because we want the standby servers to\nreceive all the WAL, including the shutdown checkpoint, before the primary\nis shut down. Therefore postmaster treats walsenders like the pgarch process,\nand instructs them to terminate at PM_SHUTDOWN_2 phase, after all regular\nbackends have died and checkpointer has issued the shutdown checkpoint.\n\nWhen postmaster accepts a connection, it immediately forks a new process\nto handle the handshake and authentication, and the process initializes to\nbecome a backend. Postmaster doesn't know if the process becomes a regular\nbackend or a walsender process at that time - that's indicated in the\nconnection handshake - so we need some extra signaling to let postmaster\nidentify walsender processes.\n\nWhen walsender process starts up, it marks itself as a walsender process in\nthe PMSignal array. That way postmaster can tell it apart from regular\nbackends.\n\nNote that no big harm is done if postmaster thinks that a walsender is a\nregular backend; it will just terminate the walsender earlier in the shutdown\nphase. A walsender will look like a regular backend until it's done with the\ninitialization and has marked itself in PMSignal array, and at process\ntermination, after unmarking the PMSignal slot.\n\nEach walsender allocates an entry from the WalSndCtl array, and tracks\ninformation about replication progress. User can monitor them via\nstatistics views.\n\n\nWalsender - walreceiver protocol\n--------------------------------\n\nSee manual.","count":110},{"name":"subsystem-name","value":"replication","count":110},{"name":"subsystem-name","value":"rmgrdesc","count":110},{"name":"subsystem-path","value":"backend/access/rmgrdesc/readme","count":110},{"name":"subsystem-path","value":"backend/replication/readme","count":110},{"name":"api-caller-count","value":"100","count":108},{"name":"api-caller-count","value":"101","count":108},{"name":"api-caller-count","value":"114","count":108},{"name":"api-caller-count","value":"157","count":108},{"name":"api-caller-count","value":"235","count":108},{"name":"api-caller-count","value":"268","count":108},{"name":"api-caller-count","value":"79","count":108},{"name":"api-caller-count","value":"89","count":108},{"name":"api-example","value":"static void refresh_by_match_merge(Oid matviewOid, Oid tempOid, Oid relowner, int save_sec_context) { StringInfoData querybuf; Relation\tmatviewRel; Relation\ttempRel; char\t   *matviewname; char\t   *tem...","count":108},{"name":"api-example","value":"void brinbuildempty(Relation index) { Buffer\t\tmetabuf; metabuf = ExtendBufferedRel(BMR_REL(index), INIT_FORKNUM, NULL, EB_LOCK_FIRST | EB_SKIP_EXTENSION_LOCK); START_CRIT_SECTION(); brin_metapage_init...","count":108},{"name":"api-typical-usage","value":"Often called from: heap_identify","count":108},{"name":"api-typical-usage","value":"Often called from: show_all_settings","count":108},{"name":"coupling-score","value":"22","count":108},{"name":"lines-of-code","value":"131","count":108},{"name":"test-count","value":"11","count":108},{"name":"tested-by","value":"_bt_check_unique, _bt_check_unique, _bt_check_unique, _bt_check_unique, _bt_check_unique, _bt_check_unique, _bt_check_unique, _bt_check_unique","count":108},{"name":"tested-by","value":"check_functional_grouping, check_index_only","count":108},{"name":"tested-by","value":"check_publications, check_publications_origin","count":108},{"name":"tested-by","value":"test_open, test_sync, test_sync, test_file_descriptor_sync, test_file_descriptor_sync, test_file_descriptor_sync, test_file_descriptor_sync, test_non_sync","count":108},{"name":"api-example","value":"void SendRowDescriptionMessage(StringInfo buf, TupleDesc typeinfo, List *targetlist, int16 *formats) { int\t\t\tnatts = typeinfo->natts; int\t\t\ti; ListCell   *tlist_item = list_head(targetlist); pq_beginm...","count":105},{"name":"subsystem-desc","value":"What is Just-in-Time Compilation?\n=================================\n\nJust-in-Time compilation (JIT) is the process of turning some form of\ninterpreted program evaluation into a native program, and doing so at\nruntime.\n\nFor example, instead of using a facility that can evaluate arbitrary\nSQL expressions to evaluate an SQL predicate like WHERE a.col = 3, it\nis possible to generate a function than can be natively executed by\nthe CPU that just handles that expression, yielding a speedup.\n\nThis is JIT, rather than ahead-of-time (AOT) compilation, because it\nis done at query execution time, and perhaps only in cases where the\nrelevant task is repeated a number of times. Given the way JIT\ncompilation is used in PostgreSQL, the lines between interpretation,\nAOT and JIT are somewhat blurry.\n\nNote that the interpreted program turned into a native program does\nnot necessarily have to be a program in the classical sense. E.g. it\nis highly beneficial to JIT compile tuple deforming into a native\nfunction just handling a specific type of table, despite tuple\ndeforming not commonly being understood as a \"program\".\n\n\nWhy JIT?\n========\n\nParts of PostgreSQL are commonly bottlenecked by comparatively small\npieces of CPU intensive code. In a number of cases that is because the\nrelevant code has to be very generic (e.g. handling arbitrary SQL\nlevel expressions, over arbitrary tables, with arbitrary extensions\ninstalled). This often leads to a large number of indirect jumps and\nunpredictable branches, and generally a high number of instructions\nfor a given task. E.g. just evaluating an expression comparing a\ncolumn in a database to an integer ends up needing several hundred\ncycles.\n\nBy generating native code large numbers of indirect jumps can be\nremoved by either making them into direct branches (e.g. replacing the\nindirect call to an SQL operator's implementation with a direct call\nto that function), or by removing it entirely (e.g. by evaluating the\nbranch at compile time because the input is constant). Similarly a lot\nof branches can be entirely removed (e.g. by again evaluating the\nbranch at compile time because the input is constant). The latter is\nparticularly beneficial for removing branches during tuple deforming.\n\n\nHow to JIT\n==========\n\nPostgreSQL, by default, uses LLVM to perform JIT. LLVM was chosen\nbecause it is developed by several large corporations and therefore\nunlikely to be discontinued, because it has a license compatible with\nPostgreSQL, and because its IR can be generated from C using the Clang\ncompiler.\n\n\nShared Library Separation\n-------------------------\n\nTo avoid the main PostgreSQL binary directly depending on LLVM, which\nwould prevent LLVM support being independently installed by OS package\nmanagers, the LLVM dependent code is located in a shared library that\nis loaded on-demand.\n\nAn additional benefit of doing so is that it is relatively easy to\nevaluate JIT compilation that does not use LLVM, by changing out the\nshared library used to provide JIT compilation.\n\nTo achieve this, code intending to perform JIT (e.g. expression evaluation)\ncalls an LLVM independent wrapper located in jit.c to do so. If the\nshared library providing JIT support can be loaded (i.e. PostgreSQL was\ncompiled with LLVM support and the shared library is installed), the task\nof JIT compiling an expression gets handed off to the shared library. This\nobviously requires that the function in jit.c is allowed to fail in case\nno JIT provider can be loaded.\n\nWhich shared library is loaded is determined by the jit_provider GUC,\ndefaulting to \"llvmjit\".\n\nCloistering code performing JIT into a shared library unfortunately\nalso means that code doing JIT compilation for various parts of code\nhas to be located separately from the code doing so without\nJIT. E.g. the JIT version of execExprInterp.c is located in jit/llvm/\nrather than executor/.\n\n\nJIT Context\n-----------\n\nFor performance and convenience reasons it is useful to allow JITed\nfunctions to be emitted and deallocated together. It is e.g. very\ncommon to create a number of functions at query initialization time,\nuse them during query execution, and then deallocate all of them\ntogether at the end of the query.\n\nLifetimes of JITed functions are managed via JITContext. Exactly one\nsuch context should be created for work in which all created JITed\nfunction should have the same lifetime. E.g. there's exactly one\nJITContext for each query executed, in the query's EState.  Only the\nrelease of a JITContext is exposed to the provider independent\nfacility, as the creation of one is done on-demand by the JIT\nimplementations.\n\nEmitting individual functions separately is more expensive than\nemitting several functions at once, and emitting them together can\nprovide additional optimization opportunities. To facilitate that, the\nLLVM provider separates defining functions from optimizing and\nemitting functions in an executable manner.\n\nCreating functions into the current mutable module (a module\nessentially is LLVM's equivalent of a translation unit in C) is done\nusing\n  extern LLVMModuleRef llvm_mutable_module(LLVMJitContext *context);\nin which it then can emit as much code using the LLVM APIs as it\nwants. Whenever a function actually needs to be called\n  extern void *llvm_get_function(LLVMJitContext *context, const char *funcname);\nreturns a pointer to it.\n\nE.g. in the expression evaluation case this setup allows most\nfunctions in a query to be emitted during ExecInitNode(), delaying the\nfunction emission to the time the first time a function is actually\nused.\n\n\nError Handling\n--------------\n\nThere are two aspects of error handling.  Firstly, generated (LLVM IR)\nand emitted functions (mmap()ed segments) need to be cleaned up both\nafter a successful query execution and after an error. This is done by\nregistering each created JITContext with the current resource owner,\nand cleaning it up on error / end of transaction. If it is desirable\nto release resources earlier, jit_release_context() can be used.\n\nThe second, less pretty, aspect of error handling is OOM handling\ninside LLVM itself. The above resowner based mechanism takes care of\ncleaning up emitted code upon ERROR, but there's also the chance that\nLLVM itself runs out of memory. LLVM by default does *not* use any C++\nexceptions. Its allocations are primarily funneled through the\nstandard \"new\" handlers, and some direct use of malloc() and\nmmap(). For the former a 'new handler' exists:\nhttp://en.cppreference.com/w/cpp/memory/new/set_new_handler\nFor the latter LLVM provides callbacks that get called upon failure\n(unfortunately mmap() failures are treated as fatal rather than OOM errors).\nWhat we've chosen to do for now is have two functions that LLVM using code\nmust use:\nextern void llvm_enter_fatal_on_oom(void);\nextern void llvm_leave_fatal_on_oom(void);\nbefore interacting with LLVM code.\n\nWhen a libstdc++ new or LLVM error occurs, the handlers set up by the\nabove functions trigger a FATAL error. We have to use FATAL rather\nthan ERROR, as we *cannot* reliably throw ERROR inside a foreign\nlibrary without risking corrupting its internal state.\n\nUsers of the above sections do *not* have to use PG_TRY/CATCH blocks,\nthe handlers instead are reset on toplevel sigsetjmp() level.\n\nUsing a relatively small enter/leave protected section of code, rather\nthan setting up these handlers globally, avoids negative interactions\nwith extensions that might use C++ such as PostGIS. As LLVM code\ngeneration should never execute arbitrary code, just setting these\nhandlers temporarily ought to suffice.\n\n\nType Synchronization\n--------------------\n\nTo be able to generate code that can perform tasks done by \"interpreted\"\nPostgreSQL, it obviously is required that code generation knows about at\nleast a few PostgreSQL types.  While it is possible to inform LLVM about\ntype definitions by recreating them manually in C code, that is failure\nprone and labor intensive.\n\nInstead there is one small file (llvmjit_types.c) which references each of\nthe types required for JITing. That file is translated to bitcode at\ncompile time, and loaded when LLVM is initialized in a backend.\n\nThat works very well to synchronize the type definition, but unfortunately\nit does *not* synchronize offsets as the IR level representation doesn't\nknow field names.  Instead, required offsets are maintained as defines in\nthe original struct definition, like so:\n#define FIELDNO_TUPLETABLESLOT_NVALID 9\n        int                     tts_nvalid;             /* # of valid values in tts_values */\nWhile that still needs to be defined, it's only required for a\nrelatively small number of fields, and it's bunched together with the\nstruct definition, so it's easily kept synchronized.\n\n\nInlining\n--------\n\nOne big advantage of JITing expressions is that it can significantly\nreduce the overhead of PostgreSQL's extensible function/operator\nmechanism, by inlining the body of called functions/operators.\n\nIt obviously is undesirable to maintain a second implementation of\ncommonly used functions, just for inlining purposes. Instead we take\nadvantage of the fact that the Clang compiler can emit LLVM IR.\n\nThe ability to do so allows us to get the LLVM IR for all operators\n(e.g. int8eq, float8pl etc), without maintaining two copies.  These\nbitcode files get installed into the server's\n  $pkglibdir/bitcode/postgres/\nUsing existing LLVM functionality (for parallel LTO compilation),\nadditionally an index is over these is stored to\n$pkglibdir/bitcode/postgres.index.bc\n\nSimilarly extensions can install code into\n  $pkglibdir/bitcode/[extension]/\naccompanied by\n  $pkglibdir/bitcode/[extension].index.bc\n\njust alongside the actual library.  An extension's index will be used\nto look up symbols when located in the corresponding shared\nlibrary. Symbols that are used inside the extension, when inlined,\nwill be first looked up in the main binary and then the extension's.\n\n\nCaching\n-------\n\nCurrently it is not yet possible to cache generated functions, even\nthough that'd be desirable from a performance point of view. The\nproblem is that the generated functions commonly contain pointers into\nper-execution memory. The expression evaluation machinery needs to\nbe redesigned a bit to avoid that. Basically all per-execution memory\nneeds to be referenced as an offset to one block of memory stored in\nan ExprState, rather than absolute pointers into memory.\n\nOnce that is addressed, adding an LRU cache that's keyed by the\ngenerated LLVM IR will allow the usage of optimized functions even for\nfaster queries.\n\nA longer term project is to move expression compilation to the planner\nstage, allowing e.g. to tie compiled expressions to prepared\nstatements.\n\nAn even more advanced approach would be to use JIT with few\noptimizations initially, and build an optimized version in the\nbackground. But that's even further off.\n\n\nWhat to JIT\n===========\n\nCurrently expression evaluation and tuple deforming are JITed. Those\nwere chosen because they commonly are major CPU bottlenecks in\nanalytics queries, but are by no means the only potentially beneficial cases.\n\nFor JITing to be beneficial a piece of code first and foremost has to\nbe a CPU bottleneck. But also importantly, JITing can only be\nbeneficial if overhead can be removed by doing so. E.g. in the tuple\ndeforming case the knowledge about the number of columns and their\ntypes can remove a significant number of branches, and in the\nexpression evaluation case a lot of indirect jumps/calls can be\nremoved.  If neither of these is the case, JITing is a waste of\nresources.\n\nFuture avenues for JITing are tuple sorting, COPY parsing/output\ngeneration, and later compiling larger parts of queries.\n\n\nWhen to JIT\n===========\n\nCurrently there are a number of GUCs that influence JITing:\n\n- jit_above_cost = -1, 0-DBL_MAX - all queries with a higher total cost\n  get JITed, *without* optimization (expensive part), corresponding to\n  -O0. This commonly already results in significant speedups if\n  expression/deforming is a bottleneck (removing dynamic branches\n  mostly).\n- jit_optimize_above_cost = -1, 0-DBL_MAX - all queries with a higher total cost\n  get JITed, *with* optimization (expensive part).\n- jit_inline_above_cost = -1, 0-DBL_MAX - inlining is tried if query has\n  higher cost.\n\nWhenever a query's total cost is above these limits, JITing is\nperformed.\n\nAlternative costing models, e.g. by generating separate paths for\nparts of a query with lower cpu_* costs, are also a possibility, but\nit's doubtful the overhead of doing so is sufficient.  Another\nalternative would be to count the number of times individual\nexpressions are estimated to be evaluated, and perform JITing of these\nindividual expressions.\n\nThe obvious seeming approach of JITing expressions individually after\na number of execution turns out not to work too well. Primarily\nbecause emitting many small functions individually has significant\noverhead. Secondarily because the time until JITing occurs causes\nrelative slowdowns that eat into the gain of JIT compilation.","count":105},{"name":"subsystem-desc","value":"src/backend/parser/README\n\nParser\n======\n\nThis directory does more than tokenize and parse SQL queries.  It also\ncreates Query structures for the various complex queries that are passed\nto the optimizer and then executor.\n\nparser.c\tthings start here\nscan.l\t\tbreak query into tokens\nscansup.c\thandle escapes in input strings\ngram.y\t\tparse the tokens and produce a \"raw\" parse tree\nanalyze.c\ttop level of parse analysis for optimizable queries\nparse_agg.c\thandle aggregates, like SUM(col1),  AVG(col2), ...\nparse_clause.c\thandle clauses like WHERE, ORDER BY, GROUP BY, ...\nparse_coerce.c\thandle coercing expressions to different data types\nparse_collate.c\tassign collation information in completed expressions\nparse_cte.c\thandle Common Table Expressions (WITH clauses)\nparse_expr.c\thandle expressions like col, col + 3, x = 3 or x = 4\nparse_enr.c\thandle ephemeral named rels (trigger transition tables, ...)\nparse_func.c\thandle functions, table.column and column identifiers\nparse_merge.c\thandle MERGE\nparse_node.c\tcreate nodes for various structures\nparse_oper.c\thandle operators in expressions\nparse_param.c\thandle Params (for the cases used in the core backend)\nparse_relation.c support routines for tables and column handling\nparse_target.c\thandle the result list of the query\nparse_type.c\tsupport routines for data type handling\nparse_utilcmd.c\tparse analysis for utility commands (done at execution time)\n\nSee also src/common/keywords.c, which contains the table of standard\nkeywords and the keyword lookup function.  We separated that out because\nvarious frontend code wants to use it too.","count":105},{"name":"subsystem-name","value":"jit","count":105},{"name":"subsystem-name","value":"parser","count":105},{"name":"subsystem-path","value":"backend/jit/readme","count":105},{"name":"subsystem-path","value":"backend/parser/readme","count":105},{"name":"api-caller-count","value":"52","count":104},{"name":"api-typical-usage","value":"Often called from: CreateTriggerFiringOn","count":104},{"name":"api-typical-usage","value":"Often called from: WaitForWALToBecomeAvailable","count":104},{"name":"api-typical-usage","value":"Often called from: create_foreign_join_path","count":104},{"name":"api-typical-usage","value":"Often called from: heap_update","count":104},{"name":"api-typical-usage","value":"Often called from: recoveryStopsAfter","count":104},{"name":"cyclomatic-complexity","value":"46","count":104},{"name":"lines-of-code","value":"117","count":104},{"name":"lines-of-code","value":"161","count":104},{"name":"loop-depth","value":"0","count":104},{"name":"perf-hotspot","value":"warm","count":104},{"name":"tested-by","value":"restrict_and_check_grant","count":104},{"name":"api-example","value":"Datum brin_minmax_add_value(PG_FUNCTION_ARGS) { BrinDesc   *bdesc = (BrinDesc *) PG_GETARG_POINTER(0); BrinValues *column = (BrinValues *) PG_GETARG_POINTER(1); Datum\t\tnewval = PG_GETARG_DATUM(2); boo...","count":102},{"name":"api-example","value":"IndexScanDesc gistbeginscan(Relation r, int nkeys, int norderbys) { IndexScanDesc scan; GISTSTATE  *giststate; GISTScanOpaque so; MemoryContext oldCxt; scan = RelationGetIndexScan(r, nkeys, norderbys)...","count":102},{"name":"api-example","value":"LLVMValueRef slot_compile_deform(LLVMJitContext *context, TupleDesc desc, const TupleTableSlotOps *ops, int natts) { char\t   *funcname; LLVMModuleRef mod; LLVMContextRef lc; LLVMBuilderRef b; LLVMType...","count":102},{"name":"arch-layer","value":"access","count":102},{"name":"arch-layer-depth","value":"5","count":102},{"name":"arch-layer-description","value":"Access methods (heap, index, TOAST)","count":102},{"name":"arch-layer-depth","value":"3","count":101},{"name":"api-caller-count","value":"147","count":100},{"name":"api-caller-count","value":"228","count":100},{"name":"api-typical-usage","value":"Often called from: DecodeXLogRecord","count":100},{"name":"api-typical-usage","value":"Often called from: ExecInitAgg","count":100},{"name":"api-typical-usage","value":"Often called from: XLOGShmemInit","count":100},{"name":"api-typical-usage","value":"Often called from: make_result_opt_error","count":100},{"name":"api-typical-usage","value":"Often called from: translate_col_privs","count":100},{"name":"api-typical-usage","value":"Often called from: utf8_to_johab","count":100},{"name":"cyclomatic-complexity","value":"53","count":100},{"name":"lines-of-code","value":"112","count":100},{"name":"lines-of-code","value":"119","count":100},{"name":"lines-of-code","value":"120","count":100},{"name":"lines-of-code","value":"123","count":100},{"name":"lines-of-code","value":"142","count":100},{"name":"lines-of-code","value":"148","count":100},{"name":"api-caller-count","value":"277","count":96},{"name":"api-caller-count","value":"98","count":96},{"name":"api-example","value":"Datum pg_get_object_address(PG_FUNCTION_ARGS) { char\t   *ttype = TextDatumGetCString(PG_GETARG_DATUM(0)); ArrayType  *namearr = PG_GETARG_ARRAYTYPE_P(1); ArrayType  *argsarr = PG_GETARG_ARRAYTYPE_P(2)...","count":96},{"name":"api-example","value":"static BlockNumber heap_scan_stream_read_next_parallel(ReadStream *stream, void *callback_private_data, void *per_buffer_data) { HeapScanDesc scan = (HeapScanDesc) callback_private_data; Assert(ScanDi...","count":96},{"name":"api-example","value":"static void gistfinishsplit(GISTInsertState *state, GISTInsertStack *stack, GISTSTATE *giststate, List *splitinfo, bool unlockbuf) { GISTPageSplitInfo *right; GISTPageSplitInfo *left; IndexTuple\ttuple...","count":96},{"name":"api-typical-usage","value":"Often called from: PLy_traceback","count":96},{"name":"api-typical-usage","value":"Often called from: add_with_check_options","count":96},{"name":"api-typical-usage","value":"Often called from: heapam_index_build_range_scan","count":96},{"name":"api-typical-usage","value":"Often called from: spg_text_inner_consistent","count":96},{"name":"cyclomatic-complexity","value":"43","count":96},{"name":"cyclomatic-complexity","value":"49","count":96},{"name":"cyclomatic-complexity","value":"54","count":96},{"name":"cyclomatic-complexity","value":"58","count":96},{"name":"lines-of-code","value":"115","count":96},{"name":"lines-of-code","value":"118","count":96},{"name":"lines-of-code","value":"121","count":96},{"name":"lines-of-code","value":"122","count":96},{"name":"lines-of-code","value":"129","count":96},{"name":"lines-of-code","value":"130","count":96},{"name":"lines-of-code","value":"138","count":96},{"name":"loop-depth","value":"26","count":96},{"name":"test-count","value":"18","count":96},{"name":"tested-by","value":"check_object_ownership, add_with_check_options, add_with_check_options, add_with_check_options","count":96},{"name":"tested-by","value":"check_object_ownership, check_duplicates_in_publist, check_duplicates_in_publist","count":96},{"name":"tested-by","value":"check_timezone","count":96},{"name":"api-caller-count","value":"132","count":92},{"name":"api-typical-usage","value":"Often called from: DefineRelation","count":92},{"name":"api-typical-usage","value":"Often called from: _bt_unlink_halfdead_page","count":92},{"name":"api-typical-usage","value":"Often called from: err_generic_string","count":92},{"name":"api-typical-usage","value":"Often called from: getObjectDescription","count":92},{"name":"coupling-score","value":"25","count":92},{"name":"coupling-score","value":"29","count":92},{"name":"lines-of-code","value":"141","count":92},{"name":"api-example","value":"bool GinPageIsRecyclable(Page page) { TransactionId delete_xid; if (PageIsNew(page)) return true; if (!GinPageIsDeleted(page)) return false; delete_xid = GinPageGetDeleteXid(page); if (!TransactionIdI...","count":90},{"name":"api-example","value":"static CopyHeaderChoice defGetCopyHeaderChoice(DefElem *def, bool is_from) { * If no parameter value given, assume \"true\" is meant. */ if (def->arg == NULL) return COPY_HEADER_TRUE; * Allow 0, 1, \"tru...","count":90},{"name":"api-example","value":"static HeapTuple ExtractReplicaIdentity(Relation relation, HeapTuple tp, bool key_required, bool *copy) { TupleDesc\tdesc = RelationGetDescr(relation); char\t\treplident = relation->rd_rel->relreplident;...","count":90},{"name":"api-caller-count","value":"136","count":88},{"name":"api-caller-count","value":"242","count":88},{"name":"api-caller-count","value":"53","count":88},{"name":"api-caller-count","value":"62","count":88},{"name":"api-caller-count","value":"668","count":88},{"name":"api-caller-count","value":"90","count":88},{"name":"api-typical-usage","value":"Often called from: DecodeDateTime","count":88},{"name":"api-typical-usage","value":"Often called from: ExecInterpExpr","count":88},{"name":"api-typical-usage","value":"Often called from: XactLogAbortRecord","count":88},{"name":"api-typical-usage","value":"Often called from: check_datestyle","count":88},{"name":"api-typical-usage","value":"Often called from: pg_stat_get_wal_senders","count":88},{"name":"api-typical-usage","value":"Often called from: reconsider_outer_join_clauses","count":88},{"name":"cyclomatic-complexity","value":"56","count":88},{"name":"lines-of-code","value":"114","count":88},{"name":"lines-of-code","value":"149","count":88},{"name":"tested-by","value":"test_timing, test_timing, test_timing","count":88},{"name":"subsystem-desc","value":"This directory contains tools to download new Unicode data files and\ngenerate static tables. These tables are used to normalize or\ndetermine various properties of Unicode data.\n\nThe generated header files are copied to src/include/common/, and\nincluded in the source tree, so these tools are not normally required\nto build PostgreSQL.\n\nUpdate Unicode Version\n----------------------\n\nEdit src/Makefile.global.in and src/common/unicode/meson.build\nto update the UNICODE_VERSION.\n\nThen, generate the new header files with:\n\n    make update-unicode\n\nor if using meson:\n\n    ninja update-unicode\n\nfrom the top level of the source tree. Examine the result to make sure\nthe changes look reasonable (that is, that the diff size and scope is\ncomparable to the Unicode changes since the last update), and then\ncommit it.\n\nTests\n-----\n\nNormalization tests:\n\nThe Unicode consortium publishes a comprehensive test suite for the\nnormalization algorithm, in a file called NormalizationTest.txt. This\ndirectory also contains a perl script and some C code, to run our\nnormalization code with all the test strings in NormalizationTest.txt.\nTo download NormalizationTest.txt and run the tests:\n\n    make normalization-check\n\nThis is also run as part of the update-unicode target.\n\nCategory, Property and Case tests:\n\nThe files case_test.c and category_test.c test Unicode categories,\nproperties, and case mapping by exhaustively comparing results with\nICU. For these tests to be effective, the version of the Unicode data\nfiles must be similar to the version of Unicode on which ICU is\nbased. Mismatched Unicode versions will cause the tests to skip over\ncodepoints that are assigned in one version and not the other, and may\nfalsely report failures. This test is run as a part of the\nupdate-unicode target.","count":85},{"name":"subsystem-desc","value":"src/backend/utils/misc/README\n\nGUC Implementation Notes\n========================\n\nThe GUC (Grand Unified Configuration) module implements configuration\nvariables of multiple types (currently boolean, enum, int, real, and string).\nVariable settings can come from various places, with a priority ordering\ndetermining which setting is used.\n\n\nPer-Variable Hooks\n------------------\n\nEach variable known to GUC can optionally have a check_hook, an\nassign_hook, and/or a show_hook to provide customized behavior.\nCheck hooks are used to perform validity checking on variable values\n(above and beyond what GUC can do), to compute derived settings when\nnontrivial work is needed to do that, and optionally to \"canonicalize\"\nuser-supplied values.  Assign hooks are used to update any derived state\nthat needs to change when a GUC variable is set.  Show hooks are used to\nmodify the default SHOW display for a variable.\n\n\nIf a check_hook is provided, it points to a function of the signature\n\tbool check_hook(datatype *newvalue, void **extra, GucSource source)\nThe \"newvalue\" argument is of type bool *, int *, double *, or char **\nfor bool, int/enum, real, or string variables respectively.  The check\nfunction should validate the proposed new value, and return true if it is\nOK or false if not.  The function can optionally do a few other things:\n\n* When rejecting a bad proposed value, it may be useful to append some\nadditional information to the generic \"invalid value for parameter FOO\"\ncomplaint that guc.c will emit.  To do that, call\n\tvoid GUC_check_errdetail(const char *format, ...)\nwhere the format string and additional arguments follow the rules for\nerrdetail() arguments.  The resulting string will be emitted as the\nDETAIL line of guc.c's error report, so it should follow the message style\nguidelines for DETAIL messages.  There is also\n\tvoid GUC_check_errhint(const char *format, ...)\nwhich can be used in the same way to append a HINT message.\nOccasionally it may even be appropriate to override guc.c's generic primary\nmessage or error code, which can be done with\n\tvoid GUC_check_errcode(int sqlerrcode)\n\tvoid GUC_check_errmsg(const char *format, ...)\nIn general, check_hooks should avoid throwing errors directly if possible,\nthough this may be impractical to avoid for some corner cases such as\nout-of-memory.\n\n* Since the newvalue is pass-by-reference, the function can modify it.\nThis might be used for example to canonicalize the spelling of a string\nvalue, round off a buffer size to the nearest supported value, or replace\na special value such as \"-1\" with a computed default value.  If the\nfunction wishes to replace a string value, it must guc_malloc (not palloc)\nthe replacement value, and be sure to guc_free() the previous value.\n\n* Derived information, such as the role OID represented by a user name,\ncan be stored for use by the assign hook.  To do this, guc_malloc (not palloc)\nstorage space for the information, and return its address at *extra.\nguc.c will automatically guc_free() this space when the associated GUC setting\nis no longer of interest.  *extra is initialized to NULL before call, so\nit can be ignored if not needed.\n\nThe \"source\" argument indicates the source of the proposed new value,\nIf it is >= PGC_S_INTERACTIVE, then we are performing an interactive\nassignment (e.g., a SET command).  But when source < PGC_S_INTERACTIVE,\nwe are reading a non-interactive option source, such as postgresql.conf.\nThis is sometimes needed to determine whether a setting should be\nallowed.  The check_hook might also look at the current actual value of\nthe variable to determine what is allowed.\n\nNote that check hooks are sometimes called just to validate a value,\nwithout any intention of actually changing the setting.  Therefore the\ncheck hook must *not* take any action based on the assumption that an\nassignment will occur.\n\n\nIf an assign_hook is provided, it points to a function of the signature\n\tvoid assign_hook(datatype newvalue, void *extra)\nwhere the type of \"newvalue\" matches the kind of variable, and \"extra\"\nis the derived-information pointer returned by the check_hook (always\nNULL if there is no check_hook).  This function is called immediately\nbefore actually setting the variable's value (so it can look at the actual\nvariable to determine the old value, for example to avoid doing work when\nthe value isn't really changing).\n\nNote that there is no provision for a failure result code.  assign_hooks\nshould never fail except under the most dire circumstances, since a failure\nmay for example result in GUC settings not being rolled back properly during\ntransaction abort.  In general, try to do anything that could conceivably\nfail in a check_hook instead, and pass along the results in an \"extra\"\nstruct, so that the assign hook has little to do beyond copying the data to\nsomeplace.  This applies particularly to catalog lookups: any required\nlookups must be done in the check_hook, since the assign_hook may be\nexecuted during transaction rollback when lookups will be unsafe.\n\nNote that check_hooks are sometimes called outside any transaction, too.\nThis happens when processing the wired-in \"bootstrap\" value, values coming\nfrom the postmaster command line or environment, or values coming from\npostgresql.conf.  Therefore, any catalog lookups done in a check_hook\nshould be guarded with an IsTransactionState() test, and there must be a\nfallback path to allow derived values to be computed during the first\nsubsequent use of the GUC setting within a transaction.  A typical\narrangement is for the catalog values computed by the check_hook and\ninstalled by the assign_hook to be used only for the remainder of the\ntransaction in which the new setting is made.  Each subsequent transaction\nlooks up the values afresh on first use.  This arrangement is useful to\nprevent use of stale catalog values, independently of the problem of\nneeding to check GUC values outside a transaction.\n\n\nIf a show_hook is provided, it points to a function of the signature\n\tconst char *show_hook(void)\nThis hook allows variable-specific computation of the value displayed\nby SHOW (and other SQL features for showing GUC variable values).\nThe return value can point to a static buffer, since show functions are\nnot used reentrantly.\n\n\nSaving/Restoring GUC Variable Values\n------------------------------------\n\nPrior values of configuration variables must be remembered in order to deal\nwith several special cases: RESET (a/k/a SET TO DEFAULT), rollback of SET\non transaction abort, rollback of SET LOCAL at transaction end (either\ncommit or abort), and save/restore around a function that has a SET option.\nRESET is defined as selecting the value that would be effective had there\nnever been any SET commands in the current session.\n\nTo handle these cases we must keep track of many distinct values for each\nvariable.  The primary values are:\n\n* actual variable contents\talways the current effective value\n\n* reset_val\t\t\tthe value to use for RESET\n\n(Each GUC entry also has a boot_val which is the wired-in default value.\nThis is assigned to the reset_val and the actual variable during\nInitializeGUCOptions().  The boot_val is also consulted to restore the\ncorrect reset_val if SIGHUP processing discovers that a variable formerly\nspecified in postgresql.conf is no longer set there.)\n\nIn addition to the primary values, there is a stack of former effective\nvalues that might need to be restored in future.  Stacking and unstacking\nis controlled by the GUC \"nest level\", which is zero when outside any\ntransaction, one at top transaction level, and incremented for each\nopen subtransaction or function call with a SET option.  A stack entry\nis made whenever a GUC variable is first modified at a given nesting level.\n(Note: the reset_val need not be stacked because it is only changed by\nnon-transactional operations.)\n\nA stack entry has a state, a prior value of the GUC variable, a remembered\nsource of that prior value, and depending on the state may also have a\n\"masked\" value.  The masked value is needed when SET followed by SET LOCAL\noccur at the same nest level: the SET's value is masked but must be\nremembered to restore after transaction commit.\n\nDuring initialization we set the actual value and reset_val based on\nwhichever non-interactive source has the highest priority.  They will\nhave the same value.\n\nThe possible transactional operations on a GUC value are:\n\nEntry to a function with a SET option:\n\n\tPush a stack entry with the prior variable value and state SAVE,\n\tthen set the variable.\n\nPlain SET command:\n\n\tIf no stack entry of current level:\n\t\tPush new stack entry w/prior value and state SET\n\telse if stack entry's state is SAVE, SET, or LOCAL:\n\t\tchange stack state to SET, don't change saved value\n\t\t(here we are forgetting effects of prior set action)\n\telse (entry must have state SET+LOCAL):\n\t\tdiscard its masked value, change state to SET\n\t\t(here we are forgetting effects of prior SET and SET LOCAL)\n\tNow set new value.\n\nSET LOCAL command:\n\n\tIf no stack entry of current level:\n\t\tPush new stack entry w/prior value and state LOCAL\n\telse if stack entry's state is SAVE or LOCAL or SET+LOCAL:\n\t\tno change to stack entry\n\t\t(in SAVE case, SET LOCAL will be forgotten at func exit)\n\telse (entry must have state SET):\n\t\tput current active into its masked slot, set state SET+LOCAL\n\tNow set new value.\n\nTransaction or subtransaction abort:\n\n\tPop stack entries, restoring prior value, until top < subxact depth\n\nTransaction or subtransaction commit (incl. successful function exit):\n\n\tWhile stack entry level >= subxact depth\n\n\t\tif entry's state is SAVE:\n\t\t\tpop, restoring prior value\n\t\telse if level is 1 and entry's state is SET+LOCAL:\n\t\t\tpop, restoring *masked* value\n\t\telse if level is 1 and entry's state is SET:\n\t\t\tpop, discarding old value\n\t\telse if level is 1 and entry's state is LOCAL:\n\t\t\tpop, restoring prior value\n\t\telse if there is no entry of exactly level N-1:\n\t\t\tdecrement entry's level, no other state change\n\t\telse\n\t\t\tmerge entries of level N-1 and N as specified below\n\nThe merged entry will have level N-1 and prior = older prior, so easiest\nto keep older entry and free newer.  There are 12 possibilities since\nwe already handled level N state = SAVE:\n\nN-1\t\tN\n\nSAVE\t\tSET\t\tdiscard top prior, set state SET\nSAVE\t\tLOCAL\t\tdiscard top prior, no change to stack entry\nSAVE\t\tSET+LOCAL\tdiscard top prior, copy masked, state S+L\n\nSET\t\tSET\t\tdiscard top prior, no change to stack entry\nSET\t\tLOCAL\t\tcopy top prior to masked, state S+L\nSET\t\tSET+LOCAL\tdiscard top prior, copy masked, state S+L\n\nLOCAL\t\tSET\t\tdiscard top prior, set state SET\nLOCAL\t\tLOCAL\t\tdiscard top prior, no change to stack entry\nLOCAL\t\tSET+LOCAL\tdiscard top prior, copy masked, state S+L\n\nSET+LOCAL\tSET\t\tdiscard top prior and second masked, state SET\nSET+LOCAL\tLOCAL\t\tdiscard top prior, no change to stack entry\nSET+LOCAL\tSET+LOCAL\tdiscard top prior, copy masked, state S+L\n\n\nRESET is executed like a SET, but using the reset_val as the desired new\nvalue.  (We do not provide a RESET LOCAL command, but SET LOCAL TO DEFAULT\nhas the same behavior that RESET LOCAL would.)  The source associated with\nthe reset_val also becomes associated with the actual value.\n\nIf SIGHUP is received, the GUC code rereads the postgresql.conf\nconfiguration file (this does not happen in the signal handler, but at\nnext return to main loop; note that it can be executed while within a\ntransaction).  New values from postgresql.conf are assigned to actual\nvariable, reset_val, and stacked actual values, but only if each of\nthese has a current source priority <= PGC_S_FILE.  (It is thus possible\nfor reset_val to track the config-file setting even if there is\ncurrently a different interactive value of the actual variable.)\n\nThe check_hook, assign_hook and show_hook routines work only with the\nactual variable, and are not directly aware of the additional values\nmaintained by GUC.\n\n\nGUC Memory Handling\n-------------------\n\nString variable values are allocated with guc_malloc or guc_strdup,\nwhich ensure that the values are kept in a long-lived context, and provide\nmore control over handling out-of-memory failures than bare palloc.\n\nWe allow a string variable's actual value, reset_val, boot_val, and stacked\nvalues to point at the same storage.  This makes it slightly harder to free\nspace (we must test whether a value to be freed isn't equal to any of the\nother pointers in the GUC entry or associated stack items).  The main\nadvantage is that we never need to malloc during transaction commit/abort,\nso cannot cause an out-of-memory failure there.\n\n\"Extra\" structs returned by check_hook routines are managed in the same\nway as string values.  Note that we support \"extra\" structs for all types\nof GUC variables, although they are mainly useful with strings.\n\n\nGUC and Null String Variables\n-----------------------------\n\nA GUC string variable can have a boot_val of NULL.  guc.c handles this\nunsurprisingly, assigning the NULL to the underlying C variable.  Any code\nusing such a variable, as well as any hook functions for it, must then be\nprepared to deal with a NULL value.\n\nHowever, it is not possible to assign a NULL value to a GUC string\nvariable in any other way: values coming from SET, postgresql.conf, etc,\nmight be empty strings, but they'll never be NULL.  And SHOW displays\na NULL the same as an empty string.  It is therefore not appropriate to\ntreat a NULL value as a distinct user-visible setting.  A typical use\nfor a NULL boot_val is to denote that a value hasn't yet been set for\na variable that will receive a real value later in startup.\n\nIf it's undesirable for code using the underlying C variable to have to\nworry about NULL values ever, the variable can be given a non-null static\ninitializer as well as a non-null boot_val.  guc.c will overwrite the\nstatic initializer pointer with a copy of the boot_val during\nInitializeGUCOptions, but the variable will never contain a NULL.","count":85},{"name":"subsystem-name","value":"misc","count":85},{"name":"subsystem-name","value":"unicode","count":85},{"name":"subsystem-path","value":"backend/utils/misc/readme","count":85},{"name":"subsystem-path","value":"common/unicode/readme","count":85},{"name":"api-caller-count","value":"154","count":84},{"name":"api-caller-count","value":"68","count":84},{"name":"api-caller-count","value":"70","count":84},{"name":"api-example","value":"static GinPlaceToPageRC dataBeginPlaceToPageLeaf(GinBtree btree, Buffer buf, GinBtreeStack *stack, void *insertdata, void **ptp_workspace, Page *newlpage, Page *newrpage) { GinBtreeDataLeafInsertData ...","count":84},{"name":"api-example","value":"static void brin_xlog_insert_update(XLogReaderState *record, xl_brin_insert *xlrec) { XLogRecPtr\tlsn = record->EndRecPtr; Buffer\t\tbuffer; BlockNumber regpgno; Page\t\tpage; XLogRedoAction action; * If w...","count":84},{"name":"api-example","value":"void gistdoinsert(Relation r, IndexTuple itup, Size freespace, GISTSTATE *giststate, Relation heapRel, bool is_build) { ItemId\t\tiid; IndexTuple\tidxtuple; GISTInsertStack firststack; GISTInsertStack *s...","count":84},{"name":"api-typical-usage","value":"Often called from: CreateCheckPoint","count":84},{"name":"api-typical-usage","value":"Often called from: DefineIndex","count":84},{"name":"api-typical-usage","value":"Often called from: _SPI_execute_plan","count":84},{"name":"api-typical-usage","value":"Often called from: heap2_decode","count":84},{"name":"cyclomatic-complexity","value":"50","count":84},{"name":"lines-of-code","value":"107","count":84},{"name":"lines-of-code","value":"124","count":84},{"name":"lines-of-code","value":"128","count":84},{"name":"lines-of-code","value":"147","count":84},{"name":"security-risk","value":"sql-injection","count":84},{"name":"tested-by","value":"call_string_check_hook","count":84},{"name":"api-example","value":"Bitmapset * execute_attr_map_cols(AttrMap *attrMap, Bitmapset *in_cols) { Bitmapset  *out_cols; int\t\t\tout_attnum; if (in_cols == NULL) return NULL; * For each output column, check which input column i...","count":81},{"name":"api-example","value":"Datum koi8r_to_mic(PG_FUNCTION_ARGS) { unsigned char *src = (unsigned char *) PG_GETARG_CSTRING(2); unsigned char *dest = (unsigned char *) PG_GETARG_CSTRING(3); int\t\t\tlen = PG_GETARG_INT32(4); bool\t\t...","count":81},{"name":"api-example","value":"bool check_datestyle(char **newval, void **extra, GucSource source) { int\t\t\tnewDateStyle = DateStyle; int\t\t\tnewDateOrder = DateOrder; bool\t\thave_style = false; bool\t\thave_order = false; bool\t\tok = tru...","count":81},{"name":"api-example","value":"bool heap_attisnull(HeapTuple tup, int attnum, TupleDesc tupleDesc) { * We allow a NULL tupledesc for relations not expected to have missing * values, such as catalog relations and indexes. */ Assert(...","count":81},{"name":"api-example","value":"static inline void brin_deconstruct_tuple(BrinDesc *brdesc, char *tp, bits8 *nullbits, bool nulls, Datum *values, bool *allnulls, bool *hasnulls) { int\t\t\tattnum; int\t\t\tstored; TupleDesc\tdiskdsc; long\t...","count":81},{"name":"api-example","value":"void ExecEvalArrayExpr(ExprState *state, ExprEvalStep *op) { ArrayType  *result; Oid\t\t\telement_type = op->d.arrayexpr.elemtype; int\t\t\tnelems = op->d.arrayexpr.nelems; int\t\t\tndims = 0; int\t\t\tdims[MAXDI...","count":81},{"name":"api-caller-count","value":"1029","count":80},{"name":"api-caller-count","value":"111","count":80},{"name":"api-caller-count","value":"310","count":80},{"name":"api-caller-count","value":"317","count":80},{"name":"api-caller-count","value":"64","count":80},{"name":"api-caller-count","value":"66","count":80},{"name":"api-typical-usage","value":"Often called from: ATAddForeignKeyConstraint","count":80},{"name":"api-typical-usage","value":"Often called from: _bt_first","count":80},{"name":"api-typical-usage","value":"Often called from: createdb","count":80},{"name":"api-typical-usage","value":"Often called from: dsm_detach","count":80},{"name":"api-typical-usage","value":"Often called from: load_domaintype_info","count":80},{"name":"api-typical-usage","value":"Often called from: spg_range_quad_inner_consistent","count":80},{"name":"coupling-score","value":"24","count":80},{"name":"coupling-score","value":"28","count":80},{"name":"cyclomatic-complexity","value":"64","count":80},{"name":"lines-of-code","value":"135","count":80},{"name":"lines-of-code","value":"136","count":80},{"name":"lines-of-code","value":"153","count":80},{"name":"lines-of-code","value":"157","count":80},{"name":"lines-of-code","value":"158","count":80},{"name":"lines-of-code","value":"164","count":80},{"name":"lines-of-code","value":"167","count":80},{"name":"subsystem-desc","value":"src/backend/nodes/README\n\nNode Structures\n===============\n\nIntroduction\n------------\n\nPostgres uses \"node\" types to organize parse trees, plan trees, and\nexecutor state trees.  All objects that can appear in such trees must\nbe declared as node types.  In addition, a few object types that aren't\npart of parse/plan/execute node trees receive NodeTags anyway for\nidentification purposes, usually because they are involved in APIs\nwhere we want to pass multiple object types through the same pointer.\n\nThe node structures are plain old C structures with the first field\nbeing of type NodeTag.  \"Inheritance\" is achieved by convention:\nthe first field can alternatively be of another node type.\n\nNode types typically have support for being copied by copyObject(),\ncompared by equal(), serialized by outNode(), and deserialized by\nnodeRead().  For some classes of Nodes, not all of these support\nfunctions are required; for example, executor state nodes don't\npresently need any of them.  So far as the system is concerned,\noutput and read functions are only needed for node types that can\nappear in parse trees stored in the catalogs, and for plan tree\nnodes because those are serialized to be passed to parallel workers.\nHowever, we provide output functions for some other node types as well,\nbecause they are very handy for debugging.  Currently, such coverage\nexists for raw parsetrees and most planner data structures.  However,\noutput coverage of raw parsetrees is incomplete: in particular, utility\nstatements are almost entirely unsupported.\n\nRelevant Files\n--------------\n\nUtility functions for manipulating node structures reside in this\ndirectory.  Some support functions are automatically generated by the\ngen_node_support.pl script, other functions are maintained manually.\nTo control the automatic generation of support functions, node types\nand node fields can be annotated with pg_node_attr() specifications;\nsee further documentation in src/include/nodes/nodes.h.\n\n\nFILES IN THIS DIRECTORY (src/backend/nodes/)\n\n    General-purpose node manipulation functions:\n\tcopyfuncs.c\t- copy a node tree (*)\n\tequalfuncs.c\t- compare two node trees (*)\n\toutfuncs.c\t- convert a node tree to text representation (*)\n\treadfuncs.c\t- convert text representation back to a node tree (*)\n\tmakefuncs.c\t- creator functions for some common node types\n\tnodeFuncs.c\t- some other general-purpose manipulation functions\n\tqueryjumblefuncs.c - compute a node tree for query jumbling (*)\n\n    (*) - Most functions in these files are generated by\n    gen_node_support.pl and #include'd there.\n\n    Specialized manipulation functions:\n\tbitmapset.c\t- Bitmapset support\n\tlist.c\t\t- generic list support\n\tmultibitmapset.c - List-of-Bitmapset support\n\tparams.c\t- Param support\n\ttidbitmap.c\t- TIDBitmap support\n\tvalue.c\t\t- support for value nodes\n\nFILES IN src/include/nodes/\n\n    Node definitions primarily appear in:\n\tnodes.h\t\t- define node tags (NodeTag) (*)\n\tprimnodes.h\t- primitive nodes\n\tparsenodes.h\t- parse tree nodes\n\tpathnodes.h\t- path tree nodes and planner internal structures\n\tplannodes.h\t- plan tree nodes\n\texecnodes.h\t- executor nodes\n\tmemnodes.h\t- memory nodes\n\tpg_list.h\t- generic list\n\n    (*) - Also #include's files generated by gen_node_support.pl.\n\n\nSteps to Add a Node\n-------------------\n\nSuppose you want to define a node Foo:\n\n1. Add the structure definition to the appropriate include/nodes/???.h file.\n   If you intend to inherit from, say a Plan node, put Plan as the first field\n   of your struct definition.  (The T_Foo tag is created automatically.)\n2. Check that the generated support functions in copyfuncs.funcs.c,\n   equalfuncs.funcs.c, outfuncs.funcs.c, queryjumblefuncs.funcs.c and\n   readfuncs.funcs.c look correct.  Add attributes as necessary to control the\n   outcome.  (For some classes of node types, you don't need all the support\n   functions.  Use node attributes similar to those of related node types.)\n3. Add cases to the functions in nodeFuncs.c as needed.  There are many\n   other places you'll probably also need to teach about your new node\n   type.  Best bet is to grep for references to one or two similar existing\n   node types to find all the places to touch.\n   (Except for frequently-created nodes, don't bother writing a creator\n   function in makefuncs.c.)\n4. Consider testing your new code with COPY_PARSE_PLAN_TREES,\n   WRITE_READ_PARSE_PLAN_TREES, and RAW_EXPRESSION_COVERAGE_TEST to ensure\n   support has been added everywhere that it's necessary; see\n   pg_config_manual.h about these.\n\nAdding a new node type moves the numbers associated with existing\ntags, so you'll need to recompile the whole tree after doing this.\n(--enable-depend usually helps.)  It doesn't force initdb though,\nbecause the numbers never go to disk.  But altering or removing a node\ntype should usually be accompanied by an initdb-forcing catalog\nversion change, since the interpretation of serialized node trees\nstored in system catalogs is affected by that.  (If the node type\nnever appears in stored parse trees, as for example Plan nodes do not,\nthen a catversion change is not needed to change it.)","count":80},{"name":"subsystem-name","value":"nodes","count":80},{"name":"subsystem-path","value":"backend/nodes/readme","count":80},{"name":"test-count","value":"93","count":80},{"name":"tested-by","value":"check_locale_name, check_locale_name, check_locale_name, check_authmethod_valid, check_need_password, check_data_directory, check_data_directory, check_data_directory, check_backup_label_files, check_","count":80},{"name":"api-example","value":"int main(int argc, char **argv) { int         dec_ind;\t/* current indentation for declarations */ int         di_stack[20];\t/* a stack of structure indentation levels */ int         force_nl;\t/* when ...","count":78},{"name":"api-example","value":"static Buffer brin_getinsertbuffer(Relation irel, Buffer oldbuf, Size itemsz, bool *extended) { BlockNumber oldblk; BlockNumber newblk; Page\t\tpage; Size\t\tfreespace; Assert(itemsz <= BrinMaxItemSize); ...","count":78},{"name":"api-example","value":"static double heapam_index_build_range_scan(Relation heapRelation, Relation indexRelation, IndexInfo *indexInfo, bool allow_sync, bool anyvisible, bool progress, BlockNumber start_blockno, BlockNumber...","count":78},{"name":"api-caller-count","value":"45","count":76},{"name":"api-caller-count","value":"582","count":76},{"name":"api-caller-count","value":"71","count":76},{"name":"api-caller-count","value":"82","count":76},{"name":"api-caller-count","value":"96","count":76},{"name":"api-typical-usage","value":"Often called from: BackgroundWriterMain","count":76},{"name":"api-typical-usage","value":"Often called from: InitializeOneGUCOption","count":76},{"name":"api-typical-usage","value":"Often called from: executeItemOptUnwrapTarget","count":76},{"name":"api-typical-usage","value":"Often called from: heap_lock_tuple","count":76},{"name":"api-typical-usage","value":"Often called from: pg_newlocale_from_collation","count":76},{"name":"api-typical-usage","value":"Often called from: pltcl_process_SPI_result","count":76},{"name":"api-typical-usage","value":"Often called from: tsvector_concat","count":76},{"name":"cyclomatic-complexity","value":"60","count":76},{"name":"lines-of-code","value":"132","count":76},{"name":"lines-of-code","value":"139","count":76},{"name":"tested-by","value":"check_acl, check_float8_array, pg_isolation_test_session_is_blocked, pg_isolation_test_session_is_blocked","count":76},{"name":"tested-by","value":"check_input, check_input, check_input, check_locale_name, check_locale_encoding, check_icu_locale_encoding, check_publisher, check_publisher, check_publisher, check_publisher, check_publisher, check_s","count":76},{"name":"tested-by","value":"table_recheck_autovac","count":76},{"name":"api-example","value":"Datum date_in(PG_FUNCTION_ARGS) { char\t   *str = PG_GETARG_CSTRING(0); Node\t   *escontext = fcinfo->context; DateADT\t\tdate; fsec_t\t\tfsec; struct pg_tm tt, *tm = &tt; int\t\t\ttzp; int\t\t\tdtype; int\t\t\tnf; ...","count":75},{"name":"api-example","value":"Datum ginarrayextract(PG_FUNCTION_ARGS) { ArrayType  *array = PG_GETARG_ARRAYTYPE_P_COPY(0); int32\t   *nkeys = (int32 *) PG_GETARG_POINTER(1); bool\t  **nullFlags = (bool **) PG_GETARG_POINTER(2); int1...","count":75},{"name":"api-example","value":"const char * SPI_result_code_string(int code) { static char buf[64]; switch (code) { case SPI_ERROR_CONNECT: return \"SPI_ERROR_CONNECT\"; case SPI_ERROR_COPY: return \"SPI_ERROR_COPY\"; case SPI_ERROR_OP...","count":75},{"name":"api-example","value":"static BloomFilter * bloom_init(int ndistinct, double false_positive_rate) { Size\t\tlen; BloomFilter *filter; int\t\t\tnbits;\t\t\t/* size of filter / number of bits */ int\t\t\tnbytes;\t\t\t/* size of filter / nu...","count":75},{"name":"api-example","value":"static void brin_xlog_createidx(XLogReaderState *record) { XLogRecPtr\tlsn = record->EndRecPtr; xl_brin_createidx *xlrec = (xl_brin_createidx *) XLogRecGetData(record); Buffer\t\tbuf; Page\t\tpage; buf = X...","count":75},{"name":"api-example","value":"void heap_insert(Relation relation, HeapTuple tup, CommandId cid, int options, BulkInsertState bistate) { TransactionId xid = GetCurrentTransactionId(); HeapTuple\theaptup; Buffer\t\tbuffer; Buffer\t\tvmbu...","count":75},{"name":"subsystem-desc","value":"src/backend/access/gin/README\n\nGin for PostgreSQL\n==================\n\nGin was sponsored by jfg://networks (http://www.jfg-networks.com/)\n\nGin stands for Generalized Inverted Index and should be considered as a genie,\nnot a drink.\n\nGeneralized means that the index does not know which operation it accelerates.\nIt instead works with custom strategies, defined for specific data types (read\n\"Index Method Strategies\" in the PostgreSQL documentation). In that sense, Gin\nis similar to GiST and differs from btree indices, which have predefined,\ncomparison-based operations.\n\nAn inverted index is an index structure storing a set of (key, posting list)\npairs, where 'posting list' is a set of heap rows in which the key occurs.\n(A text document would usually contain many keys.)  The primary goal of\nGin indices is support for highly scalable, full-text search in PostgreSQL.\n\nA Gin index consists of a B-tree index constructed over key values,\nwhere each key is an element of some indexed items (element of array, lexeme\nfor tsvector) and where each tuple in a leaf page contains either a pointer to\na B-tree over item pointers (posting tree), or a simple list of item pointers\n(posting list) if the list is small enough.\n\nNote: There is no delete operation in the key (entry) tree. The reason for\nthis is that in our experience, the set of distinct words in a large corpus\nchanges very slowly.  This greatly simplifies the code and concurrency\nalgorithms.\n\nCore PostgreSQL includes built-in Gin support for one-dimensional arrays\n(eg. integer[], text[]).  The following operations are available:\n\n  * contains: value_array @> query_array\n  * overlaps: value_array && query_array\n  * is contained by: value_array <@ query_array\n\nSynopsis\n--------\n\n=# create index txt_idx on aa using gin(a);\n\nFeatures\n--------\n\n  * Concurrency\n  * Write-Ahead Logging (WAL).  (Recoverability from crashes.)\n  * User-defined opclasses.  (The scheme is similar to GiST.)\n  * Optimized index creation (Makes use of maintenance_work_mem to accumulate\n    postings in memory.)\n  * Text search support via an opclass\n  * Soft upper limit on the returned results set using a GUC variable:\n    gin_fuzzy_search_limit\n\nGin Fuzzy Limit\n---------------\n\nThere are often situations when a full-text search returns a very large set of\nresults.  Since reading tuples from the disk and sorting them could take a\nlot of time, this is unacceptable for production.  (Note that the search\nitself is very fast.)\n\nSuch queries usually contain very frequent lexemes, so the results are not\nvery helpful. To facilitate execution of such queries Gin has a configurable\nsoft upper limit on the size of the returned set, determined by the\n'gin_fuzzy_search_limit' GUC variable.  This is set to 0 by default (no\nlimit).\n\nIf a non-zero search limit is set, then the returned set is a subset of the\nwhole result set, chosen at random.\n\n\"Soft\" means that the actual number of returned results could differ\nfrom the specified limit, depending on the query and the quality of the\nsystem's random number generator.\n\nFrom experience, a value of 'gin_fuzzy_search_limit' in the thousands\n(eg. 5000-20000) works well.  This means that 'gin_fuzzy_search_limit' will\nhave no effect for queries returning a result set with less tuples than this\nnumber.\n\nIndex structure\n---------------\n\nThe \"items\" that a GIN index indexes are composite values that contain\nzero or more \"keys\".  For example, an item might be an integer array, and\nthen the keys would be the individual integer values.  The index actually\nstores and searches for the key values, not the items per se.  In the\npg_opclass entry for a GIN opclass, the opcintype is the data type of the\nitems, and the opckeytype is the data type of the keys.  GIN is optimized\nfor cases where items contain many keys and the same key values appear\nin many different items.\n\nA GIN index contains a metapage, a btree of key entries, and possibly\n\"posting tree\" pages, which hold the overflow when a key entry acquires\ntoo many heap tuple pointers to fit in a btree page.  Additionally, if the\nfast-update feature is enabled, there can be \"list pages\" holding \"pending\"\nkey entries that haven't yet been merged into the main btree.  The list\npages have to be scanned linearly when doing a search, so the pending\nentries should be merged into the main btree before there get to be too\nmany of them.  The advantage of the pending list is that bulk insertion of\na few thousand entries can be much faster than retail insertion.  (The win\ncomes mainly from not having to do multiple searches/insertions when the\nsame key appears in multiple new heap tuples.)\n\nKey entries are nominally of the same IndexTuple format as used in other\nindex types, but since a leaf key entry typically refers to multiple heap\ntuples, there are significant differences.  (See GinFormTuple, which works\nby building a \"normal\" index tuple and then modifying it.)  The points to\nknow are:\n\n* In a single-column index, a key tuple just contains the key datum, but\nin a multi-column index, a key tuple contains the pair (column number,\nkey datum) where the column number is stored as an int2.  This is needed\nto support different key data types in different columns.  This much of\nthe tuple is built by index_form_tuple according to the usual rules.\nThe column number (if present) can never be null, but the key datum can\nbe, in which case a null bitmap is present as usual.  (As usual for index\ntuples, the size of the null bitmap is fixed at INDEX_MAX_KEYS.)\n\n* If the key datum is null (ie, IndexTupleHasNulls() is true), then\njust after the nominal index data (ie, at offset IndexInfoFindDataOffset\nor IndexInfoFindDataOffset + sizeof(int2)) there is a byte indicating\nthe \"category\" of the null entry.  These are the possible categories:\n\t1 = ordinary null key value extracted from an indexable item\n\t2 = placeholder for zero-key indexable item\n\t3 = placeholder for null indexable item\nPlaceholder null entries are inserted into the index because otherwise\nthere would be no index entry at all for an empty or null indexable item,\nwhich would mean that full index scans couldn't be done and various corner\ncases would give wrong answers.  The different categories of null entries\nare treated as distinct keys by the btree, but heap itempointers for the\nsame category of null entry are merged into one index entry just as happens\nwith ordinary key entries.\n\n* In a key entry at the btree leaf level, at the next SHORTALIGN boundary,\nthere is a list of item pointers, in compressed format (see Posting List\nCompression section), pointing to the heap tuples for which the indexable\nitems contain this key. This is called the \"posting list\".\n\nIf the list would be too big for the index tuple to fit on an index page, the\nItemPointers are pushed out to a separate posting page or pages, and none\nappear in the key entry itself.  The separate pages are called a \"posting\ntree\" (see below); Note that in either case, the ItemPointers associated with\na key can easily be read out in sorted order; this is relied on by the scan\nalgorithms.\n\n* The index tuple header fields of a leaf key entry are abused as follows:\n\n1) Posting list case:\n\n* ItemPointerGetBlockNumber(&itup->t_tid) contains the offset from index\n  tuple start to the posting list.\n  Access macros: GinGetPostingOffset(itup) / GinSetPostingOffset(itup,n)\n\n* ItemPointerGetOffsetNumber(&itup->t_tid) contains the number of elements\n  in the posting list (number of heap itempointers).\n  Access macros: GinGetNPosting(itup) / GinSetNPosting(itup,n)\n\n* If IndexTupleHasNulls(itup) is true, the null category byte can be\n  accessed/set with GinGetNullCategory(itup,gs) / GinSetNullCategory(itup,gs,c)\n\n* The posting list can be accessed with GinGetPosting(itup)\n\n* If GinItupIsCompressed(itup), the posting list is stored in compressed\n  format. Otherwise it is just an array of ItemPointers. New tuples are always\n  stored in compressed format, uncompressed items can be present if the\n  database was migrated from 9.3 or earlier version.\n\n2) Posting tree case:\n\n* ItemPointerGetBlockNumber(&itup->t_tid) contains the index block number\n  of the root of the posting tree.\n  Access macros: GinGetPostingTree(itup) / GinSetPostingTree(itup, blkno)\n\n* ItemPointerGetOffsetNumber(&itup->t_tid) contains the magic number\n  GIN_TREE_POSTING, which distinguishes this from the posting-list case\n  (it's large enough that that many heap itempointers couldn't possibly\n  fit on an index page).  This value is inserted automatically by the\n  GinSetPostingTree macro.\n\n* If IndexTupleHasNulls(itup) is true, the null category byte can be\n  accessed/set with GinGetNullCategory(itup,gs) / GinSetNullCategory(itup,gs,c)\n\n* The posting list is not present and must not be accessed.\n\nUse the macro GinIsPostingTree(itup) to determine which case applies.\n\nIn both cases, itup->t_info & INDEX_SIZE_MASK contains actual total size of\ntuple, and the INDEX_VAR_MASK and INDEX_NULL_MASK bits have their normal\nmeanings as set by index_form_tuple.\n\nIndex tuples in non-leaf levels of the btree contain the optional column\nnumber, key datum, and null category byte as above.  They do not contain\na posting list.  ItemPointerGetBlockNumber(&itup->t_tid) is the downlink\nto the next lower btree level, and ItemPointerGetOffsetNumber(&itup->t_tid)\nis InvalidOffsetNumber.  Use the access macros GinGetDownlink/GinSetDownlink\nto get/set the downlink.\n\nIndex entries that appear in \"pending list\" pages work a tad differently as\nwell.  The optional column number, key datum, and null category byte are as\nfor other GIN index entries.  However, there is always exactly one heap\nitempointer associated with a pending entry, and it is stored in the t_tid\nheader field just as in non-GIN indexes.  There is no posting list.\nFurthermore, the code that searches the pending list assumes that all\nentries for a given heap tuple appear consecutively in the pending list and\nare sorted by the column-number-plus-key-datum.  The GIN_LIST_FULLROW page\nflag bit tells whether entries for a given heap tuple are spread across\nmultiple pending-list pages.  If GIN_LIST_FULLROW is set, the page contains\nall the entries for one or more heap tuples.  If GIN_LIST_FULLROW is clear,\nthe page contains entries for only one heap tuple, *and* they are not all\nthe entries for that tuple.  (Thus, a heap tuple whose entries do not all\nfit on one pending-list page must have those pages to itself, even if this\nresults in wasting much of the space on the preceding page and the last\npage for the tuple.)\n\nGIN packs downlinks and pivot keys into internal page tuples in a different way\nthan nbtree does.  Lehman & Yao defines it as following.\n\nP_0, K_1, P_1, K_2, P_2, ... , K_n, P_n, K_{n+1}\n\nThere P_i is a downlink and K_i is a key.  K_i splits key space between P_{i-1}\nand P_i (0 <= i <= n).  K_{n+1} is high key.\n\nIn internal page tuple is key and downlink grouped together.  nbtree packs\nkeys and downlinks into tuples as following.\n\n(K_{n+1}, None), (-Inf, P_0), (K_1, P_1), ... , (K_n, P_n)\n\nThere tuples are shown in parentheses.  So, highkey is stored separately.  P_i\nis grouped with K_i.  P_0 is grouped with -Inf key.\n\nGIN packs keys and downlinks into tuples in a different way.\n\n(P_0, K_1), (P_1, K_2), ... , (P_n, K_{n+1})\n\nP_i is grouped with K_{i+1}.  -Inf key is not needed.\n\nThere are couple of additional notes regarding K_{n+1} key.\n1) In entry tree rightmost page, a key coupled with P_n doesn't really matter.\nHighkey is assumed to be infinity.\n2) In posting tree, a key coupled with P_n always doesn't matter.  Highkey for\nnon-rightmost pages is stored separately and accessed via\nGinDataPageGetRightBound().\n\nPosting tree\n------------\n\nIf a posting list is too large to store in-line in a key entry, a posting tree\nis created. A posting tree is a B-tree structure, where the ItemPointer is\nused as the key.\n\nInternal posting tree pages use the standard PageHeader and the same \"opaque\"\nstruct as other GIN page, but do not contain regular index tuples. Instead,\nthe contents of the page is an array of PostingItem structs. Each PostingItem\nconsists of the block number of the child page, and the right bound of that\nchild page, as an ItemPointer. The right bound of the page is stored right\nafter the page header, before the PostingItem array.\n\nPosting tree leaf pages also use the standard PageHeader and opaque struct,\nand the right bound of the page is stored right after the page header, but\nthe page content comprises of a number of compressed posting lists. The\ncompressed posting lists are stored one after each other, between page header\nand pd_lower. The space between pd_lower and pd_upper is unused, which allows\nfull-page images of posting tree leaf pages to skip the unused space in middle\n(buffer_std = true in XLogRecData).\n\nThe item pointers are stored in a number of independent compressed posting\nlists (also called segments), instead of one big one, to make random access\nto a given item pointer faster: to find an item in a compressed list, you\nhave to read the list from the beginning, but when the items are split into\nmultiple lists, you can first skip over to the list containing the item you're\nlooking for, and read only that segment. Also, an update only needs to\nre-encode the affected segment.\n\nPosting List Compression\n------------------------\n\nTo fit as many item pointers on a page as possible, posting tree leaf pages\nand posting lists stored inline in entry tree leaf tuples use a lightweight\nform of compression. We take advantage of the fact that the item pointers\nare stored in sorted order. Instead of storing the block and offset number of\neach item pointer separately, we store the difference from the previous item.\nThat in itself doesn't do much, but it allows us to use so-called varbyte\nencoding to compress them.\n\nVarbyte encoding is a method to encode integers, allowing smaller numbers to\ntake less space at the cost of larger numbers. Each integer is represented by\nvariable number of bytes. High bit of each byte in varbyte encoding determines\nwhether the next byte is still part of this number. Therefore, to read a single\nvarbyte encoded number, you have to read bytes until you find a byte with the\nhigh bit not set.\n\nWhen encoding, the block and offset number forming the item pointer are\ncombined into a single integer. The offset number is stored in the 11 low\nbits (see MaxHeapTuplesPerPageBits in ginpostinglist.c), and the block number\nis stored in the higher bits. That requires 43 bits in total, which\nconveniently fits in at most 6 bytes.\n\nA compressed posting list is passed around and stored on disk in a\nGinPostingList struct. The first item in the list is stored uncompressed\nas a regular ItemPointerData, followed by the length of the list in bytes,\nfollowed by the packed items.\n\nConcurrency\n-----------\n\nThe entry tree and each posting tree are B-trees, with right-links connecting\nsibling pages at the same level.  This is the same structure that is used in\nthe regular B-tree indexam (invented by Lehman & Yao), but we don't support\nscanning a GIN trees backwards, so we don't need left-links.  The entry tree\nleaves don't have dedicated high keys, instead greatest leaf tuple serves as\nhigh key.  That works because tuples are never deleted from the entry tree.\n\nThe algorithms used to operate entry and posting trees are considered below.\n\n### Locating the leaf page\n\nWhen we search for leaf page in GIN btree to perform a read, we descend from\nthe root page to the leaf through using downlinks taking pin and shared lock on\none page at once.  So, we release pin and shared lock on previous page before\ngetting them on the next page.\n\nThe picture below shows tree state after finding the leaf page.  Lower case\nletters depicts tree pages.  'S' depicts shared lock on the page.\n\n               a\n           /   |   \\\n       b       c       d\n     / | \\     | \\     | \\\n   eS  f   g   h   i   j   k\n\n### Steping right\n\nConcurrent page splits move the keyspace to right, so after following a\ndownlink, the page actually containing the key we're looking for might be\nsomewhere to the right of the page we landed on.  In that case, we follow the\nright-links until we find the page we're looking for.\n\nDuring stepping right we take pin and shared lock on the right sibling before\nreleasing them from the current page.  This mechanism was designed to protect\nfrom stepping to delete page.  We step to the right sibling while hold lock on\nthe rightlink pointing there.  So, it's guaranteed that nobody updates rightlink\nconcurrently and doesn't delete right sibling accordingly.\n\nThe picture below shows two pages locked at once during stepping right.\n\n               a\n           /   |   \\\n       b       c       d\n     / | \\     | \\     | \\\n   eS  fS  g   h   i   j   k\n\n### Insert\n\nWhile finding appropriate leaf for insertion we also descend from the root to\nleaf, while shared locking one page at once in.  But during insertion we don't\nrelease pins from root and internal pages.  That could save us some lookups to\nthe buffers hash table for downlinks insertion assuming parents are not changed\ndue to concurrent splits.  Once we reach leaf we re-lock the page in exclusive\nmode.\n\nThe picture below shows leaf page locked in exclusive mode and ready for\ninsertion.  'P' and 'E' depict pin and exclusive lock correspondingly.\n\n\n               aP\n           /   |   \\\n       b       cP      d\n     / | \\     | \\     | \\\n   e   f   g   hE  i   j   k\n\n\nIf insert causes a page split, the parent is locked in exclusive mode before\nunlocking the left child.  So, insertion algorithm can exclusively lock both\nparent and child pages at once starting from child.\n\nThe picture below shows tree state after leaf page split.  'q' is new page\nproduced by split.  Parent 'c' is about to have downlink inserted.\n\n                  aP\n            /     |   \\\n       b          cE      d\n     / | \\      / | \\     | \\\n   e   f   g  hE  q   i   j   k\n\n\n### Page deletion\n\nVacuum never deletes tuples or pages from the entry tree. It traverses entry\ntree leafs in logical order by rightlinks and removes deletable TIDs from\nposting lists. Posting trees are processed by links from entry tree leafs. They\nare vacuumed in two stages. At first stage, deletable TIDs are removed from\nleafs. If first stage detects at least one empty page, then at the second stage\nginScanToDelete() deletes empty pages.\n\nginScanToDelete() traverses the whole tree in depth-first manner.  It starts\nfrom the full cleanup lock on the tree root.  This lock prevents all the\nconcurrent insertions into this tree while we're deleting pages.  However,\nthere are still might be some in-progress readers, who traversed root before\nwe locked it.\n\nThe picture below shows tree state after page deletion algorithm traversed to\nleftmost leaf of the tree.\n\n               aE\n           /   |   \\\n       bE      c       d\n     / | \\     | \\     | \\\n   eE  f   g   h   i   j   k\n\nDeletion algorithm keeps exclusive locks on left siblings of pages comprising\ncurrently investigated path.  Thus, if current page is to be removed, all\nrequired pages to remove both downlink and rightlink are already locked.  That\navoids potential right to left page locking order, which could deadlock with\nconcurrent stepping right.\n\nA search concurrent to page deletion might already have read a pointer to the\npage to be deleted, and might be just about to follow it.  A page can be reached\nvia the right-link of its left sibling, or via its downlink in the parent.\n\nTo prevent a backend from reaching a deleted page via a right-link, stepping\nright algorithm doesn't release lock on the current page until lock of the\nright page is acquired.\n\nThe downlink is more tricky.  A search descending the tree must release the lock\non the parent page before locking the child, or it could deadlock with a\nconcurrent split of the child page; a page split locks the parent, while already\nholding a lock on the child page.  So, deleted page cannot be reclaimed\nimmediately.  Instead, we have to wait for every transaction, which might wait\nto reference this page, to finish.  Corresponding processes must observe that\nthe page is marked deleted and recover accordingly.\n\nThe picture below shows tree state after page deletion algorithm further\ntraversed the tree.  Currently investigated path is 'a-c-h'.  Left siblings 'b'\nand 'g' of 'c' and 'h' correspondingly are also exclusively locked.\n\n               aE\n           /   |   \\\n       bE      cE      d\n     / | \\     | \\     | \\\n   e   f   gE  hE  i   j   k\n\nThe next picture shows tree state after page 'h' was deleted.  It's marked with\n'deleted' flag and newest xid, which might visit it.  Downlink from 'c' to 'h'\nis also deleted.\n\n               aE\n           /   |   \\\n       bE      cE      d\n     / | \\       \\     | \\\n   e   f   gE  hD  iE  j   k\n\nHowever, it's still possible that concurrent reader has seen downlink from 'c'\nto 'h' before we deleted it.  In that case this reader will step right from 'h'\nto till find non-deleted page.  Xid-marking of page 'h' guarantees that this\npage wouldn't be reused till all such readers gone.  Next leaf page under\ninvestigation is 'i'.  'g' remains locked as it becomes left sibling of 'i'.\n\nThe next picture shows tree state after 'i' and 'c' was deleted.  Internal page\n'c' was deleted because it appeared to have no downlinks.  The path under\ninvestigation is 'a-d-j'.  Pages 'b' and 'g' are locked as self siblings of 'd'\nand 'j'.\n\n               aE\n           /       \\\n       bE      cD      dE\n     / | \\             | \\\n   e   f   gE  hD  iD  jE  k\n\nDuring the replay of page deletion at standby, the page's left sibling, the\ntarget page, and its parent, are locked in that order.  This order guarantees\nno deadlock with concurrent reads.\n\nPredicate Locking\n-----------------\n\nGIN supports predicate locking, for serializable snapshot isolation.\nA predicate locks represent that a scan has scanned a range of values.  They\nare not concerned with physical pages as such, but the logical key values.\nA predicate lock on a page covers the key range that would belong on that\npage, whether or not there are any matching tuples there currently.  In other\nwords, a predicate lock on an index page covers the \"gaps\" between the index\ntuples.  To minimize false positives, predicate locks are acquired at the\nfinest level possible.\n\n* Like in the B-tree index, it is enough to lock only leaf pages, because all\n  insertions happen at the leaf level.\n\n* In an equality search (i.e. not a partial match search), if a key entry has\n  a posting tree, we lock the posting tree root page, to represent a lock on\n  just that key entry.  Otherwise, we lock the entry tree page.  We also lock\n  the entry tree page if no match is found, to lock the \"gap\" where the entry\n  would've been, had there been one.\n\n* In a partial match search, we lock all the entry leaf pages that we scan,\n  in addition to locks on posting tree roots, to represent the \"gaps\" between\n  values.\n\n* In addition to the locks on entry leaf pages and posting tree roots, all\n  scans grab a lock the metapage.  This is to interlock with insertions to\n  the fast update pending list.  An insertion to the pending list can really\n  belong anywhere in the tree, and the lock on the metapage represents that.\n\nThe interlock for fastupdate pending lists means that with fastupdate=on,\nwe effectively always grab a full-index lock, so you could get a lot of false\npositives.\n\nCompatibility\n-------------\n\nCompression of TIDs was introduced in 9.4. Some GIN indexes could remain in\nuncompressed format because of pg_upgrade from 9.3 or earlier versions.\nFor compatibility, old uncompressed format is also supported. Following\nrules are used to handle it:\n\n* GIN_ITUP_COMPRESSED flag marks index tuples that contain a posting list.\nThis flag is stored in high bit of ItemPointerGetBlockNumber(&itup->t_tid).\nUse GinItupIsCompressed(itup) to check the flag.\n\n* Posting tree pages in the new format are marked with the GIN_COMPRESSED flag.\n  Macros GinPageIsCompressed(page) and GinPageSetCompressed(page) are used to\n  check and set this flag.\n\n* All scan operations check format of posting list add use corresponding code\nto read its content.\n\n* When updating an index tuple containing an uncompressed posting list, it\nwill be replaced with new index tuple containing a compressed list.\n\n* When updating an uncompressed posting tree leaf page, it's compressed.\n\n* If vacuum finds some dead TIDs in uncompressed posting lists, they are\nconverted into compressed posting lists. This assumes that the compressed\nposting list fits in the space occupied by the uncompressed list. IOW, we\nassume that the compressed version of the page, with the dead items removed,\ntakes less space than the old uncompressed version.\n\nLimitations\n-----------\n\n  * Gin doesn't use scan->kill_prior_tuple & scan->ignore_killed_tuples\n  * Gin searches entries only by equality matching, or simple range\n    matching using the \"partial match\" feature.\n\nTODO\n----\n\nNearest future:\n\n  * Opclasses for more types (no programming, just many catalog changes)\n\nDistant future:\n\n  * Replace B-tree of entries to something like GiST\n\nAuthors\n-------\n\nOriginal work was done by Teodor Sigaev (teodor@sigaev.ru) and Oleg Bartunov\n(oleg@sai.msu.su).","count":75},{"name":"subsystem-name","value":"gin","count":75},{"name":"subsystem-path","value":"backend/access/gin/readme","count":75},{"name":"api-caller-count","value":"110","count":72},{"name":"api-caller-count","value":"113","count":72},{"name":"api-caller-count","value":"151","count":72},{"name":"api-caller-count","value":"195","count":72},{"name":"api-example","value":"CopyToState BeginCopyTo(ParseState *pstate, Relation rel, RawStmt *raw_query, Oid queryRelId, const char *filename, bool is_program, copy_data_dest_cb data_dest_cb, List *attnamelist, List *options) {...","count":72},{"name":"api-example","value":"IndexTuple index_form_tuple_context(TupleDesc tupleDescriptor, const Datum *values, const bool *isnull, MemoryContext context) { char\t   *tp;\t\t\t\t/* tuple pointer */ IndexTuple\ttuple;\t\t\t/* return tuple...","count":72},{"name":"api-example","value":"void brin_redo(XLogReaderState *record) { uint8\t\tinfo = XLogRecGetInfo(record) & ~XLR_INFO_MASK; switch (info & XLOG_BRIN_OPMASK) { case XLOG_BRIN_CREATE_INDEX: brin_xlog_createidx(record); break; cas...","count":72},{"name":"api-example","value":"void heap_xlog_logical_rewrite(XLogReaderState *r) { char\t\tpath[MAXPGPATH]; int\t\t\tfd; xl_heap_rewrite_mapping *xlrec; uint32\t\tlen; char\t   *data; xlrec = (xl_heap_rewrite_mapping *) XLogRecGetData(r);...","count":72},{"name":"api-typical-usage","value":"Often called from: AlterTableGetLockLevel","count":72},{"name":"api-typical-usage","value":"Often called from: InitializeParallelDSM","count":72},{"name":"api-typical-usage","value":"Often called from: errstart","count":72},{"name":"api-typical-usage","value":"Often called from: extract_date","count":72},{"name":"api-typical-usage","value":"Often called from: ginbuild","count":72},{"name":"api-typical-usage","value":"Often called from: index_create","count":72},{"name":"api-typical-usage","value":"Often called from: pg_server_to_any","count":72},{"name":"api-typical-usage","value":"Often called from: vacuum_error_callback","count":72},{"name":"api-typical-usage","value":"Often called from: valid_variable_name","count":72},{"name":"coupling-score","value":"27","count":72},{"name":"cyclomatic-complexity","value":"59","count":72},{"name":"lines-of-code","value":"137","count":72},{"name":"lines-of-code","value":"155","count":72},{"name":"lines-of-code","value":"165","count":72},{"name":"lines-of-code","value":"168","count":72},{"name":"tested-by","value":"check_temp_tablespaces, check_createrole_self_grant, check_datestyle, check_datestyle, check_datestyle, check_timezone, check_log_timezone, check_random_seed, check_client_encoding, check_client_encod","count":72},{"name":"tested-by","value":"check_wal_consistency_checking, check_recovery_target_lsn, check_recovery_target_timeline, check_recovery_target_xid, check_debug_io_direct, check_restrict_nonsystem_relation_kind, check_backtrace_fun","count":72},{"name":"api-example","value":"int pg_regcomp(regex_t *re, const chr *string, size_t len, int flags, Oid collation) { struct vars var; struct vars *v = &var; struct guts *g; int\t\t\ti; size_t\t\tj; #ifdef REG_DEBUG FILE\t   *debug = (fl...","count":69},{"name":"api-example","value":"static int CopyReadAttributesText(CopyFromState cstate) { char\t\tdelimc = cstate->opts.delim[0]; int\t\t\tfieldno; char\t   *output_ptr; char\t   *cur_ptr; char\t   *line_end_ptr; * We need a special case fo...","count":69},{"name":"api-example","value":"static void ExplainNode(PlanState *planstate, List *ancestors, const char *relationship, const char *plan_name, ExplainState *es) { Plan\t   *plan = planstate->plan; const char *pname;\t\t\t/* node type n...","count":69},{"name":"api-example","value":"static void SetDefaultACL(InternalDefaultACL *iacls) { AclMode\t\tthis_privileges = iacls->privileges; char\t\tobjtype; Relation\trel; HeapTuple\ttuple; bool\t\tisNew; Acl\t\t   *def_acl; Acl\t\t   *old_acl; Acl\t...","count":69},{"name":"api-example","value":"static void init_params(ParseState *pstate, List *options, bool for_identity, bool isInit, Form_pg_sequence seqform, Form_pg_sequence_data seqdataform, bool *need_seq_rewrite, List **owned_by) { DefEl...","count":69},{"name":"api-example","value":"void ginHeapTupleFastCollect(GinState *ginstate, GinTupleCollector *collector, OffsetNumber attnum, Datum value, bool isNull, ItemPointer ht_ctid) { Datum\t   *entries; GinNullCategory *categories; int...","count":69},{"name":"api-caller-count","value":"243","count":68},{"name":"api-caller-count","value":"54","count":68},{"name":"api-typical-usage","value":"Often called from: InitPredicateLocks","count":68},{"name":"api-typical-usage","value":"Often called from: XLogPrefetcherNextBlock","count":68},{"name":"api-typical-usage","value":"Often called from: do_autovacuum","count":68},{"name":"api-typical-usage","value":"Often called from: enlargeStringInfo","count":68},{"name":"api-typical-usage","value":"Often called from: generate_subscripts","count":68},{"name":"api-typical-usage","value":"Often called from: get_hba_options","count":68},{"name":"api-typical-usage","value":"Often called from: swap_relation_files","count":68},{"name":"api-typical-usage","value":"Often called from: xlog_desc","count":68},{"name":"coupling-score","value":"26","count":68},{"name":"cyclomatic-complexity","value":"55","count":68},{"name":"cyclomatic-complexity","value":"63","count":68},{"name":"cyclomatic-complexity","value":"72","count":68},{"name":"cyclomatic-complexity","value":"73","count":68},{"name":"lines-of-code","value":"144","count":68},{"name":"lines-of-code","value":"146","count":68},{"name":"lines-of-code","value":"151","count":68},{"name":"lines-of-code","value":"156","count":68},{"name":"tested-by","value":"check_duplicates_in_publist, jsonb_subscript_check_subscripts","count":68},{"name":"tested-by","value":"check_expected_areq","count":68},{"name":"tested-by","value":"check_input, check_input, check_input, check_locale_name, check_locale_encoding, check_icu_locale_encoding, check_publisher, check_publisher, check_subscriber, check_subscriber, check_subscriber","count":68},{"name":"api-example","value":"Datum brin_bloom_add_value(PG_FUNCTION_ARGS) { BrinDesc   *bdesc = (BrinDesc *) PG_GETARG_POINTER(0); BrinValues *column = (BrinValues *) PG_GETARG_POINTER(1); Datum\t\tnewval = PG_GETARG_DATUM(2); bool...","count":66},{"name":"api-example","value":"List * untransformRelOptions(Datum options) { List\t   *result = NIL; ArrayType  *array; Datum\t   *optiondatums; int\t\t\tnoptions; int\t\t\ti; if (!PointerIsValid(DatumGetPointer(options))) return result; a...","count":66},{"name":"api-example","value":"bool check_default_table_access_method(char **newval, void **extra, GucSource source) { if (**newval == '\\0') { GUC_check_errdetail(\"\\\"%s\\\" cannot be empty.\", \"default_table_access_method\"); return fa...","count":66},{"name":"api-example","value":"static HeapTuple heap_prepare_insert(Relation relation, HeapTuple tup, TransactionId xid, CommandId cid, int options) { * To allow parallel inserts, we need to ensure that they are safe to be * perfor...","count":66},{"name":"api-example","value":"static void begin_partition(WindowAggState *winstate) { WindowAgg  *node = (WindowAgg *) winstate->ss.ps.plan; PlanState  *outerPlan = outerPlanState(winstate); int\t\t\tframeOptions = winstate->frameOpt...","count":66},{"name":"api-example","value":"static void out_gistxlogPageReuse(StringInfo buf, gistxlogPageReuse *xlrec) { appendStringInfo(buf, \"rel %u/%u/%u; blk %u; snapshotConflictHorizon %u:%u, isCatalogRel %c\", xlrec->locator.spcOid, xlrec...","count":66},{"name":"arch-sublayer","value":"execution-engine","count":65},{"name":"subsystem-desc","value":"Implementation notes about Henry Spencer's regex library\n========================================================\n\nIf Henry ever had any internals documentation, he didn't publish it.\nSo this file is an attempt to reverse-engineer some docs.\n\nGeneral source-file layout\n--------------------------\n\nThere are six separately-compilable source files, five of which expose\nexactly one exported function apiece:\n\tregcomp.c: pg_regcomp\n\tregexec.c: pg_regexec\n\tregerror.c: pg_regerror\n\tregfree.c: pg_regfree\n\tregprefix.c: pg_regprefix\n(The pg_ prefixes were added by the Postgres project to distinguish this\nlibrary version from any similar one that might be present on a particular\nsystem.  They'd need to be removed or replaced in any standalone version\nof the library.)\n\nThe sixth file, regexport.c, exposes multiple functions that allow extraction\nof info about a compiled regex (see regexport.h).\n\nThere are additional source files regc_*.c that are #include'd in regcomp,\nand similarly additional source files rege_*.c that are #include'd in\nregexec.  This was done to avoid exposing internal symbols globally;\nall functions not meant to be part of the library API are static.\n\n(Actually the above is a lie in one respect: there are two more global\nsymbols, pg_set_regex_collation and pg_reg_getcolor in regcomp.  These are\nnot meant to be part of the API, but they have to be global because both\nregcomp and regexec call them.  It'd be better to get rid of\npg_set_regex_collation, as well as the static variables it sets, in favor of\nkeeping the needed locale state in the regex structs.  We have not done this\nyet for lack of a design for how to add application-specific state to the\nstructs.)\n\nWhat's where in src/backend/regex/:\n\nregcomp.c\t\tTop-level regex compilation code\nregc_color.c\t\tColor map management\nregc_cvec.c\t\tCharacter vector (cvec) management\nregc_lex.c\t\tLexer\nregc_nfa.c\t\tNFA handling\nregc_locale.c\t\tApplication-specific locale code from Tcl project\nregc_pg_locale.c\tPostgres-added application-specific locale code\nregexec.c\t\tTop-level regex execution code\nrege_dfa.c\t\tDFA creation and execution\nregerror.c\t\tpg_regerror: generate text for a regex error code\nregfree.c\t\tpg_regfree: API to free a no-longer-needed regex_t\nregexport.c\t\tFunctions for extracting info from a regex_t\nregprefix.c\t\tCode for extracting a common prefix from a regex_t\n\nThe locale-specific code is concerned primarily with case-folding and with\nexpanding locale-specific character classes, such as [[:alnum:]].  It\nreally needs refactoring if this is ever to become a standalone library.\n\nThe header files for the library are in src/include/regex/:\n\nregcustom.h\t\tCustomizes library for particular application\nregerrs.h\t\tError message list\nregex.h\t\t\tExported API\nregexport.h\t\tExported API for regexport.c\nregguts.h\t\tInternals declarations\n\n\nDFAs, NFAs, and all that\n------------------------\n\nThis library is a hybrid DFA/NFA regex implementation.  (If you've never\nheard either of those terms, get thee to a first-year comp sci textbook.)\nIt might not be clear at first glance what that really means and how it\nrelates to what you'll see in the code.  Here's what really happens:\n\n* Initial parsing of a regex generates an NFA representation, with number\nof states approximately proportional to the length of the regexp.\n\n* The NFA is then optimized into a \"compact NFA\" representation, which is\nbasically the same idea but without fields that are not going to be needed\nat runtime.  It is simplified too: the compact format only allows \"plain\"\nand \"LACON\" arc types.  The cNFA representation is what is passed from\nregcomp to regexec.\n\n* Unlike traditional NFA-based regex engines, we do not execute directly\nfrom the NFA representation, as that would require backtracking and so be\nvery slow in some cases.  Rather, we execute a DFA, which ideally can\nprocess an input string in linear time (O(M) for M characters of input)\nwithout backtracking.  Each state of the DFA corresponds to a set of\nstates of the NFA, that is all the states that the NFA might have been in\nupon reaching the current point in the input string.  Therefore, an NFA\nwith N states might require as many as 2^N states in the corresponding\nDFA, which could easily require unreasonable amounts of memory.  We deal\nwith this by materializing states of the DFA lazily (only when needed) and\nkeeping them in a limited-size cache.  The possible need to build the same\nstate of the DFA repeatedly makes this approach not truly O(M) time, but\nin the worst case as much as O(M*N).  That's still far better than the\nworst case for a backtracking NFA engine.\n\nIf that were the end of it, we'd just say this is a DFA engine, with the\nuse of NFAs being merely an implementation detail.  However, a DFA engine\ncannot handle some important regex features such as capturing parens and\nback-references.  If the parser finds that a regex uses these features\n(collectively called \"messy cases\" in the code), then we have to use\nNFA-style backtracking search after all.\n\nWhen using the NFA mode, the representation constructed by the parser\nconsists of a tree of sub-expressions (\"subre\"s).  Leaf tree nodes are\neither plain regular expressions (which are executed as DFAs in the manner\ndescribed above) or back-references (which try to match the input to some\nprevious substring).  Non-leaf nodes are capture nodes (which save the\nlocation of the substring currently matching their child node),\nconcatenation, alternation, or iteration nodes.  At execution time, the\nexecutor recursively scans the tree.  At concatenation, alternation, or\niteration nodes, it considers each possible alternative way of matching the\ninput string, that is each place where the string could be split for a\nconcatenation or iteration, or each child node for an alternation.  It\ntries the next alternative if the match fails according to the child nodes.\nThis is exactly the sort of backtracking search done by a traditional NFA\nregex engine.  If there are many tree levels it can get very slow.\n\nBut all is not lost: we can still be smarter than the average pure NFA\nengine.  To do this, each subre node has an associated DFA, which\nrepresents what the node could possibly match insofar as a mathematically\npure regex can describe that, which basically means \"no backrefs\".\nBefore we perform any search of possible alternative sub-matches, we run\nthe DFA to see if it thinks the proposed substring could possibly match.\nIf not, we can reject the match immediately without iterating through many\npossibilities.\n\nAs an example, consider the regex \"(a[bc]+)\\1\".  The compiled\nrepresentation will have a top-level concatenation subre node.  Its first\nchild is a plain DFA node for \"a[bc]+\" (which is marked as being a capture\nnode).  The concatenation's second child is a backref node for \\1.\nThe DFA associated with the concatenation node will be \"a[bc]+a[bc]+\",\nwhere the backref has been replaced by a copy of the DFA for its referent\nexpression.  When executed, the concatenation node will have to search for\na possible division of the input string that allows its two child nodes to\neach match their part of the string (and although this specific case can\nonly succeed when the division is at the middle, the code does not know\nthat, nor would it be true in general).  However, we can first run the DFA\nand quickly reject any input that doesn't start with an \"a\" and contain\none more \"a\" plus some number of b's and c's.  If the DFA doesn't match,\nthere is no need to recurse to the two child nodes for each possible\nstring division point.  In many cases, this prefiltering makes the search\nrun much faster than a pure NFA engine could do.  It is this behavior that\njustifies using the phrase \"hybrid DFA/NFA engine\" to describe Spencer's\nlibrary.\n\nIt's perhaps worth noting that separate capture subre nodes are a rarity:\nnormally, we just mark a subre as capturing and that's it.  However, it's\nlegal to write a regex like \"((x))\" in which the same substring has to be\ncaptured by multiple sets of parentheses.  Since a subre has room for only\none \"capno\" field, a single subre can't handle that.  We handle such cases\nby wrapping the base subre (which captures the innermost parens) in a\nno-op capture node, or even more than one for \"(((x)))\" etc.  This is a\nlittle bit inefficient because we end up with multiple identical NFAs,\nbut since the case is pointless and infrequent, it's not worth working\nharder.\n\n\nColors and colormapping\n-----------------------\n\nIn many common regex patterns, there are large numbers of characters that\ncan be treated alike by the execution engine.  A simple example is the\npattern \"[[:alpha:]][[:alnum:]]*\" for an identifier.  Basically the engine\nonly needs to care whether an input symbol is a letter, a digit, or other.\nWe could build the NFA or DFA with a separate arc for each possible letter\nand digit, but that's very wasteful of space and not so cheap to execute\neither, especially when dealing with Unicode which can have thousands of\nletters.  Instead, the parser builds a \"color map\" that maps each possible\ninput symbol to a \"color\", or equivalence class.  The NFA or DFA\nrepresentation then has arcs labeled with colors, not specific input\nsymbols.  At execution, the first thing the executor does with each input\nsymbol is to look up its color in the color map, and then everything else\nworks from the color only.\n\nTo build the colormap, we start by assigning every possible input symbol\nthe color WHITE, which means \"other\" (that is, at the end of parsing, the\nsymbols that are still WHITE are those not explicitly referenced anywhere\nin the regex).  When we see a simple literal character or a bracket\nexpression in the regex, we want to assign that character, or all the\ncharacters represented by the bracket expression, a unique new color that\ncan be used to label the NFA arc corresponding to the state transition for\nmatching this character or bracket expression.  The basic idea is:\nfirst, change the color assigned to a character to some new value;\nsecond, run through all the existing arcs in the partially-built NFA,\nand for each one referencing the character's old color, add a parallel\narc referencing its new color (this keeps the reassignment from changing\nthe semantics of what we already built); and third, add a new arc with\nthe character's new color to the current pair of NFA states, denoting\nthat seeing this character allows the state transition to be made.\n\nThis is complicated a bit by not wanting to create more colors\n(equivalence classes) than absolutely necessary.  In particular, if a\nbracket expression mentions two characters that had the same color before,\nthey should still share the same color after we process the bracket, since\nthere is still not a need to distinguish them.  But we do need to\ndistinguish them from other characters that previously had the same color\nyet are not listed in the bracket expression.  To mechanize this, the code\nhas a concept of \"parent colors\" and \"subcolors\", where a color's subcolor\nis the new color that we are giving to any characters of that color while\nparsing the current atom.  (The word \"parent\" is a bit unfortunate here,\nbecause it suggests a long-lived relationship, but a subcolor link really\nonly lasts for the duration of parsing a single atom.)  In other words,\na subcolor link means that we are in process of splitting the parent color\ninto two colors (equivalence classes), depending on whether or not each\nmember character should be included by the current regex atom.\n\nAs an example, suppose we have the regex \"a\\d\\wx\".  Initially all possible\ncharacter codes are labeled WHITE (color 0).  To parse the atom \"a\", we\ncreate a new color (1), update \"a\"'s color map entry to 1, and create an\narc labeled 1 between the first two states of the NFA.  Now we see \\d,\nwhich is really a bracket expression containing the digits \"0\"-\"9\".\nFirst we process \"0\", which is currently WHITE, so we create a new color\n(2), update \"0\"'s color map entry to 2, and create an arc labeled 2\nbetween the second and third states of the NFA.  We also mark color WHITE\nas having the subcolor 2, which means that future relabelings of WHITE\ncharacters should also select 2 as the new color.  Thus, when we process\n\"1\", we won't create a new color but re-use 2.  We update \"1\"'s color map\nentry to 2, and then find that we don't need a new arc because there is\nalready one labeled 2 between the second and third states of the NFA.\nSimilarly for the other 8 digits, so there will be only one arc labeled 2\nbetween NFA states 2 and 3 for all members of this bracket expression.\nAt completion of processing of the bracket expression, we call okcolors()\nwhich breaks all the existing parent/subcolor links; there is no longer a\nmarker saying that WHITE characters should be relabeled 2.  (Note:\nactually, we did the same creation and clearing of a subcolor link for the\nprimitive atom \"a\", but it didn't do anything very interesting.)  Now we\ncome to the \"\\w\" bracket expression, which for simplicity assume expands\nto just \"[a-z0-9]\".  We process \"a\", but observe that it is already the\nsole member of its color 1.  This means there is no need to subdivide that\nequivalence class more finely, so we do not create any new color.  We just\nmake an arc labeled 1 between the third and fourth NFA states.  Next we\nprocess \"b\", which is WHITE and far from the only WHITE character, so we\ncreate a new color (3), link that as WHITE's subcolor, relabel \"b\" as\ncolor 3, and make an arc labeled 3.  As we process \"c\" through \"z\", each\nis relabeled from WHITE to 3, but no new arc is needed.  Now we come to\n\"0\", which is not the only member of its color 2, so we suppose that a new\ncolor is needed and create color 4.  We link 4 as subcolor of 2, relabel\n\"0\" as color 4 in the map, and add an arc for color 4.  Next \"1\" through\n\"9\" are similarly relabeled as color 4, with no additional arcs needed.\nHaving finished the bracket expression, we call okcolors(), which breaks\nthe subcolor links.  okcolors() further observes that we have removed\nevery member of color 2 (the previous color of the digit characters).\nTherefore, it runs through the partial NFA built so far and relabels arcs\nlabeled 2 to color 4; in particular the arc from NFA state 2 to state 3 is\nrelabeled color 4.  Then it frees up color 2, since we have no more use\nfor that color.  We now have an NFA in which transitions for digits are\nconsistently labeled with color 4.  Last, we come to the atom \"x\".\n\"x\" is currently labeled with color 3, and it's not the only member of\nthat color, so we realize that we now need to distinguish \"x\" from other\nletters when we did not before.  We create a new color, which might have\nbeen 5 but instead we recycle the unused color 2.  \"x\" is relabeled 2 in\nthe color map and 2 is linked as the subcolor of 3, and we add an arc for\n2 between states 4 and 5 of the NFA.  Now we call okcolors(), which breaks\nthe subcolor link between colors 3 and 2 and notices that both colors are\nnonempty.  Therefore, it also runs through the existing NFA arcs and adds\nan additional arc labeled 2 wherever there is an arc labeled 3; this\naction ensures that characters of color 2 (i.e., \"x\") will still be\nconsidered as allowing any transitions they did before.  We are now done\nparsing the regex, and we have these final color assignments:\n\tcolor 1: \"a\"\n\tcolor 2: \"x\"\n\tcolor 3: other letters\n\tcolor 4: digits\nand the NFA has these arcs:\n\tstates 1 -> 2 on color 1 (hence, \"a\" only)\n\tstates 2 -> 3 on color 4 (digits)\n\tstates 3 -> 4 on colors 1, 3, 4, and 2 (covering all \\w characters)\n\tstates 4 -> 5 on color 2 (\"x\" only)\nwhich can be seen to be a correct representation of the regex.\n\nThere is one more complexity, which is how to handle \".\", that is a\nmatch-anything atom.  We used to do that by generating a \"rainbow\"\nof arcs of all live colors between the two NFA states before and after\nthe dot.  That's expensive in itself when there are lots of colors,\nand it also typically adds lots of follow-on arc-splitting work for the\ncolor splitting logic.  Now we handle this case by generating a single arc\nlabeled with the special color RAINBOW, meaning all colors.  Such arcs\nnever need to be split, so they help keep NFAs small in this common case.\n(Note: this optimization doesn't help in REG_NLSTOP mode, where \".\" is\nnot supposed to match newline.  In that case we still handle \".\" by\ngenerating an almost-rainbow of all colors except newline's color.)\n\nGiven this summary, we can see we need the following operations for\ncolors:\n\n* A fast way to look up the current color assignment for any character\n  code.  (This is needed during both parsing and execution, while the\n  remaining operations are needed only during parsing.)\n* A way to alter the color assignment for any given character code.\n* We must track the number of characters currently assigned to each\n  color, so that we can detect empty and singleton colors.\n* We must track all existing NFA arcs of a given color, so that we\n  can relabel them at need, or add parallel arcs of a new color when\n  an existing color has to be subdivided.\n\nThe last two of these are handled with the \"struct colordesc\" array and\nthe \"colorchain\" links in NFA arc structs.\n\nIdeally, we'd do the first two operations using a simple linear array\nstoring the current color assignment for each character code.\nUnfortunately, that's not terribly workable for large charsets such as\nUnicode.  Our solution is to divide the color map into two parts.  A simple\nlinear array is used for character codes up to MAX_SIMPLE_CHR, which can be\nchosen large enough to include all popular characters (so that the\nsignificantly-slower code paths about to be described are seldom invoked).\nCharacters above that need be considered at compile time only if they\nappear explicitly in the regex pattern.  We store each such mentioned\ncharacter or character range as an entry in the \"colormaprange\" array in\nthe colormap.  (Overlapping ranges are split into unique subranges, so that\neach range in the finished list needs only a single color that describes\nall its characters.)  When mapping a character above MAX_SIMPLE_CHR to a\ncolor at runtime, we search this list of ranges explicitly.\n\nThat's still not quite enough, though, because of locale-dependent\ncharacter classes such as [[:alpha:]].  In Unicode locales these classes\nmay have thousands of entries that are above MAX_SIMPLE_CHR, and we\ncertainly don't want to be searching large colormaprange arrays at runtime.\nNor do we even want to spend the time to initialize cvec structures that\nexhaustively describe all of those characters.  Our solution is to compute\nexact per-character colors at regex compile time only up to MAX_SIMPLE_CHR.\nFor characters above that, we apply the <ctype.h> or <wctype.h> lookup\nfunctions at runtime for each locale-dependent character class used in the\nregex pattern, constructing a bitmap that describes which classes the\nruntime character belongs to.  The per-character-range data structure\nmentioned above actually holds, for each range, a separate color entry\nfor each possible combination of character class properties.  That is,\nthe color map for characters above MAX_SIMPLE_CHR is really a 2-D array,\nwhose rows correspond to high characters or character ranges that are\nexplicitly mentioned in the regex pattern, and whose columns correspond\nto sets of the locale-dependent character classes that are used in the\nregex.\n\nAs an example, given the pattern '\\w\\u1234[\\U0001D100-\\U0001D1FF]'\n(and supposing that MAX_SIMPLE_CHR is less than 0x1234), we will need\na high color map with three rows.  One row is for the single character\nU+1234 (represented as a single-element range), one is for the range\nU+1D100..U+1D1FF, and the other row represents all remaining high\ncharacters.  The color map has two columns, one for characters that\nsatisfy iswalnum() and one for those that don't.\n\nWe build this color map in parallel with scanning the regex.  Each time\nwe detect a new explicit high character (or range) or a locale-dependent\ncharacter class, we split existing entry(s) in the high color map so that\ncharacters we need to be able to distinguish will have distinct entries\nthat can be given separate colors.  Often, though, single entries in the\nhigh color map will represent very large sets of characters.\n\nIf there are both explicit high characters/ranges and locale-dependent\ncharacter classes, we may have entries in the high color map array that\nhave non-WHITE colors but don't actually represent any real characters.\n(For example, in a row representing a singleton range, only one of the\ncolumns could possibly be a live entry; it's the one matching the actual\nlocale properties for that single character.)  We don't currently make\nany effort to reclaim such colors.  In principle it could be done, but\nit's not clear that it's worth the trouble.\n\n\nDetailed semantics of an NFA\n----------------------------\n\nWhen trying to read dumped-out NFAs, it's helpful to know these facts:\n\nState 0 (additionally marked with \"@\" in dumpnfa's output) is always the\ngoal state, and state 1 (additionally marked with \">\") is the start state.\n(The code refers to these as the post state and pre state respectively.)\n\nThe possible arc types are:\n\n    PLAIN arcs, which specify matching of any character of a given \"color\"\n    (see above).  These are dumped as \"[color_number]->to_state\".\n    In addition there can be \"rainbow\" PLAIN arcs, which are dumped as\n    \"[*]->to_state\".\n\n    EMPTY arcs, which specify a no-op transition to another state.  These\n    are dumped as \"->to_state\".\n\n    AHEAD constraints, which represent a \"next character must be of this\n    color\" constraint.  AHEAD differs from a PLAIN arc in that the input\n    character is not consumed when crossing the arc.  These are dumped as\n    \">color_number>->to_state\", or possibly \">*>->to_state\".\n\n    BEHIND constraints, which represent a \"previous character must be of\n    this color\" constraint, which likewise consumes no input.  These are\n    dumped as \"<color_number<->to_state\", or possibly \"<*<->to_state\".\n\n    '^' arcs, which specify a beginning-of-input constraint.  These are\n    dumped as \"^0->to_state\" or \"^1->to_state\" for beginning-of-string and\n    beginning-of-line constraints respectively.\n\n    '$' arcs, which specify an end-of-input constraint.  These are dumped\n    as \"$0->to_state\" or \"$1->to_state\" for end-of-string and end-of-line\n    constraints respectively.\n\n    LACON constraints, which represent \"(?=re)\", \"(?!re)\", \"(?<=re)\", and\n    \"(?<!re)\" constraints, i.e. the input starting/ending at this point must\n    match (or not match) a given sub-RE, but the matching input is not\n    consumed.  These are dumped as \":subtree_number:->to_state\".\n\nIf you see anything else (especially any question marks) in the display of\nan arc, it's dumpnfa() trying to tell you that there's something fishy\nabout the arc; see the source code.\n\nThe regex executor can only handle PLAIN and LACON transitions.  The regex\noptimize() function is responsible for transforming the parser's output\nto get rid of all the other arc types.  In particular, ^ and $ arcs that\nare not dropped as impossible will always end up adjacent to the pre or\npost state respectively, and then will be converted into PLAIN arcs that\nmention the special \"colors\" for BOS, BOL, EOS, or EOL.\n\nTo decide whether a thus-transformed NFA matches a given substring of the\ninput string, the executor essentially follows these rules:\n1. Start the NFA \"looking at\" the character *before* the given substring,\nor if the substring is at the start of the input, prepend an imaginary BOS\ncharacter instead.\n2. Run the NFA until it has consumed the character *after* the given\nsubstring, or an imaginary following EOS character if the substring is at\nthe end of the input.\n3. If the NFA is (or can be) in the goal state at this point, it matches.\n\nThis definition is necessary to support regexes that begin or end with\nconstraints such as \\m and \\M, which imply requirements on the adjacent\ncharacter if any.  The executor implements that by checking if the\nadjacent character (or BOS/BOL/EOS/EOL pseudo-character) is of the\nright color, and it does that in the same loop that checks characters\nwithin the match.\n\nSo one can mentally execute an untransformed NFA by taking ^ and $ as\nordinary constraints that match at start and end of input; but plain\narcs out of the start state should be taken as matches for the character\nbefore the target substring, and similarly, plain arcs leading to the\npost state are matches for the character after the target substring.\nAfter the optimize() transformation, there are explicit arcs mentioning\nBOS/BOL/EOS/EOL adjacent to the pre-state and post-state.  So a finished\nNFA for a pattern without anchors or adjacent-character constraints will\nhave pre-state outarcs for RAINBOW (all possible character colors) as well\nas BOS and BOL, and likewise post-state inarcs for RAINBOW, EOS, and EOL.\nAlso note that LACON arcs will never connect to the pre-state\nor post-state.\n\n\nLook-around constraints (LACONs)\n--------------------------------\n\nThe regex compiler doesn't have much intelligence about LACONs; it just\nconstructs a sub-NFA representing the pattern that the constraint says to\nmatch or not match, and puts a LACON arc referencing that sub-NFA into the\nmain NFA.  At runtime, the executor applies the sub-NFA at each point in\nthe string where the constraint is relevant, and then traverses or doesn't\ntraverse the arc.  (\"Traversal\" means including the arc's to-state in the\nset of NFA states that are considered active at the next character.)\n\nThe actual basic matching cycle of the executor is\n1.  Identify the color of the next input character, then advance over it.\n2.  Apply the DFA to follow all the matching \"plain\" arcs of the NFA.\n    (Notionally, the previous DFA state represents the set of states the\n    NFA could have been in before the character, and the new DFA state\n    represents the set of states the NFA could be in after the character.)\n3.  If there are any LACON arcs leading out of any of the new NFA states,\n    apply each LACON constraint starting from the new next input character\n    (while not actually consuming any input).  For each successful LACON,\n    add its to-state to the current set of NFA states.  If any such\n    to-state has outgoing LACON arcs, process those in the same way.\n    (Mathematically speaking, we compute the transitive closure of the\n    set of states reachable by successful LACONs.)\n\nThus, LACONs are always checked immediately after consuming a character\nvia a plain arc.  This is okay because the NFA's \"pre\" state only has\nplain out-arcs, so we can always consume a character (possibly a BOS\npseudo-character as described above) before we need to worry about LACONs.","count":65},{"name":"subsystem-name","value":"regex","count":65},{"name":"subsystem-path","value":"backend/regex/readme","count":65},{"name":"api-caller-count","value":"1184","count":64},{"name":"api-caller-count","value":"142","count":64},{"name":"api-caller-count","value":"63","count":64},{"name":"api-typical-usage","value":"Often called from: ExecLimit","count":64},{"name":"api-typical-usage","value":"Often called from: PQconnectPoll","count":64},{"name":"api-typical-usage","value":"Often called from: btree_xlog_split","count":64},{"name":"api-typical-usage","value":"Often called from: check_timezone","count":64},{"name":"api-typical-usage","value":"Often called from: find_param_generator","count":64},{"name":"api-typical-usage","value":"Often called from: hashvalidate","count":64},{"name":"api-typical-usage","value":"Often called from: ident_inet","count":64},{"name":"api-typical-usage","value":"Often called from: llvm_compile_module","count":64},{"name":"api-typical-usage","value":"Often called from: printJsonPathItem","count":64},{"name":"api-typical-usage","value":"Often called from: slot_compile_deform","count":64},{"name":"api-typical-usage","value":"Often called from: tts_virtual_materialize","count":64},{"name":"coupling-score","value":"30","count":64},{"name":"coupling-score","value":"32","count":64},{"name":"coupling-score","value":"36","count":64},{"name":"lines-of-code","value":"126","count":64},{"name":"lines-of-code","value":"152","count":64},{"name":"lines-of-code","value":"154","count":64},{"name":"lines-of-code","value":"163","count":64},{"name":"lines-of-code","value":"175","count":64},{"name":"lines-of-code","value":"180","count":64},{"name":"test-count","value":"66","count":64},{"name":"tested-by","value":"aclcheck_error, aclcheck_error, aclcheck_error, aclcheck_error, aclcheck_error, aclcheck_error, aclcheck_error, aclcheck_error, aclcheck_error, aclcheck_error, aclcheck_error, aclcheck_error, aclcheck","count":64},{"name":"tested-by","value":"check_domain_for_new_field","count":64},{"name":"api-example","value":"int main(int argc, char *argv[]) { PGconn\t   *conn = NULL; SimplePtrListCell *cell; SimplePtrList databases = {NULL, NULL}; SimplePtrList relations = {NULL, NULL}; bool\t\tfailed = false; const char *la...","count":63},{"name":"api-example","value":"static SerializedRanges * brin_range_serialize(Ranges *range) { Size\t\tlen; int\t\t\tnvalues; SerializedRanges *serialized; Oid\t\t\ttypid; int\t\t\ttyplen; bool\t\ttypbyval; char\t   *ptr; Assert(range->nranges >...","count":63},{"name":"api-example","value":"static int CopyGetData(CopyFromState cstate, void *databuf, int minread, int maxread) { int\t\t\tbytesread = 0; switch (cstate->copy_src) { case COPY_FILE: bytesread = fread(databuf, 1, maxread, cstate->...","count":63},{"name":"api-example","value":"static save_locale_t save_global_locale(int category) { save_locale_t save; #ifdef WIN32 save = _wsetlocale(category, NULL); if (!save) pg_fatal(\"_wsetlocale() failed\"); save = wcsdup(save); if (!save...","count":63},{"name":"api-example","value":"static void ExecAppendAsyncEventWait(AppendState *node) { int\t\t\tnevents = node->as_nasyncplans + 2; long\t\ttimeout = node->as_syncdone ? -1 : 0; WaitEvent\toccurred_event[EVENT_BUFFER_SIZE]; int\t\t\tnoccu...","count":63},{"name":"api-example","value":"static void vacuum_error_callback(void *arg) { LVRelState *errinfo = arg; switch (errinfo->phase) { case VACUUM_ERRCB_PHASE_SCAN_HEAP: if (BlockNumberIsValid(errinfo->blkno)) { if (OffsetNumberIsValid...","count":63},{"name":"api-example","value":"void SendBaseBackup(BaseBackupCmd *cmd, IncrementalBackupInfo *ib) { basebackup_options opt; bbsink\t   *sink; SessionBackupState status = get_backup_status(); if (status == SESSION_BACKUP_RUNNING) ere...","count":63},{"name":"arch-layer","value":"replication","count":62},{"name":"arch-layer-description","value":"Replication and WAL management","count":62},{"name":"api-caller-count","value":"51","count":60},{"name":"api-caller-count","value":"76","count":60},{"name":"api-example","value":"Datum heap_getsysattr(HeapTuple tup, int attnum, TupleDesc tupleDesc, bool *isnull) { Datum\t\tresult; Assert(tup); *isnull = false; switch (attnum) { case SelfItemPointerAttributeNumber: result = Point...","count":60},{"name":"api-example","value":"Datum pg_get_wal_resource_managers(PG_FUNCTION_ARGS) { #define PG_GET_RESOURCE_MANAGERS_COLS 3 ReturnSetInfo *rsinfo = (ReturnSetInfo *) fcinfo->resultinfo; Datum\t\tvalues[PG_GET_RESOURCE_MANAGERS_COLS...","count":60},{"name":"api-example","value":"static void HandleParallelMessage(ParallelContext *pcxt, int i, StringInfo msg) { char\t\tmsgtype; if (pcxt->known_attached_workers != NULL && !pcxt->known_attached_workers[i]) { pcxt->known_attached_wo...","count":60},{"name":"api-example","value":"static void XLogWrite(XLogwrtRqst WriteRqst, TimeLineID tli, bool flexible) { bool\t\tispartialpage; bool\t\tlast_iteration; bool\t\tfinishing_seg; int\t\t\tcurridx; int\t\t\tnpages; int\t\t\tstartidx; uint32\t\tstart...","count":60},{"name":"api-example","value":"static void filter_partitions(List *table_infos) { ListCell   *lc; foreach(lc, table_infos) { bool\t\tskip = false; List\t   *ancestors = NIL; ListCell   *lc2; published_rel *table_info = (published_rel ...","count":60},{"name":"api-example","value":"struct varlena * detoast_external_attr(struct varlena *attr) { struct varlena *result; if (VARATT_IS_EXTERNAL_ONDISK(attr)) { * This is an external stored plain value */ result = toast_fetch_datum(att...","count":60},{"name":"api-typical-usage","value":"Often called from: AggregateCreate","count":60},{"name":"api-typical-usage","value":"Often called from: ExecIndexBuildScanKeys","count":60},{"name":"api-typical-usage","value":"Often called from: GenerateTypeDependencies","count":60},{"name":"api-typical-usage","value":"Often called from: ProcessRepliesIfAny","count":60},{"name":"api-typical-usage","value":"Often called from: ProcessStandbyHSFeedbackMessage","count":60},{"name":"api-typical-usage","value":"Often called from: _bt_setup_array_cmp","count":60},{"name":"api-typical-usage","value":"Often called from: array_cat","count":60},{"name":"api-typical-usage","value":"Often called from: getAttrName","count":60},{"name":"api-typical-usage","value":"Often called from: getInsertSelectQuery","count":60},{"name":"api-typical-usage","value":"Often called from: get_row_security_policies","count":60},{"name":"api-typical-usage","value":"Often called from: map_sql_type_to_xmlschema_type","count":60},{"name":"api-typical-usage","value":"Often called from: numeric_abbrev_convert","count":60},{"name":"api-typical-usage","value":"Often called from: rewriteSearchAndCycle","count":60},{"name":"api-typical-usage","value":"Often called from: rowtype_field_matches","count":60},{"name":"api-typical-usage","value":"Often called from: sprintf_s","count":60},{"name":"coupling-score","value":"33","count":60},{"name":"cyclomatic-complexity","value":"62","count":60},{"name":"cyclomatic-complexity","value":"67","count":60},{"name":"cyclomatic-complexity","value":"82","count":60},{"name":"lines-of-code","value":"150","count":60},{"name":"lines-of-code","value":"172","count":60},{"name":"lines-of-code","value":"186","count":60},{"name":"lines-of-code","value":"189","count":60},{"name":"lines-of-code","value":"210","count":60},{"name":"test-count","value":"20","count":60},{"name":"tested-by","value":"_bt_check_unique, _bt_check_unique, check_exclusion_or_unique_constraint, check_exclusion_or_unique_constraint, check_exclusion_or_unique_constraint","count":60},{"name":"tested-by","value":"check_for_data_types_usage, check_for_data_types_usage, check_proper_datallowconn, check_for_isn_and_int8_passing_mismatch, check_for_isn_and_int8_passing_mismatch, check_for_user_defined_postfix_ops,","count":60},{"name":"tested-by","value":"check_nested_generated_walker, check_ungrouped_columns_walker","count":60},{"name":"tested-by","value":"convert_and_check_filename, convert_and_check_filename","count":60},{"name":"api-example","value":"Datum brin_minmax_multi_distance_float4(PG_FUNCTION_ARGS) { float\t\ta1 = PG_GETARG_FLOAT4(0); float\t\ta2 = PG_GETARG_FLOAT4(1); if (isnan(a1) && isnan(a2)) PG_RETURN_FLOAT8(0.0); if (isnan(a1) || isnan(...","count":57},{"name":"api-example","value":"Datum unique_key_recheck(PG_FUNCTION_ARGS) { TriggerData *trigdata = (TriggerData *) fcinfo->context; const char *funcname = \"unique_key_recheck\"; ItemPointerData checktid; ItemPointerData tmptid; Rel...","count":57},{"name":"api-example","value":"XLogReaderState * XLogReaderAllocate(int wal_segment_size, const char *waldir, XLogReaderRoutine *routine, void *private_data) { XLogReaderState *state; state = (XLogReaderState *) palloc_extended(siz...","count":57},{"name":"api-example","value":"static FILE * popen_check(const char *command, const char *mode) { FILE\t   *cmdfd; fflush(NULL); errno = 0; cmdfd = popen(command, mode); if (cmdfd == NULL) pg_log_error(\"could not execute command \\\"%...","count":57},{"name":"api-example","value":"static WalReceiverConn * libpqrcv_connect(const char *conninfo, bool replication, bool logical, bool must_use_password, const char *appname, char **err) { WalReceiverConn *conn; PostgresPollingStatusT...","count":57},{"name":"api-example","value":"static bool InstallXLogFileSegment(XLogSegNo *segno, char *tmppath, bool find_free, XLogSegNo max_segno, TimeLineID tli) { char\t\tpath[MAXPGPATH]; struct stat stat_buf; Assert(tli != 0); XLogFilePath(p...","count":57},{"name":"api-example","value":"static void expand_tuple(HeapTuple *targetHeapTuple, MinimalTuple *targetMinimalTuple, HeapTuple sourceTuple, TupleDesc tupleDesc) { AttrMissing *attrmiss = NULL; int\t\t\tattnum; int\t\t\tfirstmissingnum; ...","count":57},{"name":"api-example","value":"void StartupXLOG(void) { XLogCtlInsert *Insert; CheckPoint\tcheckPoint; bool\t\twasShutdown; bool\t\tdidCrash; bool\t\thaveTblspcMap; bool\t\thaveBackupLabel; XLogRecPtr\tEndOfLog; TimeLineID\tEndOfLogTLI; TimeL...","count":57},{"name":"api-typical-usage","value":"Often called from: AssignTransactionId","count":56},{"name":"api-typical-usage","value":"Often called from: RI_Initial_Check","count":56},{"name":"api-typical-usage","value":"Often called from: SPI_result_code_string","count":56},{"name":"api-typical-usage","value":"Often called from: StartupXLOG","count":56},{"name":"api-typical-usage","value":"Often called from: XlogReadTwoPhaseData","count":56},{"name":"api-typical-usage","value":"Often called from: assign_collations_walker","count":56},{"name":"api-typical-usage","value":"Often called from: expand_indexqual_rowcompare","count":56},{"name":"api-typical-usage","value":"Often called from: ginbuildempty","count":56},{"name":"api-typical-usage","value":"Often called from: heap_create_with_catalog","count":56},{"name":"api-typical-usage","value":"Often called from: inet_spg_consistent_bitmap","count":56},{"name":"api-typical-usage","value":"Often called from: init_params","count":56},{"name":"api-typical-usage","value":"Often called from: plperl_trigger_build_args","count":56},{"name":"api-typical-usage","value":"Often called from: rewriteVisibilityMap","count":56},{"name":"cyclomatic-complexity","value":"74","count":56},{"name":"lines-of-code","value":"143","count":56},{"name":"lines-of-code","value":"145","count":56},{"name":"lines-of-code","value":"160","count":56},{"name":"lines-of-code","value":"170","count":56},{"name":"lines-of-code","value":"174","count":56},{"name":"lines-of-code","value":"178","count":56},{"name":"lines-of-code","value":"219","count":56},{"name":"loop-depth","value":"28","count":56},{"name":"subsystem-desc","value":"src/backend/access/gist/README\n\nGiST Indexing\n=============\n\nThis directory contains an implementation of GiST indexing for Postgres.\n\nGiST stands for Generalized Search Tree. It was introduced in the seminal paper\n\"Generalized Search Trees for Database Systems\", 1995, Joseph M. Hellerstein,\nJeffrey F. Naughton, Avi Pfeffer:\n\n    http://www.sai.msu.su/~megera/postgres/gist/papers/gist.ps\n    https://dsf.berkeley.edu/papers/sigmod97-gist.pdf\n\nand implemented by J. Hellerstein and P. Aoki in an early version of\nPostgreSQL (more details are available from The GiST Indexing Project\nat Berkeley at http://gist.cs.berkeley.edu/). As a \"university\"\nproject it had a limited number of features and was in rare use.\n\nThe current implementation of GiST supports:\n\n  * Variable length keys\n  * Composite keys (multi-key)\n  * Ordered search (nearest-neighbor search)\n  * provides NULL-safe interface to GiST core\n  * Concurrency\n  * Recovery support via WAL logging\n  * Buffering build algorithm\n  * Sorted build method\n\nThe support for concurrency implemented in PostgreSQL was developed based on\nthe paper \"Access Methods for Next-Generation Database Systems\" by\nMarcel Kornacker:\n\n    http://www.sai.msu.su/~megera/postgres/gist/papers/concurrency/access-methods-for-next-generation.pdf.gz\n\nBuffering build algorithm for GiST was developed based on the paper \"Efficient\nBulk Operations on Dynamic R-trees\" by Lars Arge, Klaus Hinrichs, Jan Vahrenhold\nand Jeffrey Scott Vitter.\n\n    http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.135.9894&rep=rep1&type=pdf\n\nThe original algorithms were modified in several ways:\n\n* They had to be adapted to PostgreSQL conventions. For example, the SEARCH\n  algorithm was considerably changed, because in PostgreSQL the search function\n  should return one tuple (next), not all tuples at once. Also, it should\n  release page locks between calls.\n* Since we added support for variable length keys, it's not possible to\n  guarantee enough free space for all keys on pages after splitting. User\n  defined function picksplit doesn't have information about size of tuples\n  (each tuple may contain several keys as in multicolumn index while picksplit\n  could work with only one key) and pages.\n* We modified original INSERT algorithm for performance reasons. In particular,\n  it is now a single-pass algorithm.\n* Since the papers were theoretical, some details were omitted and we\n  had to find out ourself how to solve some specific problems.\n\nBecause of the above reasons, we have revised the interaction of GiST\ncore and PostgreSQL WAL system. Moreover, we encountered (and solved)\na problem of uncompleted insertions when recovering after crash, which\nwas not touched in the paper.\n\nSearch Algorithm\n----------------\n\nThe search code maintains a queue of unvisited items, where an \"item\" is\neither a heap tuple known to satisfy the search conditions, or an index\npage that is consistent with the search conditions according to inspection\nof its parent page's downlink item.  Initially the root page is searched\nto find unvisited items in it.  Then we pull items from the queue.  A\nheap tuple pointer is just returned immediately; an index page entry\ncauses that page to be searched, generating more queue entries.\n\nThe queue is kept ordered with heap tuple items at the front, then\nindex page entries, with any newly-added index page entry inserted\nbefore existing index page entries.  This ensures depth-first traversal\nof the index, and in particular causes the first few heap tuples to be\nreturned as soon as possible.  That is helpful in case there is a LIMIT\nthat requires only a few tuples to be produced.\n\nTo implement nearest-neighbor search, the queue entries are augmented\nwith distance data: heap tuple entries are labeled with exact distance\nfrom the search argument, while index-page entries must be labeled with\nthe minimum distance that any of their children could have.  Then,\nqueue entries are retrieved in smallest-distance-first order, with\nentries having identical distances managed as stated in the previous\nparagraph.\n\nThe search algorithm keeps an index page locked only long enough to scan\nits entries and queue those that satisfy the search conditions.  Since\ninsertions can occur concurrently with searches, it is possible for an\nindex child page to be split between the time we make a queue entry for it\n(while visiting its parent page) and the time we actually reach and scan\nthe child page.  To avoid missing the entries that were moved to the right\nsibling, we detect whether a split has occurred by comparing the child\npage's NSN (node sequence number, a special-purpose LSN) to the LSN that\nthe parent had when visited.  If it did, the sibling page is immediately\nadded to the front of the queue, ensuring that its items will be scanned\nin the same order as if they were still on the original child page.\n\nAs is usual in Postgres, the search algorithm only guarantees to find index\nentries that existed before the scan started; index entries added during\nthe scan might or might not be visited.  This is okay as long as all\nsearches use MVCC snapshot rules to reject heap tuples newer than the time\nof scan start.  In particular, this means that we need not worry about\ncases where a parent page's downlink key is \"enlarged\" after we look at it.\nAny such enlargement would be to add child items that we aren't interested\nin returning anyway.\n\n\nInsert Algorithm\n----------------\n\nINSERT guarantees that the GiST tree remains balanced. User defined key method\nPenalty is used for choosing a subtree to insert; method PickSplit is used for\nthe node splitting algorithm; method Union is used for propagating changes\nupward to maintain the tree properties.\n\nTo insert a tuple, we first have to find a suitable leaf page to insert to.\nThe algorithm walks down the tree, starting from the root, along the path\nof smallest Penalty. At each step:\n\n1. Has this page been split since we looked at the parent? If so, it's\npossible that we should be inserting to the other half instead, so retreat\nback to the parent.\n2. If this is a leaf node, we've found our target node.\n3. Otherwise use Penalty to pick a new target subtree.\n4. Check the key representing the target subtree. If it doesn't already cover\nthe key we're inserting, replace it with the Union of the old downlink key\nand the key being inserted. (Actually, we always call Union, and just skip\nthe replacement if the Unioned key is the same as the existing key)\n5. Replacing the key in step 4 might cause the page to be split. In that case,\npropagate the change upwards and restart the algorithm from the first parent\nthat didn't need to be split.\n6. Walk down to the target subtree, and goto 1.\n\nThis differs from the insertion algorithm in the original paper. In the\noriginal paper, you first walk down the tree until you reach a leaf page, and\nthen you adjust the downlink in the parent, and propagate the adjustment up,\nall the way up to the root in the worst case. But we adjust the downlinks to\ncover the new key already when we walk down, so that when we reach the leaf\npage, we don't need to update the parents anymore, except to insert the\ndownlinks if we have to split the page. This makes crash recovery simpler:\nafter inserting a key to the page, the tree is immediately self-consistent\nwithout having to update the parents. Even if we split a page and crash before\ninserting the downlink to the parent, the tree is self-consistent because the\nright half of the split is accessible via the rightlink of the left page\n(which replaced the original page).\n\nNote that the algorithm can walk up and down the tree before reaching a leaf\npage, if internal pages need to split while adjusting the downlinks for the\nnew key. Eventually, you should reach the bottom, and proceed with the\ninsertion of the new tuple.\n\nOnce we've found the target page to insert to, we check if there's room\nfor the new tuple. If there is, the tuple is inserted, and we're done.\nIf it doesn't fit, however, the page needs to be split. Note that it is\npossible that a page needs to be split into more than two pages, if keys have\ndifferent lengths or more than one key is being inserted at a time (which can\nhappen when inserting downlinks for a page split that resulted in more than\ntwo pages at the lower level). After splitting a page, the parent page needs\nto be updated. The downlink for the new page needs to be inserted, and the\ndownlink for the old page, which became the left half of the split, needs to\nbe updated to only cover those tuples that stayed on the left page. Inserting\nthe downlink in the parent can again lead to a page split, recursing up to the\nroot page in the worst case.\n\ngistplacetopage is the workhorse function that performs one step of the\ninsertion. If the tuple fits, it inserts it to the given page, otherwise\nit splits the page, and constructs the new downlink tuples for the split\npages. The caller must then call gistplacetopage() on the parent page to\ninsert the downlink tuples. The parent page that holds the downlink to\nthe child might have migrated as a result of concurrent splits of the\nparent, gistFindCorrectParent() is used to find the parent page.\n\nSplitting the root page works slightly differently. At root split,\ngistplacetopage() allocates the new child pages and replaces the old root\npage with the new root containing downlinks to the new children, all in one\noperation.\n\n\nfindPath is a subroutine of findParent, used when the correct parent page\ncan't be found by following the rightlinks at the parent level:\n\nfindPath( stack item )\n\tpush stack, [root, 0, 0] // page, LSN, parent\n\twhile( stack )\n\t\tptr = top of stack\n\t\tlatch( ptr->page, S-mode )\n\t\tif ( ptr->parent->page->lsn < ptr->page->nsn )\n\t\t\tpush stack, [ ptr->page->rightlink, 0, ptr->parent ]\n\t\tend\n\t\tfor( each tuple on page )\n\t\t\tif ( tuple->pagepointer == item->page )\n\t\t\t\treturn stack\n\t\t\telse\n\t\t\t\tadd to stack at the end [tuple->pagepointer,0, ptr]\n\t\t\tend\n\t\tend\n\t\tunlatch( ptr->page )\n\t\tpop stack\n\tend\n\n\ngistFindCorrectParent is used to re-find the parent of a page during\ninsertion. It might have migrated to the right since we traversed down the\ntree because of page splits.\n\nfindParent( stack item )\n\tparent = item->parent\n\tif ( parent->page->lsn != parent->lsn )\n\t\twhile(true)\n\t\t\tsearch parent tuple on parent->page, if found the return\n\t\t\trightlink = parent->page->rightlink\n\t\t\tunlatch( parent->page )\n\t\t\tif ( rightlink is incorrect )\n\t\t\t\tbreak loop\n\t\t\tend\n\t\t\tparent->page = rightlink\n\t\t\tlatch( parent->page, X-mode )\n\t\tend\n\t\tnewstack = findPath( item->parent )\n\t\treplace part of stack to new one\n\t\tlatch( parent->page, X-mode )\n\t\treturn findParent( item )\n\tend\n\npageSplit function decides how to distribute keys to the new pages after\npage split:\n\npageSplit(page, allkeys)\n\t(lkeys, rkeys) = pickSplit( allkeys )\n\tif ( page is root )\n\t\tlpage = new page\n\telse\n\t\tlpage = page\n\trpage = new page\n\tif ( no space left on rpage )\n\t\tnewkeys = pageSplit( rpage, rkeys )\n\telse\n\t\tpush newkeys, union(rkeys)\n\tend\n\tif ( no space left on lpage )\n\t\tpush newkeys, pageSplit( lpage, lkeys )\n\telse\n\t\tpush newkeys, union(lkeys)\n\tend\n\treturn newkeys\n\n\n\nConcurrency control\n-------------------\nAs a rule of thumb, if you need to hold a lock on multiple pages at the\nsame time, the locks should be acquired in the following order: child page\nbefore parent, and left-to-right at the same level. Always acquiring the\nlocks in the same order avoids deadlocks.\n\nThe search algorithm only looks at and locks one page at a time. Consequently\nthere's a race condition between a search and a page split. A page split\nhappens in two phases: 1. The page is split 2. The downlink is inserted to the\nparent. If a search looks at the parent page between those steps, before the\ndownlink is inserted, it will still find the new right half by following the\nrightlink on the left half. But it must not follow the rightlink if it saw the\ndownlink in the parent, or the page will be visited twice!\n\nA split initially marks the left page with the F_FOLLOW_RIGHT flag. If a scan\nsees that flag set, it knows that the right page is missing the downlink, and\nshould be visited too. When split inserts the downlink to the parent, it\nclears the F_FOLLOW_RIGHT flag in the child, and sets the NSN field in the\nchild page header to match the LSN of the insertion on the parent. If the\nF_FOLLOW_RIGHT flag is not set, a scan compares the NSN on the child and the\nLSN it saw in the parent. If the child's NSN is greater than the LSN seen on\nthe parent, the scan looked at the parent page before the downlink was\ninserted, so it should follow the rightlink. Otherwise the scan saw the\ndownlink in the parent page, and will/did follow that as usual.\n\nA scan can't normally see a page with the F_FOLLOW_RIGHT flag set, because\na page split keeps the child pages locked until the downlink has been inserted\nto the parent and the flag cleared again. But if a crash happens in the middle\nof a page split, before the downlinks are inserted into the parent, that will\nleave a page with F_FOLLOW_RIGHT in the tree. Scans handle that just fine,\nbut we'll eventually want to fix that for performance reasons. And more\nimportantly, dealing with pages with missing downlink pointers in the parent\nwould complicate the insertion algorithm. So when an insertion sees a page\nwith F_FOLLOW_RIGHT set, it immediately tries to bring the split that\ncrashed in the middle to completion by adding the downlink in the parent.\n\nBuffering build algorithm\n-------------------------\n\nIn the buffering index build algorithm, some or all internal nodes have a\nbuffer attached to them. When a tuple is inserted at the top, the descend down\nthe tree is stopped as soon as a buffer is reached, and the tuple is pushed to\nthe buffer. When a buffer gets too full, all the tuples in it are flushed to\nthe lower level, where they again hit lower level buffers or leaf pages. This\nmakes the insertions happen in more of a breadth-first than depth-first order,\nwhich greatly reduces the amount of random I/O required.\n\nIn the algorithm, levels are numbered so that leaf pages have level zero,\nand internal node levels count up from 1. This numbering ensures that a page's\nlevel number never changes, even when the root page is split.\n\nLevel                    Tree\n\n3                         *\n                      /       \\\n2                *                 *\n              /  |  \\           /  |  \\\n1          *     *     *     *     *     *\n          / \\   / \\   / \\   / \\   / \\   / \\\n0        o   o o   o o   o o   o o   o o   o\n\n* - internal page\no - leaf page\n\nInternal pages that belong to certain levels have buffers associated with\nthem. Leaf pages never have buffers. Which levels have buffers is controlled\nby \"level step\" parameter: level numbers that are multiples of level_step\nhave buffers, while others do not. For example, if level_step = 2, then\npages on levels 2, 4, 6, ... have buffers. If level_step = 1 then every\ninternal page has a buffer.\n\nLevel        Tree (level_step = 1)                Tree (level_step = 2)\n\n3                      *                                     *\n                   /       \\                             /       \\\n2             *(b)              *(b)                *(b)              *(b)\n           /  |  \\           /  |  \\             /  |  \\           /  |  \\\n1       *(b)  *(b)  *(b)  *(b)  *(b)  *(b)    *     *     *     *     *     *\n       / \\   / \\   / \\   / \\   / \\   / \\     / \\   / \\   / \\   / \\   / \\   / \\\n0     o   o o   o o   o o   o o   o o   o   o   o o   o o   o o   o o   o o   o\n\n(b) - buffer\n\nLogically, a buffer is just bunch of tuples. Physically, it is divided in\npages, backed by a temporary file. Each buffer can be in one of two states:\na) Last page of the buffer is kept in main memory. A node buffer is\nautomatically switched to this state when a new index tuple is added to it,\nor a tuple is removed from it.\nb) All pages of the buffer are swapped out to disk. When a buffer becomes too\nfull, and we start to flush it, all other buffers are switched to this state.\n\nWhen an index tuple is inserted, its initial processing can end in one of the\nfollowing points:\n1) Leaf page, if the depth of the index <= level_step, meaning that\n   none of the internal pages have buffers associated with them.\n2) Buffer of topmost level page that has buffers.\n\nNew index tuples are processed until one of the buffers in the topmost\nbuffered level becomes half-full. When a buffer becomes half-full, it's added\nto the emptying queue, and will be emptied before a new tuple is processed.\n\nBuffer emptying process means that index tuples from the buffer are moved\ninto buffers at a lower level, or leaf pages. First, all the other buffers are\nswapped to disk to free up the memory. Then tuples are popped from the buffer\none by one, and cascaded down the tree to the next buffer or leaf page below\nthe buffered node.\n\nEmptying a buffer has the interesting dynamic property that any intermediate\npages between the buffer being emptied, and the next buffered or leaf level\nbelow it, become cached. If there are no more buffers below the node, the leaf\npages where the tuples finally land on get cached too. If there are, the last\nbuffer page of each buffer below is kept in memory. This is illustrated in\nthe figures below:\n\n   Buffer being emptied to\n     lower-level buffers               Buffer being emptied to leaf pages\n\n               +(fb)                                 +(fb)\n            /     \\                                /     \\\n        +             +                        +             +\n      /   \\         /   \\                    /   \\         /   \\\n    *(ab)   *(ab) *(ab)   *(ab)            x       x     x       x\n\n+    - cached internal page\nx    - cached leaf page\n*    - non-cached internal page\n(fb) - buffer being emptied\n(ab) - buffers being appended to, with last page in memory\n\nIn the beginning of the index build, the level-step is chosen so that all those\npages involved in emptying one buffer fit in cache, so after each of those\npages have been accessed once and cached, emptying a buffer doesn't involve\nany more I/O. This locality is where the speedup of the buffering algorithm\ncomes from.\n\nEmptying one buffer can fill up one or more of the lower-level buffers,\ntriggering emptying of them as well. Whenever a buffer becomes too full, it's\nadded to the emptying queue, and will be emptied after the current buffer has\nbeen processed.\n\nTo keep the size of each buffer limited even in the worst case, buffer emptying\nis scheduled as soon as a buffer becomes half-full, and emptying it continues\nuntil 1/2 of the nominal buffer size worth of tuples has been emptied. This\nguarantees that when buffer emptying begins, all the lower-level buffers\nare at most half-full. In the worst case that all the tuples are cascaded down\nto the same lower-level buffer, that buffer therefore has enough space to\naccommodate all the tuples emptied from the upper-level buffer. There is no\nhard size limit in any of the data structures used, though, so this only needs\nto be approximate; small overfilling of some buffers doesn't matter.\n\nIf an internal page that has a buffer associated with it is split, the buffer\nneeds to be split too. All tuples in the buffer are scanned through and\nrelocated to the correct sibling buffers, using the penalty function to decide\nwhich buffer each tuple should go to.\n\nAfter all tuples from the heap have been processed, there are still some index\ntuples in the buffers. At this point, final buffer emptying starts. All buffers\nare emptied in top-down order. This is slightly complicated by the fact that\nnew buffers can be allocated during the emptying, due to page splits. However,\nthe new buffers will always be siblings of buffers that haven't been fully\nemptied yet; tuples never move upwards in the tree. The final emptying loops\nthrough buffers at a given level until all buffers at that level have been\nemptied, and then moves down to the next level.\n\nSorted build method\n-------------------\n\nSort all input tuples, pack them into GiST leaf pages in the sorted order,\nand create downlinks and internal pages as we go. This method builds the index\nfrom the bottom up, similar to how the B-tree index is built.\n\nThe sorted method is used if the operator classes for all columns have a\n\"sortsupport\" defined. Otherwise, we fall back on inserting tuples one by one\nwith optional buffering.\n\nSorting GiST build requires good linearization of the sort opclass. That is not\nalways the case in multidimensional data. To tackle the anomalies, we buffer\nindex tuples and apply a picksplit function that can be multidimensional-aware.\n\nBulk delete algorithm (VACUUM)\n------------------------------\n\nVACUUM works in two stages:\n\nIn the first stage, we scan the whole index in physical order. To make sure\nthat we don't miss any dead tuples because a concurrent page split moved them,\nwe check the F_FOLLOW_RIGHT flags and NSN on each page, to detect if the\npage has been concurrently split. If a concurrent page split is detected, and\none half of the page was moved to a position that we already scanned, we\n\"jump backwards\" to scan the page again. This is the same mechanism that\nB-tree VACUUM uses, but because we already have NSNs on pages, to detect page\nsplits during searches, we don't need a \"vacuum cycle ID\" concept for that\nlike B-tree does.\n\nWhile we scan all the pages, we also make note of any completely empty leaf\npages. We will try to unlink them from the tree after the scan. We also record\nthe block numbers of all internal pages; they are needed to locate parents of\nthe empty pages while unlinking them.\n\nWe try to unlink any empty leaf pages from the tree, so that their space can\nbe reused. In order to delete an empty page, its downlink must be removed from\nthe parent. We scan all the internal pages, whose block numbers we memorized\nin the first stage, and look for downlinks to pages that we have memorized as\nbeing empty. Whenever we find one, we acquire a lock on the parent and child\npage, re-check that the child page is still empty. Then, we remove the\ndownlink and mark the child as deleted, and release the locks.\n\nThe insertion algorithm would get confused, if an internal page was completely\nempty. So we never delete the last child of an internal page, even if it's\nempty. Currently, we only support deleting leaf pages.\n\nThis page deletion algorithm works on a best-effort basis. It might fail to\nfind a downlink, if a concurrent page split moved it after the first stage.\nIn that case, we won't be able to remove all empty pages. That's OK, it's\nnot expected to happen very often, and hopefully the next VACUUM will clean\nit up.\n\nWhen we have deleted a page, it's possible that an in-progress search will\nstill descend on the page, if it saw the downlink before we removed it. The\nsearch will see that it is deleted, and ignore it, but as long as that can\nhappen, we cannot reuse the page. To \"wait out\" any in-progress searches, when\na page is deleted, it's labeled with the current next-transaction counter\nvalue. The page is not recycled, until that XID is no longer visible to\nanyone. That's much more conservative than necessary, but let's keep it\nsimple.\n\n\nAuthors:\n\tTeodor Sigaev\t<teodor@sigaev.ru>\n\tOleg Bartunov\t<oleg@sai.msu.su>","count":55},{"name":"subsystem-desc","value":"src/backend/access/nbtree/README\n\nBtree Indexing\n==============\n\nThis directory contains a correct implementation of Lehman and Yao's\nhigh-concurrency B-tree management algorithm (P. Lehman and S. Yao,\nEfficient Locking for Concurrent Operations on B-Trees, ACM Transactions\non Database Systems, Vol 6, No. 4, December 1981, pp 650-670).  We also\nuse a simplified version of the deletion logic described in Lanin and\nShasha (V. Lanin and D. Shasha, A Symmetric Concurrent B-Tree Algorithm,\nProceedings of 1986 Fall Joint Computer Conference, pp 380-389).\n\nThe basic Lehman & Yao Algorithm\n--------------------------------\n\nCompared to a classic B-tree, L&Y adds a right-link pointer to each page,\nto the page's right sibling.  It also adds a \"high key\" to each page, which\nis an upper bound on the keys that are allowed on that page.  These two\nadditions make it possible to detect a concurrent page split, which allows\nthe tree to be searched without holding any read locks (except to keep a\nsingle page from being modified while reading it).\n\nWhen a search follows a downlink to a child page, it compares the page's\nhigh key with the search key.  If the search key is greater than the high\nkey, the page must've been split concurrently, and you must follow the\nright-link to find the new page containing the key range you're looking\nfor.  This might need to be repeated, if the page has been split more than\nonce.\n\nLehman and Yao talk about alternating \"separator\" keys and downlinks in\ninternal pages rather than tuples or records.  We use the term \"pivot\"\ntuple to refer to tuples which don't point to heap tuples, that are used\nonly for tree navigation.  All tuples on non-leaf pages and high keys on\nleaf pages are pivot tuples.  Since pivot tuples are only used to represent\nwhich part of the key space belongs on each page, they can have attribute\nvalues copied from non-pivot tuples that were deleted and killed by VACUUM\nsome time ago.  A pivot tuple may contain a \"separator\" key and downlink,\njust a separator key (i.e. the downlink value is implicitly undefined), or\njust a downlink (i.e. all attributes are truncated away).\n\nThe requirement that all btree keys be unique is satisfied by treating heap\nTID as a tiebreaker attribute.  Logical duplicates are sorted in heap TID\norder.  This is necessary because Lehman and Yao also require that the key\nrange for a subtree S is described by Ki < v <= Ki+1 where Ki and Ki+1 are\nthe adjacent keys in the parent page (Ki must be _strictly_ less than v,\nwhich is assured by having reliably unique keys).  Keys are always unique\non their level, with the exception of a leaf page's high key, which can be\nfully equal to the last item on the page.\n\nThe Postgres implementation of suffix truncation must make sure that the\nLehman and Yao invariants hold, and represents that absent/truncated\nattributes in pivot tuples have the sentinel value \"minus infinity\".  The\nlater section on suffix truncation will be helpful if it's unclear how the\nLehman & Yao invariants work with a real world example.\n\nDifferences to the Lehman & Yao algorithm\n-----------------------------------------\n\nWe have made the following changes in order to incorporate the L&Y algorithm\ninto Postgres:\n\nLehman and Yao don't require read locks, but assume that in-memory\ncopies of tree pages are unshared.  Postgres shares in-memory buffers\namong backends.  As a result, we do page-level read locking on btree\npages in order to guarantee that no record is modified while we are\nexamining it.  This reduces concurrency but guarantees correct\nbehavior.\n\nWe support the notion of an ordered \"scan\" of an index as well as\ninsertions, deletions, and simple lookups.  A scan in the forward\ndirection is no problem, we just use the right-sibling pointers that\nL&Y require anyway.  (Thus, once we have descended the tree to the\ncorrect start point for the scan, the scan looks only at leaf pages\nand never at higher tree levels.)  To support scans in the backward\ndirection, we also store a \"left sibling\" link much like the \"right\nsibling\".  (This adds an extra step to the L&Y split algorithm: while\nholding the write lock on the page being split, we also lock its former\nright sibling to update that page's left-link.  This is safe since no\nwriter of that page can be interested in acquiring a write lock on our\npage.)  A backwards scan has one additional bit of complexity: after\nfollowing the left-link we must account for the possibility that the\nleft sibling page got split before we could read it.  So, we have to\nmove right until we find a page whose right-link matches the page we\ncame from.  (Actually, it's even harder than that; see page deletion\ndiscussion below.)\n\nPage read locks are held only for as long as a scan is examining a page.\nTo minimize lock/unlock traffic, an index scan always searches a leaf page\nto identify all the matching items at once, copying their heap tuple IDs\ninto backend-local storage.  The heap tuple IDs are then processed while\nnot holding any page lock within the index.  We do continue to hold a pin\non the leaf page in some circumstances, to protect against concurrent\ndeletions (see below).  In this state the scan is effectively stopped\n\"between\" pages, either before or after the page it has pinned.  This is\nsafe in the presence of concurrent insertions and even page splits, because\nitems are never moved across pre-existing page boundaries --- so the scan\ncannot miss any items it should have seen, nor accidentally return the same\nitem twice.  The scan must remember the page's right-link at the time it\nwas scanned, since that is the page to move right to; if we move right to\nthe current right-link then we'd re-scan any items moved by a page split.\nWe don't similarly remember the left-link, since it's best to use the most\nup-to-date left-link when trying to move left (see detailed move-left\nalgorithm below).\n\nIn most cases we release our lock and pin on a page before attempting\nto acquire pin and lock on the page we are moving to.  In a few places\nit is necessary to lock the next page before releasing the current one.\nThis is safe when moving right or up, but not when moving left or down\n(else we'd create the possibility of deadlocks).\n\nLehman and Yao fail to discuss what must happen when the root page\nbecomes full and must be split.  Our implementation is to split the\nroot in the same way that any other page would be split, then construct\na new root page holding pointers to both of the resulting pages (which\nnow become siblings on the next level of the tree).  The new root page\nis then installed by altering the root pointer in the meta-data page (see\nbelow).  This works because the root is not treated specially in any\nother way --- in particular, searches will move right using its link\npointer if the link is set.  Therefore, searches will find the data\nthat's been moved into the right sibling even if they read the meta-data\npage before it got updated.  This is the same reasoning that makes a\nsplit of a non-root page safe.  The locking considerations are similar too.\n\nWhen an inserter recurses up the tree, splitting internal pages to insert\nlinks to pages inserted on the level below, it is possible that it will\nneed to access a page above the level that was the root when it began its\ndescent (or more accurately, the level that was the root when it read the\nmeta-data page).  In this case the stack it made while descending does not\nhelp for finding the correct page.  When this happens, we find the correct\nplace by re-descending the tree until we reach the level one above the\nlevel we need to insert a link to, and then moving right as necessary.\n(Typically this will take only two fetches, the meta-data page and the new\nroot, but in principle there could have been more than one root split\nsince we saw the root.  We can identify the correct tree level by means of\nthe level numbers stored in each page.  The situation is rare enough that\nwe do not need a more efficient solution.)\n\nLehman and Yao must couple/chain locks as part of moving right when\nrelocating a child page's downlink during an ascent of the tree.  This is\nthe only point where Lehman and Yao have to simultaneously hold three\nlocks (a lock on the child, the original parent, and the original parent's\nright sibling).  We don't need to couple internal page locks for pages on\nthe same level, though.  We match a child's block number to a downlink\nfrom a pivot tuple one level up, whereas Lehman and Yao match on the\nseparator key associated with the downlink that was followed during the\ninitial descent.  We can release the lock on the original parent page\nbefore acquiring a lock on its right sibling, since there is never any\nneed to deal with the case where the separator key that we must relocate\nbecomes the original parent's high key.  Lanin and Shasha don't couple\nlocks here either, though they also don't couple locks between levels\nduring ascents.  They are willing to \"wait and try again\" to avoid races.\nTheir algorithm is optimistic, which means that \"an insertion holds no\nmore than one write lock at a time during its ascent\".  We more or less\nstick with Lehman and Yao's approach of conservatively coupling parent and\nchild locks when ascending the tree, since it's far simpler.\n\nLehman and Yao assume fixed-size keys, but we must deal with\nvariable-size keys.  Therefore there is not a fixed maximum number of\nkeys per page; we just stuff in as many as will fit.  When we split a\npage, we try to equalize the number of bytes, not items, assigned to\npages (though suffix truncation is also considered).  Note we must include\nthe incoming item in this calculation, otherwise it is possible to find\nthat the incoming item doesn't fit on the split page where it needs to go!\n\nDeleting index tuples during VACUUM\n-----------------------------------\n\nBefore deleting a leaf item, we get a full cleanup lock on the target\npage, so that no other backend has a pin on the page when the deletion\nstarts.  This is not necessary for correctness in terms of the btree index\noperations themselves; as explained above, index scans logically stop\n\"between\" pages and so can't lose their place.  The reason we do it is to\nprovide an interlock between VACUUM and index scans that are not prepared\nto deal with concurrent TID recycling when visiting the heap.  Since only\nVACUUM can ever mark pointed-to items LP_UNUSED in the heap, and since\nthis only ever happens _after_ btbulkdelete returns, having index scans\nhold on to the pin (used when reading from the leaf page) until _after_\nthey're done visiting the heap (for TIDs from pinned leaf page) prevents\nconcurrent TID recycling.  VACUUM cannot get a conflicting cleanup lock\nuntil the index scan is totally finished processing its leaf page.\n\nThis approach is fairly coarse, so we avoid it whenever possible.  In\npractice most index scans won't hold onto their pin, and so won't block\nVACUUM.  These index scans must deal with TID recycling directly, which is\nmore complicated and not always possible.  See later section on making\nconcurrent TID recycling safe.\n\nOpportunistic index tuple deletion performs almost the same page-level\nmodifications while only holding an exclusive lock.  This is safe because\nthere is no question of TID recycling taking place later on -- only VACUUM\ncan make TIDs recyclable.  See also simple deletion and bottom-up\ndeletion, below.\n\nBecause a pin is not always held, and a page can be split even while\nsomeone does hold a pin on it, it is possible that an indexscan will\nreturn items that are no longer stored on the page it has a pin on, but\nrather somewhere to the right of that page.  To ensure that VACUUM can't\nprematurely make TIDs recyclable in this scenario, we require btbulkdelete\nto obtain a cleanup lock on every leaf page in the index, even pages that\ndon't contain any deletable tuples.  Note that this requirement does not\nsay that btbulkdelete must visit the pages in any particular order.\n\nVACUUM's linear scan, concurrent page splits\n--------------------------------------------\n\nVACUUM accesses the index by doing a linear scan to search for deletable\nTIDs, while considering the possibility of deleting empty pages in\npassing.  This is in physical/block order, not logical/keyspace order.\nThe tricky part of this is avoiding missing any deletable tuples in the\npresence of concurrent page splits: a page split could easily move some\ntuples from a page not yet passed over by the sequential scan to a\nlower-numbered page already passed over.\n\nTo implement this, we provide a \"vacuum cycle ID\" mechanism that makes it\npossible to determine whether a page has been split since the current\nbtbulkdelete cycle started.  If btbulkdelete finds a page that has been\nsplit since it started, and has a right-link pointing to a lower page\nnumber, then it temporarily suspends its sequential scan and visits that\npage instead.  It must continue to follow right-links and vacuum dead\ntuples until reaching a page that either hasn't been split since\nbtbulkdelete started, or is above the location of the outer sequential\nscan.  Then it can resume the sequential scan.  This ensures that all\ntuples are visited.  It may be that some tuples are visited twice, but\nthat has no worse effect than an inaccurate index tuple count (and we\ncan't guarantee an accurate count anyway in the face of concurrent\nactivity).  Note that this still works if the has-been-recently-split test\nhas a small probability of false positives, so long as it never gives a\nfalse negative.  This makes it possible to implement the test with a small\ncounter value stored on each index page.\n\nDeleting entire pages during VACUUM\n-----------------------------------\n\nWe consider deleting an entire page from the btree only when it's become\ncompletely empty of items.  (Merging partly-full pages would allow better\nspace reuse, but it seems impractical to move existing data items left or\nright to make this happen --- a scan moving in the opposite direction\nmight miss the items if so.)  Also, we *never* delete the rightmost page\non a tree level (this restriction simplifies the traversal algorithms, as\nexplained below).  Page deletion always begins from an empty leaf page.  An\ninternal page can only be deleted as part of deleting an entire subtree.\nThis is always a \"skinny\" subtree consisting of a \"chain\" of internal pages\nplus a single leaf page.  There is one page on each level of the subtree,\nand each level/page covers the same key space.\n\nDeleting a leaf page is a two-stage process.  In the first stage, the page\nis unlinked from its parent, and marked as half-dead.  The parent page must\nbe found using the same type of search as used to find the parent during an\ninsertion split.  We lock the target and the parent pages, change the\ntarget's downlink to point to the right sibling, and remove its old\ndownlink.  This causes the target page's key space to effectively belong to\nits right sibling.  (Neither the left nor right sibling pages need to\nchange their \"high key\" if any; so there is no problem with possibly not\nhaving enough space to replace a high key.)  At the same time, we mark the\ntarget page as half-dead, which causes any subsequent searches to ignore it\nand move right (or left, in a backwards scan).  This leaves the tree in a\nsimilar state as during a page split: the page has no downlink pointing to\nit, but it's still linked to its siblings.\n\n(Note: Lanin and Shasha prefer to make the key space move left, but their\nargument for doing so hinges on not having left-links, which we have\nanyway.  So we simplify the algorithm by moving the key space right.  This\nis only possible because we don't match on a separator key when ascending\nthe tree during a page split, unlike Lehman and Yao/Lanin and Shasha -- it\ndoesn't matter if the downlink is re-found in a pivot tuple whose separator\nkey does not match the one encountered when inserter initially descended\nthe tree.)\n\nTo preserve consistency on the parent level, we cannot merge the key space\nof a page into its right sibling unless the right sibling is a child of\nthe same parent --- otherwise, the parent's key space assignment changes\ntoo, meaning we'd have to make bounding-key updates in its parent, and\nperhaps all the way up the tree.  Since we can't possibly do that\natomically, we forbid this case.  That means that the rightmost child of a\nparent node can't be deleted unless it's the only remaining child, in which\ncase we will delete the parent too (see below).\n\nIn the second-stage, the half-dead leaf page is unlinked from its siblings.\nWe first lock the left sibling (if any) of the target, the target page\nitself, and its right sibling (there must be one) in that order.  Then we\nupdate the side-links in the siblings, and mark the target page deleted.\n\nWhen we're about to delete the last remaining child of a parent page, things\nare slightly more complicated.  In the first stage, we leave the immediate\nparent of the leaf page alone, and remove the downlink to the parent page\ninstead, from the grandparent.  If it's the last child of the grandparent\ntoo, we recurse up until we find a parent with more than one child, and\nremove the downlink of that page.  The leaf page is marked as half-dead, and\nthe block number of the page whose downlink was removed is stashed in the\nhalf-dead leaf page.  This leaves us with a chain of internal pages, with\none downlink each, leading to the half-dead leaf page, and no downlink\npointing to the topmost page in the chain.\n\nWhile we recurse up to find the topmost parent in the chain, we keep the\nleaf page locked, but don't need to hold locks on the intermediate pages\nbetween the leaf and the topmost parent -- insertions into upper tree levels\nhappen only as a result of splits of child pages, and that can't happen as\nlong as we're keeping the leaf locked.  The internal pages in the chain\ncannot acquire new children afterwards either, because the leaf page is\nmarked as half-dead and won't be split.\n\nRemoving the downlink to the top of the to-be-deleted subtree/chain\neffectively transfers the key space to the right sibling for all the\nintermediate levels too, in one atomic operation.  A concurrent search might\nstill visit the intermediate pages, but it will move right when it reaches\nthe half-dead page at the leaf level.  In particular, the search will move to\nthe subtree to the right of the half-dead leaf page/to-be-deleted subtree,\nsince the half-dead leaf page's right sibling must be a \"cousin\" page, not a\n\"true\" sibling page (or a second cousin page when the to-be-deleted chain\nstarts at leaf page's grandparent page, and so on).\n\nIn the second stage, the topmost page in the chain is unlinked from its\nsiblings, and the half-dead leaf page is updated to point to the next page\ndown in the chain.  This is repeated until there are no internal pages left\nin the chain.  Finally, the half-dead leaf page itself is unlinked from its\nsiblings.\n\nA deleted page cannot be recycled immediately, since there may be other\nprocesses waiting to reference it (ie, search processes that just left the\nparent, or scans moving right or left from one of the siblings).  These\nprocesses must be able to observe a deleted page for some time after the\ndeletion operation, in order to be able to at least recover from it (they\nrecover by moving right, as with concurrent page splits).  Searchers never\nhave to worry about concurrent page recycling.\n\nSee \"Placing deleted pages in the FSM\" section below for a description of\nwhen and how deleted pages become safe for VACUUM to make recyclable.\n\nPage deletion and backwards scans\n---------------------------------\n\nMoving left in a backward scan is complicated because we must consider\nthe possibility that the left sibling was just split (meaning we must find\nthe rightmost page derived from the left sibling), plus the possibility\nthat the page we were just on has now been deleted and hence isn't in the\nsibling chain at all anymore.  So the move-left algorithm becomes:\n\n0. Remember the page we are on as the \"original page\".\n1. Follow the original page's left-link (we're done if this is zero).\n2. If the current page is live and its right-link matches the \"original\n   page\", we are done.\n3. Otherwise, move right one or more times looking for a live page whose\n   right-link matches the \"original page\".  If found, we are done.  (In\n   principle we could scan all the way to the right end of the index, but\n   in practice it seems better to give up after a small number of tries.\n   It's unlikely the original page's sibling split more than a few times\n   while we were in flight to it; if we do not find a matching link in a\n   few tries, then most likely the original page is deleted.)\n4. Return to the \"original page\".  If it is still live, return to step 1\n   (we guessed wrong about it being deleted, and should restart with its\n   current left-link).  If it is dead, move right until a non-dead page\n   is found (there must be one, since rightmost pages are never deleted),\n   mark that as the new \"original page\", and return to step 1.\n\nThis algorithm is correct because the live page found by step 4 will have\nthe same left keyspace boundary as the page we started from.  Therefore,\nwhen we ultimately exit, it must be on a page whose right keyspace\nboundary matches the left boundary of where we started --- which is what\nwe need to be sure we don't miss or re-scan any items.\n\nPage deletion and tree height\n-----------------------------\n\nBecause we never delete the rightmost page of any level (and in particular\nnever delete the root), it's impossible for the height of the tree to\ndecrease.  After massive deletions we might have a scenario in which the\ntree is \"skinny\", with several single-page levels below the root.\nOperations will still be correct in this case, but we'd waste cycles\ndescending through the single-page levels.  To handle this we use an idea\nfrom Lanin and Shasha: we keep track of the \"fast root\" level, which is\nthe lowest single-page level.  The meta-data page keeps a pointer to this\nlevel as well as the true root.  All ordinary operations initiate their\nsearches at the fast root not the true root.  When we split a page that is\nalone on its level or delete the next-to-last page on a level (both cases\nare easily detected), we have to make sure that the fast root pointer is\nadjusted appropriately.  In the split case, we do this work as part of the\natomic update for the insertion into the parent level; in the delete case\nas part of the atomic update for the delete (either way, the metapage has\nto be the last page locked in the update to avoid deadlock risks).  This\navoids race conditions if two such operations are executing concurrently.\n\nPlacing deleted pages in the FSM\n--------------------------------\n\nRecycling a page is decoupled from page deletion.  A deleted page can only\nbe put in the FSM to be recycled once there is no possible scan or search\nthat has a reference to it; until then, it must stay in place with its\nsibling links undisturbed, as a tombstone that allows concurrent searches\nto detect and then recover from concurrent deletions (which are rather\nlike concurrent page splits to searchers).  This design is an\nimplementation of what Lanin and Shasha call \"the drain technique\".\n\nWe implement the technique by waiting until all active snapshots and\nregistered snapshots as of the page deletion are gone; which is overly\nstrong, but is simple to implement within Postgres.  When marked fully\ndead, a deleted page is labeled with the next-transaction counter value.\nVACUUM can reclaim the page for re-use when the stored XID is guaranteed\nto be \"visible to everyone\".  As collateral damage, we wait for snapshots\ntaken until the next transaction to allocate an XID commits.  We also wait\nfor running XIDs with no snapshots.\n\nPrior to PostgreSQL 14, VACUUM would only place _old_ deleted pages that\nit encounters during its linear scan (pages deleted by a previous VACUUM\noperation) in the FSM.  Newly deleted pages were never placed in the FSM,\nbecause that was assumed to _always_ be unsafe.  That assumption was\nunnecessarily pessimistic in practice, though -- it often doesn't take\nvery long for newly deleted pages to become safe to place in the FSM.\nThere is no truly principled way to predict when deleted pages will become\nsafe to place in the FSM for recycling -- it might become safe almost\nimmediately (long before the current VACUUM completes), or it might not\neven be safe by the time the next VACUUM takes place.  Recycle safety is\npurely a question of maintaining the consistency (or at least the apparent\nconsistency) of a physical data structure.  The state within the backend\nrunning VACUUM is simply not relevant.\n\nPostgreSQL 14 added the ability for VACUUM to consider if it's possible to\nrecycle newly deleted pages at the end of the full index scan where the\npage deletion took place.  It is convenient to check if it's safe at that\npoint.  This does require that VACUUM keep around a little bookkeeping\ninformation about newly deleted pages, but that's very cheap.  Using\nin-memory state for this avoids the need to revisit newly deleted pages a\nsecond time later on -- we can just use safexid values from the local\nbookkeeping state to determine recycle safety in a deferred fashion.\n\nThe need for additional FSM indirection after a page deletion operation\ntakes place is a natural consequence of the highly permissive rules for\nindex scans with Lehman and Yao's design.  In general an index scan\ndoesn't have to hold a lock or even a pin on any page when it descends the\ntree (nothing that you'd usually think of as an interlock is held \"between\nlevels\").  At the same time, index scans cannot be allowed to land on a\ntruly unrelated page due to concurrent recycling (not to be confused with\nconcurrent deletion), because that results in wrong answers to queries.\nSimpler approaches to page deletion that don't need to defer recycling are\npossible, but none seem compatible with Lehman and Yao's design.\n\nPlacing an already-deleted page in the FSM to be recycled when needed\ndoesn't actually change the state of the page.  The page will be changed\nwhenever it is subsequently taken from the FSM for reuse.  The deleted\npage's contents will be overwritten by the split operation (it will become\nthe new right sibling page).\n\nMaking concurrent TID recycling safe\n------------------------------------\n\nAs explained in the earlier section about deleting index tuples during\nVACUUM, we implement a locking protocol that allows individual index scans\nto avoid concurrent TID recycling.  Index scans opt-out (and so drop their\nleaf page pin when visiting the heap) whenever it's safe to do so, though.\nDropping the pin early is useful because it avoids blocking progress by\nVACUUM.  This is particularly important with index scans used by cursors,\nsince idle cursors sometimes stop for relatively long periods of time.  In\nextreme cases, a client application may hold on to an idle cursors for\nhours or even days.  Blocking VACUUM for that long could be disastrous.\n\nIndex scans that don't hold on to a buffer pin are protected by holding an\nMVCC snapshot instead.  This more limited interlock prevents wrong answers\nto queries, but it does not prevent concurrent TID recycling itself (only\nholding onto the leaf page pin while accessing the heap ensures that).\n\nIndex-only scans can never drop their buffer pin, since they are unable to\ntolerate having a referenced TID become recyclable.  Index-only scans\ntypically just visit the visibility map (not the heap proper), and so will\nnot reliably notice that any stale TID reference (for a TID that pointed\nto a dead-to-all heap item at first) was concurrently marked LP_UNUSED in\nthe heap by VACUUM.  This could easily allow VACUUM to set the whole heap\npage to all-visible in the visibility map immediately afterwards.  An MVCC\nsnapshot is only sufficient to avoid problems during plain index scans\nbecause they must access granular visibility information from the heap\nproper.  A plain index scan will even recognize LP_UNUSED items in the\nheap (items that could be recycled but haven't been just yet) as \"not\nvisible\" -- even when the heap page is generally considered all-visible.\n\nLP_DEAD setting of index tuples by the kill_prior_tuple optimization\n(described in full in simple deletion, below) is also more complicated for\nindex scans that drop their leaf page pins.  We must be careful to avoid\nLP_DEAD-marking any new index tuple that looks like a known-dead index\ntuple because it happens to share the same TID, following concurrent TID\nrecycling.  It's just about possible that some other session inserted a\nnew, unrelated index tuple, on the same leaf page, which has the same\noriginal TID.  It would be totally wrong to LP_DEAD-set this new,\nunrelated index tuple.\n\nWe handle this kill_prior_tuple race condition by having affected index\nscans conservatively assume that any change to the leaf page at all\nimplies that it was reached by btbulkdelete in the interim period when no\nbuffer pin was held.  This is implemented by not setting any LP_DEAD bits\non the leaf page at all when the page's LSN has changed.  (That won't work\nwith an unlogged index, so for now we don't ever apply the \"don't hold\nonto pin\" optimization there.)\n\nFastpath For Index Insertion\n----------------------------\n\nWe optimize for a common case of insertion of increasing index key\nvalues by caching the last page to which this backend inserted the last\nvalue, if this page was the rightmost leaf page. For the next insert, we\ncan then quickly check if the cached page is still the rightmost leaf\npage and also the correct place to hold the current value. We can avoid\nthe cost of walking down the tree in such common cases.\n\nThe optimization works on the assumption that there can only be one\nnon-ignorable leaf rightmost page, and so not even a visible-to-everyone\nstyle interlock is required.  We cannot fail to detect that our hint was\ninvalidated, because there can only be one such page in the B-Tree at\nany time. It's possible that the page will be deleted and recycled\nwithout a backend's cached page also being detected as invalidated, but\nonly when we happen to recycle a block that once again gets recycled as the\nrightmost leaf page.\n\nSimple deletion\n---------------\n\nIf a process visits a heap tuple and finds that it's dead and removable\n(ie, dead to all open transactions, not only that process), then we can\nreturn to the index and mark the corresponding index entry \"known dead\",\nallowing subsequent index scans to skip visiting the heap tuple.  The\n\"known dead\" marking works by setting the index item's lp_flags state\nto LP_DEAD.  This is currently only done in plain indexscans, not bitmap\nscans, because only plain scans visit the heap and index \"in sync\" and so\nthere's not a convenient way to do it for bitmap scans.  Note also that\nLP_DEAD bits are often set when checking a unique index for conflicts on\ninsert (this is simpler because it takes place when we hold an exclusive\nlock on the leaf page).\n\nOnce an index tuple has been marked LP_DEAD it can actually be deleted\nfrom the index immediately; since index scans only stop \"between\" pages,\nno scan can lose its place from such a deletion.  We separate the steps\nbecause we allow LP_DEAD to be set with only a share lock (it's like a\nhint bit for a heap tuple), but physically deleting tuples requires an\nexclusive lock.  We also need to generate a snapshotConflictHorizon for\neach deletion operation's WAL record, which requires additional\ncoordinating with the tableam when the deletion actually takes place.\n(snapshotConflictHorizon value may be used to generate a conflict during\nsubsequent REDO of the record by a standby.)\n\nDelaying and batching index tuple deletion like this enables a further\noptimization: opportunistic checking of \"extra\" nearby index tuples\n(tuples that are not LP_DEAD-set) when they happen to be very cheap to\ncheck in passing (because we already know that the tableam will be\nvisiting their table block to generate a snapshotConflictHorizon).  Any\nindex tuples that turn out to be safe to delete will also be deleted.\nSimple deletion will behave as if the extra tuples that actually turn\nout to be delete-safe had their LP_DEAD bits set right from the start.\n\nDeduplication can also prevent a page split, but index tuple deletion is\nour preferred approach.  Note that posting list tuples can only have\ntheir LP_DEAD bit set when every table TID within the posting list is\nknown dead.  This isn't much of a problem in practice because LP_DEAD\nbits are just a starting point for deletion.  What really matters is\nthat _some_ deletion operation that targets related nearby-in-table TIDs\ntakes place at some point before the page finally splits.  That's all\nthat's required for the deletion process to perform granular removal of\ngroups of dead TIDs from posting list tuples (without the situation ever\nbeing allowed to get out of hand).\n\nBottom-Up deletion\n------------------\n\nWe attempt to delete whatever duplicates happen to be present on the page\nwhen the duplicates are suspected to be caused by version churn from\nsuccessive UPDATEs.  This only happens when we receive an executor hint\nindicating that optimizations like heapam's HOT have not worked out for\nthe index -- the incoming tuple must be a logically unchanged duplicate\nwhich is needed for MVCC purposes, suggesting that that might well be the\ndominant source of new index tuples on the leaf page in question.  (Also,\nbottom-up deletion is triggered within unique indexes in cases with\ncontinual INSERT and DELETE related churn, since that is easy to detect\nwithout any external hint.)\n\nSimple deletion will already have failed to prevent a page split when a\nbottom-up deletion pass takes place (often because no LP_DEAD bits were\never set on the page).  The two mechanisms have closely related\nimplementations.  The same WAL records are used for each operation, and\nthe same tableam infrastructure is used to determine what TIDs/tuples are\nactually safe to delete.  The implementations only differ in how they pick\nTIDs to consider for deletion, and whether or not the tableam will give up\nbefore accessing all table blocks (bottom-up deletion lives with the\nuncertainty of its success by keeping the cost of failure low).  Even\nstill, the two mechanisms are clearly distinct at the conceptual level.\n\nBottom-up index deletion is driven entirely by heuristics (whereas simple\ndeletion is guaranteed to delete at least those index tuples that are\nalready LP_DEAD marked -- there must be at least one).  We have no\ncertainty that we'll find even one index tuple to delete.  That's why we\nclosely cooperate with the tableam to keep the costs it pays in balance\nwith the benefits we receive.  The interface that we use for this is\ndescribed in detail in access/tableam.h.\n\nBottom-up index deletion can be thought of as a backstop mechanism against\nunnecessary version-driven page splits.  It is based in part on an idea\nfrom generational garbage collection: the \"generational hypothesis\".  This\nis the empirical observation that \"most objects die young\".  Within\nnbtree, new index tuples often quickly appear in the same place, and then\nquickly become garbage.  There can be intense concentrations of garbage in\nrelatively few leaf pages with certain workloads (or there could be in\nearlier versions of PostgreSQL without bottom-up index deletion, at\nleast).  See doc/src/sgml/btree.sgml for a high-level description of the\ndesign principles behind bottom-up index deletion in nbtree, including\ndetails of how it complements VACUUM.\n\nWe expect to find a reasonably large number of tuples that are safe to\ndelete within each bottom-up pass.  If we don't then we won't need to\nconsider the question of bottom-up deletion for the same leaf page for\nquite a while (usually because the page splits, which resolves the\nsituation for the time being).  We expect to perform regular bottom-up\ndeletion operations against pages that are at constant risk of unnecessary\npage splits caused only by version churn.  When the mechanism works well\nwe'll constantly be \"on the verge\" of having version-churn-driven page\nsplits, but never actually have even one.\n\nOur duplicate heuristics work well despite being fairly simple.\nUnnecessary page splits only occur when there are truly pathological\nlevels of version churn (in theory a small amount of version churn could\nmake a page split occur earlier than strictly necessary, but that's pretty\nharmless).  We don't have to understand the underlying workload; we only\nhave to understand the general nature of the pathology that we target.\nVersion churn is easy to spot when it is truly pathological.  Affected\nleaf pages are fairly homogeneous.\n\nWAL Considerations\n------------------\n\nThe insertion and deletion algorithms in themselves don't guarantee btree\nconsistency after a crash.  To provide robustness, we depend on WAL\nreplay.  A single WAL entry is effectively an atomic action --- we can\nredo it from the log if it fails to complete.\n\nOrdinary item insertions (that don't force a page split) are of course\nsingle WAL entries, since they only affect one page.  The same for\nleaf-item deletions (if the deletion brings the leaf page to zero items,\nit is now a candidate to be deleted, but that is a separate action).\n\nAn insertion that causes a page split is logged as a single WAL entry for\nthe changes occurring on the insertion's level --- including update of the\nright sibling's left-link --- followed by a second WAL entry for the\ninsertion on the parent level (which might itself be a page split, requiring\nan additional insertion above that, etc).\n\nFor a root split, the follow-on WAL entry is a \"new root\" entry rather than\nan \"insertion\" entry, but details are otherwise much the same.\n\nBecause splitting involves multiple atomic actions, it's possible that the\nsystem crashes between splitting a page and inserting the downlink for the\nnew half to the parent.  After recovery, the downlink for the new page will\nbe missing.  The search algorithm works correctly, as the page will be found\nby following the right-link from its left sibling, although if a lot of\ndownlinks in the tree are missing, performance will suffer.  A more serious\nconsequence is that if the page without a downlink gets split again, the\ninsertion algorithm will fail to find the location in the parent level to\ninsert the downlink.\n\nOur approach is to create any missing downlinks on-the-fly, when searching\nthe tree for a new insertion.  It could be done during searches, too, but\nit seems best not to put any extra updates in what would otherwise be a\nread-only operation (updating is not possible in hot standby mode anyway).\nIt would seem natural to add the missing downlinks in VACUUM, but since\ninserting a downlink might require splitting a page, it might fail if you\nrun out of disk space.  That would be bad during VACUUM - the reason for\nrunning VACUUM in the first place might be that you run out of disk space,\nand now VACUUM won't finish because you're out of disk space.  In contrast,\nan insertion can require enlarging the physical file anyway.  There is one\nminor exception: VACUUM finishes interrupted splits of internal pages when\ndeleting their children.  This allows the code for re-finding parent items\nto be used by both page splits and page deletion.\n\nTo identify missing downlinks, when a page is split, the left page is\nflagged to indicate that the split is not yet complete (INCOMPLETE_SPLIT).\nWhen the downlink is inserted to the parent, the flag is cleared atomically\nwith the insertion.  The child page is kept locked until the insertion in\nthe parent is finished and the flag in the child cleared, but can be\nreleased immediately after that, before recursing up the tree if the parent\nalso needs to be split.  This ensures that incompletely split pages should\nnot be seen under normal circumstances; only if insertion to the parent\nhas failed for some reason. (It's also possible for a reader to observe\na page with the incomplete split flag set during recovery; see later\nsection on \"Scans during Recovery\" for details.)\n\nWe flag the left page, even though it's the right page that's missing the\ndownlink, because it's more convenient to know already when following the\nright-link from the left page to the right page that it will need to have\nits downlink inserted to the parent.\n\nWhen splitting a non-root page that is alone on its level, the required\nmetapage update (of the \"fast root\" link) is performed and logged as part\nof the insertion into the parent level.  When splitting the root page, the\nmetapage update is handled as part of the \"new root\" action.\n\nEach step in page deletion is logged as a separate WAL entry: marking the\nleaf as half-dead and removing the downlink is one record, and unlinking a\npage is a second record.  If vacuum is interrupted for some reason, or the\nsystem crashes, the tree is consistent for searches and insertions.  The\nnext VACUUM will find the half-dead leaf page and continue the deletion.\n\nBefore 9.4, we used to keep track of incomplete splits and page deletions\nduring recovery and finish them immediately at end of recovery, instead of\ndoing it lazily at the next insertion or vacuum.  However, that made the\nrecovery much more complicated, and only fixed the problem when crash\nrecovery was performed.  An incomplete split can also occur if an otherwise\nrecoverable error, like out-of-memory or out-of-disk-space, happens while\ninserting the downlink to the parent.\n\nScans during Recovery\n---------------------\n\nnbtree indexes support read queries in Hot Standby mode. Every atomic\naction/WAL record makes isolated changes that leave the tree in a\nconsistent state for readers. Readers lock pages according to the same\nrules that readers follow on the primary. (Readers may have to move\nright to recover from a \"concurrent\" page split or page deletion, just\nlike on the primary.)\n\nHowever, there are a couple of differences in how pages are locked by\nreplay/the startup process as compared to the original write operation\non the primary. The exceptions involve page splits and page deletions.\nThe first phase and second phase of a page split are processed\nindependently during replay, since they are independent atomic actions.\nWe do not attempt to recreate the coupling of parent and child page\nwrite locks that took place on the primary. This is safe because readers\nnever care about the incomplete split flag anyway. Holding on to an\nextra write lock on the primary is only necessary so that a second\nwriter cannot observe the incomplete split flag before the first writer\nfinishes the split. If we let concurrent writers on the primary observe\nan incomplete split flag on the same page, each writer would attempt to\ncomplete the unfinished split, corrupting the parent page.  (Similarly,\nreplay of page deletion records does not hold a write lock on the target\nleaf page throughout; only the primary needs to block out concurrent\nwriters that insert on to the page being deleted.)\n\nWAL replay holds same-level locks in a way that matches the approach\ntaken during original execution, though. This prevent readers from\nobserving same-level inconsistencies. It's probably possible to be more\nlax about how same-level locks are acquired during recovery (most kinds\nof readers could still move right to recover if we didn't couple\nsame-level locks), but we prefer to be conservative here.\n\nDuring recovery all index scans start with ignore_killed_tuples = false\nand we never set kill_prior_tuple. We do this because the oldest xmin\non the standby server can be older than the oldest xmin on the primary\nserver, which means tuples can be marked LP_DEAD even when they are\nstill visible on the standby. We don't WAL log tuple LP_DEAD bits, but\nthey can still appear in the standby because of full page writes. So\nwe must always ignore them in standby, and that means it's not worth\nsetting them either.  (When LP_DEAD-marked tuples are eventually deleted\non the primary, the deletion is WAL-logged.  Queries that run on a\nstandby therefore get much of the benefit of any LP_DEAD setting that\ntakes place on the primary.)\n\nNote that we talk about scans that are started during recovery. We go to\na little trouble to allow a scan to start during recovery and end during\nnormal running after recovery has completed. This is a key capability\nbecause it allows running applications to continue while the standby\nchanges state into a normally running server.\n\nThe interlocking required to avoid returning incorrect results from\nnon-MVCC scans is not required on standby nodes. We still get a full\ncleanup lock when replaying VACUUM records during recovery, but recovery\ndoes not need to lock every leaf page (only those leaf pages that have\nitems to delete) -- that's sufficient to avoid breaking index-only scans\nduring recovery (see section above about making TID recycling safe). That\nleaves concern only for plain index scans. (XXX: Not actually clear why\nthis is totally unnecessary during recovery.)\n\nMVCC snapshot plain index scans are always safe, for the same reasons that\nthey're safe during original execution.  HeapTupleSatisfiesToast() doesn't\nuse MVCC semantics, though that's because it doesn't need to - if the main\nheap row is visible then the toast rows will also be visible. So as long\nas we follow a toast pointer from a visible (live) tuple the corresponding\ntoast rows will also be visible, so we do not need to recheck MVCC on\nthem.\n\nOther Things That Are Handy to Know\n-----------------------------------\n\nPage zero of every btree is a meta-data page.  This page stores the\nlocation of the root page --- both the true root and the current effective\nroot (\"fast\" root).  To avoid fetching the metapage for every single index\nsearch, we cache a copy of the meta-data information in the index's\nrelcache entry (rd_amcache).  This is a bit ticklish since using the cache\nimplies following a root page pointer that could be stale.  However, a\nbackend following a cached pointer can sufficiently verify whether it\nreached the intended page; either by checking the is-root flag when it\nis going to the true root, or by checking that the page has no siblings\nwhen going to the fast root.  At worst, this could result in descending\nsome extra tree levels if we have a cached pointer to a fast root that is\nnow above the real fast root.  Such cases shouldn't arise often enough to\nbe worth optimizing; and in any case we can expect a relcache flush will\ndiscard the cached metapage before long, since a VACUUM that's moved the\nfast root pointer can be expected to issue a statistics update for the\nindex.\n\nThe algorithm assumes we can fit at least three items per page\n(a \"high key\" and two real data items).  Therefore it's unsafe\nto accept items larger than 1/3rd page size.  Larger items would\nwork sometimes, but could cause failures later on depending on\nwhat else gets put on their page.\n\n\"ScanKey\" data structures are used in two fundamentally different ways\nin this code, which we describe as \"search\" scankeys and \"insertion\"\nscankeys.  A search scankey is the kind passed to btbeginscan() or\nbtrescan() from outside the btree code.  The sk_func pointers in a search\nscankey point to comparison functions that return boolean, such as int4lt.\nThere might be more than one scankey entry for a given index column, or\nnone at all.  (We require the keys to appear in index column order, but\nthe order of multiple keys for a given column is unspecified.)  An\ninsertion scankey (\"BTScanInsert\" data structure) uses a similar\narray-of-ScanKey data structure, but the sk_func pointers point to btree\ncomparison support functions (ie, 3-way comparators that return int4 values\ninterpreted as <0, =0, >0).  In an insertion scankey there is at most one\nentry per index column.  There is also other data about the rules used to\nlocate where to begin the scan, such as whether or not the scan is a\n\"nextkey\" scan.  Insertion scankeys are built within the btree code (eg, by\n_bt_mkscankey()) and are used to locate the starting point of a scan, as\nwell as for locating the place to insert a new index tuple.  (Note: in the\ncase of an insertion scankey built from a search scankey or built from a\ntruncated pivot tuple, there might be fewer keys than index columns,\nindicating that we have no constraints for the remaining index columns.)\nAfter we have located the starting point of a scan, the original search\nscankey is consulted as each index entry is sequentially scanned to decide\nwhether to return the entry and whether the scan can stop (see\n_bt_checkkeys()).\n\nNotes about suffix truncation\n-----------------------------\n\nWe truncate away suffix key attributes that are not needed for a page high\nkey during a leaf page split.  The remaining attributes must distinguish\nthe last index tuple on the post-split left page as belonging on the left\npage, and the first index tuple on the post-split right page as belonging\non the right page.  Tuples logically retain truncated key attributes,\nthough they implicitly have \"negative infinity\" as their value, and have no\nstorage overhead.  Since the high key is subsequently reused as the\ndownlink in the parent page for the new right page, suffix truncation makes\npivot tuples short.  INCLUDE indexes are guaranteed to have non-key\nattributes truncated at the time of a leaf page split, but may also have\nsome key attributes truncated away, based on the usual criteria for key\nattributes.  They are not a special case, since non-key attributes are\nmerely payload to B-Tree searches.\n\nThe goal of suffix truncation of key attributes is to improve index\nfan-out.  The technique was first described by Bayer and Unterauer (R.Bayer\nand K.Unterauer, Prefix B-Trees, ACM Transactions on Database Systems, Vol\n2, No. 1, March 1977, pp 11-26).  The Postgres implementation is loosely\nbased on their paper.  Note that Postgres only implements what the paper\nrefers to as simple prefix B-Trees.  Note also that the paper assumes that\nthe tree has keys that consist of single strings that maintain the \"prefix\nproperty\", much like strings that are stored in a suffix tree (comparisons\nof earlier bytes must always be more significant than comparisons of later\nbytes, and, in general, the strings must compare in a way that doesn't\nbreak transitive consistency as they're split into pieces).  Suffix\ntruncation in Postgres currently only works at the whole-attribute\ngranularity, but it would be straightforward to invent opclass\ninfrastructure that manufactures a smaller attribute value in the case of\nvariable-length types, such as text.  An opclass support function could\nmanufacture the shortest possible key value that still correctly separates\neach half of a leaf page split.\n\nThere is sophisticated criteria for choosing a leaf page split point.  The\ngeneral idea is to make suffix truncation effective without unduly\ninfluencing the balance of space for each half of the page split.  The\nchoice of leaf split point can be thought of as a choice among points\n*between* items on the page to be split, at least if you pretend that the\nincoming tuple was placed on the page already (you have to pretend because\nthere won't actually be enough space for it on the page).  Choosing the\nsplit point between two index tuples where the first non-equal attribute\nappears as early as possible results in truncating away as many suffix\nattributes as possible.  Evenly balancing space among each half of the\nsplit is usually the first concern, but even small adjustments in the\nprecise split point can allow truncation to be far more effective.\n\nSuffix truncation is primarily valuable because it makes pivot tuples\nsmaller, which delays splits of internal pages, but that isn't the only\nreason why it's effective.  Even truncation that doesn't make pivot tuples\nsmaller due to alignment still prevents pivot tuples from being more\nrestrictive than truly necessary in how they describe which values belong\non which pages.\n\nWhile it's not possible to correctly perform suffix truncation during\ninternal page splits, it's still useful to be discriminating when splitting\nan internal page.  The split point that implies a downlink be inserted in\nthe parent that's the smallest one available within an acceptable range of\nthe fillfactor-wise optimal split point is chosen.  This idea also comes\nfrom the Prefix B-Tree paper.  This process has much in common with what\nhappens at the leaf level to make suffix truncation effective.  The overall\neffect is that suffix truncation tends to produce smaller, more\ndiscriminating pivot tuples, especially early in the lifetime of the index,\nwhile biasing internal page splits makes the earlier, smaller pivot tuples\nend up in the root page, delaying root page splits.\n\nLogical duplicates are given special consideration.  The logic for\nselecting a split point goes to great lengths to avoid having duplicates\nspan more than one page, and almost always manages to pick a split point\nbetween two user-key-distinct tuples, accepting a completely lopsided split\nif it must.  When a page that's already full of duplicates must be split,\nthe fallback strategy assumes that duplicates are mostly inserted in\nascending heap TID order.  The page is split in a way that leaves the left\nhalf of the page mostly full, and the right half of the page mostly empty.\nThe overall effect is that leaf page splits gracefully adapt to inserts of\nlarge groups of duplicates, maximizing space utilization.  Note also that\n\"trapping\" large groups of duplicates on the same leaf page like this makes\ndeduplication more efficient.  Deduplication can be performed infrequently,\nwithout merging together existing posting list tuples too often.\n\nNotes about deduplication\n-------------------------\n\nWe deduplicate non-pivot tuples in non-unique indexes to reduce storage\noverhead, and to avoid (or at least delay) page splits.  Note that the\ngoals for deduplication in unique indexes are rather different; see later\nsection for details.  Deduplication alters the physical representation of\ntuples without changing the logical contents of the index, and without\nadding overhead to read queries.  Non-pivot tuples are merged together\ninto a single physical tuple with a posting list (a simple array of heap\nTIDs with the standard item pointer format).  Deduplication is always\napplied lazily, at the point where it would otherwise be necessary to\nperform a page split.  It occurs only when LP_DEAD items have been\nremoved, as our last line of defense against splitting a leaf page\n(bottom-up index deletion may be attempted first, as our second last line\nof defense).  We can set the LP_DEAD bit with posting list tuples, though\nonly when all TIDs are known dead.\n\nOur lazy approach to deduplication allows the page space accounting used\nduring page splits to have absolutely minimal special case logic for\nposting lists.  Posting lists can be thought of as extra payload that\nsuffix truncation will reliably truncate away as needed during page\nsplits, just like non-key columns from an INCLUDE index tuple.\nIncoming/new tuples can generally be treated as non-overlapping plain\nitems (though see section on posting list splits for information about how\noverlapping new/incoming items are really handled).\n\nThe representation of posting lists is almost identical to the posting\nlists used by GIN, so it would be straightforward to apply GIN's varbyte\nencoding compression scheme to individual posting lists.  Posting list\ncompression would break the assumptions made by posting list splits about\npage space accounting (see later section), so it's not clear how\ncompression could be integrated with nbtree.  Besides, posting list\ncompression does not offer a compelling trade-off for nbtree, since in\ngeneral nbtree is optimized for consistent performance with many\nconcurrent readers and writers.  Compression would also make the deletion\nof a subset of TIDs from a posting list slow and complicated, which would\nbe a big problem for workloads that depend heavily on bottom-up index\ndeletion.\n\nA major goal of our lazy approach to deduplication is to limit the\nperformance impact of deduplication with random updates.  Even concurrent\nappend-only inserts of the same key value will tend to have inserts of\nindividual index tuples in an order that doesn't quite match heap TID\norder.  Delaying deduplication minimizes page level fragmentation.\n\nDeduplication in unique indexes\n-------------------------------\n\nVery often, the number of distinct values that can ever be placed on\nalmost any given leaf page in a unique index is fixed and permanent.  For\nexample, a primary key on an identity column will usually only have leaf\npage splits caused by the insertion of new logical rows within the\nrightmost leaf page.  If there is a split of a non-rightmost leaf page,\nthen the split must have been triggered by inserts associated with UPDATEs\nof existing logical rows.  Splitting a leaf page purely to store multiple\nversions is a false economy.  In effect, we're permanently degrading the\nindex structure just to absorb a temporary burst of duplicates.\n\nDeduplication in unique indexes helps to prevent these pathological page\nsplits.  Storing duplicates in a space efficient manner is not the goal,\nsince in the long run there won't be any duplicates anyway.  Rather, we're\nbuying time for standard garbage collection mechanisms to run before a\npage split is needed.\n\nUnique index leaf pages only get a deduplication pass when an insertion\n(that might have to split the page) observed an existing duplicate on the\npage in passing.  This is based on the assumption that deduplication will\nonly work out when _all_ new insertions are duplicates from UPDATEs.  This\nmay mean that we miss an opportunity to delay a page split, but that's\nokay because our ultimate goal is to delay leaf page splits _indefinitely_\n(i.e. to prevent them altogether).  There is little point in trying to\ndelay a split that is probably inevitable anyway.  This allows us to avoid\nthe overhead of attempting to deduplicate with unique indexes that always\nhave few or no duplicates.\n\nNote: Avoiding \"unnecessary\" page splits driven by version churn is also\nthe goal of bottom-up index deletion, which was added to PostgreSQL 14.\nBottom-up index deletion is now the preferred way to deal with this\nproblem (with all kinds of indexes, though especially with unique\nindexes).  Still, deduplication can sometimes augment bottom-up index\ndeletion.  When deletion cannot free tuples (due to an old snapshot\nholding up cleanup), falling back on deduplication provides additional\ncapacity.  Delaying the page split by deduplicating can allow a future\nbottom-up deletion pass of the same page to succeed.\n\nPosting list splits\n-------------------\n\nWhen the incoming tuple happens to overlap with an existing posting list,\na posting list split is performed.  Like a page split, a posting list\nsplit resolves a situation where a new/incoming item \"won't fit\", while\ninserting the incoming item in passing (i.e. as part of the same atomic\naction).  It's possible (though not particularly likely) that an insert of\na new item on to an almost-full page will overlap with a posting list,\nresulting in both a posting list split and a page split.  Even then, the\natomic action that splits the posting list also inserts the new item\n(since page splits always insert the new item in passing).  Including the\nposting list split in the same atomic action as the insert avoids problems\ncaused by concurrent inserts into the same posting list --  the exact\ndetails of how we change the posting list depend upon the new item, and\nvice-versa.  A single atomic action also minimizes the volume of extra\nWAL required for a posting list split, since we don't have to explicitly\nWAL-log the original posting list tuple.\n\nDespite piggy-backing on the same atomic action that inserts a new tuple,\nposting list splits can be thought of as a separate, extra action to the\ninsert itself (or to the page split itself).  Posting list splits\nconceptually \"rewrite\" an insert that overlaps with an existing posting\nlist into an insert that adds its final new item just to the right of the\nposting list instead.  The size of the posting list won't change, and so\npage space accounting code does not need to care about posting list splits\nat all.  This is an important upside of our design; the page split point\nchoice logic is very subtle even without it needing to deal with posting\nlist splits.\n\nOnly a few isolated extra steps are required to preserve the illusion that\nthe new item never overlapped with an existing posting list in the first\nplace: the heap TID of the incoming tuple has its TID replaced with the\nrightmost/max heap TID from the existing/originally overlapping posting\nlist.  Similarly, the original incoming item's TID is relocated to the\nappropriate offset in the posting list (we usually shift TIDs out of the\nway to make a hole for it).  Finally, the posting-split-with-page-split\ncase must generate a new high key based on an imaginary version of the\noriginal page that has both the final new item and the after-list-split\nposting tuple (page splits usually just operate against an imaginary\nversion that contains the new item/item that won't fit).\n\nThis approach avoids inventing an \"eager\" atomic posting split operation\nthat splits the posting list without simultaneously finishing the insert\nof the incoming item.  This alternative design might seem cleaner, but it\ncreates subtle problems for page space accounting.  In general, there\nmight not be enough free space on the page to split a posting list such\nthat the incoming/new item no longer overlaps with either posting list\nhalf --- the operation could fail before the actual retail insert of the\nnew item even begins.  We'd end up having to handle posting list splits\nthat need a page split anyway.  Besides, supporting variable \"split points\"\nwhile splitting posting lists won't actually improve overall space\nutilization.\n\nNotes About Data Representation\n-------------------------------\n\nThe right-sibling link required by L&Y is kept in the page \"opaque\ndata\" area, as is the left-sibling link, the page level, and some flags.\nThe page level counts upwards from zero at the leaf level, to the tree\ndepth minus 1 at the root.  (Counting up from the leaves ensures that we\ndon't need to renumber any existing pages when splitting the root.)\n\nThe Postgres disk block data format (an array of items) doesn't fit\nLehman and Yao's alternating-keys-and-pointers notion of a disk page,\nso we have to play some games.  (The alternating-keys-and-pointers\nnotion is important for internal page splits, which conceptually split\nat the middle of an existing pivot tuple -- the tuple's \"separator\" key\ngoes on the left side of the split as the left side's new high key,\nwhile the tuple's pointer/downlink goes on the right side as the\nfirst/minus infinity downlink.)\n\nOn a page that is not rightmost in its tree level, the \"high key\" is\nkept in the page's first item, and real data items start at item 2.\nThe link portion of the \"high key\" item goes unused.  A page that is\nrightmost has no \"high key\" (it's implicitly positive infinity), so\ndata items start with the first item.  Putting the high key at the\nleft, rather than the right, may seem odd, but it avoids moving the\nhigh key as we add data items.\n\nOn a leaf page, the data items are simply links to (TIDs of) tuples\nin the relation being indexed, with the associated key values.\n\nOn a non-leaf page, the data items are down-links to child pages with\nbounding keys.  The key in each data item is a strict lower bound for\nkeys on that child page, so logically the key is to the left of that\ndownlink.  The high key (if present) is the upper bound for the last\ndownlink.  The first data item on each such page has no lower bound\n--- or lower bound of minus infinity, if you prefer.  The comparison\nroutines must treat it accordingly.  The actual key stored in the\nitem is irrelevant, and need not be stored at all.  This arrangement\ncorresponds to the fact that an L&Y non-leaf page has one more pointer\nthan key.  Suffix truncation's negative infinity attributes behave in\nthe same way.","count":55},{"name":"subsystem-desc","value":"src/backend/access/spgist/README\n\nSP-GiST is an abbreviation of space-partitioned GiST.  It provides a\ngeneralized infrastructure for implementing space-partitioned data\nstructures, such as quadtrees, k-d trees, and radix trees (tries).  When\nimplemented in main memory, these structures are usually designed as a set of\ndynamically-allocated nodes linked by pointers.  This is not suitable for\ndirect storing on disk, since the chains of pointers can be rather long and\nrequire too many disk accesses. In contrast, disk based data structures\nshould have a high fanout to minimize I/O.  The challenge is to map tree\nnodes to disk pages in such a way that the search algorithm accesses only a\nfew disk pages, even if it traverses many nodes.\n\n\nCOMMON STRUCTURE DESCRIPTION\n\nLogically, an SP-GiST tree is a set of tuples, each of which can be either\nan inner or leaf tuple.  Each inner tuple contains \"nodes\", which are\n(label,pointer) pairs, where the pointer (ItemPointerData) is a pointer to\nanother inner tuple or to the head of a list of leaf tuples.  Inner tuples\ncan have different numbers of nodes (children).  Branches can be of different\ndepth (actually, there is no control or code to support balancing), which\nmeans that the tree is non-balanced.  However, leaf and inner tuples cannot\nbe intermixed at the same level: a downlink from a node of an inner tuple\nleads either to one inner tuple, or to a list of leaf tuples.\n\nThe SP-GiST core requires that inner and leaf tuples fit on a single index\npage, and even more stringently that the list of leaf tuples reached from a\nsingle inner-tuple node all be stored on the same index page.  (Restricting\nsuch lists to not cross pages reduces seeks, and allows the list links to be\nstored as simple 2-byte OffsetNumbers.)  SP-GiST index opclasses should\ntherefore ensure that not too many nodes can be needed in one inner tuple,\nand that inner-tuple prefixes and leaf-node datum values not be too large.\n\nInner and leaf tuples are stored separately: the former are stored only on\n\"inner\" pages, the latter only on \"leaf\" pages.  Also, there are special\nrestrictions on the root page.  Early in an index's life, when there is only\none page's worth of data, the root page contains an unorganized set of leaf\ntuples.  After the first page split has occurred, the root is required to\ncontain exactly one inner tuple.\n\nWhen the search traversal algorithm reaches an inner tuple, it chooses a set\nof nodes to continue tree traverse in depth.  If it reaches a leaf page it\nscans a list of leaf tuples to find the ones that match the query. SP-GiST\nalso supports ordered (nearest-neighbor) searches - that is during scan pending\nnodes are put into priority queue, so traversal is performed by the\nclosest-first model.\n\n\nThe insertion algorithm descends the tree similarly, except it must choose\njust one node to descend to from each inner tuple.  Insertion might also have\nto modify the inner tuple before it can descend: it could add a new node, or\nit could \"split\" the tuple to obtain a less-specific prefix that can match\nthe value to be inserted.  If it's necessary to append a new leaf tuple to a\nlist and there is no free space on page, then SP-GiST creates a new inner\ntuple and distributes leaf tuples into a set of lists on, perhaps, several\npages.\n\nAn inner tuple consists of:\n\n  optional prefix value - all successors must be consistent with it.\n    Example:\n        radix tree   - prefix value is a common prefix string\n        quad tree    - centroid\n        k-d tree     - one coordinate\n\n  list of nodes, where node is a (label, pointer) pair.\n    Example of a label: a single character for radix tree\n\nA leaf tuple consists of:\n\n  a leaf value\n    Example:\n        radix tree - the rest of string (postfix)\n        quad and k-d tree - the point itself\n\n  ItemPointer to the corresponding heap tuple\n  nextOffset number of next leaf tuple in a chain on a leaf page\n\n  optional nulls bitmask\n  optional INCLUDE-column values\n\nFor compatibility with pre-v14 indexes, a leaf tuple has a nulls bitmask\nonly if there are null values (among the leaf value and the INCLUDE values)\n*and* there is at least one INCLUDE column.  The null-ness of the leaf\nvalue can be inferred from whether the tuple is on a \"nulls page\" (see below)\nso it is not necessary to represent it explicitly.  But we include it anyway\nin a bitmask used with INCLUDE values, so that standard tuple deconstruction\ncode can be used.\n\n\nNULLS HANDLING\n\nWe assume that SPGiST-indexable operators are strict (can never succeed for\nnull inputs).  It is still desirable to index nulls, so that whole-table\nindexscans are possible and so that \"x IS NULL\" can be implemented by an\nSPGiST indexscan.  However, we prefer that SPGiST index opclasses not have\nto cope with nulls.  Therefore, the main tree of an SPGiST index does not\ninclude any null entries.  We store null entries in a separate SPGiST tree\noccupying a disjoint set of pages (in particular, its own root page).\nInsertions and searches in the nulls tree do not use any of the\nopclass-supplied functions, but just use hardwired logic comparable to\nAllTheSame cases in the normal tree.\n\n\nINSERTION ALGORITHM\n\nInsertion algorithm is designed to keep the tree in a consistent state at\nany moment.  Here is a simplified insertion algorithm specification\n(numbers refer to notes below):\n\n  Start with the first tuple on the root page (1)\n\n  loop:\n    if (page is leaf) then\n        if (enough space)\n            insert on page and exit (5)\n        else (7)\n            call PickSplitFn() (2)\n        end if\n    else\n        switch (chooseFn())\n            case MatchNode  - descend through selected node\n            case AddNode    - add node and then retry chooseFn (3, 6)\n            case SplitTuple - split inner tuple to prefix and postfix, then\n                              retry chooseFn with the prefix tuple (4, 6)\n    end if\n\nNotes:\n\n(1) Initially, we just dump leaf tuples into the root page until it is full;\nthen we split it.  Once the root is not a leaf page, it can have only one\ninner tuple, so as to keep the amount of free space on the root as large as\npossible.  Both of these rules are meant to postpone doing PickSplit on the\nroot for as long as possible, so that the topmost partitioning of the search\nspace is as good as we can easily make it.\n\n(2) Current implementation allows to do picksplit and insert a new leaf tuple\nin one operation, if the new list of leaf tuples fits on one page. It's\nalways possible for trees with small nodes like quad tree or k-d tree, but\nradix trees may require another picksplit.\n\n(3) Addition of node must keep size of inner tuple small enough to fit on a\npage.  After addition, inner tuple could become too large to be stored on\ncurrent page because of other tuples on page. In this case it will be moved\nto another inner page (see notes about page management). When moving tuple to\nanother page, we can't change the numbers of other tuples on the page, else\nwe'd make downlink pointers to them invalid. To prevent that, SP-GiST leaves\na \"placeholder\" tuple, which can be reused later whenever another tuple is\nadded to the page. See also Concurrency and Vacuum sections below. Right now\nonly radix trees could add a node to the tuple; quad trees and k-d trees\nmake all possible nodes at once in PickSplitFn() call.\n\n(4) Prefix value could only partially match a new value, so the SplitTuple\naction allows breaking the current tree branch into upper and lower sections.\nAnother way to say it is that we can split the current inner tuple into\n\"prefix\" and \"postfix\" parts, where the prefix part is able to match the\nincoming new value. Consider example of insertion into a radix tree. We use\nthe following notation, where tuple's id is just for discussion (no such id\nis actually stored):\n\ninner tuple: {tuple id}(prefix string)[ comma separated list of node labels ]\nleaf tuple: {tuple id}<value>\n\nSuppose we need to insert string 'www.gogo.com' into inner tuple\n\n    {1}(www.google.com/)[a, i]\n\nThe string does not match the prefix so we cannot descend.  We must\nsplit the inner tuple into two tuples:\n\n    {2}(www.go)[o]  - prefix tuple\n                |\n                {3}(gle.com/)[a,i] - postfix tuple\n\nOn the next iteration of loop we find that 'www.gogo.com' matches the\nprefix, but not any node label, so we add a node [g] to tuple {2}:\n\n                   NIL (no child exists yet)\n                   |\n    {2}(www.go)[o, g]\n                |\n                {3}(gle.com/)[a,i]\n\nNow we can descend through the [g] node, which will cause us to update\nthe target string to just 'o.com'.  Finally, we'll insert a leaf tuple\nbearing that string:\n\n                  {4}<o.com>\n                   |\n    {2}(www.go)[o, g]\n                |\n                {3}(gle.com/)[a,i]\n\nAs we can see, the original tuple's node array moves to postfix tuple without\nany changes.  Note also that SP-GiST core assumes that prefix tuple is not\nlarger than old inner tuple.  That allows us to store prefix tuple directly\nin place of old inner tuple.  SP-GiST core will try to store postfix tuple on\nthe same page if possible, but will use another page if there is not enough\nfree space (see notes 5 and 6).  Currently, quad and k-d trees don't use this\nfeature, because they have no concept of a prefix being \"inconsistent\" with\nany new value.  They grow their depth only by PickSplitFn() call.\n\n(5) If pointer from node of parent is a NIL pointer, algorithm chooses a leaf\npage to store on.  At first, it tries to use the last-used leaf page with the\nlargest free space (which we track in each backend) to better utilize disk\nspace.  If that's not large enough, then the algorithm allocates a new page.\n\n(6) Management of inner pages is very similar to management of leaf pages,\ndescribed in (5).\n\n(7) Actually, current implementation can move the whole list of leaf tuples\nand a new tuple to another page, if the list is short enough. This improves\nspace utilization, but doesn't change the basis of the algorithm.\n\n\nCONCURRENCY\n\nWhile descending the tree, the insertion algorithm holds exclusive lock on\ntwo tree levels at a time, ie both parent and child pages (but parent and\nchild pages can be the same, see notes above).  There is a possibility of\ndeadlock between two insertions if there are cross-referenced pages in\ndifferent branches.  That is, if inner tuple on page M has a child on page N\nwhile an inner tuple from another branch is on page N and has a child on\npage M, then two insertions descending the two branches could deadlock,\nsince they will each hold their parent page's lock while trying to get the\nchild page's lock.\n\nCurrently, we deal with this by conditionally locking buffers as we descend\nthe tree.  If we fail to get lock on a buffer, we release both buffers and\nrestart the insertion process.  This is potentially inefficient, but the\nlocking costs of a more deterministic approach seem very high.\n\nTo reduce the number of cases where that happens, we introduce a concept of\n\"triple parity\" of pages: if inner tuple is on page with BlockNumber N, then\nits child tuples should be placed on the same page, or else on a page with\nBlockNumber M where (N+1) mod 3 == M mod 3.  This rule ensures that tuples\non page M will have no children on page N, since (M+1) mod 3 != N mod 3.\nThat makes it unlikely that two insertion processes will conflict against\neach other while descending the tree.  It's not perfect though: in the first\nplace, we could still get a deadlock among three or more insertion processes,\nand in the second place, it's impractical to preserve this invariant in every\ncase when we expand or split an inner tuple.  So we still have to allow for\ndeadlocks.\n\nInsertion may also need to take locks on an additional inner and/or leaf page\nto add tuples of the right type(s), when there's not enough room on the pages\nit descended through.  However, we don't care exactly which such page we add\nto, so deadlocks can be avoided by conditionally locking the additional\nbuffers: if we fail to get lock on an additional page, just try another one.\n\nSearch traversal algorithm is rather traditional.  At each non-leaf level, it\nshare-locks the page, identifies which node(s) in the current inner tuple\nneed to be visited, and puts those addresses on a stack of pages to examine\nlater.  It then releases lock on the current buffer before visiting the next\nstack item.  So only one page is locked at a time, and no deadlock is\npossible.  But instead, we have to worry about race conditions: by the time\nwe arrive at a pointed-to page, a concurrent insertion could have replaced\nthe target inner tuple (or leaf tuple chain) with data placed elsewhere.\nTo handle that, whenever the insertion algorithm changes a nonempty downlink\nin an inner tuple, it places a \"redirect tuple\" in place of the lower-level\ninner tuple or leaf-tuple chain head that the link formerly led to.  Scans\n(though not insertions) must be prepared to honor such redirects.  Only a\nscan that had already visited the parent level could possibly reach such a\nredirect tuple, so we can remove redirects once all active transactions have\nbeen flushed out of the system.\n\n\nDEAD TUPLES\n\nTuples on leaf pages can be in one of four states:\n\nSPGIST_LIVE: normal, live pointer to a heap tuple.\n\nSPGIST_REDIRECT: placeholder that contains a link to another place in the\nindex.  When a chain of leaf tuples has to be moved to another page, a\nredirect tuple is inserted in place of the chain's head tuple.  The parent\ninner tuple's downlink is updated when this happens, but concurrent scans\nmight be \"in flight\" from the parent page to the child page (since they\nrelease lock on the parent page before attempting to lock the child).\nThe redirect pointer serves to tell such a scan where to go.  A redirect\npointer is only needed for as long as such concurrent scans could be in\nprogress.  Eventually, it's converted into a PLACEHOLDER dead tuple by\nVACUUM, and is then a candidate for replacement.  Searches that find such\na tuple (which should never be part of a chain) should immediately proceed\nto the other place, forgetting about the redirect tuple.  Insertions that\nreach such a tuple should raise error, since a valid downlink should never\npoint to such a tuple.\n\nSPGIST_DEAD: tuple is dead, but it cannot be removed or moved to a\ndifferent offset on the page because there is a link leading to it from\nsome inner tuple elsewhere in the index.  (Such a tuple is never part of a\nchain, since we don't need one unless there is nothing live left in its\nchain.)  Searches should ignore such entries.  If an insertion action\narrives at such a tuple, it should either replace it in-place (if there's\nroom on the page to hold the desired new leaf tuple) or replace it with a\nredirection pointer to wherever it puts the new leaf tuple.\n\nSPGIST_PLACEHOLDER: tuple is dead, and there are known to be no links to\nit from elsewhere.  When a live tuple is deleted or moved away, and not\nreplaced by a redirect pointer, it is replaced by a placeholder to keep\nthe offsets of later tuples on the same page from changing.  Placeholders\ncan be freely replaced when adding a new tuple to the page, and also\nVACUUM will delete any that are at the end of the range of valid tuple\noffsets.  Both searches and insertions should complain if a link from\nelsewhere leads them to a placeholder tuple.\n\nWhen the root page is also a leaf, all its tuple should be in LIVE state;\nthere's no need for the others since there are no links and no need to\npreserve offset numbers.\n\nTuples on inner pages can be in LIVE, REDIRECT, or PLACEHOLDER states.\nThe REDIRECT state has the same function as on leaf pages, to send\nconcurrent searches to the place where they need to go after an inner\ntuple is moved to another page.  Expired REDIRECT pointers are converted\nto PLACEHOLDER status by VACUUM, and are then candidates for replacement.\nDEAD state is not currently possible, since VACUUM does not attempt to\nremove unused inner tuples.\n\n\nVACUUM\n\nVACUUM (or more precisely, spgbulkdelete) performs a single sequential scan\nover the entire index.  On both leaf and inner pages, we can convert old\nREDIRECT tuples into PLACEHOLDER status, and then remove any PLACEHOLDERs\nthat are at the end of the page (since they aren't needed to preserve the\noffsets of any live tuples).  On leaf pages, we scan for tuples that need\nto be deleted because their heap TIDs match a vacuum target TID.\n\nIf we find a deletable tuple that is not at the head of its chain, we\ncan simply replace it with a PLACEHOLDER, updating the chain links to\nremove it from the chain.  If it is at the head of its chain, but there's\nat least one live tuple remaining in the chain, we move that live tuple\nto the head tuple's offset, replacing it with a PLACEHOLDER to preserve\nthe offsets of other tuples.  This keeps the parent inner tuple's downlink\nvalid.  If we find ourselves deleting all live tuples in a chain, we\nreplace the head tuple with a DEAD tuple and the rest with PLACEHOLDERS.\nThe parent inner tuple's downlink thus points to the DEAD tuple, and the\nrules explained in the previous section keep everything working.\n\nVACUUM doesn't know a-priori which tuples are heads of their chains, but\nit can easily figure that out by constructing a predecessor array that's\nthe reverse map of the nextOffset links (ie, when we see tuple x links to\ntuple y, we set predecessor[y] = x).  Then head tuples are the ones with\nno predecessor.\n\nBecause insertions can occur while VACUUM runs, a pure sequential scan\ncould miss deleting some target leaf tuples, because they could get moved\nfrom a not-yet-visited leaf page to an already-visited leaf page as a\nconsequence of a PickSplit or MoveLeafs operation.  Failing to delete any\ntarget TID is not acceptable, so we have to extend the algorithm to cope\nwith such cases.  We recognize that such a move might have occurred when\nwe see a leaf-page REDIRECT tuple whose XID indicates it might have been\ncreated after the VACUUM scan started.  We add the redirection target TID\nto a \"pending list\" of places we need to recheck.  Between pages of the\nmain sequential scan, we empty the pending list by visiting each listed\nTID.  If it points to an inner tuple (from a PickSplit), add each downlink\nTID to the pending list.  If it points to a leaf page, vacuum that page.\n(We could just vacuum the single pointed-to chain, but vacuuming the\nwhole page simplifies the code and reduces the odds of VACUUM having to\nmodify the same page multiple times.)  To ensure that pending-list\nprocessing can never get into an endless loop, even in the face of\nconcurrent index changes, we don't remove list entries immediately but\nonly after we've completed all pending-list processing; instead we just\nmark items as done after processing them.  Adding a TID that's already in\nthe list is a no-op, whether or not that item is marked done yet.\n\nspgbulkdelete also updates the index's free space map.\n\nCurrently, spgvacuumcleanup has nothing to do if spgbulkdelete was\nperformed; otherwise, it does an spgbulkdelete scan with an empty target\nlist, so as to clean up redirections and placeholders, update the free\nspace map, and gather statistics.\n\n\nLAST USED PAGE MANAGEMENT\n\nThe list of last used pages contains four pages - a leaf page and three\ninner pages, one from each \"triple parity\" group.  (Actually, there's one\nsuch list for the main tree and a separate one for the nulls tree.)  This\nlist is stored between calls on the index meta page, but updates are never\nWAL-logged to decrease WAL traffic.  Incorrect data on meta page isn't\ncritical, because we could allocate a new page at any moment.\n\n\nAUTHORS\n\n    Teodor Sigaev <teodor@sigaev.ru>\n    Oleg Bartunov <oleg@sai.msu.su>","count":55},{"name":"subsystem-desc","value":"src/tools/pg_bsd_indent/README\n\nThis is a lightly modified version of the \"indent\" program maintained\nby the FreeBSD project.  The modifications are mostly to make it portable\nto non-BSD-ish platforms, though we do have one formatting switch we\ncouldn't convince upstream to take.\n\nTo build it, configure the surrounding Postgres source tree,\nthen run \"make\" in this directory.\nOptionally, run \"make test\" for some simple tests.\n\nYou'll need to install pg_bsd_indent somewhere in your PATH before\nusing it.  Most likely, if you're a developer, you don't want to\nput it in the same place as where the surrounding Postgres build\ngets installed.  Therefore, do this part with something like\n\n\tmake install prefix=/usr/local\n\nIf you are using Meson to build, the standard build targets will\nbuild pg_bsd_indent and also test it, but there is not currently\nprovision for installing it anywhere.  Manually copy the built\nexecutable from build/src/tools/pg_bsd_indent/pg_bsd_indent to\nwherever you want to put it.\n\n\nIf you happen to be hacking upon the indent source code, the closest\napproximation to the existing indentation style seems to be\n\n\t./pg_bsd_indent -i4 -l79 -di12 -nfc1 -nlp -sac somefile.c\n\nalthough this has by no means been rigorously adhered to.\n(What was that saw about the shoemaker's children?)\nWe're not planning to re-indent to Postgres style, because that\nwould make it difficult to compare to the FreeBSD sources.\n\n----------\n\nThe FreeBSD originals of the files in this directory bear the\n\"4-clause\" version of the BSD license.  We have removed the\n\"advertising\" clauses, as per UC Berkeley's directive here:\nftp://ftp.cs.berkeley.edu/pub/4bsd/README.Impt.License.Change\nwhich reads:\n\nJuly 22, 1999\n\nTo All Licensees, Distributors of Any Version of BSD:\n\nAs you know, certain of the Berkeley Software Distribution (\"BSD\") source\ncode files require that further distributions of products containing all or\nportions of the software, acknowledge within their advertising materials\nthat such products contain software developed by UC Berkeley and its\ncontributors.\n\nSpecifically, the provision reads:\n\n\"     * 3. All advertising materials mentioning features or use of this software\n      *    must display the following acknowledgement:\n      *    This product includes software developed by the University of\n      *    California, Berkeley and its contributors.\"\n\nEffective immediately, licensees and distributors are no longer required to\ninclude the acknowledgement within advertising materials.  Accordingly, the\nforegoing paragraph of those BSD Unix files containing it is hereby deleted\nin its entirety.\n\nWilliam Hoskins\nDirector, Office of Technology Licensing\nUniversity of California, Berkeley\n\n----------\n\nWhat follows is the README file as maintained by FreeBSD indent.\n\n----------\n\n  $FreeBSD: head/usr.bin/indent/README 105244 2002-10-16 13:58:39Z charnier $\n\nThis is the C indenter, it originally came from the University of Illinois\nvia some distribution tape for PDP-11 Unix.  It has subsequently been\nhacked upon by James Gosling @ CMU.  It isn't very pretty, and really needs\nto be completely redone, but it is probably the nicest C pretty printer\naround.\n\nFurther additions to provide \"Kernel Normal Form\" were contributed\nby the folks at Sun Microsystems.\n\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n> From mnetor!yunexus!oz@uunet.UU.NET Wed Mar  9 15:30:55 1988\n> Date: Tue, 8 Mar 88 18:36:25 EST\n> From: yunexus!oz@uunet.UU.NET (Ozan Yigit)\n> To: bostic@okeeffe.berkeley.edu\n> Cc: ccvaxa!willcox@uunet.UU.NET, jag@sun.com, rsalz@uunet.UU.NET\n> In-Reply-To: Keith Bostic's message of Tue, 16 Feb 88 16:09:06 PST \n> Subject: Re: Indent...\n\nThank you for your response about indent. I was wrong in my original\nobservation (or mis-observation :-). UCB did keep the Illinois\ncopyright intact.\n\nThe issue still is whether we can distribute indent, and if we can, which\nversion. David Willcox (the author) states that:\n\n| Several people have asked me on what basis I claim that indent is in\n| the public domain.  I knew I would be sorry I made that posting.\n| \n| Some history.  Way back in 1976, the project I worked on at the\n| University of Illinois Center for Advanced Computation had a huge\n| battle about how to format C code.  After about a week of fighting, I\n| got disgusted and wrote a program, which I called indent, to reformat C\n| code.  It had a bunch of different options that would let you format\n| the output the way you liked.  In particular, all of the different\n| formats being championed were supported.\n| \n| It was my first big C program.  It was ugly.  It wasn't designed, it\n| just sort of grew.  But it pretty much worked, and it stopped most of\n| the fighting.\n| \n| As a matter of form, I included a University of Illinois Copyright\n| notice.  However, my understanding was that, since the work was done\n| on an ARPA contract, it was in the public domain.\n| \n| Time passed.  Some years later, indent showed up on one of the early\n| emacs distributions.\n| \n| Later still, someone from UC Berkeley called the UofI and asked if\n| indent was in the public domain.  They wanted to include it in their\n| UNIX distributions, along with the emacs stuff.  I was no longer at the\n| UofI, but Rob Kolstad, who was, asked me about it.  I told him I didn't\n| care if they used it, and since then it has been on the BSD distributions.\n| \n| Somewhere along the way, several other unnamed people have had their\n| hands in it.  It was converted to understand version 7 C.  (The\n| original was version 6.)  It was converted from its original filter\n| interface to its current \"blow away the user's file\" interface.\n| The $HOME/.indent.pro file parsing was added.  Some more formatting\n| options were added.\n| \n| The source I have right now has two copyright notices.  One is the\n| original from the UofI.  One is from Berkeley.\n| \n| I am not a lawyer, and I certainly do not understand copyright law.  As\n| far as I am concerned, the bulk of this program, everything covered by\n| the UofI copyright, is in the public domain, and worth every penny.\n| Berkeley's copyright probably should only cover their changes, and I\n| don't know their feelings about sending it out.  \n\nIn any case, there appears to be none at UofI to clarify/and change\nthat copyright, but I am confident (based on the statements of its\nauthor) that the code, as it stands with its copyright, is\ndistributable, and will not cause any legal problems.\n\nHence, the issue reduces to *which* one to distribute through\ncomp.sources.unix. I would suggest that with the permission of you\nfolks (given that you have parts copyrighted), we distribute the 4.3\nversion of indent, which appears to be the most up-to-date version. I\nhappen to have just about every known version of indent, including the\nvery original submission from the author to a unix tape, later the\nG-Emacs version, any 4.n version, sun version and the Unipress\nversion.  I still think we should not have to \"go-back-in-time\" and\nre-do all the work you people have done.\n\nI hope to hear from you as to what you think about this. You may of\ncourse send 4.3 version to the moderator directly, or you can let me\nknow of your permission, and I will send the sources, or you can let\nme know that 4.3 version is off-limits, in which case we would probably\nhave to revert to an older version. One way or another, I hope to get\na version of indent to comp.sources.unix.\n\nregards..\toz\n\ncc: ccvaxa!willcox\n    sun.com!jar\n    uunet!rsalz","count":55},{"name":"subsystem-name","value":"gist","count":55},{"name":"subsystem-name","value":"nbtree","count":55},{"name":"subsystem-name","value":"pg_bsd_indent","count":55},{"name":"subsystem-name","value":"spgist","count":55},{"name":"subsystem-path","value":"backend/access/gist/readme","count":55},{"name":"subsystem-path","value":"backend/access/nbtree/readme","count":55},{"name":"subsystem-path","value":"backend/access/spgist/readme","count":55},{"name":"subsystem-path","value":"tools/pg_bsd_indent/readme","count":55},{"name":"api-example","value":"bool heap_hot_search_buffer(ItemPointer tid, Relation relation, Buffer buffer, Snapshot snapshot, HeapTuple heapTuple, bool *all_dead, bool first_call) { Page\t\tpage = BufferGetPage(buffer); Transactio...","count":54},{"name":"api-example","value":"static bool range_gist_consistent_int_range(TypeCacheEntry *typcache, StrategyNumber strategy, const RangeType *key, const RangeType *query) { switch (strategy) { case RANGESTRAT_BEFORE: if (RangeIsEm...","count":54},{"name":"api-example","value":"static void CommitTransaction(void) { TransactionState s = CurrentTransactionState; TransactionId latestXid; bool\t\tis_parallel_worker; is_parallel_worker = (s->blockState == TBLOCK_PARALLEL_INPROGRESS...","count":54},{"name":"api-example","value":"void DestroyParallelContext(ParallelContext *pcxt) { int\t\t\ti; * Be careful about order of operations here!  We remove the parallel * context from the list before we do anything else; otherwise, if an ...","count":54},{"name":"api-example","value":"void ParallelWorkerMain(Datum main_arg) { dsm_segment *seg; shm_toc    *toc; FixedParallelState *fps; char\t   *error_queue_space; shm_mq\t   *mq; shm_mq_handle *mqh; char\t   *libraryspace; char\t   *ent...","count":54},{"name":"api-example","value":"void PerformCursorOpen(ParseState *pstate, DeclareCursorStmt *cstmt, ParamListInfo params, bool isTopLevel) { Query\t   *query = castNode(Query, cstmt->query); List\t   *rewritten; PlannedStmt *plan; Po...","count":54},{"name":"api-example","value":"void do_pg_backup_stop(BackupState *state, bool waitforarchive) { bool\t\tbackup_stopped_in_recovery = false; char\t\thistfilepath[MAXPGPATH]; char\t\tlastxlogfilename[MAXFNAMELEN]; char\t\thistfilename[MAXFN...","count":54},{"name":"api-example","value":"void gistRelocateBuildBuffersOnSplit(GISTBuildBuffers *gfbb, GISTSTATE *giststate, Relation r, int level, Buffer buffer, List *splitinfo) { RelocationBufferInfo *relocationBuffersInfos; bool\t\tfound; G...","count":54},{"name":"arch-layer","value":"query-optimizer","count":54},{"name":"arch-layer-description","value":"Query planning and optimization","count":54},{"name":"api-typical-usage","value":"Often called from: ER_flatten_into","count":52},{"name":"api-typical-usage","value":"Often called from: IOContextForStrategy","count":52},{"name":"api-typical-usage","value":"Often called from: PQcancel","count":52},{"name":"api-typical-usage","value":"Often called from: PostmasterMain","count":52},{"name":"api-typical-usage","value":"Often called from: add_tablespace_mapping","count":52},{"name":"api-typical-usage","value":"Often called from: apply_handle_truncate","count":52},{"name":"api-typical-usage","value":"Often called from: gistplacetopage","count":52},{"name":"api-typical-usage","value":"Often called from: next","count":52},{"name":"api-typical-usage","value":"Often called from: pqBuildErrorMessage3","count":52},{"name":"api-typical-usage","value":"Often called from: statext_mcv_deserialize","count":52},{"name":"cyclomatic-complexity","value":"57","count":52},{"name":"cyclomatic-complexity","value":"68","count":52},{"name":"lines-of-code","value":"133","count":52},{"name":"lines-of-code","value":"140","count":52},{"name":"lines-of-code","value":"159","count":52},{"name":"lines-of-code","value":"171","count":52},{"name":"lines-of-code","value":"181","count":52},{"name":"lines-of-code","value":"188","count":52},{"name":"lines-of-code","value":"211","count":52},{"name":"lines-of-code","value":"241","count":52},{"name":"loop-depth","value":"27","count":52},{"name":"loop-depth","value":"37","count":52},{"name":"tested-by","value":"_bt_check_compare, _bt_check_compare, _bt_check_compare, _bt_check_rowcompare, _bt_check_rowcompare, _bt_check_rowcompare","count":52},{"name":"tested-by","value":"check_datestyle, check_datestyle, check_datestyle","count":52},{"name":"tested-by","value":"check_exclusion_or_unique_constraint, check_default_partition_contents","count":52},{"name":"tested-by","value":"check_nested_generated_walker, check_simple_rowfilter_expr_walker, check_agg_arguments_walker, check_ungrouped_columns_walker, check_parameter_resolution_walker","count":52},{"name":"tested-by","value":"check_recovery_target_time","count":52},{"name":"tested-by","value":"check_timezone, check_timezone","count":52},{"name":"api-example","value":"TSVector make_tsvector(ParsedText *prs) { int\t\t\ti, j, lenstr = 0, totallen; TSVector\tin; WordEntry  *ptr; char\t   *str; int\t\t\tstroff; if (prs->curwords > 0) prs->curwords = uniqueWORD(prs->words, prs-...","count":51},{"name":"api-example","value":"XLogRecPtr XLogInsertRecord(XLogRecData *rdata, XLogRecPtr fpw_lsn, uint8 flags, int num_fpi, bool topxid_included) { XLogCtlInsert *Insert = &XLogCtl->Insert; pg_crc32c\trdata_crc; bool\t\tinserted; XLo...","count":51},{"name":"api-example","value":"bool gistplacetopage(Relation rel, Size freespace, GISTSTATE *giststate, Buffer buffer, IndexTuple *itup, int ntup, OffsetNumber oldoffnum, BlockNumber *newblkno, Buffer leftchildbuf, List **splitinfo...","count":51},{"name":"api-example","value":"bool heap_prepare_freeze_tuple(HeapTupleHeader tuple, const struct VacuumCutoffs *cutoffs, HeapPageFreeze *pagefrz, HeapTupleFreeze *frz, bool *totally_frozen) { bool\t\txmin_already_frozen = false, xma...","count":51},{"name":"api-example","value":"static Datum RI_FKey_check(TriggerData *trigdata) { const RI_ConstraintInfo *riinfo; Relation\tfk_rel; Relation\tpk_rel; TupleTableSlot *newslot; RI_QueryKey qkey; SPIPlanPtr\tqplan; riinfo = ri_FetchCon...","count":51},{"name":"api-example","value":"static Datum time_part_common(PG_FUNCTION_ARGS, bool retnumeric) { text\t   *units = PG_GETARG_TEXT_PP(0); TimeADT\t\ttime = PG_GETARG_TIMEADT(1); int64\t\tintresult; int\t\t\ttype, val; char\t   *lowunits; lo...","count":51},{"name":"api-example","value":"static int ident_inet(hbaPort *port) { const SockAddr remote_addr = port->raddr; const SockAddr local_addr = port->laddr; char\t\tident_user[IDENT_USERNAME_MAX + 1]; pgsocket\tsock_fd = PGINVALID_SOCKET;...","count":51},{"name":"api-example","value":"static void AddNewAttributeTuples(Oid new_rel_oid, TupleDesc tupdesc, char relkind) { Relation\trel; CatalogIndexState indstate; int\t\t\tnatts = tupdesc->natts; ObjectAddress myself, referenced; * open p...","count":51},{"name":"api-example","value":"static void XlogReadTwoPhaseData(XLogRecPtr lsn, char **buf, int *len) { XLogRecord *record; XLogReaderState *xlogreader; char\t   *errormsg; xlogreader = XLogReaderAllocate(wal_segment_size, NULL, XL_...","count":51},{"name":"api-example","value":"static void check_input(char *path) { struct stat statbuf; if (stat(path, &statbuf) != 0) { if (errno == ENOENT) { pg_log_error(\"file \\\"%s\\\" does not exist\", path); pg_log_error_hint(\"This might mean ...","count":51},{"name":"api-example","value":"void ParseCommitRecord(uint8 info, xl_xact_commit *xlrec, xl_xact_parsed_commit *parsed) { char\t   *data = ((char *) xlrec) + MinSizeOfXactCommit; memset(parsed, 0, sizeof(*parsed)); parsed->xinfo = 0...","count":51},{"name":"api-example","value":"void PostmasterMain(int argc, char *argv[]) { int\t\t\topt; int\t\t\tstatus; char\t   *userDoption = NULL; bool\t\tlisten_addr_saved = false; char\t   *output_config_variable = NULL; InitProcessGlobals(); Postm...","count":51},{"name":"api-example","value":"void brin_mask(char *pagedata, BlockNumber blkno) { Page\t\tpage = (Page) pagedata; PageHeader\tpagehdr = (PageHeader) page; mask_page_lsn_and_checksum(page); mask_page_hint_bits(page); * Regular brin pa...","count":51},{"name":"api-example","value":"void smgr_desc(StringInfo buf, XLogReaderState *record) { char\t   *rec = XLogRecGetData(record); uint8\t\tinfo = XLogRecGetInfo(record) & ~XLR_INFO_MASK; if (info == XLOG_SMGR_CREATE) { xl_smgr_create *...","count":51},{"name":"subsystem-desc","value":"Block Range Indexes (BRIN)\n==========================\n\nBRIN indexes intend to enable very fast scanning of extremely large tables.\n\nThe essential idea of a BRIN index is to keep track of summarizing values in\nconsecutive groups of heap pages (page ranges); for example, the minimum and\nmaximum values for datatypes with a btree opclass, or the bounding box for\ngeometric types.  These values can be used to avoid scanning such pages\nduring a table scan, depending on query quals.\n\nThe cost of this is having to update the stored summary values of each page\nrange as tuples are inserted into them.\n\n\nAccess Method Design\n--------------------\n\nSince item pointers are not stored inside indexes of this type, it is not\npossible to support the amgettuple interface.  Instead, we only provide\namgetbitmap support.  The amgetbitmap routine returns a lossy TIDBitmap\ncomprising all pages in those page ranges that match the query\nqualifications.  The recheck step in the BitmapHeapScan node prunes tuples\nthat are not visible according to the query qualifications.\n\nAn operator class must have the following entries:\n\n- generic support procedures (pg_amproc), identical to all opclasses:\n  * \"opcinfo\" (BRIN_PROCNUM_OPCINFO) initializes a structure for index\n    creation or scanning\n  * \"addValue\" (BRIN_PROCNUM_ADDVALUE) takes an index tuple and a heap item,\n    and possibly changes the index tuple so that it includes the heap item\n    values\n  * \"consistent\" (BRIN_PROCNUM_CONSISTENT) takes an index tuple and query\n    quals, and returns whether the index tuple values match the query quals.\n  * \"union\" (BRIN_PROCNUM_UNION) takes two index tuples and modifies the first\n    one so that it represents the union of the two.\nProcedure numbers up to 10 are reserved for future expansion.\n\nAdditionally, each opclass needs additional support functions:\n- Minmax-style operator classes:\n  * Proc numbers 11-14 are used for the functions implementing inequality\n    operators for the type, in this order: less than, less or equal,\n    greater or equal, greater than.\n\nOpclasses using a different design will require different additional procedure\nnumbers.\n\nOperator classes also need to have operator (pg_amop) entries so that the\noptimizer can choose the index to execute queries.\n- Minmax-style operator classes:\n  * The same operators as btree (<=, <, =, >=, >)\n\nEach index tuple stores some NULL bits and some opclass-specified values, which\nare stored in a single null bitmask of length twice the number of columns.  The\ngeneric NULL bits indicate, for each column:\n  * bt_hasnulls: Whether there's any NULL value at all in the page range\n  * bt_allnulls: Whether all values are NULLs in the page range\n\nThe opclass-specified values are:\n- Minmax-style operator classes\n  * minimum value across all tuples in the range\n  * maximum value across all tuples in the range\n\nNote that the addValue and Union support procedures  must be careful to\ndatumCopy() the values they want to store in the in-memory BRIN tuple, and\nmust pfree() the old copies when replacing older ones.  Since some values\nreferenced from the tuple persist and others go away, there is no\nwell-defined lifetime for a memory context that would make this automatic.\n\n\nThe Range Map\n-------------\n\nTo find the index tuple for a particular page range, we have an internal\nstructure we call the range map, or \"revmap\" for short.  This stores one TID\nper page range, which is the address of the index tuple summarizing that\nrange.  Since the map entries are fixed size, it is possible to compute the\naddress of the range map entry for any given heap page by simple arithmetic.\n\nWhen a new heap tuple is inserted in a summarized page range, we compare the\nexisting index tuple with the new heap tuple.  If the heap tuple is outside\nthe summarization data given by the index tuple for any indexed column (or\nif the new heap tuple contains null values but the index tuple indicates\nthere are no nulls), the index is updated with the new values.  In many\ncases it is possible to update the index tuple in-place, but if the new\nindex tuple is larger than the old one and there's not enough space in the\npage, it is necessary to create a new index tuple with the new values.  The\nrange map can be updated quickly to point to it; the old index tuple is\nremoved.\n\nIf the range map points to an invalid TID, the corresponding page range is\nconsidered to be not summarized.  When tuples are added to unsummarized\npages, nothing needs to happen.\n\nTo scan a table following a BRIN index, we scan the range map sequentially.\nThis yields index tuples in ascending page range order.  Query quals are\nmatched to each index tuple; if they match, each page within the page range\nis returned as part of the output TID bitmap.  If there's no match, they are\nskipped.  Range map entries returning invalid index TIDs, that is\nunsummarized page ranges, are also returned in the TID bitmap.\n\nThe revmap is stored in the first few blocks of the index main fork,\nimmediately following the metapage.  Whenever the revmap needs to be\nextended by another page, existing tuples in that page are moved to some\nother page.\n\nHeap tuples can be removed from anywhere without restriction.  It might be\nuseful to mark the corresponding index tuple somehow, if the heap tuple is\none of the constraining values of the summary data (i.e. either min or max\nin the case of a btree-opclass-bearing datatype), so that in the future we\nare aware of the need to re-execute summarization on that range, leading to\na possible tightening of the summary values.\n\nSummarization\n-------------\n\nAt index creation time, the whole table is scanned; for each page range the\nsummarizing values of each indexed column and nulls bitmap are collected and\nstored in the index.  The partially-filled page range at the end of the\ntable is also summarized.\n\nAs new tuples get inserted at the end of the table, they may update the\nindex tuple that summarizes the partial page range at the end.  Eventually\nthat page range is complete and new tuples belong in a new page range that\nhasn't yet been summarized.  Those insertions do not create a new index\nentry; instead, the page range remains unsummarized until later.\n\nWhenever VACUUM is run on the table, all unsummarized page ranges are\nsummarized.  This action can also be invoked by the user via\nbrin_summarize_new_values().  Both these procedures scan all the\nunsummarized ranges, and create a summary tuple.  Again, this includes the\npartially-filled page range at the end of the table.\n\nVacuuming\n---------\n\nSince no heap TIDs are stored in a BRIN index, it's not necessary to scan the\nindex when heap tuples are removed.  It might be that some summary values can\nbe tightened if heap tuples have been deleted; but this would represent an\noptimization opportunity only, not a correctness issue.  It's simpler to\nrepresent this as the need to re-run summarization on the affected page range\nrather than \"subtracting\" values from the existing one.  This is not\ncurrently implemented.\n\nNote that if there are no indexes on the table other than the BRIN index,\nusage of maintenance_work_mem by vacuum can be decreased significantly, because\nno detailed index scan needs to take place (and thus it's not necessary for\nvacuum to save TIDs to remove).  It's unlikely that BRIN would be the only\nindexes in a table, though, because primary keys can be btrees only, and so\nwe don't implement this optimization.\n\n\nOptimizer\n---------\n\nThe optimizer selects the index based on the operator class' pg_amop\nentries for the column.\n\n\nFuture improvements\n-------------------\n\n* Different-size page ranges?\n  In the current design, each \"index entry\" in a BRIN index covers the same\n  number of pages.  There's no hard reason for this; it might make sense to\n  allow the index to self-tune so that some index entries cover smaller page\n  ranges, if this allows the summary values to be more compact.  This would incur\n  larger BRIN overhead for the index itself, but might allow better pruning of\n  page ranges during scan.  In the limit of one index tuple per page, the index\n  itself would occupy too much space, even though we would be able to skip\n  reading the most heap pages, because the summary values are tight; in the\n  opposite limit of a single tuple that summarizes the whole table, we wouldn't\n  be able to prune anything even though the index is very small.  This can\n  probably be made to work by using the range map as an index in itself.\n\n* More compact representation for TIDBitmap?\n  TIDBitmap is the structure used to represent bitmap scans.  The\n  representation of lossy page ranges is not optimal for our purposes, because\n  it uses a Bitmapset to represent pages in the range; since we're going to return\n  all pages in a large range, it might be more convenient to allow for a\n  struct that uses start and end page numbers to represent the range, instead.\n\n* Better vacuuming?\n  It might be useful to enable passing more useful info to BRIN indexes during\n  vacuuming about tuples that are deleted, i.e. do not require the callback to\n  pass each tuple's TID.  For instance we might need a callback that passes a\n  block number instead of a TID.  That would help determine when to re-run\n  summarization on blocks that have seen lots of tuple deletions.","count":50},{"name":"subsystem-desc","value":"src/backend/access/hash/README\n\nHash Indexing\n=============\n\nThis directory contains an implementation of hash indexing for Postgres.\nMost of the core ideas are taken from Margo Seltzer and Ozan Yigit,\nA New Hashing Package for UNIX, Proceedings of the Winter USENIX Conference,\nJanuary 1991.  (Our in-memory hashtable implementation,\nsrc/backend/utils/hash/dynahash.c, also relies on some of the same concepts;\nit is derived from code written by Esmond Pitt and later improved by Margo\namong others.)\n\nA hash index consists of two or more \"buckets\", into which tuples are\nplaced whenever their hash key maps to the bucket number.  The\nkey-to-bucket-number mapping is chosen so that the index can be\nincrementally expanded.  When a new bucket is to be added to the index,\nexactly one existing bucket will need to be \"split\", with some of its\ntuples being transferred to the new bucket according to the updated\nkey-to-bucket-number mapping.  This is essentially the same hash table\nmanagement technique embodied in src/backend/utils/hash/dynahash.c for\nin-memory hash tables.\n\nEach bucket in the hash index comprises one or more index pages.  The\nbucket's first page is permanently assigned to it when the bucket is\ncreated.  Additional pages, called \"overflow pages\", are added if the\nbucket receives too many tuples to fit in the primary bucket page.\nThe pages of a bucket are chained together in a doubly-linked list\nusing fields in the index page special space.\n\nThere is currently no provision to shrink a hash index, other than by\nrebuilding it with REINDEX.  Overflow pages can be recycled for reuse\nin other buckets, but we never give them back to the operating system.\nThere is no provision for reducing the number of buckets, either.\n\nAs of PostgreSQL 8.4, hash index entries store only the hash code, not the\nactual data value, for each indexed item.  This makes the index entries\nsmaller (perhaps very substantially so) and speeds up various operations.\nIn particular, we can speed searches by keeping the index entries in any\none index page sorted by hash code, thus allowing binary search to be used\nwithin an index page.  Note however that there is *no* assumption about the\nrelative ordering of hash codes across different index pages of a bucket.\n\n\nPage Addressing\n---------------\n\nThere are four kinds of pages in a hash index: the meta page (page zero),\nwhich contains statically allocated control information; primary bucket\npages; overflow pages; and bitmap pages, which keep track of overflow\npages that have been freed and are available for re-use.  For addressing\npurposes, bitmap pages are regarded as a subset of the overflow pages.\n\nPrimary bucket pages and overflow pages are allocated independently (since\nany given index might need more or fewer overflow pages relative to its\nnumber of buckets).  The hash code uses an interesting set of addressing\nrules to support a variable number of overflow pages while not having to\nmove primary bucket pages around after they are created.\n\nPrimary bucket pages (henceforth just \"bucket pages\") are allocated in\npower-of-2 groups, called \"split points\" in the code.  That means at every new\nsplitpoint we double the existing number of buckets.  Allocating huge chunks\nof bucket pages all at once isn't optimal and we will take ages to consume\nthose.  To avoid this exponential growth of index size, we did use a trick to\nbreak up allocation of buckets at the splitpoint into 4 equal phases.  If\n(2 ^ x) are the total buckets need to be allocated at a splitpoint (from now on\nwe shall call this as a splitpoint group), then we allocate 1/4th (2 ^ (x - 2))\nof total buckets at each phase of splitpoint group.  Next quarter of allocation\nwill only happen if buckets of the previous phase have been already consumed.\nFor the initial splitpoint groups < 10 we will allocate all of their buckets in\nsingle phase only, as number of buckets allocated at initial groups are small\nin numbers.  And for the groups >= 10 the allocation process is distributed\namong four equal phases.  At group 10 we allocate (2 ^ 9) buckets in 4\ndifferent phases {2 ^ 7, 2 ^ 7, 2 ^ 7, 2 ^ 7}, the numbers in curly braces\nindicate the number of buckets allocated within each phase of splitpoint group\n10.  And, for splitpoint group 11 and 12 allocation phases will be\n{2 ^ 8, 2 ^ 8, 2 ^ 8, 2 ^ 8} and {2 ^ 9, 2 ^ 9, 2 ^ 9, 2 ^ 9} respectively.  We\ncan see that at each splitpoint group we double the total number of buckets\nfrom the previous group but in an incremental phase.  The bucket pages\nallocated within one phase of a splitpoint group will appear consecutively in\nthe index.  This addressing scheme allows the physical location of a bucket\npage to be computed from the bucket number relatively easily, using only a\nsmall amount of control information.  If we look at the function\n_hash_spareindex for a given bucket number we first compute the\nsplitpoint group it belongs to and then the phase to which the bucket belongs\nto.  Adding them we get the global splitpoint phase number S to which the\nbucket belongs and then simply add \"hashm_spares[S] + 1\" (where hashm_spares[]\nis an array stored in the metapage) with given bucket number to compute its\nphysical address.  The hashm_spares[S] can be interpreted as the total number\nof overflow pages that have been allocated before the bucket pages of\nsplitpoint phase S.  The hashm_spares[0] is always 0, so that buckets 0 and 1\nalways appear at block numbers 1 and 2, just after the meta page.  We always\nhave hashm_spares[N] <= hashm_spares[N+1], since the latter count includes the\nformer.  The difference between the two represents the number of overflow pages\nappearing between the bucket page groups of splitpoints phase N and N+1.\n(Note: the above describes what happens when filling an initially minimally\nsized hash index.  In practice, we try to estimate the required index size and\nallocate a suitable number of splitpoints phases immediately, to avoid\nexpensive re-splitting during initial index build.)\n\nWhen S splitpoints exist altogether, the array entries hashm_spares[0]\nthrough hashm_spares[S] are valid; hashm_spares[S] records the current\ntotal number of overflow pages.  New overflow pages are created as needed\nat the end of the index, and recorded by incrementing hashm_spares[S].\nWhen it is time to create a new splitpoint phase's worth of bucket pages, we\ncopy hashm_spares[S] into hashm_spares[S+1] and increment S (which is\nstored in the hashm_ovflpoint field of the meta page).  This has the\neffect of reserving the correct number of bucket pages at the end of the\nindex, and preparing to allocate additional overflow pages after those\nbucket pages.  hashm_spares[] entries before S cannot change anymore,\nsince that would require moving already-created bucket pages.\n\nThe last page nominally used by the index is always determinable from\nhashm_spares[S].  To avoid complaints from smgr, the logical EOF as seen by\nthe filesystem and smgr must always be greater than or equal to this page.\nWe have to allow the case \"greater than\" because it's possible that during\nan index extension we crash after allocating filesystem space and before\nupdating the metapage.  Note that on filesystems that allow \"holes\" in\nfiles, it's entirely likely that pages before the logical EOF are not yet\nallocated: when we allocate a new splitpoint phase's worth of bucket pages, we\nphysically zero the last such page to force the EOF up, and the first such\npage will be used immediately, but the intervening pages are not written\nuntil needed.\n\nSince overflow pages may be recycled if enough tuples are deleted from\ntheir bucket, we need a way to keep track of currently-free overflow\npages.  The state of each overflow page (0 = available, 1 = not available)\nis recorded in \"bitmap\" pages dedicated to this purpose.  The entries in\nthe bitmap are indexed by \"bit number\", a zero-based count in which every\noverflow page has a unique entry.  We can convert between an overflow\npage's physical block number and its bit number using the information in\nhashm_spares[] (see hashovfl.c for details).  The bit number sequence\nincludes the bitmap pages, which is the reason for saying that bitmap\npages are a subset of the overflow pages.  It turns out in fact that each\nbitmap page's first bit represents itself --- this is not an essential\nproperty, but falls out of the fact that we only allocate another bitmap\npage when we really need one.  Bit number zero always corresponds to the\nfirst bitmap page, which is allocated during index creation just after all\nthe initially created buckets.\n\n\nLock Definitions\n----------------\n\nConcurrency control for hash indexes is provided using buffer content\nlocks, buffer pins, and cleanup locks.   Here as elsewhere in PostgreSQL,\ncleanup lock means that we hold an exclusive lock on the buffer and have\nobserved at some point after acquiring the lock that we hold the only pin\non that buffer.  For hash indexes, a cleanup lock on a primary bucket page\nrepresents the right to perform an arbitrary reorganization of the entire\nbucket.  Therefore, scans retain a pin on the primary bucket page for the\nbucket they are currently scanning.  Splitting a bucket requires a cleanup\nlock on both the old and new primary bucket pages.  VACUUM therefore takes\na cleanup lock on every bucket page in order to remove tuples.  It can also\nremove tuples copied to a new bucket by any previous split operation, because\nthe cleanup lock taken on the primary bucket page guarantees that no scans\nwhich started prior to the most recent split can still be in progress.  After\ncleaning each page individually, it attempts to take a cleanup lock on the\nprimary bucket page in order to \"squeeze\" the bucket down to the minimum\npossible number of pages.\n\nTo avoid deadlocks, we must be consistent about the lock order in which we\nlock the buckets for operations that requires locks on two different buckets.\nWe choose to always lock the lower-numbered bucket first.  The metapage is\nonly ever locked after all bucket locks have been taken.\n\n\nMetapage Caching\n----------------\n\nBoth scanning the index and inserting tuples require locating the bucket\nwhere a given tuple ought to be located.  To do this, we need the bucket\ncount, highmask, and lowmask from the metapage; however, it's undesirable\nfor performance reasons to have to have to lock and pin the metapage for\nevery such operation.  Instead, we retain a cached copy of the metapage\nin each backend's relcache entry.  This will produce the correct\nbucket mapping as long as the target bucket hasn't been split since the\nlast cache refresh.\n\nTo guard against the possibility that such a split has occurred, the\nprimary page of each bucket chain stores the number of buckets that\nexisted as of the time the bucket was last split, or if never split as\nof the time it was created, in the space normally used for the\nprevious block number (that is, hasho_prevblkno).  This doesn't cost\nanything because the primary bucket page is always the first page in\nthe chain, and the previous block number is therefore always, in\nreality, InvalidBlockNumber.\n\nAfter computing the ostensibly-correct bucket number based on our cached\ncopy of the metapage, we lock the corresponding primary bucket page and\ncheck whether the bucket count stored in hasho_prevblkno is greater than\nthe number of buckets stored in our cached copy of the metapage.  If\nso, the bucket has certainly been split, because the count must originally\nhave been less than the number of buckets that existed at that time and\ncan't have increased except due to a split.  If not, the bucket can't have\nbeen split, because a split would have created a new bucket with a higher\nbucket number than any we'd seen previously.  In the latter case, we've\nlocked the correct bucket and can proceed; in the former case, we must\nrelease the lock on this bucket, lock the metapage, update our cache,\nunlock the metapage, and retry.\n\nNeeding to retry occasionally might seem expensive, but the number of times\nany given bucket can be split is limited to a few dozen no matter how\nmany times the hash index is accessed, because the total number of\nbuckets is limited to less than 2^32.  On the other hand, the number of\ntimes we access a bucket is unbounded and will be several orders of\nmagnitude larger even in unsympathetic cases.\n\n(The metapage cache is new in v10.  Older hash indexes had the primary\nbucket page's hasho_prevblkno initialized to InvalidBuffer.)\n\nPseudocode Algorithms\n---------------------\n\nVarious flags that are used in hash index operations are described as below:\n\nThe bucket-being-split and bucket-being-populated flags indicate that split\noperation is in progress for a bucket.  During split operation, a\nbucket-being-split flag is set on the old bucket and bucket-being-populated\nflag is set on new bucket.  These flags are cleared once the split operation\nis finished.\n\nThe split-cleanup flag indicates that a bucket which has been recently split\nstill contains tuples that were also copied to the new bucket; it essentially\nmarks the split as incomplete.  Once we're certain that no scans which\nstarted before the new bucket was fully populated are still in progress, we\ncan remove the copies from the old bucket and clear the flag.  We insist that\nthis flag must be clear before splitting a bucket; thus, a bucket can't be\nsplit again until the previous split is totally complete.\n\nThe moved-by-split flag on a tuple indicates that tuple is moved from old to\nnew bucket.  Concurrent scans will skip such tuples until the split operation\nis finished.  Once the tuple is marked as moved-by-split, it will remain so\nforever but that does no harm.  We have intentionally not cleared it as that\ncan generate an additional I/O which is not necessary.\n\nThe operations we need to support are: readers scanning the index for\nentries of a particular hash code (which by definition are all in the same\nbucket); insertion of a new tuple into the correct bucket; enlarging the\nhash table by splitting an existing bucket; and garbage collection\n(deletion of dead tuples and compaction of buckets).  Bucket splitting is\ndone at conclusion of any insertion that leaves the hash table more full\nthan the target load factor, but it is convenient to consider it as an\nindependent operation.  Note that we do not have a bucket-merge operation\n--- the number of buckets never shrinks.  Insertion, splitting, and\ngarbage collection may all need access to freelist management, which keeps\ntrack of available overflow pages.\n\nThe reader algorithm is:\n\n    lock the primary bucket page of the target bucket\n\tif the target bucket is still being populated by a split:\n\t\trelease the buffer content lock on current bucket page\n\t\tpin and acquire the buffer content lock on old bucket in shared mode\n\t\trelease the buffer content lock on old bucket, but not pin\n\t\tretake the buffer content lock on new bucket\n\t\tarrange to scan the old bucket normally and the new bucket for\n         tuples which are not moved-by-split\n-- then, per read request:\n\treacquire content lock on current page\n\tstep to next page if necessary (no chaining of content locks, but keep\n\tthe pin on the primary bucket throughout the scan)\n\tsave all the matching tuples from current index page into an items array\n\trelease pin and content lock (but if it is primary bucket page retain\n\tits pin till the end of the scan)\n\tget tuple from an item array\n-- at scan shutdown:\n\trelease all pins still held\n\nHolding the buffer pin on the primary bucket page for the whole scan prevents\nthe reader's current-tuple pointer from being invalidated by splits or\ncompactions.  (Of course, other buckets can still be split or compacted.)\n\nTo minimize lock/unlock traffic, hash index scan always searches the entire\nhash page to identify all the matching items at once, copying their heap tuple\nIDs into backend-local storage. The heap tuple IDs are then processed while not\nholding any page lock within the index thereby, allowing concurrent insertion\nto happen on the same index page without any requirement of re-finding the\ncurrent scan position for the reader. We do continue to hold a pin on the\nbucket page, to protect against concurrent deletions and bucket split.\n\nTo allow for scans during a bucket split, if at the start of the scan, the\nbucket is marked as bucket-being-populated, it scan all the tuples in that\nbucket except for those that are marked as moved-by-split.  Once it finishes\nthe scan of all the tuples in the current bucket, it scans the old bucket from\nwhich this bucket is formed by split.\n\nThe insertion algorithm is rather similar:\n\n    lock the primary bucket page of the target bucket\n-- (so far same as reader, except for acquisition of buffer content lock in\n\texclusive mode on primary bucket page)\n\tif the bucket-being-split flag is set for a bucket and pin count on it is\n\t one, then finish the split\n\t\trelease the buffer content lock on current bucket\n\t\tget the \"new\" bucket which was being populated by the split\n\t\tscan the new bucket and form the hash table of TIDs\n\t\tconditionally get the cleanup lock on old and new buckets\n\t\tif we get the lock on both the buckets\n\t\t\tfinish the split using algorithm mentioned below for split\n\t\trelease the pin on old bucket and restart the insert from beginning.\n\tif current page is full, first check if this page contains any dead tuples.\n\tif yes, remove dead tuples from the current page and again check for the\n\tavailability of the space. If enough space found, insert the tuple else\n\trelease lock but not pin, read/exclusive-lock\n     next page; repeat as needed\n\t>> see below if no space in any page of bucket\n\ttake buffer content lock in exclusive mode on metapage\n\tinsert tuple at appropriate place in page\n\tmark current page dirty\n\tincrement tuple count, decide if split needed\n\tmark meta page dirty\n\twrite WAL for insertion of tuple\n\trelease the buffer content lock on metapage\n\trelease buffer content lock on current page\n\tif current page is not a bucket page, release the pin on bucket page\n\tif split is needed, enter Split algorithm below\n\trelease the pin on metapage\n\nTo speed searches, the index entries within any individual index page are\nkept sorted by hash code; the insertion code must take care to insert new\nentries in the right place.  It is okay for an insertion to take place in a\nbucket that is being actively scanned, because readers can cope with this\nas explained above.  We only need the short-term buffer locks to ensure\nthat readers do not see a partially-updated page.\n\nTo avoid deadlock between readers and inserters, whenever there is a need\nto lock multiple buckets, we always take in the order suggested in Lock\nDefinitions above.  This algorithm allows them a very high degree of\nconcurrency.  (The exclusive metapage lock taken to update the tuple count\nis stronger than necessary, since readers do not care about the tuple count,\nbut the lock is held for such a short time that this is probably not an\nissue.)\n\nWhen an inserter cannot find space in any existing page of a bucket, it\nmust obtain an overflow page and add that page to the bucket's chain.\nDetails of that part of the algorithm appear later.\n\nThe page split algorithm is entered whenever an inserter observes that the\nindex is overfull (has a higher-than-wanted ratio of tuples to buckets).\nThe algorithm attempts, but does not necessarily succeed, to split one\nexisting bucket in two, thereby lowering the fill ratio:\n\n    pin meta page and take buffer content lock in exclusive mode\n    check split still needed\n    if split not needed anymore, drop buffer content lock and pin and exit\n    decide which bucket to split\n    try to take a cleanup lock on that bucket; if fail, give up\n    if that bucket is still being split or has split-cleanup work:\n       try to finish the split and the cleanup work\n       if that succeeds, start over; if it fails, give up\n\tmark the old and new buckets indicating split is in progress\n\tmark both old and new buckets as dirty\n\twrite WAL for allocation of new page for split\n\tcopy the tuples that belongs to new bucket from old bucket, marking\n     them as moved-by-split\n\twrite WAL record for moving tuples to new page once the new page is full\n\tor all the pages of old bucket are finished\n\trelease lock but not pin for primary bucket page of old bucket,\n\t read/shared-lock next page; repeat as needed\n\tclear the bucket-being-split and bucket-being-populated flags\n\tmark the old bucket indicating split-cleanup\n\twrite WAL for changing the flags on both old and new buckets\n\nThe split operation's attempt to acquire cleanup-lock on the old bucket number\ncould fail if another process holds any lock or pin on it.  We do not want to\nwait if that happens, because we don't want to wait while holding the metapage\nexclusive-lock.  So, this is a conditional LWLockAcquire operation, and if\nit fails we just abandon the attempt to split.  This is all right since the\nindex is overfull but perfectly functional.  Every subsequent inserter will\ntry to split, and eventually one will succeed.  If multiple inserters failed\nto split, the index might still be overfull, but eventually, the index will\nnot be overfull and split attempts will stop.  (We could make a successful\nsplitter loop to see if the index is still overfull, but it seems better to\ndistribute the split overhead across successive insertions.)\n\nIf a split fails partway through (e.g. due to insufficient disk space or an\ninterrupt), the index will not be corrupted.  Instead, we'll retry the split\nevery time a tuple is inserted into the old bucket prior to inserting the new\ntuple; eventually, we should succeed.  The fact that a split is left\nunfinished doesn't prevent subsequent buckets from being split, but we won't\ntry to split the bucket again until the prior split is finished.  In other\nwords, a bucket can be in the middle of being split for some time, but it can't\nbe in the middle of two splits at the same time.\n\nThe fourth operation is garbage collection (bulk deletion):\n\n\tnext bucket := 0\n\tpin metapage and take buffer content lock in exclusive mode\n\tfetch current max bucket number\n\trelease meta page buffer content lock and pin\n\twhile next bucket <= max bucket do\n\t\tacquire cleanup lock on primary bucket page\n\t\tloop:\n\t\t\tscan and remove tuples\n\t\t\tmark the target page dirty\n\t\t\twrite WAL for deleting tuples from target page\n\t\t\tif this is the last bucket page, break out of loop\n\t\t\tpin and x-lock next page\n\t\t\trelease prior lock and pin (except keep pin on primary bucket page)\n\t\tif the page we have locked is not the primary bucket page:\n\t\t\trelease lock and take exclusive lock on primary bucket page\n\t\tif there are no other pins on the primary bucket page:\n\t\t\tsqueeze the bucket to remove free space\n\t\trelease the pin on primary bucket page\n\t\tnext bucket ++\n\tend loop\n\tpin metapage and take buffer content lock in exclusive mode\n\tcheck if number of buckets changed\n\tif so, release content lock and pin and return to for-each-bucket loop\n\telse update metapage tuple count\n\tmark meta page dirty and write WAL for update of metapage\n\trelease buffer content lock and pin\n\nNote that this is designed to allow concurrent splits and scans.  If a split\noccurs, tuples relocated into the new bucket will be visited twice by the\nscan, but that does no harm.  See also \"Interlocking Between Scans and\nVACUUM\", below.\n\nWe must be careful about the statistics reported by the VACUUM operation.\nWhat we can do is count the number of tuples scanned, and believe this in\npreference to the stored tuple count if the stored tuple count and number of\nbuckets did *not* change at any time during the scan.  This provides a way of\ncorrecting the stored tuple count if it gets out of sync for some reason.  But\nif a split or insertion does occur concurrently, the scan count is\nuntrustworthy; instead, subtract the number of tuples deleted from the stored\ntuple count and use that.\n\nInterlocking Between Scans and VACUUM\n-------------------------------------\n\nSince we release the lock on bucket page during a cleanup scan of a bucket, a\nconcurrent scan could start in that bucket before we've finished vacuuming it.\nIf a scan gets ahead of cleanup, we could have the following problem: (1) the\nscan sees heap TIDs that are about to be removed before they are processed by\nVACUUM, (2) the scan decides that one or more of those TIDs are dead, (3)\nVACUUM completes, (4) one or more of the TIDs the scan decided were dead are\nreused for an unrelated tuple, and finally (5) the scan wakes up and\nerroneously kills the new tuple.\n\nNote that this requires VACUUM and a scan to be active in the same bucket at\nthe same time.  If VACUUM completes before the scan starts, the scan never has\na chance to see the dead tuples; if the scan completes before the VACUUM\nstarts, the heap TIDs can't have been reused meanwhile.  Furthermore, VACUUM\ncan't start on a bucket that has an active scan, because the scan holds a pin\non the primary bucket page, and VACUUM must take a cleanup lock on that page\nin order to begin cleanup.  Therefore, the only way this problem can occur is\nfor a scan to start after VACUUM has released the cleanup lock on the bucket\nbut before it has processed the entire bucket and then overtake the cleanup\noperation.\n\nCurrently, we prevent this using lock chaining: cleanup locks the next page\nin the chain before releasing the lock and pin on the page just processed.\n\nFree Space Management\n---------------------\n\n(Question: why is this so complicated?  Why not just have a linked list\nof free pages with the list head in the metapage?  It's not like we\navoid needing to modify the metapage with all this.)\n\nFree space management consists of two sub-algorithms, one for reserving\nan overflow page to add to a bucket chain, and one for returning an empty\noverflow page to the free pool.\n\nObtaining an overflow page:\n\n\ttake metapage content lock in exclusive mode\n\tdetermine next bitmap page number; if none, exit loop\n\trelease meta page content lock\n\tpin bitmap page and take content lock in exclusive mode\n\tsearch for a free page (zero bit in bitmap)\n\tif found:\n\t\tset bit in bitmap\n\t\tmark bitmap page dirty\n\t\ttake metapage buffer content lock in exclusive mode\n\t\tif first-free-bit value did not change,\n\t\t\tupdate it and mark meta page dirty\n\telse (not found):\n\trelease bitmap page buffer content lock\n\tloop back to try next bitmap page, if any\n-- here when we have checked all bitmap pages; we hold meta excl. lock\n\textend index to add another overflow page; update meta information\n\tmark meta page dirty\n\treturn page number\n\nIt is slightly annoying to release and reacquire the metapage lock\nmultiple times, but it seems best to do it that way to minimize loss of\nconcurrency against processes just entering the index.  We don't want\nto hold the metapage exclusive lock while reading in a bitmap page.\n(We can at least avoid repeated buffer pin/unpin here.)\n\nThe normal path for extending the index does not require doing I/O while\nholding the metapage lock.  We do have to do I/O when the extension\nrequires adding a new bitmap page as well as the required overflow page\n... but that is an infrequent case, so the loss of concurrency seems\nacceptable.\n\nThe portion of tuple insertion that calls the above subroutine looks\nlike this:\n\n\t-- having determined that no space is free in the target bucket:\n\tremember last page of bucket, drop write lock on it\n\tre-write-lock last page of bucket\n\tif it is not last anymore, step to the last page\n\texecute free-page-acquire (obtaining an overflow page) mechanism\n      described above\n\tupdate (former) last page to point to the new page and mark buffer dirty\n\twrite-lock and initialize new page, with back link to former last page\n\twrite WAL for addition of overflow page\n\trelease the locks on meta page and bitmap page acquired in\n      free-page-acquire algorithm\n\trelease the lock on former last page\n\trelease the lock on new overflow page\n\tinsert tuple into new page\n\t-- etc.\n\nNotice this handles the case where two concurrent inserters try to extend\nthe same bucket.  They will end up with a valid, though perhaps\nspace-inefficient, configuration: two overflow pages will be added to the\nbucket, each containing one tuple.\n\nThe last part of this violates the rule about holding write lock on two\npages concurrently, but it should be okay to write-lock the previously\nfree page; there can be no other process holding lock on it.\n\nBucket splitting uses a similar algorithm if it has to extend the new\nbucket, but it need not worry about concurrent extension since it has\nbuffer content lock in exclusive mode on the new bucket.\n\nFreeing an overflow page requires the process to hold buffer content lock in\nexclusive mode on the containing bucket, so need not worry about other\naccessors of pages in the bucket.  The algorithm is:\n\n\tdelink overflow page from bucket chain\n\t(this requires read/update/write/release of fore and aft siblings)\n\tpin meta page and take buffer content lock in shared mode\n\tdetermine which bitmap page contains the free space bit for page\n\trelease meta page buffer content lock\n\tpin bitmap page and take buffer content lock in exclusive mode\n\tretake meta page buffer content lock in exclusive mode\n\tmove (insert) tuples that belong to the overflow page being freed\n\tupdate bitmap bit\n\tmark bitmap page dirty\n\tif page number is still less than first-free-bit,\n\t\tupdate first-free-bit field and mark meta page dirty\n\twrite WAL for delinking overflow page operation\n\trelease buffer content lock and pin\n\trelease meta page buffer content lock and pin\n\nWe have to do it this way because we must clear the bitmap bit before\nchanging the first-free-bit field (hashm_firstfree).  It is possible that\nwe set first-free-bit too small (because someone has already reused the\npage we just freed), but that is okay; the only cost is the next overflow\npage acquirer will scan more bitmap bits than he needs to.  What must be\navoided is having first-free-bit greater than the actual first free bit,\nbecause then that free page would never be found by searchers.\n\nThe reason of moving tuples from overflow page while delinking the later is\nto make that as an atomic operation.  Not doing so could lead to spurious reads\non standby.  Basically, the user might see the same tuple twice.\n\n\nWAL Considerations\n------------------\n\nThe hash index operations like create index, insert, delete, bucket split,\nallocate overflow page, and squeeze in themselves don't guarantee hash index\nconsistency after a crash.  To provide robustness, we write WAL for each of\nthese operations.\n\nCREATE INDEX writes multiple WAL records.  First, we write a record to cover\nthe initialization of the metapage, followed by one for each new bucket\ncreated, followed by one for the initial bitmap page.  It's not important for\nindex creation to appear atomic, because the index isn't yet visible to any\nother transaction, and the creating transaction will roll back in the event of\na crash.  It would be difficult to cover the whole operation with a single\nwrite-ahead log record anyway, because we can log only a fixed number of\npages, as given by XLR_MAX_BLOCK_ID (32), with current XLog machinery.\n\nOrdinary item insertions (that don't force a page split or need a new overflow\npage) are single WAL entries.  They touch a single bucket page and the\nmetapage.  The metapage is updated during replay as it is updated during\noriginal operation.\n\nIf an insertion causes the addition of an overflow page, there will be one\nWAL entry for the new overflow page and second entry for insert itself.\n\nIf an insertion causes a bucket split, there will be one WAL entry for insert\nitself, followed by a WAL entry for allocating a new bucket, followed by a WAL\nentry for each overflow bucket page in the new bucket to which the tuples are\nmoved from old bucket, followed by a WAL entry to indicate that split is\ncomplete for both old and new buckets.  A split operation which requires\noverflow pages to complete the operation will need to write a WAL record for\neach new allocation of an overflow page.\n\nAs splitting involves multiple atomic actions, it's possible that the system\ncrashes between moving tuples from bucket pages of the old bucket to new\nbucket.  In such a case, after recovery, the old and new buckets will be\nmarked with bucket-being-split and bucket-being-populated flags respectively\nwhich indicates that split is in progress for those buckets.  The reader\nalgorithm works correctly, as it will scan both the old and new buckets when\nthe split is in progress as explained in the reader algorithm section above.\n\nWe finish the split at next insert or split operation on the old bucket as\nexplained in insert and split algorithm above.  It could be done during\nsearches, too, but it seems best not to put any extra updates in what would\notherwise be a read-only operation (updating is not possible in hot standby\nmode anyway).  It would seem natural to complete the split in VACUUM, but since\nsplitting a bucket might require allocating a new page, it might fail if you\nrun out of disk space.  That would be bad during VACUUM - the reason for\nrunning VACUUM in the first place might be that you run out of disk space,\nand now VACUUM won't finish because you're out of disk space.  In contrast,\nan insertion can require enlarging the physical file anyway.\n\nDeletion of tuples from a bucket is performed for two reasons: to remove dead\ntuples, and to remove tuples that were moved by a bucket split.  A WAL entry\nis made for each bucket page from which tuples are removed, and then another\nWAL entry is made when we clear the needs-split-cleanup flag.  If dead tuples\nare removed, a separate WAL entry is made to update the metapage.\n\nAs deletion involves multiple atomic operations, it is quite possible that\nsystem crashes after (a) removing tuples from some of the bucket pages, (b)\nbefore clearing the garbage flag, or (c) before updating the metapage.  If the\nsystem crashes before completing (b), it will again try to clean the bucket\nduring next vacuum or insert after recovery which can have some performance\nimpact, but it will work fine. If the system crashes before completing (c),\nafter recovery there could be some additional splits until the next vacuum\nupdates the metapage, but the other operations like insert, delete and scan\nwill work correctly.  We can fix this problem by actually updating the\nmetapage based on delete operation during replay, but it's not clear whether\nit's worth the complication.\n\nA squeeze operation moves tuples from one of the buckets later in the chain to\none of the bucket earlier in chain and writes WAL record when either the\nbucket to which it is writing tuples is filled or bucket from which it\nis removing the tuples becomes empty.\n\nAs a squeeze operation involves writing multiple atomic operations, it is\nquite possible that the system crashes before completing the operation on\nentire bucket.  After recovery, the operations will work correctly, but\nthe index will remain bloated and this can impact performance of read and\ninsert operations until the next vacuum squeeze the bucket completely.\n\n\nOther Notes\n-----------\n\nClean up locks prevent a split from occurring while *another* process is stopped\nin a given bucket.  It also ensures that one of our *own* backend's scans is not\nstopped in the bucket.","count":50},{"name":"subsystem-desc","value":"src/backend/utils/mmgr/README\n\nMemory Context System Design Overview\n=====================================\n\nBackground\n----------\n\nWe do most of our memory allocation in \"memory contexts\", which are usually\nAllocSets as implemented by src/backend/utils/mmgr/aset.c.  The key to\nsuccessful memory management without lots of overhead is to define a useful\nset of contexts with appropriate lifespans.\n\nThe basic operations on a memory context are:\n\n* create a context\n\n* allocate a chunk of memory within a context (equivalent of standard\n  C library's malloc())\n\n* delete a context (including freeing all the memory allocated therein)\n\n* reset a context (free all memory allocated in the context, but not the\n  context object itself)\n\n* inquire about the total amount of memory allocated to the context\n  (the raw memory from which the context allocates chunks; not the\n  chunks themselves)\n\nGiven a chunk of memory previously allocated from a context, one can\nfree it or reallocate it larger or smaller (corresponding to standard C\nlibrary's free() and realloc() routines).  These operations return memory\nto or get more memory from the same context the chunk was originally\nallocated in.\n\nAt all times there is a \"current\" context denoted by the\nCurrentMemoryContext global variable.  palloc() implicitly allocates space\nin that context.  The MemoryContextSwitchTo() operation selects a new current\ncontext (and returns the previous context, so that the caller can restore the\nprevious context before exiting).\n\nThe main advantage of memory contexts over plain use of malloc/free is\nthat the entire contents of a memory context can be freed easily, without\nhaving to request freeing of each individual chunk within it.  This is\nboth faster and more reliable than per-chunk bookkeeping.  We use this\nfact to clean up at transaction end: by resetting all the active contexts\nof transaction or shorter lifespan, we can reclaim all transient memory.\nSimilarly, we can clean up at the end of each query, or after each tuple\nis processed during a query.\n\n\nSome Notes About the palloc API Versus Standard C Library\n---------------------------------------------------------\n\nThe behavior of palloc and friends is similar to the standard C library's\nmalloc and friends, but there are some deliberate differences too.  Here\nare some notes to clarify the behavior.\n\n* If out of memory, palloc and repalloc exit via elog(ERROR).  They\nnever return NULL, and it is not necessary or useful to test for such\na result.  With palloc_extended() that behavior can be overridden\nusing the MCXT_ALLOC_NO_OOM flag.\n\n* palloc(0) is explicitly a valid operation.  It does not return a NULL\npointer, but a valid chunk of which no bytes may be used.  However, the\nchunk might later be repalloc'd larger; it can also be pfree'd without\nerror.  Similarly, repalloc allows realloc'ing to zero size.\n\n* pfree and repalloc do not accept a NULL pointer.  This is intentional.\n(For repalloc, this is necessary: As mentioned above, repalloc does\nnot depend on the current memory context.  But then it needs to know\nwhich memory context to do the allocation in.  So the first allocation\nhas to be done outside of repalloc.  For pfree, this behavior is\nmostly historical and partially because the extra check would impact\nperformance.)\n\n\nThe Current Memory Context\n--------------------------\n\nBecause it would be too much notational overhead to always pass an\nappropriate memory context to called routines, there always exists the\nnotion of the current memory context CurrentMemoryContext.  Without it,\nfor example, the copyObject routines would need to be passed a context, as\nwould function execution routines that return a pass-by-reference\ndatatype.  Similarly for routines that temporarily allocate space\ninternally, but don't return it to their caller?  We certainly don't\nwant to clutter every call in the system with \"here is a context to\nuse for any temporary memory allocation you might want to do\".\n\nThe upshot of that reasoning, though, is that CurrentMemoryContext should\ngenerally point at a short-lifespan context if at all possible.  During\nquery execution it usually points to a context that gets reset after each\ntuple.  Only in *very* circumscribed code should it ever point at a\ncontext having greater than transaction lifespan, since doing so risks\npermanent memory leaks.\n\n\npfree/repalloc Do Not Depend On CurrentMemoryContext\n----------------------------------------------------\n\npfree() and repalloc() can be applied to any chunk whether it belongs\nto CurrentMemoryContext or not --- the chunk's owning context will be\ninvoked to handle the operation, regardless.\n\n\n\"Parent\" and \"Child\" Contexts\n-----------------------------\n\nIf all contexts were independent, it'd be hard to keep track of them,\nespecially in error cases.  That is solved by creating a tree of\n\"parent\" and \"child\" contexts.  When creating a memory context, the\nnew context can be specified to be a child of some existing context.\nA context can have many children, but only one parent.  In this way\nthe contexts form a forest (not necessarily a single tree, since there\ncould be more than one top-level context; although in current practice\nthere is only one top context, TopMemoryContext).\n\nDeleting a context deletes all its direct and indirect children as\nwell.  When resetting a context it's almost always more useful to\ndelete child contexts, thus MemoryContextReset() means that, and if\nyou really do want a tree of empty contexts you need to call\nMemoryContextResetOnly() plus MemoryContextResetChildren().\n\nThese features allow us to manage a lot of contexts without fear that\nsome will be leaked; we only need to keep track of one top-level\ncontext that we are going to delete at transaction end, and make sure\nthat any shorter-lived contexts we create are descendants of that\ncontext.  Since the tree can have multiple levels, we can deal easily\nwith nested lifetimes of storage, such as per-transaction,\nper-statement, per-scan, per-tuple.  Storage lifetimes that only\npartially overlap can be handled by allocating from different trees of\nthe context forest (there are some examples in the next section).\n\nFor convenience we also provide operations like \"reset/delete all children\nof a given context, but don't reset or delete that context itself\".\n\n\nMemory Context Reset/Delete Callbacks\n-------------------------------------\n\nA feature introduced in Postgres 9.5 allows memory contexts to be used\nfor managing more resources than just plain palloc'd memory.  This is\ndone by registering a \"reset callback function\" for a memory context.\nSuch a function will be called, once, just before the context is next\nreset or deleted.  It can be used to give up resources that are in some\nsense associated with an object allocated within the context.  Possible\nuse-cases include\n* closing open files associated with a tuplesort object;\n* releasing reference counts on long-lived cache objects that are held\n  by some object within the context being reset;\n* freeing malloc-managed memory associated with some palloc'd object.\nThat last case would just represent bad programming practice for pure\nPostgres code; better to have made all the allocations using palloc,\nin the target context or some child context.  However, it could well\ncome in handy for code that interfaces to non-Postgres libraries.\n\nAny number of reset callbacks can be established for a memory context;\nthey are called in reverse order of registration.  Also, callbacks\nattached to child contexts are called before callbacks attached to\nparent contexts, if a tree of contexts is being reset or deleted.\n\nThe API for this requires the caller to provide a MemoryContextCallback\nmemory chunk to hold the state for a callback.  Typically this should be\nallocated in the same context it is logically attached to, so that it\nwill be released automatically after use.  The reason for asking the\ncaller to provide this memory is that in most usage scenarios, the caller\nwill be creating some larger struct within the target context, and the\nMemoryContextCallback struct can be made \"for free\" without a separate\npalloc() call by including it in this larger struct.\n\n\nMemory Contexts in Practice\n===========================\n\nGlobally Known Contexts\n-----------------------\n\nThere are a few widely-known contexts that are typically referenced\nthrough global variables.  At any instant the system may contain many\nadditional contexts, but all other contexts should be direct or indirect\nchildren of one of these contexts to ensure they are not leaked in event\nof an error.\n\nTopMemoryContext --- this is the actual top level of the context tree;\nevery other context is a direct or indirect child of this one.  Allocating\nhere is essentially the same as \"malloc\", because this context will never\nbe reset or deleted.  This is for stuff that should live forever, or for\nstuff that the controlling module will take care of deleting at the\nappropriate time.  An example is fd.c's tables of open files.  Avoid\nallocating stuff here unless really necessary, and especially avoid\nrunning with CurrentMemoryContext pointing here.\n\nPostmasterContext --- this is the postmaster's normal working context.\nAfter a backend is spawned, it can delete PostmasterContext to free its\ncopy of memory the postmaster was using that it doesn't need.\nNote that in non-EXEC_BACKEND builds, the postmaster's copy of pg_hba.conf\nand pg_ident.conf data is used directly during authentication in backend\nprocesses; so backends can't delete PostmasterContext until that's done.\n(The postmaster has only TopMemoryContext, PostmasterContext, and\nErrorContext --- the remaining top-level contexts are set up in each\nbackend during startup.)\n\nCacheMemoryContext --- permanent storage for relcache, catcache, and\nrelated modules.  This will never be reset or deleted, either, so it's\nnot truly necessary to distinguish it from TopMemoryContext.  But it\nseems worthwhile to maintain the distinction for debugging purposes.\n(Note: CacheMemoryContext has child contexts with shorter lifespans.\nFor example, a child context is the best place to keep the subsidiary\nstorage associated with a relcache entry; that way we can free rule\nparsetrees and so forth easily, without having to depend on constructing\na reliable version of freeObject().)\n\nMessageContext --- this context holds the current command message from the\nfrontend, as well as any derived storage that need only live as long as\nthe current message (for example, in simple-Query mode the parse and plan\ntrees can live here).  This context will be reset, and any children\ndeleted, at the top of each cycle of the outer loop of PostgresMain.  This\nis kept separate from per-transaction and per-portal contexts because a\nquery string might need to live either a longer or shorter time than any\nsingle transaction or portal.\n\nTopTransactionContext --- this holds everything that lives until end of the\ntop-level transaction.  This context will be reset, and all its children\ndeleted, at conclusion of each top-level transaction cycle.  In most cases\nyou don't want to allocate stuff directly here, but in CurTransactionContext;\nwhat does belong here is control information that exists explicitly to manage\nstatus across multiple subtransactions.  Note: this context is NOT cleared\nimmediately upon error; its contents will survive until the transaction block\nis exited by COMMIT/ROLLBACK.\n\nCurTransactionContext --- this holds data that has to survive until the end\nof the current transaction, and in particular will be needed at top-level\ntransaction commit.  When we are in a top-level transaction this is the same\nas TopTransactionContext, but in subtransactions it points to a child context.\nIt is important to understand that if a subtransaction aborts, its\nCurTransactionContext is thrown away after finishing the abort processing;\nbut a committed subtransaction's CurTransactionContext is kept until top-level\ncommit (unless of course one of the intermediate levels of subtransaction\naborts).  This ensures that we do not keep data from a failed subtransaction\nlonger than necessary.  Because of this behavior, you must be careful to clean\nup properly during subtransaction abort --- the subtransaction's state must be\ndelinked from any pointers or lists kept in upper transactions, or you will\nhave dangling pointers leading to a crash at top-level commit.  An example of\ndata kept here is pending NOTIFY messages, which are sent at top-level commit,\nbut only if the generating subtransaction did not abort.\n\nPortalContext --- this is not actually a separate context, but a\nglobal variable pointing to the per-portal context of the currently active\nexecution portal.  This can be used if it's necessary to allocate storage\nthat will live just as long as the execution of the current portal requires.\n\nErrorContext --- this permanent context is switched into for error\nrecovery processing, and then reset on completion of recovery.  We arrange\nto have a few KB of memory available in it at all times.  In this way, we\ncan ensure that some memory is available for error recovery even if the\nbackend has run out of memory otherwise.  This allows out-of-memory to be\ntreated as a normal ERROR condition, not a FATAL error.\n\n\nContexts For Prepared Statements And Portals\n--------------------------------------------\n\nA prepared-statement object has an associated private context, in which\nthe parse and plan trees for its query are stored.  Because these trees\nare read-only to the executor, the prepared statement can be re-used many\ntimes without further copying of these trees.\n\nAn execution-portal object has a private context that is referenced by\nPortalContext when the portal is active.  In the case of a portal created\nby DECLARE CURSOR, this private context contains the query parse and plan\ntrees (there being no other object that can hold them).  Portals created\nfrom prepared statements simply reference the prepared statements' trees,\nand don't actually need any storage allocated in their private contexts.\n\n\nLogical Replication Worker Contexts\n-----------------------------------\n\nApplyContext --- permanent during whole lifetime of apply worker.  It\nis possible to use TopMemoryContext here as well, but for simplicity\nof memory usage analysis we spin up different context.\n\nApplyMessageContext --- short-lived context that is reset after each\nlogical replication protocol message is processed.\n\n\nTransient Contexts During Execution\n-----------------------------------\n\nWhen creating a prepared statement, the parse and plan trees will be built\nin a temporary context that's a child of MessageContext (so that it will\ngo away automatically upon error).  On success, the finished plan is\ncopied to the prepared statement's private context, and the temp context\nis released; this allows planner temporary space to be recovered before\nexecution begins.  (In simple-Query mode we don't bother with the extra\ncopy step, so the planner temp space stays around till end of query.)\n\nThe top-level executor routines, as well as most of the \"plan node\"\nexecution code, will normally run in a context that is created by\nExecutorStart and destroyed by ExecutorEnd; this context also holds the\n\"plan state\" tree built during ExecutorStart.  Most of the memory\nallocated in these routines is intended to live until end of query,\nso this is appropriate for those purposes.  The executor's top context\nis a child of PortalContext, that is, the per-portal context of the\nportal that represents the query's execution.\n\nThe main memory-management consideration in the executor is that\nexpression evaluation --- both for qual testing and for computation of\ntargetlist entries --- needs to not leak memory.  To do this, each\nExprContext (expression-eval context) created in the executor has a\nprivate memory context associated with it, and we switch into that context\nwhen evaluating expressions in that ExprContext.  The plan node that owns\nthe ExprContext is responsible for resetting the private context to empty\nwhen it no longer needs the results of expression evaluations.  Typically\nthe reset is done at the start of each tuple-fetch cycle in the plan node.\n\nNote that this design gives each plan node its own expression-eval memory\ncontext.  This appears necessary to handle nested joins properly, since\nan outer plan node might need to retain expression results it has computed\nwhile obtaining the next tuple from an inner node --- but the inner node\nmight execute many tuple cycles and many expressions before returning a\ntuple.  The inner node must be able to reset its own expression context\nmore often than once per outer tuple cycle.  Fortunately, memory contexts\nare cheap enough that giving one to each plan node doesn't seem like a\nproblem.\n\nA problem with running index accesses and sorts in a query-lifespan context\nis that these operations invoke datatype-specific comparison functions,\nand if the comparators leak any memory then that memory won't be recovered\ntill end of query.  The comparator functions all return bool or int32,\nso there's no problem with their result data, but there can be a problem\nwith leakage of internal temporary data.  In particular, comparator\nfunctions that operate on TOAST-able data types need to be careful\nnot to leak detoasted versions of their inputs.  This is annoying, but\nit appeared a lot easier to make the comparators conform than to fix the\nindex and sort routines, so that's what was done for 7.1.  This remains\nthe state of affairs in btree and hash indexes, so btree and hash support\nfunctions still need to not leak memory.  Most of the other index AMs\nhave been modified to run opclass support functions in short-lived\ncontexts, so that leakage is not a problem; this is necessary in view\nof the fact that their support functions tend to be far more complex.\n\nThere are some special cases, such as aggregate functions.  nodeAgg.c\nneeds to remember the results of evaluation of aggregate transition\nfunctions from one tuple cycle to the next, so it can't just discard\nall per-tuple state in each cycle.  The easiest way to handle this seems\nto be to have two per-tuple contexts in an aggregate node, and to\nping-pong between them, so that at each tuple one is the active allocation\ncontext and the other holds any results allocated by the prior cycle's\ntransition function.\n\nExecutor routines that switch the active CurrentMemoryContext may need\nto copy data into their caller's current memory context before returning.\nHowever, we have minimized the need for that, because of the convention\nof resetting the per-tuple context at the *start* of an execution cycle\nrather than at its end.  With that rule, an execution node can return a\ntuple that is palloc'd in its per-tuple context, and the tuple will remain\ngood until the node is called for another tuple or told to end execution.\nThis parallels the situation with pass-by-reference values at the table\nscan level, since a scan node can return a direct pointer to a tuple in a\ndisk buffer that is only guaranteed to remain good that long.\n\nA more common reason for copying data is to transfer a result from\nper-tuple context to per-query context; for example, a Unique node will\nsave the last distinct tuple value in its per-query context, requiring a\ncopy step.\n\n\nMechanisms to Allow Multiple Types of Contexts\n----------------------------------------------\n\nTo efficiently allow for different allocation patterns, and for\nexperimentation, we allow for different types of memory contexts with\ndifferent allocation policies but similar external behavior.  To\nhandle this, memory allocation functions are accessed via function\npointers, and we require all context types to obey the conventions\ngiven here.\n\nA memory context is represented by struct MemoryContextData (see\nmemnodes.h). This struct identifies the exact type of the context, and\ncontains information common between the different types of\nMemoryContext like the parent and child contexts, and the name of the\ncontext.\n\nThis is essentially an abstract superclass, and the behavior is\ndetermined by the \"methods\" pointer which references which set of\nMemoryContextMethods are to be used.  Specific memory context types will\nuse derived structs having these fields as their first fields.  All the\ncontexts of a specific type will have methods pointers that point to\nthe corresponding element in the mcxt_methods[] array as defined in mcxt.c.\n\nWhile operations like allocating from and resetting a context take the\nrelevant MemoryContext as a parameter, operations like free and\nrealloc are trickier.  To make those work, we require all memory\ncontext types to produce allocated chunks that are immediately,\nwithout any padding, preceded by a uint64 value of which the least\nsignificant 4 bits are set to the owning context's MemoryContextMethodID.\nThis allows the code to determine the correct MemoryContextMethods to\nuse by looking up the mcxt_methods[] array using the 4 bits as an index\ninto that array.\n\nIf a type of allocator needs additional information about its chunks,\nlike e.g. the size of the allocation, that information can in turn\neither be encoded into the remaining 60 bits of the preceding uint64 value\nor if more space is required, additional values may be stored directly prior\nto the uint64 value.  It is up to the context implementation to manage this.\n\nGiven this, routines like pfree can determine which set of\nMemoryContextMethods to call the free_p function for by calling\nGetMemoryChunkMethodID() and finding the corresponding MemoryContextMethods\nin the mcxt_methods[] array.  For convenience, the MCXT_METHOD() macro is\nprovided, making the code as simple as:\n\nvoid\npfree(void *pointer)\n{\n\tMCXT_METHOD(pointer, free_p)(pointer);\n}\n\nAll of the current memory contexts make use of the MemoryChunk header type\nwhich is defined in memutils_memorychunk.h.  This suits all of the existing\ncontext types well as it makes use of the remaining 60-bits of the uint64\nheader to efficiently encode the size of the chunk of memory (or freelist\nindex, in the case of aset.c) and the number of bytes which must be subtracted\nfrom the chunk in order to obtain a reference to the block that the chunk\nbelongs to.  30 bits are used for each of these, but only a total of 59 bits\nas the lowest bit for the chunk to block offset is the same bit as the highest\nbit of the chunk size.  This overlapping is possible as the relative offset\nbetween the block and the chunk is expected to be a MAXALIGNed value which\nguarantees the lowest bit is always 0.  If more than 30 bits are required for\neach of these fields then the memory context must manage that itself.  This\ncan be done by calling the MemoryChunkSetHdrMaskExternal() function on the\ngiven chunk.  Whether a chunk is an external chunk can be determined by the 1\nremaining bit from the 64-bit MemoryChunk.\n\nCurrently, each memory context type stores large allocations on dedicated\nblocks (which always contain only a single chunk).  For these, finding the\nblock is simple as we know that the chunk must be the first on the given\nblock, so the block is always at a fixed offset to the chunk.  For these,\nfinding the size of the chunk is also simple as the block always stores an\nendptr which we can use to calculate the size of the chunk.\n\nMore Control Over aset.c Behavior\n---------------------------------\n\nBy default aset.c always allocates an 8K block upon the first\nallocation in a context, and doubles that size for each successive\nblock request.  That's good behavior for a context that might hold\n*lots* of data.  But if there are dozens if not hundreds of smaller\ncontexts in the system, we need to be able to fine-tune things a\nlittle better.\n\nThe creator of a context is able to specify an initial block size and\na maximum block size.  Selecting smaller values can prevent wastage of\nspace in contexts that aren't expected to hold very much (an example\nis the relcache's per-relation contexts).\n\nAlso, it is possible to specify a minimum context size, in case for some\nreason that should be different from the initial size for additional\nblocks.  An aset.c context will always contain at least one block,\nof size minContextSize if that is specified, otherwise initBlockSize.\n\nWe expect that per-tuple contexts will be reset frequently and typically\nwill not allocate very much space per tuple cycle.  To make this usage\npattern cheap, the first block allocated in a context is not given\nback to malloc() during reset, but just cleared.  This avoids malloc\nthrashing.\n\n\nAlternative Memory Context Implementations\n------------------------------------------\n\naset.c (AllocSetContext) is our default general-purpose allocator.  Three other\nallocator types also exist which are special-purpose:\n\n* slab.c (SlabContext) is designed for allocations of fixed-sized\n  chunks.  The fixed chunk size must be specified when creating the context.\n  New chunks are allocated to the fullest block, keeping used chunks densely\n  packed together to avoid memory fragmentation.  This also increases the\n  chances that pfree'ing a chunk will result in a block becoming empty of all\n  chunks and allow it to be free'd back to the operating system.\n\n* generation.c (GenerationContext) is best suited for cases when chunks are\n  allocated in groups with similar lifespan (generations), or roughly in FIFO\n  order.  No attempt is made to reuse space left by pfree'd chunks.  Blocks\n  are returned to the operating system when all chunks on them have been\n  pfree'd.\n\n* bump.c (BumpContext) is best suited for use cases that require densely\n  allocated chunks of memory that never need to be individually pfree'd or\n  repalloc'd.  These operations are unsupported due to BumpContext chunks\n  having no chunk header.  No chunk header means more densely packed chunks,\n  which is especially useful for workloads that perform lots of small\n  allocations.  Blocks are only free'd back to the operating system when the\n  context is reset or deleted.\n\nFor further details, please read the header comment in the corresponding .c\nfile.\n\nMemory Accounting\n-----------------\n\nOne of the basic memory context operations is determining the amount of\nmemory used in the context (and its children). We have multiple places\nthat implement their own ad hoc memory accounting, and this is meant to\nprovide a unified approach. Ad hoc accounting solutions work for places\nwith tight control over the allocations or when it's easy to determine\nsizes of allocated chunks (e.g. places that only work with tuples).\n\nThe accounting built into the memory contexts is transparent and works\ntransparently for all allocations as long as they end up in the right\nmemory context subtree.\n\nConsider for example aggregate functions - the aggregate state is often\nrepresented by an arbitrary structure, allocated from the transition\nfunction, so the ad hoc accounting is unlikely to work. The built-in\naccounting will however handle such cases just fine.\n\nTo minimize overhead, the accounting is done at the block level, not for\nindividual allocation chunks.\n\nThe accounting is lazy - after a block is allocated (or freed), only the\ncontext owning that block is updated. This means that when inquiring\nabout the memory usage in a given context, we have to walk all children\ncontexts recursively. This means the memory accounting is not intended\nfor cases with too many memory contexts (in the relevant subtree).","count":50},{"name":"subsystem-name","value":"brin","count":50},{"name":"subsystem-name","value":"hash","count":50},{"name":"subsystem-name","value":"mmgr","count":50},{"name":"subsystem-path","value":"backend/access/brin/readme","count":50},{"name":"subsystem-path","value":"backend/access/hash/readme","count":50},{"name":"subsystem-path","value":"backend/utils/mmgr/readme","count":50},{"name":"api-example","value":"CopyFromState BeginCopyFrom(ParseState *pstate, Relation rel, Node *whereClause, const char *filename, bool is_program, copy_data_source_cb data_source_cb, List *attnamelist, List *options) { CopyFrom...","count":48},{"name":"api-example","value":"bbsink * bbsink_server_new(bbsink *next, char *pathname) { bbsink_server *sink = palloc0(sizeof(bbsink_server)); *((const bbsink_ops **) &sink->base.bbs_ops) = &bbsink_server_ops; sink->pathname = pat...","count":48},{"name":"api-example","value":"bool check_recovery_target_time(char **newval, void **extra, GucSource source) { if (strcmp(*newval, \"\") != 0) { if (strcmp(*newval, \"now\") == 0 || strcmp(*newval, \"today\") == 0 || strcmp(*newval, \"to...","count":48},{"name":"api-example","value":"static AclMode restrict_and_check_grant(bool is_grant, AclMode avail_goptions, bool all_privs, AclMode privileges, Oid objectId, Oid grantorId, ObjectType objtype, const char *objname, AttrNumber att_...","count":48},{"name":"api-example","value":"static bool TriggerEnabled(EState *estate, ResultRelInfo *relinfo, Trigger *trigger, TriggerEvent event, Bitmapset *modifiedCols, TupleTableSlot *oldslot, TupleTableSlot *newslot) { if (SessionReplica...","count":48},{"name":"api-example","value":"static void WriteControlFile(void) { int\t\t\tfd; char\t\tbuffer[PG_CONTROL_FILE_SIZE];\t/* need not be aligned */ * Initialize version and compatibility-check fields */ ControlFile->pg_control_version = PG...","count":48},{"name":"api-example","value":"void heap_prepare_pagescan(TableScanDesc sscan) { HeapScanDesc scan = (HeapScanDesc) sscan; Buffer\t\tbuffer = scan->rs_cbuf; BlockNumber block = scan->rs_cblock; Snapshot\tsnapshot; Page\t\tpage; int\t\t\tli...","count":48},{"name":"api-example","value":"void mask_lp_flags(Page page) { OffsetNumber offnum, maxoff; maxoff = PageGetMaxOffsetNumber(page); for (offnum = FirstOffsetNumber; offnum <= maxoff; offnum = OffsetNumberNext(offnum)) { ItemId\t\titem...","count":48},{"name":"api-typical-usage","value":"Often called from: BeginCopyFrom","count":48},{"name":"api-typical-usage","value":"Often called from: DefineRange","count":48},{"name":"api-typical-usage","value":"Often called from: EncodeInterval","count":48},{"name":"api-typical-usage","value":"Often called from: ExecGrant_Relation","count":48},{"name":"api-typical-usage","value":"Often called from: ExecMergeMatched","count":48},{"name":"api-typical-usage","value":"Often called from: RelationTruncate","count":48},{"name":"api-typical-usage","value":"Often called from: XLogReaderValidatePageHeader","count":48},{"name":"api-typical-usage","value":"Often called from: deconstruct_recurse","count":48},{"name":"api-typical-usage","value":"Often called from: do_to_timestamp","count":48},{"name":"api-typical-usage","value":"Often called from: dt2time","count":48},{"name":"api-typical-usage","value":"Often called from: expanded_record_set_field_internal","count":48},{"name":"api-typical-usage","value":"Often called from: get_control_data","count":48},{"name":"api-typical-usage","value":"Often called from: plpgsql_parse_cwordtype","count":48},{"name":"api-typical-usage","value":"Often called from: pqTraceOutputMessage","count":48},{"name":"api-typical-usage","value":"Often called from: readtup_cluster","count":48},{"name":"api-typical-usage","value":"Often called from: spg_box_quad_leaf_consistent","count":48},{"name":"api-typical-usage","value":"Often called from: transformRuleStmt","count":48},{"name":"api-typical-usage","value":"Often called from: tsquery_rewrite","count":48},{"name":"cyclomatic-complexity","value":"61","count":48},{"name":"cyclomatic-complexity","value":"70","count":48},{"name":"cyclomatic-complexity","value":"76","count":48},{"name":"cyclomatic-complexity","value":"83","count":48},{"name":"cyclomatic-complexity","value":"84","count":48},{"name":"lines-of-code","value":"169","count":48},{"name":"lines-of-code","value":"173","count":48},{"name":"lines-of-code","value":"176","count":48},{"name":"lines-of-code","value":"177","count":48},{"name":"lines-of-code","value":"179","count":48},{"name":"lines-of-code","value":"191","count":48},{"name":"lines-of-code","value":"194","count":48},{"name":"lines-of-code","value":"196","count":48},{"name":"lines-of-code","value":"200","count":48},{"name":"lines-of-code","value":"206","count":48},{"name":"lines-of-code","value":"208","count":48},{"name":"lines-of-code","value":"209","count":48},{"name":"lines-of-code","value":"215","count":48},{"name":"tested-by","value":"check_control_files","count":48},{"name":"tested-by","value":"check_memoizable, check_memoizable","count":48},{"name":"arch-layer","value":"catalog","count":47},{"name":"arch-layer-description","value":"System catalog and metadata cache","count":47},{"name":"arch-sublayer","value":"commands","count":47},{"name":"api-example","value":"Oid GetNewObjectId(void) { Oid\t\t\tresult; if (RecoveryInProgress()) elog(ERROR, \"cannot assign OIDs during recovery\"); LWLockAcquire(OidGenLock, LW_EXCLUSIVE); * Check for wraparound of the OID counter...","count":45},{"name":"api-example","value":"Relation relation_openrv(const RangeVar *relation, LOCKMODE lockmode) { Oid\t\t\trelOid; * Check for shared-cache-inval messages before trying to open the * relation.  This is needed even if we already h...","count":45},{"name":"api-example","value":"const char * get_config_unit_name(int flags) { switch (flags & GUC_UNIT) { case 0: return NULL;\t\t/* GUC has no units */ case GUC_UNIT_BYTE: return \"B\"; case GUC_UNIT_KB: return \"kB\"; case GUC_UNIT_MB:...","count":45},{"name":"api-example","value":"static int64 sendDir(bbsink *sink, const char *path, int basepathlen, bool sizeonly, List *tablespaces, bool sendtblspclinks, backup_manifest_info *manifest, Oid spcoid, IncrementalBackupInfo *ib) { D...","count":45},{"name":"api-example","value":"static void perform_base_backup(basebackup_options *opt, bbsink *sink, IncrementalBackupInfo *ib) { bbsink_state state; XLogRecPtr\tendptr; TimeLineID\tendtli; backup_manifest_info manifest; BackupState...","count":45},{"name":"api-example","value":"uint64 CopyFrom(CopyFromState cstate) { ResultRelInfo *resultRelInfo; ResultRelInfo *target_resultRelInfo; ResultRelInfo *prevResultRelInfo = NULL; EState\t   *estate = CreateExecutorState(); /* for Ex...","count":45},{"name":"api-example","value":"void BootstrapModeMain(int argc, char *argv[], bool check_only) { int\t\t\ti; char\t   *progname = argv[0]; int\t\t\tflag; char\t   *userDoption = NULL; Assert(!IsUnderPostmaster); InitStandaloneProcess(argv[...","count":45},{"name":"api-example","value":"void index_concurrently_swap(Oid newIndexId, Oid oldIndexId, const char *oldName) { Relation\tpg_class, pg_index, pg_constraint, pg_trigger; Relation\toldClassRel, newClassRel; HeapTuple\toldClassTuple, ...","count":45},{"name":"arch-layer-depth","value":"2","count":45},{"name":"subsystem-desc","value":"src/backend/storage/lmgr/README\n\nLocking Overview\n================\n\nPostgres uses four types of interprocess locks:\n\n* Spinlocks.  These are intended for *very* short-term locks.  If a lock\nis to be held more than a few dozen instructions, or across any sort of\nkernel call (or even a call to a nontrivial subroutine), don't use a\nspinlock. Spinlocks are primarily used as infrastructure for lightweight\nlocks. They are implemented using a hardware atomic-test-and-set\ninstruction, if available.  Waiting processes busy-loop until they can\nget the lock. There is no provision for deadlock detection, automatic\nrelease on error, or any other nicety.  There is a timeout if the lock\ncannot be gotten after a minute or so (which is approximately forever in\ncomparison to the intended lock hold time, so this is certainly an error\ncondition).\n\n* Lightweight locks (LWLocks).  These locks are typically used to\ninterlock access to datastructures in shared memory.  LWLocks support\nboth exclusive and shared lock modes (for read/write and read-only\naccess to a shared object). There is no provision for deadlock\ndetection, but the LWLock manager will automatically release held\nLWLocks during elog() recovery, so it is safe to raise an error while\nholding LWLocks.  Obtaining or releasing an LWLock is quite fast (a few\ndozen instructions) when there is no contention for the lock.  When a\nprocess has to wait for an LWLock, it blocks on a SysV semaphore so as\nto not consume CPU time.  Waiting processes will be granted the lock in\narrival order.  There is no timeout.\n\n* Regular locks (a/k/a heavyweight locks).  The regular lock manager\nsupports a variety of lock modes with table-driven semantics, and it has\nfull deadlock detection and automatic release at transaction end.\nRegular locks should be used for all user-driven lock requests.\n\n* SIReadLock predicate locks.  See separate README-SSI file for details.\n\nAcquisition of either a spinlock or a lightweight lock causes query\ncancel and die() interrupts to be held off until all such locks are\nreleased. No such restriction exists for regular locks, however.  Also\nnote that we can accept query cancel and die() interrupts while waiting\nfor a regular lock, but we will not accept them while waiting for\nspinlocks or LW locks. It is therefore not a good idea to use LW locks\nwhen the wait time might exceed a few seconds.\n\nThe rest of this README file discusses the regular lock manager in detail.\n\n\nLock Data Structures\n--------------------\n\nLock methods describe the overall locking behavior.  Currently there are\ntwo lock methods: DEFAULT and USER.\n\nLock modes describe the type of the lock (read/write or shared/exclusive).\nIn principle, each lock method can have its own set of lock modes with\ndifferent conflict rules, but currently DEFAULT and USER methods use\nidentical lock mode sets. See src/include/storage/lock.h for more details.\n(Lock modes are also called lock types in some places in the code and\ndocumentation.)\n\nThere are two main methods for recording locks in shared memory.  The primary\nmechanism uses two main structures: the per-lockable-object LOCK struct, and\nthe per-lock-and-requestor PROCLOCK struct.  A LOCK object exists for each\nlockable object that currently has locks held or requested on it.  A PROCLOCK\nstruct exists for each backend that is holding or requesting lock(s) on each\nLOCK object.\n\nThere is also a special \"fast path\" mechanism which backends may use to\nrecord a limited number of locks with very specific characteristics: they must\nuse the DEFAULT lockmethod; they must represent a lock on a database relation\n(not a shared relation), they must be a \"weak\" lock which is unlikely to\nconflict (AccessShareLock, RowShareLock, or RowExclusiveLock); and the system\nmust be able to quickly verify that no conflicting locks could possibly be\npresent.  See \"Fast Path Locking\", below, for more details.\n\nEach backend also maintains an unshared LOCALLOCK structure for each lockable\nobject and lock mode that it is currently holding or requesting.  The shared\nlock structures only allow a single lock grant to be made per lockable\nobject/lock mode/backend.  Internally to a backend, however, the same lock may\nbe requested and perhaps released multiple times in a transaction, and it can\nalso be held both transactionally and session-wide.  The internal request\ncounts are held in LOCALLOCK so that the shared data structures need not be\naccessed to alter them.\n\n---------------------------------------------------------------------------\n\nThe lock manager's LOCK objects contain:\n\ntag -\n    The key fields that are used for hashing locks in the shared memory\n    lock hash table.  The contents of the tag essentially define an\n    individual lockable object.  See include/storage/lock.h for details\n    about the supported types of lockable objects.  This is declared as\n    a separate struct to ensure that we always zero out the correct number\n    of bytes.  It is critical that any alignment-padding bytes the compiler\n    might insert in the struct be zeroed out, else the hash computation\n    will be random.  (Currently, we are careful to define struct LOCKTAG\n    so that there are no padding bytes.)\n\ngrantMask -\n    This bitmask indicates what types of locks are currently held on the\n    given lockable object.  It is used (against the lock table's conflict\n    table) to determine if a new lock request will conflict with existing\n    lock types held.  Conflicts are determined by bitwise AND operations\n    between the grantMask and the conflict table entry for the requested\n    lock type.  Bit i of grantMask is 1 if and only if granted[i] > 0.\n\nwaitMask -\n    This bitmask shows the types of locks being waited for.  Bit i of waitMask\n    is 1 if and only if requested[i] > granted[i].\n\nprocLocks -\n    This is a shared memory queue of all the PROCLOCK structs associated with\n    the lock object.  Note that both granted and waiting PROCLOCKs are in this\n    list (indeed, the same PROCLOCK might have some already-granted locks and\n    be waiting for more!).\n\nwaitProcs -\n    This is a shared memory queue of all PGPROC structures corresponding to\n    backends that are waiting (sleeping) until another backend releases this\n    lock.  The process structure holds the information needed to determine\n    if it should be woken up when the lock is released.\n\nnRequested -\n    Keeps a count of how many times this lock has been attempted to be\n    acquired.  The count includes attempts by processes which were put\n    to sleep due to conflicts.  It also counts the same backend twice\n    if, for example, a backend process first acquires a read and then\n    acquires a write.  (But multiple acquisitions of the same lock/lock mode\n    within a backend are not multiply counted here; they are recorded\n    only in the backend's LOCALLOCK structure.)\n\nrequested -\n    Keeps a count of how many locks of each type have been attempted.  Only\n    elements 1 through MAX_LOCKMODES-1 are used as they correspond to the lock\n    type defined constants.  Summing the values of requested[] should come out\n    equal to nRequested.\n\nnGranted -\n    Keeps count of how many times this lock has been successfully acquired.\n    This count does not include attempts that are waiting due to conflicts.\n    Otherwise the counting rules are the same as for nRequested.\n\ngranted -\n    Keeps count of how many locks of each type are currently held.  Once again\n    only elements 1 through MAX_LOCKMODES-1 are used (0 is not).  Also, like\n    requested[], summing the values of granted[] should total to the value\n    of nGranted.\n\nWe should always have 0 <= nGranted <= nRequested, and\n0 <= granted[i] <= requested[i] for each i.  When all the request counts\ngo to zero, the LOCK object is no longer needed and can be freed.\n\n---------------------------------------------------------------------------\n\nThe lock manager's PROCLOCK objects contain:\n\ntag -\n    The key fields that are used for hashing entries in the shared memory\n    PROCLOCK hash table.  This is declared as a separate struct to ensure that\n    we always zero out the correct number of bytes.  It is critical that any\n    alignment-padding bytes the compiler might insert in the struct be zeroed\n    out, else the hash computation will be random.  (Currently, we are careful\n    to define struct PROCLOCKTAG so that there are no padding bytes.)\n\n    tag.myLock\n        Pointer to the shared LOCK object this PROCLOCK is for.\n\n    tag.myProc\n        Pointer to the PGPROC of backend process that owns this PROCLOCK.\n\n    Note: it's OK to use pointers here because a PROCLOCK never outlives\n    either its lock or its proc.  The tag is therefore unique for as long\n    as it needs to be, even though the same tag values might mean something\n    else at other times.\n\nholdMask -\n    A bitmask for the lock modes successfully acquired by this PROCLOCK.\n    This should be a subset of the LOCK object's grantMask, and also a\n    subset of the PGPROC object's heldLocks mask (if the PGPROC is\n    currently waiting for another lock mode on this lock).\n\nreleaseMask -\n    A bitmask for the lock modes due to be released during LockReleaseAll.\n    This must be a subset of the holdMask.  Note that it is modified without\n    taking the partition LWLock, and therefore it is unsafe for any\n    backend except the one owning the PROCLOCK to examine/change it.\n\nlockLink -\n    List link for shared memory queue of all the PROCLOCK objects for the\n    same LOCK.\n\nprocLink -\n    List link for shared memory queue of all the PROCLOCK objects for the\n    same backend.\n\n---------------------------------------------------------------------------\n\n\nLock Manager Internal Locking\n-----------------------------\n\nBefore PostgreSQL 8.2, all of the shared-memory data structures used by\nthe lock manager were protected by a single LWLock, the LockMgrLock;\nany operation involving these data structures had to exclusively lock\nLockMgrLock.  Not too surprisingly, this became a contention bottleneck.\nTo reduce contention, the lock manager's data structures have been split\ninto multiple \"partitions\", each protected by an independent LWLock.\nMost operations only need to lock the single partition they are working in.\nHere are the details:\n\n* Each possible lock is assigned to one partition according to a hash of\nits LOCKTAG value.  The partition's LWLock is considered to protect all the\nLOCK objects of that partition as well as their subsidiary PROCLOCKs.\n\n* The shared-memory hash tables for LOCKs and PROCLOCKs are organized\nso that different partitions use different hash chains, and thus there\nis no conflict in working with objects in different partitions.  This\nis supported directly by dynahash.c's \"partitioned table\" mechanism\nfor the LOCK table: we need only ensure that the partition number is\ntaken from the low-order bits of the dynahash hash value for the LOCKTAG.\nTo make it work for PROCLOCKs, we have to ensure that a PROCLOCK's hash\nvalue has the same low-order bits as its associated LOCK.  This requires\na specialized hash function (see proclock_hash).\n\n* Formerly, each PGPROC had a single list of PROCLOCKs belonging to it.\nThis has now been split into per-partition lists, so that access to a\nparticular PROCLOCK list can be protected by the associated partition's\nLWLock.  (This rule allows one backend to manipulate another backend's\nPROCLOCK lists, which was not originally necessary but is now required in\nconnection with fast-path locking; see below.)\n\n* The other lock-related fields of a PGPROC are only interesting when\nthe PGPROC is waiting for a lock, so we consider that they are protected\nby the partition LWLock of the awaited lock.\n\nFor normal lock acquisition and release, it is sufficient to lock the\npartition containing the desired lock.  Deadlock checking needs to touch\nmultiple partitions in general; for simplicity, we just make it lock all\nthe partitions in partition-number order.  (To prevent LWLock deadlock,\nwe establish the rule that any backend needing to lock more than one\npartition at once must lock them in partition-number order.)  It's\npossible that deadlock checking could be done without touching every\npartition in typical cases, but since in a properly functioning system\ndeadlock checking should not occur often enough to be performance-critical,\ntrying to make this work does not seem a productive use of effort.\n\nA backend's internal LOCALLOCK hash table is not partitioned.  We do store\na copy of the locktag hash code in LOCALLOCK table entries, from which the\npartition number can be computed, but this is a straight speed-for-space\ntradeoff: we could instead recalculate the partition number from the LOCKTAG\nwhen needed.\n\n\nFast Path Locking\n-----------------\n\nFast path locking is a special purpose mechanism designed to reduce the\noverhead of taking and releasing certain types of locks which are taken\nand released very frequently but rarely conflict.  Currently, this includes\ntwo categories of locks:\n\n(1) Weak relation locks.  SELECT, INSERT, UPDATE, and DELETE must acquire a\nlock on every relation they operate on, as well as various system catalogs\nthat can be used internally.  Many DML operations can proceed in parallel\nagainst the same table at the same time; only DDL operations such as\nCLUSTER, ALTER TABLE, or DROP -- or explicit user action such as LOCK TABLE\n-- will create lock conflicts with the \"weak\" locks (AccessShareLock,\nRowShareLock, RowExclusiveLock) acquired by DML operations.\n\n(2) VXID locks.  Every transaction takes a lock on its own virtual\ntransaction ID.  Currently, the only operations that wait for these locks\nare CREATE INDEX CONCURRENTLY and Hot Standby (in the case of a conflict),\nso most VXID locks are taken and released by the owner without anyone else\nneeding to care.\n\nThe primary locking mechanism does not cope well with this workload.  Even\nthough the lock manager locks are partitioned, the locktag for any given\nrelation still falls in one, and only one, partition.  Thus, if many short\nqueries are accessing the same relation, the lock manager partition lock for\nthat partition becomes a contention bottleneck.  This effect is measurable\neven on 2-core servers, and becomes very pronounced as core count increases.\n\nTo alleviate this bottleneck, beginning in PostgreSQL 9.2, each backend is\npermitted to record a limited number of locks on unshared relations in an\narray within its PGPROC structure, rather than using the primary lock table.\nThis mechanism can only be used when the locker can verify that no conflicting\nlocks exist at the time of taking the lock.\n\nA key point of this algorithm is that it must be possible to verify the\nabsence of possibly conflicting locks without fighting over a shared LWLock or\nspinlock.  Otherwise, this effort would simply move the contention bottleneck\nfrom one place to another.  We accomplish this using an array of 1024 integer\ncounters, which are in effect a 1024-way partitioning of the lock space.\nEach counter records the number of \"strong\" locks (that is, ShareLock,\nShareRowExclusiveLock, ExclusiveLock, and AccessExclusiveLock) on unshared\nrelations that fall into that partition.  When this counter is non-zero, the\nfast path mechanism may not be used to take new relation locks within that\npartition.  A strong locker bumps the counter and then scans each per-backend\narray for matching fast-path locks; any which are found must be transferred to\nthe primary lock table before attempting to acquire the lock, to ensure proper\nlock conflict and deadlock detection.\n\nOn an SMP system, we must guarantee proper memory synchronization.  Here we\nrely on the fact that LWLock acquisition acts as a memory sequence point: if\nA performs a store, A and B both acquire an LWLock in either order, and B\nthen performs a load on the same memory location, it is guaranteed to see\nA's store.  In this case, each backend's fast-path lock queue is protected\nby an LWLock.  A backend wishing to acquire a fast-path lock grabs this\nLWLock before examining FastPathStrongRelationLocks to check for the presence\nof a conflicting strong lock.  And the backend attempting to acquire a strong\nlock, because it must transfer any matching weak locks taken via the fast-path\nmechanism to the shared lock table, will acquire every LWLock protecting a\nbackend fast-path queue in turn.  So, if we examine\nFastPathStrongRelationLocks and see a zero, then either the value is truly\nzero, or if it is a stale value, the strong locker has yet to acquire the\nper-backend LWLock we now hold (or, indeed, even the first per-backend LWLock)\nand will notice any weak lock we take when it does.\n\nFast-path VXID locks do not use the FastPathStrongRelationLocks table.  The\nfirst lock taken on a VXID is always the ExclusiveLock taken by its owner.\nAny subsequent lockers are share lockers waiting for the VXID to terminate.\nIndeed, the only reason VXID locks use the lock manager at all (rather than\nwaiting for the VXID to terminate via some other method) is for deadlock\ndetection.  Thus, the initial VXID lock can *always* be taken via the fast\npath without checking for conflicts.  Any subsequent locker must check\nwhether the lock has been transferred to the main lock table, and if not,\ndo so.  The backend owning the VXID must be careful to clean up any entry\nmade in the main lock table at end of transaction.\n\nDeadlock detection does not need to examine the fast-path data structures,\nbecause any lock that could possibly be involved in a deadlock must have\nbeen transferred to the main tables beforehand.\n\n\nThe Deadlock Detection Algorithm\n--------------------------------\n\nSince we allow user transactions to request locks in any order, deadlock\nis possible.  We use a deadlock detection/breaking algorithm that is\nfairly standard in essence, but there are many special considerations\nneeded to deal with Postgres' generalized locking model.\n\nA key design consideration is that we want to make routine operations\n(lock grant and release) run quickly when there is no deadlock, and\navoid the overhead of deadlock handling as much as possible.  We do this\nusing an \"optimistic waiting\" approach: if a process cannot acquire the\nlock it wants immediately, it goes to sleep without any deadlock check.\nBut it also sets a delay timer, with a delay of DeadlockTimeout\nmilliseconds (typically set to one second).  If the delay expires before\nthe process is granted the lock it wants, it runs the deadlock\ndetection/breaking code. Normally this code will determine that there is\nno deadlock condition, and then the process will go back to sleep and\nwait quietly until it is granted the lock.  But if a deadlock condition\ndoes exist, it will be resolved, usually by aborting the detecting\nprocess' transaction.  In this way, we avoid deadlock handling overhead\nwhenever the wait time for a lock is less than DeadlockTimeout, while\nnot imposing an unreasonable delay of detection when there is an error.\n\nLock acquisition (routines LockAcquire and ProcSleep) follows these rules:\n\n1. A lock request is granted immediately if it does not conflict with\nany existing or waiting lock request, or if the process already holds an\ninstance of the same lock type (eg, there's no penalty to acquire a read\nlock twice).  Note that a process never conflicts with itself, eg one\ncan obtain read lock when one already holds exclusive lock.\n\n2. Otherwise the process joins the lock's wait queue.  Normally it will\nbe added to the end of the queue, but there is an exception: if the\nprocess already holds locks on this same lockable object that conflict\nwith the request of any pending waiter, then the process will be\ninserted in the wait queue just ahead of the first such waiter.  (If we\ndid not make this check, the deadlock detection code would adjust the\nqueue order to resolve the conflict, but it's relatively cheap to make\nthe check in ProcSleep and avoid a deadlock timeout delay in this case.)\nNote special case when inserting before the end of the queue: if the\nprocess's request does not conflict with any existing lock nor any\nwaiting request before its insertion point, then go ahead and grant the\nlock without waiting.\n\nWhen a lock is released, the lock release routine (ProcLockWakeup) scans\nthe lock object's wait queue.  Each waiter is awoken if (a) its request\ndoes not conflict with already-granted locks, and (b) its request does\nnot conflict with the requests of prior un-wakable waiters.  Rule (b)\nensures that conflicting requests are granted in order of arrival. There\nare cases where a later waiter must be allowed to go in front of\nconflicting earlier waiters to avoid deadlock, but it is not\nProcLockWakeup's responsibility to recognize these cases; instead, the\ndeadlock detection code will re-order the wait queue when necessary.\n\nTo perform deadlock checking, we use the standard method of viewing the\nvarious processes as nodes in a directed graph (the waits-for graph or\nWFG).  There is a graph edge leading from process A to process B if A\nwaits for B, ie, A is waiting for some lock and B holds a conflicting\nlock.  There is a deadlock condition if and only if the WFG contains a\ncycle.  We detect cycles by searching outward along waits-for edges to\nsee if we return to our starting point.  There are three possible\noutcomes:\n\n1. All outgoing paths terminate at a running process (which has no\noutgoing edge).\n\n2. A deadlock is detected by looping back to the start point.  We\nresolve such a deadlock by canceling the start point's lock request and\nreporting an error in that transaction, which normally leads to\ntransaction abort and release of that transaction's held locks.  Note\nthat it's sufficient to cancel one request to remove the cycle; we don't\nneed to kill all the transactions involved.\n\n3. Some path(s) loop back to a node other than the start point.  This\nindicates a deadlock, but one that does not involve our starting\nprocess. We ignore this condition on the grounds that resolving such a\ndeadlock is the responsibility of the processes involved --- killing our\nstart-point process would not resolve the deadlock.  So, cases 1 and 3\nboth report \"no deadlock\".\n\nPostgres' situation is a little more complex than the standard discussion\nof deadlock detection, for two reasons:\n\n1. A process can be waiting for more than one other process, since there\nmight be multiple PROCLOCKs of (non-conflicting) lock types that all\nconflict with the waiter's request.  This creates no real difficulty\nhowever; we simply need to be prepared to trace more than one outgoing\nedge.\n\n2. If a process A is behind a process B in some lock's wait queue, and\ntheir requested locks conflict, then we must say that A waits for B, since\nProcLockWakeup will never awaken A before B.  This creates additional\nedges in the WFG.  We call these \"soft\" edges, as opposed to the \"hard\"\nedges induced by locks already held.  Note that if B already holds any\nlocks conflicting with A's request, then their relationship is a hard edge\nnot a soft edge.\n\nA \"soft\" block, or wait-priority block, has the same potential for\ninducing deadlock as a hard block.  However, we may be able to resolve\na soft block without aborting the transactions involved: we can instead\nrearrange the order of the wait queue.  This rearrangement reverses the\ndirection of the soft edge between two processes with conflicting requests\nwhose queue order is reversed.  If we can find a rearrangement that\neliminates a cycle without creating new ones, then we can avoid an abort.\nChecking for such possible rearrangements is the trickiest part of the\nalgorithm.\n\nThe workhorse of the deadlock detector is a routine FindLockCycle() which\nis given a starting point process (which must be a waiting process).\nIt recursively scans outward across waits-for edges as discussed above.\nIf it finds no cycle involving the start point, it returns \"false\".\n(As discussed above, we can ignore cycles not involving the start point.)\nWhen such a cycle is found, FindLockCycle() returns \"true\", and as it\nunwinds it also builds a list of any \"soft\" edges involved in the cycle.\nIf the resulting list is empty then there is a hard deadlock and the\nconfiguration cannot succeed.  However, if the list is not empty, then\nreversing any one of the listed edges through wait-queue rearrangement\nwill eliminate that cycle.  Since such a reversal might create cycles\nelsewhere, we may need to try every possibility.  Therefore, we need to\nbe able to invoke FindLockCycle() on hypothetical configurations (wait\norders) as well as the current real order.\n\nThe easiest way to handle this seems to be to have a lookaside table that\nshows the proposed new queue order for each wait queue that we are\nconsidering rearranging.  This table is checked by FindLockCycle, and it\nbelieves the proposed queue order rather than the real order for each lock\nthat has an entry in the lookaside table.\n\nWe build a proposed new queue order by doing a \"topological sort\" of the\nexisting entries.  Each soft edge that we are currently considering\nreversing creates a property of the partial order that the topological sort\nhas to enforce.  We must use a sort method that preserves the input\nordering as much as possible, so as not to gratuitously break arrival\norder for processes not involved in a deadlock.  (This is not true of the\ntsort method shown in Knuth, for example, but it's easily done by a simple\ndoubly-nested-loop method that emits the first legal candidate at each\nstep.  Fortunately, we don't need a highly efficient sort algorithm, since\nthe number of partial order constraints is not likely to be large.)  Note\nthat failure of the topological sort tells us we have conflicting ordering\nconstraints, and therefore that the last-added soft edge reversal\nconflicts with a prior edge reversal.  We need to detect this case to\navoid an infinite loop in the case where no possible rearrangement will\nwork: otherwise, we might try a reversal, find that it still leads to\na cycle, then try to un-reverse the reversal while trying to get rid of\nthat cycle, etc etc.  Topological sort failure tells us the un-reversal\nis not a legitimate move in this context.\n\nSo, the basic step in our rearrangement method is to take a list of\nsoft edges in a cycle (as returned by FindLockCycle()) and successively\ntry the reversal of each one as a topological-sort constraint added to\nwhatever constraints we are already considering.  We recursively search\nthrough all such sets of constraints to see if any one eliminates all\nthe deadlock cycles at once.  Although this might seem impossibly\ninefficient, it shouldn't be a big problem in practice, because there\nwill normally be very few, and not very large, deadlock cycles --- if\nany at all.  So the combinatorial inefficiency isn't going to hurt us.\nBesides, it's better to spend some time to guarantee that we've checked\nall possible escape routes than to abort a transaction when we didn't\nreally have to.\n\nEach edge reversal constraint can be viewed as requesting that the waiting\nprocess A be moved to before the blocking process B in the wait queue they\nare both in.  This action will reverse the desired soft edge, as well as\nany other soft edges between A and other processes it is advanced over.\nNo other edges will be affected (note this is actually a constraint on our\ntopological sort method to not re-order the queue more than necessary.)\nTherefore, we can be sure we have not created any new deadlock cycles if\nneither FindLockCycle(A) nor FindLockCycle(B) discovers any cycle.  Given\nthe above-defined behavior of FindLockCycle, each of these searches is\nnecessary as well as sufficient, since FindLockCycle starting at the\noriginal start point will not complain about cycles that include A or B\nbut not the original start point.\n\nIn short then, a proposed rearrangement of the wait queue(s) is determined\nby one or more broken soft edges A->B, fully specified by the output of\ntopological sorts of each wait queue involved, and then tested by invoking\nFindLockCycle() starting at the original start point as well as each of\nthe mentioned processes (A's and B's).  If none of the tests detect a\ncycle, then we have a valid configuration and can implement it by\nreordering the wait queues per the sort outputs (and then applying\nProcLockWakeup on each reordered queue, in case a waiter has become wakable).\nIf any test detects a soft cycle, we can try to resolve it by adding each\nsoft link in that cycle, in turn, to the proposed rearrangement list.\nThis is repeated recursively until we either find a workable rearrangement\nor determine that none exists.  In the latter case, the outer level\nresolves the deadlock by aborting the original start-point transaction.\n\nThe particular order in which rearrangements are tried depends on the\norder FindLockCycle() happens to scan in, so if there are multiple\nworkable rearrangements of the wait queues, then it is unspecified which\none will be chosen.  What's more important is that we guarantee to try\nevery queue rearrangement that could lead to success.  (For example,\nif we have A before B before C and the needed order constraints are\nC before A and B before C, we would first discover that A before C\ndoesn't work and try the rearrangement C before A before B.  This would\neventually lead to the discovery of the additional constraint B before C.)\n\nGot that?\n\nMiscellaneous Notes\n-------------------\n\n1. It is easily proven that no deadlock will be missed due to our\nasynchronous invocation of deadlock checking.  A deadlock cycle in the WFG\nis formed when the last edge in the cycle is added; therefore the last\nprocess in the cycle to wait (the one from which that edge is outgoing) is\ncertain to detect and resolve the cycle when it later runs CheckDeadLock.\nThis holds even if that edge addition created multiple cycles; the process\nmay indeed abort without ever noticing those additional cycles, but we\ndon't particularly care.  The only other possible creation of deadlocks is\nduring deadlock resolution's rearrangement of wait queues, and we already\nsaw that that algorithm will prove that it creates no new deadlocks before\nit attempts to actually execute any rearrangement.\n\n2. It is not certain that a deadlock will be resolved by aborting the\nlast-to-wait process.  If earlier waiters in the cycle have not yet run\nCheckDeadLock, then the first one to do so will be the victim.\n\n3. No live (wakable) process can be missed by ProcLockWakeup, since it\nexamines every member of the wait queue (this was not true in the 7.0\nimplementation, BTW).  Therefore, if ProcLockWakeup is always invoked\nafter a lock is released or a wait queue is rearranged, there can be no\nfailure to wake a wakable process.  One should also note that\nLockErrorCleanup (abort a waiter due to outside factors) must run\nProcLockWakeup, in case the canceled waiter was soft-blocking other\nwaiters.\n\n4. We can minimize excess rearrangement-trial work by being careful to\nscan the wait queue from the front when looking for soft edges.  For\nexample, if we have queue order A,B,C and C has deadlock conflicts with\nboth A and B, we want to generate the \"C before A\" constraint first,\nrather than wasting time with \"C before B\", which won't move C far\nenough up.  So we look for soft edges outgoing from C starting at the\nfront of the wait queue.\n\n5. The working data structures needed by the deadlock detection code can\nbe limited to numbers of entries computed from MaxBackends.  Therefore,\nwe can allocate the worst-case space needed during backend startup. This\nseems a safer approach than trying to allocate workspace on the fly; we\ndon't want to risk having the deadlock detector run out of memory, else\nwe really have no guarantees at all that deadlock will be detected.\n\n6. We abuse the deadlock detector to implement autovacuum cancellation.\nWhen we run the detector and we find that there's an autovacuum worker\ninvolved in the waits-for graph, we store a pointer to its PGPROC, and\nreturn a special return code (unless a hard deadlock has been detected).\nThe caller can then send a cancellation signal.  This implements the\nprinciple that autovacuum has a low locking priority (eg it must not block\nDDL on the table).\n\nGroup Locking\n-------------\n\nAs if all of that weren't already complicated enough, PostgreSQL now supports\nparallelism (see src/backend/access/transam/README.parallel), which means that\nwe might need to resolve deadlocks that occur between gangs of related\nprocesses rather than individual processes.  This doesn't change the basic\ndeadlock detection algorithm very much, but it makes the bookkeeping more\ncomplicated.\n\nWe choose to regard locks held by processes in the same parallel group as\nnon-conflicting with the exception of relation extension lock.  This means that\ntwo processes in a parallel group can hold a self-exclusive lock on the same\nrelation at the same time, or one process can acquire an AccessShareLock while\nthe other already holds AccessExclusiveLock.  This might seem dangerous and\ncould be in some cases (more on that below), but if we didn't do this then\nparallel query would be extremely prone to self-deadlock.  For example, a\nparallel query against a relation on which the leader already had\nAccessExclusiveLock would hang, because the workers would try to lock the same\nrelation and be blocked by the leader; yet the leader can't finish until it\nreceives completion indications from all workers.  An undetected deadlock\nresults.  This is far from the only scenario where such a problem happens.  The\nsame thing will occur if the leader holds only AccessShareLock, the worker\nseeks AccessShareLock, but between the time the leader attempts to acquire the\nlock and the time the worker attempts to acquire it, some other process queues\nup waiting for an AccessExclusiveLock.  In this case, too, an indefinite hang\nresults.\n\nIt might seem that we could predict which locks the workers will attempt to\nacquire and ensure before going parallel that those locks would be acquired\nsuccessfully.  But this is very difficult to make work in a general way.  For\nexample, a parallel worker's portion of the query plan could involve an\nSQL-callable function which generates a query dynamically, and that query\nmight happen to hit a table on which the leader happens to hold\nAccessExclusiveLock.  By imposing enough restrictions on what workers can do,\nwe could eventually create a situation where their behavior can be adequately\nrestricted, but these restrictions would be fairly onerous, and even then, the\nsystem required to decide whether the workers will succeed at acquiring the\nnecessary locks would be complex and possibly buggy.\n\nSo, instead, we take the approach of deciding that locks within a lock group\ndo not conflict.  This eliminates the possibility of an undetected deadlock,\nbut also opens up some problem cases: if the leader and worker try to do some\noperation at the same time which would ordinarily be prevented by the\nheavyweight lock mechanism, undefined behavior might result.  In practice, the\ndangers are modest.  The leader and worker share the same transaction,\nsnapshot, and combo CID hash, and neither can perform any DDL or, indeed,\nwrite any data at all.  Thus, for either to read a table locked exclusively by\nthe other is safe enough.  Problems would occur if the leader initiated\nparallelism from a point in the code at which it had some backend-private\nstate that made table access from another process unsafe, for example after\ncalling SetReindexProcessing and before calling ResetReindexProcessing,\ncatastrophe could ensue, because the worker won't have that state.  Similarly,\nproblems could occur with certain kinds of non-relation locks, such as\nGIN page locks.  It's no safer for two related processes to perform GIN clean\nup at the same time than for unrelated processes to do the same.\nHowever, since parallel mode is strictly read-only at present, neither this\nnor most of the similar cases can arise at present.  To allow parallel writes,\nwe'll either need to (1) further enhance the deadlock detector to handle those\ntypes of locks in a different way than other types; or (2) have parallel\nworkers use some other mutual exclusion method for such cases.\n\nGroup locking adds three new members to each PGPROC: lockGroupLeader,\nlockGroupMembers, and lockGroupLink. A PGPROC's lockGroupLeader is NULL for\nprocesses not involved in parallel query. When a process wants to cooperate\nwith parallel workers, it becomes a lock group leader, which means setting\nthis field to point to its own PGPROC. When a parallel worker starts up, it\npoints this field at the leader. The lockGroupMembers field is only used in\nthe leader; it is a list of the member PGPROCs of the lock group (the leader\nand all workers). The lockGroupLink field is the list link for this list.\n\nAll three of these fields are considered to be protected by a lock manager\npartition lock.  The partition lock that protects these fields within a given\nlock group is chosen by taking the leader's pgprocno modulo the number of lock\nmanager partitions.  This unusual arrangement has a major advantage: the\ndeadlock detector can count on the fact that no lockGroupLeader field can\nchange while the deadlock detector is running, because it knows that it holds\nall the lock manager locks.  Also, holding this single lock allows safe\nmanipulation of the lockGroupMembers list for the lock group.\n\nWe need an additional interlock when setting these fields, because a newly\nstarted parallel worker has to try to join the leader's lock group, but it\nhas no guarantee that the group leader is still alive by the time it gets\nstarted.  We try to ensure that the parallel leader dies after all workers\nin normal cases, but also that the system could survive relatively intact\nif that somehow fails to happen.  This is one of the precautions against\nsuch a scenario: the leader relays its PGPROC and also its PID to the\nworker, and the worker fails to join the lock group unless the given PGPROC\nstill has the same PID and is still a lock group leader.  We assume that\nPIDs are not recycled quickly enough for this interlock to fail.\n\n\nUser Locks (Advisory Locks)\n---------------------------\n\nUser locks are handled totally on the application side as long term\ncooperative locks which may extend beyond the normal transaction boundaries.\nTheir purpose is to indicate to an application that someone is `working'\non an item.  So it is possible to put a user lock on a tuple's oid,\nretrieve the tuple, work on it for an hour and then update it and remove\nthe lock.  While the lock is active other clients can still read and write\nthe tuple but they can be aware that it has been locked at the application\nlevel by someone.\n\nUser locks and normal locks are completely orthogonal and they don't\ninterfere with each other.\n\nUser locks can be acquired either at session level or transaction level.\nA session-level lock request is not automatically released at transaction\nend, but must be explicitly released by the application.  (However, any\nremaining locks are always released at session end.)  Transaction-level\nuser lock requests behave the same as normal lock requests, in that they\nare released at transaction end and do not need explicit unlocking.\n\nLocking during Hot Standby\n--------------------------\n\nThe Startup process is the only backend that can make changes during\nrecovery, all other backends are read only.  As a result the Startup\nprocess does not acquire locks on relations or objects except when the lock\nlevel is AccessExclusiveLock.\n\nRegular backends are only allowed to take locks on relations or objects\nat RowExclusiveLock or lower. This ensures that they do not conflict with\neach other or with the Startup process, unless AccessExclusiveLocks are\nrequested by the Startup process.\n\nDeadlocks involving AccessExclusiveLocks are not possible, so we need\nnot be concerned that a user initiated deadlock can prevent recovery from\nprogressing.\n\nAccessExclusiveLocks on the primary node generate WAL records\nthat are then applied by the Startup process. Locks are released at end\nof transaction just as they are in normal processing. These locks are\nheld by the Startup process, acting as a proxy for the backends that\noriginally acquired these locks. Again, these locks cannot conflict with\none another, so the Startup process cannot deadlock itself either.\n\nAlthough deadlock is not possible, a regular backend's weak lock can\nprevent the Startup process from making progress in applying WAL, which is\nusually not something that should be tolerated for very long.  Mechanisms\nexist to forcibly cancel a regular backend's query if it blocks the\nStartup process for too long.","count":45},{"name":"subsystem-desc","value":"src/timezone/README\n\nThis is a PostgreSQL adapted version of the IANA timezone library from\n\n\thttps://www.iana.org/time-zones\n\nThe latest version of the timezone data and library source code is\navailable right from that page.  It's best to get the merged file\ntzdb-NNNNX.tar.lz, since the other archive formats omit tzdata.zi.\nHistorical versions, as well as release announcements, can be found\nelsewhere on the site.\n\nSince time zone rules change frequently in some parts of the world,\nwe should endeavor to update the data files before each PostgreSQL\nrelease.  The code need not be updated as often, but we must track\nchanges that might affect interpretation of the data files.\n\n\nTime Zone data\n==============\n\nWe distribute the time zone source data as-is under src/timezone/data/.\nCurrently, we distribute just the abbreviated single-file format\n\"tzdata.zi\", to reduce the size of our tarballs as well as churn\nin our git repo.  Feeding that file to zic produces the same compiled\noutput as feeding the bulkier individual data files would do.\n\nWhile data/tzdata.zi can just be duplicated when updating, manual effort\nis needed to update the time zone abbreviation lists under tznames/.\nThese need to be changed whenever new abbreviations are invented or the\nUTC offset associated with an existing abbreviation changes.  To detect\nif this has happened, after installing new files under data/ do\n\tmake abbrevs.txt\nwhich will produce a file showing all abbreviations that are in current\nuse according to the data/ files.  Compare this to known_abbrevs.txt,\nwhich is the list that existed last time the tznames/ files were updated.\nUpdate tznames/ as seems appropriate, then replace known_abbrevs.txt\nin the same commit.  Usually, if a known abbreviation has changed meaning,\nthe appropriate fix is to make it refer to a long-form zone name instead\nof a fixed GMT offset.\n\nThe core regression test suite does some simple validation of the zone\ndata and abbreviations data (notably by checking that the pg_timezone_names\nand pg_timezone_abbrevs views don't throw errors).  It's worth running it\nas a cross-check on proposed updates.\n\nWhen there has been a new release of Windows (probably including Service\nPacks), findtimezone.c's mapping from Windows zones to IANA zones may\nneed to be updated.  We have two approaches to doing this:\n1. Consult the CLDR project's windowsZones.xml file, and add any zones\n   listed there that we don't have.  Use their \"territory=001\" mapping\n   if there's more than one IANA zone listed.\n2. Run the script in src/tools/win32tzlist.pl on a Windows machine\n   running the new release, and add any new timezones that it detects.\n   (This is not a full substitute for #1, though, as win32tzlist.pl\n   can't tell you which IANA zone to map to.)\nIn either case, never remove any zone names that have disappeared from\nWindows, since we still need to match properly on older versions.\n\n\nTime Zone code\n==============\n\nThe code in this directory is currently synced with tzcode release 2020d.\nThere are many cosmetic (and not so cosmetic) differences from the\noriginal tzcode library, but diffs in the upstream version should usually\nbe propagated to our version.  Here are some notes about that.\n\nFor the most part we want to use the upstream code as-is, but there are\nseveral considerations preventing an exact match:\n\n* For readability/maintainability we reformat the code to match our own\nconventions; this includes pgindent'ing it and getting rid of upstream's\noveruse of \"register\" declarations.  (It used to include conversion of\nold-style function declarations to C89 style, but thank goodness they\nfixed that.)\n\n* We need the code to follow Postgres' portability conventions; this\nincludes relying on configure's results rather than hand-hacked\n#defines (see private.h in particular).\n\n* Similarly, avoid relying on <stdint.h> features that may not exist on old\nsystems.  In particular this means using Postgres' definitions of the int32\nand int64 typedefs, not int_fast32_t/int_fast64_t.  Likewise we use\nPG_INT32_MIN/MAX not INT32_MIN/MAX.  (Once we desupport all PG versions\nthat don't require C99, it'd be practical to rely on <stdint.h> and remove\nthis set of diffs; but that day is not yet.)\n\n* Since Postgres is typically built on a system that has its own copy\nof the <time.h> functions, we must avoid conflicting with those.  This\nmandates renaming typedef time_t to pg_time_t, and similarly for most\nother exposed names.\n\n* zic.c's typedef \"lineno\" is renamed to \"lineno_t\", because having\n\"lineno\" in our typedefs list would cause unfortunate pgindent behavior\nin some other files where we have variables named that.\n\n* We have exposed the tzload() and tzparse() internal functions, and\nslightly modified the API of the former, in part because it now relies\non our own pg_open_tzfile() rather than opening files for itself.\n\n* tzparse() is adjusted to never try to load the TZDEFRULES zone.\n\n* There's a fair amount of code we don't need and have removed,\nincluding all the nonstandard optional APIs.  We have also added\na few functions of our own at the bottom of localtime.c.\n\n* In zic.c, we have added support for a -P (print_abbrevs) switch, which\nis used to create the \"abbrevs.txt\" summary of currently-in-use zone\nabbreviations that was described above.\n\n\nThe most convenient way to compare a new tzcode release to our code is\nto first run the tzcode source files through a sed filter like this:\n\n    sed -r \\\n        -e 's/^([ \\t]*)\\*\\*([ \\t])/\\1 *\\2/' \\\n        -e 's/^([ \\t]*)\\*\\*$/\\1 */' \\\n        -e 's|^\\*/| */|' \\\n        -e 's/\\bregister[ \\t]//g' \\\n        -e 's/\\bATTRIBUTE_PURE[ \\t]//g' \\\n        -e 's/int_fast32_t/int32/g' \\\n        -e 's/int_fast64_t/int64/g' \\\n        -e 's/intmax_t/int64/g' \\\n        -e 's/INT32_MIN/PG_INT32_MIN/g' \\\n        -e 's/INT32_MAX/PG_INT32_MAX/g' \\\n        -e 's/INTMAX_MIN/PG_INT64_MIN/g' \\\n        -e 's/INTMAX_MAX/PG_INT64_MAX/g' \\\n        -e 's/struct[ \\t]+tm\\b/struct pg_tm/g' \\\n        -e 's/\\btime_t\\b/pg_time_t/g' \\\n        -e 's/lineno/lineno_t/g' \\\n\nand then run them through pgindent.  (The first three sed patterns deal\nwith conversion of their block comment style to something pgindent\nwon't make a hash of; the remainder address other points noted above.)\nAfter that, the files can be diff'd directly against our corresponding\nfiles.  Also, it's typically helpful to diff against the previous tzcode\nrelease (after processing that the same way), and then try to apply the\ndiff to our files.  This will take care of most of the changes\nmechanically.","count":45},{"name":"subsystem-name","value":"lmgr","count":45},{"name":"subsystem-name","value":"timezone","count":45},{"name":"subsystem-path","value":"backend/storage/lmgr/readme","count":45},{"name":"subsystem-path","value":"timezone/readme","count":45},{"name":"api-caller-count","value":"211","count":44},{"name":"api-caller-count","value":"92","count":44},{"name":"api-typical-usage","value":"Often called from: CommitTransaction","count":44},{"name":"api-typical-usage","value":"Often called from: CreateStatistics","count":44},{"name":"api-typical-usage","value":"Often called from: CreateSubscription","count":44},{"name":"api-typical-usage","value":"Often called from: InsertPgAttributeTuples","count":44},{"name":"api-typical-usage","value":"Often called from: ProcSleep","count":44},{"name":"api-typical-usage","value":"Often called from: SnapBuildRestore","count":44},{"name":"api-typical-usage","value":"Often called from: WaitForOlderSnapshots","count":44},{"name":"api-typical-usage","value":"Often called from: XidCacheRemoveRunningXids","count":44},{"name":"api-typical-usage","value":"Often called from: _hash_freeovflpage","count":44},{"name":"api-typical-usage","value":"Often called from: _snprintf_s","count":44},{"name":"api-typical-usage","value":"Often called from: _vsnwprintf_s","count":44},{"name":"api-typical-usage","value":"Often called from: all_rows_selectable","count":44},{"name":"api-typical-usage","value":"Often called from: copy_replication_slot","count":44},{"name":"api-typical-usage","value":"Often called from: dumpTableSchema","count":44},{"name":"api-typical-usage","value":"Often called from: exec_stmt_return_query","count":44},{"name":"api-typical-usage","value":"Often called from: fetch_remote_table_info","count":44},{"name":"api-typical-usage","value":"Often called from: float8_regr_accum","count":44},{"name":"api-typical-usage","value":"Often called from: func_select_candidate","count":44},{"name":"api-typical-usage","value":"Often called from: gettoken_tsvector","count":44},{"name":"api-typical-usage","value":"Often called from: gistchoose","count":44},{"name":"api-typical-usage","value":"Often called from: inet_gist_consistent","count":44},{"name":"api-typical-usage","value":"Often called from: log_heap_update","count":44},{"name":"api-typical-usage","value":"Often called from: progress_report","count":44},{"name":"api-typical-usage","value":"Often called from: swprintf_s","count":44},{"name":"api-typical-usage","value":"Often called from: try_partitionwise_join","count":44},{"name":"api-typical-usage","value":"Often called from: update_frametailpos","count":44},{"name":"api-typical-usage","value":"Often called from: writezone","count":44},{"name":"coupling-score","value":"34","count":44},{"name":"coupling-score","value":"37","count":44},{"name":"coupling-score","value":"38","count":44},{"name":"cyclomatic-complexity","value":"69","count":44},{"name":"cyclomatic-complexity","value":"79","count":44},{"name":"cyclomatic-complexity","value":"89","count":44},{"name":"cyclomatic-complexity","value":"92","count":44},{"name":"lines-of-code","value":"182","count":44},{"name":"lines-of-code","value":"183","count":44},{"name":"lines-of-code","value":"221","count":44},{"name":"lines-of-code","value":"245","count":44},{"name":"lines-of-code","value":"262","count":44},{"name":"lines-of-code","value":"264","count":44},{"name":"loop-depth","value":"30","count":44},{"name":"test-count","value":"15","count":44},{"name":"tested-by","value":"_bt_check_natts, check_exclusion_or_unique_constraint, index_recheck_constraint","count":44},{"name":"tested-by","value":"check_application_name, check_cluster_name","count":44},{"name":"tested-by","value":"check_for_freed_segments","count":44},{"name":"tested-by","value":"check_null_keys, _bt_check_compare, _bt_check_rowcompare, check_exclusion_or_unique_constraint, HeapKeyTest","count":44},{"name":"tested-by","value":"check_primary_slot_name, check_application_name, check_cluster_name","count":44},{"name":"tested-by","value":"check_publisher, check_control_files","count":44},{"name":"tested-by","value":"check_recovery_target_name, check_recovery_target_name","count":44},{"name":"tested-by","value":"check_ssl_key_file_permissions","count":44},{"name":"tested-by","value":"heap_truncate_check_FKs, check_default_partition_contents","count":44},{"name":"tested-by","value":"recheck_cast_function_args, recheck_cast_function_args, recheck_cast_function_args, check_generic_type_consistency","count":44},{"name":"api-example","value":"Datum brin_minmax_multi_distance_timetz(PG_FUNCTION_ARGS) { float8\t\tdelta = 0; TimeTzADT  *ta = PG_GETARG_TIMETZADT_P(0); TimeTzADT  *tb = PG_GETARG_TIMETZADT_P(1); delta = (tb->time - ta->time) + (tb...","count":42},{"name":"api-example","value":"GISTSTATE * initGISTstate(Relation index) { GISTSTATE  *giststate; MemoryContext scanCxt; MemoryContext oldCxt; int\t\t\ti; if (index->rd_att->natts > INDEX_MAX_KEYS) elog(ERROR, \"numberOfAttributes %d >...","count":42},{"name":"api-example","value":"Oid heap_create_with_catalog(const char *relname, Oid relnamespace, Oid reltablespace, Oid relid, Oid reltypeid, Oid reloftypeid, Oid ownerid, Oid accessmtd, TupleDesc tupdesc, List *cooked_constraint...","count":42},{"name":"api-example","value":"int DecodeInterval(char **field, int *ftype, int nf, int range, int *dtype, struct pg_itm_in *itm_in) { bool\t\tforce_negative = false; bool\t\tis_before = false; bool\t\tparsing_unit_val = false; char\t   *...","count":42},{"name":"api-example","value":"static bool ginPlaceToPage(GinBtree btree, GinBtreeStack *stack, void *insertdata, BlockNumber updateblkno, Buffer childbuf, GinStatsData *buildStats) { Page\t\tpage = BufferGetPage(stack->buffer); bool...","count":42},{"name":"api-example","value":"static void reportDependentObjects(const ObjectAddresses *targetObjects, DropBehavior behavior, int flags, const ObjectAddress *origObject) { int\t\t\tmsglevel = (flags & PERFORM_DELETION_QUIETLY) ? DEBU...","count":42},{"name":"api-example","value":"static void show_sortorder_options(StringInfo buf, Node *sortexpr, Oid sortOperator, Oid collation, bool nullsFirst) { Oid\t\t\tsortcoltype = exprType(sortexpr); bool\t\treverse = false; TypeCacheEntry *ty...","count":42},{"name":"api-example","value":"void SyncScanShmemInit(void) { int\t\t\ti; bool\t\tfound; scan_locations = (ss_scan_locations_t *) ShmemInitStruct(\"Sync Scan Locations List\", SizeOfScanLocations(SYNC_SCAN_NELEM), &found); if (!IsUnderPos...","count":42},{"name":"api-example","value":"void SysLoggerMain(char *startup_data, size_t startup_data_len) { #ifndef WIN32 char\t\tlogbuffer[READ_BUF_SIZE]; int\t\t\tbytes_in_logbuffer = 0; #endif char\t   *currentLogDir; char\t   *currentLogFilename...","count":42},{"name":"api-example","value":"void compute_semi_anti_join_factors(PlannerInfo *root, RelOptInfo *joinrel, RelOptInfo *outerrel, RelOptInfo *innerrel, JoinType jointype, SpecialJoinInfo *sjinfo, List *restrictlist, SemiAntiJoinFact...","count":42},{"name":"api-example","value":"void restoreTimeLineHistoryFiles(TimeLineID begin, TimeLineID end) { char\t\tpath[MAXPGPATH]; char\t\thistfname[MAXFNAMELEN]; TimeLineID\ttli; for (tli = begin; tli < end; tli++) { if (tli == 1) continue; ...","count":42},{"name":"api-caller-count","value":"149","count":40},{"name":"api-typical-usage","value":"Often called from: AllocSetRealloc","count":40},{"name":"api-typical-usage","value":"Often called from: CreateReplicationSlot","count":40},{"name":"api-typical-usage","value":"Often called from: DecodeISO8601Interval","count":40},{"name":"api-typical-usage","value":"Often called from: ExecSetTupleBound","count":40},{"name":"api-typical-usage","value":"Often called from: HeapTupleSatisfiesMVCC","count":40},{"name":"api-typical-usage","value":"Often called from: InitQueryHashTable","count":40},{"name":"api-typical-usage","value":"Often called from: JsonbHashScalarValueExtended","count":40},{"name":"api-typical-usage","value":"Often called from: PLy_cursor_close","count":40},{"name":"api-typical-usage","value":"Often called from: PerformRadiusTransaction","count":40},{"name":"api-typical-usage","value":"Often called from: PredicateLockingNeededForRelation","count":40},{"name":"api-typical-usage","value":"Often called from: ProcessStartupPacket","count":40},{"name":"api-typical-usage","value":"Often called from: RollbackToSavepoint","count":40},{"name":"api-typical-usage","value":"Often called from: SanityCheckBackgroundWorker","count":40},{"name":"api-typical-usage","value":"Often called from: SetTransactionIdLimit","count":40},{"name":"api-typical-usage","value":"Often called from: array_replace_internal","count":40},{"name":"api-typical-usage","value":"Often called from: asyncQueueUnregister","count":40},{"name":"api-typical-usage","value":"Often called from: btree_desc","count":40},{"name":"api-typical-usage","value":"Often called from: check_simple_rowfilter_expr_walker","count":40},{"name":"api-typical-usage","value":"Often called from: connectDatabase","count":40},{"name":"api-typical-usage","value":"Often called from: ecpg_get_data","count":40},{"name":"api-typical-usage","value":"Often called from: flatten_unplanned_rtes","count":40},{"name":"api-typical-usage","value":"Often called from: getSchemaData","count":40},{"name":"api-typical-usage","value":"Often called from: get_rule_expr","count":40},{"name":"api-typical-usage","value":"Often called from: gtsvector_picksplit","count":40},{"name":"api-typical-usage","value":"Often called from: parse_datetime","count":40},{"name":"api-typical-usage","value":"Often called from: parse_hba_auth_opt","count":40},{"name":"api-typical-usage","value":"Often called from: parse_snapshot","count":40},{"name":"api-typical-usage","value":"Often called from: pg_cryptohash_final","count":40},{"name":"api-typical-usage","value":"Often called from: pg_saslprep","count":40},{"name":"api-typical-usage","value":"Often called from: pgpipe","count":40},{"name":"api-typical-usage","value":"Often called from: pgwin32_dispatch_queued_signals","count":40},{"name":"api-typical-usage","value":"Often called from: pq_parse_errornotice","count":40},{"name":"api-typical-usage","value":"Often called from: range_recv","count":40},{"name":"api-typical-usage","value":"Often called from: set_foreignscan_references","count":40},{"name":"api-typical-usage","value":"Often called from: string_to_privilege","count":40},{"name":"api-typical-usage","value":"Often called from: tbm_prepare_shared_iterate","count":40},{"name":"api-typical-usage","value":"Often called from: window_dense_rank_support","count":40},{"name":"api-typical-usage","value":"Often called from: write_stderr","count":40},{"name":"cyclomatic-complexity","value":"100","count":40},{"name":"cyclomatic-complexity","value":"77","count":40},{"name":"lines-of-code","value":"184","count":40},{"name":"lines-of-code","value":"185","count":40},{"name":"lines-of-code","value":"192","count":40},{"name":"lines-of-code","value":"198","count":40},{"name":"lines-of-code","value":"216","count":40},{"name":"lines-of-code","value":"217","count":40},{"name":"lines-of-code","value":"272","count":40},{"name":"lines-of-code","value":"283","count":40},{"name":"loop-depth","value":"29","count":40},{"name":"loop-depth","value":"32","count":40},{"name":"subsystem-desc","value":"src/backend/optimizer/plan/README\n\nSubselects\n==========\n\nVadim B. Mikheev\n\n\nFrom owner-pgsql-hackers@hub.org Fri Feb 13 09:01:19 1998\nReceived: from renoir.op.net (root@renoir.op.net [209.152.193.4])\n\tby candle.pha.pa.us (8.8.5/8.8.5) with ESMTP id JAA11576\n\tfor <maillist@candle.pha.pa.us>; Fri, 13 Feb 1998 09:01:17 -0500 (EST)\nReceived: from hub.org (hub.org [209.47.148.200]) by renoir.op.net (o1/$Revision: 1.14 $) with ESMTP id IAA09761 for <maillist@candle.pha.pa.us>; Fri, 13 Feb 1998 08:41:22 -0500 (EST)\nReceived: from localhost (majordom@localhost) by hub.org (8.8.8/8.7.5) with SMTP id IAA08135; Fri, 13 Feb 1998 08:40:17 -0500 (EST)\nReceived: by hub.org (TLB v0.10a (1.23 tibbs 1997/01/09 00:29:32)); Fri, 13 Feb 1998 08:38:42 -0500 (EST)\nReceived: (from majordom@localhost) by hub.org (8.8.8/8.7.5) id IAA06646 for pgsql-hackers-outgoing; Fri, 13 Feb 1998 08:38:35 -0500 (EST)\nReceived: from dune.krasnet.ru (dune.krasnet.ru [193.125.44.86]) by hub.org (8.8.8/8.7.5) with ESMTP id IAA04568 for <hackers@postgreSQL.org>; Fri, 13 Feb 1998 08:37:16 -0500 (EST)\nReceived: from sable.krasnoyarsk.su (dune.krasnet.ru [193.125.44.86])\n\tby dune.krasnet.ru (8.8.7/8.8.7) with ESMTP id UAA13717\n\tfor <hackers@postgreSQL.org>; Fri, 13 Feb 1998 20:51:03 +0700 (KRS)\n\t(envelope-from vadim@sable.krasnoyarsk.su)\nMessage-ID: <34E44FBA.D64E7997@sable.krasnoyarsk.su>\nDate: Fri, 13 Feb 1998 20:50:50 +0700\nFrom: \"Vadim B. Mikheev\" <vadim@sable.krasnoyarsk.su>\nOrganization: ITTS (Krasnoyarsk)\nX-Mailer: Mozilla 4.04 [en] (X11; I; FreeBSD 2.2.5-RELEASE i386)\nMIME-Version: 1.0\nTo: PostgreSQL Developers List <hackers@postgreSQL.org>\nSubject: [HACKERS] Subselects are in CVS...\nContent-Type: text/plain; charset=us-ascii\nContent-Transfer-Encoding: 7bit\nSender: owner-pgsql-hackers@hub.org\nPrecedence: bulk\nStatus: OR\n\nThis is some implementation notes and opened issues...\n\nFirst, implementation uses new type of parameters - PARAM_EXEC - to deal\nwith correlation Vars. When query_planner() is called, it first tries to\nreplace all upper queries Var referenced in current query with Param of\nthis type. Some global variables are used to keep mapping of Vars to\nParams and Params to Vars.\n\nAfter this, all current query' SubLinks are processed: for each SubLink\nfound in query' qual union_planner() (old planner() function) will be\ncalled to plan corresponding subselect (union_planner() calls\nquery_planner() for \"simple\" query and supports UNIONs). After subselect\nare planned, optimizer knows about is this correlated, un-correlated or\n_undirect_ correlated (references some grand-parent Vars but no parent\nones: uncorrelated from the parent' point of view) query.\n\nFor uncorrelated and undirect correlated subqueries of EXPRession or\nEXISTS type SubLinks will be replaced with \"normal\" clauses from\nSubLink->Oper list (I changed this list to be list of EXPR nodes,\nnot just Oper ones). Right sides of these nodes are replaced with\nPARAM_EXEC parameters. This is second use of new parameter type.\nAt run-time these parameters get value from result of subquery\nevaluation (i.e. - from target list of subquery). Execution plan of\nsubquery itself becomes init plan of parent query. InitPlan knows\nwhat parameters are to get values from subquery' results and will be\nexecuted \"on-demand\" (for query select * from table where x > 0 and\ny > (select max(a) from table_a) subquery will not be executed at all\nif there are no tuples with x > 0 _and_ y is not used in index scan).\n\nSubLinks for subqueries of all other types are transformed into\nnew type of Expr node - SUBPLAN_EXPR. Expr->args are just correlation\nvariables from _parent_ query. Expr->oper is new SubPlan node.\n\nThis node is used for InitPlan too. It keeps subquery range table,\nindices of Params which are to get value from _parent_ query Vars\n(i.e. - from Expr->args), indices of Params into which subquery'\nresults are to be substituted (this is for InitPlans), SubLink\nand subquery' execution plan.\n\nPlan node was changed to know about dependencies on Params from\nparent queries and InitPlans, to keep list of changed Params\n(from the above) and so be re-scanned if this list is not NULL.\nAlso, added list of InitPlans (actually, all of them for current\nquery are in topmost plan node now) and other SubPlans (from\nplan->qual) - to initialize them and let them know about changed\nParams (from the list of their \"interests\").\n\nAfter all SubLinks are processed, query_planner() calls qual'\ncanonificator and does \"normal\" work. By using Params optimizer\nis mostly unchanged.\n\nWell, Executor. To get subplans re-evaluated without ExecutorStart()\nand ExecutorEnd() (without opening and closing relations and indices\nand without many palloc() and pfree() - this is what SQL-funcs does\non each call) ExecReScan() now supports most of Plan types...\n\nExplanation of EXPLAIN.\n\nvac=> explain select * from tmp where x >= (select max(x2) from test2\nwhere y2 = y and exists (select * from tempx where tx = x));\nNOTICE:  QUERY PLAN:\n\nSeq Scan on tmp  (cost=40.03 size=101 width=8)\n  SubPlan\n  ^^^^^^^ subquery is in Seq Scan' qual, its plan is below\n    ->  Aggregate  (cost=2.05 size=0 width=0)\n          InitPlan\n          ^^^^^^^^ EXISTS subsubquery is InitPlan of subquery\n            ->  Seq Scan on tempx  (cost=4.33 size=1 width=4)\n          ->  Result  (cost=2.05 size=0 width=0)\n              ^^^^^^ EXISTS subsubquery was transformed into Param\n                     and so we have Result node here\n                ->  Index Scan on test2  (cost=2.05 size=1 width=4)\n\n\nOpened issues.\n\n1. No read permissions checking (easy, just not done yet).\n2. readfuncs.c can't read subplan-s (easy, not critical, because of\n   we currently nowhere use ascii representation of execution plans).\n3. ExecReScan() doesn't support all plan types. At least support for\n   MergeJoin has to be implemented.\n4. Memory leaks in ExecReScan().\n5. I need in advice: if subquery introduced with NOT IN doesn't return\n   any tuples then qualification is failed, yes ?\n6. Regression tests !!!!!!!!!!!!!!!!!!!!\n   (Could we use data/queries from MySQL' crash.me ?\n    Copyright-ed ? Could they give us rights ?)\n7. Performance.\n   - Should be good when subquery is transformed into InitPlan.\n   - Something should be done for uncorrelated subqueries introduced\n     with ANY/ALL - keep thinking. Currently, subplan will be re-scanned\n     for each parent tuple - very slow...\n\nResults of some test. TMP is table with x,y (int4-s), x in 0-9,\ny = 100 - x, 1000 tuples (10 duplicates of each tuple). TEST2 is table\nwith x2, y2 (int4-s), x2 in 1-99, y2 = 100 -x2, 10000 tuples (100 dups).\n\n   Trying\n\nselect * from tmp where x >= (select max(x2) from test2 where y2 = y);\n\n   and\n\nbegin;\nselect y as ty, max(x2) as mx into table tsub from test2, tmp\nwhere y2 = y group by ty;\nvacuum tsub;\nselect x, y from tmp, tsub where x >= mx and y = ty;\ndrop table tsub;\nend;\n\n   Without index on test2(y2):\n\nSubSelect         -> 320 sec\nUsing temp table  -> 32 sec\n\n   Having index\n\nSubSelect         -> 17 sec (2M of memory)\nUsing temp table  -> 32 sec (12M of memory: -S 8192)\n\nVadim","count":40},{"name":"subsystem-name","value":"plan","count":40},{"name":"subsystem-path","value":"backend/optimizer/plan/readme","count":40},{"name":"tested-by","value":"check_agg_arguments_walker, check_ungrouped_columns_walker, check_variable_parameters, check_parameter_resolution_walker","count":40},{"name":"tested-by","value":"check_data_directory, check_publisher, check_subscriber","count":40},{"name":"tested-by","value":"check_hostname","count":40},{"name":"tested-by","value":"check_locale_encoding, check_icu_locale_encoding, _check_database_version","count":40},{"name":"tested-by","value":"check_publication_add_relation, check_publication_add_relation","count":40},{"name":"tested-by","value":"check_publications_origin","count":40},{"name":"tested-by","value":"check_rel_can_be_partition","count":40},{"name":"tested-by","value":"check_temp_tablespaces","count":40},{"name":"tested-by","value":"domain_check_input","count":40},{"name":"tested-by","value":"test_timing, test_timing","count":40},{"name":"api-example","value":"Datum pg_xact_commit_timestamp(PG_FUNCTION_ARGS) { TransactionId xid = PG_GETARG_TRANSACTIONID(0); TimestampTz ts; bool\t\tfound; found = TransactionIdGetCommitTsData(xid, &ts, NULL); if (!found) PG_RET...","count":39},{"name":"api-example","value":"ObjectAddress DefineAggregate(ParseState *pstate, List *name, List *args, bool oldstyle, List *parameters, bool replace) { char\t   *aggName; Oid\t\t\taggNamespace; AclResult\taclresult; char\t\taggKind = AG...","count":39},{"name":"api-example","value":"bool _bt_first(IndexScanDesc scan, ScanDirection dir) { Relation\trel = scan->indexRelation; BTScanOpaque so = (BTScanOpaque) scan->opaque; Buffer\t\tbuf; BTStack\t\tstack; OffsetNumber offnum; StrategyNum...","count":39},{"name":"api-example","value":"int ParseDateTime(const char *timestr, char *workbuf, size_t buflen, char **field, int *ftype, int maxfields, int *numfields) { int\t\t\tnf = 0; const char *cp = timestr; char\t   *bufp = workbuf; const c...","count":39},{"name":"api-example","value":"static bool check_null_keys(BrinValues *bval, ScanKey *nullkeys, int nnullkeys) { int\t\t\tkeyno; * First check if there are any IS [NOT] NULL scan keys, and if we're * violating them. */ for (keyno = 0;...","count":39},{"name":"api-example","value":"static int bottomup_sort_and_shrink_cmp(const void *arg1, const void *arg2) { const IndexDeleteCounts *group1 = (const IndexDeleteCounts *) arg1; const IndexDeleteCounts *group2 = (const IndexDeleteCo...","count":39},{"name":"api-example","value":"static struct subre * parseqatom(struct vars *v, int stopper,\t\t\t/* EOS or ')' */ int type,\t\t\t/* LACON (lookaround subRE) or PLAIN */ struct state *lp,\t/* left state to hang it on */ struct state *rp,\t...","count":39},{"name":"api-example","value":"static void heapam_relation_copy_data(Relation rel, const RelFileLocator *newrlocator) { SMgrRelation dstrel; * Since we copy the file directly without looking at the shared buffers, * we'd better fir...","count":39},{"name":"api-example","value":"static void heapam_relation_copy_for_cluster(Relation OldHeap, Relation NewHeap, Relation OldIndex, bool use_sort, TransactionId OldestXmin, TransactionId *xid_cutoff, MultiXactId *multi_cutoff, doubl...","count":39},{"name":"api-example","value":"static void hlfinditem(HeadlineParsedText *prs, TSQuery query, int32 pos, char *buf, int buflen) { int\t\t\ti; QueryItem  *item = GETQUERY(query); HeadlineWordEntry *word; while (prs->curwords + query->s...","count":39},{"name":"api-example","value":"void AsyncShmemInit(void) { bool\t\tfound; Size\t\tsize; * Create or attach to the AsyncQueueControl structure. */ size = mul_size(MaxBackends, sizeof(QueueBackendStatus)); size = add_size(size, offsetof(...","count":39},{"name":"api-example","value":"void EncodeInterval(struct pg_itm *itm, int style, char *str) { char\t   *cp = str; int\t\t\tyear = itm->tm_year; int\t\t\tmon = itm->tm_mon; int64\t\tmday = itm->tm_mday;\t/* tm_mday could be INT_MIN */ int64\t...","count":39},{"name":"api-example","value":"void InitializeParallelDSM(ParallelContext *pcxt) { MemoryContext oldcontext; Size\t\tlibrary_len = 0; Size\t\tguc_len = 0; Size\t\tcombocidlen = 0; Size\t\ttsnaplen = 0; Size\t\tasnaplen = 0; Size\t\ttstatelen =...","count":39},{"name":"api-example","value":"void RelationBuildRowSecurity(Relation relation) { MemoryContext rscxt; MemoryContext oldcxt = CurrentMemoryContext; RowSecurityDesc *rsdesc; Relation\tcatalog; ScanKeyData skey; SysScanDesc sscan; Hea...","count":39},{"name":"api-example","value":"void dbase_desc(StringInfo buf, XLogReaderState *record) { char\t   *rec = XLogRecGetData(record); uint8\t\tinfo = XLogRecGetInfo(record) & ~XLR_INFO_MASK; if (info == XLOG_DBASE_CREATE_FILE_COPY) { xl_d...","count":39},{"name":"api-example","value":"void gistrescan(IndexScanDesc scan, ScanKey key, int nkeys, ScanKey orderbys, int norderbys) { GISTScanOpaque so = (GISTScanOpaque) scan->opaque; bool\t\tfirst_time; int\t\t\ti; MemoryContext oldCxt; * The...","count":39},{"name":"arch-layer","value":"query-frontend","count":39},{"name":"arch-layer-description","value":"Query parsing and semantic analysis","count":39},{"name":"api-caller-count","value":"78","count":36},{"name":"api-caller-count","value":"83","count":36},{"name":"api-example","value":"Datum brin_bloom_summary_out(PG_FUNCTION_ARGS) { BloomFilter *filter; StringInfoData str; filter = (BloomFilter *) PG_DETOAST_DATUM(PG_GETARG_DATUM(0)); initStringInfo(&str); appendStringInfoChar(&str...","count":36},{"name":"api-example","value":"Datum ginqueryarrayextract(PG_FUNCTION_ARGS) { ArrayType  *array = PG_GETARG_ARRAYTYPE_P_COPY(0); int32\t   *nkeys = (int32 *) PG_GETARG_POINTER(1); StrategyNumber strategy = PG_GETARG_UINT16(2); bool\t...","count":36},{"name":"api-example","value":"IndexBulkDeleteResult * hashbulkdelete(IndexVacuumInfo *info, IndexBulkDeleteResult *stats, IndexBulkDeleteCallback callback, void *callback_state) { Relation\trel = info->index; double\t\ttuples_removed...","count":36},{"name":"api-example","value":"TM_Result heap_update(Relation relation, ItemPointer otid, HeapTuple newtup, CommandId cid, Snapshot crosscheck, bool wait, TM_FailureData *tmfd, LockTupleMode *lockmode, TU_UpdateIndexes *update_inde...","count":36},{"name":"api-example","value":"bool check_timezone(char **newval, void **extra, GucSource source) { pg_tz\t   *new_tz; long\t\tgmtoffset; char\t   *endptr; double\t\thours; if (pg_strncasecmp(*newval, \"interval\", 8) == 0) { * Support INT...","count":36},{"name":"api-example","value":"char * getObjectDescription(const ObjectAddress *object, bool missing_ok) { StringInfoData buffer; initStringInfo(&buffer); switch (object->classId) { case RelationRelationId: if (object->objectSubId ...","count":36},{"name":"api-example","value":"char * getObjectIdentityParts(const ObjectAddress *object, List **objname, List **objargs, bool missing_ok) { StringInfoData buffer; initStringInfo(&buffer); * Make sure that both objname and objargs ...","count":36},{"name":"api-example","value":"static FmgrInfo * bloom_get_procinfo(BrinDesc *bdesc, uint16 attno, uint16 procnum) { BloomOpaque *opaque; uint16\t\tbasenum = procnum - PROCNUM_BASE; * We cache these in the opaque struct, to avoid rep...","count":36},{"name":"api-example","value":"static TupleDesc ConstructTupleDescriptor(Relation heapRelation, const IndexInfo *indexInfo, const List *indexColNames, Oid accessMethodId, const Oid *collationIds, const Oid *opclassIds) { int\t\t\tnuma...","count":36},{"name":"api-example","value":"static bool MatchNamedCall(HeapTuple proctup, int nargs, List *argnames, bool include_out_arguments, int pronargs, int **argnumbers) { Form_pg_proc procform = (Form_pg_proc) GETSTRUCT(proctup); int\t\t\t...","count":36},{"name":"api-example","value":"static bool verify_client_proof(scram_state *state) { uint8\t\tClientSignature[SCRAM_MAX_KEY_LEN]; uint8\t\tClientKey[SCRAM_MAX_KEY_LEN]; uint8\t\tclient_StoredKey[SCRAM_MAX_KEY_LEN]; pg_hmac_ctx *ctx = pg_...","count":36},{"name":"api-example","value":"static void eval_windowaggregates(WindowAggState *winstate) { WindowStatePerAgg peraggstate; int\t\t\twfuncno, numaggs, numaggs_restart, i; int64\t\taggregatedupto_nonrestarted; MemoryContext oldContext; E...","count":36},{"name":"api-example","value":"static void logical_heap_rewrite_flush_mappings(RewriteState state) { HASH_SEQ_STATUS seq_status; RewriteMappingFile *src; dlist_mutable_iter iter; Assert(state->rs_logical_rewrite); if (state->rs_num...","count":36},{"name":"api-example","value":"static void setup_config(void) { char\t  **conflines; char\t\trepltok[MAXPGPATH]; char\t\tpath[MAXPGPATH]; _stringlist *gnames, *gvalues; fputs(_(\"creating configuration files ... \"), stdout); fflush(stdou...","count":36},{"name":"api-example","value":"void ginInsertCleanup(GinState *ginstate, bool full_clean, bool fill_fsm, bool forceCleanup, IndexBulkDeleteResult *stats) { Relation\tindex = ginstate->index; Buffer\t\tmetabuffer, buffer; Page\t\tmetapag...","count":36},{"name":"api-example","value":"void heap_inplace_update_and_unlock(Relation relation, HeapTuple oldtup, HeapTuple tuple, Buffer buffer) { HeapTupleHeader htup = oldtup->t_data; uint32\t\toldlen; uint32\t\tnewlen; Assert(ItemPointerEqua...","count":36},{"name":"api-typical-usage","value":"Often called from: AlterStatistics","count":36},{"name":"api-typical-usage","value":"Often called from: AtEOSubXact_cleanup","count":36},{"name":"api-typical-usage","value":"Often called from: BackgroundWorkerMain","count":36},{"name":"api-typical-usage","value":"Often called from: CheckIndexCompatible","count":36},{"name":"api-typical-usage","value":"Often called from: CopyGetData","count":36},{"name":"api-typical-usage","value":"Often called from: CreateConstraintEntry","count":36},{"name":"api-typical-usage","value":"Often called from: ExecHashJoinImpl","count":36},{"name":"api-typical-usage","value":"Often called from: ExecInitParallelPlan","count":36},{"name":"api-typical-usage","value":"Often called from: GetTupleForTrigger","count":36},{"name":"api-typical-usage","value":"Often called from: GinFormTuple","count":36},{"name":"api-typical-usage","value":"Often called from: HeapTupleSatisfiesUpdate","count":36},{"name":"api-typical-usage","value":"Often called from: KeepLogSeg","count":36},{"name":"api-typical-usage","value":"Often called from: LockErrorCleanup","count":36},{"name":"api-typical-usage","value":"Often called from: MainLoop","count":36},{"name":"api-typical-usage","value":"Often called from: PLy_output_setup_func","count":36},{"name":"api-typical-usage","value":"Often called from: ParseDateTime","count":36},{"name":"api-typical-usage","value":"Often called from: PostgresMain","count":36},{"name":"api-typical-usage","value":"Often called from: ReorderBufferIterTXNInit","count":36},{"name":"api-typical-usage","value":"Often called from: ReorderBufferProcessTXN","count":36},{"name":"api-typical-usage","value":"Often called from: TS_phrase_execute","count":36},{"name":"api-typical-usage","value":"Often called from: TransactionIdIsInProgress","count":36},{"name":"api-typical-usage","value":"Often called from: XLogReaderAllocate","count":36},{"name":"api-typical-usage","value":"Often called from: _PrintTocData","count":36},{"name":"api-typical-usage","value":"Often called from: _bt_check_compare","count":36},{"name":"api-typical-usage","value":"Often called from: _bt_parallel_build_main","count":36},{"name":"api-typical-usage","value":"Often called from: _bt_spools_heapscan","count":36},{"name":"api-typical-usage","value":"Often called from: _fmt","count":36},{"name":"api-typical-usage","value":"Often called from: apply_handle_tuple_routing","count":36},{"name":"api-typical-usage","value":"Often called from: array_fill_internal","count":36},{"name":"api-typical-usage","value":"Often called from: array_set_slice","count":36},{"name":"api-typical-usage","value":"Often called from: build_subplan","count":36},{"name":"api-typical-usage","value":"Often called from: compute_tsvector_stats","count":36},{"name":"api-typical-usage","value":"Often called from: executeDateTimeMethod","count":36},{"name":"api-typical-usage","value":"Often called from: fill_val","count":36},{"name":"api-typical-usage","value":"Often called from: get_policies_for_relation","count":36},{"name":"api-typical-usage","value":"Often called from: gistdoinsert","count":36},{"name":"api-typical-usage","value":"Often called from: hash_xlog_squeeze_page","count":36},{"name":"api-typical-usage","value":"Often called from: heap_xlog_multi_insert","count":36},{"name":"api-typical-usage","value":"Often called from: inet_spg_choose","count":36},{"name":"api-typical-usage","value":"Often called from: interval_div","count":36},{"name":"api-typical-usage","value":"Often called from: merge_null_partitions","count":36},{"name":"api-typical-usage","value":"Often called from: outzone","count":36},{"name":"api-typical-usage","value":"Often called from: pg_euc2wchar_with_len","count":36},{"name":"api-typical-usage","value":"Often called from: pgstat_end_function_usage","count":36},{"name":"api-typical-usage","value":"Often called from: pqInternalNotice","count":36},{"name":"api-typical-usage","value":"Often called from: sanityChecks","count":36},{"name":"api-typical-usage","value":"Often called from: scanNSItemForColumn","count":36},{"name":"api-typical-usage","value":"Often called from: set_upper_references","count":36},{"name":"api-typical-usage","value":"Often called from: sqrt_var","count":36},{"name":"api-typical-usage","value":"Often called from: tsvector_update_trigger","count":36},{"name":"api-typical-usage","value":"Often called from: xlog_redo","count":36},{"name":"coupling-score","value":"31","count":36},{"name":"coupling-score","value":"53","count":36},{"name":"cyclomatic-complexity","value":"107","count":36},{"name":"cyclomatic-complexity","value":"71","count":36},{"name":"cyclomatic-complexity","value":"78","count":36},{"name":"cyclomatic-complexity","value":"85","count":36},{"name":"cyclomatic-complexity","value":"93","count":36},{"name":"lines-of-code","value":"166","count":36},{"name":"lines-of-code","value":"190","count":36},{"name":"lines-of-code","value":"199","count":36},{"name":"lines-of-code","value":"223","count":36},{"name":"lines-of-code","value":"226","count":36},{"name":"lines-of-code","value":"233","count":36},{"name":"lines-of-code","value":"242","count":36},{"name":"lines-of-code","value":"254","count":36},{"name":"lines-of-code","value":"259","count":36},{"name":"lines-of-code","value":"336","count":36},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\mb\\mbutils.c, backend\\utils\\mb\\conv.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c","count":36},{"name":"tested-by","value":"RI_FKey_fk_upd_check_required","count":36},{"name":"tested-by","value":"check_exclusion_or_unique_constraint","count":36},{"name":"tested-by","value":"test_sync, test_sync, test_non_sync","count":36},{"name":"tested-by","value":"truncate_check_activity","count":36},{"name":"arch-layer","value":"transaction","count":35},{"name":"arch-layer-description","value":"Transaction and concurrency control","count":35},{"name":"api-example","value":"Datum brin_minmax_multi_summary_out(PG_FUNCTION_ARGS) { int\t\t\ti; int\t\t\tidx; SerializedRanges *ranges; Ranges\t   *ranges_deserialized; StringInfoData str; bool\t\tisvarlena; Oid\t\t\toutfunc; FmgrInfo\tfmgri...","count":33},{"name":"api-example","value":"Datum tsm_bernoulli_handler(PG_FUNCTION_ARGS) { TsmRoutine *tsm = makeNode(TsmRoutine); tsm->parameterTypes = list_make1_oid(FLOAT4OID); tsm->repeatable_across_queries = true; tsm->repeatable_across_s...","count":33},{"name":"api-example","value":"ObjectAddress CreateSubscription(ParseState *pstate, CreateSubscriptionStmt *stmt, bool isTopLevel) { Relation\trel; ObjectAddress myself; Oid\t\t\tsubid; bool\t\tnulls[Natts_pg_subscription]; Datum\t\tvalues...","count":33},{"name":"api-example","value":"bool hashvalidate(Oid opclassoid) { bool\t\tresult = true; HeapTuple\tclasstup; Form_pg_opclass classform; Oid\t\t\topfamilyoid; Oid\t\t\topcintype; char\t   *opclassname; HeapTuple\tfamilytup; Form_pg_opfamily ...","count":33},{"name":"api-example","value":"dsm_handle GetSessionDsmHandle(void) { shm_toc_estimator estimator; shm_toc    *toc; dsm_segment *seg; size_t\t\ttypmod_registry_size; size_t\t\tsize; void\t   *dsa_space; void\t   *typmod_registry_space; d...","count":33},{"name":"api-example","value":"static IndexBulkDeleteResult * lazy_vacuum_one_index(Relation indrel, IndexBulkDeleteResult *istat, double reltuples, LVRelState *vacrel) { IndexVacuumInfo ivinfo; LVSavedErrInfo saved_err_info; ivinf...","count":33},{"name":"api-example","value":"static Plan * set_plan_refs(PlannerInfo *root, Plan *plan, int rtoffset) { ListCell   *l; if (plan == NULL) return NULL; plan->plan_node_id = root->glob->lastPlanNodeId++; * Plan-type-specific fixes *...","count":33},{"name":"api-example","value":"static bool PerformRecoveryXLogAction(void) { bool\t\tpromoted = false; * Perform a checkpoint to update all our recovery activity to disk. * * Note that we write a shutdown checkpoint rather than an on...","count":33},{"name":"api-example","value":"static bool paraminfo_get_equal_hashops(PlannerInfo *root, ParamPathInfo *param_info, RelOptInfo *outerrel, RelOptInfo *innerrel, List **param_exprs, List **operators, bool *binary_mode) { ListCell   ...","count":33},{"name":"api-example","value":"static void AbortTransaction(void) { TransactionState s = CurrentTransactionState; TransactionId latestXid; bool\t\tis_parallel_worker; HOLD_INTERRUPTS(); if (TransactionTimeout > 0) disable_timeout(TRA...","count":33},{"name":"api-example","value":"static void ExecHashIncreaseNumBatches(HashJoinTable hashtable) { int\t\t\toldnbatch = hashtable->nbatch; int\t\t\tcurbatch = hashtable->curbatch; int\t\t\tnbatch; long\t\tninmemory; long\t\tnfreed; HashMemoryChun...","count":33},{"name":"api-example","value":"static void NUMDesc_prepare(NUMDesc *num, FormatNode *n) { if (n->type != NODE_TYPE_ACTION) return; if (IS_EEEE(num) && n->key->id != NUM_E) ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg(\"\\\"EE...","count":33},{"name":"api-example","value":"static void computeLeafRecompressWALData(disassembledLeaf *leaf) { int\t\t\tnmodified = 0; char\t   *walbufbegin; char\t   *walbufend; dlist_iter\titer; int\t\t\tsegno; ginxlogRecompressDataLeaf *recompress_xl...","count":33},{"name":"api-example","value":"static void generate_base_implied_equalities_no_const(PlannerInfo *root, EquivalenceClass *ec) { EquivalenceMember **prev_ems; ListCell   *lc; * We scan the EC members once and track the last-seen mem...","count":33},{"name":"api-example","value":"void ExplainPrintPlan(ExplainState *es, QueryDesc *queryDesc) { Bitmapset  *rels_used = NULL; PlanState  *ps; Assert(queryDesc->plannedstmt != NULL); es->pstmt = queryDesc->plannedstmt; es->rtable = q...","count":33},{"name":"api-example","value":"void WaitForOlderSnapshots(TransactionId limitXmin, bool progress) { int\t\t\tn_old_snapshots; int\t\t\ti; VirtualTransactionId *old_snapshots; old_snapshots = GetCurrentVirtualXIDs(limitXmin, true, false, ...","count":33},{"name":"api-example","value":"void XLogArchiveForceDone(const char *xlog) { char\t\tarchiveReady[MAXPGPATH]; char\t\tarchiveDone[MAXPGPATH]; struct stat stat_buf; FILE\t   *fd; StatusFilePath(archiveDone, xlog, \".done\"); if (stat(archi...","count":33},{"name":"api-example","value":"void XLogRecGetBlockRefInfo(XLogReaderState *record, bool pretty, bool detailed_format, StringInfo buf, uint32 *fpi_len) { int\t\t\tblock_id; Assert(record != NULL); if (detailed_format && pretty) append...","count":33},{"name":"api-example","value":"void cost_samplescan(Path *path, PlannerInfo *root, RelOptInfo *baserel, ParamPathInfo *param_info) { Cost\t\tstartup_cost = 0; Cost\t\trun_cost = 0; RangeTblEntry *rte; TableSampleClause *tsc; TsmRoutine...","count":33},{"name":"api-example","value":"void hashbucketcleanup(Relation rel, Bucket cur_bucket, Buffer bucket_buf, BlockNumber bucket_blkno, BufferAccessStrategy bstrategy, uint32 maxbucket, uint32 highmask, uint32 lowmask, double *tuples_r...","count":33},{"name":"api-example","value":"void setup_text_search(void) { if (!default_text_search_config) { default_text_search_config = find_matching_ts_config(lc_ctype); if (!default_text_search_config) { pg_log_info(\"could not find suitabl...","count":33},{"name":"api-caller-count","value":"125","count":32},{"name":"api-caller-count","value":"97","count":32},{"name":"api-typical-usage","value":"Often called from: AfterTriggerSaveEvent","count":32},{"name":"api-typical-usage","value":"Often called from: AlterRole","count":32},{"name":"api-typical-usage","value":"Often called from: AuxiliaryProcessMainCommon","count":32},{"name":"api-typical-usage","value":"Often called from: BaseBackup","count":32},{"name":"api-typical-usage","value":"Often called from: CleanupBackupHistory","count":32},{"name":"api-typical-usage","value":"Often called from: CreateDatabaseUsingFileCopy","count":32},{"name":"api-typical-usage","value":"Often called from: DCH_from_char","count":32},{"name":"api-typical-usage","value":"Often called from: ExecInitHashJoin","count":32},{"name":"api-typical-usage","value":"Often called from: ExecWindowAgg","count":32},{"name":"api-typical-usage","value":"Often called from: ExtendBufferedRelShared","count":32},{"name":"api-typical-usage","value":"Often called from: GetMultiXactIdMembers","count":32},{"name":"api-typical-usage","value":"Often called from: GuessControlValues","count":32},{"name":"api-typical-usage","value":"Often called from: InitControlFile","count":32},{"name":"api-typical-usage","value":"Often called from: NIImportOOAffixes","count":32},{"name":"api-typical-usage","value":"Often called from: ProcessPendingWrites","count":32},{"name":"api-typical-usage","value":"Often called from: WALReadFromBuffers","count":32},{"name":"api-typical-usage","value":"Often called from: WaitLatchOrSocket","count":32},{"name":"api-typical-usage","value":"Often called from: WalSndComputeSleeptime","count":32},{"name":"api-typical-usage","value":"Often called from: _hash_load_qualified_items","count":32},{"name":"api-typical-usage","value":"Often called from: check_expected_areq","count":32},{"name":"api-typical-usage","value":"Often called from: cluster_rel","count":32},{"name":"api-typical-usage","value":"Often called from: createForeignKeyActionTriggers","count":32},{"name":"api-typical-usage","value":"Often called from: ensure_active_superblock","count":32},{"name":"api-typical-usage","value":"Often called from: escape_json","count":32},{"name":"api-typical-usage","value":"Often called from: exec_bind_message","count":32},{"name":"api-typical-usage","value":"Often called from: expand_planner_arrays","count":32},{"name":"api-typical-usage","value":"Often called from: flatten_join_alias_vars_mutator","count":32},{"name":"api-typical-usage","value":"Often called from: gin_desc","count":32},{"name":"api-typical-usage","value":"Often called from: inv_open","count":32},{"name":"api-typical-usage","value":"Often called from: leafRepackItems","count":32},{"name":"api-typical-usage","value":"Often called from: logicalrep_worker_launch","count":32},{"name":"api-typical-usage","value":"Often called from: make_interval","count":32},{"name":"api-typical-usage","value":"Often called from: md5_calc","count":32},{"name":"api-typical-usage","value":"Often called from: multirange_get_range","count":32},{"name":"api-typical-usage","value":"Often called from: parse_re_flags","count":32},{"name":"api-typical-usage","value":"Often called from: plperl_trigger_handler","count":32},{"name":"api-typical-usage","value":"Often called from: plpgsql_parse_tripword","count":32},{"name":"api-typical-usage","value":"Often called from: pqConnectOptions2","count":32},{"name":"api-typical-usage","value":"Often called from: r_standard_suffix","count":32},{"name":"api-typical-usage","value":"Often called from: range_serialize","count":32},{"name":"api-typical-usage","value":"Often called from: set_config_with_handle","count":32},{"name":"api-typical-usage","value":"Often called from: set_var_from_non_decimal_integer_str","count":32},{"name":"api-typical-usage","value":"Often called from: timestamp_age","count":32},{"name":"api-typical-usage","value":"Often called from: timestamptz_part_common","count":32},{"name":"api-typical-usage","value":"Often called from: transformIndexConstraint","count":32},{"name":"api-typical-usage","value":"Often called from: tsvectorin","count":32},{"name":"api-typical-usage","value":"Often called from: xact_decode","count":32},{"name":"cyclomatic-complexity","value":"136","count":32},{"name":"cyclomatic-complexity","value":"144","count":32},{"name":"cyclomatic-complexity","value":"65","count":32},{"name":"cyclomatic-complexity","value":"80","count":32},{"name":"cyclomatic-complexity","value":"88","count":32},{"name":"lines-of-code","value":"187","count":32},{"name":"lines-of-code","value":"197","count":32},{"name":"lines-of-code","value":"204","count":32},{"name":"lines-of-code","value":"205","count":32},{"name":"lines-of-code","value":"214","count":32},{"name":"lines-of-code","value":"224","count":32},{"name":"lines-of-code","value":"231","count":32},{"name":"lines-of-code","value":"236","count":32},{"name":"lines-of-code","value":"269","count":32},{"name":"lines-of-code","value":"285","count":32},{"name":"lines-of-code","value":"330","count":32},{"name":"lines-of-code","value":"354","count":32},{"name":"test-count","value":"19","count":32},{"name":"tested-by","value":"check_amproc_signature","count":32},{"name":"tested-by","value":"check_and_dump_old_cluster","count":32},{"name":"tested-by","value":"check_expected_areq, check_expected_areq","count":32},{"name":"tested-by","value":"check_ident_usermap","count":32},{"name":"tested-by","value":"check_new_partition_bound","count":32},{"name":"tested-by","value":"check_safe_enum_use","count":32},{"name":"Feature","value":"CREATE TRANSFORM","count":30},{"name":"Feature","value":"EXECUTE USING in PL/pgSQL","count":30},{"name":"Feature","value":"Parallel hash joins","count":30},{"name":"Feature","value":"Python 3 support for pl/python","count":30},{"name":"api-example","value":"Datum brin_minmax_multi_distance_inet(PG_FUNCTION_ARGS) { float8\t\tdelta; int\t\t\ti; int\t\t\tlen; unsigned char *addra, *addrb; inet\t   *ipa = PG_GETARG_INET_PP(0); inet\t   *ipb = PG_GETARG_INET_PP(1); int...","count":30},{"name":"api-example","value":"Datum gin_clean_pending_list(PG_FUNCTION_ARGS) { Oid\t\t\tindexoid = PG_GETARG_OID(0); Relation\tindexRel = index_open(indexoid, RowExclusiveLock); IndexBulkDeleteResult stats; if (RecoveryInProgress()) e...","count":30},{"name":"api-example","value":"Datum toast_save_datum(Relation rel, Datum value, struct varlena *oldexternal, int options) { Relation\ttoastrel; Relation   *toastidxs; HeapTuple\ttoasttup; TupleDesc\ttoasttupDesc; Datum\t\tt_values[3]; ...","count":30},{"name":"api-example","value":"IndexBulkDeleteResult * btbulkdelete(IndexVacuumInfo *info, IndexBulkDeleteResult *stats, IndexBulkDeleteCallback callback, void *callback_state) { Relation\trel = info->index; BTCycleId\tcycleid; if (s...","count":30},{"name":"api-example","value":"IndexScanDesc brinbeginscan(Relation r, int nkeys, int norderbys) { IndexScanDesc scan; BrinOpaque *opaque; scan = RelationGetIndexScan(r, nkeys, norderbys); opaque = palloc_object(BrinOpaque); opaque...","count":30},{"name":"api-example","value":"List * find_all_inheritors(Oid parentrelId, LOCKMODE lockmode, List **numparents) { HTAB\t   *seen_rels; HASHCTL\t\tctl; List\t   *rels_list, *rel_numparents; ListCell   *l; ctl.keysize = sizeof(Oid); ctl...","count":30},{"name":"api-example","value":"Oid CreateRole(ParseState *pstate, CreateRoleStmt *stmt) { Relation\tpg_authid_rel; TupleDesc\tpg_authid_dsc; HeapTuple\ttuple; Datum\t\tnew_record[Natts_pg_authid] = {0}; bool\t\tnew_record_nulls[Natts_pg_a...","count":30},{"name":"api-example","value":"static BrinInsertState * initialize_brin_insertstate(Relation idxRel, IndexInfo *indexInfo) { BrinInsertState *bistate; MemoryContext oldcxt; oldcxt = MemoryContextSwitchTo(indexInfo->ii_Context); bis...","count":30},{"name":"api-example","value":"static OffsetNumber _bt_findinsertloc(Relation rel, BTInsertState insertstate, bool checkingunique, bool indexUnchanged, BTStack stack, Relation heapRel) { BTScanInsert itup_key = insertstate->itup_ke...","count":30},{"name":"api-example","value":"static bool CLOGPagePrecedes(int64 page1, int64 page2) { TransactionId xid1; TransactionId xid2; xid1 = ((TransactionId) page1) * CLOG_XACTS_PER_PAGE; xid1 += FirstNormalTransactionId + 1; xid2 = ((Tr...","count":30},{"name":"api-example","value":"static bool GetTupleForTrigger(EState *estate, EPQState *epqstate, ResultRelInfo *relinfo, ItemPointer tid, LockTupleMode lockmode, TupleTableSlot *oldslot, bool do_epq_recheck, TupleTableSlot **epqsl...","count":30},{"name":"api-example","value":"static bool check_locale_encoding(const char *locale, int user_enc) { int\t\t\tlocale_enc; locale_enc = pg_get_encoding_from_locale(locale, true); if (!(locale_enc == user_enc || locale_enc == PG_SQL_ASC...","count":30},{"name":"api-example","value":"static bool sendFile(bbsink *sink, const char *readfilename, const char *tarfilename, struct stat *statbuf, bool missing_ok, Oid dboid, Oid spcoid, RelFileNumber relfilenumber, unsigned segno, backup_...","count":30},{"name":"api-example","value":"static char * str_udeescape(const char *str, char escape, int position, core_yyscan_t yyscanner) { const char *in; char\t   *new, *out; size_t\t\tnew_len; pg_wchar\tpair_first = 0; ScannerCallbackState sc...","count":30},{"name":"api-example","value":"static int row_is_in_frame(WindowAggState *winstate, int64 pos, TupleTableSlot *slot) { int\t\t\tframeOptions = winstate->frameOptions; Assert(pos >= 0);\t\t\t/* else caller error */ * First, check frame st...","count":30},{"name":"api-example","value":"static void CloneRowTriggersToPartition(Relation parent, Relation partition) { Relation\tpg_trigger; ScanKeyData key; SysScanDesc scan; HeapTuple\ttuple; MemoryContext perTupCxt; ScanKeyInit(&key, Anum_...","count":30},{"name":"api-example","value":"static void ExecHashBuildSkewHash(HashJoinTable hashtable, Hash *node, int mcvsToUse) { HeapTupleData *statsTuple; AttStatsSlot sslot; if (!OidIsValid(node->skewTable)) return; if (mcvsToUse <= 0) ret...","count":30},{"name":"api-example","value":"static void InitQueryHashTable(void) { HASHCTL\t\thash_ctl; hash_ctl.keysize = NAMEDATALEN; hash_ctl.entrysize = sizeof(PreparedStatement); prepared_queries = hash_create(\"Prepared Queries\", 32, &hash_c...","count":30},{"name":"api-example","value":"static void cleanup_directories_atexit(void) { if (success) return; if (!noclean) { if (made_new_pgdata) { pg_log_info(\"removing data directory \\\"%s\\\"\", pg_data); if (!rmtree(pg_data, true)) pg_log_er...","count":30},{"name":"api-example","value":"static void gistRedoDeleteRecord(XLogReaderState *record) { XLogRecPtr\tlsn = record->EndRecPtr; gistxlogDelete *xldata = (gistxlogDelete *) XLogRecGetData(record); Buffer\t\tbuffer; Page\t\tpage; OffsetNu...","count":30},{"name":"api-example","value":"void SendBackupManifest(backup_manifest_info *manifest, bbsink *sink) { uint8\t\tchecksumbuf[PG_SHA256_DIGEST_LENGTH]; char\t\tchecksumstringbuf[PG_SHA256_DIGEST_STRING_LENGTH]; size_t\t\tmanifest_bytes_don...","count":30},{"name":"api-example","value":"void heap_multi_insert(Relation relation, TupleTableSlot **slots, int ntuples, CommandId cid, int options, BulkInsertState bistate) { TransactionId xid = GetCurrentTransactionId(); HeapTuple  *heaptup...","count":30},{"name":"Feature","value":"Two Phase commit","count":29},{"name":"api-caller-count","value":"102","count":28},{"name":"api-caller-count","value":"104","count":28},{"name":"api-caller-count","value":"131","count":28},{"name":"api-caller-count","value":"146","count":28},{"name":"api-caller-count","value":"240","count":28},{"name":"api-caller-count","value":"2703","count":28},{"name":"api-caller-count","value":"67","count":28},{"name":"api-caller-count","value":"81","count":28},{"name":"api-caller-count","value":"86","count":28},{"name":"api-typical-usage","value":"Often called from: AllocSetContextCreateInternal","count":28},{"name":"api-typical-usage","value":"Often called from: ApplyWalRecord","count":28},{"name":"api-typical-usage","value":"Often called from: AtEOXact_PgStat_DroppedStats","count":28},{"name":"api-typical-usage","value":"Often called from: CopyXLogRecordToWAL","count":28},{"name":"api-typical-usage","value":"Often called from: CreateDirAndVersionFile","count":28},{"name":"api-typical-usage","value":"Often called from: ExecSupportsBackwardScan","count":28},{"name":"api-typical-usage","value":"Often called from: ExecuteTruncateGuts","count":28},{"name":"api-typical-usage","value":"Often called from: FreePageManagerPutInternal","count":28},{"name":"api-typical-usage","value":"Often called from: GetNewMultiXactId","count":28},{"name":"api-typical-usage","value":"Often called from: InitProcess","count":28},{"name":"api-typical-usage","value":"Often called from: InstrEndLoop","count":28},{"name":"api-typical-usage","value":"Often called from: InterlockedCompareExchange","count":28},{"name":"api-typical-usage","value":"Often called from: InterlockedDecrement","count":28},{"name":"api-typical-usage","value":"Often called from: InterlockedExchange","count":28},{"name":"api-typical-usage","value":"Often called from: InterlockedExchangeAdd","count":28},{"name":"api-typical-usage","value":"Often called from: InterlockedIncrement","count":28},{"name":"api-typical-usage","value":"Often called from: LWLockUpdateVar","count":28},{"name":"api-typical-usage","value":"Often called from: LWLockWakeup","count":28},{"name":"api-typical-usage","value":"Often called from: LogCurrentRunningXacts","count":28},{"name":"api-typical-usage","value":"Often called from: NUMDesc_prepare","count":28},{"name":"api-typical-usage","value":"Often called from: ParseTzFile","count":28},{"name":"api-typical-usage","value":"Often called from: ProcessInterrupts","count":28},{"name":"api-typical-usage","value":"Often called from: RestoreArchive","count":28},{"name":"api-typical-usage","value":"Often called from: SetLatch","count":28},{"name":"api-typical-usage","value":"Often called from: SysLoggerMain","count":28},{"name":"api-typical-usage","value":"Often called from: _bt_advance_array_keys","count":28},{"name":"api-typical-usage","value":"Often called from: _bt_buildadd","count":28},{"name":"api-typical-usage","value":"Often called from: _bt_truncate","count":28},{"name":"api-typical-usage","value":"Often called from: apply_handle_stream_abort","count":28},{"name":"api-typical-usage","value":"Often called from: bms_add_range","count":28},{"name":"api-typical-usage","value":"Often called from: brackpart","count":28},{"name":"api-typical-usage","value":"Often called from: brin_form_tuple","count":28},{"name":"api-typical-usage","value":"Often called from: ccondissect","count":28},{"name":"api-typical-usage","value":"Often called from: change_directory","count":28},{"name":"api-typical-usage","value":"Often called from: dttofmtasc_replace","count":28},{"name":"api-typical-usage","value":"Often called from: exec_move_row_from_datum","count":28},{"name":"api-typical-usage","value":"Often called from: expand_tuple","count":28},{"name":"api-typical-usage","value":"Often called from: expression_tree_mutator_impl","count":28},{"name":"api-typical-usage","value":"Often called from: fix_join_expr_mutator","count":28},{"name":"api-typical-usage","value":"Often called from: float8_to_char","count":28},{"name":"api-typical-usage","value":"Often called from: generate_union_paths","count":28},{"name":"api-typical-usage","value":"Often called from: getTables","count":28},{"name":"api-typical-usage","value":"Often called from: gistXLogDelete","count":28},{"name":"api-typical-usage","value":"Often called from: gistgettuple","count":28},{"name":"api-typical-usage","value":"Often called from: hash_inner_and_outer","count":28},{"name":"api-typical-usage","value":"Often called from: heapam_index_fetch_tuple","count":28},{"name":"api-typical-usage","value":"Often called from: index_drop","count":28},{"name":"api-typical-usage","value":"Often called from: int2_sum","count":28},{"name":"api-typical-usage","value":"Often called from: make_group_input_target","count":28},{"name":"api-typical-usage","value":"Often called from: make_ruledef","count":28},{"name":"api-typical-usage","value":"Often called from: pg_fe_sendauth","count":28},{"name":"api-typical-usage","value":"Often called from: pg_lsn_eq","count":28},{"name":"api-typical-usage","value":"Often called from: pg_malloc_internal","count":28},{"name":"api-typical-usage","value":"Often called from: pg_password_sendauth","count":28},{"name":"api-typical-usage","value":"Often called from: pg_pwritev","count":28},{"name":"api-typical-usage","value":"Often called from: plpgsql_inline_handler","count":28},{"name":"api-typical-usage","value":"Often called from: pqsecure_open_gss","count":28},{"name":"api-typical-usage","value":"Often called from: preprocess_targetlist","count":28},{"name":"api-typical-usage","value":"Often called from: recurse_dir","count":28},{"name":"api-typical-usage","value":"Often called from: str_udeescape","count":28},{"name":"api-typical-usage","value":"Often called from: timestamptz_bin","count":28},{"name":"api-typical-usage","value":"Often called from: unicode_normalize_func","count":28},{"name":"coupling-score","value":"35","count":28},{"name":"coupling-score","value":"42","count":28},{"name":"coupling-score","value":"44","count":28},{"name":"coupling-score","value":"50","count":28},{"name":"coupling-score","value":"52","count":28},{"name":"coupling-score","value":"59","count":28},{"name":"cyclomatic-complexity","value":"103","count":28},{"name":"cyclomatic-complexity","value":"121","count":28},{"name":"cyclomatic-complexity","value":"135","count":28},{"name":"cyclomatic-complexity","value":"155","count":28},{"name":"cyclomatic-complexity","value":"158","count":28},{"name":"cyclomatic-complexity","value":"75","count":28},{"name":"cyclomatic-complexity","value":"98","count":28},{"name":"cyclomatic-complexity","value":"99","count":28},{"name":"lines-of-code","value":"162","count":28},{"name":"lines-of-code","value":"201","count":28},{"name":"lines-of-code","value":"203","count":28},{"name":"lines-of-code","value":"207","count":28},{"name":"lines-of-code","value":"218","count":28},{"name":"lines-of-code","value":"222","count":28},{"name":"lines-of-code","value":"227","count":28},{"name":"lines-of-code","value":"228","count":28},{"name":"lines-of-code","value":"235","count":28},{"name":"lines-of-code","value":"240","count":28},{"name":"lines-of-code","value":"256","count":28},{"name":"lines-of-code","value":"257","count":28},{"name":"lines-of-code","value":"270","count":28},{"name":"lines-of-code","value":"271","count":28},{"name":"lines-of-code","value":"275","count":28},{"name":"lines-of-code","value":"307","count":28},{"name":"lines-of-code","value":"308","count":28},{"name":"lines-of-code","value":"329","count":28},{"name":"lines-of-code","value":"388","count":28},{"name":"tested-by","value":"_bt_check_rowcompare, _bt_check_rowcompare, pg_attribute_aclcheck_all_ext, pg_attribute_aclcheck_all_ext, check_publications, check_publications_origin, test_indoption, check_domain_for_new_field, che","count":28},{"name":"tested-by","value":"check_domain_for_new_tuple","count":28},{"name":"tested-by","value":"check_hash_func_signature","count":28},{"name":"tested-by","value":"check_log_destination","count":28},{"name":"tested-by","value":"check_null_keys, _bt_check_compare, check_exclusion_or_unique_constraint","count":28},{"name":"tested-by","value":"check_publisher, check_publisher, check_publisher, check_publisher, check_publisher, check_publisher, check_subscriber, check_subscriber, check_subscriber, check_subscriber, check_backup_label_files, ","count":28},{"name":"tested-by","value":"check_wal_segment_size","count":28},{"name":"tested-by","value":"exec_simple_check_plan","count":28},{"name":"tested-by","value":"truncate_check_perms","count":28},{"name":"api-example","value":"Datum array_out(PG_FUNCTION_ARGS) { AnyArrayType *v = PG_GETARG_ANY_ARRAY_P(0); Oid\t\t\telement_type = AARR_ELEMTYPE(v); int\t\t\ttyplen; bool\t\ttypbyval; char\t\ttypalign; char\t\ttypdelim; char\t   *p, *tmp, *...","count":27},{"name":"api-example","value":"Datum brin_summarize_new_values(PG_FUNCTION_ARGS) { Datum\t\trelation = PG_GETARG_DATUM(0); return DirectFunctionCall2(brin_summarize_range, relation, Int64GetDatum((int64) BRIN_ALL_BLOCKRANGES)); }","count":27},{"name":"api-example","value":"Datum ginarraytriconsistent(PG_FUNCTION_ARGS) { GinTernaryValue *check = (GinTernaryValue *) PG_GETARG_POINTER(0); StrategyNumber strategy = PG_GETARG_UINT16(1); int32\t\tnkeys = PG_GETARG_INT32(3); boo...","count":27},{"name":"api-example","value":"Datum multirange_in(PG_FUNCTION_ARGS) { char\t   *input_str = PG_GETARG_CSTRING(0); Oid\t\t\tmltrngtypoid = PG_GETARG_OID(1); Oid\t\t\ttypmod = PG_GETARG_INT32(2); Node\t   *escontext = fcinfo->context; TypeC...","count":27},{"name":"api-example","value":"Datum to_tsquery_byid(PG_FUNCTION_ARGS) { text\t   *in = PG_GETARG_TEXT_PP(1); TSQuery\t\tquery; MorphOpaque data; data.cfg_id = PG_GETARG_OID(0); * Passing OP_PHRASE as a qoperator makes tsquery require...","count":27},{"name":"api-example","value":"MemoryContext AllocSetContextCreateInternal(MemoryContext parent, const char *name, Size minContextSize, Size initBlockSize, Size maxBlockSize) { int\t\t\tfreeListIndex; Size\t\tfirstBlockSize; AllocSet\tse...","count":27},{"name":"api-example","value":"PyObject * PLy_cursor_plan(PyObject *ob, PyObject *args) { PLyCursorObject *cursor; volatile int nargs; PLyPlanObject *plan; PLyExecutionContext *exec_ctx = PLy_current_execution_context(); volatile M...","count":27},{"name":"api-example","value":"Size WALReadFromBuffers(char *dstbuf, XLogRecPtr startptr, Size count, TimeLineID tli) { char\t   *pdst = dstbuf; XLogRecPtr\trecptr = startptr; XLogRecPtr\tinserted; Size\t\tnbytes = count; if (RecoveryIn...","count":27},{"name":"api-example","value":"int CheckSASLAuth(const pg_be_sasl_mech *mech, Port *port, char *shadow_pass, const char **logdetail) { StringInfoData sasl_mechs; int\t\t\tmtype; StringInfoData buf; void\t   *opaq = NULL; char\t   *outpu...","count":27},{"name":"api-example","value":"int32 _bt_compare(Relation rel, BTScanInsert key, Page page, OffsetNumber offnum) { TupleDesc\titupdesc = RelationGetDescr(rel); BTPageOpaque opaque = BTPageGetOpaque(page); IndexTuple\titup; ItemPointe...","count":27},{"name":"api-example","value":"static XLogRecPtr XLogBytePosToRecPtr(uint64 bytepos) { uint64\t\tfullsegs; uint64\t\tfullpages; uint64\t\tbytesleft; uint32\t\tseg_offset; XLogRecPtr\tresult; fullsegs = bytepos / UsableBytesInSegment; bytesl...","count":27},{"name":"api-example","value":"static bool agg_refill_hash_table(AggState *aggstate) { HashAggBatch *batch; AggStatePerHash perhash; HashAggSpill spill; LogicalTapeSet *tapeset = aggstate->hash_tapeset; bool\t\tspill_initialized = fa...","count":27},{"name":"api-example","value":"static char parse_policy_command(const char *cmd_name) { char\t\tpolcmd; if (!cmd_name) elog(ERROR, \"unrecognized policy command\"); if (strcmp(cmd_name, \"all\") == 0) polcmd = '*'; else if (strcmp(cmd_na...","count":27},{"name":"api-example","value":"static inline bytea * cryptohash_internal(pg_cryptohash_type type, bytea *input) { const uint8 *data; const char *typestr = NULL; int\t\t\tdigest_len = 0; size_t\t\tlen; pg_cryptohash_ctx *ctx; bytea\t   *r...","count":27},{"name":"api-example","value":"static int ServerLoop(void) { time_t\t\tlast_lockfile_recheck_time, last_touch_time; WaitEvent\tevents[MAXLISTEN]; int\t\t\tnevents; ConfigurePostmasterWaitSet(true); last_lockfile_recheck_time = last_touch...","count":27},{"name":"api-example","value":"static int XLogFileInitInternal(XLogSegNo logsegno, TimeLineID logtli, bool *added, char *path) { char\t\ttmppath[MAXPGPATH]; XLogSegNo\tinstalled_segno; XLogSegNo\tmax_segno; int\t\t\tfd; int\t\t\tsave_errno; ...","count":27},{"name":"api-example","value":"static int euc_jis_20042shift_jis_2004(const unsigned char *euc, unsigned char *p, int len, bool noError) { const unsigned char *start = euc; int\t\t\tc1, ku, ten; int\t\t\tl; while (len > 0) { c1 = *euc; i...","count":27},{"name":"api-example","value":"static uint64 XLogRecPtrToBytePos(XLogRecPtr ptr) { uint64\t\tfullsegs; uint32\t\tfullpages; uint32\t\toffset; uint64\t\tresult; XLByteToSeg(ptr, fullsegs, wal_segment_size); fullpages = (XLogSegmentOffset(pt...","count":27},{"name":"api-example","value":"static void DCH_to_char(FormatNode *node, bool is_interval, TmToChar *in, char *out, Oid collid) { FormatNode *n; char\t   *s; struct fmt_tm *tm = &in->tm; int\t\t\ti; cache_locale_time(); s = out; for (n...","count":27},{"name":"api-example","value":"static void ExecInitExprRec(Expr *node, ExprState *state, Datum *resv, bool *resnull) { ExprEvalStep scratch = {0}; check_stack_depth(); Assert(resv != NULL && resnull != NULL); scratch.resvalue = res...","count":27},{"name":"api-example","value":"static void InitPlan(QueryDesc *queryDesc, int eflags) { CmdType\t\toperation = queryDesc->operation; PlannedStmt *plannedstmt = queryDesc->plannedstmt; Plan\t   *plan = plannedstmt->planTree; List\t   *r...","count":27},{"name":"api-example","value":"static void parse_subscription_options(ParseState *pstate, List *stmt_options, bits32 supported_opts, SubOpts *opts) { ListCell   *lc; memset(opts, 0, sizeof(SubOpts)); Assert(supported_opts != 0); As...","count":27},{"name":"api-example","value":"static void pushval_morph(Datum opaque, TSQueryParserState state, char *strval, int lenval, int16 weight, bool prefix) { int32\t\tcount = 0; ParsedText\tprs; uint32\t\tvariant, pos = 0, cntvar = 0, cntpos ...","count":27},{"name":"api-example","value":"void AutoVacLauncherMain(char *startup_data, size_t startup_data_len) { sigjmp_buf\tlocal_sigjmp_buf; Assert(startup_data_len == 0); if (PostmasterContext) { MemoryContextDelete(PostmasterContext); Pos...","count":27},{"name":"api-example","value":"void ExecVacuum(ParseState *pstate, VacuumStmt *vacstmt, bool isTopLevel) { VacuumParams params; BufferAccessStrategy bstrategy = NULL; bool\t\tverbose = false; bool\t\tskip_locked = false; bool\t\tanalyze ...","count":27},{"name":"api-example","value":"void ExplainOnePlan(PlannedStmt *plannedstmt, IntoClause *into, ExplainState *es, const char *queryString, ParamListInfo params, QueryEnvironment *queryEnv, const instr_time *planduration, const Buffe...","count":27},{"name":"api-example","value":"void heap2_redo(XLogReaderState *record) { uint8\t\tinfo = XLogRecGetInfo(record) & ~XLR_INFO_MASK; switch (info & XLOG_HEAP_OPMASK) { case XLOG_HEAP2_PRUNE_ON_ACCESS: case XLOG_HEAP2_PRUNE_VACUUM_SCAN:...","count":27},{"name":"api-example","value":"void reindex_index(const ReindexStmt *stmt, Oid indexId, bool skip_constraint_checks, char persistence, const ReindexParams *params) { Relation\tiRel, heapRelation; Oid\t\t\theapId; Oid\t\t\tsave_userid; int...","count":27},{"name":"api-example","value":"void standby_desc(StringInfo buf, XLogReaderState *record) { char\t   *rec = XLogRecGetData(record); uint8\t\tinfo = XLogRecGetInfo(record) & ~XLR_INFO_MASK; if (info == XLOG_STANDBY_LOCK) { xl_standby_l...","count":27},{"name":"Feature","value":"Replication Slots","count":26},{"name":"Feature","value":"ALTER SYSTEM","count":25},{"name":"Feature","value":"Point-in-Time Recovery","count":25},{"name":"subsystem-desc","value":"src/backend/storage/buffer/README\n\nNotes About Shared Buffer Access Rules\n======================================\n\nThere are two separate access control mechanisms for shared disk buffers:\nreference counts (a/k/a pin counts) and buffer content locks.  (Actually,\nthere's a third level of access control: one must hold the appropriate kind\nof lock on a relation before one can legally access any page belonging to\nthe relation.  Relation-level locks are not discussed here.)\n\nPins: one must \"hold a pin on\" a buffer (increment its reference count)\nbefore being allowed to do anything at all with it.  An unpinned buffer is\nsubject to being reclaimed and reused for a different page at any instant,\nso touching it is unsafe.  Normally a pin is acquired via ReadBuffer and\nreleased via ReleaseBuffer.  It is OK and indeed common for a single\nbackend to pin a page more than once concurrently; the buffer manager\nhandles this efficiently.  It is considered OK to hold a pin for long\nintervals --- for example, sequential scans hold a pin on the current page\nuntil done processing all the tuples on the page, which could be quite a\nwhile if the scan is the outer scan of a join.  Similarly, a btree index\nscan may hold a pin on the current index page.  This is OK because normal\noperations never wait for a page's pin count to drop to zero.  (Anything\nthat might need to do such a wait is instead handled by waiting to obtain\nthe relation-level lock, which is why you'd better hold one first.)  Pins\nmay not be held across transaction boundaries, however.\n\nBuffer content locks: there are two kinds of buffer lock, shared and exclusive,\nwhich act just as you'd expect: multiple backends can hold shared locks on\nthe same buffer, but an exclusive lock prevents anyone else from holding\neither shared or exclusive lock.  (These can alternatively be called READ\nand WRITE locks.)  These locks are intended to be short-term: they should not\nbe held for long.  Buffer locks are acquired and released by LockBuffer().\nIt will *not* work for a single backend to try to acquire multiple locks on\nthe same buffer.  One must pin a buffer before trying to lock it.\n\nBuffer access rules:\n\n1. To scan a page for tuples, one must hold a pin and either shared or\nexclusive content lock.  To examine the commit status (XIDs and status bits)\nof a tuple in a shared buffer, one must likewise hold a pin and either shared\nor exclusive lock.\n\n2. Once one has determined that a tuple is interesting (visible to the\ncurrent transaction) one may drop the content lock, yet continue to access\nthe tuple's data for as long as one holds the buffer pin.  This is what is\ntypically done by heap scans, since the tuple returned by heap_fetch\ncontains a pointer to tuple data in the shared buffer.  Therefore the\ntuple cannot go away while the pin is held (see rule #5).  Its state could\nchange, but that is assumed not to matter after the initial determination\nof visibility is made.\n\n3. To add a tuple or change the xmin/xmax fields of an existing tuple,\none must hold a pin and an exclusive content lock on the containing buffer.\nThis ensures that no one else might see a partially-updated state of the\ntuple while they are doing visibility checks.\n\n4. It is considered OK to update tuple commit status bits (ie, OR the\nvalues HEAP_XMIN_COMMITTED, HEAP_XMIN_INVALID, HEAP_XMAX_COMMITTED, or\nHEAP_XMAX_INVALID into t_infomask) while holding only a shared lock and\npin on a buffer.  This is OK because another backend looking at the tuple\nat about the same time would OR the same bits into the field, so there\nis little or no risk of conflicting update; what's more, if there did\nmanage to be a conflict it would merely mean that one bit-update would\nbe lost and need to be done again later.  These four bits are only hints\n(they cache the results of transaction status lookups in pg_xact), so no\ngreat harm is done if they get reset to zero by conflicting updates.\nNote, however, that a tuple is frozen by setting both HEAP_XMIN_INVALID\nand HEAP_XMIN_COMMITTED; this is a critical update and accordingly requires\nan exclusive buffer lock (and it must also be WAL-logged).\n\n5. To physically remove a tuple or compact free space on a page, one\nmust hold a pin and an exclusive lock, *and* observe while holding the\nexclusive lock that the buffer's shared reference count is one (ie,\nno other backend holds a pin).  If these conditions are met then no other\nbackend can perform a page scan until the exclusive lock is dropped, and\nno other backend can be holding a reference to an existing tuple that it\nmight expect to examine again.  Note that another backend might pin the\nbuffer (increment the refcount) while one is performing the cleanup, but\nit won't be able to actually examine the page until it acquires shared\nor exclusive content lock.\n\n\nObtaining the lock needed under rule #5 is done by the bufmgr routines\nLockBufferForCleanup() or ConditionalLockBufferForCleanup().  They first get\nan exclusive lock and then check to see if the shared pin count is currently\n1.  If not, ConditionalLockBufferForCleanup() releases the exclusive lock and\nthen returns false, while LockBufferForCleanup() releases the exclusive lock\n(but not the caller's pin) and waits until signaled by another backend,\nwhereupon it tries again.  The signal will occur when UnpinBuffer decrements\nthe shared pin count to 1.  As indicated above, this operation might have to\nwait a good while before it acquires the lock, but that shouldn't matter much\nfor concurrent VACUUM.  The current implementation only supports a single\nwaiter for pin-count-1 on any particular shared buffer.  This is enough for\nVACUUM's use, since we don't allow multiple VACUUMs concurrently on a single\nrelation anyway.  Anyone wishing to obtain a cleanup lock outside of recovery\nor a VACUUM must use the conditional variant of the function.\n\n\nBuffer Manager's Internal Locking\n---------------------------------\n\nBefore PostgreSQL 8.1, all operations of the shared buffer manager itself\nwere protected by a single system-wide lock, the BufMgrLock, which\nunsurprisingly proved to be a source of contention.  The new locking scheme\navoids grabbing system-wide exclusive locks in common code paths.  It works\nlike this:\n\n* There is a system-wide LWLock, the BufMappingLock, that notionally\nprotects the mapping from buffer tags (page identifiers) to buffers.\n(Physically, it can be thought of as protecting the hash table maintained\nby buf_table.c.)  To look up whether a buffer exists for a tag, it is\nsufficient to obtain share lock on the BufMappingLock.  Note that one\nmust pin the found buffer, if any, before releasing the BufMappingLock.\nTo alter the page assignment of any buffer, one must hold exclusive lock\non the BufMappingLock.  This lock must be held across adjusting the buffer's\nheader fields and changing the buf_table hash table.  The only common\noperation that needs exclusive lock is reading in a page that was not\nin shared buffers already, which will require at least a kernel call\nand usually a wait for I/O, so it will be slow anyway.\n\n* As of PG 8.2, the BufMappingLock has been split into NUM_BUFFER_PARTITIONS\nseparate locks, each guarding a portion of the buffer tag space.  This allows\nfurther reduction of contention in the normal code paths.  The partition\nthat a particular buffer tag belongs to is determined from the low-order\nbits of the tag's hash value.  The rules stated above apply to each partition\nindependently.  If it is necessary to lock more than one partition at a time,\nthey must be locked in partition-number order to avoid risk of deadlock.\n\n* A separate system-wide spinlock, buffer_strategy_lock, provides mutual\nexclusion for operations that access the buffer free list or select\nbuffers for replacement.  A spinlock is used here rather than a lightweight\nlock for efficiency; no other locks of any sort should be acquired while\nbuffer_strategy_lock is held.  This is essential to allow buffer replacement\nto happen in multiple backends with reasonable concurrency.\n\n* Each buffer header contains a spinlock that must be taken when examining\nor changing fields of that buffer header.  This allows operations such as\nReleaseBuffer to make local state changes without taking any system-wide\nlock.  We use a spinlock, not an LWLock, since there are no cases where\nthe lock needs to be held for more than a few instructions.\n\nNote that a buffer header's spinlock does not control access to the data\nheld within the buffer.  Each buffer header also contains an LWLock, the\n\"buffer content lock\", that *does* represent the right to access the data\nin the buffer.  It is used per the rules above.\n\n* The BM_IO_IN_PROGRESS flag acts as a kind of lock, used to wait for I/O on a\nbuffer to complete (and in releases before 14, it was accompanied by a\nper-buffer LWLock).  The process doing a read or write sets the flag for the\nduration, and processes that need to wait for it to be cleared sleep on a\ncondition variable.\n\n\nNormal Buffer Replacement Strategy\n----------------------------------\n\nThere is a \"free list\" of buffers that are prime candidates for replacement.\nIn particular, buffers that are completely free (contain no valid page) are\nalways in this list.  We could also throw buffers into this list if we\nconsider their pages unlikely to be needed soon; however, the current\nalgorithm never does that.  The list is singly-linked using fields in the\nbuffer headers; we maintain head and tail pointers in global variables.\n(Note: although the list links are in the buffer headers, they are\nconsidered to be protected by the buffer_strategy_lock, not the buffer-header\nspinlocks.)  To choose a victim buffer to recycle when there are no free\nbuffers available, we use a simple clock-sweep algorithm, which avoids the\nneed to take system-wide locks during common operations.  It works like\nthis:\n\nEach buffer header contains a usage counter, which is incremented (up to a\nsmall limit value) whenever the buffer is pinned.  (This requires only the\nbuffer header spinlock, which would have to be taken anyway to increment the\nbuffer reference count, so it's nearly free.)\n\nThe \"clock hand\" is a buffer index, nextVictimBuffer, that moves circularly\nthrough all the available buffers.  nextVictimBuffer is protected by the\nbuffer_strategy_lock.\n\nThe algorithm for a process that needs to obtain a victim buffer is:\n\n1. Obtain buffer_strategy_lock.\n\n2. If buffer free list is nonempty, remove its head buffer.  Release\nbuffer_strategy_lock.  If the buffer is pinned or has a nonzero usage count,\nit cannot be used; ignore it go back to step 1.  Otherwise, pin the buffer,\nand return it.\n\n3. Otherwise, the buffer free list is empty.  Select the buffer pointed to by\nnextVictimBuffer, and circularly advance nextVictimBuffer for next time.\nRelease buffer_strategy_lock.\n\n4. If the selected buffer is pinned or has a nonzero usage count, it cannot\nbe used.  Decrement its usage count (if nonzero), reacquire\nbuffer_strategy_lock, and return to step 3 to examine the next buffer.\n\n5. Pin the selected buffer, and return.\n\n(Note that if the selected buffer is dirty, we will have to write it out\nbefore we can recycle it; if someone else pins the buffer meanwhile we will\nhave to give up and try another buffer.  This however is not a concern\nof the basic select-a-victim-buffer algorithm.)\n\n\nBuffer Ring Replacement Strategy\n---------------------------------\n\nWhen running a query that needs to access a large number of pages just once,\nsuch as VACUUM or a large sequential scan, a different strategy is used.\nA page that has been touched only by such a scan is unlikely to be needed\nagain soon, so instead of running the normal clock sweep algorithm and\nblowing out the entire buffer cache, a small ring of buffers is allocated\nusing the normal clock sweep algorithm and those buffers are reused for the\nwhole scan.  This also implies that much of the write traffic caused by such\na statement will be done by the backend itself and not pushed off onto other\nprocesses.\n\nFor sequential scans, a 256KB ring is used. That's small enough to fit in L2\ncache, which makes transferring pages from OS cache to shared buffer cache\nefficient.  Even less would often be enough, but the ring must be big enough\nto accommodate all pages in the scan that are pinned concurrently.  256KB\nshould also be enough to leave a small cache trail for other backends to\njoin in a synchronized seq scan.  If a ring buffer is dirtied and its LSN\nupdated, we would normally have to write and flush WAL before we could\nre-use the buffer; in this case we instead discard the buffer from the ring\nand (later) choose a replacement using the normal clock-sweep algorithm.\nHence this strategy works best for scans that are read-only (or at worst\nupdate hint bits).  In a scan that modifies every page in the scan, like a\nbulk UPDATE or DELETE, the buffers in the ring will always be dirtied and\nthe ring strategy effectively degrades to the normal strategy.\n\nVACUUM uses a ring like sequential scans, however, the size of this ring is\ncontrolled by the vacuum_buffer_usage_limit GUC.  Dirty pages are not removed\nfrom the ring.  Instead, WAL is flushed if needed to allow reuse of the\nbuffers.  Before introducing the buffer ring strategy in 8.3, VACUUM's buffers\nwere sent to the freelist, which was effectively a buffer ring of 1 buffer,\nresulting in excessive WAL flushing.\n\nBulk writes work similarly to VACUUM.  Currently this applies only to\nCOPY IN and CREATE TABLE AS SELECT.  (Might it be interesting to make\nseqscan UPDATE and DELETE use the bulkwrite strategy?)  For bulk writes\nwe use a ring size of 16MB (but not more than 1/8th of shared_buffers).\nSmaller sizes have been shown to result in the COPY blocking too often\nfor WAL flushes.  While it's okay for a background vacuum to be slowed by\ndoing its own WAL flushing, we'd prefer that COPY not be subject to that,\nso we let it use up a bit more of the buffer arena.\n\n\nBackground Writer's Processing\n------------------------------\n\nThe background writer is designed to write out pages that are likely to be\nrecycled soon, thereby offloading the writing work from active backends.\nTo do this, it scans forward circularly from the current position of\nnextVictimBuffer (which it does not change!), looking for buffers that are\ndirty and not pinned nor marked with a positive usage count.  It pins,\nwrites, and releases any such buffer.\n\nIf we can assume that reading nextVictimBuffer is an atomic action, then\nthe writer doesn't even need to take buffer_strategy_lock in order to look\nfor buffers to write; it needs only to spinlock each buffer header for long\nenough to check the dirtybit.  Even without that assumption, the writer\nonly needs to take the lock long enough to read the variable value, not\nwhile scanning the buffers.  (This is a very substantial improvement in\nthe contention cost of the writer compared to PG 8.0.)\n\nThe background writer takes shared content lock on a buffer while writing it\nout (and anyone else who flushes buffer contents to disk must do so too).\nThis ensures that the page image transferred to disk is reasonably consistent.\nWe might miss a hint-bit update or two but that isn't a problem, for the same\nreasons mentioned under buffer access rules.\n\nAs of 8.4, background writer starts during recovery mode when there is\nsome form of potentially extended recovery to perform. It performs an\nidentical service to normal processing, except that checkpoints it\nwrites are technically restartpoints.","count":25},{"name":"subsystem-name","value":"buffer","count":25},{"name":"subsystem-path","value":"backend/storage/buffer/readme","count":25},{"name":"Feature","value":"NULLs in Array","count":24},{"name":"api-caller-count","value":"1392","count":24},{"name":"api-caller-count","value":"1934","count":24},{"name":"api-caller-count","value":"229","count":24},{"name":"api-caller-count","value":"232","count":24},{"name":"api-caller-count","value":"60","count":24},{"name":"api-caller-count","value":"665","count":24},{"name":"api-caller-count","value":"859","count":24},{"name":"api-example","value":"Datum brin_bloom_consistent(PG_FUNCTION_ARGS) { BrinDesc   *bdesc = (BrinDesc *) PG_GETARG_POINTER(0); BrinValues *column = (BrinValues *) PG_GETARG_POINTER(1); ScanKey    *keys = (ScanKey *) PG_GETAR...","count":24},{"name":"api-example","value":"Datum brin_minmax_multi_distance_interval(PG_FUNCTION_ARGS) { float8\t\tdelta = 0; Interval   *ia = PG_GETARG_INTERVAL_P(0); Interval   *ib = PG_GETARG_INTERVAL_P(1); int64\t\tdayfraction; int64\t\tdays; * ...","count":24},{"name":"api-example","value":"Datum gist_point_consistent(PG_FUNCTION_ARGS) { GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0); StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2); bool\t   *recheck = (bool *) PG_G...","count":24},{"name":"api-example","value":"Datum numeric_in(PG_FUNCTION_ARGS) { char\t   *str = PG_GETARG_CSTRING(0); #ifdef NOT_USED Oid\t\t\ttypelem = PG_GETARG_OID(1); #endif int32\t\ttypmod = PG_GETARG_INT32(2); Node\t   *escontext = fcinfo->cont...","count":24},{"name":"api-example","value":"Datum pg_backup_start(PG_FUNCTION_ARGS) { text\t   *backupid = PG_GETARG_TEXT_PP(0); bool\t\tfast = PG_GETARG_BOOL(1); char\t   *backupidstr; SessionBackupState status = get_backup_status(); MemoryContext...","count":24},{"name":"api-example","value":"Datum pg_promote(PG_FUNCTION_ARGS) { bool\t\twait = PG_GETARG_BOOL(0); int\t\t\twait_seconds = PG_GETARG_INT32(1); FILE\t   *promote_file; int\t\t\ti; if (!RecoveryInProgress()) ereport(ERROR, (errcode(ERRCODE...","count":24},{"name":"api-example","value":"Datum unicode_assigned(PG_FUNCTION_ARGS) { text\t   *input = PG_GETARG_TEXT_PP(0); unsigned char *p; int\t\t\tsize; if (GetDatabaseEncoding() != PG_UTF8) ereport(ERROR, (errmsg(\"Unicode categorization can...","count":24},{"name":"api-example","value":"FILE * open_auth_file(const char *filename, int elevel, int depth, char **err_msg) { FILE\t   *file; * Reject too-deep include nesting depth.  This is just a safety check to * avoid dumping core due to...","count":24},{"name":"api-example","value":"IndexTuple CopyIndexTuple(IndexTuple source) { IndexTuple\tresult; Size\t\tsize; size = IndexTupleSize(source); result = (IndexTuple) palloc(size); memcpy(result, source, size); return result; }","count":24},{"name":"api-example","value":"List * readTimeLineHistory(TimeLineID targetTLI) { List\t   *result; char\t\tpath[MAXPGPATH]; char\t\thistfname[MAXFNAMELEN]; FILE\t   *fd; TimeLineHistoryEntry *entry; TimeLineID\tlasttli = 0; XLogRecPtr\tpr...","count":24},{"name":"api-example","value":"Oid createdb(ParseState *pstate, const CreatedbStmt *stmt) { Oid\t\t\tsrc_dboid; Oid\t\t\tsrc_owner; int\t\t\tsrc_encoding = -1; char\t   *src_collate = NULL; char\t   *src_ctype = NULL; char\t   *src_locale = NU...","count":24},{"name":"api-example","value":"PostgresPollingStatusType PQconnectPoll(PGconn *conn) { bool\t\treset_connection_state_machine = false; bool\t\tneed_new_connection = false; PGresult   *res; char\t\tsebuf[PG_STRERROR_R_BUFLEN]; int\t\t\toptva...","count":24},{"name":"api-example","value":"RelOptInfo * make_one_rel(PlannerInfo *root, List *joinlist) { RelOptInfo *rel; Index\t\trti; double\t\ttotal_pages; set_base_rel_consider_startup(root); * Compute size estimates and consider_parallel fla...","count":24},{"name":"api-example","value":"Relation try_relation_open(Oid relationId, LOCKMODE lockmode) { Relation\tr; Assert(lockmode >= NoLock && lockmode < MAX_LOCKMODES); if (lockmode != NoLock) LockRelationOid(relationId, lockmode); * Now...","count":24},{"name":"api-example","value":"XLogRecPtr log_heap_visible(Relation rel, Buffer heap_buffer, Buffer vm_buffer, TransactionId snapshotConflictHorizon, uint8 vmflags) { xl_heap_visible xlrec; XLogRecPtr\trecptr; uint8\t\tflags; Assert(B...","count":24},{"name":"api-example","value":"bool ECPGconnect(int lineno, int c, const char *name, const char *user, const char *passwd, const char *connection_name, int autocommit) { struct sqlca_t *sqlca = ECPGget_sqlca(); enum COMPAT_MODE com...","count":24},{"name":"api-example","value":"bool ReadRecentBuffer(RelFileLocator rlocator, ForkNumber forkNum, BlockNumber blockNum, Buffer recent_buffer) { BufferDesc *bufHdr; BufferTag\ttag; uint32\t\tbuf_state; bool\t\thave_private_ref; Assert(Bu...","count":24},{"name":"api-example","value":"bool brin_start_evacuating_page(Relation idxRel, Buffer buf) { OffsetNumber off; OffsetNumber maxoff; Page\t\tpage; page = BufferGetPage(buf); if (PageIsNew(page)) return false; maxoff = PageGetMaxOffse...","count":24},{"name":"api-example","value":"bool check_amproc_signature(Oid funcid, Oid restype, bool exact, int minargs, int maxargs,...) { bool\t\tresult = true; HeapTuple\ttp; Form_pg_proc procform; va_list\t\tap; int\t\t\ti; tp = SearchSysCache1(PR...","count":24},{"name":"api-example","value":"bool function_parse_error_transpose(const char *prosrc) { int\t\t\torigerrposition; int\t\t\tnewerrposition; * Nothing to do unless we are dealing with a syntax error that has a * cursor position. * * Some ...","count":24},{"name":"api-example","value":"bool heap_inplace_lock(Relation relation, HeapTuple oldtup_ptr, Buffer buffer, void (*release_callback) (void *), void *arg) { HeapTupleData oldtup = *oldtup_ptr; /* minimize diff vs. heap_update() */...","count":24},{"name":"api-example","value":"int be_tls_init(bool isServerStart) { SSL_CTX    *context; int\t\t\tssl_ver_min = -1; int\t\t\tssl_ver_max = -1; if (!SSL_initialized) { #ifdef HAVE_OPENSSL_INIT_SSL OPENSSL_init_ssl(OPENSSL_INIT_LOAD_CONFI...","count":24},{"name":"api-example","value":"int main(int argc, char *argv[]) { bool\t\tdo_check_root = true; reached_main = true; * If supported on the current platform, set up a handler to be called if * the backend/postmaster crashes with a fat...","count":24},{"name":"api-example","value":"int pgtypes_fmt_replace(union un_fmt_comb replace_val, int replace_type, char **output, int *pstr_len) { * general purpose variable, set to 0 in order to fix compiler warning */ int\t\t\ti = 0; switch (r...","count":24},{"name":"api-example","value":"ssize_t secure_open_gssapi(Port *port) { bool\t\tcomplete_next = false; OM_uint32\tmajor, minor; gss_cred_id_t delegated_creds; * Allocate subsidiary Port data for GSSAPI operations. */ port->gss = (pg_g...","count":24},{"name":"api-example","value":"static Acl * merge_acl_with_grant(Acl *old_acl, bool is_grant, bool grant_option, DropBehavior behavior, List *grantees, AclMode privileges, Oid grantorId, Oid ownerId) { unsigned\tmodechg; ListCell   ...","count":24},{"name":"api-example","value":"static Datum pltcl_func_handler(PG_FUNCTION_ARGS, pltcl_call_state *call_state, bool pltrusted) { bool\t\tnonatomic; pltcl_proc_desc *prodesc; Tcl_Interp *volatile interp; Tcl_Obj    *tcl_cmd; int\t\t\ti; ...","count":24},{"name":"api-example","value":"static JsonPathExecResult executeItemOptUnwrapTarget(JsonPathExecContext *cxt, JsonPathItem *jsp, JsonbValue *jb, JsonValueList *found, bool unwrap) { JsonPathItem elem; JsonPathExecResult res = jperN...","count":24},{"name":"api-example","value":"static List * MergeAttributes(List *columns, const List *supers, char relpersistence, bool is_partition, List **supconstr) { List\t   *inh_columns = NIL; List\t   *constraints = NIL; bool\t\thave_bogus_de...","count":24},{"name":"api-example","value":"static List * objectNamesToOids(ObjectType objtype, List *objnames, bool is_grant) { List\t   *objects = NIL; ListCell   *cell; Assert(objnames != NIL); switch (objtype) { case OBJECT_TABLE: case OBJEC...","count":24},{"name":"api-example","value":"static ObjectAddress ATAddForeignKeyConstraint(List **wqueue, AlteredTableInfo *tab, Relation rel, Constraint *fkconstraint, bool recurse, bool recursing, LOCKMODE lockmode) { Relation\tpkrel; int16\t\tp...","count":24},{"name":"api-example","value":"static TM_Result heapam_tuple_lock(Relation relation, ItemPointer tid, Snapshot snapshot, TupleTableSlot *slot, CommandId cid, LockTupleMode mode, LockWaitPolicy wait_policy, uint8 flags, TM_FailureDa...","count":24},{"name":"api-example","value":"static bool doPickSplit(Relation index, SpGistState *state, SPPageDesc *current, SPPageDesc *parent, SpGistLeafTuple newLeafTuple, int level, bool isNulls, bool isNew) { bool\t\tinsertedNew = false; spg...","count":24},{"name":"api-example","value":"static bool recoveryApplyDelay(XLogReaderState *record) { uint8\t\txact_info; TimestampTz xtime; TimestampTz delayUntil; long\t\tmsecs; if (recovery_min_apply_delay <= 0) return false; if (!reachedConsist...","count":24},{"name":"api-example","value":"static char * GetXLogBuffer(XLogRecPtr ptr, TimeLineID tli) { int\t\t\tidx; XLogRecPtr\tendptr; static uint64 cachedPage = 0; static char *cachedPos = NULL; XLogRecPtr\texpectedEndPtr; * Fast path for the ...","count":24},{"name":"api-example","value":"static dsa_pointer SerializeParamExecParams(EState *estate, Bitmapset *params, dsa_area *area) { Size\t\tsize; int\t\t\tnparams; int\t\t\tparamid; ParamExecData *prm; dsa_pointer handle; char\t   *start_addres...","count":24},{"name":"api-example","value":"static inline void CopySendInt32(CopyToState cstate, int32 val) { uint32\t\tbuf; buf = pg_hton32((uint32) val); CopySendData(cstate, &buf, sizeof(buf)); }","count":24},{"name":"api-example","value":"static int\t\t\t\t\t\t/* 1 normal, 0 failure */ next(struct vars *v) { chr\t\t\tc; next_restart:\t\t\t\t\t/* loop here after eating a comment */ if (ISERR()) return 0;\t\t\t\t/* the error has set nexttype to EOS */ v->...","count":24},{"name":"api-example","value":"static int SocketBackend(StringInfo inBuf) { int\t\t\tqtype; int\t\t\tmaxmsglen; * Get message type code from the frontend. */ HOLD_CANCEL_INTERRUPTS(); pq_startmsgread(); qtype = pq_getbyte(); if (qtype ==...","count":24},{"name":"api-example","value":"static int create_collation_from_locale(const char *locale, int nspid, int *nvalidp, int *ncreatedp) { int\t\t\tenc; Oid\t\t\tcollid; * Some systems have locale names that don't consist entirely of ASCII * ...","count":24},{"name":"api-example","value":"static std::unique_ptr<ImportMapTy> llvm_build_inline_plan(LLVMContextRef lc, llvm::Module *mod) { std::unique_ptr<ImportMapTy> globalsToInline(new ImportMapTy()); FunctionInlineStates functionStates;...","count":24},{"name":"api-example","value":"static struct cvec * range(struct vars *v,\t\t\t/* context */ chr a,\t\t\t\t\t/* range start */ chr b,\t\t\t\t\t/* range end, might equal a */ int cases)\t\t\t\t/* case-independent? */ { int\t\t\tnchrs; struct cvec *cv; ...","count":24},{"name":"api-example","value":"static void ATPrepCmd(List **wqueue, Relation rel, AlterTableCmd *cmd, bool recurse, bool recursing, LOCKMODE lockmode, AlterTableUtilityContext *context) { AlteredTableInfo *tab; AlterTablePass pass ...","count":24},{"name":"api-example","value":"static void CopySendChar(CopyToState cstate, char c) { appendStringInfoCharMacro(cstate->fe_msgbuf, c); }","count":24},{"name":"api-example","value":"static void InitControlFile(uint64 sysidentifier) { char\t\tmock_auth_nonce[MOCK_AUTH_NONCE_LEN]; * Generate a random nonce. This is used for authentication requests that * will fail because the user do...","count":24},{"name":"api-example","value":"static void advanceConnectionState(TState *thread, CState *st, StatsData *agg) { * gettimeofday() isn't free, so we get the current timestamp lazily the * first time it's needed, and reuse the same va...","count":24},{"name":"api-example","value":"static void dead_items_alloc(LVRelState *vacrel, int nworkers) { VacDeadItemsInfo *dead_items_info; int\t\t\tvac_work_mem = AmAutoVacuumWorkerProcess() && autovacuum_work_mem != -1 ? autovacuum_work_mem ...","count":24},{"name":"api-example","value":"static void freecm(struct colormap *cm) { cm->magic = 0; if (cm->cd != cm->cdspace) FREE(cm->cd); if (cm->locolormap != NULL) FREE(cm->locolormap); if (cm->cmranges != NULL) FREE(cm->cmranges); if (cm...","count":24},{"name":"api-example","value":"static void ginScanKeyAddHiddenEntry(GinScanOpaque so, GinScanKey key, GinNullCategory queryCategory) { int\t\t\ti = key->nentries++; key->scanEntry[i] = ginFillScanEntry(so, key->attnum, InvalidStrategy...","count":24},{"name":"api-example","value":"void AddFileToBackupManifest(backup_manifest_info *manifest, Oid spcoid, const char *pathname, size_t size, pg_time_t mtime, pg_checksum_context *checksum_ctx) { char\t\tpathbuf[MAXPGPATH]; int\t\t\tpathle...","count":24},{"name":"api-example","value":"void ClientAuthentication(Port *port) { int\t\t\tstatus = STATUS_ERROR; const char *logdetail = NULL; * Get the authentication method to use for this frontend/database * combination.  Note: we do not par...","count":24},{"name":"api-example","value":"void InitBufTable(int size) { HASHCTL\t\tinfo; info.keysize = sizeof(BufferTag); info.entrysize = sizeof(BufferLookupEnt); info.num_partitions = NUM_BUFFER_PARTITIONS; SharedBufHash = ShmemInitHash(\"Sha...","count":24},{"name":"api-example","value":"void InsertPgAttributeTuples(Relation pg_attribute_rel, TupleDesc tupdesc, Oid new_rel_oid, const FormExtraData_pg_attribute tupdesc_extra[], CatalogIndexState indstate) { TupleTableSlot **slot; Tuple...","count":24},{"name":"api-example","value":"void PerformPortalFetch(FetchStmt *stmt, DestReceiver *dest, QueryCompletion *qc) { Portal\t\tportal; uint64\t\tnprocessed; * Disallow empty-string cursor name (conflicts with protocol-level * unnamed por...","count":24},{"name":"api-example","value":"void TidStoreSetBlockOffsets(TidStore *ts, BlockNumber blkno, OffsetNumber *offsets, int num_offsets) { union { char\t\tdata[MaxBlocktableEntrySize]; BlocktableEntry force_align_entry; }\t\t\tdata; Blockta...","count":24},{"name":"api-example","value":"void TupleDescInitBuiltinEntry(TupleDesc desc, AttrNumber attributeNumber, const char *attributeName, Oid oidtypeid, int32 typmod, int attdim) { Form_pg_attribute att; Assert(PointerIsValid(desc)); As...","count":24},{"name":"api-example","value":"void _bt_dedup_pass(Relation rel, Buffer buf, IndexTuple newitem, Size newitemsz, bool bottomupdedup) { OffsetNumber offnum, minoff, maxoff; Page\t\tpage = BufferGetPage(buf); BTPageOpaque opaque = BTPa...","count":24},{"name":"api-example","value":"void add_paths_to_append_rel(PlannerInfo *root, RelOptInfo *rel, List *live_childrels) { List\t   *subpaths = NIL; bool\t\tsubpaths_valid = true; List\t   *startup_subpaths = NIL; bool\t\tstartup_subpaths_v...","count":24},{"name":"api-example","value":"void gistXLogPageReuse(Relation rel, Relation heaprel, BlockNumber blkno, FullTransactionId deleteXid) { gistxlogPageReuse xlrec_reuse; * Note that we don't register the buffer with the record, becaus...","count":24},{"name":"api-example","value":"void index_drop(Oid indexId, bool concurrent, bool concurrent_lock_mode) { Oid\t\t\theapId; Relation\tuserHeapRelation; Relation\tuserIndexRelation; Relation\tindexRelation; HeapTuple\ttuple; bool\t\thasexprs;...","count":24},{"name":"api-example","value":"void initGinState(GinState *state, Relation index) { TupleDesc\torigTupdesc = RelationGetDescr(index); int\t\t\ti; MemSet(state, 0, sizeof(GinState)); state->index = index; state->oneCol = (origTupdesc->n...","count":24},{"name":"api-example","value":"void multirange_get_bounds(TypeCacheEntry *rangetyp, const MultirangeType *multirange, uint32 i, RangeBound *lower, RangeBound *upper) { uint32\t\toffset; uint8\t\tflags; Pointer\t\tptr; int16\t\ttyplen = ran...","count":24},{"name":"api-example","value":"void write_stderr(const char *fmt,...) { va_list\t\tap; #ifdef WIN32 char\t\terrbuf[2048];\t/* Arbitrary size? */ #endif fmt = _(fmt); va_start(ap, fmt); #ifndef WIN32 vfprintf(stderr, fmt, ap); fflush(std...","count":24},{"name":"api-typical-usage","value":"Often called from: &","count":24},{"name":"api-typical-usage","value":"Often called from: ATPrepCmd","count":24},{"name":"api-typical-usage","value":"Often called from: AlterSubscription","count":24},{"name":"api-typical-usage","value":"Often called from: BufferUsageAccumDiff","count":24},{"name":"api-typical-usage","value":"Often called from: CheckTargetForConflictsIn","count":24},{"name":"api-typical-usage","value":"Often called from: DecodeTimeOnly","count":24},{"name":"api-typical-usage","value":"Often called from: ECPGget_desc","count":24},{"name":"api-typical-usage","value":"Often called from: ExecInitMaterial","count":24},{"name":"api-typical-usage","value":"Often called from: ExecParallelHashIncreaseNumBatches","count":24},{"name":"api-typical-usage","value":"Often called from: ExecScan","count":24},{"name":"api-typical-usage","value":"Often called from: ExecSetParamPlan","count":24},{"name":"api-typical-usage","value":"Often called from: ExecVacuum","count":24},{"name":"api-typical-usage","value":"Often called from: ExplainPrintJIT","count":24},{"name":"api-typical-usage","value":"Often called from: GetSnapshotData","count":24},{"name":"api-typical-usage","value":"Often called from: OpernameGetOprid","count":24},{"name":"api-typical-usage","value":"Often called from: PLy_cursor_query","count":24},{"name":"api-typical-usage","value":"Often called from: PLy_output","count":24},{"name":"api-typical-usage","value":"Often called from: PQescapeStringInternal","count":24},{"name":"api-typical-usage","value":"Often called from: PageTruncateLinePointerArray","count":24},{"name":"api-typical-usage","value":"Often called from: PerformCursorOpen","count":24},{"name":"api-typical-usage","value":"Often called from: ProcedureCreate","count":24},{"name":"api-typical-usage","value":"Often called from: RelationIdGetRelation","count":24},{"name":"api-typical-usage","value":"Often called from: RequestCheckpoint","count":24},{"name":"api-typical-usage","value":"Often called from: ResetUnloggedRelationsInDbspaceDir","count":24},{"name":"api-typical-usage","value":"Often called from: SocketBackend","count":24},{"name":"api-typical-usage","value":"Often called from: TS_execute_locations_recurse","count":24},{"name":"api-typical-usage","value":"Often called from: TupleDescInitBuiltinEntry","count":24},{"name":"api-typical-usage","value":"Often called from: WinGetFuncArgInFrame","count":24},{"name":"api-typical-usage","value":"Often called from: XLogInsertRecord","count":24},{"name":"api-typical-usage","value":"Often called from: _bt_getstackbuf","count":24},{"name":"api-typical-usage","value":"Often called from: _bt_load","count":24},{"name":"api-typical-usage","value":"Often called from: _readRangeTblEntry","count":24},{"name":"api-typical-usage","value":"Often called from: add_path","count":24},{"name":"api-typical-usage","value":"Often called from: apply_handle_rollback_prepared","count":24},{"name":"api-typical-usage","value":"Often called from: brin_identify","count":24},{"name":"api-typical-usage","value":"Often called from: calc_hist_selectivity","count":24},{"name":"api-typical-usage","value":"Often called from: calculate_client_proof","count":24},{"name":"api-typical-usage","value":"Often called from: check_wal_consistency_checking","count":24},{"name":"api-typical-usage","value":"Often called from: comparetup_index_hash","count":24},{"name":"api-typical-usage","value":"Often called from: conninfo_uri_parse_options","count":24},{"name":"api-typical-usage","value":"Often called from: copy_xact_xlog_xid","count":24},{"name":"api-typical-usage","value":"Often called from: detoast_attr","count":24},{"name":"api-typical-usage","value":"Often called from: do_analyze_rel","count":24},{"name":"api-typical-usage","value":"Often called from: extractPageInfo","count":24},{"name":"api-typical-usage","value":"Often called from: function_parse_error_transpose","count":24},{"name":"api-typical-usage","value":"Often called from: generic_redo","count":24},{"name":"api-typical-usage","value":"Often called from: get_attstatsslot","count":24},{"name":"api-typical-usage","value":"Often called from: ginNewScanKey","count":24},{"name":"api-typical-usage","value":"Often called from: ginRedoRecompress","count":24},{"name":"api-typical-usage","value":"Often called from: ginarrayconsistent","count":24},{"name":"api-typical-usage","value":"Often called from: ginarraytriconsistent","count":24},{"name":"api-typical-usage","value":"Often called from: gist_box_leaf_consistent","count":24},{"name":"api-typical-usage","value":"Often called from: gist_point_consistent","count":24},{"name":"api-typical-usage","value":"Often called from: gisthandler","count":24},{"name":"api-typical-usage","value":"Often called from: grow_memtuples","count":24},{"name":"api-typical-usage","value":"Often called from: heap_toast_insert_or_update","count":24},{"name":"api-typical-usage","value":"Often called from: in_range_int8_int8","count":24},{"name":"api-typical-usage","value":"Often called from: index_form_tuple_context","count":24},{"name":"api-typical-usage","value":"Often called from: infix","count":24},{"name":"api-typical-usage","value":"Often called from: int8gcd_internal","count":24},{"name":"api-typical-usage","value":"Often called from: lazy_scan_prune","count":24},{"name":"api-typical-usage","value":"Often called from: lexi","count":24},{"name":"api-typical-usage","value":"Often called from: lookup_ts_dictionary_cache","count":24},{"name":"api-typical-usage","value":"Often called from: macaddr8_ge","count":24},{"name":"api-typical-usage","value":"Often called from: macaddr8_or","count":24},{"name":"api-typical-usage","value":"Often called from: macaddr_and","count":24},{"name":"api-typical-usage","value":"Often called from: numeric_power","count":24},{"name":"api-typical-usage","value":"Often called from: parse_subscription_options","count":24},{"name":"api-typical-usage","value":"Often called from: pg_checksum_init","count":24},{"name":"api-typical-usage","value":"Often called from: pg_control_init","count":24},{"name":"api-typical-usage","value":"Often called from: pg_convert","count":24},{"name":"api-typical-usage","value":"Often called from: pg_hmac_create","count":24},{"name":"api-typical-usage","value":"Often called from: pg_lock_status","count":24},{"name":"api-typical-usage","value":"Often called from: pgoutput_row_filter","count":24},{"name":"api-typical-usage","value":"Often called from: process_pm_child_exit","count":24},{"name":"api-typical-usage","value":"Often called from: readRecoverySignalFile","count":24},{"name":"api-typical-usage","value":"Often called from: ri_PerformCheck","count":24},{"name":"api-typical-usage","value":"Often called from: scram_SaltedPassword","count":24},{"name":"api-typical-usage","value":"Often called from: secure_open_gssapi","count":24},{"name":"api-typical-usage","value":"Often called from: show_buffer_usage","count":24},{"name":"api-typical-usage","value":"Often called from: smgr_desc","count":24},{"name":"api-typical-usage","value":"Often called from: spgRedoPickSplit","count":24},{"name":"api-typical-usage","value":"Often called from: standard_ProcessUtility","count":24},{"name":"api-typical-usage","value":"Often called from: sub_var","count":24},{"name":"api-typical-usage","value":"Often called from: systable_beginscan","count":24},{"name":"api-typical-usage","value":"Often called from: test_timing","count":24},{"name":"api-typical-usage","value":"Often called from: timestamp_bin","count":24},{"name":"api-typical-usage","value":"Often called from: timestamptz_zone","count":24},{"name":"api-typical-usage","value":"Often called from: toast_flatten_tuple_to_datum","count":24},{"name":"api-typical-usage","value":"Often called from: verify_manifest_checksum","count":24},{"name":"api-typical-usage","value":"Often called from: xideq","count":24},{"name":"arch-sublayer","value":"transaction-manager","count":24},{"name":"coupling-score","value":"39","count":24},{"name":"coupling-score","value":"40","count":24},{"name":"coupling-score","value":"43","count":24},{"name":"coupling-score","value":"49","count":24},{"name":"cyclomatic-complexity","value":"104","count":24},{"name":"cyclomatic-complexity","value":"110","count":24},{"name":"cyclomatic-complexity","value":"112","count":24},{"name":"cyclomatic-complexity","value":"117","count":24},{"name":"cyclomatic-complexity","value":"127","count":24},{"name":"cyclomatic-complexity","value":"200","count":24},{"name":"cyclomatic-complexity","value":"66","count":24},{"name":"cyclomatic-complexity","value":"86","count":24},{"name":"cyclomatic-complexity","value":"87","count":24},{"name":"cyclomatic-complexity","value":"96","count":24},{"name":"lines-of-code","value":"195","count":24},{"name":"lines-of-code","value":"202","count":24},{"name":"lines-of-code","value":"212","count":24},{"name":"lines-of-code","value":"213","count":24},{"name":"lines-of-code","value":"220","count":24},{"name":"lines-of-code","value":"229","count":24},{"name":"lines-of-code","value":"234","count":24},{"name":"lines-of-code","value":"243","count":24},{"name":"lines-of-code","value":"244","count":24},{"name":"lines-of-code","value":"246","count":24},{"name":"lines-of-code","value":"248","count":24},{"name":"lines-of-code","value":"250","count":24},{"name":"lines-of-code","value":"255","count":24},{"name":"lines-of-code","value":"265","count":24},{"name":"lines-of-code","value":"278","count":24},{"name":"lines-of-code","value":"291","count":24},{"name":"lines-of-code","value":"294","count":24},{"name":"lines-of-code","value":"302","count":24},{"name":"lines-of-code","value":"304","count":24},{"name":"lines-of-code","value":"306","count":24},{"name":"lines-of-code","value":"321","count":24},{"name":"lines-of-code","value":"342","count":24},{"name":"lines-of-code","value":"353","count":24},{"name":"lines-of-code","value":"367","count":24},{"name":"lines-of-code","value":"372","count":24},{"name":"lines-of-code","value":"422","count":24},{"name":"lines-of-code","value":"445","count":24},{"name":"tested-by","value":"_bt_check_natts","count":24},{"name":"tested-by","value":"_bt_check_rowcompare, check_new_partition_bound, check_new_partition_bound, check_new_partition_bound, array_subscript_check_subscripts, array_subscript_check_subscripts, pg_isolation_test_session_is_","count":24},{"name":"tested-by","value":"_bt_check_unique, _bt_check_unique","count":24},{"name":"tested-by","value":"check_circularity","count":24},{"name":"tested-by","value":"check_datestyle, check_datestyle","count":24},{"name":"tested-by","value":"check_exec","count":24},{"name":"tested-by","value":"check_is_install_user","count":24},{"name":"tested-by","value":"check_null_keys","count":24},{"name":"tested-by","value":"check_object_ownership","count":24},{"name":"tested-by","value":"check_root","count":24},{"name":"tested-by","value":"domain_check_internal","count":24},{"name":"tested-by","value":"double_to_shortest_decimal_bufn","count":24},{"name":"tested-by","value":"jsonb_subscript_check_subscripts","count":24},{"name":"tested-by","value":"spgLeafTest, spgLeafTest, spgInnerTest, spgInnerTest, check_duplicates_in_publist, check_for_column_name_collision, check_session_authorization, check_role, jsonb_subscript_check_subscripts","count":24},{"name":"tested-by","value":"test_open, test_open","count":24},{"name":"Feature","value":"CSV support for COPY","count":23},{"name":"Feature","value":"IMPORT FOREIGN SCHEMA","count":23},{"name":"Feature","value":"JSONB Subscripting","count":21},{"name":"api-example","value":"CustomScanState * ExecInitCustomScan(CustomScan *cscan, EState *estate, int eflags) { CustomScanState *css; const TupleTableSlotOps *slotOps; Relation\tscan_rel = NULL; Index\t\tscanrelid = cscan->scan.s...","count":21},{"name":"api-example","value":"Datum brin_desummarize_range(PG_FUNCTION_ARGS) { Oid\t\t\tindexoid = PG_GETARG_OID(0); int64\t\theapBlk64 = PG_GETARG_INT64(1); BlockNumber heapBlk; Oid\t\t\theapoid; Relation\theapRel; Relation\tindexRel; bool...","count":21},{"name":"api-example","value":"Datum brin_minmax_multi_distance_pg_lsn(PG_FUNCTION_ARGS) { float8\t\tdelta = 0; XLogRecPtr\tlsna = PG_GETARG_LSN(0); XLogRecPtr\tlsnb = PG_GETARG_LSN(1); delta = (lsnb - lsna); Assert(delta >= 0); PG_RET...","count":21},{"name":"api-example","value":"Datum gist_box_picksplit(PG_FUNCTION_ARGS) { GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0); GIST_SPLITVEC *v = (GIST_SPLITVEC *) PG_GETARG_POINTER(1); OffsetNumber i, maxoff; Co...","count":21},{"name":"api-example","value":"Datum hashfloat4extended(PG_FUNCTION_ARGS) { float4\t\tkey = PG_GETARG_FLOAT4(0); uint64\t\tseed = PG_GETARG_INT64(1); float8\t\tkey8; if (key == (float4) 0) PG_RETURN_UINT64(seed); key8 = key; if (isnan(ke...","count":21},{"name":"api-example","value":"Datum macaddr8_in(PG_FUNCTION_ARGS) { const unsigned char *str = (unsigned char *) PG_GETARG_CSTRING(0); Node\t   *escontext = fcinfo->context; const unsigned char *ptr = str; bool\t\tbadhex = false; mac...","count":21},{"name":"api-example","value":"Datum pg_event_trigger_dropped_objects(PG_FUNCTION_ARGS) { ReturnSetInfo *rsinfo = (ReturnSetInfo *) fcinfo->resultinfo; slist_iter\titer; * Protect this function from being called out of context */ if...","count":21},{"name":"api-example","value":"Datum pg_wal_summary_contents(PG_FUNCTION_ARGS) { ReturnSetInfo *rsi; Datum\t\tvalues[NUM_SUMMARY_ATTS]; bool\t\tnulls[NUM_SUMMARY_ATTS]; WalSummaryFile ws; WalSummaryIO io; BlockRefTableReader *reader; i...","count":21},{"name":"api-example","value":"IndexTuple GinFormTuple(GinState *ginstate, OffsetNumber attnum, Datum key, GinNullCategory category, Pointer data, Size dataSize, int nipd, bool errorTooBig) { Datum\t\tdatums[2]; bool\t\tisnull[2]; Inde...","count":21},{"name":"api-example","value":"LogicalDecodingContext * CreateInitDecodingContext(const char *plugin, List *output_plugin_options, bool need_full_snapshot, XLogRecPtr restart_lsn, XLogReaderRoutine *xl_routine, LogicalOutputPluginW...","count":21},{"name":"api-example","value":"PVOID __cdecl __InlineInterlockedCompareExchangePointer (PVOID volatile *Destination, PVOID ExChange, PVOID Comperand) { return ((PVOID) (LONG_PTR)InterlockedCompareExchange ((LONG volatile *)Destinat...","count":21},{"name":"api-example","value":"__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(int, vsprintf_s, char, _DstBuf, const char*, _Format, va_list, _ArgList)","count":21},{"name":"api-example","value":"__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(int, vswprintf_s, wchar_t, _Dst, const wchar_t*, _Format, va_list, _ArgList)","count":21},{"name":"api-example","value":"__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(int,_vsnprintf_s,char,_DstBuf,size_t,_MaxCount,const char*,_Format,va_list,_ArgList)","count":21},{"name":"api-example","value":"__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(int,_vsnwprintf_s,wchar_t,_DstBuf,size_t,_MaxCount,const wchar_t*,_Format,va_list,_ArgList)","count":21},{"name":"api-example","value":"bool _hash_next(IndexScanDesc scan, ScanDirection dir) { Relation\trel = scan->indexRelation; HashScanOpaque so = (HashScanOpaque) scan->opaque; HashScanPosItem *currItem; BlockNumber blkno; Buffer\t\tbu...","count":21},{"name":"api-example","value":"bool check_wal_segment_size(int *newval, void **extra, GucSource source) { if (!IsValidWalSegSize(*newval)) { GUC_check_errdetail(\"The WAL segment size must be a power of two between 1 MB and 1 GB.\");...","count":21},{"name":"api-example","value":"bool llvm_compile_expr(ExprState *state) { PlanState  *parent = state->parent; char\t   *funcname; LLVMJitContext *context = NULL; LLVMBuilderRef b; LLVMModuleRef mod; LLVMContextRef lc; LLVMValueRef e...","count":21},{"name":"api-example","value":"static LONG WINAPI crashDumpHandler(struct _EXCEPTION_POINTERS *pExceptionInfo) { * We only write crash dumps if the \"crashdumps\" directory within the * postgres data directory exists. */ DWORD\t\tattri...","count":21},{"name":"api-example","value":"static List * objectsInSchemaToOids(ObjectType objtype, List *nspnames) { List\t   *objects = NIL; ListCell   *cell; foreach(cell, nspnames) { char\t   *nspname = strVal(lfirst(cell)); Oid\t\t\tnamespaceId...","count":21},{"name":"api-example","value":"static Node * sql_fn_post_column_ref(ParseState *pstate, ColumnRef *cref, Node *var) { SQLFunctionParseInfoPtr pinfo = (SQLFunctionParseInfoPtr) pstate->p_ref_hook_state; int\t\t\tnnames; Node\t   *field1...","count":21},{"name":"api-example","value":"static ParamListInfo EvaluateParams(ParseState *pstate, PreparedStatement *pstmt, List *params, EState *estate) { Oid\t\t   *param_types = pstmt->plansource->param_types; int\t\t\tnum_params = pstmt->plans...","count":21},{"name":"api-example","value":"static TransactionId FreezeMultiXactId(MultiXactId multi, uint16 t_infomask, const struct VacuumCutoffs *cutoffs, uint16 *flags, HeapPageFreeze *pagefrz) { TransactionId newxmax; MultiXactMember *memb...","count":21},{"name":"api-example","value":"static bool CommitTransactionCommandInternal(void) { TransactionState s = CurrentTransactionState; SavedTransactionCharacteristics savetc; SaveTransactionCharacteristics(&savetc); switch (s->blockStat...","count":21},{"name":"api-example","value":"static bool SlruPhysicalReadPage(SlruCtl ctl, int64 pageno, int slotno) { SlruShared\tshared = ctl->shared; int64\t\tsegno = pageno / SLRU_PAGES_PER_SEGMENT; int\t\t\trpageno = pageno % SLRU_PAGES_PER_SEGME...","count":21},{"name":"api-example","value":"static bool pair_decode(char *str, float8 *x, float8 *y, char **endptr_p, const char *type_name, const char *orig_string, Node *escontext) { bool\t\thas_delim; while (isspace((unsigned char) *str)) str+...","count":21},{"name":"api-example","value":"static char * libpqrcv_get_conninfo(WalReceiverConn *conn) { PQconninfoOption *conn_opts; PQconninfoOption *conn_opt; PQExpBufferData buf; char\t   *retval; Assert(conn->streamConn != NULL); initPQExpB...","count":21},{"name":"api-example","value":"static char ** replace_guc_value(char **lines, const char *guc_name, const char *guc_value, bool mark_as_comment) { int\t\t\tnamelen = strlen(guc_name); PQExpBuffer newline = createPQExpBuffer(); int\t\t\ti...","count":21},{"name":"api-example","value":"static inline void CopyMultiInsertBufferFlush(CopyMultiInsertInfo *miinfo, CopyMultiInsertBuffer *buffer, int64 *processed) { CopyFromState cstate = miinfo->cstate; EState\t   *estate = miinfo->estate;...","count":21},{"name":"api-example","value":"static int PerformRadiusTransaction(const char *server, const char *secret, const char *portstr, const char *identifier, const char *user_name, const char *passwd) { radius_packet radius_send_pack; ra...","count":21},{"name":"api-example","value":"static int pg_SASL_init(PGconn *conn, int payloadlen) { char\t   *initialresponse = NULL; int\t\t\tinitialresponselen; const char *selected_mechanism; PQExpBufferData mechanism_buf; char\t   *password = NU...","count":21},{"name":"api-example","value":"static struct config_generic * add_placeholder_variable(const char *name, int elevel) { size_t\t\tsz = sizeof(struct config_string) + sizeof(char *); struct config_string *var; struct config_generic *ge...","count":21},{"name":"api-example","value":"static void CleanupPriorWALFiles(void) { int\t\t\trc; DIR\t\t   *xldir; struct dirent *xlde; char\t\twalfile[MAXPGPATH]; xldir = opendir(archiveLocation); if (xldir == NULL) pg_fatal(\"could not open archive ...","count":21},{"name":"api-example","value":"static void ExecGrant_common(InternalGrant *istmt, Oid classid, AclMode default_privs, void (*object_check) (InternalGrant *istmt, HeapTuple tuple)) { int\t\t\tcacheid; Relation\trelation; ListCell   *cel...","count":21},{"name":"api-example","value":"static void RecordNewMultiXact(MultiXactId multi, MultiXactOffset offset, int nmembers, MultiXactMember *members) { int64\t\tpageno; int64\t\tprev_pageno; int\t\t\tentryno; int\t\t\tslotno; MultiXactOffset *off...","count":21},{"name":"api-example","value":"static void SetRelationNumChecks(Relation rel, int numchecks) { Relation\trelrel; HeapTuple\treltup; Form_pg_class relStruct; relrel = table_open(RelationRelationId, RowExclusiveLock); reltup = SearchSy...","count":21},{"name":"api-example","value":"static void _bt_insertonpg(Relation rel, Relation heaprel, BTScanInsert itup_key, Buffer buf, Buffer cbuf, BTStack stack, IndexTuple itup, Size itemsz, OffsetNumber newitemoff, int postingoff, bool sp...","count":21},{"name":"api-example","value":"static void gistRedoPageUpdateRecord(XLogReaderState *record) { XLogRecPtr\tlsn = record->EndRecPtr; gistxlogPageUpdate *xldata = (gistxlogPageUpdate *) XLogRecGetData(record); Buffer\t\tbuffer; Page\t\tpa...","count":21},{"name":"api-example","value":"static void terminate_brin_buildstate(BrinBuildState *state) { * Release the last index buffer used.  We might as well ensure that * whatever free space remains in that page is available in FSM, too. ...","count":21},{"name":"api-example","value":"unsigned InterlockedDecrement (unsigned volatile *Addend) { return (unsigned) InterlockedDecrement ((volatile __LONG32 *) Addend); }","count":21},{"name":"api-example","value":"unsigned InterlockedExchange (unsigned volatile *Target, unsigned Value) { return (unsigned) InterlockedExchange ((volatile __LONG32 *) Target,(__LONG32) Value); }","count":21},{"name":"api-example","value":"unsigned InterlockedExchangeAdd (unsigned volatile *Addend, unsigned Value) { return (unsigned) InterlockedExchangeAdd ((volatile __LONG32 *) Addend,(__LONG32) Value); }","count":21},{"name":"api-example","value":"unsigned InterlockedIncrement (unsigned volatile *Addend) { return (unsigned) InterlockedIncrement ((volatile __LONG32 *) Addend); }","count":21},{"name":"api-example","value":"void ExecEvalJsonIsPredicate(ExprState *state, ExprEvalStep *op) { JsonIsPredicate *pred = op->d.is_json.pred; Datum\t\tjs = *op->resvalue; Oid\t\t\texprtype; bool\t\tres; if (*op->resnull) { *op->resvalue =...","count":21},{"name":"api-example","value":"void ExecuteTruncateGuts(List *explicit_rels, List *relids, List *relids_logged, DropBehavior behavior, bool restart_seqs, bool run_as_table_owner) { List\t   *rels; List\t   *seq_relids = NIL; HTAB\t   ...","count":21},{"name":"api-example","value":"void InitializeBackupManifest(backup_manifest_info *manifest, backup_manifest_option want_manifest, pg_checksum_type manifest_checksum_type) { memset(manifest, 0, sizeof(backup_manifest_info)); manife...","count":21},{"name":"api-example","value":"void RestoreArchive(Archive *AHX) { ArchiveHandle *AH = (ArchiveHandle *) AHX; RestoreOptions *ropt = AH->public.ropt; bool\t\tparallel_mode; TocEntry   *te; CompressFileHandle *sav; AH->stage = STAGE_I...","count":21},{"name":"api-example","value":"void XLOGShmemInit(void) { bool\t\tfoundCFile, foundXLog; char\t   *allocptr; int\t\t\ti; ControlFileData *localControlFile; #ifdef WAL_DEBUG * Create a memory context for WAL debugging that's exempt from t...","count":21},{"name":"api-example","value":"void ginHeapTupleFastInsert(GinState *ginstate, GinTupleCollector *collector) { Relation\tindex = ginstate->index; Buffer\t\tmetabuffer; Page\t\tmetapage; GinMetaPageData *metadata = NULL; Buffer\t\tbuffer =...","count":21},{"name":"api-example","value":"void heap_redo(XLogReaderState *record) { uint8\t\tinfo = XLogRecGetInfo(record) & ~XLR_INFO_MASK; * These operations don't overwrite MVCC data so no conflict processing is * required. The ones in heap2...","count":21},{"name":"Feature","value":"Failover support for logical replication slots","count":20},{"name":"Feature","value":"Incremental sort","count":20},{"name":"Feature","value":"Nondeterministic collations","count":20},{"name":"Feature","value":"Qualified function parameters","count":20},{"name":"Feature","value":"WITHIN GROUP clause","count":20},{"name":"api-caller-count","value":"1171","count":20},{"name":"api-caller-count","value":"139","count":20},{"name":"api-caller-count","value":"1512","count":20},{"name":"api-caller-count","value":"152","count":20},{"name":"api-caller-count","value":"188","count":20},{"name":"api-caller-count","value":"1883","count":20},{"name":"api-caller-count","value":"21028","count":20},{"name":"api-caller-count","value":"306","count":20},{"name":"api-caller-count","value":"316","count":20},{"name":"api-caller-count","value":"437","count":20},{"name":"api-caller-count","value":"442","count":20},{"name":"api-caller-count","value":"494","count":20},{"name":"api-caller-count","value":"74","count":20},{"name":"api-caller-count","value":"85","count":20},{"name":"api-caller-count","value":"95","count":20},{"name":"api-typical-usage","value":"Often called from: ATExecCmd","count":20},{"name":"api-typical-usage","value":"Often called from: ATRewriteTable","count":20},{"name":"api-typical-usage","value":"Often called from: AlterTypeNamespaceInternal","count":20},{"name":"api-typical-usage","value":"Often called from: BufferUsageAdd","count":20},{"name":"api-typical-usage","value":"Often called from: CommitTransactionCommandInternal","count":20},{"name":"api-typical-usage","value":"Often called from: DatumGetJsonPathPCopy","count":20},{"name":"api-typical-usage","value":"Often called from: ECPGdump_a_type","count":20},{"name":"api-typical-usage","value":"Often called from: ExecGetJsonValueItemString","count":20},{"name":"api-typical-usage","value":"Often called from: ExecIncrementalSort","count":20},{"name":"api-typical-usage","value":"Often called from: ExecMergeJoin","count":20},{"name":"api-typical-usage","value":"Often called from: GetOldestSnapshot","count":20},{"name":"api-typical-usage","value":"Often called from: GetRunningTransactionLocks","count":20},{"name":"api-typical-usage","value":"Often called from: HeapCheckForSerializableConflictOut","count":20},{"name":"api-typical-usage","value":"Often called from: InitMaterializedSRF","count":20},{"name":"api-typical-usage","value":"Often called from: InitProcGlobal","count":20},{"name":"api-typical-usage","value":"Often called from: JsonEncodeDateTime","count":20},{"name":"api-typical-usage","value":"Often called from: LockAcquireExtended","count":20},{"name":"api-typical-usage","value":"Often called from: MultiXactIdSetOldestVisible","count":20},{"name":"api-typical-usage","value":"Often called from: PGLC_localeconv","count":20},{"name":"api-typical-usage","value":"Often called from: PGTYPEStimestamp_from_asc","count":20},{"name":"api-typical-usage","value":"Often called from: PLyObject_ToComposite","count":20},{"name":"api-typical-usage","value":"Often called from: PQsendPrepare","count":20},{"name":"api-typical-usage","value":"Often called from: PQsendQueryGuts","count":20},{"name":"api-typical-usage","value":"Often called from: ProcArrayAdd","count":20},{"name":"api-typical-usage","value":"Often called from: ProcessConfigFileInternal","count":20},{"name":"api-typical-usage","value":"Often called from: ProcessIncomingNotify","count":20},{"name":"api-typical-usage","value":"Often called from: ProcessUtilitySlow","count":20},{"name":"api-typical-usage","value":"Often called from: RI_FKey_check","count":20},{"name":"api-typical-usage","value":"Often called from: RecordTransactionAbortPrepared","count":20},{"name":"api-typical-usage","value":"Often called from: RelationBuildLocalRelation","count":20},{"name":"api-typical-usage","value":"Often called from: RelationFindReplTupleSeq","count":20},{"name":"api-typical-usage","value":"Often called from: ReorderBufferChangeMemoryUpdate","count":20},{"name":"api-typical-usage","value":"Often called from: ResolveRecoveryConflictWithLock","count":20},{"name":"api-typical-usage","value":"Often called from: RevalidateCachedQuery","count":20},{"name":"api-typical-usage","value":"Often called from: SetLocktagRelationOid","count":20},{"name":"api-typical-usage","value":"Often called from: SnapBuildSerialize","count":20},{"name":"api-typical-usage","value":"Often called from: TransactionIdGetCommitTsData","count":20},{"name":"api-typical-usage","value":"Often called from: XLogRecGetBlockRefInfo","count":20},{"name":"api-typical-usage","value":"Often called from: XLogRecordMatchesRelationBlock","count":20},{"name":"api-typical-usage","value":"Often called from: XLogSaveBufferForHint","count":20},{"name":"api-typical-usage","value":"Often called from: XLogWalRcvProcessMsg","count":20},{"name":"api-typical-usage","value":"Often called from: XLogWalRcvWrite","count":20},{"name":"api-typical-usage","value":"Often called from: XLogWrite","count":20},{"name":"api-typical-usage","value":"Often called from: _PrepParallelRestore","count":20},{"name":"api-typical-usage","value":"Often called from: _bt_getroot","count":20},{"name":"api-typical-usage","value":"Often called from: _outRangeTblEntry","count":20},{"name":"api-typical-usage","value":"Often called from: acldefault","count":20},{"name":"api-typical-usage","value":"Often called from: aclupdate","count":20},{"name":"api-typical-usage","value":"Often called from: addTargetToSortList","count":20},{"name":"api-typical-usage","value":"Often called from: advanceConnectionState","count":20},{"name":"api-typical-usage","value":"Often called from: agg_retrieve_direct","count":20},{"name":"api-typical-usage","value":"Often called from: array_recv","count":20},{"name":"api-typical-usage","value":"Often called from: asyncQueueAddEntries","count":20},{"name":"api-typical-usage","value":"Often called from: bbstreamer_tar_archiver_content","count":20},{"name":"api-typical-usage","value":"Often called from: be_tls_init","count":20},{"name":"api-typical-usage","value":"Often called from: brin_minmax_multi_distance_interval","count":20},{"name":"api-typical-usage","value":"Often called from: brin_minmax_multi_distance_macaddr","count":20},{"name":"api-typical-usage","value":"Often called from: build_joinrel_tlist","count":20},{"name":"api-typical-usage","value":"Often called from: calc_length_hist_frac","count":20},{"name":"api-typical-usage","value":"Often called from: chareqfast","count":20},{"name":"api-typical-usage","value":"Often called from: check_memoizable","count":20},{"name":"api-typical-usage","value":"Often called from: cleanup_objects_atexit","count":20},{"name":"api-typical-usage","value":"Often called from: clonesuccessorstates","count":20},{"name":"api-typical-usage","value":"Often called from: command_no_begin","count":20},{"name":"api-typical-usage","value":"Often called from: compute_new_xmax_infomask","count":20},{"name":"api-typical-usage","value":"Often called from: dbase_redo","count":20},{"name":"api-typical-usage","value":"Often called from: deccall3","count":20},{"name":"api-typical-usage","value":"Often called from: do_connect","count":20},{"name":"api-typical-usage","value":"Often called from: dumpDatabase","count":20},{"name":"api-typical-usage","value":"Often called from: errdetail_internal","count":20},{"name":"api-typical-usage","value":"Often called from: evalStandardFunc","count":20},{"name":"api-typical-usage","value":"Often called from: finalize_aggregates","count":20},{"name":"api-typical-usage","value":"Often called from: float4smaller","count":20},{"name":"api-typical-usage","value":"Often called from: formTextDatum","count":20},{"name":"api-typical-usage","value":"Often called from: get_configdata","count":20},{"name":"api-typical-usage","value":"Often called from: get_name_for_var_field","count":20},{"name":"api-typical-usage","value":"Often called from: get_namespace_oid","count":20},{"name":"api-typical-usage","value":"Often called from: ginHeapTupleFastInsert","count":20},{"name":"api-typical-usage","value":"Often called from: ginInsertCleanup","count":20},{"name":"api-typical-usage","value":"Often called from: gin_extract_tsquery","count":20},{"name":"api-typical-usage","value":"Often called from: gistvalidate","count":20},{"name":"api-typical-usage","value":"Often called from: heap_get_root_tuples","count":20},{"name":"api-typical-usage","value":"Often called from: in_range_interval_interval","count":20},{"name":"api-typical-usage","value":"Often called from: index_deform_tuple_internal","count":20},{"name":"api-typical-usage","value":"Often called from: inet_net_ntop_ipv6","count":20},{"name":"api-typical-usage","value":"Often called from: inet_spg_picksplit","count":20},{"name":"api-typical-usage","value":"Often called from: inv_getsize","count":20},{"name":"api-typical-usage","value":"Often called from: keyGetItem","count":20},{"name":"api-typical-usage","value":"Often called from: lo_import_internal","count":20},{"name":"api-typical-usage","value":"Often called from: log_status_format","count":20},{"name":"api-typical-usage","value":"Often called from: make_range","count":20},{"name":"api-typical-usage","value":"Often called from: nameeqfast","count":20},{"name":"api-typical-usage","value":"Often called from: objectNamesToOids","count":20},{"name":"api-typical-usage","value":"Often called from: pg_control_checkpoint","count":20},{"name":"api-typical-usage","value":"Often called from: pg_preadv","count":20},{"name":"api-typical-usage","value":"Often called from: pg_snapshot_recv","count":20},{"name":"api-typical-usage","value":"Often called from: pltcl_func_handler","count":20},{"name":"api-typical-usage","value":"Often called from: pq_puttextmessage","count":20},{"name":"api-typical-usage","value":"Often called from: pq_setkeepalivescount","count":20},{"name":"api-typical-usage","value":"Often called from: process_pipe_input","count":20},{"name":"api-typical-usage","value":"Often called from: process_pm_shutdown_request","count":20},{"name":"api-typical-usage","value":"Often called from: pull_var_clause_walker","count":20},{"name":"api-typical-usage","value":"Often called from: r_mark_regions","count":20},{"name":"api-typical-usage","value":"Often called from: r_stem_noun_suffixes","count":20},{"name":"api-typical-usage","value":"Often called from: range_gist_consistent_int_range","count":20},{"name":"api-typical-usage","value":"Often called from: range_gist_penalty","count":20},{"name":"api-typical-usage","value":"Often called from: relation_open","count":20},{"name":"api-typical-usage","value":"Often called from: replace_nestloop_params_mutator","count":20},{"name":"api-typical-usage","value":"Often called from: resolve_polymorphic_tupdesc","count":20},{"name":"api-typical-usage","value":"Often called from: scanGetItem","count":20},{"name":"api-typical-usage","value":"Often called from: send_message_to_frontend","count":20},{"name":"api-typical-usage","value":"Often called from: serialize_expr_stats","count":20},{"name":"api-typical-usage","value":"Often called from: set_plan_refs","count":20},{"name":"api-typical-usage","value":"Often called from: set_var_from_str","count":20},{"name":"api-typical-usage","value":"Often called from: smgr_bulk_finish","count":20},{"name":"api-typical-usage","value":"Often called from: standard_ExecutorStart","count":20},{"name":"api-typical-usage","value":"Often called from: start_postmaster","count":20},{"name":"api-typical-usage","value":"Often called from: statext_is_compatible_clause_internal","count":20},{"name":"api-typical-usage","value":"Often called from: table_block_parallelscan_startblock_init","count":20},{"name":"api-typical-usage","value":"Often called from: tm2timestamp","count":20},{"name":"api-typical-usage","value":"Often called from: trim_array","count":20},{"name":"api-typical-usage","value":"Often called from: tsq_mcontains","count":20},{"name":"api-typical-usage","value":"Often called from: unistr","count":20},{"name":"api-typical-usage","value":"Often called from: update_frameheadpos","count":20},{"name":"api-typical-usage","value":"Often called from: validate_option_array_item","count":20},{"name":"api-typical-usage","value":"Often called from: writeTimeLineHistory","count":20},{"name":"coupling-score","value":"60","count":20},{"name":"cyclomatic-complexity","value":"101","count":20},{"name":"cyclomatic-complexity","value":"105","count":20},{"name":"cyclomatic-complexity","value":"113","count":20},{"name":"cyclomatic-complexity","value":"116","count":20},{"name":"cyclomatic-complexity","value":"129","count":20},{"name":"cyclomatic-complexity","value":"130","count":20},{"name":"cyclomatic-complexity","value":"145","count":20},{"name":"cyclomatic-complexity","value":"154","count":20},{"name":"cyclomatic-complexity","value":"161","count":20},{"name":"cyclomatic-complexity","value":"221","count":20},{"name":"cyclomatic-complexity","value":"81","count":20},{"name":"cyclomatic-complexity","value":"94","count":20},{"name":"lines-of-code","value":"232","count":20},{"name":"lines-of-code","value":"237","count":20},{"name":"lines-of-code","value":"253","count":20},{"name":"lines-of-code","value":"277","count":20},{"name":"lines-of-code","value":"280","count":20},{"name":"lines-of-code","value":"284","count":20},{"name":"lines-of-code","value":"320","count":20},{"name":"lines-of-code","value":"323","count":20},{"name":"lines-of-code","value":"327","count":20},{"name":"lines-of-code","value":"341","count":20},{"name":"lines-of-code","value":"351","count":20},{"name":"lines-of-code","value":"358","count":20},{"name":"lines-of-code","value":"411","count":20},{"name":"lines-of-code","value":"421","count":20},{"name":"loop-depth","value":"31","count":20},{"name":"loop-depth","value":"34","count":20},{"name":"subsystem-desc","value":"Extended statistics\n===================\n\nWhen estimating various quantities (e.g. condition selectivities) the default\napproach relies on the assumption of independence. In practice that's often\nnot true, resulting in estimation errors.\n\nExtended statistics track different types of dependencies between the columns,\nhopefully improving the estimates and producing better plans.\n\n\nTypes of statistics\n-------------------\n\nThere are currently several kinds of extended statistics:\n\n    (a) ndistinct coefficients\n\n    (b) soft functional dependencies (README.dependencies)\n\n    (c) MCV lists (README.mcv)\n\n\nCompatible clause types\n-----------------------\n\nEach type of statistics may be used to estimate some subset of clause types.\n\n    (a) functional dependencies - equality clauses (AND), possibly IS NULL\n\n    (b) MCV lists - equality and inequality clauses (AND, OR, NOT), IS [NOT] NULL\n\nCurrently, only OpExprs in the form Var op Const, or Const op Var are\nsupported, however it's feasible to expand the code later to also estimate the\nselectivities on clauses such as Var op Var.\n\n\nComplex clauses\n---------------\n\nWe also support estimating more complex clauses - essentially AND/OR clauses\nwith (Var op Const) as leaves, as long as all the referenced attributes are\ncovered by a single statistics object.\n\nFor example this condition\n\n    (a=1) AND ((b=2) OR ((c=3) AND (d=4)))\n\nmay be estimated using statistics on (a,b,c,d). If we only have statistics on\n(b,c,d) we may estimate the second part, and estimate (a=1) using simple stats.\n\nIf we only have statistics on (a,b,c) we can't apply it at all at this point,\nbut it's worth pointing out clauselist_selectivity() works recursively and when\nhandling the second part (the OR-clause), we'll be able to apply the statistics.\n\nNote: The multi-statistics estimation patch also makes it possible to pass some\nclauses as 'conditions' into the deeper parts of the expression tree.\n\n\nSelectivity estimation\n----------------------\n\nThroughout the planner clauselist_selectivity() still remains in charge of\nmost selectivity estimate requests. clauselist_selectivity() can be instructed\nto try to make use of any extended statistics on the given RelOptInfo, which\nit will do if:\n\n    (a) An actual valid RelOptInfo was given. Join relations are passed in as\n        NULL, therefore are invalid.\n\n    (b) The relation given actually has any extended statistics defined which\n        are actually built.\n\nWhen the above conditions are met, clauselist_selectivity() first attempts to\npass the clause list off to the extended statistics selectivity estimation\nfunction. This function may not find any clauses which it can perform any\nestimations on. In such cases, these clauses are simply ignored. When actual\nestimation work is performed in these functions they're expected to mark which\nclauses they've performed estimations for so that any other function\nperforming estimations knows which clauses are to be skipped.\n\nSize of sample in ANALYZE\n-------------------------\n\nWhen performing ANALYZE, the number of rows to sample is determined as\n\n    (300 * statistics_target)\n\nThat works reasonably well for statistics on individual columns, but perhaps\nit's not enough for extended statistics. Papers analyzing estimation errors\nall use samples proportional to the table (usually finding that 1-3% of the\ntable is enough to build accurate stats).\n\nThe requested accuracy (number of MCV items or histogram bins) should also\nbe considered when determining the sample size, and in extended statistics\nthose are not necessarily limited by statistics_target.\n\nThis however merits further discussion, because collecting the sample is quite\nexpensive and increasing it further would make ANALYZE even more painful.\nJudging by the experiments with the current implementation, the fixed size\nseems to work reasonably well for now, so we leave this as future work.","count":20},{"name":"subsystem-desc","value":"PostgreSQL tests\n================\n\nThis directory contains a variety of test infrastructure as well as some of the\ntests in PostgreSQL. Not all tests are here -- in particular, there are more in\nindividual contrib/ modules and in src/bin.\n\nNot all these tests get run by \"make check\". Check src/test/Makefile to see\nwhich tests get run automatically.\n\nauthentication/\n  Tests for authentication (but see also below)\n\nexamples/\n  Demonstration programs for libpq that double as regression tests via\n  \"make check\"\n\nisolation/\n  Tests for concurrent behavior at the SQL level\n\nkerberos/\n  Tests for Kerberos/GSSAPI authentication and encryption\n\nldap/\n  Tests for LDAP-based authentication\n\nlocale/\n  Sanity checks for locale data, encodings, etc\n\nmb/\n  Tests for multibyte encoding (UTF-8) support\n\nmodules/\n  Extensions used only or mainly for test purposes, generally not suitable\n  for installing in production databases\n\nperl/\n  Infrastructure for Perl-based TAP tests\n\nrecovery/\n  Test suite for recovery and replication\n\nregress/\n  PostgreSQL's main regression test suite, pg_regress\n\nssl/\n  Tests to exercise and verify SSL certificate handling\n\nsubscription/\n  Tests for logical replication","count":20},{"name":"subsystem-desc","value":"src/pl/plperl/README\n\nPL/Perl allows you to write PostgreSQL functions and procedures in\nPerl.  To include PL/Perl in the build use './configure --with-perl'.\nTo build from this directory use 'make all; make install'.  libperl\nmust have been built as a shared library, which is usually not the\ncase in standard installations.\n\nConsult the PostgreSQL User's Guide for more information.","count":20},{"name":"subsystem-name","value":"plperl","count":20},{"name":"subsystem-name","value":"statistics","count":20},{"name":"subsystem-name","value":"test","count":20},{"name":"subsystem-path","value":"backend/statistics/readme","count":20},{"name":"subsystem-path","value":"pl/plperl/readme","count":20},{"name":"subsystem-path","value":"test/readme","count":20},{"name":"test-count","value":"161","count":20},{"name":"test-count","value":"205","count":20},{"name":"tested-by","value":"GlobalVisTestIsRemovableFullXid, GlobalVisTestIsRemovableFullXid","count":20},{"name":"tested-by","value":"_bt_check_compare, spgLeafTest, index_recheck_constraint, check_constant_qual, HeapKeyTest","count":20},{"name":"tested-by","value":"_bt_check_unique, check_exclusion_or_unique_constraint","count":20},{"name":"tested-by","value":"_check_database_version","count":20},{"name":"tested-by","value":"add_with_check_options, pg_isolation_test_session_is_blocked, pg_isolation_test_session_is_blocked, pg_isolation_test_session_is_blocked, pg_isolation_test_session_is_blocked, pg_isolation_test_sessio","count":20},{"name":"tested-by","value":"check_GUC_name_for_parameter_acl","count":20},{"name":"tested-by","value":"check_default_table_access_method, check_default_table_access_method, check_default_table_access_method, check_slru_buffers, check_wal_segment_size, check_wal_consistency_checking, check_wal_consisten","count":20},{"name":"tested-by","value":"check_hash_func_signature, check_hash_func_signature, index_delete_check_htid, index_delete_check_htid, index_delete_check_htid, lazy_check_wraparound_failsafe, check_amproc_signature, check_amop_sign","count":20},{"name":"tested-by","value":"check_publications","count":20},{"name":"tested-by","value":"check_recovery_target_xid","count":20},{"name":"tested-by","value":"check_role, check_db","count":20},{"name":"tested-by","value":"check_usermap, check_usermap, check_usermap","count":20},{"name":"tested-by","value":"lazy_check_wraparound_failsafe, _bt_check_unique, _bt_check_unique, _bt_check_unique, _bt_check_unique, _bt_check_compare, _bt_check_natts, spgLeafTest, spgLeafTest, spgLeafTest, check_wal_consistency","count":20},{"name":"tested-by","value":"pg_attribute_aclcheck_all_ext, index_check_primary_key","count":20},{"name":"tested-by","value":"pg_check_dir","count":20},{"name":"tested-by","value":"plpgsql_extra_checks_check_hook","count":20},{"name":"tested-by","value":"spgLeafTest, spgLeafTest, spgLeafTest, spgLeafTest, spgInnerTest, spgInnerTest, spgInnerTest, check_default_partition_contents, check_default_partition_contents, domain_check_input, domain_check_input","count":20},{"name":"tested-by","value":"test_lockmode_for_conflict","count":20},{"name":"tested-by","value":"test_specific_config_settings, test_specific_config_settings","count":20},{"name":"tested-by","value":"truncate_check_rel","count":20},{"name":"Feature","value":"Archive modules","count":19},{"name":"Feature","value":"GUID/UUID data type","count":18},{"name":"Feature","value":"Logical replication parallel apply of transactions","count":18},{"name":"Feature","value":"Partitioning by a hash key","count":18},{"name":"Feature","value":"Unicode object support in PL/python","count":18},{"name":"Feature","value":"psql \\bind","count":18},{"name":"api-example","value":"Datum bit_in(PG_FUNCTION_ARGS) { char\t   *input_string = PG_GETARG_CSTRING(0); #ifdef NOT_USED Oid\t\t\ttypelem = PG_GETARG_OID(1); #endif int32\t\tatttypmod = PG_GETARG_INT32(2); Node\t   *escontext = fcin...","count":18},{"name":"api-example","value":"Datum brin_minmax_multi_distance_int2(PG_FUNCTION_ARGS) { int16\t\ta1 = PG_GETARG_INT16(0); int16\t\ta2 = PG_GETARG_INT16(1); * We know the values are range boundaries, but the range may be collapsed * (i...","count":18},{"name":"api-example","value":"Datum brin_minmax_multi_distance_macaddr(PG_FUNCTION_ARGS) { float8\t\tdelta; macaddr    *a = PG_GETARG_MACADDR_P(0); macaddr    *b = PG_GETARG_MACADDR_P(1); delta = ((float8) b->f - (float8) a->f); del...","count":18},{"name":"api-example","value":"Datum brin_minmax_multi_distance_macaddr8(PG_FUNCTION_ARGS) { float8\t\tdelta; macaddr8   *a = PG_GETARG_MACADDR8_P(0); macaddr8   *b = PG_GETARG_MACADDR8_P(1); delta = ((float8) b->h - (float8) a->h); ...","count":18},{"name":"api-example","value":"Datum ginhandler(PG_FUNCTION_ARGS) { IndexAmRoutine *amroutine = makeNode(IndexAmRoutine); amroutine->amstrategies = 0; amroutine->amsupport = GINNProcs; amroutine->amoptsprocnum = GIN_OPTIONS_PROC; a...","count":18},{"name":"api-example","value":"Datum gtsvectorout(PG_FUNCTION_ARGS) { SignTSVector *key = (SignTSVector *) PG_DETOAST_DATUM(PG_GETARG_DATUM(0)); char\t   *outbuf; if (outbuf_maxlen == 0) outbuf_maxlen = 2 * EXTRALEN + Max(strlen(SIN...","count":18},{"name":"api-example","value":"Datum hashchar(PG_FUNCTION_ARGS) { return hash_uint32((int32) PG_GETARG_CHAR(0)); }","count":18},{"name":"api-example","value":"Datum inet_in(PG_FUNCTION_ARGS) { char\t   *src = PG_GETARG_CSTRING(0); PG_RETURN_INET_P(network_in(src, false, fcinfo->context)); }","count":18},{"name":"api-example","value":"Datum macaddr_in(PG_FUNCTION_ARGS) { char\t   *str = PG_GETARG_CSTRING(0); Node\t   *escontext = fcinfo->context; macaddr    *result; int\t\t\ta, b, c, d, e, f; char\t\tjunk[2]; int\t\t\tcount; count = sscanf(s...","count":18},{"name":"api-example","value":"Datum numeric_recv(PG_FUNCTION_ARGS) { StringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0); #ifdef NOT_USED Oid\t\t\ttypelem = PG_GETARG_OID(1); #endif int32\t\ttypmod = PG_GETARG_INT32(2); NumericVar\tvalue...","count":18},{"name":"api-example","value":"Datum timetz_zone(PG_FUNCTION_ARGS) { text\t   *zone = PG_GETARG_TEXT_PP(0); TimeTzADT  *t = PG_GETARG_TIMETZADT_P(1); TimeTzADT  *result; int\t\t\ttz; char\t\ttzname[TZ_STRLEN_MAX + 1]; int\t\t\ttype, val; pg...","count":18},{"name":"api-example","value":"EndOfWalRecoveryInfo * FinishWalRecovery(void) { EndOfWalRecoveryInfo *result = palloc(sizeof(EndOfWalRecoveryInfo)); XLogRecPtr\tlastRec; TimeLineID\tlastRecTLI; XLogRecPtr\tendOfLog; * Kill WAL receive...","count":18},{"name":"api-example","value":"GinBtreeStack * ginFindLeafPage(GinBtree btree, bool searchMode, bool rootConflictCheck) { GinBtreeStack *stack; stack = (GinBtreeStack *) palloc(sizeof(GinBtreeStack)); stack->blkno = btree->rootBlkn...","count":18},{"name":"api-example","value":"HeapTuple heap_form_tuple(TupleDesc tupleDescriptor, const Datum *values, const bool *isnull) { HeapTuple\ttuple;\t\t\t/* return tuple */ HeapTupleHeader td;\t\t\t/* tuple data */ Size\t\tlen, data_len; int\t\t\t...","count":18},{"name":"api-example","value":"ObjectAddress CreateConversionCommand(CreateConversionStmt *stmt) { Oid\t\t\tnamespaceId; char\t   *conversion_name; AclResult\taclresult; int\t\t\tfrom_encoding; int\t\t\tto_encoding; Oid\t\t\tfuncoid; const char ...","count":18},{"name":"api-example","value":"RelFileNumber GetNewRelFileNumber(Oid reltablespace, Relation pg_class, char relpersistence) { RelFileLocatorBackend rlocator; char\t   *rpath; bool\t\tcollides; ProcNumber\tprocNumber; * If we ever get h...","count":18},{"name":"api-example","value":"TransactionId GetStableLatestTransactionId(void) { static LocalTransactionId lxid = InvalidLocalTransactionId; static TransactionId stablexid = InvalidTransactionId; if (lxid != MyProc->vxid.lxid) { l...","count":18},{"name":"api-example","value":"XLogRecPtr gistGetFakeLSN(Relation rel) { if (rel->rd_rel->relpersistence == RELPERSISTENCE_TEMP) { * Temporary relations are only accessible in our session, so a simple * backend-local counter will d...","count":18},{"name":"api-example","value":"bool ExecSupportsBackwardScan(Plan *node) { if (node == NULL) return false; * Parallel-aware nodes return a subset of the tuples in each worker, and * in general we can't expect to have enough bookkee...","count":18},{"name":"api-example","value":"bool LockHasWaiters(const LOCKTAG *locktag, LOCKMODE lockmode, bool sessionLock) { LOCKMETHODID lockmethodid = locktag->locktag_lockmethodid; LockMethod\tlockMethodTable; LOCALLOCKTAG localtag; LOCALLO...","count":18},{"name":"api-example","value":"bool _hash_first(IndexScanDesc scan, ScanDirection dir) { Relation\trel = scan->indexRelation; HashScanOpaque so = (HashScanOpaque) scan->opaque; ScanKey\t\tcur; uint32\t\thashkey; Bucket\t\tbucket; Buffer\t\t...","count":18},{"name":"api-example","value":"int run_ssl_passphrase_command(const char *prompt, bool is_server_start, char *buf, int size) { int\t\t\tloglevel = is_server_start ? ERROR : LOG; char\t   *command; FILE\t   *fh; int\t\t\tpclose_rc; size_t\t\t...","count":18},{"name":"api-example","value":"pg_cryptohash_ctx * pg_cryptohash_create(pg_cryptohash_type type) { pg_cryptohash_ctx *ctx; * Note that this always allocates enough space for the largest hash. A * smaller allocation would be enough ...","count":18},{"name":"api-example","value":"ssize_t pg_GSS_read(PGconn *conn, void *ptr, size_t len) { OM_uint32\tmajor, minor; gss_buffer_desc input = GSS_C_EMPTY_BUFFER, output = GSS_C_EMPTY_BUFFER; ssize_t\t\tret; size_t\t\tbytes_returned = 0; gs...","count":18},{"name":"api-example","value":"static Datum ExecInterpExpr(ExprState *state, ExprContext *econtext, bool *isnull) { ExprEvalStep *op; TupleTableSlot *resultslot; TupleTableSlot *innerslot; TupleTableSlot *outerslot; TupleTableSlot ...","count":18},{"name":"api-example","value":"static MultiXactId GetNewMultiXactId(int nmembers, MultiXactOffset *offset) { MultiXactId result; MultiXactOffset nextOffset; debug_elog3(DEBUG2, \"GetNew: for %d xids\", nmembers); if (RecoveryInProgre...","count":18},{"name":"api-example","value":"static PyObject * PLy_cursor_query(const char *query) { PLyCursorObject *cursor; PLyExecutionContext *exec_ctx = PLy_current_execution_context(); volatile MemoryContext oldcontext; volatile ResourceOw...","count":18},{"name":"api-example","value":"static VacAttrStats * examine_attribute(Relation onerel, int attnum, Node *index_expr) { Form_pg_attribute attr = TupleDescAttr(onerel->rd_att, attnum - 1); int\t\t\tattstattarget; HeapTuple\tatttuple; Da...","count":18},{"name":"api-example","value":"static XLogRecPtr log_heap_update(Relation reln, Buffer oldbuf, Buffer newbuf, HeapTuple oldtup, HeapTuple newtup, HeapTuple old_key_tuple, bool all_visible_cleared, bool new_all_visible_cleared) { xl...","count":18},{"name":"api-example","value":"static bool TParserGet(TParser *prs) { const TParserStateActionItem *item = NULL; CHECK_FOR_INTERRUPTS(); Assert(prs->state); if (prs->state->posbyte >= prs->lenstr) return false; prs->token = prs->st...","count":18},{"name":"api-example","value":"static bool shell_archive_file(ArchiveModuleState *state, const char *file, const char *path) { char\t   *xlogarchcmd; char\t   *nativePath = NULL; int\t\t\trc; if (path) { nativePath = pstrdup(path); make...","count":18},{"name":"api-example","value":"static char * pg_get_triggerdef_worker(Oid trigid, bool pretty) { HeapTuple\tht_trig; Form_pg_trigger trigrec; StringInfoData buf; Relation\ttgrel; ScanKeyData skey[1]; SysScanDesc tgscan; int\t\t\tfindx =...","count":18},{"name":"api-example","value":"static color\t\t\t\t\t/* COLORLESS for error */ newcolor(struct colormap *cm) { struct colordesc *cd; size_t\t\tn; if (CISERR()) return COLORLESS; if (cm->free != 0) { assert(cm->free > 0); assert((size_t) c...","count":18},{"name":"api-example","value":"static const char * getsecs(const char *strp, int32 *const secsp) { int\t\t\tnum; * 'HOURSPERDAY * DAYSPERWEEK - 1' allows quasi-Posix rules like * \"M10.4.6/26\", which does not conform to Posix, but whic...","count":18},{"name":"api-example","value":"static inline bool CopyGetInt32(CopyFromState cstate, int32 *val) { uint32\t\tbuf; if (CopyReadBinaryData(cstate, (char *) &buf, sizeof(buf)) != sizeof(buf)) { *val = 0;\t\t\t\t/* suppress compiler warning ...","count":18},{"name":"api-example","value":"static int regcomp_auth_token(AuthToken *token, char *filename, int line_num, char **err_msg, int elevel) { pg_wchar   *wstr; int\t\t\twlen; int\t\t\trc; Assert(token->regex == NULL); if (token->string[0] !...","count":18},{"name":"api-example","value":"static void ExplainPrintJIT(ExplainState *es, int jit_flags, JitInstrumentation *ji) { instr_time\ttotal_time; if (!ji || ji->created_functions == 0) return; INSTR_TIME_SET_ZERO(total_time); INSTR_TIME...","count":18},{"name":"api-example","value":"static void ExplainSaveGroup(ExplainState *es, int depth, int *state_save) { switch (es->format) { case EXPLAIN_FORMAT_TEXT: break; case EXPLAIN_FORMAT_XML: es->indent -= depth; break; case EXPLAIN_FO...","count":18},{"name":"api-example","value":"static void MultiExecParallelHash(HashState *node) { ParallelHashJoinState *pstate; PlanState  *outerNode; List\t   *hashkeys; HashJoinTable hashtable; TupleTableSlot *slot; ExprContext *econtext; uint...","count":18},{"name":"api-example","value":"static void SendCopyDone(void) { pq_putemptymessage(PqMsg_CopyDone); }","count":18},{"name":"api-example","value":"static void addLeafTuple(Relation index, SpGistState *state, SpGistLeafTuple leafTuple, SPPageDesc *current, SPPageDesc *parent, bool isNulls, bool isNew) { spgxlogAddLeaf xlrec; xlrec.newPage = isNew...","count":18},{"name":"api-example","value":"static void bbsink_copystream_begin_archive(bbsink *sink, const char *archive_name) { bbsink_state *state = sink->bbs_state; tablespaceinfo *ti; StringInfoData buf; ti = list_nth(state->tablespaces, s...","count":18},{"name":"api-example","value":"static void check_for_data_types_usage(ClusterInfo *cluster, DataTypesUsageChecks *checks) { bool\t\tfound = false; bool\t   *results; PQExpBufferData report; DataTypesUsageChecks *tmp = checks; int\t\t\tn_...","count":18},{"name":"api-example","value":"static void check_publications(WalReceiverConn *wrconn, List *publications) { WalRcvExecResult *res; StringInfo\tcmd; TupleTableSlot *slot; List\t   *publicationsCopy = NIL; Oid\t\t\ttableRow[1] = {TEXTOID...","count":18},{"name":"api-example","value":"static void compute_index_stats(Relation onerel, double totalrows, AnlIndexData *indexdata, int nindexes, HeapTuple *rows, int numrows, MemoryContext col_context) { MemoryContext ind_context, old_cont...","count":18},{"name":"api-example","value":"static void execute_extension_script(Oid extensionOid, ExtensionControlFile *control, const char *from_version, const char *version, List *requiredSchemas, const char *schemaName, Oid schemaOid) { boo...","count":18},{"name":"api-example","value":"static void flagInhTables(Archive *fout, TableInfo *tblinfo, int numTables, InhInfo *inhinfo, int numInherits) { TableInfo  *child = NULL; TableInfo  *parent = NULL; int\t\t\ti, j; * Set up links from ch...","count":18},{"name":"api-example","value":"static void ginFinishOldSplit(GinBtree btree, GinBtreeStack *stack, GinStatsData *buildStats, int access) { INJECTION_POINT(\"gin-finish-incomplete-split\"); elog(DEBUG1, \"finishing incomplete split of ...","count":18},{"name":"api-example","value":"static void gist_indexsortbuild(GISTBuildState *state) { IndexTuple\titup; GistSortedBuildLevelState *levelstate; BulkWriteBuffer rootbuf; state->pages_allocated = 1; state->bulkstate = smgr_bulk_start...","count":18},{"name":"api-example","value":"static void logical_end_heap_rewrite(RewriteState state) { HASH_SEQ_STATUS seq_status; RewriteMappingFile *src; if (!state->rs_logical_rewrite) return; if (state->rs_num_rewrite_mappings > 0) logical_...","count":18},{"name":"api-example","value":"static void logicalrep_worker_onexit(int code, Datum arg) { if (LogRepWorkerWalRcvConn) walrcv_disconnect(LogRepWorkerWalRcvConn); logicalrep_worker_detach(); if (MyLogicalRepWorker->stream_fileset !=...","count":18},{"name":"api-example","value":"static void tuplesort_begin_batch(Tuplesortstate *state) { MemoryContext oldcontext; oldcontext = MemoryContextSwitchTo(state->base.maincontext); * Caller tuple (e.g. IndexTuple) memory context. * * A...","count":18},{"name":"api-example","value":"void AtEOSubXact_Parallel(bool isCommit, SubTransactionId mySubId) { while (!dlist_is_empty(&pcxt_list)) { ParallelContext *pcxt; pcxt = dlist_head_element(ParallelContext, node, &pcxt_list); if (pcxt...","count":18},{"name":"api-example","value":"void EncodeSpecialDate(DateADT dt, char *str) { if (DATE_IS_NOBEGIN(dt)) strcpy(str, EARLY); else if (DATE_IS_NOEND(dt)) strcpy(str, LATE); else\t\t\t\t\t\t/* shouldn't happen */ elog(ERROR, \"invalid argume...","count":18},{"name":"api-example","value":"void ExecEvalConstraintNotNull(ExprState *state, ExprEvalStep *op) { if (*op->resnull) errsave((Node *) op->d.domaincheck.escontext, (errcode(ERRCODE_NOT_NULL_VIOLATION), errmsg(\"domain %s does not al...","count":18},{"name":"api-example","value":"void ExecParallelReinitialize(PlanState *planstate, ParallelExecutorInfo *pei, Bitmapset *sendParams) { EState\t   *estate = planstate->state; FixedParallelExecutorState *fpes; Assert(pei->finished); *...","count":18},{"name":"api-example","value":"void gin_desc(StringInfo buf, XLogReaderState *record) { char\t   *rec = XLogRecGetData(record); uint8\t\tinfo = XLogRecGetInfo(record) & ~XLR_INFO_MASK; switch (info) { case XLOG_GIN_CREATE_PTREE: break...","count":18},{"name":"api-example","value":"void parsetext(Oid cfgId, ParsedText *prs, char *buf, int buflen) { int\t\t\ttype, lenlemm = 0;\t/* silence compiler warning */ char\t   *lemm = NULL; LexizeData\tldata; TSLexeme   *norms; TSConfigCacheEntr...","count":18},{"name":"api-example","value":"void printsimple_startup(DestReceiver *self, int operation, TupleDesc tupdesc) { StringInfoData buf; int\t\t\ti; pq_beginmessage(&buf, PqMsg_RowDescription); pq_sendint16(&buf, tupdesc->natts); for (i = ...","count":18},{"name":"api-example","value":"void restoreTwoPhaseData(void) { DIR\t\t   *cldir; struct dirent *clde; LWLockAcquire(TwoPhaseStateLock, LW_EXCLUSIVE); cldir = AllocateDir(TWOPHASE_DIR); while ((clde = ReadDir(cldir, TWOPHASE_DIR)) !=...","count":18},{"name":"Feature","value":"Extension Installation","count":17},{"name":"Feature","value":"Full SSL support","count":17},{"name":"Feature","value":"Advisory locks","count":16},{"name":"Feature","value":"B-tree bottom-up index deletion","count":16},{"name":"Feature","value":"CONTINUE statement for PL/pgSQL","count":16},{"name":"Feature","value":"Client can require SCRAM channel binding","count":16},{"name":"Feature","value":"ICU collations","count":16},{"name":"Feature","value":"INSERT/UPDATE/DELETE RETURNING","count":16},{"name":"Feature","value":"IPv6 Support","count":16},{"name":"Feature","value":"Multiple language support","count":16},{"name":"Feature","value":"ORDER BY NULLS FIRST/LAST","count":16},{"name":"api-caller-count","value":"156","count":16},{"name":"api-caller-count","value":"160","count":16},{"name":"api-caller-count","value":"710","count":16},{"name":"api-typical-usage","value":"Often called from: ATExecAttachPartition","count":16},{"name":"api-typical-usage","value":"Often called from: ATExecSetRelOptions","count":16},{"name":"api-typical-usage","value":"Often called from: AddUserToTokenDacl","count":16},{"name":"api-typical-usage","value":"Often called from: AfterTriggerExecute","count":16},{"name":"api-typical-usage","value":"Often called from: AllocSetAllocChunkFromBlock","count":16},{"name":"api-typical-usage","value":"Often called from: BufferGetLSNAtomic","count":16},{"name":"api-typical-usage","value":"Often called from: CheckSASLAuth","count":16},{"name":"api-typical-usage","value":"Often called from: ComputeXidHorizons","count":16},{"name":"api-typical-usage","value":"Often called from: CopyCachedPlan","count":16},{"name":"api-typical-usage","value":"Often called from: CreateWorkExprContext","count":16},{"name":"api-typical-usage","value":"Often called from: DecodeUnits","count":16},{"name":"api-typical-usage","value":"Often called from: DllRegisterServer","count":16},{"name":"api-typical-usage","value":"Often called from: DropAllPredicateLocksFromTable","count":16},{"name":"api-typical-usage","value":"Often called from: DropSubscription","count":16},{"name":"api-typical-usage","value":"Often called from: ECPGdisconnect","count":16},{"name":"api-typical-usage","value":"Often called from: EncodeSpecialTimestamp","count":16},{"name":"api-typical-usage","value":"Often called from: EventTriggerOnLogin","count":16},{"name":"api-typical-usage","value":"Often called from: ExecBuildAuxRowMark","count":16},{"name":"api-typical-usage","value":"Often called from: ExecEvalJsonIsPredicate","count":16},{"name":"api-typical-usage","value":"Often called from: ExecPostprocessPlan","count":16},{"name":"api-typical-usage","value":"Often called from: FreePageManagerGetInternal","count":16},{"name":"api-typical-usage","value":"Often called from: GenerationRealloc","count":16},{"name":"api-typical-usage","value":"Often called from: GenericXLogFinish","count":16},{"name":"api-typical-usage","value":"Often called from: GenericXLogStart","count":16},{"name":"api-typical-usage","value":"Often called from: GetLockConflicts","count":16},{"name":"api-typical-usage","value":"Often called from: IN6ADDR_ISANY","count":16},{"name":"api-typical-usage","value":"Often called from: InitPostgres","count":16},{"name":"api-typical-usage","value":"Often called from: LWLockAcquire","count":16},{"name":"api-typical-usage","value":"Often called from: LWLockAcquireOrWait","count":16},{"name":"api-typical-usage","value":"Often called from: LogLogicalInvalidations","count":16},{"name":"api-typical-usage","value":"Often called from: PGTYPESnumeric_div","count":16},{"name":"api-typical-usage","value":"Often called from: PGTYPEStimestamp_defmt_scan","count":16},{"name":"api-typical-usage","value":"Often called from: PLy_spi_subtransaction_abort","count":16},{"name":"api-typical-usage","value":"Often called from: PLy_trigger_build_args","count":16},{"name":"api-typical-usage","value":"Often called from: PersistHoldablePortal","count":16},{"name":"api-typical-usage","value":"Often called from: ProcArrayApplyRecoveryInfo","count":16},{"name":"api-typical-usage","value":"Often called from: RE_compile_and_execute","count":16},{"name":"api-typical-usage","value":"Often called from: ReadArrayStr","count":16},{"name":"api-typical-usage","value":"Often called from: SetMultiXactIdLimit","count":16},{"name":"api-typical-usage","value":"Often called from: SetUserIdAndContext","count":16},{"name":"api-typical-usage","value":"Often called from: SimpleLruInit","count":16},{"name":"api-typical-usage","value":"Often called from: TransferPredicateLocksToNewTarget","count":16},{"name":"api-typical-usage","value":"Often called from: WalRcvDie","count":16},{"name":"api-typical-usage","value":"Often called from: WriteControlFile","count":16},{"name":"api-typical-usage","value":"Often called from: XLogDecodeNextRecord","count":16},{"name":"api-typical-usage","value":"Often called from: _bt_check_rowcompare","count":16},{"name":"api-typical-usage","value":"Often called from: _bt_readpage","count":16},{"name":"api-typical-usage","value":"Often called from: _hash_expandtable","count":16},{"name":"api-typical-usage","value":"Often called from: _hash_init_metabuffer","count":16},{"name":"api-typical-usage","value":"Often called from: _scprintf_p_l","count":16},{"name":"api-typical-usage","value":"Often called from: _snwscanf_s","count":16},{"name":"api-typical-usage","value":"Often called from: _sprintf_p_l","count":16},{"name":"api-typical-usage","value":"Often called from: _swscanf_s_l","count":16},{"name":"api-typical-usage","value":"Often called from: _vprintf_l","count":16},{"name":"api-typical-usage","value":"Often called from: _vprintf_p_l","count":16},{"name":"api-typical-usage","value":"Often called from: _vscanf_l","count":16},{"name":"api-typical-usage","value":"Often called from: _vsnprintf_c","count":16},{"name":"api-typical-usage","value":"Often called from: _vsprintf_l","count":16},{"name":"api-typical-usage","value":"Often called from: _vswscanf_s_l","count":16},{"name":"api-typical-usage","value":"Often called from: aclmask","count":16},{"name":"api-typical-usage","value":"Often called from: advance_windowaggregate_base","count":16},{"name":"api-typical-usage","value":"Often called from: arraycontsel","count":16},{"name":"api-typical-usage","value":"Often called from: assignProcTypes","count":16},{"name":"api-typical-usage","value":"Often called from: begin_partition","count":16},{"name":"api-typical-usage","value":"Often called from: bitsubstring","count":16},{"name":"api-typical-usage","value":"Often called from: brin_inclusion_union","count":16},{"name":"api-typical-usage","value":"Often called from: calc_arraycontsel","count":16},{"name":"api-typical-usage","value":"Often called from: check_object_ownership","count":16},{"name":"api-typical-usage","value":"Often called from: commit_ts_redo","count":16},{"name":"api-typical-usage","value":"Often called from: compile_pltcl_function","count":16},{"name":"api-typical-usage","value":"Often called from: consoleHandler","count":16},{"name":"api-typical-usage","value":"Often called from: cost_qual_eval_walker","count":16},{"name":"api-typical-usage","value":"Often called from: create_ordered_paths","count":16},{"name":"api-typical-usage","value":"Often called from: dataSplitPageInternal","count":16},{"name":"api-typical-usage","value":"Often called from: date2timestamptz_opt_overflow","count":16},{"name":"api-typical-usage","value":"Often called from: datumTransfer","count":16},{"name":"api-typical-usage","value":"Often called from: dsa_allocate_extended","count":16},{"name":"api-typical-usage","value":"Often called from: dsm_impl_windows","count":16},{"name":"api-typical-usage","value":"Often called from: ecpg_do_prologue","count":16},{"name":"api-typical-usage","value":"Often called from: ecpg_store_input","count":16},{"name":"api-typical-usage","value":"Often called from: eqjoinsel_inner","count":16},{"name":"api-typical-usage","value":"Often called from: estimate_multivariate_ndistinct","count":16},{"name":"api-typical-usage","value":"Often called from: exec_simple_query","count":16},{"name":"api-typical-usage","value":"Often called from: exec_stmt_raise","count":16},{"name":"api-typical-usage","value":"Often called from: execute_extension_script","count":16},{"name":"api-typical-usage","value":"Often called from: expanded_record_set_tuple","count":16},{"name":"api-typical-usage","value":"Often called from: finalize_plan","count":16},{"name":"api-typical-usage","value":"Often called from: finalize_windowaggregate","count":16},{"name":"api-typical-usage","value":"Often called from: find_struct_member","count":16},{"name":"api-typical-usage","value":"Often called from: flattenJsonPathParseItem","count":16},{"name":"api-typical-usage","value":"Often called from: float8_timestamptz","count":16},{"name":"api-typical-usage","value":"Often called from: format_type_extended","count":16},{"name":"api-typical-usage","value":"Often called from: fprintf_s","count":16},{"name":"api-typical-usage","value":"Often called from: function_inlinable","count":16},{"name":"api-typical-usage","value":"Often called from: fwprintf_s","count":16},{"name":"api-typical-usage","value":"Often called from: get_prompt","count":16},{"name":"api-typical-usage","value":"Often called from: get_variable_range","count":16},{"name":"api-typical-usage","value":"Often called from: getopt_long","count":16},{"name":"api-typical-usage","value":"Often called from: ginvalidate","count":16},{"name":"api-typical-usage","value":"Often called from: gistvacuum_delete_empty_pages","count":16},{"name":"api-typical-usage","value":"Often called from: gtsquery_picksplit","count":16},{"name":"api-typical-usage","value":"Often called from: hash_bytes_extended","count":16},{"name":"api-typical-usage","value":"Often called from: heap_compare_slots","count":16},{"name":"api-typical-usage","value":"Often called from: heap_prune_chain","count":16},{"name":"api-typical-usage","value":"Often called from: initGISTstate","count":16},{"name":"api-typical-usage","value":"Often called from: int8inc_support","count":16},{"name":"api-typical-usage","value":"Often called from: jsonb_path_query_first_internal","count":16},{"name":"api-typical-usage","value":"Often called from: lazy_cleanup_all_indexes","count":16},{"name":"api-typical-usage","value":"Often called from: lexescape","count":16},{"name":"api-typical-usage","value":"Often called from: line_eq","count":16},{"name":"api-typical-usage","value":"Often called from: lo_export","count":16},{"name":"api-typical-usage","value":"Often called from: macaddr_cmp_internal","count":16},{"name":"api-typical-usage","value":"Often called from: makepol","count":16},{"name":"api-typical-usage","value":"Often called from: mdsyncfiletag","count":16},{"name":"api-typical-usage","value":"Often called from: nocachegetattr","count":16},{"name":"api-typical-usage","value":"Often called from: op_mergejoinable","count":16},{"name":"api-typical-usage","value":"Often called from: open_client_SSL","count":16},{"name":"api-typical-usage","value":"Often called from: operator_predicate_proof","count":16},{"name":"api-typical-usage","value":"Often called from: pa_setup_dsm","count":16},{"name":"api-typical-usage","value":"Often called from: parallel_vacuum_index_is_parallel_safe","count":16},{"name":"api-typical-usage","value":"Often called from: parse","count":16},{"name":"api-typical-usage","value":"Often called from: parse_affentry","count":16},{"name":"api-typical-usage","value":"Often called from: parse_hba_line","count":16},{"name":"api-typical-usage","value":"Often called from: path_add_pt","count":16},{"name":"api-typical-usage","value":"Often called from: perform_base_backup","count":16},{"name":"api-typical-usage","value":"Often called from: pg_GSS_read","count":16},{"name":"api-typical-usage","value":"Often called from: pg_create_restore_point","count":16},{"name":"api-typical-usage","value":"Often called from: pg_regexec","count":16},{"name":"api-typical-usage","value":"Often called from: pg_snapshot_send","count":16},{"name":"api-typical-usage","value":"Often called from: pg_stat_get_replication_slot","count":16},{"name":"api-typical-usage","value":"Often called from: pg_tzset","count":16},{"name":"api-typical-usage","value":"Often called from: pg_wcsformat","count":16},{"name":"api-typical-usage","value":"Often called from: pgstat_report_checkpointer","count":16},{"name":"api-typical-usage","value":"Often called from: pgstat_report_replslot","count":16},{"name":"api-typical-usage","value":"Often called from: pgstat_write_statsfile","count":16},{"name":"api-typical-usage","value":"Often called from: pgwin32_select","count":16},{"name":"api-typical-usage","value":"Often called from: pointToRectBoxDistance","count":16},{"name":"api-typical-usage","value":"Often called from: poly_left","count":16},{"name":"api-typical-usage","value":"Often called from: populate_joinrel_with_paths","count":16},{"name":"api-typical-usage","value":"Often called from: pqParseInput3","count":16},{"name":"api-typical-usage","value":"Often called from: predicate_refuted_by_recurse","count":16},{"name":"api-typical-usage","value":"Often called from: pset_value_string","count":16},{"name":"api-typical-usage","value":"Often called from: pull_varnos","count":16},{"name":"api-typical-usage","value":"Often called from: range_gist_picksplit","count":16},{"name":"api-typical-usage","value":"Often called from: rbt_delete_fixup","count":16},{"name":"api-typical-usage","value":"Often called from: reconstruct_from_incremental_file","count":16},{"name":"api-typical-usage","value":"Often called from: recordExtObjInitPriv","count":16},{"name":"api-typical-usage","value":"Often called from: remove_dbtablespaces","count":16},{"name":"api-typical-usage","value":"Often called from: reparameterize_path_by_child","count":16},{"name":"api-typical-usage","value":"Often called from: revalidate_rectypeid","count":16},{"name":"api-typical-usage","value":"Often called from: rewrite_heap_tuple","count":16},{"name":"api-typical-usage","value":"Often called from: ri_Check_Pk_Match","count":16},{"name":"api-typical-usage","value":"Often called from: ri_LoadConstraintInfo","count":16},{"name":"api-typical-usage","value":"Often called from: rpytime","count":16},{"name":"api-typical-usage","value":"Often called from: run_ssl_passphrase_command","count":16},{"name":"api-typical-usage","value":"Often called from: scalararraysel","count":16},{"name":"api-typical-usage","value":"Often called from: scanf_s","count":16},{"name":"api-typical-usage","value":"Often called from: serializeAnalyzeReceive","count":16},{"name":"api-typical-usage","value":"Often called from: set_dl_error","count":16},{"name":"api-typical-usage","value":"Often called from: set_join_references","count":16},{"name":"api-typical-usage","value":"Often called from: setup_config","count":16},{"name":"api-typical-usage","value":"Often called from: sha1_pad","count":16},{"name":"api-typical-usage","value":"Often called from: spgExtractNodeLabels","count":16},{"name":"api-typical-usage","value":"Often called from: spgRedoAddNode","count":16},{"name":"api-typical-usage","value":"Often called from: spg_quad_inner_consistent","count":16},{"name":"api-typical-usage","value":"Often called from: split_part","count":16},{"name":"api-typical-usage","value":"Often called from: startScanEntry","count":16},{"name":"api-typical-usage","value":"Often called from: supportSecondarySplit","count":16},{"name":"api-typical-usage","value":"Often called from: timestamptz_to_str","count":16},{"name":"api-typical-usage","value":"Often called from: transformColumnRef","count":16},{"name":"api-typical-usage","value":"Often called from: transformLockingClause","count":16},{"name":"api-typical-usage","value":"Often called from: tsquery_or","count":16},{"name":"api-typical-usage","value":"Often called from: vacuum_rel","count":16},{"name":"api-typical-usage","value":"Often called from: validateTzEntry","count":16},{"name":"api-typical-usage","value":"Often called from: vsscanf_s","count":16},{"name":"api-typical-usage","value":"Often called from: vwscanf_s","count":16},{"name":"coupling-score","value":"41","count":16},{"name":"coupling-score","value":"46","count":16},{"name":"coupling-score","value":"47","count":16},{"name":"coupling-score","value":"55","count":16},{"name":"coupling-score","value":"61","count":16},{"name":"cyclomatic-complexity","value":"109","count":16},{"name":"cyclomatic-complexity","value":"115","count":16},{"name":"cyclomatic-complexity","value":"119","count":16},{"name":"cyclomatic-complexity","value":"120","count":16},{"name":"cyclomatic-complexity","value":"128","count":16},{"name":"cyclomatic-complexity","value":"131","count":16},{"name":"cyclomatic-complexity","value":"132","count":16},{"name":"cyclomatic-complexity","value":"139","count":16},{"name":"cyclomatic-complexity","value":"141","count":16},{"name":"cyclomatic-complexity","value":"142","count":16},{"name":"cyclomatic-complexity","value":"146","count":16},{"name":"cyclomatic-complexity","value":"152","count":16},{"name":"cyclomatic-complexity","value":"157","count":16},{"name":"cyclomatic-complexity","value":"166","count":16},{"name":"cyclomatic-complexity","value":"173","count":16},{"name":"cyclomatic-complexity","value":"182","count":16},{"name":"cyclomatic-complexity","value":"216","count":16},{"name":"cyclomatic-complexity","value":"91","count":16},{"name":"cyclomatic-complexity","value":"95","count":16},{"name":"cyclomatic-complexity","value":"97","count":16},{"name":"lines-of-code","value":"193","count":16},{"name":"lines-of-code","value":"230","count":16},{"name":"lines-of-code","value":"239","count":16},{"name":"lines-of-code","value":"247","count":16},{"name":"lines-of-code","value":"249","count":16},{"name":"lines-of-code","value":"252","count":16},{"name":"lines-of-code","value":"261","count":16},{"name":"lines-of-code","value":"273","count":16},{"name":"lines-of-code","value":"274","count":16},{"name":"lines-of-code","value":"276","count":16},{"name":"lines-of-code","value":"288","count":16},{"name":"lines-of-code","value":"289","count":16},{"name":"lines-of-code","value":"292","count":16},{"name":"lines-of-code","value":"293","count":16},{"name":"lines-of-code","value":"299","count":16},{"name":"lines-of-code","value":"301","count":16},{"name":"lines-of-code","value":"305","count":16},{"name":"lines-of-code","value":"310","count":16},{"name":"lines-of-code","value":"314","count":16},{"name":"lines-of-code","value":"325","count":16},{"name":"lines-of-code","value":"332","count":16},{"name":"lines-of-code","value":"333","count":16},{"name":"lines-of-code","value":"338","count":16},{"name":"lines-of-code","value":"340","count":16},{"name":"lines-of-code","value":"346","count":16},{"name":"lines-of-code","value":"348","count":16},{"name":"lines-of-code","value":"360","count":16},{"name":"lines-of-code","value":"363","count":16},{"name":"lines-of-code","value":"366","count":16},{"name":"lines-of-code","value":"377","count":16},{"name":"lines-of-code","value":"385","count":16},{"name":"lines-of-code","value":"386","count":16},{"name":"lines-of-code","value":"390","count":16},{"name":"lines-of-code","value":"392","count":16},{"name":"lines-of-code","value":"405","count":16},{"name":"lines-of-code","value":"469","count":16},{"name":"lines-of-code","value":"476","count":16},{"name":"lines-of-code","value":"478","count":16},{"name":"lines-of-code","value":"523","count":16},{"name":"lines-of-code","value":"527","count":16},{"name":"loop-depth","value":"58","count":16},{"name":"module-depends-on","value":"<unknown>, backend\\jit\\llvm\\postgres.h","count":16},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\mb\\mbutils.c, common\\wchar.c","count":16},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\fmgr\\fmgr.c, backend\\jit\\llvm\\postgres.h","count":16},{"name":"test-count","value":"23","count":16},{"name":"test-count","value":"49","count":16},{"name":"test-count","value":"65","count":16},{"name":"tested-by","value":"check_and_drop_existing_subscriptions","count":16},{"name":"tested-by","value":"check_db_file_conflict","count":16},{"name":"tested-by","value":"check_functions_in_node","count":16},{"name":"tested-by","value":"check_generic_type_consistency, check_generic_type_consistency","count":16},{"name":"tested-by","value":"check_hba, check_ident_usermap","count":16},{"name":"tested-by","value":"check_log_duration","count":16},{"name":"tested-by","value":"check_new_partition_bound, check_new_partition_bound","count":16},{"name":"tested-by","value":"check_output_expressions","count":16},{"name":"tested-by","value":"check_publisher","count":16},{"name":"tested-by","value":"check_role_for_policy","count":16},{"name":"tested-by","value":"check_same_host_or_net","count":16},{"name":"tested-by","value":"check_sql_fn_retval","count":16},{"name":"tested-by","value":"check_timezone, check_log_timezone","count":16},{"name":"tested-by","value":"check_ungrouped_columns_walker","count":16},{"name":"tested-by","value":"check_usermap, check_usermap","count":16},{"name":"tested-by","value":"check_wal_consistency_checking, check_wal_consistency_checking, check_wal_consistency_checking, check_wal_consistency_checking, check_wal_consistency_checking","count":16},{"name":"tested-by","value":"check_weight","count":16},{"name":"tested-by","value":"convert_testexpr_mutator","count":16},{"name":"tested-by","value":"domain_check_input, domain_check_input, populate_array_check_dimension","count":16},{"name":"tested-by","value":"ecpg_check_PQresult","count":16},{"name":"tested-by","value":"lazy_check_wraparound_failsafe","count":16},{"name":"tested-by","value":"pg_attribute_aclcheck_all_ext","count":16},{"name":"tested-by","value":"restrict_and_check_grant, check_circularity","count":16},{"name":"tested-by","value":"spgLeafTest","count":16},{"name":"tested-by","value":"spgTestLeafTuple","count":16},{"name":"tested-by","value":"test_sync, test_sync, test_file_descriptor_sync, test_file_descriptor_sync, test_non_sync","count":16},{"name":"Feature","value":"64-bit large objects","count":15},{"name":"Feature","value":"ALTER SUBSCRIPTION ... SKIP","count":15},{"name":"Feature","value":"ALTER TABLE / ENABLE REPLICA TRIGGER/RULE","count":15},{"name":"Feature","value":"ALTER TABLE ENABLE/DISABLE TRIGGER","count":15},{"name":"Feature","value":"ALTER object IF EXISTS","count":15},{"name":"Feature","value":"ANY_VALUE aggregate","count":15},{"name":"Feature","value":"Abbreviated Keys","count":15},{"name":"Feature","value":"Array support","count":15},{"name":"Feature","value":"Arrays of compound types","count":15},{"name":"Feature","value":"Automatic plan invalidation","count":15},{"name":"Feature","value":"BEGIN ATOMIC function bodies","count":15},{"name":"Feature","value":"Background Checkpointer","count":15},{"name":"Feature","value":"Base backup throttling","count":15},{"name":"Feature","value":"Block-range (BRIN) indexes","count":15},{"name":"Feature","value":"Built-in, platform independent immutable collation","count":15},{"name":"Feature","value":"CALL syntax for executing procedures","count":15},{"name":"Feature","value":"CASE in pl/pgsql","count":15},{"name":"Feature","value":"COPY ... ON_ERROR","count":15},{"name":"Feature","value":"COPY FROM ... WHERE","count":15},{"name":"Feature","value":"COPY from/to STDIN/STDOUT","count":15},{"name":"Feature","value":"COPY with arbitrary SELECT","count":15},{"name":"Feature","value":"CREATE ACCESS METHOD","count":15},{"name":"Feature","value":"CREATE EXTENSION .. CASCADE","count":15},{"name":"Feature","value":"CREATE STATISTICS - most-common values (MCV) statistics","count":15},{"name":"Feature","value":"CREATE STATISTICS - multicolumn","count":15},{"name":"Feature","value":"CREATE TABLE ... (LIKE) with foreign tables, views and composite types","count":15},{"name":"Feature","value":"Cascading streaming replication","count":15},{"name":"Feature","value":"Certificate authentication with postgres_fdw","count":15},{"name":"Feature","value":"Checksum on data pages","count":15},{"name":"Feature","value":"Column level triggers","count":15},{"name":"Feature","value":"Column-level collation support","count":15},{"name":"Feature","value":"Concurrent GiST indexes","count":15},{"name":"Feature","value":"Configure max WAL retention for replication slots","count":15},{"name":"Feature","value":"Covering Indexes for B-trees (INCLUDE)","count":15},{"name":"Feature","value":"Covering indexes for GiST (INCLUDE)","count":15},{"name":"Feature","value":"Cursors","count":15},{"name":"Feature","value":"Custom background workers","count":15},{"name":"Feature","value":"DO statement for pl/perl","count":15},{"name":"Feature","value":"DO statement for pl/pgsql","count":15},{"name":"Feature","value":"Database level Collation","count":15},{"name":"Feature","value":"Declarative table partitioning","count":15},{"name":"Feature","value":"Default ICU collations for clusters/databases","count":15},{"name":"Feature","value":"Default Partition","count":15},{"name":"Feature","value":"Default permissions","count":15},{"name":"Feature","value":"Direct TLS negotiation (\"sslnegotiation\")","count":15},{"name":"Feature","value":"Disk based FSM","count":15},{"name":"Feature","value":"Dynamic Background Workers","count":15},{"name":"Feature","value":"ENUM data type","count":15},{"name":"Feature","value":"EUC_JIS_2004/ SHIFT_JIS_2004 support","count":15},{"name":"Feature","value":"EXCEPTION support in PL/pgSQL","count":15},{"name":"Feature","value":"EXPLAIN (BUFFERS) support","count":15},{"name":"Feature","value":"EXPLAIN (MEMORY)","count":15},{"name":"Feature","value":"EXPLAIN (SERIALIZE) support","count":15},{"name":"Feature","value":"EXPLAIN (WAL) support","count":15},{"name":"Feature","value":"Event triggers","count":15},{"name":"Feature","value":"FILTER clause for aggregate functions","count":15},{"name":"Feature","value":"FOREACH IN ARRAY in pl/pgsql","count":15},{"name":"Feature","value":"Foreign Key references for partitioned tables","count":15},{"name":"Feature","value":"Foreign Tables","count":15},{"name":"Feature","value":"Foreign data wrappers","count":15},{"name":"Feature","value":"Foreign keys marked as NOT VALID","count":15},{"name":"Feature","value":"Foreign table inheritance","count":15},{"name":"Feature","value":"Frozen page map","count":15},{"name":"Feature","value":"Full Text Search","count":15},{"name":"Feature","value":"GIN (Generalized Inverted Index) Indexes","count":15},{"name":"Feature","value":"GIN Index performance and size improvements","count":15},{"name":"Feature","value":"GIN indexes partial match","count":15},{"name":"Feature","value":"GRANT/REVOKE ON ALL TABLES/SEQUENCES/FUNCTIONS","count":15},{"name":"Feature","value":"GSSAPI client and server-side encryption","count":15},{"name":"Feature","value":"GSSAPI support","count":15},{"name":"Feature","value":"Generic WAL facility","count":15},{"name":"Feature","value":"GiST (Generalized Search Tree) Indexes","count":15},{"name":"Feature","value":"Hash aggregation can use disk","count":15},{"name":"Feature","value":"Hashing support for DISTINCT/UNION/INTERSECT/EXCEPT","count":15},{"name":"Feature","value":"Heap Only Tuples (HOT)","count":15},{"name":"Feature","value":"Hot Standby","count":15},{"name":"Feature","value":"IN/OUT/INOUT parameters for pl/pgsql and PL/SQL","count":15},{"name":"Feature","value":"Import foreign table partitions","count":15},{"name":"Feature","value":"Improved performance for sorts exceeding working memory","count":15},{"name":"Feature","value":"Improved set of JSON functions and operators","count":15},{"name":"Feature","value":"Improved window function performance","count":15},{"name":"Feature","value":"In-memory Bitmap Indexes","count":15},{"name":"Feature","value":"Include directives for pg_hba.conf and pg_ident.conf","count":15},{"name":"Feature","value":"Incremental sort for SELECT DISTINCT","count":15},{"name":"Feature","value":"Incremental sort for window functions","count":15},{"name":"Feature","value":"Index support for IS NULL","count":15},{"name":"Feature","value":"Index-only scans","count":15},{"name":"Feature","value":"Index-only scans on GiST","count":15},{"name":"Feature","value":"Inlined WITH Queries (Common Table Expressions)","count":15},{"name":"Feature","value":"Inlining of SQL-functions","count":15},{"name":"Feature","value":"Inserted data can trigger autovacuum","count":15},{"name":"Feature","value":"Integrated autovacuum daemon","count":15},{"name":"Feature","value":"JSON data type","count":15},{"name":"Feature","value":"JSONB data type","count":15},{"name":"Feature","value":"JSONB-modifying operators and functions","count":15},{"name":"Feature","value":"Just-in-Time (JIT) compilation for expression evaluation and tuple deforming","count":15},{"name":"Feature","value":"K-nearest neighbor GiST support","count":15},{"name":"Feature","value":"K-nearest neighbor SP-GiST Support","count":15},{"name":"Feature","value":"LATERAL clause","count":15},{"name":"Feature","value":"LDAP server discovery","count":15},{"name":"Feature","value":"LZ4 compression for TOAST tables","count":15},{"name":"Feature","value":"Logical replication","count":15},{"name":"Feature","value":"Logical replication avoids replication loops","count":15},{"name":"Feature","value":"Logical replication column lists","count":15},{"name":"Feature","value":"Logical replication for partitioned tables","count":15},{"name":"Feature","value":"Logical replication from standbys","count":15},{"name":"Feature","value":"Logical replication initial sync using binary protocol","count":15},{"name":"Feature","value":"Logical replication lookups with additional indexes","count":15},{"name":"Feature","value":"Logical replication publish all tables in schema","count":15},{"name":"Feature","value":"Logical replication row filtering","count":15},{"name":"Feature","value":"Logical replication slots migrate through pg_upgrade migrate","count":15},{"name":"Feature","value":"Logical replication stream in-progress transactions","count":15},{"name":"Feature","value":"Logical replication subscriber can disable on error","count":15},{"name":"Feature","value":"MERGE","count":15},{"name":"Feature","value":"MERGE ... RETURNING","count":15},{"name":"Feature","value":"Microsoft Visual C++ Support","count":15},{"name":"Feature","value":"Multibyte encoding support, incl. UTF8","count":15},{"name":"Feature","value":"Multifactor authentication via valid client SSL/TLS certificate","count":15},{"name":"Feature","value":"Multiple synchronous standbys","count":15},{"name":"Feature","value":"Multiple temporary tablespaces","count":15},{"name":"Feature","value":"Named parameters","count":15},{"name":"Feature","value":"Named restore points","count":15},{"name":"Feature","value":"Native LDAP authentication","count":15},{"name":"Feature","value":"Native RADIUS authentication","count":15},{"name":"Feature","value":"Native Windows Port","count":15},{"name":"Feature","value":"Non-blocking CREATE INDEX","count":15},{"name":"Feature","value":"Non-decimal integer literals","count":15},{"name":"Feature","value":"ORDER BY support within aggregates","count":15},{"name":"Feature","value":"Outer Join reordering","count":15},{"name":"Feature","value":"Page freezing optimizations","count":15},{"name":"Feature","value":"Parallel \"SELECT DISTINCT\"","count":15},{"name":"Feature","value":"Parallel B-tree index scans","count":15},{"name":"Feature","value":"Parallel JOIN, aggregate","count":15},{"name":"Feature","value":"Parallel full table scans (sequential scans)","count":15},{"name":"Feature","value":"Parallel merge joins","count":15},{"name":"Feature","value":"Parallel pg_dump","count":15},{"name":"Feature","value":"Parallel query","count":15},{"name":"Feature","value":"Parallel query execution on remote databases","count":15},{"name":"Feature","value":"Parallel restore","count":15},{"name":"Feature","value":"Parallel vacuumdb jobs","count":15},{"name":"Feature","value":"Parallelized CREATE INDEX for BRIN indexes","count":15},{"name":"Feature","value":"Parallelized VACUUM for Indexes","count":15},{"name":"Feature","value":"Partial sort capability (top-n sorting)","count":15},{"name":"Feature","value":"Partition pruning during query execution","count":15},{"name":"Feature","value":"Payload support for LISTEN/NOTIFY","count":15},{"name":"Feature","value":"Per function GUC settings","count":15},{"name":"Feature","value":"Per function statistics","count":15},{"name":"Feature","value":"Per user/database connection limits","count":15},{"name":"Feature","value":"Phrase search","count":15},{"name":"Feature","value":"Polymorphic functions","count":15},{"name":"Feature","value":"PostgreSQL Foreign Data Wrapper","count":15},{"name":"Feature","value":"Predefined roles","count":15},{"name":"Feature","value":"Privileges for setting configuration parameters","count":15},{"name":"Feature","value":"Query parallelism for RETURN QUERY","count":15},{"name":"Feature","value":"Query pipelining","count":15},{"name":"Feature","value":"Quorum commit for synchronous replication","count":15},{"name":"Feature","value":"REINDEX CONCURRENTLY","count":15},{"name":"Feature","value":"RETURN QUERY EXECUTE","count":15},{"name":"Feature","value":"RETURN QUERY in pl/pgsql","count":15},{"name":"Feature","value":"RETURNS TABLE","count":15},{"name":"Feature","value":"ROLES","count":15},{"name":"Feature","value":"ROWS and COST specification for functions","count":15},{"name":"Feature","value":"Range types","count":15},{"name":"Feature","value":"Reduced lock levels for ALTER TABLE commands","count":15},{"name":"Feature","value":"Regular expression matching in pg_hba.conf and pg_ident.conf","count":15},{"name":"Feature","value":"Row-Level Security","count":15},{"name":"Feature","value":"Row-wise comparison","count":15},{"name":"Feature","value":"SECURITY INVOKER views","count":15},{"name":"Feature","value":"SELECT ... FOR UPDATE/SHARE NOWAIT","count":15},{"name":"Feature","value":"SELECT FOR NO KEY UPDATE/SELECT FOR KEY SHARE lock modes","count":15},{"name":"Feature","value":"SIMD support for x86","count":15},{"name":"Feature","value":"SKIP LOCKED clause","count":15},{"name":"Feature","value":"SP-GiST indexes for range types","count":15},{"name":"Feature","value":"SQL standard interval handling","count":15},{"name":"Feature","value":"SQL-standard information schema","count":15},{"name":"Feature","value":"SQL/JSON IS JSON","count":15},{"name":"Feature","value":"SQLERRM/SQLSTATE for pl/pgsql","count":15},{"name":"Feature","value":"SSL certificate validation in libpq","count":15},{"name":"Feature","value":"SSPI authentication via GSSAPI","count":15},{"name":"Feature","value":"Scrollable and updatable cursor support for pl/pgsql","count":15},{"name":"Feature","value":"Search+bind mode operation for LDAP authentication","count":15},{"name":"Feature","value":"Security Service Provider Interface (SSPI)","count":15},{"name":"Feature","value":"Serializable Snapshot Isolation","count":15},{"name":"Feature","value":"Set costs specific to TABLESPACEs","count":15},{"name":"Feature","value":"Shared row level locking","count":15},{"name":"Feature","value":"Space-Partitioned GiST (SP-GiST) Indexes","count":15},{"name":"Feature","value":"Spinlock support for the SuperH hardware platform","count":15},{"name":"Feature","value":"Statement level TRUNCATE triggers","count":15},{"name":"Feature","value":"Statement level triggers","count":15},{"name":"Feature","value":"Stored Generated Columns","count":15},{"name":"Feature","value":"Streaming Replication","count":15},{"name":"Feature","value":"Streaming-only cascading replication","count":15},{"name":"Feature","value":"Support for PRIMARY KEY, FOREIGN KEY, indexes, and triggers on partitioned tables","count":15},{"name":"Feature","value":"Support for anonymous shared memory","count":15},{"name":"Feature","value":"Synchronized sequential scanning","count":15},{"name":"Feature","value":"Synchronous replication","count":15},{"name":"Feature","value":"TABLE statement","count":15},{"name":"Feature","value":"TABLESAMPLE clause","count":15},{"name":"Feature","value":"Temporary VIEWs","count":15},{"name":"Feature","value":"Time-delayed Standbys","count":15},{"name":"Feature","value":"Triggers on views","count":15},{"name":"Feature","value":"Trusted Extensions","count":15},{"name":"Feature","value":"Typed tables","count":15},{"name":"Feature","value":"UNIQUE NULLS NOT DISTINCT","count":15},{"name":"Feature","value":"UTF8 support on Windows","count":15},{"name":"Feature","value":"Underscores (_) for thousands separators","count":15},{"name":"Feature","value":"Unlogged tables","count":15},{"name":"Feature","value":"Updatable cursors","count":15},{"name":"Feature","value":"Updatable views","count":15},{"name":"Feature","value":"Upsert (INSERT ... ON CONFLICT DO ...)","count":15},{"name":"Feature","value":"User defined exceptions","count":15},{"name":"Feature","value":"V3 client protocol","count":15},{"name":"Feature","value":"Vacuum \"emergency mode\"","count":15},{"name":"Feature","value":"Validator function for pl/perl","count":15},{"name":"Feature","value":"Verify backup integrity (pg_verifybackup)","count":15},{"name":"Feature","value":"Version aware psql","count":15},{"name":"Feature","value":"Visibility Map for Vacuuming","count":15},{"name":"Feature","value":"WAL support for hash indexes","count":15},{"name":"Feature","value":"WITH CHECK clause","count":15},{"name":"Feature","value":"WITH ORDINALITY clause","count":15},{"name":"Feature","value":"WITH Queries (Common Table Expressions)","count":15},{"name":"Feature","value":"Warm Standby","count":15},{"name":"Feature","value":"Windows x64 support","count":15},{"name":"Feature","value":"Writable Foreign Data Wrappers","count":15},{"name":"Feature","value":"Writable WITH Queries (Common Table Expressions)","count":15},{"name":"Feature","value":"XML data type","count":15},{"name":"Feature","value":"XML, JSON and YAML output for EXPLAIN","count":15},{"name":"Feature","value":"dblink asyncronous notification support","count":15},{"name":"Feature","value":"isn (ISBN)","count":15},{"name":"Feature","value":"krb5 authentication (without gssapi)","count":15},{"name":"Feature","value":"macaddr8 data type","count":15},{"name":"Feature","value":"pg_basebackup client decompression","count":15},{"name":"Feature","value":"pg_basebackup incremental backup","count":15},{"name":"Feature","value":"pg_basebackup server-side compression","count":15},{"name":"Feature","value":"pg_basebackup tool","count":15},{"name":"Feature","value":"pg_combinebackup","count":15},{"name":"Feature","value":"pg_config system view","count":15},{"name":"Feature","value":"pg_dump, pg_dumpall, pg_restore --filter","count":15},{"name":"Feature","value":"pg_rewind","count":15},{"name":"Feature","value":"pg_stat_checkpointer system view","count":15},{"name":"Feature","value":"pg_stat_io - I/O metrics view","count":15},{"name":"Feature","value":"pg_upgrade","count":15},{"name":"Feature","value":"pg_wait_events system view","count":15},{"name":"Feature","value":"pg_waldump","count":15},{"name":"Feature","value":"pg_walsummary","count":15},{"name":"Feature","value":"pgbench","count":15},{"name":"Feature","value":"pl/pgsql installed by default","count":15},{"name":"Feature","value":"postgres_fdw parallel commit","count":15},{"name":"Feature","value":"psql \\dconfig","count":15},{"name":"Feature","value":"range_agg range type aggregation function","count":15},{"name":"Feature","value":"regexp_count, regexp_instr, regexp_like","count":15},{"name":"Feature","value":"remote_apply mode","count":15},{"name":"Feature","value":"seg","count":15},{"name":"Feature","value":"tablefunc","count":15},{"name":"Feature","value":"tsearch2 compatibility wrapper","count":15},{"name":"Feature","value":"uuid-ossp","count":15},{"name":"api-example","value":"AttrMap * build_attrmap_by_position(TupleDesc indesc, TupleDesc outdesc, const char *msg) { AttrMap    *attrMap; int\t\t\tnincols; int\t\t\tnoutcols; int\t\t\tn; int\t\t\ti; int\t\t\tj; bool\t\tsame; * The length is c...","count":15},{"name":"api-example","value":"Buffer _bt_allocbuf(Relation rel, Relation heaprel) { Buffer\t\tbuf; BlockNumber blkno; Page\t\tpage; Assert(heaprel != NULL); * First see if the FSM knows of any free pages. * * We can't trust the FSM's ...","count":15},{"name":"api-example","value":"Datum ExecAggCopyTransValue(AggState *aggstate, AggStatePerTrans pertrans, Datum newValue, bool newValueIsNull, Datum oldValue, bool oldValueIsNull) { Assert(newValue != oldValue); if (!newValueIsNull...","count":15},{"name":"api-example","value":"Datum be_lo_open(PG_FUNCTION_ARGS) { Oid\t\t\tlobjId = PG_GETARG_OID(0); int32\t\tmode = PG_GETARG_INT32(1); LargeObjectDesc *lobjDesc; int\t\t\tfd; #ifdef FSDB elog(DEBUG4, \"lo_open(%u,%d)\", lobjId, mode); #...","count":15},{"name":"api-example","value":"Datum brin_minmax_multi_distance_uuid(PG_FUNCTION_ARGS) { int\t\t\ti; float8\t\tdelta = 0; Datum\t\ta1 = PG_GETARG_DATUM(0); Datum\t\ta2 = PG_GETARG_DATUM(1); pg_uuid_t  *u1 = DatumGetUUIDP(a1); pg_uuid_t  *u2...","count":15},{"name":"api-example","value":"Datum gist_box_consistent(PG_FUNCTION_ARGS) { GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0); BOX\t\t   *query = PG_GETARG_BOX_P(1); StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(2...","count":15},{"name":"api-example","value":"Datum hashname(PG_FUNCTION_ARGS) { char\t   *key = NameStr(*PG_GETARG_NAME(0)); return hash_any((unsigned char *) key, strlen(key)); }","count":15},{"name":"api-example","value":"Datum hashtext(PG_FUNCTION_ARGS) { text\t   *key = PG_GETARG_TEXT_PP(0); Oid\t\t\tcollid = PG_GET_COLLATION(); pg_locale_t mylocale = 0; Datum\t\tresult; if (!collid) ereport(ERROR, (errcode(ERRCODE_INDETER...","count":15},{"name":"api-example","value":"Datum multirange_out(PG_FUNCTION_ARGS) { MultirangeType *multirange = PG_GETARG_MULTIRANGE_P(0); Oid\t\t\tmltrngtypoid = MultirangeTypeGetOid(multirange); MultirangeIOData *cache; StringInfoData buf; Ran...","count":15},{"name":"api-example","value":"Datum numeric\t\t(PG_FUNCTION_ARGS) { Numeric\t\tnum = PG_GETARG_NUMERIC(0); int32\t\ttypmod = PG_GETARG_INT32(1); Numeric\t\tnew; int\t\t\tprecision; int\t\t\tscale; int\t\t\tddigits; int\t\t\tmaxdigits; int\t\t\tdscale; N...","count":15},{"name":"api-example","value":"Datum pg_nextoid(PG_FUNCTION_ARGS) { Oid\t\t\treloid = PG_GETARG_OID(0); Name\t\tattname = PG_GETARG_NAME(1); Oid\t\t\tidxoid = PG_GETARG_OID(2); Relation\trel; Relation\tidx; HeapTuple\tatttuple; Form_pg_attrib...","count":15},{"name":"api-example","value":"Datum pg_split_walfile_name(PG_FUNCTION_ARGS) { #define PG_SPLIT_WALFILE_NAME_COLS 2 char\t   *fname = text_to_cstring(PG_GETARG_TEXT_PP(0)); char\t   *fname_upper; char\t   *p; TimeLineID\ttli; XLogSegNo...","count":15},{"name":"api-example","value":"Datum plpgsql_exec_function(PLpgSQL_function *func, FunctionCallInfo fcinfo, EState *simple_eval_estate, ResourceOwner simple_eval_resowner, ResourceOwner procedure_resowner, bool atomic) { PLpgSQL_ex...","count":15},{"name":"api-example","value":"Datum timestamp_time(PG_FUNCTION_ARGS) { Timestamp\ttimestamp = PG_GETARG_TIMESTAMP(0); TimeADT\t\tresult; struct pg_tm tt, *tm = &tt; fsec_t\t\tfsec; if (TIMESTAMP_NOT_FINITE(timestamp)) PG_RETURN_NULL();...","count":15},{"name":"api-example","value":"Datum tsquery_rewrite_query(PG_FUNCTION_ARGS) { TSQuery\t\tquery = PG_GETARG_TSQUERY_COPY(0); text\t   *in = PG_GETARG_TEXT_PP(1); TSQuery\t\trewritten = query; MemoryContext outercontext = CurrentMemoryCo...","count":15},{"name":"api-example","value":"ExpandedArrayHeader * DatumGetExpandedArray(Datum d) { if (VARATT_IS_EXTERNAL_EXPANDED_RW(DatumGetPointer(d))) { ExpandedArrayHeader *eah = (ExpandedArrayHeader *) DatumGetEOHP(d); Assert(eah->ea_magi...","count":15},{"name":"api-example","value":"Expr * evaluate_expr(Expr *expr, Oid result_type, int32 result_typmod, Oid result_collation) { EState\t   *estate; ExprState  *exprstate; MemoryContext oldcontext; Datum\t\tconst_val; bool\t\tconst_is_null...","count":15},{"name":"api-example","value":"HeapTuple heap_copytuple(HeapTuple tuple) { HeapTuple\tnewTuple; if (!HeapTupleIsValid(tuple) || tuple->t_data == NULL) return NULL; newTuple = (HeapTuple) palloc(HEAPTUPLESIZE + tuple->t_len); newTupl...","count":15},{"name":"api-example","value":"IndexBulkDeleteResult * brinbulkdelete(IndexVacuumInfo *info, IndexBulkDeleteResult *stats, IndexBulkDeleteCallback callback, void *callback_state) { if (stats == NULL) stats = palloc0_object(IndexBul...","count":15},{"name":"api-example","value":"LockAcquireResult LockAcquireExtended(const LOCKTAG *locktag, LOCKMODE lockmode, bool sessionLock, bool dontWait, bool reportMemoryError, LOCALLOCK **locallockp) { LOCKMETHODID lockmethodid = locktag-...","count":15},{"name":"api-example","value":"ObjectAddress AggregateCreate(const char *aggName, Oid aggNamespace, bool replace, char aggKind, int numArgs, int numDirectArgs, oidvector *parameterTypes, Datum allParameterTypes, Datum parameterMode...","count":15},{"name":"api-example","value":"ObjectAddress DefineIndex(Oid tableId, IndexStmt *stmt, Oid indexRelationId, Oid parentIndexId, Oid parentConstraintId, int total_parts, bool is_alter_table, bool check_rights, bool check_not_in_use, ...","count":15},{"name":"api-example","value":"ObjectAddress DefineRelation(CreateStmt *stmt, char relkind, Oid ownerId, ObjectAddress *typaddress, const char *queryString) { char\t\trelname[NAMEDATALEN]; Oid\t\t\tnamespaceId; Oid\t\t\trelationId; Oid\t\t\tt...","count":15},{"name":"api-example","value":"ObjectAddress index_constraint_create(Relation heapRelation, Oid indexRelationId, Oid parentConstraintId, const IndexInfo *indexInfo, const char *constraintName, char constraintType, bits16 constr_fla...","count":15},{"name":"api-example","value":"Oid get_namespace_oid(const char *nspname, bool missing_ok) { Oid\t\t\toid; oid = GetSysCacheOid1(NAMESPACENAME, Anum_pg_namespace_oid, CStringGetDatum(nspname)); if (!OidIsValid(oid) && !missing_ok) ere...","count":15},{"name":"api-example","value":"Oid index_create(Relation heapRelation, const char *indexRelationName, Oid indexRelationId, Oid parentIndexRelid, Oid parentConstraintId, RelFileNumber relFileNumber, IndexInfo *indexInfo, const List ...","count":15},{"name":"api-example","value":"ParallelExecutorInfo * ExecInitParallelPlan(PlanState *planstate, EState *estate, Bitmapset *sendParams, int nworkers, int64 tuples_needed) { ParallelExecutorInfo *pei; ParallelContext *pcxt; ExecPara...","count":15},{"name":"api-example","value":"Size heap_compute_data_size(TupleDesc tupleDesc, const Datum *values, const bool *isnull) { Size\t\tdata_length = 0; int\t\t\ti; int\t\t\tnumberOfAttributes = tupleDesc->natts; for (i = 0; i < numberOfAttribu...","count":15},{"name":"api-example","value":"SysScanDesc systable_beginscan(Relation heapRelation, Oid indexId, bool indexOK, Snapshot snapshot, int nkeys, ScanKey key) { SysScanDesc sysscan; Relation\tirel; if (indexOK && !IgnoreSystemIndexes &&...","count":15},{"name":"api-example","value":"TidStore * TidStoreCreateLocal(size_t max_bytes, bool insert_only) { TidStore   *ts; size_t\t\tinitBlockSize = ALLOCSET_DEFAULT_INITSIZE; size_t\t\tminContextSize = ALLOCSET_DEFAULT_MINSIZE; size_t\t\tmaxBl...","count":15},{"name":"api-example","value":"TransactionId GetTopTransactionId(void) { if (!FullTransactionIdIsValid(XactTopFullTransactionId)) AssignTransactionId(&TopTransactionStateData); return XidFromFullTransactionId(XactTopFullTransaction...","count":15},{"name":"api-example","value":"XLogRecPtr XactLogCommitRecord(TimestampTz commit_time, int nsubxacts, TransactionId *subxacts, int nrels, RelFileLocator *rels, int ndroppedstats, xl_xact_stats_item *droppedstats, int nmsgs, SharedI...","count":15},{"name":"api-example","value":"bool SimpleLruDoesPhysicalPageExist(SlruCtl ctl, int64 pageno) { int64\t\tsegno = pageno / SLRU_PAGES_PER_SEGMENT; int\t\t\trpageno = pageno % SLRU_PAGES_PER_SEGMENT; int\t\t\toffset = rpageno * BLCKSZ; char\t...","count":15},{"name":"api-example","value":"bool WALRead(XLogReaderState *state, char *buf, XLogRecPtr startptr, Size count, TimeLineID tli, WALReadError *errinfo) { char\t   *p; XLogRecPtr\trecptr; Size\t\tnbytes; p = buf; recptr = startptr; nbyte...","count":15},{"name":"api-example","value":"bool ecpg_get_data(const PGresult *results, int act_tuple, int act_field, int lineno, enum ECPGttype type, enum ECPGttype ind_type, char *var, char *ind, long varcharsize, long offset, long ind_offset...","count":15},{"name":"api-example","value":"bool heap_tuple_should_freeze(HeapTupleHeader tuple, const struct VacuumCutoffs *cutoffs, TransactionId *NoFreezePageRelfrozenXid, MultiXactId *NoFreezePageRelminMxid) { TransactionId xid; MultiXactId...","count":15},{"name":"api-example","value":"bool spgproperty(Oid index_oid, int attno, IndexAMProperty prop, const char *propname, bool *res, bool *isnull) { Oid\t\t\topclass, opfamily, opcintype; CatCList   *catlist; int\t\t\ti; if (attno == 0) retu...","count":15},{"name":"api-example","value":"int SPI_connect_ext(int options) { int\t\t\tnewdepth; if (_SPI_stack == NULL) { if (_SPI_connected != -1 || _SPI_stack_depth != 0) elog(ERROR, \"SPI stack corrupted\"); newdepth = 16; _SPI_stack = (_SPI_co...","count":15},{"name":"api-example","value":"int pg_foreach_ifaddr(PgIfAddrCallback callback, void *cb_data) { INTERFACE_INFO *ptr, *ii = NULL; unsigned long length, i; unsigned long n_ii = 0; SOCKET\t\tsock; int\t\t\terror; sock = WSASocket(AF_INET,...","count":15},{"name":"api-example","value":"static BlockNumber ss_search(RelFileLocator relfilelocator, BlockNumber location, bool set) { ss_lru_item_t *item; item = scan_locations->head; for (;;) { bool\t\tmatch; match = RelFileLocatorEquals(ite...","count":15},{"name":"api-example","value":"static Const * _readConst(void) { READ_LOCALS(Const); READ_OID_FIELD(consttype); READ_INT_FIELD(consttypmod); READ_OID_FIELD(constcollid); READ_INT_FIELD(constlen); READ_BOOL_FIELD(constbyval); READ_B...","count":15},{"name":"api-example","value":"static DomainIOData * domain_state_setup(Oid domainType, bool binary, MemoryContext mcxt) { DomainIOData *my_extra; TypeCacheEntry *typentry; Oid\t\t\tbaseType; my_extra = (DomainIOData *) MemoryContextA...","count":15},{"name":"api-example","value":"static Size FreePageBtreeCleanup(FreePageManager *fpm) { char\t   *base = fpm_segment_base(fpm); Size\t\tmax_contiguous_pages = 0; while (!relptr_is_null(fpm->btree_root)) { FreePageBtree *root = relptr_...","count":15},{"name":"api-example","value":"static XLogRecPtr log_heap_new_cid(Relation relation, HeapTuple tup) { xl_heap_new_cid xlrec; XLogRecPtr\trecptr; HeapTupleHeader hdr = tup->t_data; Assert(ItemPointerIsValid(&tup->t_self)); Assert(tup...","count":15},{"name":"api-example","value":"static bool TypeIsVisibleExt(Oid typid, bool *is_missing) { HeapTuple\ttyptup; Form_pg_type typform; Oid\t\t\ttypnamespace; bool\t\tvisible; typtup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(typid)); if (!...","count":15},{"name":"api-example","value":"static bool check_role(const char *role, Oid roleid, List *tokens, bool case_insensitive) { ListCell   *cell; AuthToken  *tok; foreach(cell, tokens) { tok = lfirst(cell); if (token_is_member_check(tok...","count":15},{"name":"api-example","value":"static bool directBoolConsistentFn(GinScanKey key) { * Initialize recheckCurItem in case the consistentFn doesn't know it * should set it.  The safe assumption in that case is to force recheck. */ key...","count":15},{"name":"api-example","value":"static bool gist_point_consistent_internal(StrategyNumber strategy, bool isLeaf, BOX *key, Point *query) { bool\t\tresult = false; switch (strategy) { case RTLeftStrategyNumber: result = FPlt(key->low.x...","count":15},{"name":"api-example","value":"static char * _fmt(const char *format, const struct pg_tm *t, char *pt, const char *ptlim, enum warn *warnp) { for (; *format; ++format) { if (*format == '%') { label: switch (*++format) { case '\\0': ...","count":15},{"name":"api-example","value":"static const char * JsonbContainerTypeName(JsonbContainer *jbc) { JsonbValue\tscalar; if (JsonbExtractScalar(jbc, &scalar)) return JsonbTypeName(&scalar); else if (JsonContainerIsArray(jbc)) return \"ar...","count":15},{"name":"api-example","value":"static int find(struct vars *v, struct cnfa *cnfa, struct colormap *cm) { struct dfa *s; struct dfa *d; chr\t\t   *begin; chr\t\t   *end = NULL; chr\t\t   *cold; chr\t\t   *open;\t\t\t/* open and close of range ...","count":15},{"name":"api-example","value":"static int tzloadbody(char const *name, char *canonname, struct state *sp, bool doextend, union local_storage *lsp) { int\t\t\ti; int\t\t\tfid; int\t\t\tstored; ssize_t\t\tnread; union input_buffer *up = &lsp->u...","count":15},{"name":"api-example","value":"static int32 get_expr_width(PlannerInfo *root, const Node *expr) { int32\t\twidth; if (IsA(expr, Var)) { const Var  *var = (const Var *) expr; Assert(var->varlevelsup == 0); if (!IS_SPECIAL_VARNO(var->v...","count":15},{"name":"api-example","value":"static uint8 compute_infobits(uint16 infomask, uint16 infomask2) { return ((infomask & HEAP_XMAX_IS_MULTI) != 0 ? XLHL_XMAX_IS_MULTI : 0) | ((infomask & HEAP_XMAX_LOCK_ONLY) != 0 ? XLHL_XMAX_LOCK_ONLY...","count":15},{"name":"api-example","value":"static void AfterTriggerSaveEvent(EState *estate, ResultRelInfo *relinfo, ResultRelInfo *src_partinfo, ResultRelInfo *dst_partinfo, int event, bool row_trigger, TupleTableSlot *oldslot, TupleTableSlot...","count":15},{"name":"api-example","value":"static void EventTriggerInvoke(List *fn_oid_list, EventTriggerData *trigdata) { MemoryContext context; MemoryContext oldcontext; ListCell   *lc; bool\t\tfirst = true; check_stack_depth(); * Let's evalua...","count":15},{"name":"api-example","value":"static void ExecGrant_Attribute(InternalGrant *istmt, Oid relOid, const char *relname, AttrNumber attnum, Oid ownerId, AclMode col_privileges, Relation attRelation, const Acl *old_rel_acl) { HeapTuple...","count":15},{"name":"api-example","value":"static void LogicalParallelApplyLoop(shm_mq_handle *mqh) { shm_mq_result shmq_res; ErrorContextCallback errcallback; MemoryContext oldcxt = CurrentMemoryContext; * Init the ApplyMessageContext which w...","count":15},{"name":"api-example","value":"static void MarkAsPreparingGuts(GlobalTransaction gxact, TransactionId xid, const char *gid, TimestampTz prepared_at, Oid owner, Oid databaseid) { PGPROC\t   *proc; int\t\t\ti; Assert(LWLockHeldByMeInMode...","count":15},{"name":"api-example","value":"static void NIImportOOAffixes(IspellDict *Conf, const char *filename) { char\t\ttype[BUFSIZ], *ptype = NULL; char\t\tsflag[BUFSIZ]; char\t\tmask[BUFSIZ], *pmask; char\t\tfind[BUFSIZ], *pfind; char\t\trepl[BUFSI...","count":15},{"name":"api-example","value":"static void ProcessIncomingNotify(bool flush) { MemoryContext oldcontext; notifyInterruptPending = false; if (listenChannels == NIL) return; if (Trace_notify) elog(DEBUG1, \"ProcessIncomingNotify\"); se...","count":15},{"name":"api-example","value":"static void ReorderBufferProcessTXN(ReorderBuffer *rb, ReorderBufferTXN *txn, XLogRecPtr commit_lsn, volatile Snapshot snapshot_now, volatile CommandId command_id, bool streaming) { bool\t\tusing_subtxn...","count":15},{"name":"api-example","value":"static void SendXlogRecPtrResult(XLogRecPtr ptr, TimeLineID tli) { DestReceiver *dest; TupOutputState *tstate; TupleDesc\ttupdesc; Datum\t\tvalues[2]; bool\t\tnulls[2] = {0}; dest = CreateDestReceiver(Dest...","count":15},{"name":"api-example","value":"static void ShowTransactionState(const char *str) { if (message_level_is_interesting(DEBUG5)) ShowTransactionStateRec(str, CurrentTransactionState); }","count":15},{"name":"api-example","value":"static void _SPI_commit(bool chain) { MemoryContext oldcontext = CurrentMemoryContext; SavedTransactionCharacteristics savetc; * Complain if we are in a context that doesn't permit transaction * termi...","count":15},{"name":"api-example","value":"static void deleteObjectsInList(ObjectAddresses *targetObjects, Relation *depRel, int flags) { int\t\t\ti; * Keep track of objects for event triggers, if necessary. */ if (trackDroppedObjectsNeeded() && ...","count":15},{"name":"api-example","value":"static void findDependentObjects(const ObjectAddress *object, int objflags, int flags, ObjectAddressStack *stack, ObjectAddresses *targetObjects, const ObjectAddresses *pendingObjects, Relation *depRe...","count":15},{"name":"api-example","value":"static void gistvacuumpage(GistVacState *vstate, BlockNumber blkno, BlockNumber orig_blkno) { IndexVacuumInfo *info = vstate->info; IndexBulkDeleteCallback callback = vstate->callback; void\t   *callba...","count":15},{"name":"api-example","value":"static void k_hashes(bloom_filter *filter, uint32 *hashes, unsigned char *elem, size_t len) { uint64\t\thash; uint32\t\tx, y; uint64\t\tm; int\t\t\ti; hash = DatumGetUInt64(hash_any_extended(elem, len, filter-...","count":15},{"name":"api-example","value":"static void keyGetItem(GinState *ginstate, MemoryContext tempCtx, GinScanKey key, ItemPointerData advancePast) { ItemPointerData minItem; ItemPointerData curPageLossy; uint32\t\ti; bool\t\thaveLossyEntry;...","count":15},{"name":"api-example","value":"static void mock_scram_secret(const char *username, pg_cryptohash_type *hash_type, int *iterations, int *key_length, char **salt, uint8 *stored_key, uint8 *server_key) { char\t   *raw_salt; char\t   *en...","count":15},{"name":"api-example","value":"static void moveLeafs(Relation index, SpGistState *state, SPPageDesc *current, SPPageDesc *parent, SpGistLeafTuple newLeafTuple, bool isNulls) { int\t\t\ti, nDelete, nInsert, size; Buffer\t\tnbuf; Page\t\tnp...","count":15},{"name":"api-example","value":"static void prefixes(struct vars *v) { if (v->cflags & REG_QUOTE) return; if (HAVE(4) && NEXT3('*', '*', '*')) switch (*(v->now + 3)) { case CHR('?'):\t\t/* \"***?\" error, msg shows version */ ERR(REG_BA...","count":15},{"name":"api-example","value":"static void printJsonPathItem(StringInfo buf, JsonPathItem *v, bool inKey, bool printBracketes) { JsonPathItem elem; int\t\t\ti; check_stack_depth(); CHECK_FOR_INTERRUPTS(); switch (v->type) { case jpiNu...","count":15},{"name":"api-example","value":"static void process_pipe_input(char *logbuffer, int *bytes_in_logbuffer) { char\t   *cursor = logbuffer; int\t\t\tcount = *bytes_in_logbuffer; int\t\t\tdest = LOG_DESTINATION_STDERR; while (count >= (int) (o...","count":15},{"name":"api-example","value":"static void rulesub(struct rule *rp, const char *loyearp, const char *hiyearp, const char *typep, const char *monthp, const char *dayp, const char *timep) { const struct lookup *lp; const char *cp; ch...","count":15},{"name":"api-example","value":"static void xact_desc_prepare(StringInfo buf, uint8 info, xl_xact_prepare *xlrec, RepOriginId origin_id) { xl_xact_parsed_prepare parsed; ParsePrepareRecord(info, xlrec, &parsed); appendStringInfo(buf...","count":15},{"name":"api-example","value":"text * serialize_deflist(List *deflist) { text\t   *result; StringInfoData buf; ListCell   *l; initStringInfo(&buf); foreach(l, deflist) { DefElem    *defel = (DefElem *) lfirst(l); char\t   *val = defG...","count":15},{"name":"api-example","value":"void CLOGShmemInit(void) { if (transaction_buffers == 0) { char\t\tbuf[32]; snprintf(buf, sizeof(buf), \"%d\", CLOGShmemBuffers()); SetConfigOption(\"transaction_buffers\", buf, PGC_POSTMASTER, PGC_S_DYNAMI...","count":15},{"name":"api-example","value":"void ExecEvalCoerceViaIOSafe(ExprState *state, ExprEvalStep *op) { char\t   *str; if (*op->resnull) { str = NULL; } else { FunctionCallInfo fcinfo_out; fcinfo_out = op->d.iocoerce.fcinfo_data_out; fcin...","count":15},{"name":"api-example","value":"void ExecuteQuery(ParseState *pstate, ExecuteStmt *stmt, IntoClause *intoClause, ParamListInfo params, DestReceiver *dest, QueryCompletion *qc) { PreparedStatement *entry; CachedPlan *cplan; List\t   *...","count":15},{"name":"api-example","value":"void HeapTupleHeaderAdvanceConflictHorizon(HeapTupleHeader tuple, TransactionId *snapshotConflictHorizon) { TransactionId xmin = HeapTupleHeaderGetXmin(tuple); TransactionId xmax = HeapTupleHeaderGetU...","count":15},{"name":"api-example","value":"void RemoveAttributeById(Oid relid, AttrNumber attnum) { Relation\trel; Relation\tattr_rel; HeapTuple\ttuple; Form_pg_attribute attStruct; char\t\tnewattname[NAMEDATALEN]; Datum\t\tvaluesAtt[Natts_pg_attribu...","count":15},{"name":"api-example","value":"void ResetAllOptions(void) { dlist_mutable_iter iter; dlist_foreach_modify(iter, &guc_nondef_list) { struct config_generic *gconf = dlist_container(struct config_generic, nondef_link, iter.cur); if (g...","count":15},{"name":"api-example","value":"void RmgrStartup(void) { for (int rmid = 0; rmid <= RM_MAX_ID; rmid++) { if (!RmgrIdExists(rmid)) continue; if (RmgrTable[rmid].rm_startup != NULL) RmgrTable[rmid].rm_startup(); } }","count":15},{"name":"api-example","value":"void TruncateMultiXact(MultiXactId newOldestMulti, Oid newOldestMultiDB) { MultiXactId oldestMulti; MultiXactId nextMulti; MultiXactOffset newOldestOffset; MultiXactOffset oldestOffset; MultiXactOffse...","count":15},{"name":"api-example","value":"void WalReceiverMain(char *startup_data, size_t startup_data_len) { char\t\tconninfo[MAXCONNINFO]; char\t   *tmp_conninfo; char\t\tslotname[NAMEDATALEN]; bool\t\tis_temp_slot; XLogRecPtr\tstartpoint; TimeLine...","count":15},{"name":"api-example","value":"void generate_old_dump(void) { int\t\t\tdbnum; prep_status(\"Creating dump of global objects\"); exec_prog(UTILITY_LOG_FILE, NULL, true, true, \"\\\"%s/pg_dumpall\\\" %s --globals-only --quote-all-identifiers \"...","count":15},{"name":"api-example","value":"void generate_partitionwise_join_paths(PlannerInfo *root, RelOptInfo *rel) { List\t   *live_children = NIL; int\t\t\tcnt_parts; int\t\t\tnum_parts; RelOptInfo **part_rels; if (!IS_JOIN_REL(rel)) return; if (...","count":15},{"name":"api-example","value":"void heap_page_prune_and_freeze(Relation relation, Buffer buffer, GlobalVisState *vistest, int options, struct VacuumCutoffs *cutoffs, PruneFreezeResult *presult, PruneReason reason, OffsetNumber *off...","count":15},{"name":"api-example","value":"void index_store_float8_orderby_distances(IndexScanDesc scan, Oid *orderByTypes, IndexOrderByDistance *distances, bool recheckOrderBy) { int\t\t\ti; Assert(distances || !recheckOrderBy); scan->xs_recheck...","count":15},{"name":"api-example","value":"void pgstat_io_reset_all_cb(TimestampTz ts) { for (int i = 0; i < BACKEND_NUM_TYPES; i++) { LWLock\t   *bktype_lock = &pgStatLocal.shmem->io.locks[i]; PgStat_BktypeIO *bktype_shstats = &pgStatLocal.shm...","count":15},{"name":"api-example","value":"void spgPageIndexMultiDelete(SpGistState *state, Page page, OffsetNumber *itemnos, int nitems, int firststate, int reststate, BlockNumber blkno, OffsetNumber offnum) { OffsetNumber firstItem; OffsetNu...","count":15},{"name":"api-example","value":"void xlog_redo(XLogReaderState *record) { uint8\t\tinfo = XLogRecGetInfo(record) & ~XLR_INFO_MASK; XLogRecPtr\tlsn = record->EndRecPtr; * In XLOG rmgr, backup blocks are only used by XLOG_FPI and * XLOG_...","count":15},{"name":"arch-sublayer","value":"gin-index","count":15},{"name":"subsystem-desc","value":"src/backend/storage/freespace/README\n\nFree Space Map\n--------------\n\nThe purpose of the free space map is to quickly locate a page with enough\nfree space to hold a tuple to be stored; or to determine that no such page\nexists and the relation must be extended by one page.  As of PostgreSQL 8.4\neach relation has its own, extensible free space map stored in a separate\n\"fork\" of its relation.  This eliminates the disadvantages of the former\nfixed-size FSM.\n\nIt is important to keep the map small so that it can be searched rapidly.\nTherefore, we don't attempt to record the exact free space on a page.\nWe allocate one map byte to each page, allowing us to record free space\nat a granularity of 1/256th of a page.  Another way to say it is that\nthe stored value is the free space divided by BLCKSZ/256 (rounding down).\nWe assume that the free space must always be less than BLCKSZ, since\nall pages have some overhead; so the maximum map value is 255.\n\nTo assist in fast searching, the map isn't simply an array of per-page\nentries, but has a tree structure above those entries.  There is a tree\nstructure of pages, and a tree structure within each page, as described\nbelow.\n\nFSM page structure\n------------------\n\nWithin each FSM page, we use a binary tree structure where leaf nodes store\nthe amount of free space on heap pages (or lower level FSM pages, see\n\"Higher-level structure\" below), with one leaf node per heap page. A non-leaf\nnode stores the max amount of free space on any of its children.\n\nFor example:\n\n    4\n 4     2\n3 4   0 2    <- This level represents heap pages\n\nWe need two basic operations: search and update.\n\nTo search for a page with X amount of free space, traverse down the tree\nalong a path where n >= X, until you hit the bottom. If both children of a\nnode satisfy the condition, you can pick either one arbitrarily.\n\nTo update the amount of free space on a page to X, first update the leaf node\ncorresponding to the heap page, then \"bubble up\" the change to upper nodes,\nby walking up to each parent and recomputing its value as the max of its\ntwo children.  Repeat until reaching the root or a parent whose value\ndoesn't change.\n\nThis data structure has a couple of nice properties:\n- to discover that there is no page with X bytes of free space, you only\n  need to look at the root node\n- by varying which child to traverse to in the search algorithm, when you have\n  a choice, we can implement various strategies, like preferring pages closer\n  to a given page, or spreading the load across the table.\n\nHigher-level routines that use FSM pages access them through the fsm_set_avail()\nand fsm_search_avail() functions. The interface to those functions hides the\npage's internal tree structure, treating the FSM page as a black box that has\na certain number of \"slots\" for storing free space information.  (However,\nthe higher routines have to be aware of the tree structure of the whole map.)\n\nThe binary tree is stored on each FSM page as an array. Because the page\nheader takes some space on a page, the binary tree isn't perfect. That is,\na few right-most leaf nodes are missing, and there are some useless non-leaf\nnodes at the right. So the tree looks something like this:\n\n       0\n   1       2\n 3   4   5   6\n7 8 9 A B\n\nwhere the numbers denote each node's position in the array.  Note that the\ntree is guaranteed complete above the leaf level; only some leaf nodes are\nmissing.  This is reflected in the number of usable \"slots\" per page not\nbeing an exact power of 2.\n\nA FSM page also has a next slot pointer, fp_next_slot, that determines where\nto start the next search for free space within that page.  The reason for that\nis to spread out the pages that are returned by FSM searches.  When several\nbackends are concurrently inserting into a relation, contention can be avoided\nby having them insert into different pages.  But it is also desirable to fill\nup pages in sequential order, to get the benefit of OS prefetching and batched\nwrites.  The FSM is responsible for making that happen, and the next slot\npointer helps provide the desired behavior.\n\nHigher-level structure\n----------------------\n\nTo scale up the data structure described above beyond a single page, we\nmaintain a similar tree-structure across pages. Leaf nodes in higher level\npages correspond to lower level FSM pages. The root node within each page\nhas the same value as the corresponding leaf node on its parent page.\n\nThe root page is always stored at physical block 0.\n\nFor example, assuming each FSM page can hold information about 4 pages (in\nreality, it holds (BLCKSZ - headers) / 2, or ~4000 with default BLCKSZ),\nwe get a disk layout like this:\n\n 0     <-- page 0 at level 2 (root page)\n  0     <-- page 0 at level 1\n   0     <-- page 0 at level 0\n   1     <-- page 1 at level 0\n   2     <-- ...\n   3\n  1     <-- page 1 at level 1\n   4\n   5\n   6\n   7\n  2\n   8\n   9\n   10\n   11\n  3\n   12\n   13\n   14\n   15\n\nwhere the numbers are page numbers *at that level*, starting from 0.\n\nTo find the physical block # corresponding to leaf page n, we need to\ncount the number of leaf and upper-level pages preceding page n.\nThis turns out to be\n\ny = n + (n / F + 1) + (n / F^2 + 1) + ... + 1\n\nwhere F is the fanout (4 in the above example). The first term n is the number\nof preceding leaf pages, the second term is the number of pages at level 1,\nand so forth.\n\nTo keep things simple, the tree is always constant height. To cover the\nmaximum relation size of 2^32-1 blocks, three levels is enough with the default\nBLCKSZ (4000^3 > 2^32).\n\nAddressing\n----------\n\nThe higher-level routines operate on \"logical\" addresses, consisting of\n- level,\n- logical page number, and\n- slot (if applicable)\n\nBottom level FSM pages have level of 0, the level above that 1, and root 2.\nAs in the diagram above, logical page number is the page number at that level,\nstarting from 0.\n\nLocking\n-------\n\nWhen traversing down to search for free space, only one page is locked at a\ntime: the parent page is released before locking the child. If the child page\nis concurrently modified, and there no longer is free space on the child page\nwhen you land on it, you need to start from scratch (after correcting the\nparent page, so that you don't get into an infinite loop).\n\nWe use shared buffer locks when searching, but exclusive buffer lock when\nupdating a page.  However, the next slot search pointer is updated during\nsearches even though we have only a shared lock.  fp_next_slot is just a hint\nand we can easily reset it if it gets corrupted; so it seems better to accept\nsome risk of that type than to pay the overhead of exclusive locking.\n\nRecovery\n--------\n\nThe FSM is not explicitly WAL-logged. Instead, we rely on a bunch of\nself-correcting measures to repair possible corruption.\n\nFirst of all, whenever a value is set on an FSM page, the root node of the\npage is compared against the new value after bubbling up the change is\nfinished. It should be greater than or equal to the value just set, or we\nhave a corrupted page, with a parent somewhere with too small a value.\nSecondly, if we detect corrupted pages while we search, traversing down\nthe tree. That check will notice if a parent node is set to too high a value.\nIn both cases, the upper nodes on the page are immediately rebuilt, fixing\nthe corruption so far as that page is concerned.\n\nVACUUM updates all the bottom-level FSM pages with the correct amount of free\nspace on corresponding heap pages, as it proceeds through the heap.  This\ngoes through fsm_set_avail(), so that the upper nodes on those pages are\nimmediately updated.  Periodically, VACUUM calls FreeSpaceMapVacuum[Range]\nto propagate the new free-space info into the upper pages of the FSM tree.\n\nAs a result when we write to the FSM we treat that as a hint and thus use\nMarkBufferDirtyHint() rather than MarkBufferDirty().  Every read here uses\nRBM_ZERO_ON_ERROR to bypass checksum mismatches and other verification\nfailures.  We'd operate correctly without the full page images that\nMarkBufferDirtyHint() provides, but they do decrease the chance of losing slot\nknowledge to RBM_ZERO_ON_ERROR.\n\nRelation extension is not WAL-logged.  Hence, after WAL replay, an on-disk FSM\nslot may indicate free space in PageIsNew() blocks that never reached disk.\nWe detect this case by comparing against the actual relation size, and we mark\nthe block as full in that case.\n\nTODO\n----\n\n- fastroot to avoid traversing upper nodes with just 1 child\n- use a different system for tables that fit into one FSM page, with a\n  mechanism to switch to the real thing as it grows.","count":15},{"name":"subsystem-desc","value":"src/backend/storage/page/README\n\nChecksums\n---------\n\nChecksums on data pages are designed to detect corruption by the I/O system.\nWe do not protect buffers against uncorrectable memory errors, since these\nhave a very low measured incidence according to research on large server farms,\nhttp://www.cs.toronto.edu/~bianca/papers/sigmetrics09.pdf, discussed\n2010/12/22 on -hackers list.\n\nCurrent implementation requires this be enabled system-wide at initdb time, or\nby using the pg_checksums tool on an offline cluster.\n\nThe checksum is not valid at all times on a data page!!\nThe checksum is valid when the page leaves the shared pool and is checked\nwhen it later re-enters the shared pool as a result of I/O.\nWe set the checksum on a buffer in the shared pool immediately before we\nflush the buffer. As a result we implicitly invalidate the page's checksum\nwhen we modify the page for a data change or even a hint. This means that\nmany or even most pages in shared buffers have invalid page checksums,\nso be careful how you interpret the pd_checksum field.\n\nThat means that WAL-logged changes to a page do NOT update the page checksum,\nso full page images may not have a valid checksum. But those page images have\nthe WAL CRC covering them and so are verified separately from this\nmechanism. WAL replay should not test the checksum of a full-page image.\n\nThe best way to understand this is that WAL CRCs protect records entering the\nWAL stream, and data page verification protects blocks entering the shared\nbuffer pool. They are similar in purpose, yet completely separate.  Together\nthey ensure we are able to detect errors in data re-entering\nPostgreSQL-controlled memory. Note also that the WAL checksum is a 32-bit CRC,\nwhereas the page checksum is only 16-bits.\n\nAny write of a data block can cause a torn page if the write is unsuccessful.\nFull page writes protect us from that, which are stored in WAL.  Setting hint\nbits when a page is already dirty is OK because a full page write must already\nhave been written for it since the last checkpoint.  Setting hint bits on an\notherwise clean page can allow torn pages; this doesn't normally matter since\nthey are just hints, but when the page has checksums, then losing a few bits\nwould cause the checksum to be invalid.  So if we have full_page_writes = on\nand checksums enabled then we must write a WAL record specifically so that we\nrecord a full page image in WAL.  Hint bits updates should be protected using\nMarkBufferDirtyHint(), which is responsible for writing the full-page image\nwhen necessary.\n\nNote that when we write a page checksum we include the hopefully zeroed bytes\nthat form the hole in the centre of a standard page. Thus, when we read the\nblock back from storage we implicitly check that the hole is still all zeroes.\nWe do this to ensure that we spot errors that could have destroyed data even\nif they haven't actually done so. Full page images stored in WAL do *not*\ncheck that the hole is all zero; the data in the hole is simply skipped and\nre-zeroed if the backup block is reapplied. We do this because a failure in\nWAL is a fatal error and prevents further recovery, whereas a checksum failure\non a normal data block is a hard error but not a critical one for the server,\neven if it is a very bad thing for the user.\n\nNew WAL records cannot be written during recovery, so hint bits set during\nrecovery must not dirty the page if the buffer is not already dirty, when\nchecksums are enabled.  Systems in Hot-Standby mode may benefit from hint bits\nbeing set, but with checksums enabled, a page cannot be dirtied after setting a\nhint bit (due to the torn page risk). So, it must wait for full-page images\ncontaining the hint bit updates to arrive from the primary.","count":15},{"name":"subsystem-desc","value":"src/backend/storage/smgr/README\n\nStorage Managers\n================\n\nIn the original Berkeley Postgres system, there were several storage managers,\nof which only the \"magnetic disk\" manager remains.  (At Berkeley there were\nalso managers for the Sony WORM optical disk jukebox and persistent main\nmemory, but these were never supported in any externally released Postgres,\nnor in any version of PostgreSQL.)  The \"magnetic disk\" manager is itself\nseriously misnamed, because actually it supports any kind of device for\nwhich the operating system provides standard filesystem operations; which\nthese days is pretty much everything of interest.  However, we retain the\nnotion of a storage manager switch in case anyone ever wants to reintroduce\nother kinds of storage managers.  Removing the switch layer would save\nnothing noticeable anyway, since storage-access operations are surely far\nmore expensive than one extra layer of C function calls.\n\nIn Berkeley Postgres each relation was tagged with the ID of the storage\nmanager to use for it.  This is gone.  It would be probably more reasonable\nto associate storage managers with tablespaces, should we ever re-introduce\nmultiple storage managers into the system catalogs.\n\nThe files in this directory, and their contents, are\n\n    smgr.c\tThe storage manager switch dispatch code.  The routines in\n\t\tthis file call the appropriate storage manager to do storage\n\t\taccesses requested by higher-level code.  smgr.c also manages\n\t\tthe file handle cache (SMgrRelation table).\n\n    md.c\tThe \"magnetic disk\" storage manager, which is really just\n\t\tan interface to the kernel's filesystem operations.\n\nNote that md.c in turn relies on src/backend/storage/file/fd.c.\n\n\nRelation Forks\n==============\n\nSince 8.4, a single smgr relation can be comprised of multiple physical\nfiles, called relation forks. This allows storing additional metadata like\nFree Space information in additional forks, which can be grown and truncated\nindependently of the main data file, while still treating it all as a single\nphysical relation in system catalogs.\n\nIt is assumed that the main fork, fork number 0 or MAIN_FORKNUM, always\nexists. Fork numbers are assigned in src/include/common/relpath.h.\nFunctions in smgr.c and md.c take an extra fork number argument, in addition\nto relfilelocator and block number, to identify which relation fork you want to\naccess. Since most code wants to access the main fork, a shortcut version of\nReadBuffer that accesses MAIN_FORKNUM is provided in the buffer manager for\nconvenience.","count":15},{"name":"subsystem-desc","value":"src/backend/utils/fmgr/README\n\nFunction Manager\n================\n\n[This file originally explained the transition from the V0 to the V1\ninterface.  Now it just explains some internals and rationale for the V1\ninterface, while the V0 interface has been removed.]\n\nThe V1 Function-Manager Interface\n---------------------------------\n\nThe core of the design is data structures for representing the result of a\nfunction lookup and for representing the parameters passed to a specific\nfunction invocation.  (We want to keep function lookup separate from\nfunction call, since many parts of the system apply the same function over\nand over; the lookup overhead should be paid once per query, not once per\ntuple.)\n\n\nWhen a function is looked up in pg_proc, the result is represented as\n\ntypedef struct\n{\n    PGFunction  fn_addr;    /* pointer to function or handler to be called */\n    Oid         fn_oid;     /* OID of function (NOT of handler, if any) */\n    short       fn_nargs;   /* number of input args (0..FUNC_MAX_ARGS) */\n    bool        fn_strict;  /* function is \"strict\" (NULL in => NULL out) */\n    bool        fn_retset;  /* function returns a set (over multiple calls) */\n    unsigned char fn_stats; /* collect stats if track_functions > this */\n    void       *fn_extra;   /* extra space for use by handler */\n    MemoryContext fn_mcxt;  /* memory context to store fn_extra in */\n    Node       *fn_expr;    /* expression parse tree for call, or NULL */\n} FmgrInfo;\n\nFor an ordinary built-in function, fn_addr is just the address of the C\nroutine that implements the function.  Otherwise it is the address of a\nhandler for the class of functions that includes the target function.\nThe handler can use the function OID and perhaps also the fn_extra slot\nto find the specific code to execute.  (fn_oid = InvalidOid can be used\nto denote a not-yet-initialized FmgrInfo struct.  fn_extra will always\nbe NULL when an FmgrInfo is first filled by the function lookup code, but\na function handler could set it to avoid making repeated lookups of its\nown when the same FmgrInfo is used repeatedly during a query.)  fn_nargs\nis the number of arguments expected by the function, fn_strict is its\nstrictness flag, and fn_retset shows whether it returns a set; all of\nthese values come from the function's pg_proc entry.  fn_stats is also\nset up to control whether or not to track runtime statistics for calling\nthis function.\n\nIf the function is being called as part of a SQL expression, fn_expr will\npoint to the expression parse tree for the function call; this can be used\nto extract parse-time knowledge about the actual arguments.  Note that this\nfield really is information about the arguments rather than information\nabout the function, but it's proven to be more convenient to keep it in\nFmgrInfo than in FunctionCallInfoBaseData where it might more logically go.\n\n\nDuring a call of a function, the following data structure is created\nand passed to the function:\n\ntypedef struct\n{\n    FmgrInfo   *flinfo;         /* ptr to lookup info used for this call */\n    Node       *context;        /* pass info about context of call */\n    Node       *resultinfo;     /* pass or return extra info about result */\n    Oid         fncollation;    /* collation for function to use */\n    bool        isnull;         /* function must set true if result is NULL */\n    short       nargs;          /* # arguments actually passed */\n    NullableDatum args[];       /* Arguments passed to function */\n} FunctionCallInfoBaseData;\ntypedef FunctionCallInfoBaseData* FunctionCallInfo;\n\nflinfo points to the lookup info used to make the call.  Ordinary functions\nwill probably ignore this field, but function class handlers will need it\nto find out the OID of the specific function being called.\n\ncontext is NULL for an \"ordinary\" function call, but may point to additional\ninfo when the function is called in certain contexts.  (For example, the\ntrigger manager will pass information about the current trigger event here.)\nFurther details appear in \"Function Call Contexts\" below.\n\nresultinfo is NULL when calling any function from which a simple Datum\nresult is expected.  It may point to some subtype of Node if the function\nreturns more than a Datum.  (For example, resultinfo is used when calling a\nfunction that returns a set, as discussed below.)  Like the context field,\nresultinfo is a hook for expansion; fmgr itself doesn't constrain the use\nof the field.\n\nfncollation is the input collation derived by the parser, or InvalidOid\nwhen there are no inputs of collatable types or they don't share a common\ncollation.  This is effectively a hidden additional argument, which\ncollation-sensitive functions can use to determine their behavior.\n\nnargs and args[] hold the arguments being passed to the function.\nNotice that all the arguments passed to a function (as well as its result\nvalue) will now uniformly be of type Datum.  As discussed below, callers\nand callees should apply the standard Datum-to-and-from-whatever macros\nto convert to the actual argument types of a particular function.  The\nvalue in args[i].value is unspecified when args[i].isnull is true.\n\nIt is generally the responsibility of the caller to ensure that the\nnumber of arguments passed matches what the callee is expecting; except\nfor callees that take a variable number of arguments, the callee will\ntypically ignore the nargs field and just grab values from args[].\n\nThe isnull field will be initialized to \"false\" before the call.  On\nreturn from the function, isnull is the null flag for the function result:\nif it is true the function's result is NULL, regardless of the actual\nfunction return value.  Note that simple \"strict\" functions can ignore\nboth isnull and args[i].isnull, since they won't even get called when there\nare any TRUE values in args[].isnull.\n\nFunctionCallInfo replaces FmgrValues plus a bunch of ad-hoc parameter\nconventions, global variables (fmgr_pl_finfo and CurrentTriggerData at\nleast), and other uglinesses.\n\n\nCallees, whether they be individual functions or function handlers,\nshall always have this signature:\n\nDatum function (FunctionCallInfo fcinfo);\n\nwhich is represented by the typedef\n\ntypedef Datum (*PGFunction) (FunctionCallInfo fcinfo);\n\nThe function is responsible for setting fcinfo->isnull appropriately\nas well as returning a result represented as a Datum.  Note that since\nall callees will now have exactly the same signature, and will be called\nthrough a function pointer declared with exactly that signature, we\nshould have no portability or optimization problems.\n\n\nFunction Coding Conventions\n---------------------------\n\nHere are the proposed macros and coding conventions:\n\nThe definition of an fmgr-callable function will always look like\n\nDatum\nfunction_name(PG_FUNCTION_ARGS)\n{\n\t...\n}\n\n\"PG_FUNCTION_ARGS\" just expands to \"FunctionCallInfo fcinfo\".  The main\nreason for using this macro is to make it easy for scripts to spot function\ndefinitions.  However, if we ever decide to change the calling convention\nagain, it might come in handy to have this macro in place.\n\nA nonstrict function is responsible for checking whether each individual\nargument is null or not, which it can do with PG_ARGISNULL(n) (which is\njust \"fcinfo->args[n].isnull\").  It should avoid trying to fetch the value\nof any argument that is null.\n\nBoth strict and nonstrict functions can return NULL, if needed, with\n\tPG_RETURN_NULL();\nwhich expands to\n\t{ fcinfo->isnull = true; return (Datum) 0; }\n\nArgument values are ordinarily fetched using code like\n\tint32\tname = PG_GETARG_INT32(number);\n\nFor float4, float8, and int8, the PG_GETARG macros will hide whether the\ntypes are pass-by-value or pass-by-reference.  For example, if float8 is\npass-by-reference then PG_GETARG_FLOAT8 expands to\n\t(* (float8 *) DatumGetPointer(fcinfo->args[number].value))\nand would typically be called like this:\n\tfloat8  arg = PG_GETARG_FLOAT8(0);\nFor what are now historical reasons, the float-related typedefs and macros\nexpress the type width in bytes (4 or 8), whereas we prefer to label the\nwidths of integer types in bits.\n\nNon-null values are returned with a PG_RETURN_XXX macro of the appropriate\ntype.  For example, PG_RETURN_INT32 expands to\n\treturn Int32GetDatum(x)\nPG_RETURN_FLOAT4, PG_RETURN_FLOAT8, and PG_RETURN_INT64 hide whether their\ndata types are pass-by-value or pass-by-reference, by doing a palloc if\nneeded.\n\nfmgr.h will provide PG_GETARG and PG_RETURN macros for all the basic data\ntypes.  Modules or header files that define specialized SQL datatypes\n(eg, timestamp) should define appropriate macros for those types, so that\nfunctions manipulating the types can be coded in the standard style.\n\nFor non-primitive data types (particularly variable-length types) it won't\nbe very practical to hide the pass-by-reference nature of the data type,\nso the PG_GETARG and PG_RETURN macros for those types won't do much more\nthan DatumGetPointer/PointerGetDatum plus the appropriate typecast (but see\nTOAST discussion, below).  Functions returning such types will need to\npalloc() their result space explicitly.  I recommend naming the GETARG and\nRETURN macros for such types to end in \"_P\", as a reminder that they\nproduce or take a pointer.  For example, PG_GETARG_TEXT_P yields \"text *\".\n\nWhen a function needs to access fcinfo->flinfo or one of the other auxiliary\nfields of FunctionCallInfo, it should just do it.  I doubt that providing\nsyntactic-sugar macros for these cases is useful.\n\n\nSupport for TOAST-Able Data Types\n---------------------------------\n\nFor TOAST-able data types, the PG_GETARG macro will deliver a de-TOASTed\ndata value.  There might be a few cases where the still-toasted value is\nwanted, but the vast majority of cases want the de-toasted result, so\nthat will be the default.  To get the argument value without causing\nde-toasting, use PG_GETARG_RAW_VARLENA_P(n).\n\nSome functions require a modifiable copy of their input values.  In these\ncases, it's silly to do an extra copy step if we copied the data anyway\nto de-TOAST it.  Therefore, each toastable datatype has an additional\nfetch macro, for example PG_GETARG_TEXT_P_COPY(n), which delivers a\nguaranteed-fresh copy, combining this with the detoasting step if possible.\n\nThere is also a PG_FREE_IF_COPY(ptr,n) macro, which pfree's the given\npointer if and only if it is different from the original value of the n'th\nargument.  This can be used to free the de-toasted value of the n'th\nargument, if it was actually de-toasted.  Currently, doing this is not\nnecessary for the majority of functions because the core backend code\nreleases temporary space periodically, so that memory leaked in function\nexecution isn't a big problem.  However, as of 7.1 memory leaks in\nfunctions that are called by index searches will not be cleaned up until\nend of transaction.  Therefore, functions that are listed in pg_amop or\npg_amproc should be careful not to leak detoasted copies, and so these\nfunctions do need to use PG_FREE_IF_COPY() for toastable inputs.\n\nA function should never try to re-TOAST its result value; it should just\ndeliver an untoasted result that's been palloc'd in the current memory\ncontext.  When and if the value is actually stored into a tuple, the\ntuple toaster will decide whether toasting is needed.\n\n\nFunction Call Contexts\n----------------------\n\nIf a caller passes a non-NULL pointer in fcinfo->context, it should point\nto some subtype of Node; the particular kind of context is indicated by the\nnode type field.  (A callee should always check the node type, via IsA(),\nbefore assuming it knows what kind of context is being passed.)  fmgr\nitself puts no other restrictions on the use of this field.\n\nCurrent uses of this convention include:\n\n* Trigger functions are passed an instance of struct TriggerData,\ncontaining information about the trigger context.  (The trigger function\ndoes not receive any normal arguments.)  See commands/trigger.h for\nmore information and macros that are commonly used by trigger functions.\n\n* Aggregate functions (or to be precise, their transition and final\nfunctions) are passed an instance of struct AggState, that is the executor\nstate node for the calling Agg plan node; or if they are called as window\nfunctions, they receive an instance of struct WindowAggState.  It is\nrecommended that these pointers be used only via AggCheckCallContext()\nand sibling functions, which are declared in fmgr.h but are documented\nonly with their source code in src/backend/executor/nodeAgg.c.  Typically\nthese context nodes are only of interest when the transition and final\nfunctions wish to optimize execution based on knowing that they are being\nused within an aggregate rather than as standalone SQL functions.\n\n* True window functions receive an instance of struct WindowObject.\n(Like trigger functions, they don't receive any normal arguments.)\nSee windowapi.h for more information.\n\n* Procedures are passed an instance of struct CallContext, containing\ninformation about the context of the CALL statement, particularly\nwhether it is within an \"atomic\" execution context.\n\n* Some callers of datatype input functions (and in future perhaps\nother classes of functions) pass an instance of ErrorSaveContext.\nThis indicates that the caller wishes to handle \"soft\" errors without\na transaction-terminating exception being thrown: instead, the callee\nshould store information about the error cause in the ErrorSaveContext\nstruct and return a dummy result value.  Further details appear in\n\"Handling Soft Errors\" below.\n\n\nHandling Soft Errors\n--------------------\n\nPostgres' standard mechanism for reporting errors (ereport() or elog())\nis used for all sorts of error conditions.  This means that throwing\nan exception via ereport(ERROR) requires an expensive transaction or\nsubtransaction abort and cleanup, since the exception catcher dare not\nmake many assumptions about what has gone wrong.  There are situations\nwhere we would rather have a lighter-weight mechanism for dealing\nwith errors that are known to be safe to recover from without a full\ntransaction cleanup.  SQL-callable functions can support this need\nusing the ErrorSaveContext context mechanism.\n\nTo report a \"soft\" error, a SQL-callable function should call\n\terrsave(fcinfo->context, ...)\nwhere it would previously have done\n\tereport(ERROR, ...)\nIf the passed \"context\" is NULL or is not an ErrorSaveContext node,\nthen errsave behaves precisely as ereport(ERROR): the exception is\nthrown via longjmp, so that control does not return.  If \"context\"\nis an ErrorSaveContext node, then the error information included in\nerrsave's subsidiary reporting calls is stored into the context node\nand control returns from errsave normally.  The function should then\nreturn a dummy value to its caller.  (SQL NULL is recommendable as\nthe dummy value; but anything will do, since the caller is expected\nto ignore the function's return value once it sees that an error has\nbeen reported in the ErrorSaveContext node.)\n\nIf there is nothing to do except return after calling errsave(),\nyou can save a line or two by writing\n\tereturn(fcinfo->context, dummy_value, ...)\nto perform errsave() and then \"return dummy_value\".\n\nAn error reported \"softly\" must be safe, in the sense that there is\nno question about our ability to continue normal processing of the\ntransaction.  Error conditions that should NOT be handled this way\ninclude out-of-memory, unexpected internal errors, or anything that\ncannot easily be cleaned up after.  Such cases should still be thrown\nwith ereport, as they have been in the past.\n\nConsidering datatype input functions as examples, typical \"soft\" error\nconditions include input syntax errors and out-of-range values.  An\ninput function typically detects such cases with simple if-tests and\ncan easily change the ensuing ereport call to an errsave or ereturn.\nBecause of this restriction, it's typically not necessary to pass\nthe ErrorSaveContext pointer down very far, as errors reported by\nlow-level functions are typically reasonable to consider internal.\n(Another way to frame the distinction is that input functions should\nreport all invalid-input conditions softly, but internal problems are\nhard errors.)\n\nBecause no transaction cleanup will occur, a function that is exiting\nafter errsave() returns will bear responsibility for resource cleanup.\nIt is not necessary to be concerned about small leakages of palloc'd\nmemory, since the caller should be running the function in a short-lived\nmemory context.  However, resources such as locks, open files, or buffer\npins must be closed out cleanly, as they would be in the non-error code\npath.\n\nConventions for callers that use the ErrorSaveContext mechanism\nto trap errors are discussed with the declaration of that struct,\nin nodes/miscnodes.h.\n\n\nFunctions Accepting or Returning Sets\n-------------------------------------\n\nIf a function is marked in pg_proc as returning a set, then it is called\nwith fcinfo->resultinfo pointing to a node of type ReturnSetInfo.  A\nfunction that desires to return a set should raise an error \"called in\ncontext that does not accept a set result\" if resultinfo is NULL or does\nnot point to a ReturnSetInfo node.\n\nThere are currently two modes in which a function can return a set result:\nvalue-per-call, or materialize.  In value-per-call mode, the function returns\none value each time it is called, and finally reports \"done\" when it has no\nmore values to return.  In materialize mode, the function's output set is\ninstantiated in a Tuplestore object; all the values are returned in one call.\nAdditional modes might be added in future.\n\nReturnSetInfo contains a field \"allowedModes\" which is set (by the caller)\nto a bitmask that's the OR of the modes the caller can support.  The actual\nmode used by the function is returned in another field \"returnMode\".  For\nbackwards-compatibility reasons, returnMode is initialized to value-per-call\nand need only be changed if the function wants to use a different mode.\nThe function should ereport() if it cannot use any of the modes the caller is\nwilling to support.\n\nValue-per-call mode works like this: ReturnSetInfo contains a field\n\"isDone\", which should be set to one of these values:\n\n    ExprSingleResult             /* expression does not return a set */\n    ExprMultipleResult           /* this result is an element of a set */\n    ExprEndResult                /* there are no more elements in the set */\n\n(the caller will initialize it to ExprSingleResult).  If the function simply\nreturns a Datum without touching ReturnSetInfo, then the call is over and a\nsingle-item set has been returned.  To return a set, the function must set\nisDone to ExprMultipleResult for each set element.  After all elements have\nbeen returned, the next call should set isDone to ExprEndResult and return a\nnull result.  (Note it is possible to return an empty set by doing this on\nthe first call.)\n\nValue-per-call functions MUST NOT assume that they will be run to completion;\nthe executor might simply stop calling them, for example because of a LIMIT.\nTherefore, it's unsafe to attempt to perform any resource cleanup in the\nfinal call.  It's usually not necessary to clean up memory, anyway.  If it's\nnecessary to clean up other types of resources, such as file descriptors,\none can register a shutdown callback function in the ExprContext pointed to\nby the ReturnSetInfo node.  (But note that file descriptors are a limited\nresource, so it's generally unwise to hold those open across calls; SRFs\nthat need file access are better written to do it in a single call using\nMaterialize mode.)\n\nMaterialize mode works like this: the function creates a Tuplestore holding\nthe (possibly empty) result set, and returns it.  There are no multiple calls.\nThe function must also return a TupleDesc that indicates the tuple structure.\nThe Tuplestore and TupleDesc should be created in the context\necontext->ecxt_per_query_memory (note this will *not* be the context the\nfunction is called in).  The function stores pointers to the Tuplestore and\nTupleDesc into ReturnSetInfo, sets returnMode to indicate materialize mode,\nand returns null.  isDone is not used and should be left at ExprSingleResult.\n\nThe Tuplestore must be created with randomAccess = true if\nSFRM_Materialize_Random is set in allowedModes, but it can (and preferably\nshould) be created with randomAccess = false if not.  Callers that can support\nboth ValuePerCall and Materialize mode will set SFRM_Materialize_Preferred,\nor not, depending on which mode they prefer.\n\nIf available, the expected tuple descriptor is passed in ReturnSetInfo;\nin other contexts the expectedDesc field will be NULL.  The function need\nnot pay attention to expectedDesc, but it may be useful in special cases.\n\nInitMaterializedSRF() is a helper function able to setup the function's\nReturnSetInfo for a single call, filling in the Tuplestore and the\nTupleDesc with the proper configuration for Materialize mode.\n\nThere is no support for functions accepting sets; instead, the function will\nbe called multiple times, once for each element of the input set.\n\n\nNotes About Function Handlers\n-----------------------------\n\nHandlers for classes of functions should find life much easier and\ncleaner in this design.  The OID of the called function is directly\nreachable from the passed parameters; we don't need the global variable\nfmgr_pl_finfo anymore.  Also, by modifying fcinfo->flinfo->fn_extra,\nthe handler can cache lookup info to avoid repeat lookups when the same\nfunction is invoked many times.  (fn_extra can only be used as a hint,\nsince callers are not required to re-use an FmgrInfo struct.\nBut in performance-critical paths they normally will do so.)\n\nIf the handler wants to allocate memory to hold fn_extra data, it should\nNOT do so in CurrentMemoryContext, since the current context may well be\nmuch shorter-lived than the context where the FmgrInfo is.  Instead,\nallocate the memory in context flinfo->fn_mcxt, or in a long-lived cache\ncontext.  fn_mcxt normally points at the context that was\nCurrentMemoryContext at the time the FmgrInfo structure was created;\nin any case it is required to be a context at least as long-lived as the\nFmgrInfo itself.","count":15},{"name":"subsystem-name","value":"fmgr","count":15},{"name":"subsystem-name","value":"freespace","count":15},{"name":"subsystem-name","value":"page","count":15},{"name":"subsystem-name","value":"smgr","count":15},{"name":"subsystem-path","value":"backend/storage/freespace/readme","count":15},{"name":"subsystem-path","value":"backend/storage/page/readme","count":15},{"name":"subsystem-path","value":"backend/storage/smgr/readme","count":15},{"name":"subsystem-path","value":"backend/utils/fmgr/readme","count":15},{"name":"Feature","value":"B-tree deduplication","count":14},{"name":"arch-layer","value":"storage","count":14},{"name":"arch-layer-depth","value":"6","count":14},{"name":"arch-layer-description","value":"Low-level storage management (buffer, smgr)","count":14},{"name":"arch-sublayer","value":"logical-replication","count":14},{"name":"Feature","value":"Load balancing for libpq / psql","count":13},{"name":"Feature","value":"Asynchronous Commit","count":12},{"name":"Feature","value":"Exclusion constraints","count":12},{"name":"Feature","value":"Pre-fetch WAL during recovery","count":12},{"name":"api-caller-count","value":"122","count":12},{"name":"api-caller-count","value":"123","count":12},{"name":"api-caller-count","value":"130","count":12},{"name":"api-caller-count","value":"150","count":12},{"name":"api-caller-count","value":"169","count":12},{"name":"api-caller-count","value":"1843","count":12},{"name":"api-caller-count","value":"186","count":12},{"name":"api-caller-count","value":"2343","count":12},{"name":"api-caller-count","value":"237","count":12},{"name":"api-caller-count","value":"276","count":12},{"name":"api-caller-count","value":"298","count":12},{"name":"api-caller-count","value":"5576","count":12},{"name":"api-caller-count","value":"739","count":12},{"name":"api-caller-count","value":"75","count":12},{"name":"api-example","value":"Datum array_typanalyze(PG_FUNCTION_ARGS) { VacAttrStats *stats = (VacAttrStats *) PG_GETARG_POINTER(0); Oid\t\t\telement_typeid; TypeCacheEntry *typentry; ArrayAnalyzeExtraData *extra_data; * Call the st...","count":12},{"name":"api-example","value":"Datum be_lo_export(PG_FUNCTION_ARGS) { Oid\t\t\tlobjId = PG_GETARG_OID(0); text\t   *filename = PG_GETARG_TEXT_PP(1); int\t\t\tfd; int\t\t\tnbytes, tmp; char\t\tbuf[BUFSIZE]; char\t\tfnamebuf[MAXPGPATH]; LargeObjec...","count":12},{"name":"api-example","value":"Datum brin_inclusion_add_value(PG_FUNCTION_ARGS) { BrinDesc   *bdesc = (BrinDesc *) PG_GETARG_POINTER(0); BrinValues *column = (BrinValues *) PG_GETARG_POINTER(1); Datum\t\tnewval = PG_GETARG_DATUM(2); ...","count":12},{"name":"api-example","value":"Datum brin_minmax_multi_distance_timestamp(PG_FUNCTION_ARGS) { float8\t\tdelta = 0; Timestamp\tdt1 = PG_GETARG_TIMESTAMP(0); Timestamp\tdt2 = PG_GETARG_TIMESTAMP(1); delta = (float8) dt2 - (float8) dt1; A...","count":12},{"name":"api-example","value":"Datum fmgr_sql_validator(PG_FUNCTION_ARGS) { Oid\t\t\tfuncoid = PG_GETARG_OID(0); HeapTuple\ttuple; Form_pg_proc proc; List\t   *raw_parsetree_list; List\t   *querytree_list; ListCell   *lc; bool\t\tisnull; D...","count":12},{"name":"api-example","value":"Datum gist_poly_compress(PG_FUNCTION_ARGS) { GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0); GISTENTRY  *retval; if (entry->leafkey) { POLYGON    *in = DatumGetPolygonP(entry->key); BOX\t\t   *r...","count":12},{"name":"api-example","value":"Datum gist_poly_consistent(PG_FUNCTION_ARGS) { GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0); POLYGON    *query = PG_GETARG_POLYGON_P(1); StrategyNumber strategy = (StrategyNumber) PG_GETARG_...","count":12},{"name":"api-example","value":"Datum gisthandler(PG_FUNCTION_ARGS) { IndexAmRoutine *amroutine = makeNode(IndexAmRoutine); amroutine->amstrategies = 0; amroutine->amsupport = GISTNProcs; amroutine->amoptsprocnum = GIST_OPTIONS_PROC...","count":12},{"name":"api-example","value":"Datum gtsvector_compress(PG_FUNCTION_ARGS) { GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0); int\t\t\tsiglen = GET_SIGLEN(); GISTENTRY  *retval = entry; if (entry->leafkey) {\t\t\t\t\t\t\t/* tsvector */...","count":12},{"name":"api-example","value":"Datum hashfloat4(PG_FUNCTION_ARGS) { float4\t\tkey = PG_GETARG_FLOAT4(0); float8\t\tkey8; * On IEEE-float machines, minus zero and zero have different bit patterns * but should compare as equal.  We must ...","count":12},{"name":"api-example","value":"Datum heap_copy_tuple_as_datum(HeapTuple tuple, TupleDesc tupleDesc) { HeapTupleHeader td; * If the tuple contains any external TOAST pointers, we have to inline * those fields to meet the conventions...","count":12},{"name":"api-example","value":"Datum inet_gist_consistent(PG_FUNCTION_ARGS) { GISTENTRY  *ent = (GISTENTRY *) PG_GETARG_POINTER(0); inet\t   *query = PG_GETARG_INET_PP(1); StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16(...","count":12},{"name":"api-example","value":"Datum jsonb_exists(PG_FUNCTION_ARGS) { Jsonb\t   *jb = PG_GETARG_JSONB_P(0); text\t   *key = PG_GETARG_TEXT_PP(1); JsonbValue\tkval; JsonbValue *v = NULL; * We only match Object keys (which are naturally...","count":12},{"name":"api-example","value":"Datum multirange_constructor1(PG_FUNCTION_ARGS) { Oid\t\t\tmltrngtypid = get_fn_expr_rettype(fcinfo->flinfo); Oid\t\t\trngtypid; TypeCacheEntry *typcache; TypeCacheEntry *rangetyp; RangeType  *range; typcac...","count":12},{"name":"api-example","value":"Datum nocache_index_getattr(IndexTuple tup, int attnum, TupleDesc tupleDesc) { char\t   *tp;\t\t\t\t/* ptr to data part of tuple */ bits8\t   *bp = NULL;\t\t/* ptr to null bitmap in tuple */ bool\t\tslow = fals...","count":12},{"name":"api-example","value":"Datum numeric_out(PG_FUNCTION_ARGS) { Numeric\t\tnum = PG_GETARG_NUMERIC(0); NumericVar\tx; char\t   *str; * Handle NaN and infinities */ if (NUMERIC_IS_SPECIAL(num)) { if (NUMERIC_IS_PINF(num)) PG_RETURN...","count":12},{"name":"api-example","value":"Datum pg_extension_config_dump(PG_FUNCTION_ARGS) { Oid\t\t\ttableoid = PG_GETARG_OID(0); text\t   *wherecond = PG_GETARG_TEXT_PP(1); char\t   *tablename; Relation\textRel; ScanKeyData key[1]; SysScanDesc ex...","count":12},{"name":"api-example","value":"Datum pg_get_functiondef(PG_FUNCTION_ARGS) { Oid\t\t\tfuncid = PG_GETARG_OID(0); StringInfoData buf; StringInfoData dq; HeapTuple\tproctup; Form_pg_proc proc; bool\t\tisfunction; Datum\t\ttmp; bool\t\tisnull; c...","count":12},{"name":"api-example","value":"Datum range_gist_picksplit(PG_FUNCTION_ARGS) { GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0); GIST_SPLITVEC *v = (GIST_SPLITVEC *) PG_GETARG_POINTER(1); TypeCacheEntry *typcache...","count":12},{"name":"api-example","value":"Datum satisfies_hash_partition(PG_FUNCTION_ARGS) { typedef struct ColumnsHashData { Oid\t\t\trelid; int\t\t\tnkeys; Oid\t\t\tvariadic_type; int16\t\tvariadic_typlen; bool\t\tvariadic_typbyval; char\t\tvariadic_typal...","count":12},{"name":"api-example","value":"Datum ts_headline_byid_opt(PG_FUNCTION_ARGS) { Oid\t\t\ttsconfig = PG_GETARG_OID(0); text\t   *in = PG_GETARG_TEXT_PP(1); TSQuery\t\tquery = PG_GETARG_TSQUERY(2); text\t   *opt = (PG_NARGS() > 3 && PG_GETARG...","count":12},{"name":"api-example","value":"Datum tsquery_and(PG_FUNCTION_ARGS) { TSQuery\t\ta = PG_GETARG_TSQUERY_COPY(0); TSQuery\t\tb = PG_GETARG_TSQUERY_COPY(1); QTNode\t   *res; TSQuery\t\tquery; if (a->size == 0) { PG_FREE_IF_COPY(a, 1); PG_RETU...","count":12},{"name":"api-example","value":"ExecAuxRowMark * ExecBuildAuxRowMark(ExecRowMark *erm, List *targetlist) { ExecAuxRowMark *aerm = (ExecAuxRowMark *) palloc0(sizeof(ExecAuxRowMark)); char\t\tresname[32]; aerm->rowmark = erm; if (erm->m...","count":12},{"name":"api-example","value":"GenericXLogState * GenericXLogStart(Relation relation) { GenericXLogState *state; int\t\t\ti; state = (GenericXLogState *) palloc_aligned(sizeof(GenericXLogState), PG_IO_ALIGN_SIZE, 0); state->isLogged =...","count":12},{"name":"api-example","value":"HashJoinState * ExecInitHashJoin(HashJoin *node, EState *estate, int eflags) { HashJoinState *hjstate; Plan\t   *outerNode; Hash\t   *hashNode; TupleDesc\touterDesc, innerDesc; const TupleTableSlotOps *o...","count":12},{"name":"api-example","value":"HeapTuple SPI_modifytuple(Relation rel, HeapTuple tuple, int natts, int *attnum, Datum *Values, const char *Nulls) { MemoryContext oldcxt; HeapTuple\tmtuple; int\t\t\tnumberOfAttributes; Datum\t   *v; bool...","count":12},{"name":"api-example","value":"JsonbValue * findJsonbValueFromContainer(JsonbContainer *container, uint32 flags, JsonbValue *key) { JEntry\t   *children = container->children; int\t\t\tcount = JsonContainerSize(container); Assert((flag...","count":12},{"name":"api-example","value":"LLVMTypeRef llvm_pg_var_func_type(const char *varname) { LLVMValueRef v_srcvar; LLVMTypeRef typ; v_srcvar = LLVMGetNamedFunction(llvm_types_module, varname); if (!v_srcvar) elog(ERROR, \"function %s no...","count":12},{"name":"api-example","value":"Node * query_or_expression_tree_mutator_impl(Node *node, tree_mutator_callback mutator, void *context, int flags) { if (node && IsA(node, Query)) return (Node *) query_tree_mutator((Query *) node, mut...","count":12},{"name":"api-example","value":"Oid CollationCreate(const char *collname, Oid collnamespace, Oid collowner, char collprovider, bool collisdeterministic, int32 collencoding, const char *collcollate, const char *collctype, const char ...","count":12},{"name":"api-example","value":"Oid CreateTableSpace(CreateTableSpaceStmt *stmt) { Relation\trel; Datum\t\tvalues[Natts_pg_tablespace]; bool\t\tnulls[Natts_pg_tablespace] = {0}; HeapTuple\ttuple; Oid\t\t\ttablespaceoid; char\t   *location; Oi...","count":12},{"name":"api-example","value":"PlannerInfo * subquery_planner(PlannerGlobal *glob, Query *parse, PlannerInfo *parent_root, bool hasRecursion, double tuple_fraction, SetOperationStmt *setops) { PlannerInfo *root; List\t   *newWithChe...","count":12},{"name":"api-example","value":"RangeType * multirange_get_range(TypeCacheEntry *rangetyp, const MultirangeType *multirange, int i) { uint32\t\toffset; uint8\t\tflags; Pointer\t\tbegin, ptr; int16\t\ttyplen = rangetyp->rngelemtype->typlen; ...","count":12},{"name":"api-example","value":"RangeType * multirange_get_union_range(TypeCacheEntry *rangetyp, const MultirangeType *mr) { RangeBound\tlower, upper, tmp; if (MultirangeIsEmpty(mr)) return make_empty_range(rangetyp); multirange_get_...","count":12},{"name":"api-example","value":"STDAPI DllRegisterServer(void) { HKEY\t\tkey; DWORD\t\tdata; char\t\tbuffer[_MAX_PATH]; char\t\tkey_name[400]; if (!GetModuleFileName((HMODULE) g_module, buffer, sizeof(buffer))) { MessageBox(NULL, \"Could not...","count":12},{"name":"api-example","value":"Selectivity clause_selectivity_ext(PlannerInfo *root, Node *clause, int varRelid, JoinType jointype, SpecialJoinInfo *sjinfo, bool use_extended_stats) { Selectivity s1 = 0.5;\t\t/* default for any unhan...","count":12},{"name":"api-example","value":"Selectivity clauselist_selectivity_ext(PlannerInfo *root, List *clauses, int varRelid, JoinType jointype, SpecialJoinInfo *sjinfo, bool use_extended_stats) { Selectivity s1 = 1.0; RelOptInfo *rel; Bit...","count":12},{"name":"api-example","value":"TM_Result heap_lock_tuple(Relation relation, HeapTuple tuple, CommandId cid, LockTupleMode mode, LockWaitPolicy wait_policy, bool follow_updates, Buffer *buffer, TM_FailureData *tmfd) { TM_Result\tresu...","count":12},{"name":"api-example","value":"TransactionId TwoPhaseGetXidByVirtualXID(VirtualTransactionId vxid, bool *have_more) { int\t\t\ti; TransactionId result = InvalidTransactionId; Assert(VirtualTransactionIdIsValid(vxid)); LWLockAcquire(Tw...","count":12},{"name":"api-example","value":"TupleTableSlot * ExecScan(ScanState *node, ExecScanAccessMtd accessMtd,\t/* function returning a tuple */ ExecScanRecheckMtd recheckMtd) { ExprContext *econtext; ExprState  *qual; ProjectionInfo *projI...","count":12},{"name":"api-example","value":"WS2TCPIP_INLINE int IN6ADDR_ISANY(const struct sockaddr_in6 *a) { return ((a->sin6_family==AF_INET6) && IN6_IS_ADDR_UNSPECIFIED(&a->sin6_addr)); }","count":12},{"name":"api-example","value":"XLogRecPtr gistXLogAssignLSN(void) { int\t\t\tdummy = 0; * Records other than XLOG_SWITCH must have content. We use an integer 0 * to follow the restriction. */ XLogBeginInsert(); XLogSetRecordFlags(XLOG...","count":12},{"name":"api-example","value":"__mingw_ovr int __cdecl _snprintf_l(char *_DstBuf, size_t _MaxCount, const char *_Format, _locale_t _Locale, ...) { __builtin_va_list _ArgList; int _Ret; __builtin_va_start(_ArgList, _Locale); _Ret = ...","count":12},{"name":"api-example","value":"__mingw_ovr int __cdecl _snwscanf_s_l(const wchar_t *_Src, size_t _MaxCount, const wchar_t *_Format, _locale_t _Locale, ...) { __builtin_va_list _ArgList; int _Ret; __builtin_va_start(_ArgList, _Local...","count":12},{"name":"api-example","value":"__mingw_ovr int __cdecl _vfprintf_p(FILE *_File, const char *_Format, va_list _ArgList) { return _vfprintf_p_l(_File, _Format, NULL, _ArgList); }","count":12},{"name":"api-example","value":"__mingw_ovr int __cdecl _vprintf_l(const char *_Format, _locale_t _Locale, va_list _ArgList) { return _vfprintf_l(stdout, _Format, _Locale, _ArgList); }","count":12},{"name":"api-example","value":"__mingw_ovr int __cdecl _vscanf_l(const char *_Format, _locale_t _Locale, va_list _ArgList) { return _vfscanf_l(stdin, _Format, _Locale, _ArgList); }","count":12},{"name":"api-example","value":"__mingw_ovr int __cdecl _vscprintf_p(const char *_Format, va_list _ArgList) { return _vscprintf_p_l(_Format, NULL, _ArgList); }","count":12},{"name":"api-example","value":"__mingw_ovr int __cdecl _vsnprintf_c(char *_DstBuf, size_t _MaxCount, const char *_Format, va_list _ArgList) { return _vsnprintf_c_l(_DstBuf, _MaxCount, _Format, NULL, _ArgList); }","count":12},{"name":"api-example","value":"__mingw_ovr int __cdecl _vsnwprintf_s(wchar_t *_DstBuf, size_t _DstSize, size_t _MaxCount, const wchar_t *_Format, va_list _ArgList) { return _vsnwprintf_s_l(_DstBuf, _DstSize, _MaxCount, _Format, NUL...","count":12},{"name":"api-example","value":"__mingw_ovr int __cdecl _vsprintf_p(char *_Dst, size_t _MaxCount, const char *_Format, va_list _ArgList) { return _vsprintf_p_l(_Dst, _MaxCount, _Format, NULL, _ArgList); }","count":12},{"name":"api-example","value":"__mingw_ovr int __cdecl _vwprintf_s_l(const wchar_t *_Format, _locale_t _Locale, va_list _ArgList) { return _vfwprintf_s_l(stdout, _Format, _Locale, _ArgList); }","count":12},{"name":"api-example","value":"__mingw_ovr int __cdecl vfprintf_s(FILE *_File, const char *_Format, va_list _ArgList) { return _vfprintf_s_l(_File, _Format, NULL, _ArgList); }","count":12},{"name":"api-example","value":"__mingw_ovr int __cdecl vfscanf_s(FILE *_File, const char *_Format, va_list _ArgList) { return _vfscanf_s_l(_File, _Format, NULL, _ArgList); }","count":12},{"name":"api-example","value":"__mingw_ovr int __cdecl vfwscanf_s(FILE* _File, const wchar_t *_Format, va_list _ArgList) { return _vfwscanf_s_l(_File, _Format, NULL, _ArgList); }","count":12},{"name":"api-example","value":"__mingw_ovr int __cdecl vsnprintf_s(char *_DstBuf, size_t _DstSize, size_t _MaxCount, const char *_Format, va_list _ArgList) { return _vsnprintf_s_l(_DstBuf, _DstSize, _MaxCount, _Format, NULL, _ArgLi...","count":12},{"name":"api-example","value":"__mingw_ovr int __cdecl vsprintf_s(char *_DstBuf, size_t _Size, const char *_Format, va_list _ArgList) { return _vsprintf_s_l(_DstBuf, _Size, _Format, NULL, _ArgList); }","count":12},{"name":"api-example","value":"__mingw_ovr int __cdecl vsscanf_s(const char *_Src, const char *_Format, va_list _ArgList) { return _vsscanf_s_l(_Src, _Format, NULL, _ArgList); }","count":12},{"name":"api-example","value":"__mingw_ovr int __cdecl vswprintf_s(wchar_t *_DstBuf, size_t _DstSize, const wchar_t *_Format, va_list _ArgList) { return _vswprintf_s_l(_DstBuf, _DstSize, _Format, NULL, _ArgList); }","count":12},{"name":"api-example","value":"__mingw_ovr int __cdecl vswscanf_s(const wchar_t *_Src, const wchar_t *_Format, va_list _ArgList) { return _vswscanf_s_l(_Src, _Format, NULL, _ArgList); }","count":12},{"name":"api-example","value":"bool IsSubxactTopXidLogPending(void) { if (CurrentTransactionState->topXidLogged) return false; if (!XLogLogicalInfoActive()) return false; if (!IsTransactionState()) return false; if (!IsSubTransacti...","count":12},{"name":"api-example","value":"bool LWLockAcquire(LWLock *lock, LWLockMode mode) { PGPROC\t   *proc = MyProc; bool\t\tresult = true; int\t\t\textraWaits = 0; #ifdef LWLOCK_STATS lwlock_stats *lwstats; lwstats = get_lwlock_stats_entry(loc...","count":12},{"name":"api-example","value":"bool RestoreArchivedFile(char *path, const char *xlogfname, const char *recovername, off_t expectedSize, bool cleanupEnabled) { char\t\txlogpath[MAXPGPATH]; char\t   *xlogRestoreCmd; char\t\tlastRestartPoi...","count":12},{"name":"api-example","value":"bool TransactionIdIsInProgress(TransactionId xid) { static TransactionId *xids = NULL; static TransactionId *other_xids; XidCacheStatus *other_subxidstates; int\t\t\tnxids = 0; ProcArrayStruct *arrayP = ...","count":12},{"name":"api-example","value":"bool gettoken_tsvector(TSVectorParseState state, char **strval, int *lenval, WordEntryPos **pos_ptr, int *poslen, char **endptr) { int\t\t\toldstate = 0; char\t   *curpos = state->word; int\t\t\tstatecode = ...","count":12},{"name":"api-example","value":"bool heap_fetch(Relation relation, Snapshot snapshot, HeapTuple tuple, Buffer *userbuf, bool keep_buf) { ItemPointer tid = &(tuple->t_self); ItemId\t\tlp; Buffer\t\tbuffer; Page\t\tpage; OffsetNumber offnum...","count":12},{"name":"api-example","value":"char * JsonEncodeDateTime(char *buf, Datum value, Oid typid, const int *tzp) { if (!buf) buf = palloc(MAXDATELEN + 1); switch (typid) { case DATEOID: { DateADT\t\tdate; struct pg_tm tm; date = DatumGetD...","count":12},{"name":"api-example","value":"char * makeMultirangeTypeName(const char *rangeTypeName, Oid typeNamespace) { char\t   *buf; char\t   *rangestr; * If the range type name contains \"range\" then change that to * \"multirange\". Otherwise a...","count":12},{"name":"api-example","value":"char * pg_be_scram_build_secret(const char *password) { char\t   *prep_password; pg_saslprep_rc rc; char\t\tsaltbuf[SCRAM_DEFAULT_SALT_LEN]; char\t   *result; const char *errstr = NULL; * Normalize the pa...","count":12},{"name":"api-example","value":"const char * winsock_strerror(int err, char *strerrbuf, size_t buflen) { unsigned long flags; int\t\t\toffs, i; int\t\t\tsuccess = LookupWSErrorMessage(err, strerrbuf); for (i = 0; !success && i < DLLS_SIZE...","count":12},{"name":"api-example","value":"const char * xlog_identify(uint8 info) { const char *id = NULL; switch (info & ~XLR_INFO_MASK) { case XLOG_CHECKPOINT_SHUTDOWN: id = \"CHECKPOINT_SHUTDOWN\"; break; case XLOG_CHECKPOINT_ONLINE: id = \"CH...","count":12},{"name":"api-example","value":"dsa_pointer dsa_allocate_extended(dsa_area *area, size_t size, int flags) { uint16\t\tsize_class; dsa_pointer start_pointer; dsa_segment_map *segment_map; dsa_pointer result; Assert(size > 0); if (((fla...","count":12},{"name":"api-example","value":"int DecodeTimezoneAbbrev(int field, const char *lowtoken, int *ftype, int *offset, pg_tz **tz, DateTimeErrorExtra *extra) { const datetkn *tp; tp = abbrevcache[field]; if (tp == NULL || strncmp(lowtok...","count":12},{"name":"api-example","value":"int PQsetvalue(PGresult *res, int tup_num, int field_num, char *value, int len) { PGresAttValue *attval; const char *errmsg = NULL; if (!res || (const PGresult *) res == &OOM_result) return false; if ...","count":12},{"name":"api-example","value":"int SPI_execute(const char *src, bool read_only, long tcount) { _SPI_plan\tplan; SPIExecuteOptions options; int\t\t\tres; if (src == NULL || tcount < 0) return SPI_ERROR_ARGUMENT; res = _SPI_begin_call(tr...","count":12},{"name":"api-example","value":"int be_tls_open_server(Port *port) { int\t\t\tr; int\t\t\terr; int\t\t\twaitfor; unsigned long ecode; bool\t\tgive_proto_hint; Assert(!port->ssl); Assert(!port->peer); if (!SSL_context) { ereport(COMMERROR, (err...","count":12},{"name":"api-example","value":"int decadd(decimal *arg1, decimal *arg2, decimal *sum) { errno = 0; deccall3(arg1, arg2, sum, PGTYPESnumeric_add); if (errno == PGTYPES_NUM_OVERFLOW) return ECPG_INFORMIX_NUM_OVERFLOW; else if (errno ...","count":12},{"name":"api-example","value":"int getopt(int nargc, char *const *nargv, const char *ostr) { static char *place = EMSG;\t/* option letter processing */ char\t   *oli;\t\t\t/* option letter list index */ if (!*place) {\t\t\t\t\t\t\t/* update sc...","count":12},{"name":"api-example","value":"int ginTraverseLock(Buffer buffer, bool searchMode) { Page\t\tpage; int\t\t\taccess = GIN_SHARE; LockBuffer(buffer, GIN_SHARE); page = BufferGetPage(buffer); if (GinPageIsLeaf(page)) { if (searchMode == fa...","count":12},{"name":"api-example","value":"int is_infinite(double val) { int\t\t\tinf = isinf(val); if (inf == 0) return 0; else if (val > 0) return 1; else return -1; }","count":12},{"name":"api-example","value":"int set_config_with_handle(const char *name, config_handle *handle, const char *value, GucContext context, GucSource source, Oid srole, GucAction action, bool changeVal, int elevel, bool is_reload) { ...","count":12},{"name":"api-example","value":"int t_isdigit(const char *ptr) { int\t\t\tclen = pg_mblen(ptr); wchar_t\t\tcharacter[WC_BUF_LEN]; pg_locale_t mylocale = 0;\t/* TODO */ if (clen == 1 || database_ctype_is_c) return isdigit(TOUCHAR(ptr)); ch...","count":12},{"name":"api-example","value":"int time2tm(TimeADT time, struct pg_tm *tm, fsec_t *fsec) { tm->tm_hour = time / USECS_PER_HOUR; time -= tm->tm_hour * USECS_PER_HOUR; tm->tm_min = time / USECS_PER_MINUTE; time -= tm->tm_min * USECS_...","count":12},{"name":"api-example","value":"ssize_t pg_GSS_write(PGconn *conn, const void *ptr, size_t len) { OM_uint32\tmajor, minor; gss_buffer_desc input, output = GSS_C_EMPTY_BUFFER; ssize_t\t\tret = -1; size_t\t\tbytes_to_encrypt; size_t\t\tbytes...","count":12},{"name":"api-example","value":"static AclMode object_aclmask_ext(Oid classid, Oid objectid, Oid roleid, AclMode mask, AclMaskHow how, bool *is_missing) { int\t\t\tcacheid; AclMode\t\tresult; HeapTuple\ttuple; Datum\t\taclDatum; bool\t\tisNul...","count":12},{"name":"api-example","value":"static BTStack _bt_search_insert(Relation rel, Relation heaprel, BTInsertState insertstate) { Assert(insertstate->buf == InvalidBuffer); Assert(!insertstate->bounds_valid); Assert(insertstate->posting...","count":12},{"name":"api-example","value":"static BlockNumber dataLocateItem(GinBtree btree, GinBtreeStack *stack) { OffsetNumber low, high, maxoff; PostingItem *pitem = NULL; int\t\t\tresult; Page\t\tpage = BufferGetPage(stack->buffer); Assert(!Gi...","count":12},{"name":"api-example","value":"static Buffer _bt_newlevel(Relation rel, Relation heaprel, Buffer lbuf, Buffer rbuf) { Buffer\t\trootbuf; Page\t\tlpage, rootpage; BlockNumber lbkno, rbkno; BlockNumber rootblknum; BTPageOpaque rootopaque...","count":12},{"name":"api-example","value":"static Buffer _bt_split(Relation rel, Relation heaprel, BTScanInsert itup_key, Buffer buf, Buffer cbuf, OffsetNumber newitemoff, Size newitemsz, IndexTuple newitem, IndexTuple orignewitem, IndexTuple ...","count":12},{"name":"api-example","value":"static Datum pg_logical_slot_get_changes_guts(FunctionCallInfo fcinfo, bool confirm, bool binary) { Name\t\tname; XLogRecPtr\tupto_lsn; int32\t\tupto_nchanges; ReturnSetInfo *rsinfo = (ReturnSetInfo *) fci...","count":12},{"name":"api-example","value":"static GISTSearchItem * getNextGISTSearchItem(GISTScanOpaque so) { GISTSearchItem *item; if (!pairingheap_is_empty(so->queue)) { item = (GISTSearchItem *) pairingheap_remove_first(so->queue); } else {...","count":12},{"name":"api-example","value":"static HTSV_Result heap_prune_satisfies_vacuum(PruneState *prstate, HeapTuple tup, Buffer buffer) { HTSV_Result res; TransactionId dead_after; res = HeapTupleSatisfiesVacuumHorizon(tup, buffer, &dead_...","count":12},{"name":"api-example","value":"static List * fetch_table_list(WalReceiverConn *wrconn, List *publications) { WalRcvExecResult *res; StringInfoData cmd; TupleTableSlot *slot; Oid\t\t\ttableRow[3] = {TEXTOID, TEXTOID, InvalidOid}; List\t...","count":12},{"name":"api-example","value":"static Node * replace_nestloop_params_mutator(Node *node, PlannerInfo *root) { if (node == NULL) return NULL; if (IsA(node, Var)) { Var\t\t   *var = (Var *) node; Assert(var->varlevelsup == 0); if (IS_S...","count":12},{"name":"api-example","value":"static Oid GetIndexInputType(Relation index, AttrNumber indexcol) { Oid\t\t\topcintype; AttrNumber\theapcol; List\t   *indexprs; ListCell   *indexpr_item; Assert(index->rd_index != NULL); Assert(indexcol >...","count":12},{"name":"api-example","value":"static Oid lo_import_internal(text *filename, Oid lobjOid) { int\t\t\tfd; int\t\t\tnbytes, tmp PG_USED_FOR_ASSERTS_ONLY; char\t\tbuf[BUFSIZE]; char\t\tfnamebuf[MAXPGPATH]; LargeObjectDesc *lobj; Oid\t\t\toid; Prev...","count":12},{"name":"api-example","value":"static Plan * create_append_plan(PlannerInfo *root, AppendPath *best_path, int flags) { Append\t   *plan; List\t   *tlist = build_path_tlist(root, &best_path->path); int\t\t\torig_tlist_length = list_lengt...","count":12},{"name":"api-example","value":"static SV  * plperl_ref_from_pg_array(Datum arg, Oid typid) { dTHX; ArrayType  *ar = DatumGetArrayTypeP(arg); Oid\t\t\telementtype = ARR_ELEMTYPE(ar); int16\t\ttyplen; bool\t\ttypbyval; char\t\ttypalign, typde...","count":12},{"name":"api-example","value":"static Selectivity get_foreign_key_join_selectivity(PlannerInfo *root, Relids outer_relids, Relids inner_relids, SpecialJoinInfo *sjinfo, List **restrictlist) { Selectivity fkselec = 1.0; JoinType\tjoi...","count":12},{"name":"api-example","value":"static Size _brin_parallel_estimate_shared(Relation heap, Snapshot snapshot) { return add_size(BUFFERALIGN(sizeof(BrinShared)), table_parallelscan_estimate(heap, snapshot)); }","count":12},{"name":"api-example","value":"static TupleDesc get_cached_rowtype(Oid type_id, int32 typmod, ExprEvalRowtypeCache *rowcache, bool *changed) { if (type_id != RECORDOID) { * It's a named composite type, so use the regular typcache. ...","count":12},{"name":"api-example","value":"static TupleTableSlot * ExecMergeJoin(PlanState *pstate) { MergeJoinState *node = castNode(MergeJoinState, pstate); ExprState  *joinqual; ExprState  *otherqual; bool\t\tqualResult; int\t\t\tcompareResult; ...","count":12},{"name":"api-example","value":"static TupleTableSlot * ExecSort(PlanState *pstate) { SortState  *node = castNode(SortState, pstate); EState\t   *estate; ScanDirection dir; Tuplesortstate *tuplesortstate; TupleTableSlot *slot; CHECK_...","count":12},{"name":"api-example","value":"static bool handle_streamed_transaction(LogicalRepMsgType action, StringInfo s) { TransactionId current_xid; ParallelApplyWorkerInfo *winfo; TransApplyAction apply_action; StringInfoData original_msg;...","count":12},{"name":"api-example","value":"static bool heapam_scan_bitmap_next_block(TableScanDesc scan, TBMIterateResult *tbmres) { HeapScanDesc hscan = (HeapScanDesc) scan; BlockNumber block = tbmres->blockno; Buffer\t\tbuffer; Snapshot\tsnapsh...","count":12},{"name":"api-example","value":"static bool lazy_vacuum_all_indexes(LVRelState *vacrel) { bool\t\tallindexes = true; double\t\told_live_tuples = vacrel->rel->rd_rel->reltuples; const int\tprogress_start_index[] = { PROGRESS_VACUUM_PHASE,...","count":12},{"name":"api-example","value":"static bool makeVariableValue(Variable *var) { size_t\t\tslen; if (var->value.type != PGBT_NO_VALUE) return true;\t\t\t/* no work */ slen = strlen(var->svalue); if (slen == 0) return false; if (pg_strcasec...","count":12},{"name":"api-example","value":"static bool parse_hba_auth_opt(char *name, char *val, HbaLine *hbaline, int elevel, char **err_msg) { int\t\t\tline_num = hbaline->linenumber; char\t   *file_name = hbaline->sourcefile; #ifdef USE_LDAP hb...","count":12},{"name":"api-example","value":"static bool printCrosstab(const PGresult *result, int num_columns, pivot_field *piv_columns, int field_for_columns, int num_rows, pivot_field *piv_rows, int field_for_rows, int field_for_data) { print...","count":12},{"name":"api-example","value":"static bool read_tablespace_map(List **tablespaces) { tablespaceinfo *ti; FILE\t   *lfp; char\t\tstr[MAXPGPATH]; int\t\t\tch, i, n; bool\t\twas_backslash; * See if tablespace_map file is present */ lfp = Allo...","count":12},{"name":"api-example","value":"static bool tuples_equal(TupleTableSlot *slot1, TupleTableSlot *slot2, TypeCacheEntry **eq) { int\t\t\tattrnum; Assert(slot1->tts_tupleDescriptor->natts == slot2->tts_tupleDescriptor->natts); slot_getall...","count":12},{"name":"api-example","value":"static bool verify_btree_slot_handler(PGresult *res, PGconn *conn, void *context) { RelationInfo *rel = (RelationInfo *) context; if (PQresultStatus(res) == PGRES_TUPLES_OK) { int\t\t\tntups = PQntuples(...","count":12},{"name":"api-example","value":"static char * escape_quotes_bki(const char *src) { char\t   *result; char\t   *data = escape_quotes(src); char\t   *resultp; char\t   *datap; result = (char *) pg_malloc(strlen(data) + 3); resultp = resul...","count":12},{"name":"api-example","value":"static chr * longest(struct vars *v, struct dfa *d, chr *start,\t\t\t\t/* where the match should start */ chr *stop,\t\t\t\t/* match must end at or before here */ int *hitstopp)\t\t\t/* record whether hit v->sto...","count":12},{"name":"api-example","value":"static const char * auth_method_description(AuthRequest areq) { switch (areq) { case AUTH_REQ_PASSWORD: return libpq_gettext(\"server requested a cleartext password\"); case AUTH_REQ_MD5: return libpq_g...","count":12},{"name":"api-example","value":"static double point_box_distance(Point *point, BOX *box) { double\t\tdx, dy; if (isnan(point->x) || isnan(box->low.x) || isnan(point->y) || isnan(box->low.y)) return get_float8_nan(); if (point->x < box...","count":12},{"name":"api-example","value":"static inline FullTransactionId FullXidRelativeTo(FullTransactionId rel, TransactionId xid) { TransactionId rel_xid = XidFromFullTransactionId(rel); Assert(TransactionIdIsValid(xid)); Assert(Transacti...","count":12},{"name":"api-example","value":"static inline MultiXactId PreviousMultiXactId(MultiXactId multi) { return multi == FirstMultiXactId ? MaxMultiXactId : multi - 1; }","count":12},{"name":"api-example","value":"static inline bool CopyGetInt16(CopyFromState cstate, int16 *val) { uint16\t\tbuf; if (CopyReadBinaryData(cstate, (char *) &buf, sizeof(buf)) != sizeof(buf)) { *val = 0;\t\t\t\t/* suppress compiler warning ...","count":12},{"name":"api-example","value":"static inline floating_decimal_64 d2d(const uint64 ieeeMantissa, const uint32 ieeeExponent) { int32\t\te2; uint64\t\tm2; if (ieeeExponent == 0) { e2 = 1 - DOUBLE_BIAS - DOUBLE_MANTISSA_BITS - 2; m2 = ieee...","count":12},{"name":"api-example","value":"static inline void CopySendInt16(CopyToState cstate, int16 val) { uint16\t\tbuf; buf = pg_hton16((uint16) val); CopySendData(cstate, &buf, sizeof(buf)); }","count":12},{"name":"api-example","value":"static int FreeDesc(AllocateDesc *desc) { int\t\t\tresult; switch (desc->kind) { case AllocateDescFile: result = fclose(desc->desc.file); break; case AllocateDescPipe: result = pclose(desc->desc.file); b...","count":12},{"name":"api-example","value":"static int PQsendQueryInternal(PGconn *conn, const char *query, bool newQuery) { PGcmdQueueEntry *entry = NULL; if (!PQsendQueryStart(conn, newQuery)) return 0; if (!query) { libpq_append_conn_error(c...","count":12},{"name":"api-example","value":"static int ProcessStartupPacket(Port *port, bool ssl_done, bool gss_done) { int32\t\tlen; char\t   *buf; ProtocolVersion proto; MemoryContext oldcontext; pq_startmsgread(); * Grab the first byte of the l...","count":12},{"name":"api-example","value":"static int acquire_sample_rows(Relation onerel, int elevel, HeapTuple *rows, int targrows, double *totalrows, double *totaldeadrows) { int\t\t\tnumrows = 0;\t/* # rows now in reservoir */ double\t\tsamplero...","count":12},{"name":"api-example","value":"static int deccall2(decimal *arg1, decimal *arg2, int (*ptr) (numeric *, numeric *)) { numeric    *a1, *a2; int\t\t\ti; if ((a1 = PGTYPESnumeric_new()) == NULL) return ECPG_INFORMIX_OUT_OF_MEMORY; if ((a...","count":12},{"name":"api-example","value":"static int deccall3(decimal *arg1, decimal *arg2, decimal *result, int (*ptr) (numeric *, numeric *, numeric *)) { numeric    *a1, *a2, *nres; int\t\t\ti; * we must NOT set the result to NULL here becaus...","count":12},{"name":"api-example","value":"static int exec_stmt_block(PLpgSQL_execstate *estate, PLpgSQL_stmt_block *block) { volatile int rc = -1; int\t\t\ti; * First initialize all variables declared in this block */ estate->err_text = gettext_...","count":12},{"name":"api-example","value":"static int get_partition_for_tuple(PartitionDispatch pd, Datum *values, bool *isnull) { int\t\t\tbound_offset = -1; int\t\t\tpart_index = -1; PartitionKey key = pd->key; PartitionDesc partdesc = pd->partdes...","count":12},{"name":"api-example","value":"static int inet_cidr_pton_ipv6(const char *src, u_char *dst, size_t size) { static const char xdigits_l[] = \"0123456789abcdef\", xdigits_u[] = \"0123456789ABCDEF\"; u_char\t\ttmp[NS_IN6ADDRSZ], *tp, *endp,...","count":12},{"name":"api-example","value":"static int macaddr_cmp_internal(macaddr *a1, macaddr *a2) { if (hibits(a1) < hibits(a2)) return -1; else if (hibits(a1) > hibits(a2)) return 1; else if (lobits(a1) < lobits(a2)) return -1; else if (lo...","count":12},{"name":"api-example","value":"static int r_stem_suffix_chain_before_ki(struct SN_env * z) { z->ket = z->c; {   int ret = r_mark_ki(z); if (ret <= 0) return ret; } {   int m1 = z->l - z->c; (void)m1; {   int ret = r_mark_DA(z); if ...","count":12},{"name":"api-example","value":"static int uniqueWORD(ParsedWord *a, int32 l) { ParsedWord *ptr, *res; int\t\t\ttmppos; if (l == 1) { tmppos = LIMITPOS(a->pos.pos); a->alen = 2; a->pos.apos = (uint16 *) palloc(sizeof(uint16) * a->alen)...","count":12},{"name":"api-example","value":"static pg_attribute_always_inline BufferDesc * BufferAlloc(SMgrRelation smgr, char relpersistence, ForkNumber forkNum, BlockNumber blockNum, BufferAccessStrategy strategy, bool *foundPtr, IOContext io...","count":12},{"name":"api-example","value":"static pg_attribute_always_inline TupleTableSlot * ExecHashJoinImpl(PlanState *pstate, bool parallel) { HashJoinState *node = castNode(HashJoinState, pstate); PlanState  *outerNode; HashState  *hashNo...","count":12},{"name":"api-example","value":"static pushdown_safe_type qual_is_pushdown_safe(Query *subquery, Index rti, RestrictInfo *rinfo, pushdown_safety_info *safetyInfo) { pushdown_safe_type safe = PUSHDOWN_SAFE; Node\t   *qual = (Node *) r...","count":12},{"name":"api-example","value":"static struct cvec * getcvec(struct vars *v,\t\t\t/* context */ int nchrs,\t\t\t\t/* to hold this many chrs... */ int nranges)\t\t\t/* ... and this many ranges */ { if (v->cv != NULL && nchrs <= v->cv->chrspace...","count":12},{"name":"api-example","value":"static void BaseBackup(char *compression_algorithm, char *compression_detail, CompressionLocation compressloc, pg_compress_specification *client_compress, char *incremental_manifest) { PGresult   *res...","count":12},{"name":"api-example","value":"static void LWLockWakeup(LWLock *lock) { bool\t\tnew_release_ok; bool\t\twokeup_somebody = false; proclist_head wakeup; proclist_mutable_iter iter; proclist_init(&wakeup); new_release_ok = true; LWLockWai...","count":12},{"name":"api-example","value":"static void ReorderBufferProcessPartialChange(ReorderBuffer *rb, ReorderBufferTXN *txn, ReorderBufferChange *change, bool toast_insert) { ReorderBufferTXN *toptxn; * The partial changes need to be pro...","count":12},{"name":"api-example","value":"static void StartTransaction(void) { TransactionState s; VirtualTransactionId vxid; * Let's just make sure the state stack is empty */ s = &TopTransactionStateData; CurrentTransactionState = s; Assert...","count":12},{"name":"api-example","value":"static void TransactionIdSetPageStatus(TransactionId xid, int nsubxids, TransactionId *subxids, XidStatus status, XLogRecPtr lsn, int64 pageno, bool all_xact_same_page) { LWLock\t   *lock; StaticAssert...","count":12},{"name":"api-example","value":"static void TranslateSocketError(void) { switch (WSAGetLastError()) { case WSAEINVAL: case WSANOTINITIALISED: case WSAEINVALIDPROVIDER: case WSAEINVALIDPROCTABLE: case WSAEDESTADDRREQ: errno = EINVAL;...","count":12},{"name":"api-example","value":"static void UpdateXmaxHintBits(HeapTupleHeader tuple, Buffer buffer, TransactionId xid) { Assert(TransactionIdEquals(HeapTupleHeaderGetRawXmax(tuple), xid)); Assert(!(tuple->t_infomask & HEAP_XMAX_IS_...","count":12},{"name":"api-example","value":"static void ValidateXLOGDirectoryStructure(void) { char\t\tpath[MAXPGPATH]; struct stat stat_buf; if (stat(XLOGDIR, &stat_buf) != 0 || !S_ISDIR(stat_buf.st_mode)) ereport(FATAL, (errcode_for_file_access...","count":12},{"name":"api-example","value":"static void XLogReportParameters(void) { if (wal_level != ControlFile->wal_level || wal_log_hints != ControlFile->wal_log_hints || MaxConnections != ControlFile->MaxConnections || max_worker_processes...","count":12},{"name":"api-example","value":"static void _outConst(StringInfo str, const Const *node) { WRITE_NODE_TYPE(\"CONST\"); WRITE_OID_FIELD(consttype); WRITE_INT_FIELD(consttypmod); WRITE_OID_FIELD(constcollid); WRITE_INT_FIELD(constlen); ...","count":12},{"name":"api-example","value":"static void add_var(const NumericVar *var1, const NumericVar *var2, NumericVar *result) { * Decide on the signs of the two variables what to do */ if (var1->sign == NUMERIC_POS) { if (var2->sign == NU...","count":12},{"name":"api-example","value":"static void alloc_var(NumericVar *var, int ndigits) { digitbuf_free(var->buf); var->buf = digitbuf_alloc(ndigits + 1); var->buf[0] = 0;\t\t\t/* spare digit for rounding */ var->digits = var->buf + 1; var...","count":12},{"name":"api-example","value":"static void bloom_filter_size(int ndistinct, double false_positive_rate, int *nbytesp, int *nbitsp, int *nhashesp) { double\t\tk; int\t\t\tnbits, nbytes; nbits = ceil(-(ndistinct * log(false_positive_rate)...","count":12},{"name":"api-example","value":"static void deleteOneObject(const ObjectAddress *object, Relation *depRel, int flags) { ScanKeyData key[3]; int\t\t\tnkeys; SysScanDesc scan; HeapTuple\ttup; InvokeObjectDropHookArg(object->classId, objec...","count":12},{"name":"api-example","value":"static void dumpDatabase(Archive *fout) { DumpOptions *dopt = fout->dopt; PQExpBuffer dbQry = createPQExpBuffer(); PQExpBuffer delQry = createPQExpBuffer(); PQExpBuffer creaQry = createPQExpBuffer(); ...","count":12},{"name":"api-example","value":"static void ecpg_finish(struct connection *act) { if (act != NULL) { struct ECPGtype_information_cache *cache, *ptr; ecpg_deallocate_all_conn(0, ECPG_COMPAT_PGSQL, act); PQfinish(act->connection); * n...","count":12},{"name":"api-example","value":"static void heapam_relation_set_new_filelocator(Relation rel, const RelFileLocator *newrlocator, char persistence, TransactionId *freezeXid, MultiXactId *minmulti) { SMgrRelation srel; * Initialize to...","count":12},{"name":"api-example","value":"static void initcm(struct vars *v, struct colormap *cm) { struct colordesc *cd; cm->magic = CMMAGIC; cm->v = v; cm->ncds = NINLINECDS; cm->cd = cm->cdspace; cm->max = 0; cm->free = 0; cd = cm->cd;\t\t\t\t...","count":12},{"name":"api-example","value":"static void interpret_AS_clause(Oid languageOid, const char *languageName, char *funcname, List *as, Node *sql_body_in, List *parameterTypes, List *inParameterNames, char **prosrc_str_p, char **probin...","count":12},{"name":"api-example","value":"static void llvm_compile_module(LLVMJitContext *context) { LLVMJitHandle *handle; MemoryContext oldcontext; instr_time\tstarttime; instr_time\tendtime; #if LLVM_VERSION_MAJOR > 11 LLVMOrcLLJITRef compil...","count":12},{"name":"api-example","value":"static void md5_calc(const uint8 *b64, pg_md5_ctx *ctx) { uint32\t\tA = ctx->md5_sta; uint32\t\tB = ctx->md5_stb; uint32\t\tC = ctx->md5_stc; uint32\t\tD = ctx->md5_std; #ifndef WORDS_BIGENDIAN const uint32 *...","count":12},{"name":"api-example","value":"static void pgstat_write_statsfile(void) { FILE\t   *fpout; int32\t\tformat_id; const char *tmpfile = PGSTAT_STAT_PERMANENT_TMPFILE; const char *statfile = PGSTAT_STAT_PERMANENT_FILENAME; dshash_seq_stat...","count":12},{"name":"api-example","value":"static void postquel_sub_params(SQLFunctionCachePtr fcache, FunctionCallInfo fcinfo) { int\t\t\tnargs = fcinfo->nargs; if (nargs > 0) { ParamListInfo paramLI; Oid\t\t   *argtypes = fcache->pinfo->argtypes;...","count":12},{"name":"api-example","value":"static void process_pm_child_exit(void) { int\t\t\tpid;\t\t\t/* process id of dead child process */ int\t\t\texitstatus;\t\t/* its exit status */ pending_pm_child_exit = false; ereport(DEBUG4, (errmsg_internal(\"...","count":12},{"name":"api-example","value":"static void publication_translate_columns(Relation targetrel, List *columns, int *natts, AttrNumber **attrs) { AttrNumber *attarray = NULL; Bitmapset  *set = NULL; ListCell   *lc; int\t\t\tn = 0; TupleDe...","count":12},{"name":"api-example","value":"static void rbt_insert_fixup(RBTree *rbt, RBTNode *x) { * x is always a red node.  Initially, it is the newly inserted node. Each * iteration of this loop moves it higher up in the tree. */ while (x !...","count":12},{"name":"api-example","value":"static void readRecoverySignalFile(void) { struct stat stat_buf; if (IsBootstrapProcessingMode()) return; * Check for old recovery API file: recovery.conf */ if (stat(RECOVERY_COMMAND_FILE, &stat_buf)...","count":12},{"name":"api-example","value":"static void select_perl_context(bool trusted) { Oid\t\t\tuser_id; plperl_interp_desc *interp_desc; bool\t\tfound; PerlInterpreter *interp = NULL; if (trusted) user_id = GetUserId(); else user_id = InvalidO...","count":12},{"name":"api-example","value":"static void set_subquery_pathlist(PlannerInfo *root, RelOptInfo *rel, Index rti, RangeTblEntry *rte) { Query\t   *parse = root->parse; Query\t   *subquery = rte->subquery; bool\t\ttrivial_pathtarget; Reli...","count":12},{"name":"api-example","value":"static void show_buffer_usage(ExplainState *es, const BufferUsage *usage) { if (es->format == EXPLAIN_FORMAT_TEXT) { bool\t\thas_shared = (usage->shared_blks_hit > 0 || usage->shared_blks_read > 0 || us...","count":12},{"name":"api-example","value":"static void subcolorcvec(struct vars *v, struct cvec *cv, struct state *lp, struct state *rp) { struct colormap *cm = v->cm; color\t\tlastsubcolor = COLORLESS; chr\t\t\tch, from, to; const chr  *p; int\t\t\ti...","count":12},{"name":"api-example","value":"static void substitute_phv_relids(Node *node, int varno, Relids subrelids) { substitute_phv_relids_context context; context.varno = varno; context.sublevels_up = 0; context.subrelids = subrelids; * Mu...","count":12},{"name":"api-example","value":"static void write_eventlog(int level, const char *line, int len) { WCHAR\t   *utf16; int\t\t\teventlevel = EVENTLOG_ERROR_TYPE; static HANDLE evtHandle = INVALID_HANDLE_VALUE; if (evtHandle == INVALID_HAN...","count":12},{"name":"api-example","value":"struct connection * ecpg_get_connection(const char *connection_name) { struct connection *ret = NULL; if ((connection_name == NULL) || (strcmp(connection_name, \"CURRENT\") == 0)) { ecpg_pthreads_init()...","count":12},{"name":"api-example","value":"struct varlena * detoast_attr_slice(struct varlena *attr, int32 sliceoffset, int32 slicelength) { struct varlena *preslice; struct varlena *result; char\t   *attrdata; int32\t\tslicelimit; int32\t\tattrsiz...","count":12},{"name":"api-example","value":"void * dshash_find(dshash_table *hash_table, const void *key, bool exclusive) { dshash_hash hash; size_t\t\tpartition; dshash_table_item *item; hash = hash_key(hash_table, key); partition = PARTITION_FO...","count":12},{"name":"api-example","value":"void CheckAttributeType(const char *attname, Oid atttypid, Oid attcollation, List *containing_rowtypes, int flags) { char\t\tatt_typtype = get_typtype(atttypid); Oid\t\t\tatt_typelem; check_stack_depth(); ...","count":12},{"name":"api-example","value":"void CommitTsShmemInit(void) { bool\t\tfound; if (commit_timestamp_buffers == 0) { char\t\tbuf[32]; snprintf(buf, sizeof(buf), \"%d\", CommitTsShmemBuffers()); SetConfigOption(\"commit_timestamp_buffers\", bu...","count":12},{"name":"api-example","value":"void CreateCheckPoint(int flags) { bool\t\tshutdown; CheckPoint\tcheckPoint; XLogRecPtr\trecptr; XLogSegNo\t_logSegNo; XLogCtlInsert *Insert = &XLogCtl->Insert; uint32\t\tfreespace; XLogRecPtr\tPriorRedoPtr; ...","count":12},{"name":"api-example","value":"void ExecEvalSQLValueFunction(ExprState *state, ExprEvalStep *op) { LOCAL_FCINFO(fcinfo, 0); SQLValueFunction *svf = op->d.sqlvaluefunction.svf; *op->resnull = false; * Note: current_schema() can retu...","count":12},{"name":"api-example","value":"void ExplainPropertyList(const char *qlabel, List *data, ExplainState *es) { ListCell   *lc; bool\t\tfirst = true; switch (es->format) { case EXPLAIN_FORMAT_TEXT: ExplainIndentText(es); appendStringInfo...","count":12},{"name":"api-example","value":"void FreePageManagerInitialize(FreePageManager *fpm, char *base) { Size\t\tf; relptr_store(base, fpm->self, fpm); relptr_store(base, fpm->btree_root, (FreePageBtree *) NULL); relptr_store(base, fpm->btr...","count":12},{"name":"api-example","value":"void InitWalRecovery(ControlFileData *ControlFile, bool *wasShutdown_ptr, bool *haveBackupLabel_ptr, bool *haveTblspcMap_ptr) { XLogPageReadPrivate *private; struct stat st; bool\t\twasShutdown; XLogRec...","count":12},{"name":"api-example","value":"void PersistHoldablePortal(Portal portal) { QueryDesc  *queryDesc = portal->queryDesc; Portal\t\tsaveActivePortal; ResourceOwner saveResourceOwner; MemoryContext savePortalContext; MemoryContext oldcxt;...","count":12},{"name":"api-example","value":"void PrepareForIncrementalBackup(IncrementalBackupInfo *ib, BackupState *backup_state) { MemoryContext oldcontext; List\t   *expectedTLEs; List\t   *all_wslist, *required_wslist = NIL; ListCell   *lc; T...","count":12},{"name":"api-example","value":"void ProcArrayApplyRecoveryInfo(RunningTransactions running) { TransactionId *xids; TransactionId advanceNextXid; int\t\t\tnxids; int\t\t\ti; Assert(standbyState >= STANDBY_INITIALIZED); Assert(TransactionI...","count":12},{"name":"api-example","value":"void StopGeneratingPinnedObjectIds(void) { SetNextObjectId(FirstUnpinnedObjectId); }","count":12},{"name":"api-example","value":"void SyncRepReleaseWaiters(void) { volatile WalSndCtlData *walsndctl = WalSndCtl; XLogRecPtr\twritePtr; XLogRecPtr\tflushPtr; XLogRecPtr\tapplyPtr; bool\t\tgot_recptr; bool\t\tam_sync; int\t\t\tnumwrite = 0; in...","count":12},{"name":"api-example","value":"void TransactionIdSetTreeStatus(TransactionId xid, int nsubxids, TransactionId *subxids, XidStatus status, XLogRecPtr lsn) { int64\t\tpageno = TransactionIdToPage(xid);\t/* get page of parent */ int\t\t\ti;...","count":12},{"name":"api-example","value":"void TwoPhaseShmemInit(void) { bool\t\tfound; TwoPhaseState = ShmemInitStruct(\"Prepared Transaction Table\", TwoPhaseShmemSize(), &found); if (!IsUnderPostmaster) { GlobalTransaction gxacts; int\t\t\ti; Ass...","count":12},{"name":"api-example","value":"void WaitReadBuffers(ReadBuffersOperation *operation) { Buffer\t   *buffers; int\t\t\tnblocks; BlockNumber blocknum; ForkNumber\tforknum; IOContext\tio_context; IOObject\tio_object; char\t\tpersistence; * Curr...","count":12},{"name":"api-example","value":"void _bt_dedup_start_pending(BTDedupState state, IndexTuple base, OffsetNumber baseoff) { Assert(state->nhtids == 0); Assert(state->nitems == 0); Assert(!BTreeTupleIsPivot(base)); * Copy heap TID(s) f...","count":12},{"name":"api-example","value":"void _bt_unlockbuf(Relation rel, Buffer buf) { * Buffer is pinned and locked, which means that it is expected to be * defined and addressable.  Check that proactively. */ VALGRIND_CHECK_MEM_IS_DEFINED...","count":12},{"name":"api-example","value":"void brininsertcleanup(Relation index, IndexInfo *indexInfo) { BrinInsertState *bistate = (BrinInsertState *) indexInfo->ii_AmCache; if (bistate == NULL) return; indexInfo->ii_AmCache = NULL; * Clean ...","count":12},{"name":"api-example","value":"void check_object_ownership(Oid roleid, ObjectType objtype, ObjectAddress address, Node *object, Relation relation) { switch (objtype) { case OBJECT_INDEX: case OBJECT_SEQUENCE: case OBJECT_TABLE: cas...","count":12},{"name":"api-example","value":"void expanded_record_set_tuple(ExpandedRecordHeader *erh, HeapTuple tuple, bool copy, bool expand_external) { int\t\t\toldflags; HeapTuple\toldtuple; char\t   *oldfstartptr; char\t   *oldfendptr; int\t\t\tnewf...","count":12},{"name":"api-example","value":"void generic_desc(StringInfo buf, XLogReaderState *record) { Pointer\t\tptr = XLogRecGetData(record), end = ptr + XLogRecGetDataLen(record); while (ptr < end) { OffsetNumber offset, length; memcpy(&offs...","count":12},{"name":"api-example","value":"void ginVacuumPostingTreeLeaf(Relation indexrel, Buffer buffer, GinVacuumState *gvs) { Page\t\tpage = BufferGetPage(buffer); disassembledLeaf *leaf; bool\t\tremovedsomething = false; dlist_iter\titer; leaf...","count":12},{"name":"api-example","value":"void heap_get_latest_tid(TableScanDesc sscan, ItemPointer tid) { Relation\trelation = sscan->rs_rd; Snapshot\tsnapshot = sscan->rs_snapshot; ItemPointerData ctid; TransactionId priorXmax; * table_tuple_...","count":12},{"name":"api-example","value":"void heap_page_prune_execute(Buffer buffer, bool lp_truncate_only, OffsetNumber *redirected, int nredirected, OffsetNumber *nowdead, int ndead, OffsetNumber *nowunused, int nunused) { Page\t\tpage = (Pa...","count":12},{"name":"api-example","value":"void j2date(int jd, int *year, int *month, int *day) { unsigned int julian; unsigned int quad; unsigned int extra; int\t\t\ty; julian = jd; julian += 32044; quad = julian / 146097; extra = (julian - quad...","count":12},{"name":"api-example","value":"void pgwin32_signal_initialize(void) { int\t\t\ti; HANDLE\t\tsignal_thread_handle; InitializeCriticalSection(&pg_signal_crit_sec); for (i = 0; i < PG_SIGNAL_COUNT; i++) { pg_signal_array[i].sa_handler = SI...","count":12},{"name":"api-example","value":"void preprocess_minmax_aggregates(PlannerInfo *root) { Query\t   *parse = root->parse; FromExpr   *jtnode; RangeTblRef *rtr; RangeTblEntry *rte; List\t   *aggs_list; RelOptInfo *grouped_rel; ListCell   ...","count":12},{"name":"api-example","value":"void record_plan_function_dependency(PlannerInfo *root, Oid funcid) { * For performance reasons, we don't bother to track built-in functions; * we just assume they'll never change (or at least not in ...","count":12},{"name":"api-example","value":"void toast_delete_datum(Relation rel, Datum value, bool is_speculative) { struct varlena *attr = (struct varlena *) DatumGetPointer(value); struct varatt_external toast_pointer; Relation\ttoastrel; Rel...","count":12},{"name":"api-typical-usage","value":"Often called from: ATExecSetStatistics","count":12},{"name":"api-typical-usage","value":"Often called from: ATExecSetTableSpace","count":12},{"name":"api-typical-usage","value":"Often called from: AdjustIntervalForTypmod","count":12},{"name":"api-typical-usage","value":"Often called from: AllocSetDelete","count":12},{"name":"api-typical-usage","value":"Often called from: AllocateFile","count":12},{"name":"api-typical-usage","value":"Often called from: AlterDatabaseOwner","count":12},{"name":"api-typical-usage","value":"Often called from: AlterSequence","count":12},{"name":"api-typical-usage","value":"Often called from: AlterTableMoveAll","count":12},{"name":"api-typical-usage","value":"Often called from: AtEOXact_GUC","count":12},{"name":"api-typical-usage","value":"Often called from: BufFileDumpBuffer","count":12},{"name":"api-typical-usage","value":"Often called from: CLOGShmemInit","count":12},{"name":"api-typical-usage","value":"Often called from: CheckConditional","count":12},{"name":"api-typical-usage","value":"Often called from: CollationCreate","count":12},{"name":"api-typical-usage","value":"Often called from: CopyAttributeOutText","count":12},{"name":"api-typical-usage","value":"Often called from: CreateForeignTable","count":12},{"name":"api-typical-usage","value":"Often called from: CreateInitDecodingContext","count":12},{"name":"api-typical-usage","value":"Often called from: CreateRestrictedProcess","count":12},{"name":"api-typical-usage","value":"Often called from: CreateTransform","count":12},{"name":"api-typical-usage","value":"Often called from: DefineSequence","count":12},{"name":"api-typical-usage","value":"Often called from: DropRelationAllLocalBuffers","count":12},{"name":"api-typical-usage","value":"Often called from: ECPGconnect","count":12},{"name":"api-typical-usage","value":"Often called from: ECPGget_sqlca","count":12},{"name":"api-typical-usage","value":"Often called from: EOH_init_header","count":12},{"name":"api-typical-usage","value":"Often called from: ExecBSDeleteTriggers","count":12},{"name":"api-typical-usage","value":"Often called from: ExecConstraints","count":12},{"name":"api-typical-usage","value":"Often called from: ExecEvalArrayExpr","count":12},{"name":"api-typical-usage","value":"Often called from: ExecGrant_common","count":12},{"name":"api-typical-usage","value":"Often called from: ExecGroup","count":12},{"name":"api-typical-usage","value":"Often called from: ExecHashRemoveNextSkewBucket","count":12},{"name":"api-typical-usage","value":"Often called from: ExecInitSubqueryScan","count":12},{"name":"api-typical-usage","value":"Often called from: ExecInsert","count":12},{"name":"api-typical-usage","value":"Often called from: ExecParallelRetrieveInstrumentation","count":12},{"name":"api-typical-usage","value":"Often called from: ExecuteGrantStmt","count":12},{"name":"api-typical-usage","value":"Often called from: ExecuteQuery","count":12},{"name":"api-typical-usage","value":"Often called from: ExplainPropertyList","count":12},{"name":"api-typical-usage","value":"Often called from: ExtendBufferedRelLocal","count":12},{"name":"api-typical-usage","value":"Often called from: FileSize","count":12},{"name":"api-typical-usage","value":"Often called from: FlushRelationBuffers","count":12},{"name":"api-typical-usage","value":"Often called from: FreeErrorDataContents","count":12},{"name":"api-typical-usage","value":"Often called from: GXactLoadSubxactData","count":12},{"name":"api-typical-usage","value":"Often called from: GetAggInitVal","count":12},{"name":"api-typical-usage","value":"Often called from: GetLocalVictimBuffer","count":12},{"name":"api-typical-usage","value":"Often called from: IN6_IS_ADDR_MC_SITELOCAL","count":12},{"name":"api-typical-usage","value":"Often called from: InitBufTable","count":12},{"name":"api-typical-usage","value":"Often called from: IsBinaryTidClause","count":12},{"name":"api-typical-usage","value":"Often called from: JsonbIteratorNext","count":12},{"name":"api-typical-usage","value":"Often called from: KnownAssignedXidsAdd","count":12},{"name":"api-typical-usage","value":"Often called from: LockBufferForCleanup","count":12},{"name":"api-typical-usage","value":"Often called from: LogStandbyInvalidations","count":12},{"name":"api-typical-usage","value":"Often called from: MatchText","count":12},{"name":"api-typical-usage","value":"Often called from: MergeInheritedAttribute","count":12},{"name":"api-typical-usage","value":"Often called from: NIAddAffix","count":12},{"name":"api-typical-usage","value":"Often called from: NUM_processor","count":12},{"name":"api-typical-usage","value":"Often called from: OnConflict_CheckForSerializationFailure","count":12},{"name":"api-typical-usage","value":"Often called from: PLySequence_ToArray_recurse","count":12},{"name":"api-typical-usage","value":"Often called from: PLy_init_interp","count":12},{"name":"api-typical-usage","value":"Often called from: PQgetResult","count":12},{"name":"api-typical-usage","value":"Often called from: PQsendDescribePrepared","count":12},{"name":"api-typical-usage","value":"Often called from: PQsetvalue","count":12},{"name":"api-typical-usage","value":"Often called from: PageAddItemExtended","count":12},{"name":"api-typical-usage","value":"Often called from: PageIndexTupleDeleteNoCompact","count":12},{"name":"api-typical-usage","value":"Often called from: ParseFuncOrColumn","count":12},{"name":"api-typical-usage","value":"Often called from: PathNameCreateTemporaryDir","count":12},{"name":"api-typical-usage","value":"Often called from: PostmasterStateMachine","count":12},{"name":"api-typical-usage","value":"Often called from: PrepareInvalidationState","count":12},{"name":"api-typical-usage","value":"Often called from: ProcArrayGroupClearXid","count":12},{"name":"api-typical-usage","value":"Often called from: RecordNewMultiXact","count":12},{"name":"api-typical-usage","value":"Often called from: ReindexTable","count":12},{"name":"api-typical-usage","value":"Often called from: RelationClearRelation","count":12},{"name":"api-typical-usage","value":"Often called from: RelationGetIndexAttrBitmap","count":12},{"name":"api-typical-usage","value":"Often called from: RelationInitIndexAccessInfo","count":12},{"name":"api-typical-usage","value":"Often called from: RelationSetNewRelfilenumber","count":12},{"name":"api-typical-usage","value":"Often called from: RemoveAttributeById","count":12},{"name":"api-typical-usage","value":"Often called from: RemovePgTempFilesInDir","count":12},{"name":"api-typical-usage","value":"Often called from: SPI_execute_extended","count":12},{"name":"api-typical-usage","value":"Often called from: SelectConfigFiles","count":12},{"name":"api-typical-usage","value":"Often called from: SendTablespaceList","count":12},{"name":"api-typical-usage","value":"Often called from: SnapBuildCommitTxn","count":12},{"name":"api-typical-usage","value":"Often called from: SnapBuildProcessNewCid","count":12},{"name":"api-typical-usage","value":"Often called from: SplitToVariants","count":12},{"name":"api-typical-usage","value":"Often called from: StatsShmemInit","count":12},{"name":"api-typical-usage","value":"Often called from: StrategyGetBuffer","count":12},{"name":"api-typical-usage","value":"Often called from: StreamLogicalLog","count":12},{"name":"api-typical-usage","value":"Often called from: SyncRepReleaseWaiters","count":12},{"name":"api-typical-usage","value":"Often called from: TranslateSocketError","count":12},{"name":"api-typical-usage","value":"Often called from: TrimCLOG","count":12},{"name":"api-typical-usage","value":"Often called from: TupleDescCopyEntry","count":12},{"name":"api-typical-usage","value":"Often called from: XLogBytePosToRecPtr","count":12},{"name":"api-typical-usage","value":"Often called from: XLogPutNextOid","count":12},{"name":"api-typical-usage","value":"Often called from: XLogRestorePoint","count":12},{"name":"api-typical-usage","value":"Often called from: _LoadLOs","count":12},{"name":"api-typical-usage","value":"Often called from: _brin_parallel_merge","count":12},{"name":"api-typical-usage","value":"Often called from: _equalList","count":12},{"name":"api-typical-usage","value":"Often called from: _hash_addovflpage","count":12},{"name":"api-typical-usage","value":"Often called from: _hash_getnewbuf","count":12},{"name":"api-typical-usage","value":"Often called from: _hash_squeezebucket","count":12},{"name":"api-typical-usage","value":"Often called from: array_insert_slice","count":12},{"name":"api-typical-usage","value":"Often called from: bitposition","count":12},{"name":"api-typical-usage","value":"Often called from: box_closept_point","count":12},{"name":"api-typical-usage","value":"Often called from: box_div","count":12},{"name":"api-typical-usage","value":"Often called from: box_interpt_lseg","count":12},{"name":"api-typical-usage","value":"Often called from: brin_getinsertbuffer","count":12},{"name":"api-typical-usage","value":"Often called from: btree_xlog_unlink_page","count":12},{"name":"api-typical-usage","value":"Often called from: buffers_to_iovec","count":12},{"name":"api-typical-usage","value":"Often called from: build_backup_content","count":12},{"name":"api-typical-usage","value":"Often called from: byteain","count":12},{"name":"api-typical-usage","value":"Often called from: calculate_relation_size","count":12},{"name":"api-typical-usage","value":"Often called from: cash_in","count":12},{"name":"api-typical-usage","value":"Often called from: cbrdissect","count":12},{"name":"api-typical-usage","value":"Often called from: cclasscvec","count":12},{"name":"api-typical-usage","value":"Often called from: checkFkeyPermissions","count":12},{"name":"api-typical-usage","value":"Often called from: check_encoding_conversion_args","count":12},{"name":"api-typical-usage","value":"Often called from: check_encoding_locale_matches","count":12},{"name":"api-typical-usage","value":"Often called from: check_safe_enum_use","count":12},{"name":"api-typical-usage","value":"Often called from: circle_below","count":12},{"name":"api-typical-usage","value":"Often called from: cleanOpStack","count":12},{"name":"api-typical-usage","value":"Often called from: close_ls","count":12},{"name":"api-typical-usage","value":"Often called from: close_lseg","count":12},{"name":"api-typical-usage","value":"Often called from: coerce_type","count":12},{"name":"api-typical-usage","value":"Often called from: collectMatchBitmap","count":12},{"name":"api-typical-usage","value":"Often called from: comparetup_heap_tiebreak","count":12},{"name":"api-typical-usage","value":"Often called from: compile_plperl_function","count":12},{"name":"api-typical-usage","value":"Often called from: computeDistance","count":12},{"name":"api-typical-usage","value":"Often called from: compute_range_stats","count":12},{"name":"api-typical-usage","value":"Often called from: conv_18030_to_utf8","count":12},{"name":"api-typical-usage","value":"Often called from: cost_tuplesort","count":12},{"name":"api-typical-usage","value":"Often called from: create_partitionwise_grouping_paths","count":12},{"name":"api-typical-usage","value":"Often called from: create_script_for_old_cluster_deletion","count":12},{"name":"api-typical-usage","value":"Often called from: d2d","count":12},{"name":"api-typical-usage","value":"Often called from: dataFindChildPtr","count":12},{"name":"api-typical-usage","value":"Often called from: dataPlaceToPageLeafSplit","count":12},{"name":"api-typical-usage","value":"Often called from: database_to_xml_internal","count":12},{"name":"api-typical-usage","value":"Often called from: datum_to_json_internal","count":12},{"name":"api-typical-usage","value":"Often called from: defGetStreamingMode","count":12},{"name":"api-typical-usage","value":"Often called from: describePublications","count":12},{"name":"api-typical-usage","value":"Often called from: dolink","count":12},{"name":"api-typical-usage","value":"Often called from: dshash_find_or_insert","count":12},{"name":"api-typical-usage","value":"Often called from: dumpConstraint","count":12},{"name":"api-typical-usage","value":"Often called from: dumptuples","count":12},{"name":"api-typical-usage","value":"Often called from: evalLazyFunc","count":12},{"name":"api-typical-usage","value":"Often called from: eval_windowaggregates","count":12},{"name":"api-typical-usage","value":"Often called from: examine_attribute","count":12},{"name":"api-typical-usage","value":"Often called from: exec_describe_portal_message","count":12},{"name":"api-typical-usage","value":"Often called from: exec_prog","count":12},{"name":"api-typical-usage","value":"Often called from: exec_run_select","count":12},{"name":"api-typical-usage","value":"Often called from: exec_stmt_fori","count":12},{"name":"api-typical-usage","value":"Often called from: exec_stmt_open","count":12},{"name":"api-typical-usage","value":"Often called from: executeBinaryArithmExpr","count":12},{"name":"api-typical-usage","value":"Often called from: executeBoolItem","count":12},{"name":"api-typical-usage","value":"Often called from: fill_hba_line","count":12},{"name":"api-typical-usage","value":"Often called from: fill_hba_view","count":12},{"name":"api-typical-usage","value":"Often called from: filter_read_item","count":12},{"name":"api-typical-usage","value":"Often called from: findDependentObjects","count":12},{"name":"api-typical-usage","value":"Often called from: find_computable_ec_member","count":12},{"name":"api-typical-usage","value":"Often called from: find_param_referent","count":12},{"name":"api-typical-usage","value":"Often called from: flagInhTables","count":12},{"name":"api-typical-usage","value":"Often called from: fsm_vacuum_page","count":12},{"name":"api-typical-usage","value":"Often called from: generateClonedIndexStmt","count":12},{"name":"api-typical-usage","value":"Often called from: getKeyJsonValueFromContainer","count":12},{"name":"api-typical-usage","value":"Often called from: getOperators","count":12},{"name":"api-typical-usage","value":"Often called from: get_op_hash_functions","count":12},{"name":"api-typical-usage","value":"Often called from: get_perl_array_ref","count":12},{"name":"api-typical-usage","value":"Often called from: get_rel_sync_entry","count":12},{"name":"api-typical-usage","value":"Often called from: ginEntryInsert","count":12},{"name":"api-typical-usage","value":"Often called from: ginFindLeafPage","count":12},{"name":"api-typical-usage","value":"Often called from: gin_consistent_jsonb","count":12},{"name":"api-typical-usage","value":"Often called from: grouping_planner","count":12},{"name":"api-typical-usage","value":"Often called from: has_function_privilege_name_id","count":12},{"name":"api-typical-usage","value":"Often called from: hash_numeric_extended","count":12},{"name":"api-typical-usage","value":"Often called from: heap2_identify","count":12},{"name":"api-typical-usage","value":"Often called from: heap_fetch_toast_slice","count":12},{"name":"api-typical-usage","value":"Often called from: heap_xlog_update","count":12},{"name":"api-typical-usage","value":"Often called from: heapam_relation_copy_for_cluster","count":12},{"name":"api-typical-usage","value":"Often called from: hemdistcache","count":12},{"name":"api-typical-usage","value":"Often called from: in_range_numeric_numeric","count":12},{"name":"api-typical-usage","value":"Often called from: initialize_SSL","count":12},{"name":"api-typical-usage","value":"Often called from: int4range_canonical","count":12},{"name":"api-typical-usage","value":"Often called from: interval_justify_interval","count":12},{"name":"api-typical-usage","value":"Often called from: interval_part_common","count":12},{"name":"api-typical-usage","value":"Often called from: inv_write","count":12},{"name":"api-typical-usage","value":"Often called from: is_xlogfilename","count":12},{"name":"api-typical-usage","value":"Often called from: join_is_legal","count":12},{"name":"api-typical-usage","value":"Often called from: json_array_length","count":12},{"name":"api-typical-usage","value":"Often called from: jsonb_get_element","count":12},{"name":"api-typical-usage","value":"Often called from: jsonb_hash_extended","count":12},{"name":"api-typical-usage","value":"Often called from: jsonb_set","count":12},{"name":"api-typical-usage","value":"Often called from: libpqrcv_endstreaming","count":12},{"name":"api-typical-usage","value":"Often called from: line_decode","count":12},{"name":"api-typical-usage","value":"Often called from: list_union_ptr","count":12},{"name":"api-typical-usage","value":"Often called from: llvm_create_types","count":12},{"name":"api-typical-usage","value":"Often called from: load_relcache_init_file","count":12},{"name":"api-typical-usage","value":"Often called from: log_heap_new_cid","count":12},{"name":"api-typical-usage","value":"Often called from: log_heap_visible","count":12},{"name":"api-typical-usage","value":"Often called from: make_expanded_record_from_exprecord","count":12},{"name":"api-typical-usage","value":"Often called from: make_new_segment","count":12},{"name":"api-typical-usage","value":"Often called from: make_sort_input_target","count":12},{"name":"api-typical-usage","value":"Often called from: mark_hl_words","count":12},{"name":"api-typical-usage","value":"Often called from: matchuntil","count":12},{"name":"api-typical-usage","value":"Often called from: maybe_reread_subscription","count":12},{"name":"api-typical-usage","value":"Often called from: mdcreate","count":12},{"name":"api-typical-usage","value":"Often called from: mdreadv","count":12},{"name":"api-typical-usage","value":"Often called from: mdtruncate","count":12},{"name":"api-typical-usage","value":"Often called from: numeric_support","count":12},{"name":"api-typical-usage","value":"Often called from: palloc0","count":12},{"name":"api-typical-usage","value":"Often called from: parallel_vacuum_compute_workers","count":12},{"name":"api-typical-usage","value":"Often called from: parse_phrase_operator","count":12},{"name":"api-typical-usage","value":"Often called from: parse_scalar","count":12},{"name":"api-typical-usage","value":"Often called from: parse_scram_secret","count":12},{"name":"api-typical-usage","value":"Often called from: pg_regcomp","count":12},{"name":"api-typical-usage","value":"Often called from: pg_replication_origin_progress","count":12},{"name":"api-typical-usage","value":"Often called from: pg_replication_slot_advance","count":12},{"name":"api-typical-usage","value":"Often called from: pgarch_readyXlog","count":12},{"name":"api-typical-usage","value":"Often called from: pgstat_drop_database_and_contents","count":12},{"name":"api-typical-usage","value":"Often called from: pgstat_read_statsfile","count":12},{"name":"api-typical-usage","value":"Often called from: pgwin32_ServiceMain","count":12},{"name":"api-typical-usage","value":"Often called from: pgwin32_waitforsinglesocket","count":12},{"name":"api-typical-usage","value":"Often called from: plperl_create_sub","count":12},{"name":"api-typical-usage","value":"Often called from: plperl_ref_from_pg_array","count":12},{"name":"api-typical-usage","value":"Often called from: plperl_trusted_init","count":12},{"name":"api-typical-usage","value":"Often called from: plpgsql_exec_trigger","count":12},{"name":"api-typical-usage","value":"Often called from: plpgsql_fulfill_promise","count":12},{"name":"api-typical-usage","value":"Often called from: plpgsql_yylex","count":12},{"name":"api-typical-usage","value":"Often called from: pltcl_construct_errorCode","count":12},{"name":"api-typical-usage","value":"Often called from: point_horiz","count":12},{"name":"api-typical-usage","value":"Often called from: pqTraceOutputInt16","count":12},{"name":"api-typical-usage","value":"Often called from: pq_init","count":12},{"name":"api-typical-usage","value":"Often called from: pqinitmask","count":12},{"name":"api-typical-usage","value":"Often called from: print_lo_result","count":12},{"name":"api-typical-usage","value":"Often called from: process_psqlrc_file","count":12},{"name":"api-typical-usage","value":"Often called from: process_queued_fetch_requests","count":12},{"name":"api-typical-usage","value":"Often called from: range_gist_consistent_int_multirange","count":12},{"name":"api-typical-usage","value":"Often called from: read_client_first_message","count":12},{"name":"api-typical-usage","value":"Often called from: regexp_substr","count":12},{"name":"api-typical-usage","value":"Often called from: remove_useless_results_recurse","count":12},{"name":"api-typical-usage","value":"Often called from: repeat","count":12},{"name":"api-typical-usage","value":"Often called from: rewriteRuleAction","count":12},{"name":"api-typical-usage","value":"Often called from: ri_AttributesEqual","count":12},{"name":"api-typical-usage","value":"Often called from: rulesub","count":12},{"name":"api-typical-usage","value":"Often called from: sendFile","count":12},{"name":"api-typical-usage","value":"Often called from: send_message_to_server_log","count":12},{"name":"api-typical-usage","value":"Often called from: seq_redo","count":12},{"name":"api-typical-usage","value":"Often called from: set_descriptors","count":12},{"name":"api-typical-usage","value":"Often called from: set_rel_width","count":12},{"name":"api-typical-usage","value":"Often called from: setup_locale_encoding","count":12},{"name":"api-typical-usage","value":"Often called from: setup_schema","count":12},{"name":"api-typical-usage","value":"Often called from: sha1_step","count":12},{"name":"api-typical-usage","value":"Often called from: show_memoize_info","count":12},{"name":"api-typical-usage","value":"Often called from: slashUsage","count":12},{"name":"api-typical-usage","value":"Often called from: slist_is_empty","count":12},{"name":"api-typical-usage","value":"Often called from: smgr_redo","count":12},{"name":"api-typical-usage","value":"Often called from: spgRedoVacuumLeaf","count":12},{"name":"api-typical-usage","value":"Often called from: standby_redo","count":12},{"name":"api-typical-usage","value":"Often called from: startup_hacks","count":12},{"name":"api-typical-usage","value":"Often called from: str_toupper","count":12},{"name":"api-typical-usage","value":"Often called from: suppress_redundant_updates_trigger","count":12},{"name":"api-typical-usage","value":"Often called from: tarCreateHeader","count":12},{"name":"api-typical-usage","value":"Often called from: test_sync","count":12},{"name":"api-typical-usage","value":"Often called from: text_starts_with","count":12},{"name":"api-typical-usage","value":"Often called from: timestamp_ge","count":12},{"name":"api-typical-usage","value":"Often called from: timestamptz_in","count":12},{"name":"api-typical-usage","value":"Often called from: timetz_lt","count":12},{"name":"api-typical-usage","value":"Often called from: toast_fetch_datum_slice","count":12},{"name":"api-typical-usage","value":"Often called from: toast_raw_datum_size","count":12},{"name":"api-typical-usage","value":"Often called from: transformUpdateStmt","count":12},{"name":"api-typical-usage","value":"Often called from: ts_headline_json_byid_opt","count":12},{"name":"api-typical-usage","value":"Often called from: tsquery_cmp","count":12},{"name":"api-typical-usage","value":"Often called from: tsquery_rewrite_query","count":12},{"name":"api-typical-usage","value":"Often called from: uuid_recv","count":12},{"name":"api-typical-usage","value":"Often called from: validate_index","count":12},{"name":"api-typical-usage","value":"Often called from: varstr_sortsupport","count":12},{"name":"api-typical-usage","value":"Often called from: window_cume_dist","count":12},{"name":"api-typical-usage","value":"Often called from: write_relcache_init_file","count":12},{"name":"coupling-score","value":"45","count":12},{"name":"coupling-score","value":"48","count":12},{"name":"coupling-score","value":"51","count":12},{"name":"coupling-score","value":"54","count":12},{"name":"coupling-score","value":"56","count":12},{"name":"coupling-score","value":"57","count":12},{"name":"coupling-score","value":"58","count":12},{"name":"coupling-score","value":"68","count":12},{"name":"coupling-score","value":"73","count":12},{"name":"cyclomatic-complexity","value":"102","count":12},{"name":"cyclomatic-complexity","value":"108","count":12},{"name":"cyclomatic-complexity","value":"114","count":12},{"name":"cyclomatic-complexity","value":"123","count":12},{"name":"cyclomatic-complexity","value":"126","count":12},{"name":"cyclomatic-complexity","value":"140","count":12},{"name":"cyclomatic-complexity","value":"147","count":12},{"name":"cyclomatic-complexity","value":"150","count":12},{"name":"cyclomatic-complexity","value":"153","count":12},{"name":"cyclomatic-complexity","value":"159","count":12},{"name":"cyclomatic-complexity","value":"163","count":12},{"name":"cyclomatic-complexity","value":"164","count":12},{"name":"cyclomatic-complexity","value":"167","count":12},{"name":"cyclomatic-complexity","value":"176","count":12},{"name":"cyclomatic-complexity","value":"178","count":12},{"name":"cyclomatic-complexity","value":"190","count":12},{"name":"cyclomatic-complexity","value":"197","count":12},{"name":"cyclomatic-complexity","value":"204","count":12},{"name":"cyclomatic-complexity","value":"211","count":12},{"name":"cyclomatic-complexity","value":"214","count":12},{"name":"cyclomatic-complexity","value":"229","count":12},{"name":"cyclomatic-complexity","value":"237","count":12},{"name":"cyclomatic-complexity","value":"240","count":12},{"name":"cyclomatic-complexity","value":"244","count":12},{"name":"cyclomatic-complexity","value":"249","count":12},{"name":"cyclomatic-complexity","value":"257","count":12},{"name":"cyclomatic-complexity","value":"270","count":12},{"name":"cyclomatic-complexity","value":"275","count":12},{"name":"cyclomatic-complexity","value":"281","count":12},{"name":"cyclomatic-complexity","value":"282","count":12},{"name":"cyclomatic-complexity","value":"290","count":12},{"name":"cyclomatic-complexity","value":"336","count":12},{"name":"cyclomatic-complexity","value":"482","count":12},{"name":"cyclomatic-complexity","value":"90","count":12},{"name":"extension-point","value":"callback","count":12},{"name":"lines-of-code","value":"1058","count":12},{"name":"lines-of-code","value":"1372","count":12},{"name":"lines-of-code","value":"1731","count":12},{"name":"lines-of-code","value":"2223","count":12},{"name":"lines-of-code","value":"225","count":12},{"name":"lines-of-code","value":"238","count":12},{"name":"lines-of-code","value":"251","count":12},{"name":"lines-of-code","value":"258","count":12},{"name":"lines-of-code","value":"260","count":12},{"name":"lines-of-code","value":"266","count":12},{"name":"lines-of-code","value":"279","count":12},{"name":"lines-of-code","value":"287","count":12},{"name":"lines-of-code","value":"290","count":12},{"name":"lines-of-code","value":"295","count":12},{"name":"lines-of-code","value":"296","count":12},{"name":"lines-of-code","value":"311","count":12},{"name":"lines-of-code","value":"316","count":12},{"name":"lines-of-code","value":"326","count":12},{"name":"lines-of-code","value":"339","count":12},{"name":"lines-of-code","value":"347","count":12},{"name":"lines-of-code","value":"350","count":12},{"name":"lines-of-code","value":"352","count":12},{"name":"lines-of-code","value":"355","count":12},{"name":"lines-of-code","value":"356","count":12},{"name":"lines-of-code","value":"362","count":12},{"name":"lines-of-code","value":"364","count":12},{"name":"lines-of-code","value":"368","count":12},{"name":"lines-of-code","value":"376","count":12},{"name":"lines-of-code","value":"382","count":12},{"name":"lines-of-code","value":"384","count":12},{"name":"lines-of-code","value":"391","count":12},{"name":"lines-of-code","value":"396","count":12},{"name":"lines-of-code","value":"401","count":12},{"name":"lines-of-code","value":"407","count":12},{"name":"lines-of-code","value":"410","count":12},{"name":"lines-of-code","value":"432","count":12},{"name":"lines-of-code","value":"433","count":12},{"name":"lines-of-code","value":"434","count":12},{"name":"lines-of-code","value":"439","count":12},{"name":"lines-of-code","value":"444","count":12},{"name":"lines-of-code","value":"451","count":12},{"name":"lines-of-code","value":"459","count":12},{"name":"lines-of-code","value":"465","count":12},{"name":"lines-of-code","value":"467","count":12},{"name":"lines-of-code","value":"473","count":12},{"name":"lines-of-code","value":"484","count":12},{"name":"lines-of-code","value":"488","count":12},{"name":"lines-of-code","value":"507","count":12},{"name":"lines-of-code","value":"519","count":12},{"name":"lines-of-code","value":"530","count":12},{"name":"lines-of-code","value":"543","count":12},{"name":"lines-of-code","value":"558","count":12},{"name":"lines-of-code","value":"564","count":12},{"name":"lines-of-code","value":"578","count":12},{"name":"lines-of-code","value":"579","count":12},{"name":"lines-of-code","value":"701","count":12},{"name":"lines-of-code","value":"731","count":12},{"name":"lines-of-code","value":"767","count":12},{"name":"loop-depth","value":"36","count":12},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, interfaces\\libpq\\fe-print.c, backend\\nodes\\readfuncs.c, backend\\lib\\dshash.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":12},{"name":"module-depends-on","value":"<unknown>, backend\\jit\\llvm\\postgres.h, backend\\utils\\fmgr\\fmgr.c","count":12},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c","count":12},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\mb\\mbutils.c, backend\\utils\\mb\\conv.c","count":12},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\mb\\mbutils.c, backend\\utils\\mb\\conv.c, interfaces\\libpq\\fe-exec.c","count":12},{"name":"module-depends-on","value":"<unknown>, common\\stringinfo.c","count":12},{"name":"module-depends-on","value":"<unknown>, common\\stringinfo.c, interfaces\\libpq\\fe-exec.c","count":12},{"name":"module-depends-on","value":"<unknown>, include\\utils\\varbit.h, backend\\utils\\fmgr\\fmgr.c, backend\\jit\\llvm\\postgres.h","count":12},{"name":"module-depends-on","value":"backend\\snowball\\libstemmer\\utilities.c, <unknown>, backend\\snowball\\libstemmer\\api.c","count":12},{"name":"module-depends-on","value":"bin\\pg_dump\\pg_backup_archiver.c, <unknown>, bin\\pg_dump\\pg_backup_utils.c","count":12},{"name":"test-count","value":"14","count":12},{"name":"test-count","value":"16","count":12},{"name":"test-count","value":"21","count":12},{"name":"test-count","value":"26","count":12},{"name":"tested-by","value":"RI_FKey_pk_upd_check_required, RI_FKey_fk_upd_check_required","count":12},{"name":"tested-by","value":"_bt_check_compare, _bt_check_rowcompare","count":12},{"name":"tested-by","value":"_bt_check_unique, _bt_check_unique, _bt_check_natts, _bt_check_third_page","count":12},{"name":"tested-by","value":"check_backup_label_files, test_open, test_sync, test_sync, test_file_descriptor_sync, test_file_descriptor_sync, test_file_descriptor_sync, test_file_descriptor_sync, test_non_sync, win32_check_direct","count":12},{"name":"tested-by","value":"check_circularity, check_circularity","count":12},{"name":"tested-by","value":"check_client_encoding","count":12},{"name":"tested-by","value":"check_client_encoding, check_locale_encoding, check_locale_encoding, check_icu_locale_encoding","count":12},{"name":"tested-by","value":"check_compressed_file","count":12},{"name":"tested-by","value":"check_datestyle, check_datestyle, check_datestyle, check_datestyle","count":12},{"name":"tested-by","value":"check_default_partition_contents, check_default_partition_contents","count":12},{"name":"tested-by","value":"check_default_text_search_config","count":12},{"name":"tested-by","value":"check_enable_rls","count":12},{"name":"tested-by","value":"check_encoding_conversion_args, check_encoding_conversion_args","count":12},{"name":"tested-by","value":"check_encoding_locale_matches, check_encoding_locale_matches, check_locale_encoding","count":12},{"name":"tested-by","value":"check_expected_areq, check_expected_areq, check_expected_areq","count":12},{"name":"tested-by","value":"check_for_data_types_usage","count":12},{"name":"tested-by","value":"check_for_data_types_usage, check_proper_datallowconn, check_for_isn_and_int8_passing_mismatch, check_for_user_defined_postfix_ops, check_for_incompatible_polymorphics, check_for_tables_with_oids, che","count":12},{"name":"tested-by","value":"check_generic_type_consistency","count":12},{"name":"tested-by","value":"check_hard_link","count":12},{"name":"tested-by","value":"check_index_is_clusterable","count":12},{"name":"tested-by","value":"check_out_colors_match, check_in_colors_match","count":12},{"name":"tested-by","value":"check_publication_add_schema","count":12},{"name":"tested-by","value":"check_recovery_target_time, check_recovery_target_time, check_recovery_target_time, check_recovery_target_time","count":12},{"name":"tested-by","value":"check_recovery_target_timeline, check_recovery_target_xid","count":12},{"name":"tested-by","value":"check_search_path","count":12},{"name":"tested-by","value":"check_synchronous_standby_names","count":12},{"name":"tested-by","value":"check_transaction_isolation","count":12},{"name":"tested-by","value":"check_vacuum_buffer_usage_limit, check_vacuum_buffer_usage_limit","count":12},{"name":"tested-by","value":"check_wal_consistency_checking, check_search_path, check_temp_tablespaces, check_createrole_self_grant, check_datestyle, check_timezone, check_hostname, check_valid_internal_signature, libpqrcv_check_","count":12},{"name":"tested-by","value":"check_wal_consistency_checking, check_wal_consistency_checking, check_wal_consistency_checking, pg_attribute_aclcheck_all_ext, check_search_path, check_search_path, check_db_file_conflict, check_db_fi","count":12},{"name":"tested-by","value":"float_to_shortest_decimal_bufn","count":12},{"name":"tested-by","value":"index_delete_check_htid","count":12},{"name":"tested-by","value":"index_delete_check_htid, index_delete_check_htid, index_delete_check_htid, _bt_check_unique, _bt_check_unique, _bt_check_third_page, table_tuple_get_latest_tid, check_default_table_access_method, serv","count":12},{"name":"tested-by","value":"restrict_and_check_grant, restrict_and_check_grant, restrict_and_check_grant, restrict_and_check_grant, check_circularity","count":12},{"name":"tested-by","value":"spgInnerTest","count":12},{"name":"tested-by","value":"spgInnerTest, spgInnerTest, check_temp_tablespaces, table_recheck_autovac, double_to_shortest_decimal, float_to_shortest_decimal","count":12},{"name":"tested-by","value":"systable_recheck_tuple","count":12},{"name":"tested-by","value":"test_config_settings","count":12},{"name":"tested-by","value":"test_open, win32_check_directory_write_permissions","count":12},{"name":"tested-by","value":"test_opexpr_is_hashable","count":12},{"name":"tested-by","value":"test_specific_config_settings","count":12},{"name":"Feature","value":"Deferrable unique constraints","count":11},{"name":"Feature","value":"postgres_fdw pushdown","count":11},{"name":"arch-sublayer","value":"btree-index","count":11},{"name":"arch-sublayer","value":"gist-index","count":11},{"name":"Feature","value":"security_barrier option on views","count":10},{"name":"arch-sublayer","value":"hash-index","count":10},{"name":"subsystem-desc","value":"src/bin/pgevent/README\n\npgevent\n=======\n\nMSG00001.bin is a binary file, result of Microsoft MC compiler. MC compiler\ncan be downloaded for free with MS Core SDK but it is not included with MSYS\ntools and I didn't find an alternative way to compile MC file.\n\nTo summarize: the command \"MC pgmsgevent.mc\" generates pgmsgevent.h,\npgmsgevent.rc, and MSG00001.bin files.  In MC file, we declare a string\nwith %s format, so we can write anything we want in the future without\nneeding to change the definition of this string.\n\nTo finish, because DllUnregisterServer and DllRegisterServer are system\ndefined entry points, we need to export these two functions with their names\nwithout \"decoration\", so we cannot use auto generated .def files without\nhandy modifications.\n\nLaurent Ballester","count":10},{"name":"subsystem-desc","value":"src/tutorial/README\n\ntutorial\n========\n\nThis directory contains SQL tutorial scripts.  To look at them, first do a\n\t% make\nto compile all the scripts and C files for the user-defined functions\nand types.  (make needs to be GNU make --- it may be named something\ndifferent on your system, often 'gmake')\n\nThen, run psql with the -s (single-step) flag:\n\t% psql -s\n\nFrom within psql, you can try each individual script file by using\npsql's \\i <filename> command.","count":10},{"name":"subsystem-name","value":"pgevent","count":10},{"name":"subsystem-name","value":"tutorial","count":10},{"name":"subsystem-path","value":"bin/pgevent/readme","count":10},{"name":"subsystem-path","value":"tutorial/readme","count":10},{"name":"Feature","value":"Channel binding for SCRAM authentication","count":9},{"name":"Feature","value":"Foreign data wrapper query parallelism","count":9},{"name":"Feature","value":"UPDATE on a partition key","count":9},{"name":"Feature","value":"Unicode string literals and identifiers","count":9},{"name":"api-example","value":"Acl * aclupdate(const Acl *old_acl, const AclItem *mod_aip, int modechg, Oid ownerId, DropBehavior behavior) { Acl\t\t   *new_acl = NULL; AclItem    *old_aip, *new_aip = NULL; AclMode\t\told_rights, old_g...","count":9},{"name":"api-example","value":"AggState * ExecInitAgg(Agg *node, EState *estate, int eflags) { AggState   *aggstate; AggStatePerAgg peraggs; AggStatePerTrans pertransstates; AggStatePerGroup *pergroups; Plan\t   *outerPlan; ExprCont...","count":9},{"name":"api-example","value":"Datum array_cat(PG_FUNCTION_ARGS) { ArrayType  *v1, *v2; ArrayType  *result; int\t\t   *dims, *lbs, ndims, nitems, ndatabytes, nbytes; int\t\t   *dims1, *lbs1, ndims1, nitems1, ndatabytes1; int\t\t   *dims2...","count":9},{"name":"api-example","value":"Datum array_get_element(Datum arraydatum, int nSubscripts, int *indx, int arraytyplen, int elmlen, bool elmbyval, char elmalign, bool *isNull) { int\t\t\ti, ndim, *dim, *lb, offset, fixedDim[1], fixedLb[...","count":9},{"name":"api-example","value":"Datum box_in(PG_FUNCTION_ARGS) { char\t   *str = PG_GETARG_CSTRING(0); Node\t   *escontext = fcinfo->context; BOX\t\t   *box = (BOX *) palloc(sizeof(BOX)); bool\t\tisopen; float8\t\tx, y; if (!path_decode(str...","count":9},{"name":"api-example","value":"Datum brin_inclusion_opcinfo(PG_FUNCTION_ARGS) { Oid\t\t\ttypoid = PG_GETARG_OID(0); BrinOpcInfo *result; TypeCacheEntry *bool_typcache = lookup_type_cache(BOOLOID, 0); * All members of opaque are initia...","count":9},{"name":"api-example","value":"Datum brin_minmax_multi_distance_date(PG_FUNCTION_ARGS) { float8\t\tdelta = 0; DateADT\t\tdateVal1 = PG_GETARG_DATEADT(0); DateADT\t\tdateVal2 = PG_GETARG_DATEADT(1); delta = (float8) dateVal2 - (float8) da...","count":9},{"name":"api-example","value":"Datum brin_minmax_multi_distance_time(PG_FUNCTION_ARGS) { float8\t\tdelta = 0; TimeADT\t\tta = PG_GETARG_TIMEADT(0); TimeADT\t\ttb = PG_GETARG_TIMEADT(1); delta = (tb - ta); Assert(delta >= 0); PG_RETURN_FL...","count":9},{"name":"api-example","value":"Datum cash_in(PG_FUNCTION_ARGS) { char\t   *str = PG_GETARG_CSTRING(0); Node\t   *escontext = fcinfo->context; Cash\t\tresult; Cash\t\tvalue = 0; Cash\t\tdec = 0; Cash\t\tsgn = 1; bool\t\tseen_dot = false; const ...","count":9},{"name":"api-example","value":"Datum cursor_to_xml(PG_FUNCTION_ARGS) { char\t   *name = text_to_cstring(PG_GETARG_TEXT_PP(0)); int32\t\tcount = PG_GETARG_INT32(1); bool\t\tnulls = PG_GETARG_BOOL(2); bool\t\ttableforest = PG_GETARG_BOOL(3)...","count":9},{"name":"api-example","value":"Datum date_out(PG_FUNCTION_ARGS) { DateADT\t\tdate = PG_GETARG_DATEADT(0); char\t   *result; struct pg_tm tt, *tm = &tt; char\t\tbuf[MAXDATELEN + 1]; if (DATE_NOT_FINITE(date)) EncodeSpecialDate(date, buf)...","count":9},{"name":"api-example","value":"Datum dsynonym_init(PG_FUNCTION_ARGS) { List\t   *dictoptions = (List *) PG_GETARG_POINTER(0); DictSyn    *d; ListCell   *l; char\t   *filename = NULL; bool\t\tcase_sensitive = false; tsearch_readline_sta...","count":9},{"name":"api-example","value":"Datum generate_series_step_numeric(PG_FUNCTION_ARGS) { generate_series_numeric_fctx *fctx; FuncCallContext *funcctx; MemoryContext oldcontext; if (SRF_IS_FIRSTCALL()) { Numeric\t\tstart_num = PG_GETARG_...","count":9},{"name":"api-example","value":"Datum gin_extract_jsonb_query(PG_FUNCTION_ARGS) { int32\t   *nentries = (int32 *) PG_GETARG_POINTER(1); StrategyNumber strategy = PG_GETARG_UINT16(2); int32\t   *searchMode = (int32 *) PG_GETARG_POINTER...","count":9},{"name":"api-example","value":"Datum has_table_privilege_name_name(PG_FUNCTION_ARGS) { Name\t\trolename = PG_GETARG_NAME(0); text\t   *tablename = PG_GETARG_TEXT_PP(1); text\t   *priv_type_text = PG_GETARG_TEXT_PP(2); Oid\t\t\troleid; Oid...","count":9},{"name":"api-example","value":"Datum hash_array_extended(PG_FUNCTION_ARGS) { LOCAL_FCINFO(locfcinfo, 2); AnyArrayType *array = PG_GETARG_ANY_ARRAY_P(0); uint64\t\tseed = PG_GETARG_INT64(1); int\t\t\tndims = AARR_NDIM(array); int\t\t   *di...","count":9},{"name":"api-example","value":"Datum jsonb_string_to_tsvector_byid(PG_FUNCTION_ARGS) { Oid\t\t\tcfgId = PG_GETARG_OID(0); Jsonb\t   *jb = PG_GETARG_JSONB_P(1); TSVector\tresult; result = jsonb_to_tsvector_worker(cfgId, jb, jtiString); P...","count":9},{"name":"api-example","value":"Datum line_in(PG_FUNCTION_ARGS) { char\t   *str = PG_GETARG_CSTRING(0); Node\t   *escontext = fcinfo->context; LINE\t   *line = (LINE *) palloc(sizeof(LINE)); LSEG\t\tlseg; bool\t\tisopen; char\t   *s; s = st...","count":9},{"name":"api-example","value":"Datum make_date(PG_FUNCTION_ARGS) { struct pg_tm tm; DateADT\t\tdate; int\t\t\tdterr; bool\t\tbc = false; tm.tm_year = PG_GETARG_INT32(0); tm.tm_mon = PG_GETARG_INT32(1); tm.tm_mday = PG_GETARG_INT32(2); if ...","count":9},{"name":"api-example","value":"Datum multirange_constructor2(PG_FUNCTION_ARGS) { Oid\t\t\tmltrngtypid = get_fn_expr_rettype(fcinfo->flinfo); Oid\t\t\trngtypid; TypeCacheEntry *typcache; TypeCacheEntry *rangetyp; ArrayType  *rangeArray; i...","count":9},{"name":"api-example","value":"Datum nocachegetattr(HeapTuple tup, int attnum, TupleDesc tupleDesc) { HeapTupleHeader td = tup->t_data; char\t   *tp;\t\t\t\t/* ptr to data part of tuple */ bits8\t   *bp = td->t_bits;\t/* ptr to null bitma...","count":9},{"name":"api-example","value":"Datum numeric_combine(PG_FUNCTION_ARGS) { NumericAggState *state1; NumericAggState *state2; MemoryContext agg_context; MemoryContext old_context; if (!AggCheckCallContext(fcinfo, &agg_context)) elog(E...","count":9},{"name":"api-example","value":"Datum numeric_to_char(PG_FUNCTION_ARGS) { Numeric\t\tvalue = PG_GETARG_NUMERIC(0); text\t   *fmt = PG_GETARG_TEXT_PP(1); NUMDesc\t\tNum; FormatNode *format; text\t   *result; bool\t\tshouldFree; int\t\t\tout_pre...","count":9},{"name":"api-example","value":"Datum pg_identify_object_as_address(PG_FUNCTION_ARGS) { Oid\t\t\tclassid = PG_GETARG_OID(0); Oid\t\t\tobjid = PG_GETARG_OID(1); int32\t\tobjsubid = PG_GETARG_INT32(2); ObjectAddress address; char\t   *identity...","count":9},{"name":"api-example","value":"Datum pg_options_to_table(PG_FUNCTION_ARGS) { Datum\t\tarray = PG_GETARG_DATUM(0); ListCell   *cell; List\t   *options; ReturnSetInfo *rsinfo = (ReturnSetInfo *) fcinfo->resultinfo; options = untransform...","count":9},{"name":"api-example","value":"Datum range_gist_penalty(PG_FUNCTION_ARGS) { GISTENTRY  *origentry = (GISTENTRY *) PG_GETARG_POINTER(0); GISTENTRY  *newentry = (GISTENTRY *) PG_GETARG_POINTER(1); float\t   *penalty = (float *) PG_GET...","count":9},{"name":"api-example","value":"Datum spg_quad_choose(PG_FUNCTION_ARGS) { spgChooseIn *in = (spgChooseIn *) PG_GETARG_POINTER(0); spgChooseOut *out = (spgChooseOut *) PG_GETARG_POINTER(1); Point\t   *inPoint = DatumGetPointP(in->datu...","count":9},{"name":"api-example","value":"Datum suppress_redundant_updates_trigger(PG_FUNCTION_ARGS) { TriggerData *trigdata = (TriggerData *) fcinfo->context; HeapTuple\tnewtuple, oldtuple, rettuple; HeapTupleHeader newheader, oldheader; if (...","count":9},{"name":"api-example","value":"Datum to_ascii_enc(PG_FUNCTION_ARGS) { text\t   *data = PG_GETARG_TEXT_P_COPY(0); int\t\t\tenc = PG_GETARG_INT32(1); if (!PG_VALID_ENCODING(enc)) ereport(ERROR, (errcode(ERRCODE_UNDEFINED_OBJECT), errmsg(...","count":9},{"name":"api-example","value":"Datum to_tsvector_byid(PG_FUNCTION_ARGS) { Oid\t\t\tcfgId = PG_GETARG_OID(0); text\t   *in = PG_GETARG_TEXT_PP(1); ParsedText\tprs; TSVector\tout; prs.lenwords = VARSIZE_ANY_EXHDR(in) / 6;\t/* just estimatio...","count":9},{"name":"api-example","value":"Datum ts_headline_jsonb_byid_opt(PG_FUNCTION_ARGS) { Oid\t\t\ttsconfig = PG_GETARG_OID(0); Jsonb\t   *jb = PG_GETARG_JSONB_P(1); TSQuery\t\tquery = PG_GETARG_TSQUERY(2); text\t   *opt = (PG_NARGS() > 3 && PG...","count":9},{"name":"api-example","value":"Datum tsmatchsel(PG_FUNCTION_ARGS) { PlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0); #ifdef NOT_USED Oid\t\t\toperator = PG_GETARG_OID(1); #endif List\t   *args = (List *) PG_GETARG_POINTER(2); ...","count":9},{"name":"api-example","value":"EquivalenceMember * find_computable_ec_member(PlannerInfo *root, EquivalenceClass *ec, List *exprs, Relids relids, bool require_parallel_safe) { List\t   *exprvars; ListCell   *lc; * Pull out the Vars ...","count":9},{"name":"api-example","value":"ExprState * ExecInitExpr(Expr *node, PlanState *parent) { ExprState  *state; ExprEvalStep scratch = {0}; if (node == NULL) return NULL; state = makeNode(ExprState); state->expr = node; state->parent =...","count":9},{"name":"api-example","value":"IndexTuple index_truncate_tuple(TupleDesc sourceDescriptor, IndexTuple source, int leavenatts) { TupleDesc\ttruncdesc; Datum\t\tvalues[INDEX_MAX_KEYS]; bool\t\tisnull[INDEX_MAX_KEYS]; IndexTuple\ttruncated;...","count":9},{"name":"api-example","value":"ItemPointer GinDataLeafPageGetItems(Page page, int *nitems, ItemPointerData advancePast) { ItemPointer result; if (GinPageIsCompressed(page)) { GinPostingList *seg = GinDataLeafPageGetPostingList(page...","count":9},{"name":"api-example","value":"List * generate_join_implied_equalities(PlannerInfo *root, Relids join_relids, Relids outer_relids, RelOptInfo *inner_rel, SpecialJoinInfo *sjinfo) { List\t   *result = NIL; Relids\t\tinner_relids = inne...","count":9},{"name":"api-example","value":"List * get_proposed_default_constraint(List *new_part_constraints) { Expr\t   *defPartConstraint; defPartConstraint = make_ands_explicit(new_part_constraints); * Derive the partition constraints of def...","count":9},{"name":"api-example","value":"List * list_make1_impl(NodeTag t, ListCell datum1) { List\t   *list = new_list(t, 1); list->elements[0] = datum1; check_list_invariants(list); return list; }","count":9},{"name":"api-example","value":"Node * cookDefault(ParseState *pstate, Node *raw_default, Oid atttypid, int32 atttypmod, const char *attname, char attgenerated) { Node\t   *expr; Assert(raw_default != NULL); * Transform raw parsetree...","count":9},{"name":"api-example","value":"Node * expression_tree_mutator_impl(Node *node, tree_mutator_callback mutator, void *context) { * The mutator has already decided not to modify the current node, but we * must call the mutator for any...","count":9},{"name":"api-example","value":"ObjectAddress AlterStatistics(AlterStatsStmt *stmt) { Relation\trel; Oid\t\t\tstxoid; HeapTuple\toldtup; HeapTuple\tnewtup; Datum\t\trepl_val[Natts_pg_statistic_ext]; bool\t\trepl_null[Natts_pg_statistic_ext]; ...","count":9},{"name":"api-example","value":"ObjectAddress AlterSubscription(ParseState *pstate, AlterSubscriptionStmt *stmt, bool isTopLevel) { Relation\trel; ObjectAddress myself; bool\t\tnulls[Natts_pg_subscription]; bool\t\treplaces[Natts_pg_subs...","count":9},{"name":"api-example","value":"ObjectAddress CreateStatistics(CreateStatsStmt *stmt) { int16\t\tattnums[STATS_MAX_DIMENSIONS]; int\t\t\tnattnums = 0; int\t\t\tnumcols; char\t   *namestr; NameData\tstxname; Oid\t\t\tstatoid; Oid\t\t\tnamespaceId; O...","count":9},{"name":"api-example","value":"Oid AlterTableMoveAll(AlterTableMoveAllStmt *stmt) { List\t   *relations = NIL; ListCell   *l; ScanKeyData key[1]; Relation\trel; TableScanDesc scan; HeapTuple\ttuple; Oid\t\t\torig_tablespaceoid; Oid\t\t\tnew...","count":9},{"name":"api-example","value":"Oid StoreAttrDefault(Relation rel, AttrNumber attnum, Node *expr, bool is_internal, bool add_column_mode) { char\t   *adbin; Relation\tadrel; HeapTuple\ttuple; Datum\t\tvalues[4]; static bool nulls[4] = {f...","count":9},{"name":"api-example","value":"Oid index_concurrently_create_copy(Relation heapRelation, Oid oldIndexId, Oid tablespaceOid, const char *newName) { Relation\tindexRelation; IndexInfo  *oldInfo, *newInfo; Oid\t\t\tnewIndexId = InvalidOid...","count":9},{"name":"api-example","value":"PartitionPruneState * ExecInitPartitionPruning(PlanState *planstate, int n_total_subplans, PartitionPruneInfo *pruneinfo, Bitmapset **initially_valid_subplans) { PartitionPruneState *prunestate; EStat...","count":9},{"name":"api-example","value":"PrefetchBufferResult PrefetchSharedBuffer(SMgrRelation smgr_reln, ForkNumber forkNum, BlockNumber blockNum) { PrefetchBufferResult result = {InvalidBuffer, false}; BufferTag\tnewTag;\t\t\t/* identity of r...","count":9},{"name":"api-example","value":"PyObject * PLy_cursor(PyObject *self, PyObject *args) { char\t   *query; PyObject   *plan; PyObject   *planargs = NULL; if (PyArg_ParseTuple(args, \"s\", &query)) return PLy_cursor_query(query); PyErr_Cl...","count":9},{"name":"api-example","value":"TimestampTz date2timestamptz_opt_overflow(DateADT dateVal, int *overflow) { TimestampTz result; struct pg_tm tt, *tm = &tt; int\t\t\ttz; if (overflow) *overflow = 0; if (DATE_IS_NOBEGIN(dateVal)) TIMESTA...","count":9},{"name":"api-example","value":"TupleDesc CreateTupleDesc(int natts, Form_pg_attribute *attrs) { TupleDesc\tdesc; int\t\t\ti; desc = CreateTemplateTupleDesc(natts); for (i = 0; i < natts; ++i) memcpy(TupleDescAttr(desc, i), attrs[i], AT...","count":9},{"name":"api-example","value":"TupleHashTable BuildTupleHashTableExt(PlanState *parent, TupleDesc inputDesc, int numCols, AttrNumber *keyColIdx, const Oid *eqfuncoids, FmgrInfo *hashfunctions, Oid *collations, long nbuckets, Size a...","count":9},{"name":"api-example","value":"TupleTableSlot * MakeTupleTableSlot(TupleDesc tupleDesc, const TupleTableSlotOps *tts_ops) { Size\t\tbasesz, allocsz; TupleTableSlot *slot; basesz = tts_ops->base_slot_size; * When a fixed descriptor is...","count":9},{"name":"api-example","value":"TypeCacheEntry * lookup_type_cache(Oid type_id, int flags) { TypeCacheEntry *typentry; bool\t\tfound; if (TypeCacheHash == NULL) { HASHCTL\t\tctl; ctl.keysize = sizeof(Oid); ctl.entrysize = sizeof(TypeCac...","count":9},{"name":"api-example","value":"WS2TCPIP_INLINE int IN6_IS_ADDR_MC_NODELOCAL(const struct in6_addr *a) { return IN6_IS_ADDR_MULTICAST(a) && ((a->s6_bytes[1] & 0xf)==1); }","count":9},{"name":"api-example","value":"__mingw_ovr int __cdecl _vfwscanf_s_l(FILE *_File, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList) { return __stdio_common_vfwscanf(_CRT_INTERNAL_LOCAL_SCANF_OPTIONS | _CRT_INTERNAL_SCANF...","count":9},{"name":"api-example","value":"bloom_filter * bloom_create(int64 total_elems, int bloom_work_mem, uint64 seed) { bloom_filter *filter; int\t\t\tbloom_power; uint64\t\tbitset_bytes; uint64\t\tbitset_bits; * Aim for two bytes per element; t...","count":9},{"name":"api-example","value":"bool ECPGdescribe(int line, int compat, bool input, const char *connection_name, const char *stmt_name,...) { bool\t\tret = false; struct connection *con; struct prepared_statement *prep; PGresult   *re...","count":9},{"name":"api-example","value":"bool ECPGsetcommit(int lineno, const char *mode, const char *connection_name) { struct connection *con = ecpg_get_connection(connection_name); PGresult   *results; if (!ecpg_init(con, connection_name,...","count":9},{"name":"api-example","value":"bool checkSeek(FILE *fp) { pgoff_t\t\ttpos; tpos = ftello(fp); if (tpos < 0) return false; * Check that fseeko(SEEK_SET) works, too.  NB: we used to try to test * this with fseeko(fp, 0, SEEK_CUR).  But...","count":9},{"name":"api-example","value":"bool check_sql_fn_retval(List *queryTreeLists, Oid rettype, TupleDesc rettupdesc, char prokind, bool insertDroppedCols, List **resultTargetList) { bool\t\tis_tuple_result = false; Query\t   *parse; ListC...","count":9},{"name":"api-example","value":"bool expression_tree_walker_impl(Node *node, tree_walker_callback walker, void *context) { ListCell   *temp; * The walker has already visited the current node, and so we need only * recurse into any s...","count":9},{"name":"api-example","value":"bool pg_u_prop_alphabetic(pg_wchar code) { if (code < 0x80) return unicode_opt_ascii[code].properties & PG_U_PROP_ALPHABETIC; return range_search(unicode_alphabetic, lengthof(unicode_alphabetic), code...","count":9},{"name":"api-example","value":"bool pg_u_prop_cased(pg_wchar code) { uint32\t\tcategory_mask; if (code < 0x80) return unicode_opt_ascii[code].properties & PG_U_PROP_CASED; category_mask = PG_U_CATEGORY_MASK(unicode_category(code)); r...","count":9},{"name":"api-example","value":"bool spgdoinsert(Relation index, SpGistState *state, ItemPointer heapPtr, Datum *datums, bool *isnulls) { bool\t\tresult = true; TupleDesc\tleafDescriptor = state->leafTupDesc; bool\t\tisnull = isnulls[spg...","count":9},{"name":"api-example","value":"bool tzparse(const char *name, struct state *sp, bool lastditch) { const char *stdname; const char *dstname = NULL; size_t\t\tstdlen; size_t\t\tdstlen; size_t\t\tcharcnt; int32\t\tstdoffset; int32\t\tdstoffset;...","count":9},{"name":"api-example","value":"char * defGetString(DefElem *def) { if (def->arg == NULL) ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg(\"%s requires a parameter\", def->defname))); switch (nodeTag(def->arg)) { case T_Integer:...","count":9},{"name":"api-example","value":"char * gets_fromFile(FILE *source) { static PQExpBuffer buffer = NULL; char\t\tline[1024]; if (buffer == NULL)\t\t\t/* first time through? */ buffer = createPQExpBuffer(); else resetPQExpBuffer(buffer); fo...","count":9},{"name":"api-example","value":"char * pg_fe_scram_build_secret(const char *password, int iterations, const char **errstr) { char\t   *prep_password; pg_saslprep_rc rc; char\t\tsaltbuf[SCRAM_DEFAULT_SALT_LEN]; char\t   *result; * Normal...","count":9},{"name":"api-example","value":"char CompressionNameToMethod(const char *compression) { if (strcmp(compression, \"pglz\") == 0) return TOAST_PGLZ_COMPRESSION; else if (strcmp(compression, \"lz4\") == 0) { #ifndef USE_LZ4 NO_LZ4_SUPPORT(...","count":9},{"name":"api-example","value":"color pg_reg_getcolor(struct colormap *cm, chr c) { int\t\t\trownum, colnum, low, high; assert(c > MAX_SIMPLE_CHR); * Find which row it's in.  The colormapranges are in order, so we can use * binary sear...","count":9},{"name":"api-example","value":"dshash_table * dshash_create(dsa_area *area, const dshash_parameters *params, void *arg) { dshash_table *hash_table; dsa_pointer control; hash_table = palloc(sizeof(dshash_table)); control = dsa_alloc...","count":9},{"name":"api-example","value":"int ExecEvalJsonExprPath(ExprState *state, ExprEvalStep *op, ExprContext *econtext) { JsonExprState *jsestate = op->d.jsonexpr.jsestate; JsonExpr   *jsexpr = jsestate->jsexpr; Datum\t\titem; JsonPath   ...","count":9},{"name":"api-example","value":"int PQcancel(PGcancel *cancel, char *errbuf, int errbufsize) { int\t\t\tsave_errno = SOCK_ERRNO; pgsocket\ttmpsock = PGINVALID_SOCKET; int\t\t\tmaxlen; struct { uint32\t\tpacketlen; CancelRequestPacket cp; }\t\t...","count":9},{"name":"api-example","value":"int ReadOffset(ArchiveHandle *AH, pgoff_t * o) { int\t\t\ti; int\t\t\toff; int\t\t\toffsetFlg; *o = 0; if (AH->version < K_VERS_1_7) { i = ReadInt(AH); if (i < 0) return K_OFFSET_POS_NOT_SET; else if (i == 0) ...","count":9},{"name":"api-example","value":"int ValidateDate(int fmask, bool isjulian, bool is2digits, bool bc, struct pg_tm *tm) { if (fmask & DTK_M(YEAR)) { if (isjulian) { } else if (bc) { if (tm->tm_year <= 0) return DTERR_FIELD_OVERFLOW; t...","count":9},{"name":"api-example","value":"int deccvasc(const char *cp, int len, decimal *np) { char\t   *str; int\t\t\tret = 0; numeric    *result; rsetnull(CDECIMALTYPE, (char *) np); if (risnull(CSTRINGTYPE, cp)) return 0; str = ecpg_strndup(cp...","count":9},{"name":"api-example","value":"int main(int argc, char **argv) { int\t\t\tc, k; ptrdiff_t\ti, j; bool\t\ttimerange_given = false; #ifndef WIN32 umask(umask(S_IWGRP | S_IWOTH) | (S_IWGRP | S_IWOTH)); #endif progname = argv[0]; if (TYPE_BI...","count":9},{"name":"api-example","value":"int main(int argc, char **argv) { static struct option long_options[] = { {\"builtin\", required_argument, NULL, 'b'}, {\"client\", required_argument, NULL, 'c'}, {\"connect\", no_argument, NULL, 'C'}, {\"db...","count":9},{"name":"api-example","value":"int main(int argc, char *const argv[]) { static struct option ecpg_options[] = { {\"regression\", no_argument, NULL, ECPG_GETOPT_LONG_REGRESSION}, {NULL, 0, NULL, 0} }; int\t\t\tfnr, c, out_option = 0; boo...","count":9},{"name":"api-example","value":"int pgwin32_select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timeval *timeout) { WSAEVENT\tevents[FD_SETSIZE * 2]; /* worst case is readfds totally * different from w...","count":9},{"name":"api-example","value":"int pgwin32_waitforsinglesocket(SOCKET s, int what, int timeout) { static HANDLE waitevent = INVALID_HANDLE_VALUE; static SOCKET current_socket = INVALID_SOCKET; static int\tisUDP = 0; HANDLE\t\tevents[2...","count":9},{"name":"api-example","value":"int32 date_cmp_timestamp_internal(DateADT dateVal, Timestamp dt2) { Timestamp\tdt1; int\t\t\toverflow; dt1 = date2timestamp_opt_overflow(dateVal, &overflow); if (overflow > 0) { return TIMESTAMP_IS_NOEND(...","count":9},{"name":"api-example","value":"int32 numeric_maximum_size(int32 typmod) { int\t\t\tprecision; int\t\t\tnumeric_digits; if (!is_valid_numeric_typmod(typmod)) return -1; precision = numeric_typmod_precision(typmod); * This formula computes...","count":9},{"name":"api-example","value":"ssize_t be_gssapi_write(Port *port, void *ptr, size_t len) { OM_uint32\tmajor, minor; gss_buffer_desc input, output; size_t\t\tbytes_to_encrypt; size_t\t\tbytes_encrypted; gss_ctx_id_t gctx = port->gss->ct...","count":9},{"name":"api-example","value":"static Datum ri_restrict(TriggerData *trigdata, bool is_no_action) { const RI_ConstraintInfo *riinfo; Relation\tfk_rel; Relation\tpk_rel; TupleTableSlot *oldslot; RI_QueryKey qkey; SPIPlanPtr\tqplan; rii...","count":9},{"name":"api-example","value":"static List * extract_jsp_path_expr_nodes(JsonPathGinContext *cxt, JsonPathGinPath path, JsonPathItem *jsp, JsonbValue *scalar) { JsonPathItem next; List\t   *nodes = NIL; for (;;) { switch (jsp->type)...","count":9},{"name":"api-example","value":"static LsnReadQueueNextStatus XLogPrefetcherNextBlock(uintptr_t pgsr_private, XLogRecPtr *lsn) { XLogPrefetcher *prefetcher = (XLogPrefetcher *) pgsr_private; XLogReaderState *reader = prefetcher->rea...","count":9},{"name":"api-example","value":"static Node * eval_const_expressions_mutator(Node *node, eval_const_expressions_context *context) { check_stack_depth(); if (node == NULL) return NULL; switch (nodeTag(node)) { case T_Param: { Param\t ...","count":9},{"name":"api-example","value":"static Node * transformColumnRef(ParseState *pstate, ColumnRef *cref) { Node\t   *node = NULL; char\t   *nspname = NULL; char\t   *relname = NULL; char\t   *colname = NULL; ParseNamespaceItem *nsitem; int...","count":9},{"name":"api-example","value":"static ObjectAddress ATExecAlterColumnType(AlteredTableInfo *tab, Relation rel, AlterTableCmd *cmd, LOCKMODE lockmode) { char\t   *colName = cmd->name; ColumnDef  *def = (ColumnDef *) cmd->def; TypeNam...","count":9},{"name":"api-example","value":"static ObjectAddress AddNewRelationType(const char *typeName, Oid typeNamespace, Oid new_rel_oid, char new_rel_kind, Oid ownerid, Oid new_row_type, Oid new_array_type) { return TypeCreate(new_row_type...","count":9},{"name":"api-example","value":"static ObjectAddress get_object_address_type(ObjectType objtype, TypeName *typename, bool missing_ok) { ObjectAddress address; Type\t\ttup; address.classId = TypeRelationId; address.objectId = InvalidOi...","count":9},{"name":"api-example","value":"static Oid StoreRelCheck(Relation rel, const char *ccname, Node *expr, bool is_validated, bool is_local, int inhcount, bool is_no_inherit, bool is_internal) { char\t   *ccbin; List\t   *varList; int\t\t\tk...","count":9},{"name":"api-example","value":"static Oid lookup_agg_function(List *fnName, int nargs, Oid *input_types, Oid variadicArgType, Oid *rettype) { Oid\t\t\tfnOid; bool\t\tretset; int\t\t\tnvargs; Oid\t\t\tvatype; Oid\t\t   *true_oid_array; FuncDetai...","count":9},{"name":"api-example","value":"static PGresult * libpqrcv_PQgetResult(PGconn *streamConn) { * Collect data until PQgetResult is ready to get the result without * blocking. */ while (PQisBusy(streamConn)) { int\t\t\trc; * We don't need...","count":9},{"name":"api-example","value":"static PartitionBoundInfo merge_range_bounds(int partnatts, FmgrInfo *partsupfuncs, Oid *partcollations, RelOptInfo *outer_rel, RelOptInfo *inner_rel, JoinType jointype, List **outer_parts, List **inn...","count":9},{"name":"api-example","value":"static PathTarget * make_group_input_target(PlannerInfo *root, PathTarget *final_target) { Query\t   *parse = root->parse; PathTarget *input_target; List\t   *non_group_cols; List\t   *non_group_vars; in...","count":9},{"name":"api-example","value":"static Query * transformDeleteStmt(ParseState *pstate, DeleteStmt *stmt) { Query\t   *qry = makeNode(Query); ParseNamespaceItem *nsitem; Node\t   *qual; qry->commandType = CMD_DELETE; if (stmt->withClau...","count":9},{"name":"api-example","value":"static Query * transformSelectStmt(ParseState *pstate, SelectStmt *stmt) { Query\t   *qry = makeNode(Query); Node\t   *qual; ListCell   *l; qry->commandType = CMD_SELECT; if (stmt->withClause) { qry->ha...","count":9},{"name":"api-example","value":"static SV  * get_perl_array_ref(SV *sv) { dTHX; if (SvOK(sv) && SvROK(sv)) { if (SvTYPE(SvRV(sv)) == SVt_PVAV) return sv; else if (sv_isa(sv, \"PostgreSQL::InServer::ARRAY\")) { HV\t\t   *hv = (HV *) SvRV...","count":9},{"name":"api-example","value":"static Selectivity tsquery_opr_selec(QueryItem *item, char *operand, TextFreq *lookup, int length, float4 minfreq) { Selectivity selec; check_stack_depth(); if (item->type == QI_VAL) { QueryOperand *o...","count":9},{"name":"api-example","value":"static Size ER_get_flat_size(ExpandedObjectHeader *eohptr) { ExpandedRecordHeader *erh = (ExpandedRecordHeader *) eohptr; TupleDesc\ttupdesc; Size\t\tlen; Size\t\tdata_len; int\t\t\thoff; bool\t\thasnull; int\t\t...","count":9},{"name":"api-example","value":"static Size FreePageManagerLargestContiguous(FreePageManager *fpm) { char\t   *base; Size\t\tlargest; base = fpm_segment_base(fpm); largest = 0; if (!relptr_is_null(fpm->freelist[FPM_NUM_FREELISTS - 1]))...","count":9},{"name":"api-example","value":"static Size hashagg_spill_tuple(AggState *aggstate, HashAggSpill *spill, TupleTableSlot *inputslot, uint32 hash) { TupleTableSlot *spillslot; int\t\t\tpartition; MinimalTuple tuple; LogicalTape *tape; in...","count":9},{"name":"api-example","value":"static TM_Result heap_lock_updated_tuple_rec(Relation rel, ItemPointer tid, TransactionId xid, LockTupleMode mode) { TM_Result\tresult; ItemPointerData tupid; HeapTupleData mytup; Buffer\t\tbuf; uint16\t\t...","count":9},{"name":"api-example","value":"static TM_Result test_lockmode_for_conflict(MultiXactStatus status, TransactionId xid, LockTupleMode mode, HeapTuple tup, bool *needwait) { MultiXactStatus wantedstatus; *needwait = false; wantedstatu...","count":9},{"name":"api-example","value":"static TSTernaryValue TS_phrase_output(ExecPhraseData *data, ExecPhraseData *Ldata, ExecPhraseData *Rdata, int emit, int Loffset, int Roffset, int max_npos) { int\t\t\tLindex, Rindex; Lindex = Rindex = 0...","count":9},{"name":"api-example","value":"static TidOpExpr * MakeTidOpExpr(OpExpr *expr, TidRangeScanState *tidstate) { Node\t   *arg1 = get_leftop((Expr *) expr); Node\t   *arg2 = get_rightop((Expr *) expr); ExprState  *exprstate = NULL; bool\t...","count":9},{"name":"api-example","value":"static TransactionId _bt_check_unique(Relation rel, BTInsertState insertstate, Relation heapRel, IndexUniqueCheck checkUnique, bool *is_unique, uint32 *speculativeToken) { IndexTuple\titup = insertstat...","count":9},{"name":"api-example","value":"static TupleTableSlot * agg_retrieve_direct(AggState *aggstate) { Agg\t\t   *node = aggstate->phase->aggnode; ExprContext *econtext; ExprContext *tmpcontext; AggStatePerAgg peragg; AggStatePerGroup *per...","count":9},{"name":"api-example","value":"static TupleTableSlot * gather_merge_getnext(GatherMergeState *gm_state) { int\t\t\ti; if (!gm_state->gm_initialized) { * First time through: pull the first tuple from each participant, and * set up the ...","count":9},{"name":"api-example","value":"static VarBit * bit_catenate(VarBit *arg1, VarBit *arg2) { VarBit\t   *result; int\t\t\tbitlen1, bitlen2, bytelen, bit1pad, bit2shift; bits8\t   *pr, *pa; bitlen1 = VARBITLEN(arg1); bitlen2 = VARBITLEN(arg...","count":9},{"name":"api-example","value":"static XLogPageReadResult XLogDecodeNextRecord(XLogReaderState *state, bool nonblocking) { XLogRecPtr\tRecPtr; XLogRecord *record; XLogRecPtr\ttargetPagePtr; bool\t\trandAccess; uint32\t\tlen, total_len; ui...","count":9},{"name":"api-example","value":"static backslashResult exec_command_edit(PsqlScanState scan_state, bool active_branch, PQExpBuffer query_buf, PQExpBuffer previous_buf) { backslashResult status = PSQL_CMD_SKIP_LINE; if (active_branch...","count":9},{"name":"api-example","value":"static backslashResult exec_command_password(PsqlScanState scan_state, bool active_branch) { bool\t\tsuccess = true; if (active_branch) { char\t   *user = psql_scan_slash_option(scan_state, OT_SQLID, NUL...","count":9},{"name":"api-example","value":"static backslashResult exec_command_write(PsqlScanState scan_state, bool active_branch, const char *cmd, PQExpBuffer query_buf, PQExpBuffer previous_buf) { backslashResult status = PSQL_CMD_SKIP_LINE;...","count":9},{"name":"api-example","value":"static bool ExplainPreScanNode(PlanState *planstate, Bitmapset **rels_used) { Plan\t   *plan = planstate->plan; switch (nodeTag(plan)) { case T_SeqScan: case T_SampleScan: case T_IndexScan: case T_Inde...","count":9},{"name":"api-example","value":"static bool FindLockCycleRecurseMember(PGPROC *checkProc, PGPROC *checkProcLeader, int depth, EDGE *softEdges, /* output argument */ int *nSoftEdges) /* output argument */ { PGPROC\t   *proc; LOCK\t   *...","count":9},{"name":"api-example","value":"static bool GetParentPredicateLockTag(const PREDICATELOCKTARGETTAG *tag, PREDICATELOCKTARGETTAG *parent) { switch (GET_PREDICATELOCKTARGETTAG_TYPE(*tag)) { case PREDLOCKTAG_RELATION: return false; cas...","count":9},{"name":"api-example","value":"static bool HeapTupleSatisfiesSelf(HeapTuple htup, Snapshot snapshot, Buffer buffer) { HeapTupleHeader tuple = htup->t_data; Assert(ItemPointerIsValid(&htup->t_self)); Assert(htup->t_tableOid != Inval...","count":9},{"name":"api-example","value":"static bool _equalList(const List *a, const List *b) { const ListCell *item_a; const ListCell *item_b; * Try to reject by simple scalar checks before grovelling through all the * list elements... */ C...","count":9},{"name":"api-example","value":"static bool gistindex_keytest(IndexScanDesc scan, IndexTuple tuple, Page page, OffsetNumber offset, bool *recheck_p, bool *recheck_distances_p) { GISTScanOpaque so = (GISTScanOpaque) scan->opaque; GIS...","count":9},{"name":"api-example","value":"static bool hlCover(HeadlineParsedText *prs, TSQuery query, List *locations, int *nextpos, int *p, int *q) { int\t\t\tpos = *nextpos; for (;;) { int\t\t\tposb, pose; ListCell   *lc; * For each AND'ed query ...","count":9},{"name":"api-example","value":"static bool is_xlogfilename(const char *filename, bool *ispartial, pg_compress_algorithm *wal_compression_algorithm) { size_t\t\tfname_len = strlen(filename); size_t\t\txlog_pattern_len = strspn(filename,...","count":9},{"name":"api-example","value":"static bool makeDependencyGraphWalker(Node *node, CteState *cstate) { if (node == NULL) return false; if (IsA(node, RangeVar)) { RangeVar   *rv = (RangeVar *) node; if (!rv->schemaname) { ListCell   *...","count":9},{"name":"api-example","value":"static bool pa_process_spooled_messages_if_required(void) { PartialFileSetState fileset_state; fileset_state = pa_get_fileset_state(); if (fileset_state == FS_EMPTY) return false; * If the leader appl...","count":9},{"name":"api-example","value":"static bool printtup(TupleTableSlot *slot, DestReceiver *self) { TupleDesc\ttypeinfo = slot->tts_tupleDescriptor; DR_printtup *myState = (DR_printtup *) self; MemoryContext oldcontext; StringInfo\tbuf =...","count":9},{"name":"api-example","value":"static bool set_var_from_non_decimal_integer_str(const char *str, const char *cp, int sign, int base, NumericVar *dest, const char **endptr, Node *escontext) { const char *firstdigit = cp; int64\t\ttmp;...","count":9},{"name":"api-example","value":"static bool toastrel_valueid_exists(Relation toastrel, Oid valueid) { bool\t\tresult = false; ScanKeyData toastkey; SysScanDesc toastscan; int\t\t\tnum_indexes; int\t\t\tvalidIndex; Relation   *toastidxs; val...","count":9},{"name":"api-example","value":"static bytea * read_binary_file(const char *filename, int64 seek_offset, int64 bytes_to_read, bool missing_ok) { bytea\t   *buf; size_t\t\tnbytes = 0; FILE\t   *file; if (bytes_to_read > (int64) (MaxAlloc...","count":9},{"name":"api-example","value":"static char * AppendTimestampSeconds(char *cp, struct pg_tm *tm, fsec_t fsec) { return AppendSeconds(cp, tm->tm_sec, fsec, MAX_TIMESTAMP_PRECISION, true); }","count":9},{"name":"api-example","value":"static char * JsonbToCStringWorker(StringInfo out, JsonbContainer *in, int estimated_len, bool indent) { bool\t\tfirst = true; JsonbIterator *it; JsonbValue\tv; JsonbIteratorToken type = WJB_DONE; int\t\t\t...","count":9},{"name":"api-example","value":"static char * findwrd(char *in, char **end, uint16 *flags) { char\t   *start; char\t   *lastchar; while (*in && t_isspace(in)) in += pg_mblen(in); if (*in == '\\0') { *end = NULL; return NULL; } lastchar...","count":9},{"name":"api-example","value":"static char * flatten_set_variable_args(const char *name, List *args) { struct config_generic *record; int\t\t\tflags; StringInfoData buf; ListCell   *l; if (args == NIL) return NULL; * Get flags for the...","count":9},{"name":"api-example","value":"static char * get_variable(Var *var, int levelsup, bool istoplevel, deparse_context *context) { StringInfo\tbuf = context->buf; RangeTblEntry *rte; AttrNumber\tattnum; int\t\t\tnetlevelsup; deparse_namespa...","count":9},{"name":"api-example","value":"static char * libpqrcv_identify_system(WalReceiverConn *conn, TimeLineID *primary_tli) { PGresult   *res; char\t   *primary_sysid; * Get the system identifier and timeline ID as a DataRow message from ...","count":9},{"name":"api-example","value":"static char * pg_get_indexdef_worker(Oid indexrelid, int colno, const Oid *excludeOps, bool attrsOnly, bool keysOnly, bool showTblSpc, bool inherits, int prettyFlags, bool missing_ok) { bool\t\tisConstr...","count":9},{"name":"api-example","value":"static char * str_time(pg_time_t tnow) { static char buf[128]; pg_strftime(buf, sizeof(buf), \"%Y-%m-%d %H:%M:%S %Z\", pg_localtime(&tnow, log_timezone)); return buf; }","count":9},{"name":"api-example","value":"static const char * getrule(const char *strp, struct rule *const rulep) { if (*strp == 'J') { * Julian day. */ rulep->r_type = JULIAN_DAY; ++strp; strp = getnum(strp, &rulep->r_day, 1, DAYSPERNYEAR); ...","count":9},{"name":"api-example","value":"static float calc_rank_and(const float *w, TSVector t, TSQuery q) { WordEntryPosVector **pos; WordEntryPosVector1 posnull; WordEntryPosVector *POSNULL; int\t\t\ti, k, l, p; WordEntry  *entry, *firstentry...","count":9},{"name":"api-example","value":"static float8 computeDistance(bool isLeaf, BOX *box, Point *point) { float8\t\tresult = 0.0; if (isLeaf) { result = point_point_distance(point, &box->low); } else if (point->x <= box->high.x && point->x...","count":9},{"name":"api-example","value":"static float8 size_box(const BOX *box) { * Check for zero-width cases.  Note that we define the size of a zero- * by-infinity box as zero.  It's important to special-case this somehow, * as naively mu...","count":9},{"name":"api-example","value":"static inline int64 MultiXactIdToOffsetSegment(MultiXactId multi) { return MultiXactIdToOffsetPage(multi) / SLRU_PAGES_PER_SEGMENT; }","count":9},{"name":"api-example","value":"static inline void index_delete_check_htid(TM_IndexDeleteOp *delstate, Page page, OffsetNumber maxoff, ItemPointer htid, TM_IndexStatus *istatus) { OffsetNumber indexpagehoffnum = ItemPointerGetOffset...","count":9},{"name":"api-example","value":"static int CheckMD5Auth(Port *port, char *shadow_pass, const char **logdetail) { char\t\tmd5Salt[4];\t\t/* Password salt */ char\t   *passwd; int\t\t\tresult; if (!pg_strong_random(md5Salt, 4)) { ereport(LOG,...","count":9},{"name":"api-example","value":"static int CheckPasswordAuth(Port *port, const char **logdetail) { char\t   *passwd; int\t\t\tresult; char\t   *shadow_pass; sendAuthRequest(port, AUTH_REQ_PASSWORD, NULL, 0); passwd = recv_password_packet...","count":9},{"name":"api-example","value":"static int CreateRestrictedProcess(char *cmd, PROCESS_INFORMATION *processInfo, bool as_service) { int\t\t\tr; BOOL\t\tb; STARTUPINFO si; HANDLE\t\torigToken; HANDLE\t\trestrictedToken; BOOL\t\tinJob; SID_IDENTI...","count":9},{"name":"api-example","value":"static int connectNoDelay(PGconn *conn) { #ifdef\tTCP_NODELAY int\t\t\ton = 1; if (setsockopt(conn->sock, IPPROTO_TCP, TCP_NODELAY, (char *) &on, sizeof(on)) < 0) { char\t\tsebuf[PG_STRERROR_R_BUFLEN]; libp...","count":9},{"name":"api-example","value":"static int copy_read_data(void *outbuf, int minread, int maxread) { int\t\t\tbytesread = 0; int\t\t\tavail; avail = copybuf->len - copybuf->cursor; if (avail) { if (avail > maxread) avail = maxread; memcpy(...","count":9},{"name":"api-example","value":"static int dumpTableData_insert(Archive *fout, const void *dcontext) { TableDataInfo *tdinfo = (TableDataInfo *) dcontext; TableInfo  *tbinfo = tdinfo->tdtable; DumpOptions *dopt = fout->dopt; PQExpBu...","count":9},{"name":"api-example","value":"static int from_char_parse_int_len(int *dest, const char **src, const int len, FormatNode *node, Node *escontext) { long\t\tresult; char\t\tcopy[DCH_MAX_ITEM_SIZ + 1]; const char *init = *src; int\t\t\tused;...","count":9},{"name":"api-example","value":"static int interval_cmp_internal(const Interval *interval1, const Interval *interval2) { INT128\t\tspan1 = interval_cmp_value(interval1); INT128\t\tspan2 = interval_cmp_value(interval2); return int128_com...","count":9},{"name":"api-example","value":"static int pltcl_elog(ClientData cdata, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) { volatile int level; MemoryContext oldcontext; int\t\t\tpriIndex; static const char *logpriorities[] = { \"DEB...","count":9},{"name":"api-example","value":"static int r_aditzak(struct SN_env * z) { int among_var; z->ket = z->c; if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((70566434 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0; among_var = find_am...","count":9},{"name":"api-example","value":"static relopt_gen * allocate_reloption(bits32 kinds, int type, const char *name, const char *desc, LOCKMODE lockmode) { MemoryContext oldcxt; size_t\t\tsize; relopt_gen *newoption; if (kinds != RELOPT_K...","count":9},{"name":"api-example","value":"static relopt_string * init_string_reloption(bits32 kinds, const char *name, const char *desc, const char *default_val, validate_string_relopt validator, fill_string_relopt filler, LOCKMODE lockmode) ...","count":9},{"name":"api-example","value":"static size_t strftime_win32(char *dst, size_t dstlen, const char *format, const struct tm *tm) { size_t\t\tlen; wchar_t\t\twformat[8];\t\t/* formats used below need 3 chars */ wchar_t\t\twbuf[MAX_L10N_DATA];...","count":9},{"name":"api-example","value":"static struct subre * parse(struct vars *v, int stopper,\t\t\t\t/* EOS or ')' */ int type,\t\t\t\t\t/* LACON (lookaround subRE) or PLAIN */ struct state *init,\t\t/* initial state */ struct state *final)\t\t/* fin...","count":9},{"name":"api-example","value":"static uint32 conv_18030_to_utf8(uint32 code) { #define conv18030(minunicode, mincode, maxcode) \\ if (code >= mincode && code <= maxcode) \\ return unicode_to_utf8word(gb_linear(code) - gb_linear(minco...","count":9},{"name":"api-example","value":"static void ATRewriteTable(AlteredTableInfo *tab, Oid OIDNewHeap, LOCKMODE lockmode) { Relation\toldrel; Relation\tnewrel; TupleDesc\toldTupDesc; TupleDesc\tnewTupDesc; bool\t\tneedscan = false; List\t   *no...","count":9},{"name":"api-example","value":"static void AfterTriggerExecute(EState *estate, AfterTriggerEvent event, ResultRelInfo *relInfo, ResultRelInfo *src_relInfo, ResultRelInfo *dst_relInfo, TriggerDesc *trigdesc, FmgrInfo *finfo, Instrum...","count":9},{"name":"api-example","value":"static void AlterSubscription_refresh(Subscription *sub, bool copy_data, List *validate_publications) { char\t   *err; List\t   *pubrel_names; List\t   *subrel_states; Oid\t\t   *subrel_local_oids; Oid\t\t  ...","count":9},{"name":"api-example","value":"static void ComputeIndexAttrs(IndexInfo *indexInfo, Oid *typeOids, Oid *collationOids, Oid *opclassOids, Datum *opclassOptions, int16 *colOptions, const List *attList,\t/* list of IndexElem's */ const ...","count":9},{"name":"api-example","value":"static void CopySendEndOfRow(CopyToState cstate) { StringInfo\tfe_msgbuf = cstate->fe_msgbuf; switch (cstate->copy_dest) { case COPY_FILE: if (!cstate->opts.binary) { #ifndef WIN32 CopySendChar(cstate,...","count":9},{"name":"api-example","value":"static void DCH_from_char(FormatNode *node, const char *in, TmFromChar *out, Oid collid, bool std, Node *escontext) { FormatNode *n; const char *s; int\t\t\tlen, value; bool\t\tfx_mode = std; int\t\t\textra_s...","count":9},{"name":"api-example","value":"static void DecodeInsert(LogicalDecodingContext *ctx, XLogRecordBuffer *buf) { Size\t\tdatalen; char\t   *tupledata; Size\t\ttuplelen; XLogReaderState *r = buf->record; xl_heap_insert *xlrec; ReorderBuffer...","count":9},{"name":"api-example","value":"static void ECPGnoticeReceiver(void *arg, const PGresult *result) { char\t   *sqlstate = PQresultErrorField(result, PG_DIAG_SQLSTATE); char\t   *message = PQresultErrorField(result, PG_DIAG_MESSAGE_PRIM...","count":9},{"name":"api-example","value":"static void ECPGnumeric_lvalue(char *name) { const struct variable *v = find_variable(name); switch (v->type->type) { case ECPGt_short: case ECPGt_int: case ECPGt_long: case ECPGt_long_long: case ECPG...","count":9},{"name":"api-example","value":"static void GXactLoadSubxactData(GlobalTransaction gxact, int nsubxacts, TransactionId *children) { PGPROC\t   *proc = GetPGProcByNumber(gxact->pgprocno); if (nsubxacts > PGPROC_MAX_CACHED_SUBXIDS) { p...","count":9},{"name":"api-example","value":"static void InvalidateBuffer(BufferDesc *buf) { BufferTag\toldTag; uint32\t\toldHash;\t\t/* hash value for oldTag */ LWLock\t   *oldPartitionLock;\t/* buffer partition lock for it */ uint32\t\toldFlags; uint32...","count":9},{"name":"api-example","value":"static void SendNegotiateProtocolVersion(List *unrecognized_protocol_options) { StringInfoData buf; ListCell   *lc; pq_beginmessage(&buf, PqMsg_NegotiateProtocolVersion); pq_sendint32(&buf, PG_PROTOCO...","count":9},{"name":"api-example","value":"static void SetXidCommitTsInPage(TransactionId xid, int nsubxids, TransactionId *subxids, TimestampTz ts, RepOriginId nodeid, int64 pageno) { LWLock\t   *lock = SimpleLruGetBankLock(CommitTsCtl, pageno...","count":9},{"name":"api-example","value":"static void SummarizeOldestCommittedSxact(void) { SERIALIZABLEXACT *sxact; LWLockAcquire(SerializableFinishedListLock, LW_EXCLUSIVE); * This function is only called if there are no sxact slots availab...","count":9},{"name":"api-example","value":"static void WalSndWriteData(LogicalDecodingContext *ctx, XLogRecPtr lsn, TransactionId xid, bool last_write) { TimestampTz now; * Fill the send timestamp last, so that it is taken as late as possible....","count":9},{"name":"api-example","value":"static void ZeroAndLockBuffer(Buffer buffer, ReadBufferMode mode, bool already_valid) { BufferDesc *bufHdr; bool\t\tneed_to_zero; bool\t\tisLocalBuf = BufferIsLocal(buffer); Assert(mode == RBM_ZERO_AND_LO...","count":9},{"name":"api-example","value":"static void appendJSONKeyValueFmt(StringInfo buf, const char *key, bool escape_key, const char *fmt,...) { int\t\t\tsave_errno = errno; size_t\t\tlen = 128;\t\t/* initial assumption about buffer size */ char...","count":9},{"name":"api-example","value":"static void apply_handle_prepare(StringInfo s) { LogicalRepPreparedTxnData prepare_data; logicalrep_read_prepare(s, &prepare_data); if (prepare_data.prepare_lsn != remote_final_lsn) ereport(ERROR, (er...","count":9},{"name":"api-example","value":"static void bbsink_copystream_archive_contents(bbsink *sink, size_t len) { bbsink_copystream *mysink = (bbsink_copystream *) sink; bbsink_state *state = mysink->base.bbs_state; StringInfoData buf; uin...","count":9},{"name":"api-example","value":"static void brinbuildCallback(Relation index, ItemPointer tid, Datum *values, bool *isnull, bool tupleIsAlive, void *brstate) { BrinBuildState *state = (BrinBuildState *) brstate; BlockNumber thisbloc...","count":9},{"name":"api-example","value":"static void check_ident_usermap(IdentLine *identLine, const char *usermap_name, const char *pg_user, const char *system_user, bool case_insensitive, bool *found_p, bool *error_p) { Oid\t\t\troleid; *foun...","count":9},{"name":"api-example","value":"static void compute_bucket(Numeric operand, Numeric bound1, Numeric bound2, const NumericVar *count_var, bool reversed_bounds, NumericVar *result_var) { NumericVar\tbound1_var; NumericVar\tbound2_var; N...","count":9},{"name":"api-example","value":"static void dataPlaceToPageLeafSplit(disassembledLeaf *leaf, ItemPointerData lbound, ItemPointerData rbound, Page lpage, Page rpage) { char\t   *ptr; int\t\t\tsegsize; int\t\t\tlsize; int\t\t\trsize; dlist_node...","count":9},{"name":"api-example","value":"static void dumpLO(Archive *fout, const LoInfo *loinfo) { PQExpBuffer cquery = createPQExpBuffer(); * The \"definition\" is just a newline-separated list of OIDs.  We need to * put something into the dr...","count":9},{"name":"api-example","value":"static void dumpTableData(Archive *fout, const TableDataInfo *tdinfo) { DumpOptions *dopt = fout->dopt; TableInfo  *tbinfo = tdinfo->tdtable; PQExpBuffer copyBuf = createPQExpBuffer(); PQExpBuffer cli...","count":9},{"name":"api-example","value":"static void entryLoadMoreItems(GinState *ginstate, GinScanEntry entry, ItemPointerData advancePast) { Page\t\tpage; int\t\t\ti; bool\t\tstepright; if (!BufferIsValid(entry->buffer)) { entry->isFinished = tru...","count":9},{"name":"api-example","value":"static void exec_simple_query(const char *query_string) { CommandDest dest = whereToSendOutput; MemoryContext oldcontext; List\t   *parsetree_list; ListCell   *parsetree_item; bool\t\tsave_log_statement_...","count":9},{"name":"api-example","value":"static void handle_sig_alarm(SIGNAL_ARGS) { * Bump the holdoff counter, to make sure nothing we call will process * interrupts directly. No timeout handler should do that, but these * failures are har...","count":9},{"name":"api-example","value":"static void heapam_index_validate_scan(Relation heapRelation, Relation indexRelation, IndexInfo *indexInfo, Snapshot snapshot, ValidateIndexState *state) { TableScanDesc scan; HeapScanDesc hscan; Heap...","count":9},{"name":"api-example","value":"static void index_update_stats(Relation rel, bool hasindex, double reltuples) { bool\t\tupdate_stats; BlockNumber relpages = 0;\t/* keep compiler quiet */ BlockNumber relallvisible = 0; Oid\t\t\trelid = Rel...","count":9},{"name":"api-example","value":"static void libpqrcv_check_conninfo(const char *conninfo, bool must_use_password) { PQconninfoOption *opts = NULL; PQconninfoOption *opt; char\t   *err = NULL; opts = PQconninfoParse(conninfo, &err); i...","count":9},{"name":"api-example","value":"static void libpqrcv_endstreaming(WalReceiverConn *conn, TimeLineID *next_tli) { PGresult   *res; * Send copy-end message.  As in libpqrcv_PQexec, this could theoretically * block, but the risk seems ...","count":9},{"name":"api-example","value":"static void logicalrep_launcher_attach_dshmem(void) { MemoryContext oldcontext; if (LogicalRepCtx->last_start_dsh != DSHASH_HANDLE_INVALID && last_start_times != NULL) return; LWLockAcquire(LogicalRep...","count":9},{"name":"api-example","value":"static void movedb(const char *dbname, const char *tblspcname) { Oid\t\t\tdb_id; Relation\tpgdbrel; int\t\t\tnotherbackends; int\t\t\tnpreparedxacts; HeapTuple\toldtuple, newtuple; Oid\t\t\tsrc_tblspcoid, dst_tblsp...","count":9},{"name":"api-example","value":"static void parse_extension_control_file(ExtensionControlFile *control, const char *version) { char\t   *filename; FILE\t   *file; ConfigVariable *item, *head = NULL, *tail = NULL; * Locate the file to ...","count":9},{"name":"api-example","value":"static void parse_format(FormatNode *node, const char *str, const KeyWord *kw, const KeySuffix *suf, const int *index, uint32 flags, NUMDesc *Num) { FormatNode *n; #ifdef DEBUG_TO_FROM_CHAR elog(DEBUG...","count":9},{"name":"api-example","value":"static void parse_one_reloption(relopt_value *option, char *text_str, int text_len, bool validate) { char\t   *value; int\t\t\tvalue_len; bool\t\tparsed; bool\t\tnofree = false; if (option->isset && validate)...","count":9},{"name":"api-example","value":"static void pgstat_build_snapshot(void) { dshash_seq_status hstat; PgStatShared_HashEntry *p; Assert(pgstat_fetch_consistency == PGSTAT_FETCH_CONSISTENCY_SNAPSHOT); if (pgStatLocal.snapshot.mode == PG...","count":9},{"name":"api-example","value":"static void range_deduplicate_values(Ranges *range) { int\t\t\ti, n; int\t\t\tstart; compare_context cxt; * If there are no unsorted values, we're done (this probably can't * happen, as we're adding values ...","count":9},{"name":"api-example","value":"static void selectDumpableNamespace(NamespaceInfo *nsinfo, Archive *fout) { * DUMP_COMPONENT_DEFINITION typically implies a CREATE SCHEMA statement * and (for --clean) a DROP SCHEMA statement.  (In th...","count":9},{"name":"api-example","value":"static void set_using_names(deparse_namespace *dpns, Node *jtnode, List *parentUsing) { if (IsA(jtnode, RangeTblRef)) { } else if (IsA(jtnode, FromExpr)) { FromExpr   *f = (FromExpr *) jtnode; ListCel...","count":9},{"name":"api-example","value":"static void setup_connection(Archive *AH, const char *dumpencoding, const char *dumpsnapshot, char *use_role) { DumpOptions *dopt = AH->dopt; PGconn\t   *conn = GetConnection(AH); const char *std_strin...","count":9},{"name":"api-example","value":"static void sha1_pad(pg_sha1_ctx *ctx) { size_t\t\tpadlen;\t\t\t/* pad length in bytes */ size_t\t\tpadstart; PUTPAD(0x80); padstart = COUNT % 64; padlen = 64 - padstart; if (padlen < 8) { memset(&ctx->m.b8[...","count":9},{"name":"api-example","value":"static void sha1_step(pg_sha1_ctx *ctx) { uint32\t\ta, b, c, d, e; size_t\t\tt, s; uint32\t\ttmp; #ifndef WORDS_BIGENDIAN pg_sha1_ctx tctx; memmove(&tctx.m.b8[0], &ctx->m.b8[0], 64); ctx->m.b8[0] = tctx.m.b...","count":9},{"name":"api-example","value":"static void shiftList(Relation index, Buffer metabuffer, BlockNumber newHead, bool fill_fsm, IndexBulkDeleteResult *stats) { Page\t\tmetapage; GinMetaPageData *metadata; BlockNumber blknoToDelete; metap...","count":9},{"name":"api-example","value":"static void show_plan_tlist(PlanState *planstate, List *ancestors, ExplainState *es) { Plan\t   *plan = planstate->plan; List\t   *context; List\t   *result = NIL; bool\t\tuseprefix; ListCell   *lc; if (pl...","count":9},{"name":"api-example","value":"static void startup_hacks(const char *progname) { * Windows-specific execution environment hacking. */ #ifdef WIN32 { WSADATA\t\twsaData; int\t\t\terr; setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NUL...","count":9},{"name":"api-example","value":"static void test_sync(int writes_per_op) { int\t\t\ttmpfile, ops, writes; bool\t\tfs_warning = false; if (writes_per_op == 1) printf(_(\"\\nCompare file sync methods using one %dkB write:\\n\"), XLOG_BLCKSZ_K)...","count":9},{"name":"api-example","value":"static void tokenize_include_file(const char *outer_filename, const char *inc_filename, List **tok_lines, int elevel, int depth, bool missing_ok, char **err_msg) { char\t   *inc_fullname; FILE\t   *inc_...","count":9},{"name":"api-example","value":"static void tts_virtual_clear(TupleTableSlot *slot) { if (unlikely(TTS_SHOULDFREE(slot))) { VirtualTupleTableSlot *vslot = (VirtualTupleTableSlot *) slot; pfree(vslot->data); vslot->data = NULL; slot-...","count":9},{"name":"api-example","value":"static void writezone(const char *const name, const char *const string, char version, int defaulttype) { FILE\t   *fp; ptrdiff_t\ti, j; int\t\t\tpass; static const struct tzhead tzh0; static struct tzhead ...","count":9},{"name":"api-example","value":"static void xact_desc_commit(StringInfo buf, uint8 info, xl_xact_commit *xlrec, RepOriginId origin_id) { xl_xact_parsed_commit parsed; ParseCommitRecord(info, xlrec, &parsed); if (TransactionIdIsValid...","count":9},{"name":"api-example","value":"uint32 _hash_init(Relation rel, double num_tuples, ForkNumber forkNum) { Buffer\t\tmetabuf; Buffer\t\tbuf; Buffer\t\tbitmapbuf; Page\t\tpg; HashMetaPage metap; RegProcedure procid; int32\t\tdata_width; int32\t\ti...","count":9},{"name":"api-example","value":"unsigned char * pg_do_encoding_conversion(unsigned char *src, int len, int src_encoding, int dest_encoding) { unsigned char *result; Oid\t\t\tproc; if (len <= 0) return src;\t\t\t\t/* empty string is always ...","count":9},{"name":"api-example","value":"unsigned short BIG5toCNS(unsigned short big5, unsigned char *lc) { unsigned short cns = 0; int\t\t\ti; if (big5 < 0xc940U) { for (i = 0; i < sizeof(b1c4) / (sizeof(unsigned short) * 2); i++) { if (b1c4[i...","count":9},{"name":"api-example","value":"void * pgstat_fetch_entry(PgStat_Kind kind, Oid dboid, Oid objoid) { PgStat_HashKey key; PgStat_EntryRef *entry_ref; void\t   *stats_data; const PgStat_KindInfo *kind_info = pgstat_get_kind_info(kind);...","count":9},{"name":"api-example","value":"void AdvanceNextFullTransactionIdPastXid(TransactionId xid) { FullTransactionId newNextFullXid; TransactionId next_xid; uint32\t\tepoch; * It is safe to read nextXid without a lock, because this is only...","count":9},{"name":"api-example","value":"void AllocSetFree(void *pointer) { AllocSet\tset; MemoryChunk *chunk = PointerGetMemoryChunk(pointer); VALGRIND_MAKE_MEM_DEFINED(chunk, ALLOC_CHUNKHDRSZ); if (MemoryChunkIsExternal(chunk)) { AllocBlock...","count":9},{"name":"api-example","value":"void AllocSetReset(MemoryContext context) { AllocSet\tset = (AllocSet) context; AllocBlock\tblock; Size\t\tkeepersize PG_USED_FOR_ASSERTS_ONLY; Assert(AllocSetIsValid(set)); #ifdef MEMORY_CONTEXT_CHECKING...","count":9},{"name":"api-example","value":"void AlterSystemSetConfigFile(AlterSystemStmt *altersysstmt) { char\t   *name; char\t   *value; bool\t\tresetall = false; ConfigVariable *head = NULL; ConfigVariable *tail = NULL; volatile int Tmpfd; char...","count":9},{"name":"api-example","value":"void BootStrapXLOG(void) { CheckPoint\tcheckPoint; char\t   *buffer; XLogPageHeader page; XLogLongPageHeader longpage; XLogRecord *record; char\t   *recptr; uint64\t\tsysidentifier; struct timeval tv; pg_c...","count":9},{"name":"api-example","value":"void DoCopy(ParseState *pstate, const CopyStmt *stmt, int stmt_location, int stmt_len, uint64 *processed) { bool\t\tis_from = stmt->is_from; bool\t\tpipe = (stmt->filename == NULL); Relation\trel; Oid\t\t\tre...","count":9},{"name":"api-example","value":"void EndCopyTo(CopyToState cstate) { if (cstate->queryDesc != NULL) { ExecutorFinish(cstate->queryDesc); ExecutorEnd(cstate->queryDesc); FreeQueryDesc(cstate->queryDesc); PopActiveSnapshot(); } EndCop...","count":9},{"name":"api-example","value":"void EndPrepare(GlobalTransaction gxact) { TwoPhaseFileHeader *hdr; StateFileChunk *record; bool\t\treplorigin; RegisterTwoPhaseRecord(TWOPHASE_RM_END_ID, 0, NULL, 0); hdr = (TwoPhaseFileHeader *) recor...","count":9},{"name":"api-example","value":"void ExecBSInsertTriggers(EState *estate, ResultRelInfo *relinfo) { TriggerDesc *trigdesc; int\t\t\ti; TriggerData LocTriggerData = {0}; trigdesc = relinfo->ri_TrigDesc; if (trigdesc == NULL) return; if ...","count":9},{"name":"api-example","value":"void ExecChooseHashTableSize(double ntuples, int tupwidth, bool useskew, bool try_combined_hash_mem, int parallel_workers, size_t *space_allowed, int *numbuckets, int *numbatches, int *num_skew_mcvs) ...","count":9},{"name":"api-example","value":"void HeapCheckForSerializableConflictOut(bool visible, Relation relation, HeapTuple tuple, Buffer buffer, Snapshot snapshot) { TransactionId xid; HTSV_Result htsvResult; if (!CheckForSerializableConfl...","count":9},{"name":"api-example","value":"void InitArchiveFmt_Tar(ArchiveHandle *AH) { lclContext *ctx; AH->ArchiveEntryPtr = _ArchiveEntry; AH->StartDataPtr = _StartData; AH->WriteDataPtr = _WriteData; AH->EndDataPtr = _EndData; AH->WriteByt...","count":9},{"name":"api-example","value":"void InitBufferPool(void) { bool\t\tfoundBufs, foundDescs, foundIOCV, foundBufCkpt; BufferDescriptors = (BufferDescPadded *) ShmemInitStruct(\"Buffer Descriptors\", NBuffers * sizeof(BufferDescPadded), &f...","count":9},{"name":"api-example","value":"void MarkBufferDirty(Buffer buffer) { BufferDesc *bufHdr; uint32\t\tbuf_state; uint32\t\told_buf_state; if (!BufferIsValid(buffer)) elog(ERROR, \"bad buffer ID: %d\", buffer); if (BufferIsLocal(buffer)) { M...","count":9},{"name":"api-example","value":"void RelationCopyStorage(SMgrRelation src, SMgrRelation dst, ForkNumber forkNum, char relpersistence) { bool\t\tuse_wal; bool\t\tcopying_initfork; BlockNumber nblocks; BlockNumber blkno; BulkWriteState *b...","count":9},{"name":"api-example","value":"void ReorderBufferReturnChange(ReorderBuffer *rb, ReorderBufferChange *change, bool upd_mem) { if (upd_mem) ReorderBufferChangeMemoryUpdate(rb, change, NULL, false, ReorderBufferChangeSize(change)); s...","count":9},{"name":"api-example","value":"void ReplicationSlotCreate(const char *name, bool db_specific, ReplicationSlotPersistency persistency, bool two_phase, bool failover, bool synced) { ReplicationSlot *slot = NULL; int\t\t\ti; Assert(MyRep...","count":9},{"name":"api-example","value":"void ResolveRecoveryConflictWithLock(LOCKTAG locktag, bool logging_conflict) { TimestampTz ltime; TimestampTz now; Assert(InHotStandby); ltime = GetStandbyLimitTime(); now = GetCurrentTimestamp(); * U...","count":9},{"name":"api-example","value":"void ShutdownXLOG(int code, Datum arg) { * We should have an aux process resource owner to use, and we should not * be in a transaction that's installed some other resowner. */ Assert(AuxProcessResour...","count":9},{"name":"api-example","value":"void StartTransactionCommand(void) { TransactionState s = CurrentTransactionState; switch (s->blockState) { * if we aren't in a transaction block, we just do our usual start * transaction. */ case TBL...","count":9},{"name":"api-example","value":"void StorePartitionKey(Relation rel, char strategy, int16 partnatts, AttrNumber *partattrs, List *partexprs, Oid *partopclass, Oid *partcollation) { int\t\t\ti; int2vector *partattrs_vec; oidvector  *par...","count":9},{"name":"api-example","value":"void SyncRepWaitForLSN(XLogRecPtr lsn, bool commit) { int\t\t\tmode; * This should be called while holding interrupts during a transaction * commit to prevent the follow-up shared memory queue cleanups t...","count":9},{"name":"api-example","value":"void XLogFlush(XLogRecPtr record) { XLogRecPtr\tWriteRqstPtr; XLogwrtRqst WriteRqst; TimeLineID\tinsertTLI = XLogCtl->InsertTimeLineID; * During REDO, we are reading not writing WAL.  Therefore, instead...","count":9},{"name":"api-example","value":"void _h_indexbuild(HSpool *hspool, Relation heapRel) { IndexTuple\titup; int64\t\ttups_done = 0; #ifdef USE_ASSERT_CHECKING uint32\t\thashkey = 0; #endif tuplesort_performsort(hspool->sortstate); while ((i...","count":9},{"name":"api-example","value":"void analyze_rel(Oid relid, RangeVar *relation, VacuumParams *params, List *va_cols, bool in_outer_xact, BufferAccessStrategy bstrategy) { Relation\tonerel; int\t\t\televel; AcquireSampleRowsFunc acquiref...","count":9},{"name":"api-example","value":"void cache_locale_time(void) { char\t\tbuf[(2 * 7 + 2 * 12) * MAX_L10N_DATA]; char\t   *bufptr; time_t\t\ttimenow; struct tm  *timeinfo; bool\t\tstrftimefail = false; int\t\t\tencoding; int\t\t\ti; char\t   *save_l...","count":9},{"name":"api-example","value":"void cost_seqscan(Path *path, PlannerInfo *root, RelOptInfo *baserel, ParamPathInfo *param_info) { Cost\t\tstartup_cost = 0; Cost\t\tcpu_run_cost; Cost\t\tdisk_run_cost; double\t\tspc_seq_page_cost; QualCost\t...","count":9},{"name":"api-example","value":"void dsm_shmem_init(void) { size_t\t\tsize = dsm_estimate_size(); bool\t\tfound; if (size == 0) return; dsm_main_space_begin = ShmemInitStruct(\"Preallocated DSM\", size, &found); if (!found) { FreePageMana...","count":9},{"name":"api-example","value":"void generate_useful_gather_paths(PlannerInfo *root, RelOptInfo *rel, bool override_rows) { ListCell   *lc; double\t\trows; double\t   *rowsp = NULL; List\t   *useful_pathkeys_list = NIL; Path\t   *cheapes...","count":9},{"name":"api-example","value":"void get_control_data(ClusterInfo *cluster, bool live_check) { char\t\tcmd[MAXPGPATH]; char\t\tbufin[MAX_STRING]; FILE\t   *output; char\t   *p; bool\t\tgot_tli = false; bool\t\tgot_log_id = false; bool\t\tgot_lo...","count":9},{"name":"api-example","value":"void hashadjustmembers(Oid opfamilyoid, Oid opclassoid, List *operators, List *functions) { Oid\t\t\topcintype; ListCell   *lc; * Hash operators and required support functions are always \"loose\" * member...","count":9},{"name":"api-example","value":"void heap_drop_with_catalog(Oid relid) { Relation\trel; HeapTuple\ttuple; Oid\t\t\tparentOid = InvalidOid, defaultPartOid = InvalidOid; * To drop a partition safely, we must grab exclusive lock on its pare...","count":9},{"name":"api-example","value":"void heap_fetch_toast_slice(Relation toastrel, Oid valueid, int32 attrsize, int32 sliceoffset, int32 slicelength, struct varlena *result) { Relation   *toastidxs; ScanKeyData toastkey[3]; TupleDesc\tto...","count":9},{"name":"api-example","value":"void heap_finish_speculative(Relation relation, ItemPointer tid) { Buffer\t\tbuffer; Page\t\tpage; OffsetNumber offnum; ItemId\t\tlp = NULL; HeapTupleHeader htup; buffer = ReadBuffer(relation, ItemPointerGe...","count":9},{"name":"api-example","value":"void heap_mask(char *pagedata, BlockNumber blkno) { Page\t\tpage = (Page) pagedata; OffsetNumber off; mask_page_lsn_and_checksum(page); mask_page_hint_bits(page); mask_unused_space(page); for (off = 1; ...","count":9},{"name":"api-example","value":"void mdcreate(SMgrRelation reln, ForkNumber forknum, bool isRedo) { MdfdVec    *mdfd; char\t   *path; File\t\tfd; if (isRedo && reln->md_num_open_segs[forknum] > 0) return;\t\t\t\t\t/* created and opened alre...","count":9},{"name":"api-example","value":"void performDeletion(const ObjectAddress *object, DropBehavior behavior, int flags) { Relation\tdepRel; ObjectAddresses *targetObjects; * We save some cycles by opening pg_depend just once and passing ...","count":9},{"name":"api-example","value":"void pg_store_delegated_credential(gss_cred_id_t cred) { OM_uint32\tmajor, minor; gss_OID_set mech; gss_cred_usage_t usage; gss_key_value_element_desc cc; gss_key_value_set_desc ccset; cc.key = \"ccache...","count":9},{"name":"api-example","value":"void pqinitmask(void) { sigemptyset(&UnBlockSig); sigfillset(&BlockSig); sigfillset(&StartupBlockSig); * Unmark those signals that should never be blocked. Some of these signal * names don't exist on ...","count":9},{"name":"api-example","value":"void sendAuthRequest(Port *port, AuthRequest areq, const char *extradata, int extralen) { StringInfoData buf; CHECK_FOR_INTERRUPTS(); pq_beginmessage(&buf, PqMsg_AuthenticationRequest); pq_sendint32(&...","count":9},{"name":"api-example","value":"void set_option(char *arg) { struct\tpro *p; const char\t*param_start; arg++;\t\t\t/* ignore leading \"-\" */ for (p = pro; p->p_name; p++) if (*p->p_name == *arg && (param_start = eqin(p->p_name, arg)) != N...","count":9},{"name":"api-example","value":"void slist_delete(slist_head *head, const slist_node *node) { slist_node *last = &head->head; slist_node *cur; bool\t\tfound PG_USED_FOR_ASSERTS_ONLY = false; while ((cur = last->next) != NULL) { if (cu...","count":9},{"name":"api-example","value":"void standard_ProcessUtility(PlannedStmt *pstmt, const char *queryString, bool readOnlyTree, ProcessUtilityContext context, ParamListInfo params, QueryEnvironment *queryEnv, DestReceiver *dest, QueryC...","count":9},{"name":"api-example","value":"void write_csvlog(ErrorData *edata) { StringInfoData buf; bool\t\tprint_stmt = false; static long log_line_number = 0; static int\tlog_my_pid = 0; * This is one of the few places where we'd rather not in...","count":9},{"name":"arch-sublayer","value":"heap","count":9},{"name":"arch-sublayer","value":"lock-manager","count":9},{"name":"Feature","value":"Cross datatype hashing support","count":8},{"name":"Feature","value":"DROP object IF EXISTS","count":8},{"name":"Feature","value":"Indexes on expressions","count":8},{"name":"Feature","value":"SCRAM-SHA-256 Authentication","count":8},{"name":"Feature","value":"Server statistics in shared memory","count":8},{"name":"Feature","value":"pg_createsubscriber","count":8},{"name":"api-caller-count","value":"10223","count":8},{"name":"api-caller-count","value":"1055","count":8},{"name":"api-caller-count","value":"115","count":8},{"name":"api-caller-count","value":"118","count":8},{"name":"api-caller-count","value":"119","count":8},{"name":"api-caller-count","value":"121","count":8},{"name":"api-caller-count","value":"129","count":8},{"name":"api-caller-count","value":"135","count":8},{"name":"api-caller-count","value":"137","count":8},{"name":"api-caller-count","value":"141","count":8},{"name":"api-caller-count","value":"1477","count":8},{"name":"api-caller-count","value":"1517","count":8},{"name":"api-caller-count","value":"161","count":8},{"name":"api-caller-count","value":"166","count":8},{"name":"api-caller-count","value":"173","count":8},{"name":"api-caller-count","value":"174","count":8},{"name":"api-caller-count","value":"177","count":8},{"name":"api-caller-count","value":"210","count":8},{"name":"api-caller-count","value":"212","count":8},{"name":"api-caller-count","value":"213","count":8},{"name":"api-caller-count","value":"216","count":8},{"name":"api-caller-count","value":"222","count":8},{"name":"api-caller-count","value":"236","count":8},{"name":"api-caller-count","value":"239","count":8},{"name":"api-caller-count","value":"247","count":8},{"name":"api-caller-count","value":"249","count":8},{"name":"api-caller-count","value":"279","count":8},{"name":"api-caller-count","value":"291","count":8},{"name":"api-caller-count","value":"305","count":8},{"name":"api-caller-count","value":"320","count":8},{"name":"api-caller-count","value":"327","count":8},{"name":"api-caller-count","value":"4028","count":8},{"name":"api-caller-count","value":"433","count":8},{"name":"api-caller-count","value":"458","count":8},{"name":"api-caller-count","value":"459","count":8},{"name":"api-caller-count","value":"566","count":8},{"name":"api-caller-count","value":"592","count":8},{"name":"api-caller-count","value":"621","count":8},{"name":"api-caller-count","value":"637","count":8},{"name":"api-caller-count","value":"6440","count":8},{"name":"api-caller-count","value":"680","count":8},{"name":"api-caller-count","value":"792","count":8},{"name":"api-caller-count","value":"812","count":8},{"name":"api-caller-count","value":"88","count":8},{"name":"api-caller-count","value":"978","count":8},{"name":"api-caller-count","value":"9848","count":8},{"name":"api-caller-count","value":"988","count":8},{"name":"api-typical-usage","value":"Often called from: ATExecAddColumn","count":8},{"name":"api-typical-usage","value":"Often called from: ATExecAttachPartitionIdx","count":8},{"name":"api-typical-usage","value":"Often called from: AbortCurrentTransactionInternal","count":8},{"name":"api-typical-usage","value":"Often called from: AbsoluteConfigLocation","count":8},{"name":"api-typical-usage","value":"Often called from: AddFileToBackupManifest","count":8},{"name":"api-typical-usage","value":"Often called from: AfterTriggerEndSubXact","count":8},{"name":"api-typical-usage","value":"Often called from: AllocSetAllocFromNewBlock","count":8},{"name":"api-typical-usage","value":"Often called from: AlterObjectOwner_internal","count":8},{"name":"api-typical-usage","value":"Often called from: AlterPolicy","count":8},{"name":"api-typical-usage","value":"Often called from: AlterPublicationOptions","count":8},{"name":"api-typical-usage","value":"Often called from: BTreeTupleIsPosting","count":8},{"name":"api-typical-usage","value":"Often called from: BackgroundWorkerInitializeConnectionByOid","count":8},{"name":"api-typical-usage","value":"Often called from: BlockRefTableEntryMarkBlockModified","count":8},{"name":"api-typical-usage","value":"Often called from: BlockRefTableWrite","count":8},{"name":"api-typical-usage","value":"Often called from: BufferGetTag","count":8},{"name":"api-typical-usage","value":"Often called from: CheckpointerMain","count":8},{"name":"api-typical-usage","value":"Often called from: ClassifyUtilityCommandAsReadOnly","count":8},{"name":"api-typical-usage","value":"Often called from: CleanupTempFiles","count":8},{"name":"api-typical-usage","value":"Often called from: ClearOldPredicateLocks","count":8},{"name":"api-typical-usage","value":"Often called from: ClientAuthentication","count":8},{"name":"api-typical-usage","value":"Often called from: ComputeIndexAttrs","count":8},{"name":"api-typical-usage","value":"Often called from: ConditionVariableBroadcast","count":8},{"name":"api-typical-usage","value":"Often called from: ConditionalLockRelation","count":8},{"name":"api-typical-usage","value":"Often called from: CopyMultiInsertBufferFlush","count":8},{"name":"api-typical-usage","value":"Often called from: Cover","count":8},{"name":"api-typical-usage","value":"Often called from: CreateCast","count":8},{"name":"api-typical-usage","value":"Often called from: CreateCommandTag","count":8},{"name":"api-typical-usage","value":"Often called from: CreateExtensionInternal","count":8},{"name":"api-typical-usage","value":"Often called from: CreatePolicy","count":8},{"name":"api-typical-usage","value":"Often called from: CreateRestartPoint","count":8},{"name":"api-typical-usage","value":"Often called from: CreateRole","count":8},{"name":"api-typical-usage","value":"Often called from: CreateSharedBackendStatus","count":8},{"name":"api-typical-usage","value":"Often called from: DateTimeParseError","count":8},{"name":"api-typical-usage","value":"Often called from: DatumGetInetPP","count":8},{"name":"api-typical-usage","value":"Often called from: DecodeNumber","count":8},{"name":"api-typical-usage","value":"Often called from: DecodeTimezone","count":8},{"name":"api-typical-usage","value":"Often called from: DefineAggregate","count":8},{"name":"api-typical-usage","value":"Often called from: DefineCustomBoolVariable","count":8},{"name":"api-typical-usage","value":"Often called from: DefineOpClass","count":8},{"name":"api-typical-usage","value":"Often called from: DefineQueryRewrite","count":8},{"name":"api-typical-usage","value":"Often called from: DetachPartitionFinalize","count":8},{"name":"api-typical-usage","value":"Often called from: DropRole","count":8},{"name":"api-typical-usage","value":"Often called from: ECPGdebug","count":8},{"name":"api-typical-usage","value":"Often called from: ECPGdescribe","count":8},{"name":"api-typical-usage","value":"Often called from: ECPGset_var","count":8},{"name":"api-typical-usage","value":"Often called from: EvalPlanQualEnd","count":8},{"name":"api-typical-usage","value":"Often called from: ExecAlterDefaultPrivilegesStmt","count":8},{"name":"api-typical-usage","value":"Often called from: ExecBuildAggTrans","count":8},{"name":"api-typical-usage","value":"Often called from: ExecEndAgg","count":8},{"name":"api-typical-usage","value":"Often called from: ExecEndBitmapHeapScan","count":8},{"name":"api-typical-usage","value":"Often called from: ExecEvalConvertRowtype","count":8},{"name":"api-typical-usage","value":"Often called from: ExecEvalFuncExprFusage","count":8},{"name":"api-typical-usage","value":"Often called from: ExecEvalJsonExprPath","count":8},{"name":"api-typical-usage","value":"Often called from: ExecForceStoreHeapTuple","count":8},{"name":"api-typical-usage","value":"Often called from: ExecHashSkewTableInsert","count":8},{"name":"api-typical-usage","value":"Often called from: ExecInitIncrementalSort","count":8},{"name":"api-typical-usage","value":"Often called from: ExecInitSort","count":8},{"name":"api-typical-usage","value":"Often called from: ExecInitSubPlan","count":8},{"name":"api-typical-usage","value":"Often called from: ExecInitWindowAgg","count":8},{"name":"api-typical-usage","value":"Often called from: ExecInsertIndexTuples","count":8},{"name":"api-typical-usage","value":"Often called from: ExecMemoize","count":8},{"name":"api-typical-usage","value":"Often called from: ExecModifyTable","count":8},{"name":"api-typical-usage","value":"Often called from: ExecParallelHashCloseBatchAccessors","count":8},{"name":"api-typical-usage","value":"Often called from: ExecParallelHashJoinNewBatch","count":8},{"name":"api-typical-usage","value":"Often called from: ExecSetVariableStmt","count":8},{"name":"api-typical-usage","value":"Often called from: ExecShutdownNode_walker","count":8},{"name":"api-typical-usage","value":"Often called from: FastPathGrantRelationLock","count":8},{"name":"api-typical-usage","value":"Often called from: FreePageBtreeCleanup","count":8},{"name":"api-typical-usage","value":"Often called from: GenerationContextCreate","count":8},{"name":"api-typical-usage","value":"Often called from: GenerationGetChunkContext","count":8},{"name":"api-typical-usage","value":"Often called from: GetNamedDSMSegment","count":8},{"name":"api-typical-usage","value":"Often called from: GetNewRelFileNumber","count":8},{"name":"api-typical-usage","value":"Often called from: GetXLogBuffer","count":8},{"name":"api-typical-usage","value":"Often called from: HandleChildCrash","count":8},{"name":"api-typical-usage","value":"Often called from: ImportSnapshot","count":8},{"name":"api-typical-usage","value":"Often called from: IsBinaryCoercibleWithCast","count":8},{"name":"api-typical-usage","value":"Often called from: IsThereCollationInNamespace","count":8},{"name":"api-typical-usage","value":"Often called from: IteratorConcat","count":8},{"name":"api-typical-usage","value":"Often called from: JsonbArraySize","count":8},{"name":"api-typical-usage","value":"Often called from: LexizeExec","count":8},{"name":"api-typical-usage","value":"Often called from: ListenServerPort","count":8},{"name":"api-typical-usage","value":"Often called from: LoadOutputPlugin","count":8},{"name":"api-typical-usage","value":"Often called from: LockBufHdr","count":8},{"name":"api-typical-usage","value":"Often called from: LockCheckConflicts","count":8},{"name":"api-typical-usage","value":"Often called from: LockRelease","count":8},{"name":"api-typical-usage","value":"Often called from: LogicalRepSyncTableStart","count":8},{"name":"api-typical-usage","value":"Often called from: LogicalSlotAdvanceAndCheckSnapState","count":8},{"name":"api-typical-usage","value":"Often called from: LogicalTapeWrite","count":8},{"name":"api-typical-usage","value":"Often called from: MakeConfigurationMapping","count":8},{"name":"api-typical-usage","value":"Often called from: MemoryContextAllocAligned","count":8},{"name":"api-typical-usage","value":"Often called from: MemoryContextStatsDetail","count":8},{"name":"api-typical-usage","value":"Often called from: MultiExecParallelHash","count":8},{"name":"api-typical-usage","value":"Often called from: MultiXactIdExpand","count":8},{"name":"api-typical-usage","value":"Often called from: NUM_numpart_from_char","count":8},{"name":"api-typical-usage","value":"Often called from: NormalizeSubWord","count":8},{"name":"api-typical-usage","value":"Often called from: OidFunctionCall7Coll","count":8},{"name":"api-typical-usage","value":"Often called from: OpenTemporaryFileInTablespace","count":8},{"name":"api-typical-usage","value":"Often called from: PGReserveSemaphores","count":8},{"name":"api-typical-usage","value":"Often called from: PGSemaphoreTryLock","count":8},{"name":"api-typical-usage","value":"Often called from: PGSharedMemoryCreate","count":8},{"name":"api-typical-usage","value":"Often called from: PGTYPESnumeric_from_double","count":8},{"name":"api-typical-usage","value":"Often called from: PGTYPESnumeric_to_long","count":8},{"name":"api-typical-usage","value":"Often called from: PLyList_FromArray_recurse","count":8},{"name":"api-typical-usage","value":"Often called from: PLy_cursor","count":8},{"name":"api-typical-usage","value":"Often called from: PLy_exec_trigger","count":8},{"name":"api-typical-usage","value":"Often called from: PQdescribePortal","count":8},{"name":"api-typical-usage","value":"Often called from: PQsendClosePrepared","count":8},{"name":"api-typical-usage","value":"Often called from: PortalRun","count":8},{"name":"api-typical-usage","value":"Often called from: QT2QTN","count":8},{"name":"api-typical-usage","value":"Often called from: QTNTernary","count":8},{"name":"api-typical-usage","value":"Often called from: RI_FKey_setdefault_del","count":8},{"name":"api-typical-usage","value":"Often called from: RangeVarAdjustRelationPersistence","count":8},{"name":"api-typical-usage","value":"Often called from: RangeVarGetRelidExtended","count":8},{"name":"api-typical-usage","value":"Often called from: ReadControlFile","count":8},{"name":"api-typical-usage","value":"Often called from: RecordTransactionCommit","count":8},{"name":"api-typical-usage","value":"Often called from: RecoveryRequiresIntParameter","count":8},{"name":"api-typical-usage","value":"Often called from: ReindexMultipleInternal","count":8},{"name":"api-typical-usage","value":"Often called from: RelationBuildPublicationDesc","count":8},{"name":"api-typical-usage","value":"Often called from: RelationCacheInitializePhase3","count":8},{"name":"api-typical-usage","value":"Often called from: RelationCacheInvalidate","count":8},{"name":"api-typical-usage","value":"Often called from: RelationCopyStorageUsingBuffer","count":8},{"name":"api-typical-usage","value":"Often called from: RelationMapInvalidate","count":8},{"name":"api-typical-usage","value":"Often called from: RemoveRelations","count":8},{"name":"api-typical-usage","value":"Often called from: ReorderBufferImmediateInvalidation","count":8},{"name":"api-typical-usage","value":"Often called from: ReorderBufferIterTXNNext","count":8},{"name":"api-typical-usage","value":"Often called from: ReorderBufferQueueMessage","count":8},{"name":"api-typical-usage","value":"Often called from: ReorderBufferToastReplace","count":8},{"name":"api-typical-usage","value":"Often called from: ReorderBufferTransferSnapToParent","count":8},{"name":"api-typical-usage","value":"Often called from: ReorderBufferXidSetCatalogChanges","count":8},{"name":"api-typical-usage","value":"Often called from: RewriteQuery","count":8},{"name":"api-typical-usage","value":"Often called from: SHA512_Last","count":8},{"name":"api-typical-usage","value":"Often called from: SPI_execute_plan","count":8},{"name":"api-typical-usage","value":"Often called from: SendQuery","count":8},{"name":"api-typical-usage","value":"Often called from: SerialAdd","count":8},{"name":"api-typical-usage","value":"Often called from: ServerLoop","count":8},{"name":"api-typical-usage","value":"Often called from: SetDataDirectoryCreatePerm","count":8},{"name":"api-typical-usage","value":"Often called from: SetTriggerFlags","count":8},{"name":"api-typical-usage","value":"Often called from: SharedRecordTypmodRegistryInit","count":8},{"name":"api-typical-usage","value":"Often called from: SlruInternalDeleteSegment","count":8},{"name":"api-typical-usage","value":"Often called from: SpGistGetBuffer","count":8},{"name":"api-typical-usage","value":"Often called from: StartLogStreamer","count":8},{"name":"api-typical-usage","value":"Often called from: StartReplication","count":8},{"name":"api-typical-usage","value":"Often called from: SubTransSetParent","count":8},{"name":"api-typical-usage","value":"Often called from: SyncDataDirectory","count":8},{"name":"api-typical-usage","value":"Often called from: SyncRepWaitForLSN","count":8},{"name":"api-typical-usage","value":"Often called from: TParserInit","count":8},{"name":"api-typical-usage","value":"Often called from: TransactionIdDidAbort","count":8},{"name":"api-typical-usage","value":"Often called from: TransactionIdSetTreeStatus","count":8},{"name":"api-typical-usage","value":"Often called from: UnGrantLock","count":8},{"name":"api-typical-usage","value":"Often called from: VirtualXactLock","count":8},{"name":"api-typical-usage","value":"Often called from: WALRead","count":8},{"name":"api-typical-usage","value":"Often called from: WaitEventCustomNew","count":8},{"name":"api-typical-usage","value":"Often called from: WalSndWait","count":8},{"name":"api-typical-usage","value":"Often called from: WalkInnerWith","count":8},{"name":"api-typical-usage","value":"Often called from: XLogArchiveIsBusy","count":8},{"name":"api-typical-usage","value":"Often called from: XLogDumpDisplayStats","count":8},{"name":"api-typical-usage","value":"Often called from: XLogFileInitInternal","count":8},{"name":"api-typical-usage","value":"Often called from: XactLockForVirtualXact","count":8},{"name":"api-typical-usage","value":"Often called from: XidInMVCCSnapshot","count":8},{"name":"api-typical-usage","value":"Often called from: _bt_check_natts","count":8},{"name":"api-typical-usage","value":"Often called from: _bt_check_third_page","count":8},{"name":"api-typical-usage","value":"Often called from: _bt_delitems_update","count":8},{"name":"api-typical-usage","value":"Often called from: _bt_findinsertloc","count":8},{"name":"api-typical-usage","value":"Often called from: _bt_fix_scankey_strategy","count":8},{"name":"api-typical-usage","value":"Often called from: _bt_leafbuild","count":8},{"name":"api-typical-usage","value":"Often called from: _bt_steppage","count":8},{"name":"api-typical-usage","value":"Often called from: _bt_vacuum_needs_cleanup","count":8},{"name":"api-typical-usage","value":"Often called from: _hash_finish_split","count":8},{"name":"api-typical-usage","value":"Often called from: _jumbleA_Const","count":8},{"name":"api-typical-usage","value":"Often called from: _outEquivalenceClass","count":8},{"name":"api-typical-usage","value":"Often called from: _readA_Expr","count":8},{"name":"api-typical-usage","value":"Often called from: _tarReadRaw","count":8},{"name":"api-typical-usage","value":"Often called from: _vscprintf_p_l","count":8},{"name":"api-typical-usage","value":"Often called from: _vsnprintf_s_l","count":8},{"name":"api-typical-usage","value":"Often called from: aclequal","count":8},{"name":"api-typical-usage","value":"Often called from: add_module_to_inline_search_path","count":8},{"name":"api-typical-usage","value":"Often called from: add_var","count":8},{"name":"api-typical-usage","value":"Often called from: adjust_array","count":8},{"name":"api-typical-usage","value":"Often called from: adjust_data_dir","count":8},{"name":"api-typical-usage","value":"Often called from: appendQualifiedRelation","count":8},{"name":"api-typical-usage","value":"Often called from: appendStringInfoVA","count":8},{"name":"api-typical-usage","value":"Often called from: array_agg_array_deserialize","count":8},{"name":"api-typical-usage","value":"Often called from: array_agg_array_serialize","count":8},{"name":"api-typical-usage","value":"Often called from: array_cmp","count":8},{"name":"api-typical-usage","value":"Often called from: array_eq","count":8},{"name":"api-typical-usage","value":"Often called from: arraycontained","count":8},{"name":"api-typical-usage","value":"Often called from: assign_createrole_self_grant","count":8},{"name":"api-typical-usage","value":"Often called from: be_lo_creat","count":8},{"name":"api-typical-usage","value":"Often called from: bit_catenate","count":8},{"name":"api-typical-usage","value":"Often called from: bitge","count":8},{"name":"api-typical-usage","value":"Often called from: bitshiftright","count":8},{"name":"api-typical-usage","value":"Often called from: bms_prev_member","count":8},{"name":"api-typical-usage","value":"Often called from: bootstrap_template1","count":8},{"name":"api-typical-usage","value":"Often called from: box_eq","count":8},{"name":"api-typical-usage","value":"Often called from: bpcharne","count":8},{"name":"api-typical-usage","value":"Often called from: brenext","count":8},{"name":"api-typical-usage","value":"Often called from: brinRevmapDesummarizeRange","count":8},{"name":"api-typical-usage","value":"Often called from: brin_doupdate","count":8},{"name":"api-typical-usage","value":"Often called from: btparallelrescan","count":8},{"name":"api-typical-usage","value":"Often called from: bttidcmp","count":8},{"name":"api-typical-usage","value":"Often called from: buildSubPlanHash","count":8},{"name":"api-typical-usage","value":"Often called from: build_aggregate_transfn_expr","count":8},{"name":"api-typical-usage","value":"Often called from: build_child_join_sjinfo","count":8},{"name":"api-typical-usage","value":"Often called from: build_client_first_message","count":8},{"name":"api-typical-usage","value":"Often called from: build_setop_child_paths","count":8},{"name":"api-typical-usage","value":"Often called from: cache_locale_time","count":8},{"name":"api-typical-usage","value":"Often called from: cache_record_field_properties","count":8},{"name":"api-typical-usage","value":"Often called from: calc_inet_union_params_indexed","count":8},{"name":"api-typical-usage","value":"Often called from: can_coerce_type","count":8},{"name":"api-typical-usage","value":"Often called from: cash_mul_flt8","count":8},{"name":"api-typical-usage","value":"Often called from: cash_words","count":8},{"name":"api-typical-usage","value":"Often called from: cashlarger","count":8},{"name":"api-typical-usage","value":"Often called from: check_backup_label_files","count":8},{"name":"api-typical-usage","value":"Often called from: check_locale_name","count":8},{"name":"api-typical-usage","value":"Often called from: check_role_membership_authorization","count":8},{"name":"api-typical-usage","value":"Often called from: choose_next_subplan_for_worker","count":8},{"name":"api-typical-usage","value":"Often called from: clause_is_strict_for","count":8},{"name":"api-typical-usage","value":"Often called from: cleanup_directories_atexit","count":8},{"name":"api-typical-usage","value":"Often called from: cmp","count":8},{"name":"api-typical-usage","value":"Often called from: cmp_numerics","count":8},{"name":"api-typical-usage","value":"Often called from: colorcomplement","count":8},{"name":"api-typical-usage","value":"Often called from: compare_range_partitions","count":8},{"name":"api-typical-usage","value":"Often called from: compute_return_type","count":8},{"name":"api-typical-usage","value":"Often called from: contain_mutable_functions_walker","count":8},{"name":"api-typical-usage","value":"Often called from: conv_utf8_to_18030","count":8},{"name":"api-typical-usage","value":"Often called from: convert_table_priv_string","count":8},{"name":"api-typical-usage","value":"Often called from: copy_file","count":8},{"name":"api-typical-usage","value":"Often called from: countVariablesFromJsonb","count":8},{"name":"api-typical-usage","value":"Often called from: count_nulls","count":8},{"name":"api-typical-usage","value":"Often called from: create_LifetimeEnd","count":8},{"name":"api-typical-usage","value":"Often called from: create_append_plan","count":8},{"name":"api-typical-usage","value":"Often called from: create_fullpage_directory","count":8},{"name":"api-typical-usage","value":"Often called from: create_hashjoin_plan","count":8},{"name":"api-typical-usage","value":"Often called from: create_internal","count":8},{"name":"api-typical-usage","value":"Often called from: create_list_bounds","count":8},{"name":"api-typical-usage","value":"Often called from: create_merge_append_plan","count":8},{"name":"api-typical-usage","value":"Often called from: create_mergejoin_plan","count":8},{"name":"api-typical-usage","value":"Often called from: create_subscription","count":8},{"name":"api-typical-usage","value":"Often called from: create_unique_path","count":8},{"name":"api-typical-usage","value":"Often called from: crevcondissect","count":8},{"name":"api-typical-usage","value":"Often called from: croak_cstr","count":8},{"name":"api-typical-usage","value":"Often called from: cryptohash_internal","count":8},{"name":"api-typical-usage","value":"Often called from: datand","count":8},{"name":"api-typical-usage","value":"Often called from: date_in","count":8},{"name":"api-typical-usage","value":"Often called from: date_lt","count":8},{"name":"api-typical-usage","value":"Often called from: date_pli","count":8},{"name":"api-typical-usage","value":"Often called from: daterange_canonical","count":8},{"name":"api-typical-usage","value":"Often called from: deconstruct_expanded_record","count":8},{"name":"api-typical-usage","value":"Often called from: desc_recompress_leaf","count":8},{"name":"api-typical-usage","value":"Often called from: dir_open_for_write","count":8},{"name":"api-typical-usage","value":"Often called from: div_var_fast","count":8},{"name":"api-typical-usage","value":"Often called from: dlist_delete_from_thoroughly","count":8},{"name":"api-typical-usage","value":"Often called from: dlist_is_empty","count":8},{"name":"api-typical-usage","value":"Often called from: do_compile","count":8},{"name":"api-typical-usage","value":"Often called from: do_pset","count":8},{"name":"api-typical-usage","value":"Often called from: domainAddNotNullConstraint","count":8},{"name":"api-typical-usage","value":"Often called from: dropdb","count":8},{"name":"api-typical-usage","value":"Often called from: dsm_cleanup_for_mmap","count":8},{"name":"api-typical-usage","value":"Often called from: dumpACL","count":8},{"name":"api-typical-usage","value":"Often called from: dumpDomain","count":8},{"name":"api-typical-usage","value":"Often called from: dumpTableData_insert","count":8},{"name":"api-typical-usage","value":"Often called from: dump_open","count":8},{"name":"api-typical-usage","value":"Often called from: durable_rename","count":8},{"name":"api-typical-usage","value":"Often called from: ecpg_build_params","count":8},{"name":"api-typical-usage","value":"Often called from: ecpg_raise","count":8},{"name":"api-typical-usage","value":"Often called from: error_view_not_updatable","count":8},{"name":"api-typical-usage","value":"Often called from: esc_encode","count":8},{"name":"api-typical-usage","value":"Often called from: estimate_num_groups","count":8},{"name":"api-typical-usage","value":"Often called from: euc_tw2mic","count":8},{"name":"api-typical-usage","value":"Often called from: exec_command_elif","count":8},{"name":"api-typical-usage","value":"Often called from: exec_replication_command","count":8},{"name":"api-typical-usage","value":"Often called from: exec_stmt_getdiag","count":8},{"name":"api-typical-usage","value":"Often called from: exec_stmt_return_next","count":8},{"name":"api-typical-usage","value":"Often called from: executePredicate","count":8},{"name":"api-typical-usage","value":"Often called from: expandRecordVariable","count":8},{"name":"api-typical-usage","value":"Often called from: expand_array","count":8},{"name":"api-typical-usage","value":"Often called from: expand_dynamic_library_name","count":8},{"name":"api-typical-usage","value":"Often called from: exprLocation","count":8},{"name":"api-typical-usage","value":"Often called from: expression_tree_walker_impl","count":8},{"name":"api-typical-usage","value":"Often called from: f2d","count":8},{"name":"api-typical-usage","value":"Often called from: fillJsonbValue","count":8},{"name":"api-typical-usage","value":"Often called from: find","count":8},{"name":"api-typical-usage","value":"Often called from: find_my_exec","count":8},{"name":"api-typical-usage","value":"Often called from: find_or_make_matching_shared_tupledesc","count":8},{"name":"api-typical-usage","value":"Often called from: find_other_exec","count":8},{"name":"api-typical-usage","value":"Often called from: fireRIRrules","count":8},{"name":"api-typical-usage","value":"Often called from: fixconstraintloops","count":8},{"name":"api-typical-usage","value":"Often called from: float4send","count":8},{"name":"api-typical-usage","value":"Often called from: float8_regr_combine","count":8},{"name":"api-typical-usage","value":"Often called from: float8in_internal","count":8},{"name":"api-typical-usage","value":"Often called from: fmgr_c_validator","count":8},{"name":"api-typical-usage","value":"Often called from: format_operator_extended","count":8},{"name":"api-typical-usage","value":"Often called from: freeJsonLexContext","count":8},{"name":"api-typical-usage","value":"Often called from: fsm_search_avail","count":8},{"name":"api-typical-usage","value":"Often called from: gb18030_to_utf8","count":8},{"name":"api-typical-usage","value":"Often called from: gen_prune_steps_from_opexps","count":8},{"name":"api-typical-usage","value":"Often called from: generate_join_implied_equalities_for_ecs","count":8},{"name":"api-typical-usage","value":"Often called from: generate_orderedappend_paths","count":8},{"name":"api-typical-usage","value":"Often called from: generate_recursion_path","count":8},{"name":"api-typical-usage","value":"Often called from: generate_series_step_numeric","count":8},{"name":"api-typical-usage","value":"Often called from: generate_series_timestamptz_internal","count":8},{"name":"api-typical-usage","value":"Often called from: generic_mask","count":8},{"name":"api-typical-usage","value":"Often called from: getHostaddr","count":8},{"name":"api-typical-usage","value":"Often called from: getQuadrant","count":8},{"name":"api-typical-usage","value":"Often called from: getTSCurrentConfig","count":8},{"name":"api-typical-usage","value":"Often called from: getTableAttrs","count":8},{"name":"api-typical-usage","value":"Often called from: get_actual_variable_endpoint","count":8},{"name":"api-typical-usage","value":"Often called from: get_basic_select_query","count":8},{"name":"api-typical-usage","value":"Often called from: get_joinrel_parampathinfo","count":8},{"name":"api-typical-usage","value":"Often called from: get_json_table","count":8},{"name":"api-typical-usage","value":"Often called from: get_matching_list_bounds","count":8},{"name":"api-typical-usage","value":"Often called from: get_matching_part_pairs","count":8},{"name":"api-typical-usage","value":"Often called from: get_matching_range_bounds","count":8},{"name":"api-typical-usage","value":"Often called from: get_number_of_groups","count":8},{"name":"api-typical-usage","value":"Often called from: get_object_address","count":8},{"name":"api-typical-usage","value":"Often called from: get_param_path_clause_serials","count":8},{"name":"api-typical-usage","value":"Often called from: get_password_type","count":8},{"name":"api-typical-usage","value":"Often called from: get_progname","count":8},{"name":"api-typical-usage","value":"Often called from: get_qual_for_range","count":8},{"name":"api-typical-usage","value":"Often called from: get_relation_info","count":8},{"name":"api-typical-usage","value":"Often called from: get_rolespec_tuple","count":8},{"name":"api-typical-usage","value":"Often called from: get_select_query_def","count":8},{"name":"api-typical-usage","value":"Often called from: get_update_query_def","count":8},{"name":"api-typical-usage","value":"Often called from: ginRedoDeleteListPages","count":8},{"name":"api-typical-usage","value":"Often called from: gin_redo","count":8},{"name":"api-typical-usage","value":"Often called from: gincostestimate","count":8},{"name":"api-typical-usage","value":"Often called from: gistRedoPageSplitRecord","count":8},{"name":"api-typical-usage","value":"Often called from: gistScanPage","count":8},{"name":"api-typical-usage","value":"Often called from: gtsvector_same","count":8},{"name":"api-typical-usage","value":"Often called from: handleCopyIn","count":8},{"name":"api-typical-usage","value":"Often called from: has_sequence_privilege_id","count":8},{"name":"api-typical-usage","value":"Often called from: has_table_privilege_id_name","count":8},{"name":"api-typical-usage","value":"Often called from: hash_create","count":8},{"name":"api-typical-usage","value":"Often called from: hash_range","count":8},{"name":"api-typical-usage","value":"Often called from: heap_hot_search_buffer","count":8},{"name":"api-typical-usage","value":"Often called from: heap_multi_insert","count":8},{"name":"api-typical-usage","value":"Often called from: heap_page_prune_opt","count":8},{"name":"api-typical-usage","value":"Often called from: heap_xlog_insert","count":8},{"name":"api-typical-usage","value":"Often called from: heap_xlog_lock","count":8},{"name":"api-typical-usage","value":"Often called from: heap_xlog_visible","count":8},{"name":"api-typical-usage","value":"Often called from: heapam_tuple_lock","count":8},{"name":"api-typical-usage","value":"Often called from: hek2cstr","count":8},{"name":"api-typical-usage","value":"Often called from: helpSQL","count":8},{"name":"api-typical-usage","value":"Often called from: identify_system_timezone","count":8},{"name":"api-typical-usage","value":"Often called from: in_range_date_interval","count":8},{"name":"api-typical-usage","value":"Often called from: in_range_float8_float8","count":8},{"name":"api-typical-usage","value":"Often called from: index_markpos","count":8},{"name":"api-typical-usage","value":"Often called from: inet_cidr_ntop_ipv6","count":8},{"name":"api-typical-usage","value":"Often called from: inet_gist_picksplit","count":8},{"name":"api-typical-usage","value":"Often called from: inet_spg_inner_consistent","count":8},{"name":"api-typical-usage","value":"Often called from: init_degree_constants","count":8},{"name":"api-typical-usage","value":"Often called from: inject_projection_plan","count":8},{"name":"api-typical-usage","value":"Often called from: int4_avg_accum","count":8},{"name":"api-typical-usage","value":"Often called from: int4_avg_combine","count":8},{"name":"api-typical-usage","value":"Often called from: interval_mi","count":8},{"name":"api-typical-usage","value":"Often called from: intervaltypmodin","count":8},{"name":"api-typical-usage","value":"Often called from: isValidTarHeader","count":8},{"name":"api-typical-usage","value":"Often called from: json_lex_string","count":8},{"name":"api-typical-usage","value":"Often called from: json_object_agg_transfn_worker","count":8},{"name":"api-typical-usage","value":"Often called from: json_string_to_tsvector_byid","count":8},{"name":"api-typical-usage","value":"Often called from: jsonb_agg_transfn_worker","count":8},{"name":"api-typical-usage","value":"Often called from: jsonb_contains","count":8},{"name":"api-typical-usage","value":"Often called from: jsonb_int4","count":8},{"name":"api-typical-usage","value":"Often called from: leading_pad","count":8},{"name":"api-typical-usage","value":"Often called from: like_fixed_prefix","count":8},{"name":"api-typical-usage","value":"Often called from: line_interpt","count":8},{"name":"api-typical-usage","value":"Often called from: line_interpt_line","count":8},{"name":"api-typical-usage","value":"Often called from: llvm_load_summary","count":8},{"name":"api-typical-usage","value":"Often called from: lo_close","count":8},{"name":"api-typical-usage","value":"Often called from: load_backup_manifest","count":8},{"name":"api-typical-usage","value":"Often called from: logicalmsg_identify","count":8},{"name":"api-typical-usage","value":"Often called from: logicalrep_launcher_attach_dshmem","count":8},{"name":"api-typical-usage","value":"Often called from: logicalrep_worker_find","count":8},{"name":"api-typical-usage","value":"Often called from: logicalrep_worker_stop_internal","count":8},{"name":"api-typical-usage","value":"Often called from: lseg_crossing","count":8},{"name":"api-typical-usage","value":"Often called from: macaddr_le","count":8},{"name":"api-typical-usage","value":"Often called from: makeMultirangeConstructors","count":8},{"name":"api-typical-usage","value":"Often called from: make_const","count":8},{"name":"api-typical-usage","value":"Often called from: make_outerjoininfo","count":8},{"name":"api-typical-usage","value":"Often called from: make_outputdirs","count":8},{"name":"api-typical-usage","value":"Often called from: make_subplan","count":8},{"name":"api-typical-usage","value":"Often called from: mask_page_content","count":8},{"name":"api-typical-usage","value":"Often called from: match_pattern_prefix","count":8},{"name":"api-typical-usage","value":"Often called from: max_parallel_hazard_walker","count":8},{"name":"api-typical-usage","value":"Often called from: mcelem_array_contain_overlap_selec","count":8},{"name":"api-typical-usage","value":"Often called from: mcv_get_match_bitmap","count":8},{"name":"api-typical-usage","value":"Often called from: mdunlinkfork","count":8},{"name":"api-typical-usage","value":"Often called from: merge_range_bounds","count":8},{"name":"api-typical-usage","value":"Often called from: mergeruns","count":8},{"name":"api-typical-usage","value":"Often called from: mic2big5","count":8},{"name":"api-typical-usage","value":"Often called from: moveouts","count":8},{"name":"api-typical-usage","value":"Often called from: multirange_before_multirange","count":8},{"name":"api-typical-usage","value":"Often called from: multirange_in","count":8},{"name":"api-typical-usage","value":"Often called from: multirange_union","count":8},{"name":"api-typical-usage","value":"Often called from: multirangesel","count":8},{"name":"api-typical-usage","value":"Often called from: network_lt","count":8},{"name":"api-typical-usage","value":"Often called from: newdfa","count":8},{"name":"api-typical-usage","value":"Often called from: newlacon","count":8},{"name":"api-typical-usage","value":"Often called from: numeric_avg_accum","count":8},{"name":"api-typical-usage","value":"Often called from: numeric_poly_combine","count":8},{"name":"api-typical-usage","value":"Often called from: numeric_serialize","count":8},{"name":"api-typical-usage","value":"Often called from: object_ownercheck","count":8},{"name":"api-typical-usage","value":"Often called from: objectsInSchemaToOids","count":8},{"name":"api-typical-usage","value":"Often called from: output_prepare_statement","count":8},{"name":"api-typical-usage","value":"Often called from: parallel_vacuum_end","count":8},{"name":"api-typical-usage","value":"Often called from: parseAclItem","count":8},{"name":"api-typical-usage","value":"Often called from: parse_ooaffentry","count":8},{"name":"api-typical-usage","value":"Often called from: parse_psql_options","count":8},{"name":"api-typical-usage","value":"Often called from: parse_slash_copy","count":8},{"name":"api-typical-usage","value":"Often called from: parse_tsquery","count":8},{"name":"api-typical-usage","value":"Often called from: path_decode","count":8},{"name":"api-typical-usage","value":"Often called from: path_inter","count":8},{"name":"api-typical-usage","value":"Often called from: path_is_reparameterizable_by_child","count":8},{"name":"api-typical-usage","value":"Often called from: path_n_lt","count":8},{"name":"api-typical-usage","value":"Often called from: patternsel_common","count":8},{"name":"api-typical-usage","value":"Often called from: percentile_cont_multi_final_common","count":8},{"name":"api-typical-usage","value":"Often called from: perform_default_encoding_conversion","count":8},{"name":"api-typical-usage","value":"Often called from: pg_GSS_write","count":8},{"name":"api-typical-usage","value":"Often called from: pg_TZDIR","count":8},{"name":"api-typical-usage","value":"Often called from: pg_be_scram_build_secret","count":8},{"name":"api-typical-usage","value":"Often called from: pg_checksum_final","count":8},{"name":"api-typical-usage","value":"Often called from: pg_collation_for","count":8},{"name":"api-typical-usage","value":"Often called from: pg_comp_crc32c_armv8","count":8},{"name":"api-typical-usage","value":"Often called from: pg_cryptohash_init","count":8},{"name":"api-typical-usage","value":"Often called from: pg_current_logfile","count":8},{"name":"api-typical-usage","value":"Often called from: pg_extension_update_paths","count":8},{"name":"api-typical-usage","value":"Often called from: pg_get_indexdef_columns_extended","count":8},{"name":"api-typical-usage","value":"Often called from: pg_get_indexdef_worker","count":8},{"name":"api-typical-usage","value":"Often called from: pg_get_statisticsobjdef_expressions","count":8},{"name":"api-typical-usage","value":"Often called from: pg_get_triggerdef_worker","count":8},{"name":"api-typical-usage","value":"Often called from: pg_get_viewdef_worker","count":8},{"name":"api-typical-usage","value":"Often called from: pg_get_wait_events","count":8},{"name":"api-typical-usage","value":"Often called from: pg_has_role_name_id","count":8},{"name":"api-typical-usage","value":"Often called from: pg_hmac_final","count":8},{"name":"api-typical-usage","value":"Often called from: pg_namespace_aclmask_ext","count":8},{"name":"api-typical-usage","value":"Often called from: pg_pwrite_zeros","count":8},{"name":"api-typical-usage","value":"Often called from: pg_stat_get_activity","count":8},{"name":"api-typical-usage","value":"Often called from: pg_stat_get_io","count":8},{"name":"api-typical-usage","value":"Often called from: pg_strcasecmp","count":8},{"name":"api-typical-usage","value":"Often called from: pg_strerror","count":8},{"name":"api-typical-usage","value":"Often called from: pg_strncoll_libc_win32_utf8","count":8},{"name":"api-typical-usage","value":"Often called from: pg_timezone_names","count":8},{"name":"api-typical-usage","value":"Often called from: pg_u_ispunct","count":8},{"name":"api-typical-usage","value":"Often called from: pg_wc_toupper","count":8},{"name":"api-typical-usage","value":"Often called from: pgoutput_change","count":8},{"name":"api-typical-usage","value":"Often called from: pgoutput_stream_start","count":8},{"name":"api-typical-usage","value":"Often called from: pgstat_database_flush_cb","count":8},{"name":"api-typical-usage","value":"Often called from: pgstat_get_slru_index","count":8},{"name":"api-typical-usage","value":"Often called from: pgstat_report_activity","count":8},{"name":"api-typical-usage","value":"Often called from: pgtypes_fmt_replace","count":8},{"name":"api-typical-usage","value":"Often called from: pgwin32_CommandLine","count":8},{"name":"api-typical-usage","value":"Often called from: plperl_init_interp","count":8},{"name":"api-typical-usage","value":"Often called from: plperl_inline_handler","count":8},{"name":"api-typical-usage","value":"Often called from: plperl_modify_tuple","count":8},{"name":"api-typical-usage","value":"Often called from: plperl_spi_rollback","count":8},{"name":"api-typical-usage","value":"Often called from: plpgsql_exec_get_datum_type_info","count":8},{"name":"api-typical-usage","value":"Often called from: plpgsql_parse_dblword","count":8},{"name":"api-typical-usage","value":"Often called from: pltcl_SPI_execute_plan","count":8},{"name":"api-typical-usage","value":"Often called from: pltcl_trigger_handler","count":8},{"name":"api-typical-usage","value":"Often called from: pnstrdup","count":8},{"name":"api-typical-usage","value":"Often called from: point_add_point","count":8},{"name":"api-typical-usage","value":"Often called from: power_var_int","count":8},{"name":"api-typical-usage","value":"Often called from: pqGetErrorNotice3","count":8},{"name":"api-typical-usage","value":"Often called from: pqTraceOutput_Bind","count":8},{"name":"api-typical-usage","value":"Often called from: pq_sendstring","count":8},{"name":"api-typical-usage","value":"Often called from: printQuery","count":8},{"name":"api-typical-usage","value":"Often called from: print_aligned_text","count":8},{"name":"api-typical-usage","value":"Often called from: print_expr","count":8},{"name":"api-typical-usage","value":"Often called from: print_html_text","count":8},{"name":"api-typical-usage","value":"Often called from: print_latex_longtable_text","count":8},{"name":"api-typical-usage","value":"Often called from: processExtensionTables","count":8},{"name":"api-typical-usage","value":"Often called from: process_backslash_command","count":8},{"name":"api-typical-usage","value":"Often called from: process_file","count":8},{"name":"api-typical-usage","value":"Often called from: process_pm_pmsignal","count":8},{"name":"api-typical-usage","value":"Often called from: procsignal_sigusr1_handler","count":8},{"name":"api-typical-usage","value":"Often called from: prompt_for_password","count":8},{"name":"api-typical-usage","value":"Often called from: pull_up_sublinks_qual_recurse","count":8},{"name":"api-typical-usage","value":"Often called from: r_prelude","count":8},{"name":"api-typical-usage","value":"Often called from: range_constructor3","count":8},{"name":"api-typical-usage","value":"Often called from: range_get_typcache","count":8},{"name":"api-typical-usage","value":"Often called from: range_gist_double_sorting_split","count":8},{"name":"api-typical-usage","value":"Often called from: range_in","count":8},{"name":"api-typical-usage","value":"Often called from: range_merge","count":8},{"name":"api-typical-usage","value":"Often called from: range_out","count":8},{"name":"api-typical-usage","value":"Often called from: range_send","count":8},{"name":"api-typical-usage","value":"Often called from: range_super_union","count":8},{"name":"api-typical-usage","value":"Often called from: rangesel","count":8},{"name":"api-typical-usage","value":"Often called from: raw_expression_tree_walker_impl","count":8},{"name":"api-typical-usage","value":"Often called from: regtypein","count":8},{"name":"api-typical-usage","value":"Often called from: reindex_index","count":8},{"name":"api-typical-usage","value":"Often called from: repalloc","count":8},{"name":"api-typical-usage","value":"Often called from: reportDependentObjects","count":8},{"name":"api-typical-usage","value":"Often called from: reservoir_get_next_S","count":8},{"name":"api-typical-usage","value":"Often called from: restoreTimeLineHistoryFiles","count":8},{"name":"api-typical-usage","value":"Often called from: rewriteTargetView","count":8},{"name":"api-typical-usage","value":"Often called from: ri_FetchConstraintInfo","count":8},{"name":"api-typical-usage","value":"Often called from: row_security_active_name","count":8},{"name":"api-typical-usage","value":"Often called from: runShellCommand","count":8},{"name":"api-typical-usage","value":"Often called from: scram_build_secret","count":8},{"name":"api-typical-usage","value":"Often called from: scram_init","count":8},{"name":"api-typical-usage","value":"Often called from: search_directory","count":8},{"name":"api-typical-usage","value":"Often called from: selectDumpableNamespace","count":8},{"name":"api-typical-usage","value":"Often called from: select_common_type_from_oids","count":8},{"name":"api-typical-usage","value":"Often called from: select_div_scale","count":8},{"name":"api-typical-usage","value":"Often called from: sendDir","count":8},{"name":"api-typical-usage","value":"Often called from: sendFeedback","count":8},{"name":"api-typical-usage","value":"Often called from: send_relation_and_attrs","count":8},{"name":"api-typical-usage","value":"Often called from: seq_search_ascii","count":8},{"name":"api-typical-usage","value":"Often called from: sequence_options","count":8},{"name":"api-typical-usage","value":"Often called from: set_cheapest","count":8},{"name":"api-typical-usage","value":"Often called from: set_frozenxids","count":8},{"name":"api-typical-usage","value":"Often called from: set_using_names","count":8},{"name":"api-typical-usage","value":"Often called from: setup_data_file_paths","count":8},{"name":"api-typical-usage","value":"Often called from: setup_privileges","count":8},{"name":"api-typical-usage","value":"Often called from: shdepDropOwned","count":8},{"name":"api-typical-usage","value":"Often called from: show_archive_command","count":8},{"name":"api-typical-usage","value":"Often called from: show_tablesample","count":8},{"name":"api-typical-usage","value":"Often called from: sjis2mic","count":8},{"name":"api-typical-usage","value":"Often called from: spgAddNodeAction","count":8},{"name":"api-typical-usage","value":"Often called from: spgPageIndexMultiDelete","count":8},{"name":"api-typical-usage","value":"Often called from: spg_kd_inner_consistent","count":8},{"name":"api-typical-usage","value":"Often called from: spgbuildempty","count":8},{"name":"api-typical-usage","value":"Often called from: spgdoinsert","count":8},{"name":"api-typical-usage","value":"Often called from: sql_inline_error_callback","count":8},{"name":"api-typical-usage","value":"Often called from: stringoffset","count":8},{"name":"api-typical-usage","value":"Often called from: stringzone","count":8},{"name":"api-typical-usage","value":"Often called from: systable_getnext","count":8},{"name":"api-typical-usage","value":"Often called from: t_isalnum","count":8},{"name":"api-typical-usage","value":"Often called from: tbm_free_shared_area","count":8},{"name":"api-typical-usage","value":"Often called from: text_char","count":8},{"name":"api-typical-usage","value":"Often called from: text_format","count":8},{"name":"api-typical-usage","value":"Often called from: tidin","count":8},{"name":"api-typical-usage","value":"Often called from: tidlarger","count":8},{"name":"api-typical-usage","value":"Often called from: time_larger","count":8},{"name":"api-typical-usage","value":"Often called from: timesub","count":8},{"name":"api-typical-usage","value":"Often called from: timetz_part_common","count":8},{"name":"api-typical-usage","value":"Often called from: toastrel_valueid_exists","count":8},{"name":"api-typical-usage","value":"Often called from: touched_lseg_inside_poly","count":8},{"name":"api-typical-usage","value":"Often called from: transformAExprBetween","count":8},{"name":"api-typical-usage","value":"Often called from: transformAExprOp","count":8},{"name":"api-typical-usage","value":"Often called from: transformAlterTableStmt","count":8},{"name":"api-typical-usage","value":"Often called from: transformFromClauseItem","count":8},{"name":"api-typical-usage","value":"Often called from: transformInsertStmt","count":8},{"name":"api-typical-usage","value":"Often called from: transformJsonFuncExpr","count":8},{"name":"api-typical-usage","value":"Often called from: transformRangeTableFunc","count":8},{"name":"api-typical-usage","value":"Often called from: transformSetOperationStmt","count":8},{"name":"api-typical-usage","value":"Often called from: transformSetOperationTree","count":8},{"name":"api-typical-usage","value":"Often called from: transform_MERGE_to_join","count":8},{"name":"api-typical-usage","value":"Often called from: ts_match_tt","count":8},{"name":"api-typical-usage","value":"Often called from: tsearch_readline_begin","count":8},{"name":"api-typical-usage","value":"Often called from: tuplesort_getdatum","count":8},{"name":"api-typical-usage","value":"Often called from: tuplesort_gettuple_common","count":8},{"name":"api-typical-usage","value":"Often called from: tuplesort_putbrintuple","count":8},{"name":"api-typical-usage","value":"Often called from: tuplesort_puttuple_common","count":8},{"name":"api-typical-usage","value":"Often called from: tuplestore_gettuple","count":8},{"name":"api-typical-usage","value":"Often called from: tzloadbody","count":8},{"name":"api-typical-usage","value":"Often called from: tzparse","count":8},{"name":"api-typical-usage","value":"Often called from: uuid_fast_cmp","count":8},{"name":"api-typical-usage","value":"Often called from: vac_update_datfrozenxid","count":8},{"name":"api-typical-usage","value":"Often called from: vacuum","count":8},{"name":"api-typical-usage","value":"Often called from: vacuum_one_database","count":8},{"name":"api-typical-usage","value":"Often called from: varstr_levenshtein","count":8},{"name":"api-typical-usage","value":"Often called from: width_bucket_numeric","count":8},{"name":"api-typical-usage","value":"Often called from: write_eventlog","count":8},{"name":"api-typical-usage","value":"Often called from: write_jsonlog","count":8},{"name":"api-typical-usage","value":"Often called from: write_pipe_chunks","count":8},{"name":"api-typical-usage","value":"Often called from: writetup_heap","count":8},{"name":"api-typical-usage","value":"Often called from: xid8_larger","count":8},{"name":"api-typical-usage","value":"Often called from: xmlconcat2","count":8},{"name":"coupling-score","value":"63","count":8},{"name":"coupling-score","value":"67","count":8},{"name":"coupling-score","value":"72","count":8},{"name":"coupling-score","value":"75","count":8},{"name":"coupling-score","value":"82","count":8},{"name":"cyclomatic-complexity","value":"1011","count":8},{"name":"cyclomatic-complexity","value":"111","count":8},{"name":"cyclomatic-complexity","value":"122","count":8},{"name":"cyclomatic-complexity","value":"124","count":8},{"name":"cyclomatic-complexity","value":"133","count":8},{"name":"cyclomatic-complexity","value":"134","count":8},{"name":"cyclomatic-complexity","value":"138","count":8},{"name":"cyclomatic-complexity","value":"143","count":8},{"name":"cyclomatic-complexity","value":"148","count":8},{"name":"cyclomatic-complexity","value":"160","count":8},{"name":"cyclomatic-complexity","value":"165","count":8},{"name":"cyclomatic-complexity","value":"170","count":8},{"name":"cyclomatic-complexity","value":"171","count":8},{"name":"cyclomatic-complexity","value":"174","count":8},{"name":"cyclomatic-complexity","value":"187","count":8},{"name":"cyclomatic-complexity","value":"188","count":8},{"name":"cyclomatic-complexity","value":"194","count":8},{"name":"cyclomatic-complexity","value":"196","count":8},{"name":"cyclomatic-complexity","value":"199","count":8},{"name":"cyclomatic-complexity","value":"202","count":8},{"name":"cyclomatic-complexity","value":"208","count":8},{"name":"cyclomatic-complexity","value":"220","count":8},{"name":"cyclomatic-complexity","value":"228","count":8},{"name":"cyclomatic-complexity","value":"231","count":8},{"name":"cyclomatic-complexity","value":"234","count":8},{"name":"cyclomatic-complexity","value":"235","count":8},{"name":"cyclomatic-complexity","value":"246","count":8},{"name":"cyclomatic-complexity","value":"250","count":8},{"name":"cyclomatic-complexity","value":"251","count":8},{"name":"cyclomatic-complexity","value":"259","count":8},{"name":"cyclomatic-complexity","value":"260","count":8},{"name":"cyclomatic-complexity","value":"280","count":8},{"name":"cyclomatic-complexity","value":"302","count":8},{"name":"cyclomatic-complexity","value":"312","count":8},{"name":"cyclomatic-complexity","value":"317","count":8},{"name":"cyclomatic-complexity","value":"324","count":8},{"name":"cyclomatic-complexity","value":"333","count":8},{"name":"cyclomatic-complexity","value":"339","count":8},{"name":"cyclomatic-complexity","value":"340","count":8},{"name":"cyclomatic-complexity","value":"345","count":8},{"name":"cyclomatic-complexity","value":"352","count":8},{"name":"cyclomatic-complexity","value":"357","count":8},{"name":"cyclomatic-complexity","value":"364","count":8},{"name":"cyclomatic-complexity","value":"376","count":8},{"name":"cyclomatic-complexity","value":"384","count":8},{"name":"cyclomatic-complexity","value":"434","count":8},{"name":"cyclomatic-complexity","value":"471","count":8},{"name":"cyclomatic-complexity","value":"499","count":8},{"name":"cyclomatic-complexity","value":"529","count":8},{"name":"cyclomatic-complexity","value":"547","count":8},{"name":"cyclomatic-complexity","value":"591","count":8},{"name":"cyclomatic-complexity","value":"660","count":8},{"name":"cyclomatic-complexity","value":"697","count":8},{"name":"cyclomatic-complexity","value":"719","count":8},{"name":"cyclomatic-complexity","value":"984","count":8},{"name":"lines-of-code","value":"1021","count":8},{"name":"lines-of-code","value":"1053","count":8},{"name":"lines-of-code","value":"1073","count":8},{"name":"lines-of-code","value":"1102","count":8},{"name":"lines-of-code","value":"1157","count":8},{"name":"lines-of-code","value":"1159","count":8},{"name":"lines-of-code","value":"1184","count":8},{"name":"lines-of-code","value":"1205","count":8},{"name":"lines-of-code","value":"1268","count":8},{"name":"lines-of-code","value":"1286","count":8},{"name":"lines-of-code","value":"1328","count":8},{"name":"lines-of-code","value":"1332","count":8},{"name":"lines-of-code","value":"1340","count":8},{"name":"lines-of-code","value":"1409","count":8},{"name":"lines-of-code","value":"1663","count":8},{"name":"lines-of-code","value":"1793","count":8},{"name":"lines-of-code","value":"1829","count":8},{"name":"lines-of-code","value":"1842","count":8},{"name":"lines-of-code","value":"2034","count":8},{"name":"lines-of-code","value":"263","count":8},{"name":"lines-of-code","value":"2662","count":8},{"name":"lines-of-code","value":"267","count":8},{"name":"lines-of-code","value":"281","count":8},{"name":"lines-of-code","value":"286","count":8},{"name":"lines-of-code","value":"297","count":8},{"name":"lines-of-code","value":"298","count":8},{"name":"lines-of-code","value":"309","count":8},{"name":"lines-of-code","value":"313","count":8},{"name":"lines-of-code","value":"315","count":8},{"name":"lines-of-code","value":"318","count":8},{"name":"lines-of-code","value":"319","count":8},{"name":"lines-of-code","value":"334","count":8},{"name":"lines-of-code","value":"3404","count":8},{"name":"lines-of-code","value":"3431","count":8},{"name":"lines-of-code","value":"344","count":8},{"name":"lines-of-code","value":"345","count":8},{"name":"lines-of-code","value":"349","count":8},{"name":"lines-of-code","value":"359","count":8},{"name":"lines-of-code","value":"361","count":8},{"name":"lines-of-code","value":"369","count":8},{"name":"lines-of-code","value":"371","count":8},{"name":"lines-of-code","value":"375","count":8},{"name":"lines-of-code","value":"381","count":8},{"name":"lines-of-code","value":"383","count":8},{"name":"lines-of-code","value":"389","count":8},{"name":"lines-of-code","value":"397","count":8},{"name":"lines-of-code","value":"400","count":8},{"name":"lines-of-code","value":"406","count":8},{"name":"lines-of-code","value":"412","count":8},{"name":"lines-of-code","value":"413","count":8},{"name":"lines-of-code","value":"415","count":8},{"name":"lines-of-code","value":"417","count":8},{"name":"lines-of-code","value":"418","count":8},{"name":"lines-of-code","value":"424","count":8},{"name":"lines-of-code","value":"425","count":8},{"name":"lines-of-code","value":"426","count":8},{"name":"lines-of-code","value":"427","count":8},{"name":"lines-of-code","value":"437","count":8},{"name":"lines-of-code","value":"441","count":8},{"name":"lines-of-code","value":"446","count":8},{"name":"lines-of-code","value":"453","count":8},{"name":"lines-of-code","value":"456","count":8},{"name":"lines-of-code","value":"457","count":8},{"name":"lines-of-code","value":"458","count":8},{"name":"lines-of-code","value":"460","count":8},{"name":"lines-of-code","value":"461","count":8},{"name":"lines-of-code","value":"462","count":8},{"name":"lines-of-code","value":"466","count":8},{"name":"lines-of-code","value":"468","count":8},{"name":"lines-of-code","value":"471","count":8},{"name":"lines-of-code","value":"472","count":8},{"name":"lines-of-code","value":"480","count":8},{"name":"lines-of-code","value":"489","count":8},{"name":"lines-of-code","value":"491","count":8},{"name":"lines-of-code","value":"493","count":8},{"name":"lines-of-code","value":"496","count":8},{"name":"lines-of-code","value":"497","count":8},{"name":"lines-of-code","value":"501","count":8},{"name":"lines-of-code","value":"508","count":8},{"name":"lines-of-code","value":"509","count":8},{"name":"lines-of-code","value":"512","count":8},{"name":"lines-of-code","value":"518","count":8},{"name":"lines-of-code","value":"520","count":8},{"name":"lines-of-code","value":"524","count":8},{"name":"lines-of-code","value":"533","count":8},{"name":"lines-of-code","value":"536","count":8},{"name":"lines-of-code","value":"537","count":8},{"name":"lines-of-code","value":"540","count":8},{"name":"lines-of-code","value":"542","count":8},{"name":"lines-of-code","value":"544","count":8},{"name":"lines-of-code","value":"549","count":8},{"name":"lines-of-code","value":"550","count":8},{"name":"lines-of-code","value":"555","count":8},{"name":"lines-of-code","value":"556","count":8},{"name":"lines-of-code","value":"569","count":8},{"name":"lines-of-code","value":"571","count":8},{"name":"lines-of-code","value":"574","count":8},{"name":"lines-of-code","value":"592","count":8},{"name":"lines-of-code","value":"593","count":8},{"name":"lines-of-code","value":"597","count":8},{"name":"lines-of-code","value":"602","count":8},{"name":"lines-of-code","value":"604","count":8},{"name":"lines-of-code","value":"606","count":8},{"name":"lines-of-code","value":"612","count":8},{"name":"lines-of-code","value":"616","count":8},{"name":"lines-of-code","value":"619","count":8},{"name":"lines-of-code","value":"624","count":8},{"name":"lines-of-code","value":"632","count":8},{"name":"lines-of-code","value":"646","count":8},{"name":"lines-of-code","value":"671","count":8},{"name":"lines-of-code","value":"674","count":8},{"name":"lines-of-code","value":"677","count":8},{"name":"lines-of-code","value":"680","count":8},{"name":"lines-of-code","value":"681","count":8},{"name":"lines-of-code","value":"683","count":8},{"name":"lines-of-code","value":"685","count":8},{"name":"lines-of-code","value":"686","count":8},{"name":"lines-of-code","value":"703","count":8},{"name":"lines-of-code","value":"705","count":8},{"name":"lines-of-code","value":"716","count":8},{"name":"lines-of-code","value":"720","count":8},{"name":"lines-of-code","value":"727","count":8},{"name":"lines-of-code","value":"735","count":8},{"name":"lines-of-code","value":"754","count":8},{"name":"lines-of-code","value":"761","count":8},{"name":"lines-of-code","value":"774","count":8},{"name":"lines-of-code","value":"777","count":8},{"name":"lines-of-code","value":"779","count":8},{"name":"lines-of-code","value":"789","count":8},{"name":"lines-of-code","value":"799","count":8},{"name":"lines-of-code","value":"800","count":8},{"name":"lines-of-code","value":"816","count":8},{"name":"lines-of-code","value":"827","count":8},{"name":"lines-of-code","value":"838","count":8},{"name":"lines-of-code","value":"843","count":8},{"name":"lines-of-code","value":"847","count":8},{"name":"lines-of-code","value":"876","count":8},{"name":"lines-of-code","value":"882","count":8},{"name":"lines-of-code","value":"885","count":8},{"name":"lines-of-code","value":"903","count":8},{"name":"lines-of-code","value":"914","count":8},{"name":"lines-of-code","value":"923","count":8},{"name":"lines-of-code","value":"927","count":8},{"name":"lines-of-code","value":"940","count":8},{"name":"lines-of-code","value":"960","count":8},{"name":"lines-of-code","value":"970","count":8},{"name":"lines-of-code","value":"973","count":8},{"name":"lines-of-code","value":"982","count":8},{"name":"lines-of-code","value":"991","count":8},{"name":"loop-depth","value":"41","count":8},{"name":"loop-depth","value":"42","count":8},{"name":"loop-depth","value":"43","count":8},{"name":"loop-depth","value":"47","count":8},{"name":"loop-depth","value":"48","count":8},{"name":"loop-depth","value":"53","count":8},{"name":"loop-depth","value":"54","count":8},{"name":"loop-depth","value":"55","count":8},{"name":"loop-depth","value":"59","count":8},{"name":"loop-depth","value":"60","count":8},{"name":"loop-depth","value":"64","count":8},{"name":"loop-depth","value":"67","count":8},{"name":"loop-depth","value":"70","count":8},{"name":"loop-depth","value":"80","count":8},{"name":"loop-depth","value":"88","count":8},{"name":"module-depends-on","value":"<unknown>, backend\\access\\rmgrdesc\\dbasedesc.c, common\\stringinfo.c, interfaces\\libpq\\fe-exec.c","count":8},{"name":"module-depends-on","value":"<unknown>, backend\\access\\rmgrdesc\\genericdesc.c, backend\\access\\rmgrdesc\\gindesc.c, common\\stringinfo.c, backend\\nodes\\readfuncs.c","count":8},{"name":"module-depends-on","value":"<unknown>, backend\\access\\rmgrdesc\\genericdesc.c, backend\\access\\rmgrdesc\\gindesc.c, common\\stringinfo.c, interfaces\\libpq\\fe-exec.c","count":8},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\smgr\\smgr.c","count":8},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c","count":8},{"name":"module-depends-on","value":"<unknown>, bin\\scripts\\clusterdb.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, common\\logging.c, port\\path.c, fe_utils\\option_utils.c, port\\getopt_long.c, common\\fe_memutils.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":8},{"name":"module-depends-on","value":"<unknown>, common\\config_info.c","count":8},{"name":"module-depends-on","value":"<unknown>, include\\common\\kwlookup.h","count":8},{"name":"module-depends-on","value":"<unknown>, include\\nodes\\pg_list.h","count":8},{"name":"module-depends-on","value":"<unknown>, include\\port\\simd.h","count":8},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c","count":8},{"name":"module-depends-on","value":"C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, <unknown>, interfaces\\libpq\\fe-print.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\sec_api\\stdio_s.h, backend\\jit\\llvm\\llvmjit_error.cpp, C:\\mingw64\\x86_64-w64-mingw32\\include\\guiddef.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\winnt.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\memoryapi.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\oleauto.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\winuser.h","count":8},{"name":"module-depends-on","value":"backend\\executor\\execExprInterp.c, <unknown>, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\executor\\nodeValuesscan.c, include\\nodes\\nodes.h, include\\nodes\\pg_list.h, backend\\utils\\mmgr\\mcxt.c, backend\\executor\\execProcnode.c","count":8},{"name":"module-depends-on","value":"bin\\pg_basebackup\\bbstreamer_file.c, <unknown>, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c","count":8},{"name":"test-count","value":"209","count":8},{"name":"test-count","value":"211","count":8},{"name":"test-count","value":"29","count":8},{"name":"test-count","value":"50","count":8},{"name":"test-count","value":"57","count":8},{"name":"test-count","value":"59","count":8},{"name":"test-count","value":"68","count":8},{"name":"tested-by","value":"GlobalVisTestShouldUpdate, GlobalVisTestIsRemovableFullXid","count":8},{"name":"tested-by","value":"RI_FKey_check_ins, RI_FKey_check_upd","count":8},{"name":"tested-by","value":"_bt_check_compare, _bt_check_compare","count":8},{"name":"tested-by","value":"_bt_check_compare, _bt_check_compare, _bt_check_compare, _bt_check_compare, _bt_check_rowcompare, _bt_check_rowcompare, _bt_check_rowcompare, _bt_check_rowcompare","count":8},{"name":"tested-by","value":"_bt_check_compare, _bt_check_rowcompare, spgLeafTest, spgInnerTest, HeapKeyTest","count":8},{"name":"tested-by","value":"_bt_check_rowcompare, _bt_check_rowcompare","count":8},{"name":"tested-by","value":"_bt_check_third_page, _bt_check_third_page, _bt_check_third_page, _bt_check_third_page, _bt_check_third_page, _bt_check_third_page, _bt_check_third_page, _bt_check_third_page, _bt_check_third_page, _b","count":8},{"name":"tested-by","value":"_bt_check_unique, _bt_check_natts","count":8},{"name":"tested-by","value":"add_with_check_options, add_with_check_options","count":8},{"name":"tested-by","value":"call_bool_check_hook, call_int_check_hook, call_real_check_hook, call_string_check_hook, call_enum_check_hook","count":8},{"name":"tested-by","value":"call_string_check_hook, call_string_check_hook","count":8},{"name":"tested-by","value":"check_canonical_path, convert_and_check_filename, check_required_directory","count":8},{"name":"tested-by","value":"check_createrole_self_grant","count":8},{"name":"tested-by","value":"check_datestyle, check_datestyle, check_datestyle, check_timezone, check_special_value, check_special_value, check_special_value","count":8},{"name":"tested-by","value":"check_db_file_conflict, check_default_partition_contents","count":8},{"name":"tested-by","value":"check_default_table_access_method, check_recovery_target_name, check_valid_extension_name, check_valid_version_name, check_ident_usermap, check_synchronized_standby_slots, check_synchronized_standby_s","count":8},{"name":"tested-by","value":"check_domain_for_new_field, check_domain_for_new_tuple","count":8},{"name":"tested-by","value":"check_encoding_locale_matches, check_encoding_locale_matches","count":8},{"name":"tested-by","value":"check_file_excluded","count":8},{"name":"tested-by","value":"check_for_data_types_usage, check_is_install_user, check_proper_datallowconn, check_for_prepared_transactions, check_for_isn_and_int8_passing_mismatch, check_for_user_defined_postfix_ops, check_for_in","count":8},{"name":"tested-by","value":"check_hash_func_signature, check_hash_func_signature, index_delete_check_htid, index_delete_check_htid, index_delete_check_htid, check_amproc_signature, check_amop_signature, _bt_check_unique, _bt_che","count":8},{"name":"tested-by","value":"check_index_only, check_index_only","count":8},{"name":"tested-by","value":"check_index_predicates, check_index_predicates","count":8},{"name":"tested-by","value":"check_indicator","count":8},{"name":"tested-by","value":"check_locale, check_locale, check_locale_name, check_locale_name","count":8},{"name":"tested-by","value":"check_locale_name","count":8},{"name":"tested-by","value":"check_log_duration, check_data_directory, check_backup_label_files, check_file_excluded, check_for_data_types_usage, check_for_new_tablespace_dir, check_proper_datallowconn, check_for_isn_and_int8_pas","count":8},{"name":"tested-by","value":"check_max_connections, check_autovacuum_max_workers, check_max_worker_processes, check_max_wal_senders","count":8},{"name":"tested-by","value":"check_max_stack_depth, check_max_stack_depth","count":8},{"name":"tested-by","value":"check_mergejoinable","count":8},{"name":"tested-by","value":"check_nested_generated_walker","count":8},{"name":"tested-by","value":"check_object_ownership, check_object_ownership, check_object_ownership, check_role_membership_authorization, check_role_membership_authorization, check_role_grantor, check_session_authorization","count":8},{"name":"tested-by","value":"check_object_ownership, check_role_membership_authorization, check_role_membership_authorization, check_role_membership_authorization, check_role_membership_authorization, check_role_membership_author","count":8},{"name":"tested-by","value":"check_of_type","count":8},{"name":"tested-by","value":"check_ok","count":8},{"name":"tested-by","value":"check_output_expressions, check_output_expressions","count":8},{"name":"tested-by","value":"check_pghost_envvar","count":8},{"name":"tested-by","value":"check_publication_add_relation","count":8},{"name":"tested-by","value":"check_publications, check_backup_label_files","count":8},{"name":"tested-by","value":"check_publications, check_publications, check_publications_origin, check_backup_label_files, check_backup_label_files","count":8},{"name":"tested-by","value":"check_publications, check_publications_origin, check_publications_origin","count":8},{"name":"tested-by","value":"check_publisher, check_subscriber","count":8},{"name":"tested-by","value":"check_restrict_nonsystem_relation_kind","count":8},{"name":"tested-by","value":"check_role","count":8},{"name":"tested-by","value":"check_role, check_db, check_ident_usermap","count":8},{"name":"tested-by","value":"check_role, check_ident_usermap","count":8},{"name":"tested-by","value":"check_search_path, truncate_check_perms, check_temp_tablespaces, convert_and_check_filename, check_enable_rls","count":8},{"name":"tested-by","value":"check_session_authorization","count":8},{"name":"tested-by","value":"check_session_authorization, check_role","count":8},{"name":"tested-by","value":"check_session_authorization, check_session_authorization","count":8},{"name":"tested-by","value":"check_simple_rowfilter_expr_walker, check_rolespec_name, call_bool_check_hook, call_int_check_hook, call_real_check_hook, call_string_check_hook, call_enum_check_hook","count":8},{"name":"tested-by","value":"check_single_dir, check_bin_dir","count":8},{"name":"tested-by","value":"check_stack_depth","count":8},{"name":"tested-by","value":"check_synchronized_standby_slots, check_synchronized_standby_slots","count":8},{"name":"tested-by","value":"check_temp_tablespaces, check_synchronized_standby_slots","count":8},{"name":"tested-by","value":"check_uescapechar","count":8},{"name":"tested-by","value":"check_valid_extension_name, check_valid_version_name, check_restricted_library_name","count":8},{"name":"tested-by","value":"check_valid_polymorphic_signature, check_valid_polymorphic_signature","count":8},{"name":"tested-by","value":"check_valid_polymorphic_signature, check_valid_polymorphic_signature, check_valid_polymorphic_signature, check_valid_polymorphic_signature, check_control_files, check_compressed_file","count":8},{"name":"tested-by","value":"check_wal_consistency_checking, check_wal_consistency_checking, check_publications_origin, check_createrole_self_grant, check_createrole_self_grant, check_datestyle, check_datestyle, check_datestyle, ","count":8},{"name":"tested-by","value":"convert_and_check_filename","count":8},{"name":"tested-by","value":"domain_check_input, domain_check_input","count":8},{"name":"tested-by","value":"double_to_shortest_decimal","count":8},{"name":"tested-by","value":"double_to_shortest_decimal_bufn, double_to_shortest_decimal_bufn, double_to_shortest_decimal_bufn","count":8},{"name":"tested-by","value":"float_to_shortest_decimal_bufn, float_to_shortest_decimal_bufn, float_to_shortest_decimal_bufn","count":8},{"name":"tested-by","value":"heap_get_latest_tid, index_delete_check_htid, _bt_check_unique, _bt_check_natts, spgTestLeafTuple","count":8},{"name":"tested-by","value":"hypothetical_check_argtypes","count":8},{"name":"tested-by","value":"index_recheck_constraint","count":8},{"name":"tested-by","value":"jsonb_subscript_check_subscripts, pg_isolation_test_session_is_blocked","count":8},{"name":"tested-by","value":"lazy_check_wraparound_failsafe, _bt_check_unique, _bt_check_third_page, check_nested_generated_walker, check_nested_generated_walker, heap_truncate_check_FKs, heap_truncate_check_FKs, check_object_own","count":8},{"name":"tested-by","value":"lazy_check_wraparound_failsafe, _bt_check_unique, _bt_check_third_page, heap_truncate_check_FKs, check_publications_origin, check_agg_arguments_walker, check_lateral_ref_ok, check_stack_depth, check_s","count":8},{"name":"tested-by","value":"lazy_check_wraparound_failsafe, _bt_check_unique, _bt_check_unique, _bt_check_third_page, table_tuple_get_latest_tid, check_default_table_access_method, server_check_detail, restrict_and_check_grant, ","count":8},{"name":"tested-by","value":"pg_attribute_aclcheck_all_ext, pg_isolation_test_session_is_blocked, pg_isolation_test_session_is_blocked","count":8},{"name":"tested-by","value":"populate_array_check_dimension","count":8},{"name":"tested-by","value":"recheck_cast_function_args","count":8},{"name":"tested-by","value":"recheck_relation_needs_vacanalyze","count":8},{"name":"tested-by","value":"spgInnerTest, check_wal_consistency_checking, check_domain_for_new_field, check_domain_for_new_field, json_unique_check_init, test_strlower, test_strlower, test_strlower, test_strlower","count":8},{"name":"tested-by","value":"test_config_settings, test_config_settings, test_config_settings, test_config_settings, check_ok, check_ok, check_ok, test_sync, test_sync, test_sync, test_sync, test_sync, test_open_sync, test_file_d","count":8},{"name":"tested-by","value":"test_lockmode_for_conflict, check_safe_enum_use","count":8},{"name":"tested-by","value":"test_open, test_file_descriptor_sync, test_file_descriptor_sync","count":8},{"name":"tested-by","value":"test_open, test_open, test_open, test_sync, test_sync, test_sync, test_sync, test_sync, test_file_descriptor_sync, test_file_descriptor_sync, test_file_descriptor_sync, test_file_descriptor_sync, test","count":8},{"name":"tested-by","value":"test_strlower, test_strlower","count":8},{"name":"tested-by","value":"test_strlower, test_strlower, test_strlower, test_strlower","count":8},{"name":"tested-by","value":"test_sync","count":8},{"name":"tested-by","value":"test_timing, test_timing, check_for_data_types_usage, check_for_data_types_usage, check_proper_datallowconn, check_for_isn_and_int8_passing_mismatch, check_for_isn_and_int8_passing_mismatch, check_for","count":8},{"name":"Feature","value":"ALTER TABLE ... SET ACCESS METHOD","count":7},{"name":"Feature","value":"Changing column types (ALTER TABLE .. ALTER COLUMN TYPE)","count":7},{"name":"Feature","value":"Large object access controls","count":7},{"name":"Feature","value":"Materialized Views","count":7},{"name":"Feature","value":"Variadic functions","count":7},{"name":"Feature","value":"ALTER TABLE ... ADD UNIQUE/PRIMARY KEY USING INDEX","count":6},{"name":"Feature","value":"Window functions","count":6},{"name":"Feature","value":"xml2","count":6},{"name":"api-example","value":"BitmapHeapScanState * ExecInitBitmapHeapScan(BitmapHeapScan *node, EState *estate, int eflags) { BitmapHeapScanState *scanstate; Relation\tcurrentRelation; Assert(!(eflags & (EXEC_FLAG_BACKWARD | EXEC_...","count":6},{"name":"api-example","value":"BlockNumber ss_get_location(Relation rel, BlockNumber relnblocks) { BlockNumber startloc; LWLockAcquire(SyncScanLock, LW_EXCLUSIVE); startloc = ss_search(rel->rd_locator, 0, false); LWLockRelease(Sync...","count":6},{"name":"api-example","value":"BrinTuple * brin_copy_tuple(BrinTuple *tuple, Size len, BrinTuple *dest, Size *destsz) { if (!destsz || *destsz == 0) dest = palloc(len); else if (len > *destsz) { dest = repalloc(dest, len); *destsz ...","count":6},{"name":"api-example","value":"Buffer ReleaseAndReadBuffer(Buffer buffer, Relation relation, BlockNumber blockNum) { ForkNumber\tforkNum = MAIN_FORKNUM; BufferDesc *bufHdr; if (BufferIsValid(buffer)) { Assert(BufferIsPinned(buffer))...","count":6},{"name":"api-example","value":"ConfigData * get_configdata(const char *my_exec_path, size_t *configdata_len) { ConfigData *configdata; char\t\tpath[MAXPGPATH]; char\t   *lastsep; int\t\t\ti = 0; *configdata_len = 23; configdata = palloc_...","count":6},{"name":"api-example","value":"ConfigVariable * ProcessConfigFileInternal(GucContext context, bool applySettings, int elevel) { bool\t\terror = false; bool\t\tapplying = false; const char *ConfFileWithError; ConfigVariable *item, *head...","count":6},{"name":"api-example","value":"DIR * AllocateDir(const char *dirname) { DIR\t\t   *dir; DO_DB(elog(LOG, \"AllocateDir: Allocated %d (%s)\", numAllocatedDescs, dirname)); if (!reserveAllocatedDesc()) ereport(ERROR, (errcode(ERRCODE_INSU...","count":6},{"name":"api-example","value":"DateADT GetSQLCurrentDate(void) { struct pg_tm tm; static int\tcache_year = 0; static int\tcache_mon = 0; static int\tcache_mday = 0; static DateADT cache_date; GetCurrentDateTime(&tm); * date2j involves...","count":6},{"name":"api-example","value":"Datum RI_FKey_noaction_del(PG_FUNCTION_ARGS) { ri_CheckTrigger(fcinfo, \"RI_FKey_noaction_del\", RI_TRIGTYPE_DELETE); return ri_restrict((TriggerData *) fcinfo->context, true); }","count":6},{"name":"api-example","value":"Datum aclitemout(PG_FUNCTION_ARGS) { AclItem    *aip = PG_GETARG_ACLITEM_P(0); char\t   *p; char\t   *out; HeapTuple\thtup; unsigned\ti; out = palloc(strlen(\"=/\") + 2 * N_ACL_RIGHTS + 2 * (2 * NAMEDATALEN...","count":6},{"name":"api-example","value":"Datum array_agg_serialize(PG_FUNCTION_ARGS) { ArrayBuildState *state; StringInfoData buf; bytea\t   *result; Assert(AggCheckCallContext(fcinfo, NULL)); state = (ArrayBuildState *) PG_GETARG_POINTER(0);...","count":6},{"name":"api-example","value":"Datum arraycontsel(PG_FUNCTION_ARGS) { PlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0); Oid\t\t\toperator = PG_GETARG_OID(1); List\t   *args = (List *) PG_GETARG_POINTER(2); int\t\t\tvarRelid = PG_G...","count":6},{"name":"api-example","value":"Datum bit(PG_FUNCTION_ARGS) { VarBit\t   *arg = PG_GETARG_VARBIT_P(0); int32\t\tlen = PG_GETARG_INT32(1); bool\t\tisExplicit = PG_GETARG_BOOL(2); VarBit\t   *result; int\t\t\trlen; if (len <= 0 || len > VARBIT...","count":6},{"name":"api-example","value":"Datum bit_recv(PG_FUNCTION_ARGS) { StringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0); #ifdef NOT_USED Oid\t\t\ttypelem = PG_GETARG_OID(1); #endif int32\t\tatttypmod = PG_GETARG_INT32(2); VarBit\t   *result...","count":6},{"name":"api-example","value":"Datum box_center(PG_FUNCTION_ARGS) { BOX\t\t   *box = PG_GETARG_BOX_P(0); Point\t   *result = (Point *) palloc(sizeof(Point)); box_cn(result, box); PG_RETURN_POINT_P(result); }","count":6},{"name":"api-example","value":"Datum brin_minmax_multi_distance_numeric(PG_FUNCTION_ARGS) { Datum\t\td; Datum\t\ta1 = PG_GETARG_DATUM(0); Datum\t\ta2 = PG_GETARG_DATUM(1); * We know the values are range boundaries, but the range may be c...","count":6},{"name":"api-example","value":"Datum brin_minmax_multi_distance_tid(PG_FUNCTION_ARGS) { double\t\tda1, da2; ItemPointer pa1 = (ItemPointer) PG_GETARG_DATUM(0); ItemPointer pa2 = (ItemPointer) PG_GETARG_DATUM(1); * We know the values ...","count":6},{"name":"api-example","value":"Datum cash_out(PG_FUNCTION_ARGS) { Cash\t\tvalue = PG_GETARG_CASH(0); char\t   *result; char\t\tbuf[128]; char\t   *bufptr; int\t\t\tdigit_pos; int\t\t\tpoints, mon_group; char\t\tdsymbol; const char *ssymbol, *csy...","count":6},{"name":"api-example","value":"Datum dacosd(PG_FUNCTION_ARGS) { float8\t\targ1 = PG_GETARG_FLOAT8(0); float8\t\tresult; if (isnan(arg1)) PG_RETURN_FLOAT8(get_float8_nan()); INIT_DEGREE_CONSTANTS(); * The principal branch of the inverse...","count":6},{"name":"api-example","value":"Datum dtof(PG_FUNCTION_ARGS) { float8\t\tnum = PG_GETARG_FLOAT8(0); float4\t\tresult; result = (float4) num; if (unlikely(isinf(result)) && !isinf(num)) float_overflow_error(); if (unlikely(result == 0.0f...","count":6},{"name":"api-example","value":"Datum expand_array(Datum arraydatum, MemoryContext parentcontext, ArrayMetaState *metacache) { ArrayType  *array; ExpandedArrayHeader *eah; MemoryContext objcxt; MemoryContext oldcxt; ArrayMetaState f...","count":6},{"name":"api-example","value":"Datum expanded_record_fetch_field(ExpandedRecordHeader *erh, int fnumber, bool *isnull) { if (fnumber > 0) { if (ExpandedRecordIsEmpty(erh)) { *isnull = true; return (Datum) 0; } deconstruct_expanded_...","count":6},{"name":"api-example","value":"Datum float8_combine(PG_FUNCTION_ARGS) { ArrayType  *transarray1 = PG_GETARG_ARRAYTYPE_P(0); ArrayType  *transarray2 = PG_GETARG_ARRAYTYPE_P(1); float8\t   *transvalues1; float8\t   *transvalues2; float...","count":6},{"name":"api-example","value":"Datum fmgr_internal_validator(PG_FUNCTION_ARGS) { Oid\t\t\tfuncoid = PG_GETARG_OID(0); HeapTuple\ttuple; Datum\t\ttmp; char\t   *prosrc; if (!CheckFunctionValidatorAccess(fcinfo->flinfo->fn_oid, funcoid)) PG...","count":6},{"name":"api-example","value":"Datum gin_extract_jsonb(PG_FUNCTION_ARGS) { Jsonb\t   *jb = (Jsonb *) PG_GETARG_JSONB_P(0); int32\t   *nentries = (int32 *) PG_GETARG_POINTER(1); int\t\t\ttotal = JB_ROOT_COUNT(jb); JsonbIterator *it; Json...","count":6},{"name":"api-example","value":"Datum gin_extract_tsvector(PG_FUNCTION_ARGS) { TSVector\tvector = PG_GETARG_TSVECTOR(0); int32\t   *nentries = (int32 *) PG_GETARG_POINTER(1); Datum\t   *entries = NULL; *nentries = vector->size; if (vec...","count":6},{"name":"api-example","value":"Datum gist_circle_compress(PG_FUNCTION_ARGS) { GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0); GISTENTRY  *retval; if (entry->leafkey) { CIRCLE\t   *in = DatumGetCircleP(entry->key); BOX\t\t   *r...","count":6},{"name":"api-example","value":"Datum gist_circle_consistent(PG_FUNCTION_ARGS) { GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0); CIRCLE\t   *query = PG_GETARG_CIRCLE_P(1); StrategyNumber strategy = (StrategyNumber) PG_GETARG_...","count":6},{"name":"api-example","value":"Datum gtsvector_union(PG_FUNCTION_ARGS) { GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0); int\t\t   *size = (int *) PG_GETARG_POINTER(1); int\t\t\tsiglen = GET_SIGLEN(); SignTSVector ...","count":6},{"name":"api-example","value":"Datum has_column_privilege_name_name_name(PG_FUNCTION_ARGS) { Name\t\trolename = PG_GETARG_NAME(0); text\t   *tablename = PG_GETARG_TEXT_PP(1); text\t   *column = PG_GETARG_TEXT_PP(2); text\t   *priv_type_...","count":6},{"name":"api-example","value":"Datum inet_merge(PG_FUNCTION_ARGS) { inet\t   *a1 = PG_GETARG_INET_PP(0), *a2 = PG_GETARG_INET_PP(1); int\t\t\tcommonbits; if (ip_family(a1) != ip_family(a2)) ereport(ERROR, (errcode(ERRCODE_INVALID_PARAM...","count":6},{"name":"api-example","value":"Datum inet_to_cidr(PG_FUNCTION_ARGS) { inet\t   *src = PG_GETARG_INET_PP(0); int\t\t\tbits; bits = ip_bits(src); if ((bits < 0) || (bits > ip_maxbits(src))) elog(ERROR, \"invalid inet bit length: %d\", bits...","count":6},{"name":"api-example","value":"Datum interval_in(PG_FUNCTION_ARGS) { char\t   *str = PG_GETARG_CSTRING(0); #ifdef NOT_USED Oid\t\t\ttypelem = PG_GETARG_OID(1); #endif int32\t\ttypmod = PG_GETARG_INT32(2); Node\t   *escontext = fcinfo->con...","count":6},{"name":"api-example","value":"Datum interval_time(PG_FUNCTION_ARGS) { Interval   *span = PG_GETARG_INTERVAL_P(0); TimeADT\t\tresult; if (INTERVAL_NOT_FINITE(span)) ereport(ERROR, (errcode(ERRCODE_DATETIME_VALUE_OUT_OF_RANGE), errmsg...","count":6},{"name":"api-example","value":"Datum json_in(PG_FUNCTION_ARGS) { char\t   *json = PG_GETARG_CSTRING(0); text\t   *result = cstring_to_text(json); JsonLexContext lex; makeJsonLexContext(&lex, result, false); if (!pg_parse_json_or_errs...","count":6},{"name":"api-example","value":"Datum json_recv(PG_FUNCTION_ARGS) { StringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0); char\t   *str; int\t\t\tnbytes; JsonLexContext lex; str = pq_getmsgtext(buf, buf->len - buf->cursor, &nbytes); makeJ...","count":6},{"name":"api-example","value":"Datum jsonb_set_element(Jsonb *jb, Datum *path, int path_len, JsonbValue *newval) { JsonbValue *res; JsonbParseState *state = NULL; JsonbIterator *it; bool\t   *path_nulls = palloc0(path_len * sizeof(b...","count":6},{"name":"api-example","value":"Datum line_out(PG_FUNCTION_ARGS) { LINE\t   *line = PG_GETARG_LINE_P(0); char\t   *astr = float8out_internal(line->A); char\t   *bstr = float8out_internal(line->B); char\t   *cstr = float8out_internal(lin...","count":6},{"name":"api-example","value":"Datum lseg_out(PG_FUNCTION_ARGS) { LSEG\t   *ls = PG_GETARG_LSEG_P(0); PG_RETURN_CSTRING(path_encode(PATH_OPEN, 2, &ls->p[0])); }","count":6},{"name":"api-example","value":"Datum make_timestamptz_at_timezone(PG_FUNCTION_ARGS) { int32\t\tyear = PG_GETARG_INT32(0); int32\t\tmonth = PG_GETARG_INT32(1); int32\t\tmday = PG_GETARG_INT32(2); int32\t\thour = PG_GETARG_INT32(3); int32\t\tm...","count":6},{"name":"api-example","value":"Datum multirangesel(PG_FUNCTION_ARGS) { PlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0); Oid\t\t\toperator = PG_GETARG_OID(1); List\t   *args = (List *) PG_GETARG_POINTER(2); int\t\t\tvarRelid = PG_...","count":6},{"name":"api-example","value":"Datum numeric_accum(PG_FUNCTION_ARGS) { NumericAggState *state; state = PG_ARGISNULL(0) ? NULL : (NumericAggState *) PG_GETARG_POINTER(0); if (state == NULL) state = makeNumericAggState(fcinfo, true);...","count":6},{"name":"api-example","value":"Datum numeric_avg_serialize(PG_FUNCTION_ARGS) { NumericAggState *state; StringInfoData buf; bytea\t   *result; NumericVar\ttmp_var; if (!AggCheckCallContext(fcinfo, NULL)) elog(ERROR, \"aggregate functio...","count":6},{"name":"api-example","value":"Datum numeric_sqrt(PG_FUNCTION_ARGS) { Numeric\t\tnum = PG_GETARG_NUMERIC(0); Numeric\t\tres; NumericVar\targ; NumericVar\tresult; int\t\t\tsweight; int\t\t\trscale; * Handle NaN and infinities */ if (NUMERIC_IS_...","count":6},{"name":"api-example","value":"Datum numeric_to_number(PG_FUNCTION_ARGS) { text\t   *value = PG_GETARG_TEXT_PP(0); text\t   *fmt = PG_GETARG_TEXT_PP(1); NUMDesc\t\tNum; Datum\t\tresult; FormatNode *format; char\t   *numstr; bool\t\tshouldFr...","count":6},{"name":"api-example","value":"Datum path_area(PG_FUNCTION_ARGS) { PATH\t   *path = PG_GETARG_PATH_P(0); float8\t\tarea = 0.0; int\t\t\ti, j; if (!path->closed) PG_RETURN_NULL(); for (i = 0; i < path->npts; i++) { j = (i + 1) % path->npt...","count":6},{"name":"api-example","value":"Datum path_close(PG_FUNCTION_ARGS) { PATH\t   *path = PG_GETARG_PATH_P_COPY(0); path->closed = true; PG_RETURN_PATH_P(path); }","count":6},{"name":"api-example","value":"Datum path_in(PG_FUNCTION_ARGS) { char\t   *str = PG_GETARG_CSTRING(0); Node\t   *escontext = fcinfo->context; PATH\t   *path; bool\t\tisopen; char\t   *s; int\t\t\tnpts; int\t\t\tsize; int\t\t\tbase_size; int\t\t\tdep...","count":6},{"name":"api-example","value":"Datum pg_get_ruledef(PG_FUNCTION_ARGS) { Oid\t\t\truleoid = PG_GETARG_OID(0); int\t\t\tprettyFlags; char\t   *res; prettyFlags = PRETTYFLAG_INDENT; res = pg_get_ruledef_worker(ruleoid, prettyFlags); if (res ...","count":6},{"name":"api-example","value":"Datum pg_get_viewdef(PG_FUNCTION_ARGS) { Oid\t\t\tviewoid = PG_GETARG_OID(0); int\t\t\tprettyFlags; char\t   *res; prettyFlags = PRETTYFLAG_INDENT; res = pg_get_viewdef_worker(viewoid, prettyFlags, WRAP_COLU...","count":6},{"name":"api-example","value":"Datum pg_has_role_name_name(PG_FUNCTION_ARGS) { Name\t\tusername = PG_GETARG_NAME(0); Name\t\trolename = PG_GETARG_NAME(1); text\t   *priv_type_text = PG_GETARG_TEXT_PP(2); Oid\t\t\troleid; Oid\t\t\troleoid; Acl...","count":6},{"name":"api-example","value":"Datum pg_identify_object(PG_FUNCTION_ARGS) { Oid\t\t\tclassid = PG_GETARG_OID(0); Oid\t\t\tobjid = PG_GETARG_OID(1); int32\t\tobjsubid = PG_GETARG_INT32(2); Oid\t\t\tschema_oid = InvalidOid; const char *objname ...","count":6},{"name":"api-example","value":"Datum pg_input_error_info(PG_FUNCTION_ARGS) { text\t   *txt = PG_GETARG_TEXT_PP(0); text\t   *typname = PG_GETARG_TEXT_PP(1); ErrorSaveContext escontext = {T_ErrorSaveContext}; TupleDesc\ttupdesc; Datum\t...","count":6},{"name":"api-example","value":"Datum pg_last_committed_xact(PG_FUNCTION_ARGS) { TransactionId xid; RepOriginId nodeid; TimestampTz ts; Datum\t\tvalues[3]; bool\t\tnulls[3]; TupleDesc\ttupdesc; HeapTuple\thtup; xid = GetLatestCommitTsData...","count":6},{"name":"api-example","value":"Datum pg_prepared_statement(PG_FUNCTION_ARGS) { ReturnSetInfo *rsinfo = (ReturnSetInfo *) fcinfo->resultinfo; * We put all the tuples into a tuplestore in one scan of the hashtable. * This avoids any ...","count":6},{"name":"api-example","value":"Datum pg_replication_origin_xact_setup(PG_FUNCTION_ARGS) { XLogRecPtr\tlocation = PG_GETARG_LSN(0); replorigin_check_prerequisites(true, false); if (session_replication_state == NULL) ereport(ERROR, (e...","count":6},{"name":"api-example","value":"Datum pg_wal_replay_pause(PG_FUNCTION_ARGS) { if (!RecoveryInProgress()) ereport(ERROR, (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE), errmsg(\"recovery is not in progress\"), errhint(\"Recovery con...","count":6},{"name":"api-example","value":"Datum range_in(PG_FUNCTION_ARGS) { char\t   *input_str = PG_GETARG_CSTRING(0); Oid\t\t\trngtypoid = PG_GETARG_OID(1); Oid\t\t\ttypmod = PG_GETARG_INT32(2); Node\t   *escontext = fcinfo->context; RangeType  *r...","count":6},{"name":"api-example","value":"Datum range_merge_from_multirange(PG_FUNCTION_ARGS) { MultirangeType *mr = PG_GETARG_MULTIRANGE_P(0); Oid\t\t\tmltrngtypoid = MultirangeTypeGetOid(mr); TypeCacheEntry *typcache; RangeType  *result; typca...","count":6},{"name":"api-example","value":"Datum table_to_xmlschema(PG_FUNCTION_ARGS) { Oid\t\t\trelid = PG_GETARG_OID(0); bool\t\tnulls = PG_GETARG_BOOL(1); bool\t\ttableforest = PG_GETARG_BOOL(2); const char *targetns = text_to_cstring(PG_GETARG_TE...","count":6},{"name":"api-example","value":"Datum tidin(PG_FUNCTION_ARGS) { char\t   *str = PG_GETARG_CSTRING(0); Node\t   *escontext = fcinfo->context; char\t   *p, *coord[NTIDARGS]; int\t\t\ti; ItemPointer result; BlockNumber blockNumber; OffsetNum...","count":6},{"name":"api-example","value":"Datum tidout(PG_FUNCTION_ARGS) { ItemPointer itemPtr = PG_GETARG_ITEMPOINTER(0); BlockNumber blockNumber; OffsetNumber offsetNumber; char\t\tbuf[32]; blockNumber = ItemPointerGetBlockNumberNoCheck(itemP...","count":6},{"name":"api-example","value":"Datum timestamp_date(PG_FUNCTION_ARGS) { Timestamp\ttimestamp = PG_GETARG_TIMESTAMP(0); DateADT\t\tresult; struct pg_tm tt, *tm = &tt; fsec_t\t\tfsec; if (TIMESTAMP_IS_NOBEGIN(timestamp)) DATE_NOBEGIN(resu...","count":6},{"name":"api-example","value":"Datum transformGenericOptions(Oid catalogId, Datum oldOptions, List *options, Oid fdwvalidator) { List\t   *resultOptions = untransformRelOptions(oldOptions); ListCell   *optcell; Datum\t\tresult; foreac...","count":6},{"name":"api-example","value":"Datum ts_lexize(PG_FUNCTION_ARGS) { Oid\t\t\tdictId = PG_GETARG_OID(0); text\t   *in = PG_GETARG_TEXT_PP(1); ArrayType  *a; TSDictionaryCacheEntry *dict; TSLexeme   *res, *ptr; Datum\t   *da; DictSubState ...","count":6},{"name":"api-example","value":"Datum width_bucket_numeric(PG_FUNCTION_ARGS) { Numeric\t\toperand = PG_GETARG_NUMERIC(0); Numeric\t\tbound1 = PG_GETARG_NUMERIC(1); Numeric\t\tbound2 = PG_GETARG_NUMERIC(2); int32\t\tcount = PG_GETARG_INT32(3...","count":6},{"name":"api-example","value":"Datum xid8in(PG_FUNCTION_ARGS) { char\t   *str = PG_GETARG_CSTRING(0); uint64\t\tresult; result = uint64in_subr(str, NULL, \"xid8\", fcinfo->context); PG_RETURN_FULLTRANSACTIONID(FullTransactionIdFromU64(r...","count":6},{"name":"api-example","value":"Datum xid8toxid(PG_FUNCTION_ARGS) { FullTransactionId fxid = PG_GETARG_FULLTRANSACTIONID(0); PG_RETURN_TRANSACTIONID(XidFromFullTransactionId(fxid)); }","count":6},{"name":"api-example","value":"ExpandedRecordHeader * make_expanded_record_from_typeid(Oid type_id, int32 typmod, MemoryContext parentcontext) { ExpandedRecordHeader *erh; int\t\t\tflags = 0; TupleDesc\ttupdesc; uint64\t\ttupdesc_id; Mem...","count":6},{"name":"api-example","value":"FILE * OpenPipeStream(const char *command, const char *mode) { FILE\t   *file; int\t\t\tsave_errno; DO_DB(elog(LOG, \"OpenPipeStream: Allocated %d (%s)\", numAllocatedDescs, command)); if (!reserveAllocated...","count":6},{"name":"api-example","value":"HTAB * ShmemInitHash(const char *name,\t\t/* table string name for shmem index */ long init_size,\t/* initial table size */ long max_size,\t/* max size of the table */ HASHCTL *infoP,\t/* info about key an...","count":6},{"name":"api-example","value":"HV * plperl_spi_exec(char *query, int limit) { HV\t\t   *ret_hv; * Execute the query inside a sub-transaction, so we can cope with errors * sanely */ MemoryContext oldcontext = CurrentMemoryContext; Res...","count":6},{"name":"api-example","value":"HeapTuple BuildTupleFromCStrings(AttInMetadata *attinmeta, char **values) { TupleDesc\ttupdesc = attinmeta->tupdesc; int\t\t\tnatts = tupdesc->natts; Datum\t   *dvalues; bool\t   *nulls; int\t\t\ti; HeapTuple\t...","count":6},{"name":"api-example","value":"HeapTuple heap_modify_tuple(HeapTuple tuple, TupleDesc tupleDesc, const Datum *replValues, const bool *replIsnull, const bool *doReplace) { int\t\t\tnumberOfAttributes = tupleDesc->natts; int\t\t\tattoff; D...","count":6},{"name":"api-example","value":"IndexBuildResult * gistbuild(Relation heap, Relation index, IndexInfo *indexInfo) { IndexBuildResult *result; double\t\treltuples; GISTBuildState buildstate; MemoryContext oldcxt = CurrentMemoryContext;...","count":6},{"name":"api-example","value":"IndexTuple _bt_form_posting(IndexTuple base, ItemPointer htids, int nhtids) { uint32\t\tkeysize, newsize; IndexTuple\titup; if (BTreeTupleIsPosting(base)) keysize = BTreeTupleGetPostingOffset(base); else...","count":6},{"name":"api-example","value":"JoinExpr * convert_EXISTS_sublink_to_join(PlannerInfo *root, SubLink *sublink, bool under_not, Relids available_rels) { JoinExpr   *result; Query\t   *parse = root->parse; Query\t   *subselect = (Query ...","count":6},{"name":"api-example","value":"Jsonb * JsonbValueToJsonb(JsonbValue *val) { Jsonb\t   *out; if (IsAJsonbScalar(val)) { JsonbParseState *pstate = NULL; JsonbValue *res; JsonbValue\tscalarArray; scalarArray.type = jbvArray; scalarArray...","count":6},{"name":"api-example","value":"LLVMValueRef llvm_function_reference(LLVMJitContext *context, LLVMBuilderRef builder, LLVMModuleRef mod, FunctionCallInfo fcinfo) { char\t   *modname; char\t   *basename; char\t   *funcname; LLVMValueRef...","count":6},{"name":"api-example","value":"List * CopyGetAttnums(TupleDesc tupDesc, Relation rel, List *attnamelist) { List\t   *attnums = NIL; if (attnamelist == NIL) { int\t\t\tattr_count = tupDesc->natts; int\t\t\ti; for (i = 0; i < attr_count; i+...","count":6},{"name":"api-example","value":"List * pg_parse_query(const char *query_string) { List\t   *raw_parsetree_list; TRACE_POSTGRESQL_QUERY_PARSE_START(query_string); if (log_parser_stats) ResetUsage(); raw_parsetree_list = raw_parser(que...","count":6},{"name":"api-example","value":"LogicalRepWorker * logicalrep_worker_find(Oid subid, Oid relid, bool only_running) { int\t\t\ti; LogicalRepWorker *res = NULL; Assert(LWLockHeldByMe(LogicalRepWorkerLock)); for (i = 0; i < max_logical_re...","count":6},{"name":"api-example","value":"MemoryContext BumpContextCreate(MemoryContext parent, const char *name, Size minContextSize, Size initBlockSize, Size maxBlockSize) { Size\t\tfirstBlockSize; Size\t\tallocSize; BumpContext *set; BumpBlock...","count":6},{"name":"api-example","value":"MemoryContext GenerationContextCreate(MemoryContext parent, const char *name, Size minContextSize, Size initBlockSize, Size maxBlockSize) { Size\t\tfirstBlockSize; Size\t\tallocSize; GenerationContext *se...","count":6},{"name":"api-example","value":"MemoryContext GetMemoryChunkContext(void *pointer) { return MCXT_METHOD(pointer, get_chunk_context) (pointer); }","count":6},{"name":"api-example","value":"Node * negate_clause(Node *node) { if (node == NULL)\t\t\t/* should not happen */ elog(ERROR, \"can't negate an empty subexpression\"); switch (nodeTag(node)) { case T_Const: { Const\t   *c = (Const *) node...","count":6},{"name":"api-example","value":"ObjectAddress DefineCollation(ParseState *pstate, List *names, List *parameters, bool if_not_exists) { char\t   *collName; Oid\t\t\tcollNamespace; AclResult\taclresult; ListCell   *pl; DefElem    *fromEl =...","count":6},{"name":"api-example","value":"ObjectAddress DefineOpClass(CreateOpClassStmt *stmt) { char\t   *opcname;\t\t/* name of opclass we're creating */ Oid\t\t\tamoid,\t\t\t/* our AM's oid */ typeoid,\t\t/* indexable datatype oid */ storageoid,\t\t/* ...","count":6},{"name":"api-example","value":"ObjectAddress DefineSequence(ParseState *pstate, CreateSeqStmt *seq) { FormData_pg_sequence seqform; FormData_pg_sequence_data seqdataform; bool\t\tneed_seq_rewrite; List\t   *owned_by; CreateStmt *stmt ...","count":6},{"name":"api-example","value":"ObjectAddress ExecCreateTableAs(ParseState *pstate, CreateTableAsStmt *stmt, ParamListInfo params, QueryEnvironment *queryEnv, QueryCompletion *qc) { Query\t   *query = castNode(Query, stmt->query); In...","count":6},{"name":"api-example","value":"ObjectAddress ProcedureCreate(const char *procedureName, Oid procNamespace, bool replace, bool returnsSet, Oid returnType, Oid proowner, Oid languageObjectId, Oid languageValidator, const char *prosrc...","count":6},{"name":"api-example","value":"ObjectAddress publication_add_relation(Oid pubid, PublicationRelInfo *pri, bool if_not_exists) { Relation\trel; HeapTuple\ttup; Datum\t\tvalues[Natts_pg_publication_rel]; bool\t\tnulls[Natts_pg_publication_...","count":6},{"name":"api-example","value":"OffsetNumber _bt_findsplitloc(Relation rel, Page origpage, OffsetNumber newitemoff, Size newitemsz, IndexTuple newitem, bool *newitemonleft) { BTPageOpaque opaque; int\t\t\tleftspace, rightspace, olddata...","count":6},{"name":"api-example","value":"OffsetNumber brin_doinsert(Relation idxrel, BlockNumber pagesPerRange, BrinRevmap *revmap, Buffer *buffer, BlockNumber heapBlk, BrinTuple *tup, Size itemsz) { Page\t\tpage; BlockNumber blk; OffsetNumber...","count":6},{"name":"api-example","value":"Oid AlterEventTrigger(AlterEventTrigStmt *stmt) { Relation\ttgrel; HeapTuple\ttup; Oid\t\t\ttrigoid; Form_pg_event_trigger evtForm; char\t\ttgenabled = stmt->tgenabled; tgrel = table_open(EventTriggerRelatio...","count":6},{"name":"api-example","value":"Oid CreateSchemaCommand(CreateSchemaStmt *stmt, const char *queryString, int stmt_location, int stmt_len) { const char *schemaName = stmt->schemaname; Oid\t\t\tnamespaceId; List\t   *parsetree_list; ListC...","count":6},{"name":"api-example","value":"Oid RangeVarGetAndCheckCreationNamespace(RangeVar *relation, LOCKMODE lockmode, Oid *existing_relation_id) { uint64\t\tinval_count; Oid\t\t\trelid; Oid\t\t\toldrelid = InvalidOid; Oid\t\t\tnspid; Oid\t\t\toldnspid ...","count":6},{"name":"api-example","value":"Oid RangeVarGetCreationNamespace(const RangeVar *newRelation) { Oid\t\t\tnamespaceId; * We check the catalog name and then ignore it. */ if (newRelation->catalogname) { if (strcmp(newRelation->catalognam...","count":6},{"name":"api-example","value":"PGconn * GetConnection(void) { PGconn\t   *tmpconn; int\t\t\targcount = 7;\t/* dbname, replication, fallback_app_name, * host, user, port, password */ int\t\t\ti; const char **keywords; const char **values; c...","count":6},{"name":"api-example","value":"PGresult * PQexec(PGconn *conn, const char *query) { if (!PQexecStart(conn)) return NULL; if (!PQsendQuery(conn, query)) return NULL; return PQexecFinish(conn); }","count":6},{"name":"api-example","value":"PGresult * PQgetResult(PGconn *conn) { PGresult   *res; if (!conn) return NULL; parseInput(conn); while (conn->asyncStatus == PGASYNC_BUSY) { int\t\t\tflushResult; * If data remains unsent, send it.  Els...","count":6},{"name":"api-example","value":"ParallelContext * CreateParallelContext(const char *library_name, const char *function_name, int nworkers) { MemoryContext oldcontext; ParallelContext *pcxt; Assert(IsInParallelMode()); Assert(nworker...","count":6},{"name":"api-example","value":"PasswordType get_password_type(const char *shadow_pass) { char\t   *encoded_salt; int\t\t\titerations; int\t\t\tkey_length = 0; pg_cryptohash_type hash_type; uint8\t\tstored_key[SCRAM_MAX_KEY_LEN]; uint8\t\tserv...","count":6},{"name":"api-example","value":"Path * reparameterize_path_by_child(PlannerInfo *root, Path *path, RelOptInfo *child_rel) { Path\t   *new_path; ParamPathInfo *new_ppi; ParamPathInfo *old_ppi; Relids\t\trequired_outer; #define ADJUST_CH...","count":6},{"name":"api-example","value":"Plan * create_plan(PlannerInfo *root, Path *best_path) { Plan\t   *plan; Assert(root->plan_params == NIL); root->curOuterRels = NULL; root->curOuterParams = NIL; plan = create_plan_recurse(root, best_p...","count":6},{"name":"api-example","value":"Port * pq_init(ClientSocket *client_sock) { Port\t   *port; int\t\t\tsocket_pos PG_USED_FOR_ASSERTS_ONLY; int\t\t\tlatch_pos PG_USED_FOR_ASSERTS_ONLY; port = palloc0(sizeof(Port)); port->sock = client_sock->...","count":6},{"name":"api-example","value":"ReadStream * read_stream_begin_relation(int flags, BufferAccessStrategy strategy, Relation rel, ForkNumber forknum, ReadStreamBlockNumberCB callback, void *callback_private_data, size_t per_buffer_dat...","count":6},{"name":"api-example","value":"Relation heap_create(const char *relname, Oid relnamespace, Oid reltablespace, Oid relid, RelFileNumber relfilenumber, Oid accessmtd, TupleDesc tupDesc, char relkind, char relpersistence, bool shared_...","count":6},{"name":"api-example","value":"SQLFunctionParseInfoPtr prepare_sql_fn_parse_info(HeapTuple procedureTuple, Node *call_expr, Oid inputCollation) { SQLFunctionParseInfoPtr pinfo; Form_pg_proc procedureStruct = (Form_pg_proc) GETSTRUC...","count":6},{"name":"api-example","value":"Selectivity scalararraysel_containment(PlannerInfo *root, Node *leftop, Node *rightop, Oid elemtype, bool isEquality, bool useOr, int varRelid) { Selectivity selec; VariableStatData vardata; Datum\t\tco...","count":6},{"name":"api-example","value":"SplitPageLayout * gistSplit(Relation r, Page page, IndexTuple *itup,\t\t/* contains compressed entry */ int len, GISTSTATE *giststate) { IndexTuple *lvectup, *rvectup; GistSplitVector v; int\t\t\ti; SplitP...","count":6},{"name":"api-example","value":"TimeTzADT * GetSQLCurrentTime(int32 typmod) { TimeTzADT  *result; struct pg_tm tt, *tm = &tt; fsec_t\t\tfsec; int\t\t\ttz; GetCurrentTimeUsec(tm, &fsec, &tz); result = (TimeTzADT *) palloc(sizeof(TimeTzADT...","count":6},{"name":"api-example","value":"Timestamp date2timestamp_opt_overflow(DateADT dateVal, int *overflow) { Timestamp\tresult; if (overflow) *overflow = 0; if (DATE_IS_NOBEGIN(dateVal)) TIMESTAMP_NOBEGIN(result); else if (DATE_IS_NOEND(d...","count":6},{"name":"api-example","value":"TupleDesc BuildDescForRelation(const List *columns) { int\t\t\tnatts; AttrNumber\tattnum; ListCell   *l; TupleDesc\tdesc; bool\t\thas_not_null; char\t   *attname; Oid\t\t\tatttypid; int32\t\tatttypmod; Oid\t\t\tattco...","count":6},{"name":"api-example","value":"TupleTableSlot * execute_attr_map_slot(AttrMap *attrMap, TupleTableSlot *in_slot, TupleTableSlot *out_slot) { Datum\t   *invalues; bool\t   *inisnull; Datum\t   *outvalues; bool\t   *outisnull; int\t\t\toutn...","count":6},{"name":"api-example","value":"Tuplesortstate * tuplesort_begin_heap(TupleDesc tupDesc, int nkeys, AttrNumber *attNums, Oid *sortOperators, Oid *sortCollations, bool *nullsFirstFlags, int workMem, SortCoordinate coordinate, int sor...","count":6},{"name":"api-example","value":"TypeName * typeStringToTypeName(const char *str, Node *escontext) { List\t   *raw_parsetree_list; TypeName   *typeName; ErrorContextCallback ptserrcontext; if (strspn(str, \" \\t\\n\\r\\f\\v\") == strlen(str)...","count":6},{"name":"api-example","value":"XLogSegNo XLogGetOldestSegno(TimeLineID tli) { DIR\t\t   *xldir; struct dirent *xlde; XLogSegNo\toldest_segno = 0; xldir = AllocateDir(XLOGDIR); while ((xlde = ReadDir(xldir, XLOGDIR)) != NULL) { TimeLin...","count":6},{"name":"api-example","value":"__DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(int,sprintf_s,vsprintf_s,char,_DstBuf,const char*,_Format)","count":6},{"name":"api-example","value":"__mingw_ovr int __cdecl _vsnprintf_c_l(char *_DstBuf, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList) { return __stdio_common_vsprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _...","count":6},{"name":"api-example","value":"bool ConditionVariableCancelSleep(void) { ConditionVariable *cv = cv_sleep_target; bool\t\tsignaled = false; if (cv == NULL) return false; SpinLockAcquire(&cv->mutex); if (proclist_contains(&cv->wakeup,...","count":6},{"name":"api-example","value":"bool ConfigOptionIsVisible(struct config_generic *conf) { if ((conf->flags & GUC_SUPERUSER_ONLY) && !has_privs_of_role(GetUserId(), ROLE_PG_READ_ALL_SETTINGS)) return false; else return true; }","count":6},{"name":"api-example","value":"bool CreateRestartPoint(int flags) { XLogRecPtr\tlastCheckPointRecPtr; XLogRecPtr\tlastCheckPointEndPtr; CheckPoint\tlastCheckPoint; XLogRecPtr\tPriorRedoPtr; XLogRecPtr\treceivePtr; XLogRecPtr\treplayPtr; ...","count":6},{"name":"api-example","value":"bool ECPGset_desc(int lineno, const char *desc_name, int index,...) { va_list\t\targs; struct descriptor *desc; struct descriptor_item *desc_item; struct variable *var; desc = ecpg_find_desc(lineno, des...","count":6},{"name":"api-example","value":"bool IsBinaryCoercibleWithCast(Oid srctype, Oid targettype, Oid *castoid) { HeapTuple\ttuple; Form_pg_cast castForm; bool\t\tresult; *castoid = InvalidOid; if (srctype == targettype) return true; if (tar...","count":6},{"name":"api-example","value":"bool JsonbExtractScalar(JsonbContainer *jbc, JsonbValue *res) { JsonbIterator *it; JsonbIteratorToken tok PG_USED_FOR_ASSERTS_ONLY; JsonbValue\ttmp; if (!JsonContainerIsArray(jbc) || !JsonContainerIsSc...","count":6},{"name":"api-example","value":"bool NextCopyFrom(CopyFromState cstate, ExprContext *econtext, Datum *values, bool *nulls) { TupleDesc\ttupDesc; AttrNumber\tnum_phys_attrs, attr_count, num_defaults = cstate->num_defaults; FmgrInfo   *...","count":6},{"name":"api-example","value":"bool RI_Initial_Check(Trigger *trigger, Relation fk_rel, Relation pk_rel) { const RI_ConstraintInfo *riinfo; StringInfoData querybuf; char\t\tpkrelname[MAX_QUOTED_REL_NAME_LEN]; char\t\tfkrelname[MAX_QUOT...","count":6},{"name":"api-example","value":"bool RS_isRegis(const char *str) { int\t\t\tstate = RS_IN_WAIT; const char *c = str; while (*c) { if (state == RS_IN_WAIT) { if (t_isalpha(c)) else if (t_iseq(c, '[')) state = RS_IN_ONEOF; else return fa...","count":6},{"name":"api-example","value":"bool SlruScanDirectory(SlruCtl ctl, SlruScanCallback callback, void *data) { bool\t\tretval = false; DIR\t\t   *cldir; struct dirent *clde; int64\t\tsegno; int64\t\tsegpage; cldir = AllocateDir(ctl->Dir); whi...","count":6},{"name":"api-example","value":"bool _bt_bottomupdel_pass(Relation rel, Buffer buf, Relation heapRel, Size newitemsz) { OffsetNumber offnum, minoff, maxoff; Page\t\tpage = BufferGetPage(buf); BTPageOpaque opaque = BTPageGetOpaque(page...","count":6},{"name":"api-example","value":"bool _bt_doinsert(Relation rel, IndexTuple itup, IndexUniqueCheck checkUnique, bool indexUnchanged, Relation heapRel) { bool\t\tis_unique = false; BTInsertStateData insertstate; BTScanInsert itup_key; B...","count":6},{"name":"api-example","value":"bool brin_tuples_equal(const BrinTuple *a, Size alen, const BrinTuple *b, Size blen) { if (alen != blen) return false; if (memcmp(a, b, alen) != 0) return false; return true; }","count":6},{"name":"api-example","value":"bool buildACLCommands(const char *name, const char *subname, const char *nspname, const char *type, const char *acls, const char *baseacls, const char *owner, const char *prefix, int remoteVersion, PQ...","count":6},{"name":"api-example","value":"bool check_generic_type_consistency(const Oid *actual_arg_types, const Oid *declared_arg_types, int nargs) { Oid\t\t\telem_typeid = InvalidOid; Oid\t\t\tarray_typeid = InvalidOid; Oid\t\t\trange_typeid = Inval...","count":6},{"name":"api-example","value":"bool check_wal_consistency_checking(char **newval, void **extra, GucSource source) { char\t   *rawstring; List\t   *elemlist; ListCell   *l; bool\t\tnewwalconsistency[RM_MAX_ID + 1]; MemSet(newwalconsiste...","count":6},{"name":"api-example","value":"bool datum_image_eq(Datum value1, Datum value2, bool typByVal, int typLen) { Size\t\tlen1, len2; bool\t\tresult = true; if (typByVal) { result = (value1 == value2); } else if (typLen > 0) { result = (memc...","count":6},{"name":"api-example","value":"bool do_pset(const char *param, const char *value, printQueryOpt *popt, bool quiet) { size_t\t\tvallen = 0; Assert(param != NULL); if (value) vallen = strlen(value); if (strcmp(param, \"format\") == 0) { ...","count":6},{"name":"api-example","value":"bool ecpg_store_input(const int lineno, const bool force_indicator, const struct variable *var, char **tobeinserted_p, bool quote) { char\t   *mallocedval = NULL; char\t   *newcopy = NULL; * arrays are ...","count":6},{"name":"api-example","value":"bool errstart(int elevel, const char *domain) { ErrorData  *edata; bool\t\toutput_to_server; bool\t\toutput_to_client = false; int\t\t\ti; * Check some cases in which we want to promote an error into a more ...","count":6},{"name":"api-example","value":"bool exec_prog(const char *log_filename, const char *opt_log_file, bool report_error, bool exit_on_error, const char *fmt,...) { int\t\t\tresult = 0; int\t\t\twritten; char\t\tlog_file[MAXPGPATH]; #define MAX...","count":6},{"name":"api-example","value":"bool fsm_set_avail(Page page, int slot, uint8 value) { int\t\t\tnodeno = NonLeafNodesPerPage + slot; FSMPage\t\tfsmpage = (FSMPage) PageGetContents(page); uint8\t\toldvalue; Assert(slot < LeafNodesPerPage); ...","count":6},{"name":"api-example","value":"bool has_partition_attrs(Relation rel, Bitmapset *attnums, bool *used_in_expr) { PartitionKey key; int\t\t\tpartnatts; List\t   *partexprs; ListCell   *partexprs_item; int\t\t\ti; if (attnums == NULL || rel-...","count":6},{"name":"api-example","value":"bool json_validate(text *json, bool check_unique_keys, bool throw_error) { JsonLexContext lex; JsonSemAction uniqueSemAction = {0}; JsonUniqueParsingState state; JsonParseErrorType result; makeJsonLex...","count":6},{"name":"api-example","value":"bool parse_scram_secret(const char *secret, int *iterations, pg_cryptohash_type *hash_type, int *key_length, char **salt, uint8 *stored_key, uint8 *server_key) { char\t   *v; char\t   *p; char\t   *schem...","count":6},{"name":"api-example","value":"bool pg_u_prop_case_ignorable(pg_wchar code) { if (code < 0x80) return unicode_opt_ascii[code].properties & PG_U_PROP_CASE_IGNORABLE; return range_search(unicode_case_ignorable, lengthof(unicode_case_...","count":6},{"name":"api-example","value":"bool pg_u_prop_hex_digit(pg_wchar code) { if (code < 0x80) return unicode_opt_ascii[code].properties & PG_U_PROP_HEX_DIGIT; return range_search(unicode_hex_digit, lengthof(unicode_hex_digit), code); }","count":6},{"name":"api-example","value":"bool pg_u_prop_lowercase(pg_wchar code) { if (code < 0x80) return unicode_opt_ascii[code].properties & PG_U_PROP_LOWERCASE; return range_search(unicode_lowercase, lengthof(unicode_lowercase), code); }","count":6},{"name":"api-example","value":"bool pg_u_prop_uppercase(pg_wchar code) { if (code < 0x80) return unicode_opt_ascii[code].properties & PG_U_PROP_UPPERCASE; return range_search(unicode_uppercase, lengthof(unicode_uppercase), code); }","count":6},{"name":"api-example","value":"bool pg_u_prop_white_space(pg_wchar code) { if (code < 0x80) return unicode_opt_ascii[code].properties & PG_U_PROP_WHITE_SPACE; return range_search(unicode_white_space, lengthof(unicode_white_space), ...","count":6},{"name":"api-example","value":"bool pgstat_database_flush_cb(PgStat_EntryRef *entry_ref, bool nowait) { PgStatShared_Database *sharedent; PgStat_StatDBEntry *pendingent; pendingent = (PgStat_StatDBEntry *) entry_ref->pending; share...","count":6},{"name":"api-example","value":"bool process_equivalence(PlannerInfo *root, RestrictInfo **p_restrictinfo, JoinDomain *jdomain) { RestrictInfo *restrictinfo = *p_restrictinfo; Expr\t   *clause = restrictinfo->clause; Oid\t\t\topno, coll...","count":6},{"name":"api-example","value":"bool reindex_relation(const ReindexStmt *stmt, Oid relid, int flags, const ReindexParams *params) { Relation\trel; Oid\t\t\ttoast_relid; List\t   *indexIds; char\t\tpersistence; bool\t\tresult = false; ListCel...","count":6},{"name":"api-example","value":"bool scram_verify_plain_password(const char *username, const char *password, const char *secret) { char\t   *encoded_salt; char\t   *salt; int\t\t\tsaltlen; int\t\t\titerations; int\t\t\tkey_length = 0; pg_crypt...","count":6},{"name":"api-example","value":"bool tuplesort_gettuple_common(Tuplesortstate *state, bool forward, SortTuple *stup) { unsigned int tuplen; size_t\t\tnmoved; Assert(!WORKER(state)); switch (state->status) { case TSS_SORTEDINMEM: Asser...","count":6},{"name":"api-example","value":"bytea * extractRelOptions(HeapTuple tuple, TupleDesc tupdesc, amoptions_function amoptions) { bytea\t   *options; bool\t\tisnull; Datum\t\tdatum; Form_pg_class classForm; datum = fastgetattr(tuple, Anum_pg...","count":6},{"name":"api-example","value":"char * AbsoluteConfigLocation(const char *location, const char *calling_file) { if (is_absolute_path(location)) return pstrdup(location); else { char\t\tabs_path[MAXPGPATH]; if (calling_file != NULL) { ...","count":6},{"name":"api-example","value":"char * BuildParamLogString(ParamListInfo params, char **knownTextValues, int maxlen) { MemoryContext tmpCxt, oldCxt; StringInfoData buf; * NB: think not of returning params->paramValuesStr!  It may ha...","count":6},{"name":"api-example","value":"char * NameListToQuotedString(const List *names) { StringInfoData string; ListCell   *l; initStringInfo(&string); foreach(l, names) { if (l != list_head(names)) appendStringInfoChar(&string, '.'); app...","count":6},{"name":"api-example","value":"char * build_backup_content(BackupState *state, bool ishistoryfile) { char\t\tstartstrbuf[128]; char\t\tstartxlogfile[MAXFNAMELEN]; /* backup start WAL file */ XLogSegNo\tstartsegno; StringInfo\tresult = ma...","count":6},{"name":"api-example","value":"char * downcase_identifier(const char *ident, int len, bool warn, bool truncate) { char\t   *result; int\t\t\ti; bool\t\tenc_is_single_byte; result = palloc(len + 1); enc_is_single_byte = pg_database_encodi...","count":6},{"name":"api-example","value":"char * get_prompt(promptStatus_t status, ConditionalStack cstack) { #define MAX_PROMPT_SIZE 256 static char destination[MAX_PROMPT_SIZE + 1]; char\t\tbuf[MAX_PROMPT_SIZE + 1]; bool\t\tesc = false; const c...","count":6},{"name":"api-example","value":"char * pg_inet_cidr_ntop(int af, const void *src, int bits, char *dst, size_t size) { switch (af) { case PGSQL_AF_INET: return inet_cidr_ntop_ipv4(src, bits, dst, size); case PGSQL_AF_INET6: return in...","count":6},{"name":"api-example","value":"char * pnstrdup(const char *in, Size len) { char\t   *out; len = strnlen(in, len); out = palloc(len + 1); memcpy(out, in, len); out[len] = '\\0'; return out; }","count":6},{"name":"api-example","value":"char * tsearch_readline(tsearch_readline_state *stp) { char\t   *recoded; stp->lineno++; if (stp->curline) { if (stp->curline != stp->buf.data) pfree(stp->curline); stp->curline = NULL; } if (!pg_get_l...","count":6},{"name":"api-example","value":"const char * GetConfigOption(const char *name, bool missing_ok, bool restrict_privileged) { struct config_generic *record; static char buffer[256]; record = find_option(name, false, missing_ok, ERROR)...","count":6},{"name":"api-example","value":"const char * pgstat_get_slru_name(int slru_idx) { if (slru_idx < 0 || slru_idx >= SLRU_NUM_ELEMENTS) return NULL; return slru_names[slru_idx]; }","count":6},{"name":"api-example","value":"const char * show_timezone(void) { const char *tzn; tzn = pg_get_timezone_name(session_timezone); if (tzn != NULL) return tzn; return \"unknown\"; }","count":6},{"name":"api-example","value":"extern struct SN_env * SN_create_env(int S_size, int I_size) { struct SN_env * z = (struct SN_env *) calloc(1, sizeof(struct SN_env)); if (z == NULL) return NULL; z->p = create_s(); if (z->p == NULL) ...","count":6},{"name":"api-example","value":"extern symbol * create_s(void) { symbol * p; void * mem = malloc(HEAD + (CREATE_SIZE + 1) * sizeof(symbol)); if (mem == NULL) return NULL; p = (symbol *) (HEAD + (char *) mem); CAPACITY(p) = CREATE_SI...","count":6},{"name":"api-example","value":"int BlockRefTableEntryGetBlocks(BlockRefTableEntry *entry, BlockNumber start_blkno, BlockNumber stop_blkno, BlockNumber *blocks, int nblocks) { uint32\t\tstart_chunkno; uint32\t\tstop_chunkno; uint32\t\tchu...","count":6},{"name":"api-example","value":"int DecodeISO8601Interval(char *str, int *dtype, struct pg_itm_in *itm_in) { bool\t\tdatepart = true; bool\t\thavefield = false; *dtype = DTK_DELTA; ClearPgItmIn(itm_in); if (strlen(str) < 2 || str[0] != ...","count":6},{"name":"api-example","value":"int MainLoop(FILE *source) { PsqlScanState scan_state;\t/* lexer working state */ ConditionalStack cond_stack;\t/* \\if status stack */ volatile PQExpBuffer query_buf; /* buffer for query being accumulat...","count":6},{"name":"api-example","value":"int PGTYPEStimestamp_defmt_scan(char **str, char *fmt, timestamp * d, int *year, int *month, int *day, int *hour, int *minute, int *second, int *tz) { union un_fmt_comb scan_val; int\t\t\tscan_type; char...","count":6},{"name":"api-example","value":"int SimpleLruReadPage(SlruCtl ctl, int64 pageno, bool write_ok, TransactionId xid) { SlruShared\tshared = ctl->shared; LWLock\t   *banklock = SimpleLruGetBankLock(ctl, pageno); Assert(LWLockHeldByMeInMo...","count":6},{"name":"api-example","value":"int durable_rename(const char *oldfile, const char *newfile, int elevel) { int\t\t\tfd; * First fsync the old and target path (if it exists), to ensure that they * are properly persistent on disk. Syncin...","count":6},{"name":"api-example","value":"int errcode_for_file_access(void) { ErrorData  *edata = &errordata[errordata_stack_depth]; CHECK_STACK_DEPTH(); switch (edata->saved_errno) { case EPERM:\t\t\t\t/* Not super-user */ case EACCES:\t\t\t/* Perm...","count":6},{"name":"api-example","value":"int errdatatype(Oid datatypeOid) { HeapTuple\ttup; Form_pg_type typtup; tup = SearchSysCache1(TYPEOID, ObjectIdGetDatum(datatypeOid)); if (!HeapTupleIsValid(tup)) elog(ERROR, \"cache lookup failed for t...","count":6},{"name":"api-example","value":"int find_my_exec(const char *argv0, char *retpath) { char\t   *path; * If argv0 contains a separator, then PATH wasn't used. */ strlcpy(retpath, argv0, MAXPGPATH); if (first_dir_separator(retpath) != N...","count":6},{"name":"api-example","value":"int find_other_exec(const char *argv0, const char *target, const char *versionstr, char *retpath) { char\t\tcmd[MAXPGPATH]; char\t   *line; if (find_my_exec(argv0, retpath) < 0) return -1; *last_dir_sepa...","count":6},{"name":"api-example","value":"int lo_open(PGconn *conn, Oid lobjId, int mode) { int\t\t\tfd; int\t\t\tresult_len; PQArgBlock\targv[2]; PGresult   *res; if (lo_initialize(conn) < 0) return -1; argv[0].isint = 1; argv[0].len = 4; argv[0].u...","count":6},{"name":"api-example","value":"int lo_read(int fd, char *buf, int len) { int\t\t\tstatus; LargeObjectDesc *lobj; if (fd < 0 || fd >= cookies_size || cookies[fd] == NULL) ereport(ERROR, (errcode(ERRCODE_UNDEFINED_OBJECT), errmsg(\"inval...","count":6},{"name":"api-example","value":"int lo_write(int fd, const char *buf, int len) { int\t\t\tstatus; LargeObjectDesc *lobj; if (fd < 0 || fd >= cookies_size || cookies[fd] == NULL) ereport(ERROR, (errcode(ERRCODE_UNDEFINED_OBJECT), errmsg...","count":6},{"name":"api-example","value":"int main(int argc, char **argv) { static struct option long_options[] = { {\"database\", required_argument, NULL, 'd'}, {\"pgdata\", required_argument, NULL, 'D'}, {\"dry-run\", no_argument, NULL, 'n'}, {\"s...","count":6},{"name":"api-example","value":"int main(int argc, char **argv) { uint32\t\txlogid; uint32\t\txrecoff; XLogReaderState *xlogreader_state; XLogDumpPrivate private; XLogDumpConfig config; XLogStats\tstats; XLogRecord *record; XLogRecPtr\tfi...","count":6},{"name":"api-example","value":"int main(int argc, char *argv[]) { static struct option long_options[] = { {\"host\", required_argument, NULL, 'h'}, {\"port\", required_argument, NULL, 'p'}, {\"username\", required_argument, NULL, 'U'}, {...","count":6},{"name":"api-example","value":"int main(int argc, char *argv[]) { struct adhoc_opts options; int\t\t\tsuccessResult; char\t   *password = NULL; bool\t\tnew_pass; pg_logging_init(argv[0]); pg_logging_set_pre_callback(log_pre_callback); pg...","count":6},{"name":"api-example","value":"int plpgsql_yylex(void) { int\t\t\ttok1; TokenAuxData aux1; int\t\t\tkwnum; tok1 = internal_yylex(&aux1); if (tok1 == IDENT || tok1 == PARAM) { int\t\t\ttok2; TokenAuxData aux2; tok2 = internal_yylex(&aux2); i...","count":6},{"name":"api-example","value":"int process_file(char *filename, bool use_relative_path) { FILE\t   *fd; int\t\t\tresult; char\t   *oldfilename; char\t\trelpath[MAXPGPATH]; if (!filename) { fd = stdin; filename = NULL; } else if (strcmp(fi...","count":6},{"name":"api-example","value":"int32 date_cmp_timestamptz_internal(DateADT dateVal, TimestampTz dt2) { TimestampTz dt1; int\t\t\toverflow; dt1 = date2timestamptz_opt_overflow(dateVal, &overflow); if (overflow > 0) { return TIMESTAMP_I...","count":6},{"name":"api-example","value":"long pgstat_report_stat(bool force) { static TimestampTz pending_since = 0; static TimestampTz last_flush = 0; bool\t\tpartial_flush; TimestampTz now; bool\t\tnowait; pgstat_assert_is_up(); Assert(!IsTran...","count":6},{"name":"api-example","value":"pg_attribute_always_inline static int page_collect_tuples(HeapScanDesc scan, Snapshot snapshot, Page page, Buffer buffer, BlockNumber block, int lines, bool all_visible, bool check_serializable) { int...","count":6},{"name":"api-example","value":"pg_crc32c pg_comp_crc32c_armv8(pg_crc32c crc, const void *data, size_t len) { const unsigned char *p = data; const unsigned char *pend = p + len; * ARMv8 doesn't require alignment, but aligned memory ...","count":6},{"name":"api-example","value":"pg_saslprep_rc pg_saslprep(const char *input, char **output) { pg_wchar   *input_chars = NULL; pg_wchar   *output_chars = NULL; int\t\t\tinput_size; char\t   *result; int\t\t\tresult_size; int\t\t\tcount; int\t\t...","count":6},{"name":"api-example","value":"ssize_t be_gssapi_read(Port *port, void *ptr, size_t len) { OM_uint32\tmajor, minor; gss_buffer_desc input, output; ssize_t\t\tret; size_t\t\tbytes_returned = 0; gss_ctx_id_t gctx = port->gss->ctx; * The p...","count":6},{"name":"api-example","value":"static AclMode pg_namespace_aclmask_ext(Oid nsp_oid, Oid roleid, AclMode mask, AclMaskHow how, bool *is_missing) { AclMode\t\tresult; HeapTuple\ttuple; Datum\t\taclDatum; bool\t\tisNull; Acl\t\t   *acl; Oid\t\t\t...","count":6},{"name":"api-example","value":"static AffixNode * mkANode(IspellDict *Conf, int low, int high, int level, int type) { int\t\t\ti; int\t\t\tnchar = 0; uint8\t\tlastchar = '\\0'; AffixNode  *rs; AffixNodeData *data; int\t\t\tlownew = low; int\t\t\t...","count":6},{"name":"api-example","value":"static BOOL CALLBACK win32_read_locale(LPWSTR pStr, DWORD dwFlags, LPARAM lparam) { CollParam  *param = (CollParam *) lparam; char\t\tlocalebuf[NAMEDATALEN]; int\t\t\tresult; int\t\t\tenc; (void) dwFlags; res...","count":6},{"name":"api-example","value":"static Bitmapset * HeapDetermineColumnsInfo(Relation relation, Bitmapset *interesting_cols, Bitmapset *external_cols, HeapTuple oldtup, HeapTuple newtup, bool *has_external) { int\t\t\tattidx; Bitmapset ...","count":6},{"name":"api-example","value":"static BloomFilter * bloom_add_value(BloomFilter *filter, uint32 value, bool *updated) { int\t\t\ti; uint64\t\th1, h2; h1 = hash_bytes_uint32_extended(value, BLOOM_SEED_1) % filter->nbits; h2 = hash_bytes_...","count":6},{"name":"api-example","value":"static CAC_state canAcceptConnections(int backend_type) { CAC_state\tresult = CAC_OK; * Can't start backends when in startup/shutdown/inconsistent recovery * state.  We treat autovac workers the same a...","count":6},{"name":"api-example","value":"static Datum * extract_jsp_query(JsonPath *jp, StrategyNumber strat, bool pathOps, int32 *nentries, Pointer **extra_data) { JsonPathGinContext cxt; JsonPathItem root; JsonPathGinNode *node; JsonPathGi...","count":6},{"name":"api-example","value":"static Datum CopyReadBinaryAttribute(CopyFromState cstate, FmgrInfo *flinfo, Oid typioparam, int32 typmod, bool *isnull) { int32\t\tfld_size; Datum\t\tresult; if (!CopyGetInt32(cstate, &fld_size)) ereport...","count":6},{"name":"api-example","value":"static Datum each_worker_jsonb(FunctionCallInfo fcinfo, const char *funcname, bool as_text) { Jsonb\t   *jb = PG_GETARG_JSONB_P(0); ReturnSetInfo *rsi; MemoryContext old_cxt, tmp_cxt; bool\t\tskipNested ...","count":6},{"name":"api-example","value":"static Datum filter_list_to_array(List *filterlist) { ListCell   *lc; Datum\t   *data; int\t\t\ti = 0, l = list_length(filterlist); data = (Datum *) palloc(l * sizeof(Datum)); foreach(lc, filterlist) { co...","count":6},{"name":"api-example","value":"static Datum jsonb_path_exists_internal(FunctionCallInfo fcinfo, bool tz) { Jsonb\t   *jb = PG_GETARG_JSONB_P(0); JsonPath   *jp = PG_GETARG_JSONPATH_P(1); JsonPathExecResult res; Jsonb\t   *vars = NULL...","count":6},{"name":"api-example","value":"static Datum jsonb_path_match_internal(FunctionCallInfo fcinfo, bool tz) { Jsonb\t   *jb = PG_GETARG_JSONB_P(0); JsonPath   *jp = PG_GETARG_JSONPATH_P(1); JsonValueList found = {0}; Jsonb\t   *vars = NU...","count":6},{"name":"api-example","value":"static DefElem * buildDefItem(const char *name, const char *val, bool was_quoted) { if (!was_quoted && val[0] != '\\0') { int\t\t\tv; char\t   *endptr; errno = 0; v = strtoint(val, &endptr, 10); if (errno ...","count":6},{"name":"api-example","value":"static ExpandedArrayHeader * fetch_array_arg_replace_nulls(FunctionCallInfo fcinfo, int argno) { ExpandedArrayHeader *eah; Oid\t\t\telement_type; ArrayMetaState *my_extra; MemoryContext resultcxt; my_ext...","count":6},{"name":"api-example","value":"static GinTernaryValue directTriConsistentFn(GinScanKey key) { return DatumGetGinTernaryValue(FunctionCall7Coll(key->triConsistentFmgrInfo, key->collation, PointerGetDatum(key->entryRes), UInt16GetDat...","count":6},{"name":"api-example","value":"static GlobalTransaction LockGXact(const char *gid, Oid user) { int\t\t\ti; if (!twophaseExitRegistered) { before_shmem_exit(AtProcExit_Twophase, 0); twophaseExitRegistered = true; } LWLockAcquire(TwoPha...","count":6},{"name":"api-example","value":"static HeapTuple ExecCallTriggerFunc(TriggerData *trigdata, int tgindx, FmgrInfo *finfo, Instrumentation *instr, MemoryContext per_tuple_context) { LOCAL_FCINFO(fcinfo, 0); PgStat_FunctionCallUsage fc...","count":6},{"name":"api-example","value":"static JsonParseErrorType jsonb_in_scalar(void *pstate, char *token, JsonTokenType tokentype) { JsonbInState *_state = (JsonbInState *) pstate; JsonbValue\tv; Datum\t\tnumd; switch (tokentype) { case JSO...","count":6},{"name":"api-example","value":"static JsonPathExecResult executeItemOptUnwrapResult(JsonPathExecContext *cxt, JsonPathItem *jsp, JsonbValue *jb, bool unwrap, JsonValueList *found) { if (unwrap && jspAutoUnwrap(cxt)) { JsonValueList...","count":6},{"name":"api-example","value":"static JsonPathGinNode * extract_jsp_bool_expr(JsonPathGinContext *cxt, JsonPathGinPath path, JsonPathItem *jsp, bool not) { check_stack_depth(); switch (jsp->type) { case jpiAnd:\t\t\t/* expr && expr */...","count":6},{"name":"api-example","value":"static List * get_gating_quals(PlannerInfo *root, List *quals) { if (!root->hasPseudoConstantQuals) return NIL; quals = order_qual_clauses(root, quals); return extract_actual_clauses(quals, true); }","count":6},{"name":"api-example","value":"static List * merge_clump(PlannerInfo *root, List *clumps, Clump *new_clump, int num_gene, bool force) { ListCell   *lc; int\t\t\tpos; foreach(lc, clumps) { Clump\t   *old_clump = (Clump *) lfirst(lc); if...","count":6},{"name":"api-example","value":"static Node * add_nullingrels_if_needed(PlannerInfo *root, Node *newnode, Var *oldvar) { if (oldvar->varnullingrels == NULL) return newnode;\t\t\t/* nothing to do */ if (is_standard_join_alias_expression...","count":6},{"name":"api-example","value":"static Node * buildMergedJoinVar(ParseState *pstate, JoinType jointype, Var *l_colvar, Var *r_colvar) { Oid\t\t\toutcoltype; int32\t\toutcoltypmod; Node\t   *l_node, *r_node, *res_node; outcoltype = select_...","count":6},{"name":"api-example","value":"static Node * get_rule_sortgroupclause(Index ref, List *tlist, bool force_colno, deparse_context *context) { StringInfo\tbuf = context->buf; TargetEntry *tle; Node\t   *expr; tle = get_sortgroupref_tle(...","count":6},{"name":"api-example","value":"static Node * remove_useless_results_recurse(PlannerInfo *root, Node *jtnode, Node **parent_quals, Relids *dropped_outer_joins) { Assert(jtnode != NULL); if (IsA(jtnode, RangeTblRef)) { } else if (IsA...","count":6},{"name":"api-example","value":"static Node * transformAExprOp(ParseState *pstate, A_Expr *a) { Node\t   *lexpr = a->lexpr; Node\t   *rexpr = a->rexpr; Node\t   *result; * Special-case \"foo = NULL\" and \"NULL = foo\" for compatibility wi...","count":6},{"name":"api-example","value":"static Node * transformJoinUsingClause(ParseState *pstate, List *leftVars, List *rightVars) { Node\t   *result; List\t   *andargs = NIL; ListCell   *lvars, *rvars; * We cheat a little bit here by buildi...","count":6},{"name":"api-example","value":"static Node * transformJsonObjectConstructor(ParseState *pstate, JsonObjectConstructor *ctor) { JsonReturning *returning; List\t   *args = NIL; if (ctor->exprs) { ListCell   *lc; foreach(lc, ctor->expr...","count":6},{"name":"api-example","value":"static Node * transformSQLValueFunction(ParseState *pstate, SQLValueFunction *svf) { * All we need to do is insert the correct result type and (where needed) * validate the typmod, so we just modify t...","count":6},{"name":"api-example","value":"static Node * transformSetOperationTree(ParseState *pstate, SelectStmt *stmt, bool isTopLevel, List **targetlist) { bool\t\tisLeaf; Assert(stmt && IsA(stmt, SelectStmt)); check_stack_depth(); * Validity...","count":6},{"name":"api-example","value":"static ObjectAddress ATExecAddColumn(List **wqueue, AlteredTableInfo *tab, Relation rel, AlterTableCmd **cmd, bool recurse, bool recursing, LOCKMODE lockmode, AlterTablePass cur_pass, AlterTableUtilit...","count":6},{"name":"api-example","value":"static ObjectAddress CreateExtensionInternal(char *extensionName, char *schemaName, const char *versionName, bool cascade, List *parents, bool is_create) { char\t   *origSchemaName = schemaName; Oid\t\t\t...","count":6},{"name":"api-example","value":"static ObjectAddress create_ctas_internal(List *attrList, IntoClause *into) { CreateStmt *create = makeNode(CreateStmt); bool\t\tis_matview; char\t\trelkind; Datum\t\ttoast_options; static char *validnsps[]...","count":6},{"name":"api-example","value":"static ObjectAddress get_object_address_opcf(ObjectType objtype, List *object, bool missing_ok) { Oid\t\t\tamoid; ObjectAddress address; amoid = get_index_am_oid(strVal(linitial(object)), false); object ...","count":6},{"name":"api-example","value":"static ObjectAddress get_object_address_relobject(ObjectType objtype, List *object, Relation *relp, bool missing_ok) { ObjectAddress address; Relation\trelation = NULL; int\t\t\tnnames; const char *depnam...","count":6},{"name":"api-example","value":"static ObjectAddress get_object_address_unqualified(ObjectType objtype, String *strval, bool missing_ok) { const char *name; ObjectAddress address; name = strVal(strval); switch (objtype) { case OBJEC...","count":6},{"name":"api-example","value":"static PGconn * connect_database(const char *conninfo, bool exit_on_error) { PGconn\t   *conn; PGresult   *res; conn = PQconnectdb(conninfo); if (PQstatus(conn) != CONNECTION_OK) { pg_log_error(\"connec...","count":6},{"name":"api-example","value":"static PLpgSQL_function * do_compile(FunctionCallInfo fcinfo, HeapTuple procTup, PLpgSQL_function *function, PLpgSQL_func_hashkey *hashkey, bool forValidator) { Form_pg_proc procStruct = (Form_pg_proc...","count":6},{"name":"api-example","value":"static PLpgSQL_variable * make_callstmt_target(PLpgSQL_execstate *estate, PLpgSQL_expr *expr) { CachedPlan *cplan; PlannedStmt *pstmt; CallStmt   *stmt; FuncExpr   *funcexpr; HeapTuple\tfunc_tuple; Oid...","count":6},{"name":"api-example","value":"static PQExpBuffer getThreadLocalPQExpBuffer(void) { * The Tls code goes awry if we use a static var, so we provide for both * static and auto, and omit any use of the static var when using Tls. We * ...","count":6},{"name":"api-example","value":"static PartitionBoundInfo merge_list_bounds(FmgrInfo *partsupfunc, Oid *partcollation, RelOptInfo *outer_rel, RelOptInfo *inner_rel, JoinType jointype, List **outer_parts, List **inner_parts) { Partit...","count":6},{"name":"api-example","value":"static PathKey * make_pathkey_from_sortinfo(PlannerInfo *root, Expr *expr, Oid opfamily, Oid opcintype, Oid collation, bool reverse_sort, bool nulls_first, Index sortref, Relids rel, bool create_it) {...","count":6},{"name":"api-example","value":"static PerlInterpreter * plperl_init_interp(void) { PerlInterpreter *plperl; static char *embedding[3 + 2] = { \"\", \"-e\", PLC_PERLBOOT }; int\t\t\tnargs = 3; #ifdef WIN32 * The perl library on startup doe...","count":6},{"name":"api-example","value":"static Plan * create_gating_plan(PlannerInfo *root, Path *path, Plan *plan, List *gating_quals) { Plan\t   *gplan; Plan\t   *splan; Assert(gating_quals); * We might have a trivial Result plan already.  ...","count":6},{"name":"api-example","value":"static Plan * create_scan_plan(PlannerInfo *root, Path *best_path, int flags) { RelOptInfo *rel = best_path->parent; List\t   *scan_clauses; List\t   *gating_clauses; List\t   *tlist; Plan\t   *plan; * Ex...","count":6},{"name":"api-example","value":"static Plan * create_unique_plan(PlannerInfo *root, UniquePath *best_path, int flags) { Plan\t   *plan; Plan\t   *subplan; List\t   *in_operators; List\t   *uniq_exprs; List\t   *newtlist; int\t\t\tnextresno;...","count":6},{"name":"api-example","value":"static PyObject * PLy_cursor_fetch(PyObject *self, PyObject *args) { PLyCursorObject *cursor; int\t\t\tcount; PLyResultObject *ret; PLyExecutionContext *exec_ctx = PLy_current_execution_context(); volati...","count":6},{"name":"api-example","value":"static PyObject * PLy_cursor_iternext(PyObject *self) { PLyCursorObject *cursor; PyObject   *ret; PLyExecutionContext *exec_ctx = PLy_current_execution_context(); volatile MemoryContext oldcontext; vo...","count":6},{"name":"api-example","value":"static QTNode * findeq(QTNode *node, QTNode *ex, QTNode *subs, bool *isfind) { if ((node->sign & ex->sign) != ex->sign || node->valnode->type != ex->valnode->type) return node; if (node->flags & QTN_N...","count":6},{"name":"api-example","value":"static QTNode * join_tsqueries(TSQuery a, TSQuery b, int8 operator, uint16 distance) { QTNode\t   *res = (QTNode *) palloc0(sizeof(QTNode)); res->flags |= QTN_NEEDFREE; res->valnode = (QueryItem *) pal...","count":6},{"name":"api-example","value":"static Query * ApplyRetrieveRule(Query *parsetree, RewriteRule *rule, int rt_index, Relation relation, List *activeRIRs) { Query\t   *rule_action; RangeTblEntry *rte; RowMarkClause *rc; int\t\t\tnumCols; ...","count":6},{"name":"api-example","value":"static Query * transformInsertStmt(ParseState *pstate, InsertStmt *stmt) { Query\t   *qry = makeNode(Query); SelectStmt *selectStmt = (SelectStmt *) stmt->selectStmt; List\t   *exprList = NIL; bool\t\tisG...","count":6},{"name":"api-example","value":"static Query * transformValuesClause(ParseState *pstate, SelectStmt *stmt) { Query\t   *qry = makeNode(Query); List\t   *exprsLists = NIL; List\t   *coltypes = NIL; List\t   *coltypmods = NIL; List\t   *co...","count":6},{"name":"api-example","value":"static RangeIOData * get_range_io_data(FunctionCallInfo fcinfo, Oid rngtypid, IOFuncSelector func) { RangeIOData *cache = (RangeIOData *) fcinfo->flinfo->fn_extra; if (cache == NULL || cache->typcache...","count":6},{"name":"api-example","value":"static Relation RelationBuildDesc(Oid targetRelId, bool insertIt) { int\t\t\tin_progress_offset; Relation\trelation; Oid\t\t\trelid; HeapTuple\tpg_class_tuple; Form_pg_class relp; * This function and its subr...","count":6},{"name":"api-example","value":"static ResultRelInfo * ExecInitPartitionInfo(ModifyTableState *mtstate, EState *estate, PartitionTupleRouting *proute, PartitionDispatch dispatch, ResultRelInfo *rootResultRelInfo, int partidx) { Modi...","count":6},{"name":"api-example","value":"static SV  * plperl_trigger_build_args(FunctionCallInfo fcinfo) { dTHX; TriggerData *tdata; TupleDesc\ttupdesc; int\t\t\ti; char\t   *level; char\t   *event; char\t   *relid; char\t   *when; HV\t\t   *hv; hv = ...","count":6},{"name":"api-example","value":"static ScanKey _bt_preprocess_array_keys(IndexScanDesc scan) { BTScanOpaque so = (BTScanOpaque) scan->opaque; Relation\trel = scan->indexRelation; int\t\t\tnumberOfKeys = scan->numberOfKeys; int16\t   *ind...","count":6},{"name":"api-example","value":"static Selectivity mcelem_array_contain_overlap_selec(Datum *mcelem, int nmcelem, float4 *numbers, int nnumbers, Datum *array_data, int nitems, Oid operator, TypeCacheEntry *typentry) { Selectivity se...","count":6},{"name":"api-example","value":"static Selectivity tsquerysel(VariableStatData *vardata, Datum constval) { Selectivity selec; TSQuery\t\tquery; query = DatumGetTSQuery(constval); if (query->size == 0) return (Selectivity) 0.0; if (Hea...","count":6},{"name":"api-example","value":"static SignTSVector * gtsvector_alloc(int flag, int len, BITVECP sign) { int\t\t\tsize = CALCGTSIZE(flag, len); SignTSVector *res = palloc(size); SET_VARSIZE(res, size); res->flag = flag; if ((flag & (SI...","count":6},{"name":"api-example","value":"static Snapshot GetSerializableTransactionSnapshotInt(Snapshot snapshot, VirtualTransactionId *sourcevxid, int sourcepid) { PGPROC\t   *proc; VirtualTransactionId vxid; SERIALIZABLEXACT *sxact, *others...","count":6},{"name":"api-example","value":"static TSTernaryValue TS_phrase_execute(QueryItem *curitem, void *arg, uint32 flags, TSExecuteCallback chkcond, ExecPhraseData *data) { ExecPhraseData Ldata, Rdata; TSTernaryValue lmatch, rmatch; int\t...","count":6},{"name":"api-example","value":"static TupleDesc brtuple_disk_tupdesc(BrinDesc *brdesc) { if (brdesc->bd_disktdesc == NULL) { int\t\t\ti; int\t\t\tj; AttrNumber\tattno = 1; TupleDesc\ttupdesc; MemoryContext oldcxt; oldcxt = MemoryContextSwi...","count":6},{"name":"api-example","value":"static TupleTableSlot *\t\t\t/* return: a tuple or NULL */ ExecLockRows(PlanState *pstate) { LockRowsState *node = castNode(LockRowsState, pstate); TupleTableSlot *slot; EState\t   *estate; PlanState  *ou...","count":6},{"name":"api-example","value":"static TupleTableSlot * BitmapHeapNext(BitmapHeapScanState *node) { ExprContext *econtext; TableScanDesc scan; TIDBitmap  *tbm; TBMIterator *tbmiterator = NULL; TBMSharedIterator *shared_tbmiterator =...","count":6},{"name":"api-example","value":"static TupleTableSlot * ExecInsert(ModifyTableContext *context, ResultRelInfo *resultRelInfo, TupleTableSlot *slot, bool canSetTag, TupleTableSlot **inserted_tuple, ResultRelInfo **insert_destrel) { M...","count":6},{"name":"api-example","value":"static WaitPMResult wait_for_postmaster_start(pid_t pm_pid, bool do_checkpoint) { int\t\t\ti; for (i = 0; i < wait_seconds * WAITS_PER_SEC; i++) { char\t  **optlines; int\t\t\tnumlines; * Try to read the pos...","count":6},{"name":"api-example","value":"static backslashResult exec_command_connect(PsqlScanState scan_state, bool active_branch) { bool\t\tsuccess = true; if (active_branch) { static const char prefix[] = \"-reuse-previous=\"; char\t   *opt1, *...","count":6},{"name":"api-example","value":"static backslashResult exec_command_sf_sv(PsqlScanState scan_state, bool active_branch, const char *cmd, bool is_func) { backslashResult status = PSQL_CMD_SKIP_LINE; if (active_branch) { bool\t\tshow_li...","count":6},{"name":"api-example","value":"static bool AdjustDays(int64 val, int scale, struct pg_itm_in *itm_in) { int\t\t\tdays; if (val < INT_MIN || val > INT_MAX) return false; return !pg_mul_s32_overflow((int32) val, scale, &days) && !pg_add...","count":6},{"name":"api-example","value":"static bool CopyReadLine(CopyFromState cstate) { bool\t\tresult; resetStringInfo(&cstate->line_buf); cstate->line_buf_valid = false; result = CopyReadLineText(cstate); if (result) { * Reached EOF.  In p...","count":6},{"name":"api-example","value":"static bool ExecComputeSlotInfo(ExprState *state, ExprEvalStep *op) { PlanState  *parent = state->parent; TupleDesc\tdesc = NULL; const TupleTableSlotOps *tts_ops = NULL; bool\t\tisfixed = false; ExprEva...","count":6},{"name":"api-example","value":"static bool _bt_unlink_halfdead_page(Relation rel, Buffer leafbuf, BlockNumber scanblkno, bool *rightsib_empty, BTVacState *vstate) { BlockNumber leafblkno = BufferGetBlockNumber(leafbuf); IndexBulkDe...","count":6},{"name":"api-example","value":"static bool afterTriggerMarkEvents(AfterTriggerEventList *events, AfterTriggerEventList *move_list, bool immediate_only) { bool\t\tfound = false; bool\t\tdeferred_found = false; AfterTriggerEvent event; A...","count":6},{"name":"api-example","value":"static bool describeOneTableDetails(const char *schemaname, const char *relationname, const char *oid, bool verbose) { bool\t\tretval = false; PQExpBufferData buf; PGresult   *res = NULL; printTableOpt ...","count":6},{"name":"api-example","value":"static bool entryIsMoveRight(GinBtree btree, Page page) { IndexTuple\titup; OffsetNumber attnum; Datum\t\tkey; GinNullCategory category; if (GinPageRightMost(page)) return false; itup = getRightMostTuple...","count":6},{"name":"api-example","value":"static bool evalLazyFunc(CState *st, PgBenchFunction func, PgBenchExprLink *args, PgBenchValue *retval) { PgBenchValue a1, a2; bool\t\tba1, ba2; Assert(isLazyFunc(func) && args != NULL && args->next != ...","count":6},{"name":"api-example","value":"static bool evalStandardFunc(CState *st, PgBenchFunction func, PgBenchExprLink *args, PgBenchValue *retval) { int\t\t\tnargs = 0; PgBenchExprLink *l = args; bool\t\thas_null = false; * This value is double...","count":6},{"name":"api-example","value":"static bool fix_opfuncids_walker(Node *node, void *context) { if (node == NULL) return false; if (IsA(node, OpExpr)) set_opfuncid((OpExpr *) node); else if (IsA(node, DistinctExpr)) set_opfuncid((OpEx...","count":6},{"name":"api-example","value":"static bool getNextNearest(IndexScanDesc scan) { GISTScanOpaque so = (GISTScanOpaque) scan->opaque; bool\t\tres = false; if (scan->xs_hitup) { pfree(scan->xs_hitup); scan->xs_hitup = NULL; } do { GISTSe...","count":6},{"name":"api-example","value":"static bool grow_memtuples(Tuplesortstate *state) { int\t\t\tnewmemtupsize; int\t\t\tmemtupsize = state->memtupsize; int64\t\tmemNowUsed = state->allowedMem - state->availMem; if (!state->growmemtuples) retur...","count":6},{"name":"api-example","value":"static bool index_unchanged_by_update(ResultRelInfo *resultRelInfo, EState *estate, IndexInfo *indexInfo, Relation indexRelation) { Bitmapset  *updatedCols; Bitmapset  *extraUpdatedCols; Bitmapset  *a...","count":6},{"name":"api-example","value":"static bool jsonb_ops__add_path_item(JsonPathGinPath *path, JsonPathItem *jsp) { JsonPathGinPathItem *pentry; Datum\t\tkeyName; switch (jsp->type) { case jpiRoot: path->items = NULL; /* reset path */ re...","count":6},{"name":"api-example","value":"static bool lseg_interpt_lseg(Point *result, LSEG *l1, LSEG *l2) { Point\t\tinterpt; LINE\t\ttmp; line_construct(&tmp, &l2->p[0], lseg_sl(l2)); if (!lseg_interpt_line(&interpt, l1, &tmp)) return false; * ...","count":6},{"name":"api-example","value":"static bool parseAclItem(const char *item, const char *type, const char *name, const char *subname, int remoteVersion, PQExpBuffer grantee, PQExpBuffer grantor, PQExpBuffer privs, PQExpBuffer privswgo...","count":6},{"name":"api-example","value":"static bool parse_and_validate_value(struct config_generic *record, const char *name, const char *value, GucSource source, int elevel, union config_var_val *newval, void **newextra) { switch (record->...","count":6},{"name":"api-example","value":"static bool peek_buffer_usage(ExplainState *es, const BufferUsage *usage) { bool\t\thas_shared; bool\t\thas_local; bool\t\thas_temp; bool\t\thas_shared_timing; bool\t\thas_local_timing; bool\t\thas_temp_timing; i...","count":6},{"name":"api-example","value":"static bool predicate_implied_by_recurse(Node *clause, Node *predicate, bool weak) { PredIterInfoData clause_info; PredIterInfoData pred_info; PredClass\tpclass; bool\t\tresult; Assert(clause != NULL); i...","count":6},{"name":"api-example","value":"static bool printPsetInfo(const char *param, printQueryOpt *popt) { Assert(param != NULL); if (strcmp(param, \"border\") == 0) printf(_(\"Border style is %d.\\n\"), popt->topt.border); else if (strcmp(para...","count":6},{"name":"api-example","value":"static bool range_gist_consistent_int_element(TypeCacheEntry *typcache, StrategyNumber strategy, const RangeType *key, Datum query) { switch (strategy) { case RANGESTRAT_CONTAINS_ELEM: return range_co...","count":6},{"name":"api-example","value":"static bool rank_up(WindowObject winobj) { bool\t\tup = false;\t\t/* should rank increase? */ int64\t\tcurpos = WinGetCurrentPosition(winobj); rank_context *context; context = (rank_context *) WinGetPartiti...","count":6},{"name":"api-example","value":"static bool record_fields_have_equality(TypeCacheEntry *typentry) { if (!(typentry->flags & TCFLAGS_CHECKED_FIELD_PROPERTIES)) cache_record_field_properties(typentry); return (typentry->flags & TCFLAG...","count":6},{"name":"api-example","value":"static bool set_string_attr(PyObject *obj, char *attrname, char *str) { int\t\t\tresult; PyObject   *val; if (str != NULL) { val = PLyUnicode_FromString(str); if (!val) return false; } else { val = Py_No...","count":6},{"name":"api-example","value":"static bool synchronize_one_slot(RemoteSlot *remote_slot, Oid remote_dbid) { ReplicationSlot *slot; XLogRecPtr\tlatestFlushPtr; bool\t\tslot_updated = false; * Make sure that concerned WAL is received an...","count":6},{"name":"api-example","value":"static bool test_specific_config_settings(int test_conns, int test_buffs) { PQExpBufferData cmd; _stringlist *gnames, *gvalues; int\t\t\tstatus; initPQExpBuffer(&cmd); printfPQExpBuffer(&cmd, \"\\\"%s\\\" --c...","count":6},{"name":"api-example","value":"static char * ResOwnerPrintTupleDesc(Datum res) { TupleDesc\ttupdesc = (TupleDesc) DatumGetPointer(res); return psprintf(\"TupleDesc %p (%u,%d)\", tupdesc, tupdesc->tdtypeid, tupdesc->tdtypmod); }","count":6},{"name":"api-example","value":"static char * _bt_delitems_update(BTVacuumPosting *updatable, int nupdatable, OffsetNumber *updatedoffsets, Size *updatedbuflen, bool needswal) { char\t   *updatedbuf = NULL; Size\t\tbuflen = 0; Assert(n...","count":6},{"name":"api-example","value":"static char * build_server_first_message(scram_state *state) { * The syntax for the server-first-message is: (RFC 5802) * * server-first-message = *\t\t\t\t\t [reserved-mext \",\"] nonce \",\" salt \",\" *\t\t\t\t\t ...","count":6},{"name":"api-example","value":"static char * cpstrdup(IspellDict *Conf, const char *str) { char\t   *res = cpalloc(strlen(str) + 1); strcpy(res, str); return res; }","count":6},{"name":"api-example","value":"static char * get_extension_control_directory(void) { char\t\tsharepath[MAXPGPATH]; char\t   *result; get_share_path(my_exec_path, sharepath); result = (char *) palloc(MAXPGPATH); snprintf(result, MAXPGP...","count":6},{"name":"api-example","value":"static char * hek2cstr(HE *he) { dTHX; char\t   *ret; SV\t\t   *sv; * HeSVKEY_force will return a temporary mortal SV*, so we need to make * sure to free it with ENTER/SAVE/FREE/LEAVE */ ENTER; SAVETMPS;...","count":6},{"name":"api-example","value":"static char * inet_cidr_ntop_ipv4(const u_char *src, int bits, char *dst, size_t size) { char\t   *odst = dst; char\t   *t; u_int\t\tm; int\t\t\tb; if (bits < 0 || bits > 32) { errno = EINVAL; return NULL; }...","count":6},{"name":"api-example","value":"static char * network_out(inet *src, bool is_cidr) { char\t\ttmp[sizeof(\"xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:255.255.255.255/128\")]; char\t   *dst; int\t\t\tlen; dst = pg_inet_net_ntop(ip_family(src), ip_addr(src...","count":6},{"name":"api-example","value":"static char * pset_value_string(const char *param, printQueryOpt *popt) { Assert(param != NULL); if (strcmp(param, \"border\") == 0) return psprintf(\"%d\", popt->topt.border); else if (strcmp(param, \"col...","count":6},{"name":"api-example","value":"static color maxcolor(struct colormap *cm) { if (CISERR()) return COLORLESS; return (color) cm->max; }","count":6},{"name":"api-example","value":"static disassembledLeaf * disassembleLeaf(Page page) { disassembledLeaf *leaf; GinPostingList *seg; Pointer\t\tsegbegin; Pointer\t\tsegend; leaf = palloc0(sizeof(disassembledLeaf)); dlist_init(&leaf->segm...","count":6},{"name":"api-example","value":"static double _brin_parallel_merge(BrinBuildState *state) { BrinTuple  *btup; BrinMemTuple *memtuple = NULL; Size\t\ttuplen; BlockNumber prevblkno = InvalidBlockNumber; MemoryContext rangeCxt, oldCxt; d...","count":6},{"name":"api-example","value":"static double _bt_spools_heapscan(Relation heap, Relation index, BTBuildState *buildstate, IndexInfo *indexInfo) { BTSpool    *btspool = (BTSpool *) palloc0(sizeof(BTSpool)); SortCoordinate coordinate...","count":6},{"name":"api-example","value":"static double calc_hist_selectivity(TypeCacheEntry *typcache, VariableStatData *vardata, const MultirangeType *constval, Oid operator) { TypeCacheEntry *rng_typcache = typcache->rngtype; AttStatsSlot ...","count":6},{"name":"api-example","value":"static double compute_parallel_delay(void) { double\t\tmsec = 0; uint32\t\tshared_balance; int\t\t\tnworkers; Assert(VacuumSharedCostBalance); nworkers = pg_atomic_read_u32(VacuumActiveNWorkers); Assert(nwor...","count":6},{"name":"api-example","value":"static inet * network_in(char *src, bool is_cidr, Node *escontext) { int\t\t\tbits; inet\t   *dst; dst = (inet *) palloc0(sizeof(inet)); * First, check to see if this is an IPv6 or IPv4 address.  IPv6 add...","count":6},{"name":"api-example","value":"static inline BlockNumber read_stream_get_block(ReadStream *stream, void *per_buffer_data) { BlockNumber blocknum; blocknum = stream->buffered_blocknum; if (blocknum != InvalidBlockNumber) stream->buf...","count":6},{"name":"api-example","value":"static inline HeapTuple SearchCatCacheInternal(CatCache *cache, int nkeys, Datum v1, Datum v2, Datum v3, Datum v4) { Datum\t\targuments[CATCACHE_MAXKEYS]; uint32\t\thashValue; Index\t\thashIndex; dlist_iter...","count":6},{"name":"api-example","value":"static inline JsonParseErrorType lex_expect(JsonParseContext ctx, JsonLexContext *lex, JsonTokenType token) { if (lex_peek(lex) == token) return json_lex(lex); else return report_parse_error(ctx, lex)...","count":6},{"name":"api-example","value":"static inline bool SerializationNeededForRead(Relation relation, Snapshot snapshot) { if (MySerializableXact == InvalidSerializableXact) return false; * Don't acquire locks or conflict when scanning w...","count":6},{"name":"api-example","value":"static inline bool dlist_is_empty(const dlist_head *head) { dlist_check(head); return head->head.next == NULL || head->head.next == &(head->head); }","count":6},{"name":"api-example","value":"static inline void * pagetable_allocate(pagetable_hash *pagetable, Size size) { TIDBitmap  *tbm = (TIDBitmap *) pagetable->private_data; PTEntryArray *ptbase; if (tbm->dsa == NULL) return MemoryContex...","count":6},{"name":"api-example","value":"static inline void dlist_delete_from(dlist_head *head, dlist_node *node) { dlist_member_check(head, node); dlist_delete(node); }","count":6},{"name":"api-example","value":"static int ClassifyUtilityCommandAsReadOnly(Node *parsetree) { switch (nodeTag(parsetree)) { case T_AlterCollationStmt: case T_AlterDatabaseRefreshCollStmt: case T_AlterDatabaseSetStmt: case T_AlterDa...","count":6},{"name":"api-example","value":"static int DecodeTimeCommon(char *str, int fmask, int range, int *tmask, struct pg_itm *itm) { char\t   *cp; int\t\t\tdterr; fsec_t\t\tfsec = 0; *tmask = DTK_TIME_M; errno = 0; itm->tm_hour = strtoi64(str, ...","count":6},{"name":"api-example","value":"static int GetDecimalFromHex(char hex) { if (isdigit((unsigned char) hex)) return hex - '0'; else return tolower((unsigned char) hex) - 'a' + 10; }","count":6},{"name":"api-example","value":"static int InteractiveBackend(StringInfo inBuf) { int\t\t\tc;\t\t\t\t/* character read from getc() */ * display a prompt and obtain input from the user */ printf(\"backend> \"); fflush(stdout); resetStringInfo...","count":6},{"name":"api-example","value":"static int euc_tw2mic(const unsigned char *euc, unsigned char *p, int len, bool noError) { const unsigned char *start = euc; int\t\t\tc1; int\t\t\tl; while (len > 0) { c1 = *euc; if (IS_HIGHBIT_SET(c1)) { l...","count":6},{"name":"api-example","value":"static int exec_stmt_call(PLpgSQL_execstate *estate, PLpgSQL_stmt_call *stmt) { PLpgSQL_expr *expr = stmt->expr; LocalTransactionId before_lxid; LocalTransactionId after_lxid; ParamListInfo paramLI; S...","count":6},{"name":"api-example","value":"static int get_decomposed_size(pg_wchar code, bool compat) { const pg_unicode_decomposition *entry; int\t\t\tsize = 0; int\t\t\ti; const uint32 *decomp; int\t\t\tdec_size; * Fast path for Hangul characters not...","count":6},{"name":"api-example","value":"static int pg_strncoll_libc_win32_utf8(const char *arg1, size_t len1, const char *arg2, size_t len2, pg_locale_t locale) { char\t\tsbuf[TEXTBUFLEN]; char\t   *buf = sbuf; char\t   *a1p, *a2p; int\t\t\ta1len ...","count":6},{"name":"api-example","value":"static int pg_wc_isalpha(pg_wchar c) { switch (pg_regex_strategy) { case PG_REGEX_LOCALE_C: return (c <= (pg_wchar) 127 && (pg_char_properties[c] & PG_ISALPHA)); case PG_REGEX_BUILTIN: return pg_u_isa...","count":6},{"name":"api-example","value":"static int pg_wc_islower(pg_wchar c) { switch (pg_regex_strategy) { case PG_REGEX_LOCALE_C: return (c <= (pg_wchar) 127 && (pg_char_properties[c] & PG_ISLOWER)); case PG_REGEX_BUILTIN: return pg_u_isl...","count":6},{"name":"api-example","value":"static int pg_wc_isprint(pg_wchar c) { switch (pg_regex_strategy) { case PG_REGEX_LOCALE_C: return (c <= (pg_wchar) 127 && (pg_char_properties[c] & PG_ISPRINT)); case PG_REGEX_BUILTIN: return pg_u_isp...","count":6},{"name":"api-example","value":"static int pg_wc_ispunct(pg_wchar c) { switch (pg_regex_strategy) { case PG_REGEX_LOCALE_C: return (c <= (pg_wchar) 127 && (pg_char_properties[c] & PG_ISPUNCT)); case PG_REGEX_BUILTIN: return pg_u_isp...","count":6},{"name":"api-example","value":"static int r_e_ending(struct SN_env * z) { z->I[2] = 0; z->ket = z->c; if (z->c <= z->lb || z->p[z->c - 1] != 'e') return 0; z->c--; z->bra = z->c; {   int ret = r_R1(z); if (ret <= 0) return ret; } {...","count":6},{"name":"api-example","value":"static int r_main_suffix(struct SN_env * z) { int among_var; {   int mlimit1; if (z->c < z->I[1]) return 0; mlimit1 = z->lb; z->lb = z->I[1]; z->ket = z->c; if (z->c <= z->lb || z->p[z->c - 1] >> 5 !=...","count":6},{"name":"api-example","value":"static int r_mark_regions(struct SN_env * z) { z->I[1] = z->l; z->I[0] = z->l; {   int c1 = z->c; { int ret = out_grouping_U(z, g_v, 1377, 1413, 1); if (ret < 0) goto lab0; z->c += ret; } z->I[1] = z-...","count":6},{"name":"api-example","value":"static int r_mark_regions(struct SN_env * z) { z->I[2] = z->l; z->I[1] = z->l; z->I[0] = z->l; {   int c1 = z->c; {   int c2 = z->c; if (in_grouping(z, g_v, 97, 117, 0)) goto lab2; {   int c3 = z->c; ...","count":6},{"name":"api-example","value":"static int r_stem_nominal_verb_suffixes(struct SN_env * z) { z->ket = z->c; z->I[0] = 1; {   int m1 = z->l - z->c; (void)m1; {   int m2 = z->l - z->c; (void)m2; {   int ret = r_mark_ymUs_(z); if (ret ...","count":6},{"name":"api-example","value":"static int sjis2mic(const unsigned char *sjis, unsigned char *p, int len, bool noError) { const unsigned char *start = sjis; int\t\t\tc1, c2, i, k, k2; while (len > 0) { c1 = *sjis; if (c1 >= 0xa1 && c1 ...","count":6},{"name":"api-example","value":"static int text_position(text *t1, text *t2, Oid collid) { TextPositionState state; int\t\t\tresult; if (VARSIZE_ANY_EXHDR(t2) < 1) return 1; if (VARSIZE_ANY_EXHDR(t1) < VARSIZE_ANY_EXHDR(t2)) return 0; ...","count":6},{"name":"api-example","value":"static int transformFkeyGetPrimaryKey(Relation pkrel, Oid *indexOid, List **attnamelist, int16 *attnums, Oid *atttypids, Oid *opclasses) { List\t   *indexoidlist; ListCell   *indexoidscan; HeapTuple\tin...","count":6},{"name":"api-example","value":"static int32 multirange_canonicalize(TypeCacheEntry *rangetyp, int32 input_range_count, RangeType **ranges) { RangeType  *lastRange = NULL; RangeType  *currentRange; int32\t\ti; int32\t\toutput_range_coun...","count":6},{"name":"api-example","value":"static int32 network_cmp_internal(inet *a1, inet *a2) { if (ip_family(a1) == ip_family(a2)) { int\t\t\torder; order = bitncmp(ip_addr(a1), ip_addr(a2), Min(ip_bits(a1), ip_bits(a2))); if (order != 0) ret...","count":6},{"name":"api-example","value":"static llvm::Module* load_module_cached(LLVMContextRef lc, llvm::StringRef modPath) { auto it = module_cache->find(modPath); if (it == module_cache->end()) { it = module_cache->insert( std::make_pair(...","count":6},{"name":"api-example","value":"static parallel_worker_main_type LookupParallelWorkerFunction(const char *libraryname, const char *funcname) { * If the function is to be loaded from postgres itself, search the * InternalParallelWork...","count":6},{"name":"api-example","value":"static pg_wchar pg_wc_tolower(pg_wchar c) { switch (pg_regex_strategy) { case PG_REGEX_LOCALE_C: if (c <= (pg_wchar) 127) return pg_ascii_tolower((unsigned char) c); return c; case PG_REGEX_BUILTIN: r...","count":6},{"name":"api-example","value":"static size_t initcap_wbnext(void *state) { struct WordBoundaryState *wbstate = (struct WordBoundaryState *) state; while (wbstate->offset < wbstate->len && wbstate->str[wbstate->offset] != '\\0') { pg...","count":6},{"name":"api-example","value":"static ssize_t read_or_wait(Port *port, ssize_t len) { ssize_t\t\tret; * Keep going until we either read in everything we were asked to, or we * error out. */ while (PqGSSRecvLength < len) { ret = secur...","count":6},{"name":"api-example","value":"static struct connection * ecpg_get_connection_nr(const char *connection_name) { struct connection *ret = NULL; if ((connection_name == NULL) || (strcmp(connection_name, \"CURRENT\") == 0)) { ecpg_pthre...","count":6},{"name":"api-example","value":"static struct copy_options * parse_slash_copy(const char *args) { struct copy_options *result; char\t   *token; const char *whitespace = \" \\t\\n\\r\"; char\t\tnonstd_backslash = standard_strings() ? 0 : '\\\\...","count":6},{"name":"api-example","value":"static struct variable * find_struct_member(char *name, char *str, struct ECPGstruct_member *members, int brace_level) { char\t   *next = strpbrk(++str, \".-[\"), *end, c = '\\0'; if (next != NULL) { c = ...","count":6},{"name":"api-example","value":"static uint32 TupleHashTableHash_internal(struct tuplehash_hash *tb, const MinimalTuple tuple) { TupleHashTable hashtable = (TupleHashTable) tb->private_data; int\t\t\tnumCols = hashtable->numCols; AttrN...","count":6},{"name":"api-example","value":"static uint32 WaitEventCustomNew(uint32 classId, const char *wait_event_name) { uint16\t\teventId; bool\t\tfound; WaitEventCustomEntryByName *entry_by_name; WaitEventCustomEntryByInfo *entry_by_info; uint...","count":6},{"name":"api-example","value":"static uint32 conv_utf8_to_18030(uint32 code) { uint32\t\tucs = utf8word_to_unicode(code); #define convutf8(minunicode, maxunicode, mincode) \\ if (ucs >= minunicode && ucs <= maxunicode) \\ return gb_unl...","count":6},{"name":"api-example","value":"static uint64 esc_decode(const char *src, size_t srclen, char *dst) { const char *end = src + srclen; char\t   *rp = dst; uint64\t\tlen = 0; while (src < end) { if (src[0] != '\\\\') *rp++ = *src++; else i...","count":6},{"name":"api-example","value":"static uint64 esc_encode(const char *src, size_t srclen, char *dst) { const char *end = src + srclen; char\t   *rp = dst; uint64\t\tlen = 0; while (src < end) { unsigned char c = (unsigned char) *src; if...","count":6},{"name":"api-example","value":"static void * InternalIpcMemoryCreate(IpcMemoryKey memKey, Size size) { IpcMemoryId shmid; void\t   *requestedAddress = NULL; void\t   *memAddress; * Normally we just pass requestedAddress = NULL to shm...","count":6},{"name":"api-example","value":"static void ATPostAlterTypeParse(Oid oldId, Oid oldRelId, Oid refRelId, char *cmd, List **wqueue, LOCKMODE lockmode, bool rewrite) { List\t   *raw_parsetree_list; List\t   *querytree_list; ListCell   *l...","count":6},{"name":"api-example","value":"static void AppendStringToManifest(backup_manifest_info *manifest, const char *s) { int\t\t\tlen = strlen(s); Assert(manifest != NULL); if (manifest->still_checksumming) { if (pg_cryptohash_update(manife...","count":6},{"name":"api-example","value":"static void ApplyLauncherSetWorkerStartTime(Oid subid, TimestampTz start_time) { LauncherLastStartTimesEntry *entry; bool\t\tfound; logicalrep_launcher_attach_dshmem(); entry = dshash_find_or_insert(las...","count":6},{"name":"api-example","value":"static void BackendInitialize(ClientSocket *client_sock, CAC_state cac) { int\t\t\tstatus; int\t\t\tret; Port\t   *port; char\t\tremote_host[NI_MAXHOST]; char\t\tremote_port[NI_MAXSERV]; StringInfoData ps_data; ...","count":6},{"name":"api-example","value":"static void CheckConditional(const ParsedScript *ps) { ConditionalStack cs = conditional_stack_create(); int\t\t\ti; for (i = 0; ps->commands[i] != NULL; i++) { Command    *cmd = ps->commands[i]; if (cmd...","count":6},{"name":"api-example","value":"static void CopyAttributeOutText(CopyToState cstate, const char *string) { const char *ptr; const char *start; char\t\tc; char\t\tdelimc = cstate->opts.delim[0]; if (cstate->need_transcoding) ptr = pg_ser...","count":6},{"name":"api-example","value":"static void CreateLockFile(const char *filename, bool amPostmaster, const char *socketDir, bool isDDLock, const char *refName) { int\t\t\tfd; char\t\tbuffer[MAXPGPATH * 2 + 256]; int\t\t\tntries; int\t\t\tlen; i...","count":6},{"name":"api-example","value":"static void DiscardAll(bool isTopLevel) { * Disallow DISCARD ALL in a transaction block. This is arguably * inconsistent (we don't make a similar check in the command sequence * that DISCARD ALL is eq...","count":6},{"name":"api-example","value":"static void EncodeSpecialInterval(const Interval *interval, char *str) { if (INTERVAL_IS_NOBEGIN(interval)) strcpy(str, EARLY); else if (INTERVAL_IS_NOEND(interval)) strcpy(str, LATE); else\t\t\t\t\t\t/* sh...","count":6},{"name":"api-example","value":"static void ExecAlterExtensionContentsRecurse(AlterExtensionContentsStmt *stmt, ObjectAddress extension, ObjectAddress object) { Oid\t\t\toldExtension; * Check existing extension membership. */ oldExtens...","count":6},{"name":"api-example","value":"static void ExecGrantStmt_oids(InternalGrant *istmt) { switch (istmt->objtype) { case OBJECT_TABLE: case OBJECT_SEQUENCE: ExecGrant_Relation(istmt); break; case OBJECT_DATABASE: ExecGrant_common(istmt...","count":6},{"name":"api-example","value":"static void Exec_ListenPreCommit(void) { QueuePosition head; QueuePosition max; ProcNumber\tprevListener; * Nothing to do if we are already listening to something, nor if we * already ran this routine ...","count":6},{"name":"api-example","value":"static void ExplainPrintSettings(ExplainState *es) { int\t\t\tnum; struct config_generic **gucs; if (!es->settings) return; gucs = get_explain_guc_options(&num); if (es->format != EXPLAIN_FORMAT_TEXT) { ...","count":6},{"name":"api-example","value":"static void FreePageBtreeAdjustAncestorKeys(FreePageManager *fpm, FreePageBtree *btp) { char\t   *base = fpm_segment_base(fpm); Size\t\tfirst_page; FreePageBtree *parent; FreePageBtree *child; Assert(btp...","count":6},{"name":"api-example","value":"static void GetForeignKeyActionTriggers(Relation trigrel, Oid conoid, Oid confrelid, Oid conrelid, Oid *deleteTriggerOid, Oid *updateTriggerOid) { ScanKeyData key; SysScanDesc scan; HeapTuple\ttrigtup;...","count":6},{"name":"api-example","value":"static void HandleAutoVacLauncherInterrupts(void) { if (ShutdownRequestPending) AutoVacLauncherShutdown(); if (ConfigReloadPending) { ConfigReloadPending = false; ProcessConfigFile(PGC_SIGHUP); if (!A...","count":6},{"name":"api-example","value":"static void InitializeLWLocks(void) { int\t\t\tnumNamedLocks = NumLWLocksForNamedTranches(); int\t\t\tid; int\t\t\ti; int\t\t\tj; LWLockPadded *lock; for (id = 0, lock = MainLWLockArray; id < NUM_INDIVIDUAL_LWLOC...","count":6},{"name":"api-example","value":"static void MultiExecPrivateHash(HashState *node) { PlanState  *outerNode; List\t   *hashkeys; HashJoinTable hashtable; TupleTableSlot *slot; ExprContext *econtext; uint32\t\thashvalue; * get state info ...","count":6},{"name":"api-example","value":"static void NIAddAffix(IspellDict *Conf, const char *flag, char flagflags, const char *mask, const char *find, const char *repl, int type) { AFFIX\t   *Affix; if (Conf->naffixes >= Conf->maffixes) { if...","count":6},{"name":"api-example","value":"static void NIAddSpell(IspellDict *Conf, const char *word, const char *flag) { if (Conf->nspell >= Conf->mspell) { if (Conf->mspell) { Conf->mspell *= 2; Conf->Spell = (SPELL **) repalloc(Conf->Spell,...","count":6},{"name":"api-example","value":"static void NUM_numpart_from_char(NUMProc *Np, int id, int input_len) { bool\t\tisread = false; #ifdef DEBUG_TO_FROM_CHAR elog(DEBUG_elog_output, \" --- scan start --- id=%s\", (id == NUM_0 || id == NUM_9...","count":6},{"name":"api-example","value":"static void ReadTempFileBlock(BufFile *file, long blknum, void *ptr) { if (BufFileSeekBlock(file, blknum) != 0) elog(ERROR, \"could not seek to block %ld in temporary file\", blknum); BufFileReadExact(f...","count":6},{"name":"api-example","value":"static void RecordTransactionCommitPrepared(TransactionId xid, int nchildren, TransactionId *children, int nrels, RelFileLocator *rels, int nstats, xl_xact_stats_item *stats, int ninvalmsgs, SharedInv...","count":6},{"name":"api-example","value":"static void ReorderBufferCleanupTXN(ReorderBuffer *rb, ReorderBufferTXN *txn) { bool\t\tfound; dlist_mutable_iter iter; Size\t\tmem_freed = 0; dlist_foreach_modify(iter, &txn->subtxns) { ReorderBufferTXN ...","count":6},{"name":"api-example","value":"static void ReorderBufferResetTXN(ReorderBuffer *rb, ReorderBufferTXN *txn, Snapshot snapshot_now, CommandId command_id, XLogRecPtr last_lsn, ReorderBufferChange *specinsert) { ReorderBufferTruncateTX...","count":6},{"name":"api-example","value":"static void SHA256_Last(pg_sha256_ctx *context) { unsigned int usedspace; usedspace = (context->bitcount >> 3) % PG_SHA256_BLOCK_LENGTH; #ifndef WORDS_BIGENDIAN REVERSE64(context->bitcount, context->b...","count":6},{"name":"api-example","value":"static void SerialInit(void) { bool\t\tfound; * Set up SLRU management of the pg_serial data. */ SerialSlruCtl->PagePrecedes = SerialPagePrecedesLogically; SimpleLruInit(SerialSlruCtl, \"serializable\", s...","count":6},{"name":"api-example","value":"static void StartLogStreamer(char *startpos, uint32 timeline, char *sysidentifier, pg_compress_algorithm wal_compress_algorithm, int wal_compress_level) { logstreamer_param *param; uint32\t\thi, lo; cha...","count":6},{"name":"api-example","value":"static void StartReplication(StartReplicationCmd *cmd) { StringInfoData buf; XLogRecPtr\tFlushPtr; TimeLineID\tFlushTLI; xlogreader = XLogReaderAllocate(wal_segment_size, NULL, XL_ROUTINE(.segment_open ...","count":6},{"name":"api-example","value":"static void SyncRepCancelWait(void) { LWLockAcquire(SyncRepLock, LW_EXCLUSIVE); if (!dlist_node_is_detached(&MyProc->syncRepLinks)) dlist_delete_thoroughly(&MyProc->syncRepLinks); MyProc->syncRepState...","count":6},{"name":"api-example","value":"static void UpdateMinRecoveryPoint(XLogRecPtr lsn, bool force) { if (!updateMinRecoveryPoint || (!force && lsn <= LocalMinRecoveryPoint)) return; * An invalid minRecoveryPoint means that we need to re...","count":6},{"name":"api-example","value":"static void _bt_bottomupdel_finish_pending(Page page, BTDedupState state, TM_IndexDeleteOp *delstate) { bool\t\tdupinterval = (state->nitems > 1); Assert(state->nitems > 0); Assert(state->nitems <= stat...","count":6},{"name":"api-example","value":"static void _jumbleNode(JumbleState *jstate, Node *node) { Node\t   *expr = node; if (expr == NULL) return; check_stack_depth(); * We always emit the node's NodeTag, then any additional fields that are...","count":6},{"name":"api-example","value":"static void add_parameter_name(PLpgSQL_nsitem_type itemtype, int itemno, const char *name) { * Before adding the name, check for duplicates.  We need this even though * functioncmds.c has a similar ch...","count":6},{"name":"api-example","value":"static void adjustBox(BOX *b, const BOX *addon) { if (float8_lt(b->high.x, addon->high.x)) b->high.x = addon->high.x; if (float8_gt(b->low.x, addon->low.x)) b->low.x = addon->low.x; if (float8_lt(b->h...","count":6},{"name":"api-example","value":"static void apply_handle_commit(StringInfo s) { LogicalRepCommitData commit_data; logicalrep_read_commit(s, &commit_data); if (commit_data.commit_lsn != remote_final_lsn) ereport(ERROR, (errcode(ERRCO...","count":6},{"name":"api-example","value":"static void apply_handle_stream_prepare(StringInfo s) { LogicalRepPreparedTxnData prepare_data; ParallelApplyWorkerInfo *winfo; TransApplyAction apply_action; StringInfoData original_msg = *s; if (in_...","count":6},{"name":"api-example","value":"static void autovac_report_activity(autovac_table *tab) { #define MAX_AUTOVAC_ACTIV_LEN (NAMEDATALEN * 2 + 56) char\t\tactivity[MAX_AUTOVAC_ACTIV_LEN]; int\t\t\tlen; if (tab->at_params.options & VACOPT_VAC...","count":6},{"name":"api-example","value":"static void bbstreamer_recovery_injector_content(bbstreamer *streamer, bbstreamer_member *member, const char *data, int len, bbstreamer_archive_context context) { bbstreamer_recovery_injector *mystrea...","count":6},{"name":"api-example","value":"static void bootstrap_signals(void) { Assert(!IsUnderPostmaster); * We don't actually need any non-default signal handling in bootstrap * mode; \"curl up and die\" is a sufficient response for all these...","count":6},{"name":"api-example","value":"static void bootstrap_template1(void) { PG_CMD_DECL; PQExpBufferData cmd; char\t  **line; char\t  **bki_lines; char\t\theaderline[MAXPGPATH]; char\t\tbuf[64]; printf(_(\"running bootstrap script ... \")); ffl...","count":6},{"name":"api-example","value":"static void check_exec(const char *dir, const char *program, bool check_version) { char\t\tpath[MAXPGPATH]; char\t   *line; char\t\tcmd[MAXPGPATH]; char\t\tversionstr[128]; snprintf(path, sizeof(path), \"%s/%...","count":6},{"name":"api-example","value":"static void check_output_expressions(Query *subquery, pushdown_safety_info *safetyInfo) { ListCell   *lc; foreach(lc, subquery->targetList) { TargetEntry *tle = (TargetEntry *) lfirst(lc); if (tle->re...","count":6},{"name":"api-example","value":"static void check_valid_extension_name(const char *extensionname) { int\t\t\tnamelen = strlen(extensionname); * Disallow empty names (the parser rejects empty identifiers anyway, but * let's check). */ i...","count":6},{"name":"api-example","value":"static void cleanup_objects_atexit(void) { if (success) return; * If the server is promoted, there is no way to use the current setup * again. Warn the user that a new replication setup should be done...","count":6},{"name":"api-example","value":"static void compute_new_xmax_infomask(TransactionId xmax, uint16 old_infomask, uint16 old_infomask2, TransactionId add_to_xmax, LockTupleMode mode, bool is_update, TransactionId *result_xmax, uint16 *...","count":6},{"name":"api-example","value":"static void copy_table(Relation rel) { LogicalRepRelMapEntry *relmapentry; LogicalRepRelation lrel; List\t   *qual = NIL; WalRcvExecResult *res; StringInfoData cmd; CopyFromState cstate; List\t   *attna...","count":6},{"name":"api-example","value":"static void create_partial_distinct_paths(PlannerInfo *root, RelOptInfo *input_rel, RelOptInfo *final_distinct_rel, PathTarget *target) { RelOptInfo *partial_distinct_rel; Query\t   *parse; List\t   *di...","count":6},{"name":"api-example","value":"static void deltraverse(struct nfa *nfa, struct state *leftend, struct state *s) { struct arc *a; struct state *to; if (STACK_TOO_DEEP(nfa->v->re)) { NERR(REG_ETOOBIG); return; } if (s->nouts == 0) re...","count":6},{"name":"api-example","value":"static void do_start(void) { pid_t\t\told_pid = 0; pid_t\t\tpm_pid; if (ctl_command != RESTART_COMMAND) { old_pid = get_pgpid(false); if (old_pid != 0) write_stderr(_(\"%s: another server might be running;...","count":6},{"name":"api-example","value":"static void dopr(PrintfTarget *target, const char *format, va_list args) { int\t\t\tsave_errno = errno; const char *first_pct = NULL; int\t\t\tch; bool\t\thave_dollar; bool\t\thave_star; bool\t\tafterstar; int\t\t\t...","count":6},{"name":"api-example","value":"static void dumpFunc(Archive *fout, const FuncInfo *finfo) { DumpOptions *dopt = fout->dopt; PQExpBuffer query; PQExpBuffer q; PQExpBuffer delqry; PQExpBuffer asPart; PGresult   *res; char\t   *funcsig...","count":6},{"name":"api-example","value":"static void dumpTableSchema(Archive *fout, const TableInfo *tbinfo) { DumpOptions *dopt = fout->dopt; PQExpBuffer q = createPQExpBuffer(); PQExpBuffer delq = createPQExpBuffer(); PQExpBuffer extra = c...","count":6},{"name":"api-example","value":"static void dump_block(PLpgSQL_stmt_block *block) { char\t   *name; if (block->label == NULL) name = \"*unnamed*\"; else name = block->label; dump_ind(); printf(\"BLOCK <<%s>>\\n\", name); dump_stmts(block-...","count":6},{"name":"api-example","value":"static void exec_bind_message(StringInfo input_message) { const char *portal_name; const char *stmt_name; int\t\t\tnumPFormats; int16\t   *pformats = NULL; int\t\t\tnumParams; int\t\t\tnumRFormats; int16\t   *rf...","count":6},{"name":"api-example","value":"static void expand_col_privileges(List *colnames, Oid table_oid, AclMode this_privileges, AclMode *col_privileges, int num_col_privileges) { ListCell   *cell; foreach(cell, colnames) { char\t   *colnam...","count":6},{"name":"api-example","value":"static void extract_lateral_references(PlannerInfo *root, RelOptInfo *brel, Index rtindex) { RangeTblEntry *rte = root->simple_rte_array[rtindex]; List\t   *vars; List\t   *newvars; Relids\t\twhere_needed...","count":6},{"name":"api-example","value":"static void fillJsonbValue(JsonbContainer *container, int index, char *base_addr, uint32 offset, JsonbValue *result) { JEntry\t\tentry = container->children[index]; if (JBE_ISNULL(entry)) { result->type...","count":6},{"name":"api-example","value":"static void fill_hba_line(Tuplestorestate *tuple_store, TupleDesc tupdesc, int rule_number, char *filename, int lineno, HbaLine *hba, const char *err_msg) { Datum\t\tvalues[NUM_PG_HBA_FILE_RULES_ATTS]; ...","count":6},{"name":"api-example","value":"static void gather_merge_init(GatherMergeState *gm_state) { int\t\t\tnreaders = gm_state->nreaders; bool\t\tnowait = true; int\t\t\ti; Assert(nreaders <= castNode(GatherMerge, gm_state->ps.plan)->num_workers)...","count":6},{"name":"api-example","value":"static void generate_base_implied_equalities_const(PlannerInfo *root, EquivalenceClass *ec) { EquivalenceMember *const_em = NULL; ListCell   *lc; * In the trivial case where we just had one \"var = con...","count":6},{"name":"api-example","value":"static void generate_orderedappend_paths(PlannerInfo *root, RelOptInfo *rel, List *live_childrels, List *all_child_pathkeys) { ListCell   *lcp; List\t   *partition_pathkeys = NIL; List\t   *partition_pa...","count":6},{"name":"api-example","value":"static void getInstallationPaths(const char *argv0) { DIR\t\t   *pdir; if (find_my_exec(argv0, my_exec_path) < 0) ereport(FATAL, (errmsg(\"%s: could not locate my own executable path\", argv0))); #ifdef E...","count":6},{"name":"api-example","value":"static void get_basic_select_query(Query *query, deparse_context *context) { StringInfo\tbuf = context->buf; RangeTblEntry *values_rte; char\t   *sep; ListCell   *l; if (PRETTY_INDENT(context)) { contex...","count":6},{"name":"api-example","value":"static void get_next_fragment(HeadlineParsedText *prs, int *startpos, int *endpos, int *curlen, int *poslen, int max_words) { int\t\t\ti; * Objective: select a fragment of words between startpos and endp...","count":6},{"name":"api-example","value":"static void get_rule_expr(Node *node, deparse_context *context, bool showimplicit) { StringInfo\tbuf = context->buf; if (node == NULL) return; CHECK_FOR_INTERRUPTS(); check_stack_depth(); * Each level ...","count":6},{"name":"api-example","value":"static void get_rule_windowspec(WindowClause *wc, List *targetList, deparse_context *context) { StringInfo\tbuf = context->buf; bool\t\tneedspace = false; const char *sep; ListCell   *l; appendStringInfo...","count":6},{"name":"api-example","value":"static void get_su_pwd(void) { char\t   *pwd1; if (pwprompt) { * Read password from terminal */ char\t   *pwd2; printf(\"\\n\"); fflush(stdout); pwd1 = simple_prompt(\"Enter new superuser password: \", false...","count":6},{"name":"api-example","value":"static void get_target_list(List *targetList, deparse_context *context) { StringInfo\tbuf = context->buf; StringInfoData targetbuf; bool\t\tlast_was_multiline = false; char\t   *sep; int\t\t\tcolno; ListCell...","count":6},{"name":"api-example","value":"static void get_with_clause(Query *query, deparse_context *context) { StringInfo\tbuf = context->buf; const char *sep; ListCell   *l; if (query->cteList == NIL) return; if (PRETTY_INDENT(context)) { co...","count":6},{"name":"api-example","value":"static void ginCombineData(RBTNode *existing, const RBTNode *newdata, void *arg) { GinEntryAccumulator *eo = (GinEntryAccumulator *) existing; const GinEntryAccumulator *en = (const GinEntryAccumulato...","count":6},{"name":"api-example","value":"static void ginFinishSplit(GinBtree btree, GinBtreeStack *stack, bool freestack, GinStatsData *buildStats) { Page\t\tpage; bool\t\tdone; bool\t\tfirst = true; do { GinBtreeStack *parent = stack->parent; voi...","count":6},{"name":"api-example","value":"static void hash_xlog_squeeze_page(XLogReaderState *record) { XLogRecPtr\tlsn = record->EndRecPtr; xl_hash_squeeze_page *xldata = (xl_hash_squeeze_page *) XLogRecGetData(record); Buffer\t\tbucketbuf = In...","count":6},{"name":"api-example","value":"static void heap_xlog_visible(XLogReaderState *record) { XLogRecPtr\tlsn = record->EndRecPtr; xl_heap_visible *xlrec = (xl_heap_visible *) XLogRecGetData(record); Buffer\t\tvmbuffer = InvalidBuffer; Buff...","count":6},{"name":"api-example","value":"static void infix(INFIX *in, int parentPriority, bool rightPhraseOp) { check_stack_depth(); if (in->curpol->type == QI_VAL) { QueryOperand *curpol = &in->curpol->qoperand; char\t   *op = in->op + curpo...","count":6},{"name":"api-example","value":"static void init_degree_constants(void) { sin_30 = sin(degree_c_thirty * RADIANS_PER_DEGREE); one_minus_cos_60 = 1.0 - cos(degree_c_sixty * RADIANS_PER_DEGREE); asin_0_5 = asin(degree_c_one_half); aco...","count":6},{"name":"api-example","value":"static void initialize_reloptions(void) { int\t\t\ti; int\t\t\tj; j = 0; for (i = 0; boolRelOpts[i].gen.name; i++) { Assert(DoLockModesConflict(boolRelOpts[i].gen.lockmode, boolRelOpts[i].gen.lockmode)); j+...","count":6},{"name":"api-example","value":"static void initscan(HeapScanDesc scan, ScanKey key, bool keep_startblock) { ParallelBlockTableScanDesc bpscan = NULL; bool\t\tallow_strat; bool\t\tallow_sync; * Determine the number of blocks we have to ...","count":6},{"name":"api-example","value":"static void libpqrcv_get_senderinfo(WalReceiverConn *conn, char **sender_host, int *sender_port) { char\t   *ret = NULL; *sender_host = NULL; *sender_port = 0; Assert(conn->streamConn != NULL); ret = P...","count":6},{"name":"api-example","value":"static void llvm_create_types(void) { char\t\tpath[MAXPGPATH]; LLVMMemoryBufferRef buf; char\t   *msg; snprintf(path, MAXPGPATH, \"%s/%s\", pkglib_path, \"llvmjit_types.bc\"); if (LLVMCreateMemoryBufferWithC...","count":6},{"name":"api-example","value":"static void make_ruledef(StringInfo buf, HeapTuple ruletup, TupleDesc rulettc, int prettyFlags) { char\t   *rulename; char\t\tev_type; Oid\t\t\tev_class; bool\t\tis_instead; char\t   *ev_qual; char\t   *ev_acti...","count":6},{"name":"api-example","value":"static void manifest_report_error(JsonManifestParseContext *context, const char *fmt,...) { StringInfoData errbuf; initStringInfo(&errbuf); for (;;) { va_list\t\tap; int\t\t\tneeded; va_start(ap, fmt); nee...","count":6},{"name":"api-example","value":"static void mergeonerun(Tuplesortstate *state) { int\t\t\tsrcTapeIndex; LogicalTape *srcTape; * Start the merge by loading one tuple from each active source tape into * the heap. */ beginmerge(state); As...","count":6},{"name":"api-example","value":"static void pgoutput_send_begin(LogicalDecodingContext *ctx, ReorderBufferTXN *txn) { bool\t\tsend_replication_origin = txn->origin_id != InvalidRepOriginId; PGOutputTxnData *txndata = (PGOutputTxnData ...","count":6},{"name":"api-example","value":"static void pgoutput_startup(LogicalDecodingContext *ctx, OutputPluginOptions *opt, bool is_init) { PGOutputData *data = palloc0(sizeof(PGOutputData)); static bool publication_callback_registered = fa...","count":6},{"name":"api-example","value":"static void pgstat_read_statsfile(void) { FILE\t   *fpin; int32\t\tformat_id; bool\t\tfound; const char *statfile = PGSTAT_STAT_PERMANENT_FILENAME; PgStat_ShmemControl *shmem = pgStatLocal.shmem; Assert(Is...","count":6},{"name":"api-example","value":"static void plperl_create_sub(plperl_proc_desc *prodesc, const char *s, Oid fn_oid) { dTHX; dSP; char\t\tsubname[NAMEDATALEN + 40]; HV\t\t   *pragma_hv = newHV(); SV\t\t   *subref = NULL; int\t\t\tcount; sprin...","count":6},{"name":"api-example","value":"static void populate_joinrel_with_paths(PlannerInfo *root, RelOptInfo *rel1, RelOptInfo *rel2, RelOptInfo *joinrel, SpecialJoinInfo *sjinfo, List *restrictlist) { * Consider paths using each rel as bo...","count":6},{"name":"api-example","value":"static void pqTraceOutput_NotificationResponse(FILE *f, const char *message, int *cursor, bool regress) { fprintf(f, \"NotificationResponse\\t\"); pqTraceOutputInt32(f, message, cursor, regress); pqTrace...","count":6},{"name":"api-example","value":"static void print_unaligned_text(const printTableContent *cont, FILE *fout) { bool\t\topt_tuples_only = cont->opt->tuples_only; unsigned int i; const char *const *ptr; bool\t\tneed_recordsep = false; if (...","count":6},{"name":"api-example","value":"static void process_pm_reload_request(void) { pending_pm_reload_request = false; ereport(DEBUG2, (errmsg_internal(\"postmaster received reload request signal\"))); if (Shutdown <= SmartShutdown) { erepo...","count":6},{"name":"api-example","value":"static void read_client_first_message(scram_state *state, const char *input) { char\t   *p = pstrdup(input); char\t   *channel_binding_type; * The syntax for the client-first-message is: (RFC 5802) * * ...","count":6},{"name":"api-example","value":"static void readtup_heap(Tuplesortstate *state, SortTuple *stup, LogicalTape *tape, unsigned int len) { unsigned int tupbodylen = len - sizeof(int); unsigned int tuplen = tupbodylen + MINIMAL_TUPLE_DA...","count":6},{"name":"api-example","value":"static void recoveryPausesHere(bool endOfRecovery) { if (!LocalHotStandbyActive) return; if (LocalPromoteIsTriggered) return; if (endOfRecovery) ereport(LOG, (errmsg(\"pausing at the end of recovery\"),...","count":6},{"name":"api-example","value":"static void recovery_create_dbdir(char *path, bool only_tblspc) { struct stat st; Assert(RecoveryInProgress()); if (stat(path, &st) == 0) return; if (only_tblspc && strstr(path, \"pg_tblspc/\") == NULL)...","count":6},{"name":"api-example","value":"static void report_invalid_record(XLogReaderState *state, const char *fmt,...) { va_list\t\targs; fmt = _(fmt); va_start(args, fmt); vsnprintf(state->errormsg_buf, MAX_ERRORMSG_LEN, fmt, args); va_end(a...","count":6},{"name":"api-example","value":"static void rt_box_union(BOX *n, const BOX *a, const BOX *b) { n->high.x = float8_max(a->high.x, b->high.x); n->high.y = float8_max(a->high.y, b->high.y); n->low.x = float8_min(a->low.x, b->low.x); n-...","count":6},{"name":"api-example","value":"static void runInitSteps(const char *initialize_steps) { PQExpBufferData stats; PGconn\t   *con; const char *step; double\t\trun_time = 0.0; bool\t\tfirst = true; initPQExpBuffer(&stats); if ((con = doConn...","count":6},{"name":"api-example","value":"static void sendFileWithContent(bbsink *sink, const char *filename, const char *content, int len, backup_manifest_info *manifest) { struct stat statbuf; int\t\t\tbytes_done = 0; pg_checksum_context check...","count":6},{"name":"api-example","value":"static void send_message_to_server_log(ErrorData *edata) { StringInfoData buf; bool\t\tfallback_to_stderr = false; initStringInfo(&buf); log_line_prefix(&buf, edata); appendStringInfo(&buf, \"%s:  \", _(e...","count":6},{"name":"api-example","value":"static void set_append_rel_size(PlannerInfo *root, RelOptInfo *rel, Index rti, RangeTblEntry *rte) { int\t\t\tparentRTindex = rti; bool\t\thas_live_children; double\t\tparent_rows; double\t\tparent_size; doubl...","count":6},{"name":"api-example","value":"static void set_base_rel_consider_startup(PlannerInfo *root) { * Since parameterized paths can only be used on the inside of a nestloop * join plan, there is usually little value in considering fast-s...","count":6},{"name":"api-example","value":"static void set_foreignscan_references(PlannerInfo *root, ForeignScan *fscan, int rtoffset) { if (fscan->scan.scanrelid > 0) fscan->scan.scanrelid += rtoffset; if (fscan->fdw_scan_tlist != NIL || fsca...","count":6},{"name":"api-example","value":"static void set_rel_width(PlannerInfo *root, RelOptInfo *rel) { Oid\t\t\treloid = planner_rt_fetch(rel->relid, root)->relid; int64\t\ttuple_width = 0; bool\t\thave_wholerow_var = false; ListCell   *lc; rel->...","count":6},{"name":"api-example","value":"static void set_stack_value(struct config_generic *gconf, config_var_value *val) { switch (gconf->vartype) { case PGC_BOOL: val->val.boolval = *((struct config_bool *) gconf)->variable; break; case PG...","count":6},{"name":"api-example","value":"static void setlocales(void) { char\t   *canonname; if (locale) { if (!lc_ctype) lc_ctype = locale; if (!lc_collate) lc_collate = locale; if (!lc_numeric) lc_numeric = locale; if (!lc_time) lc_time = l...","count":6},{"name":"api-example","value":"static void show_incremental_sort_group_info(IncrementalSortGroupInfo *groupInfo, const char *groupLabel, bool indent, ExplainState *es) { ListCell   *methodCell; List\t   *methodNames = NIL; for (int ...","count":6},{"name":"api-example","value":"static void sort_inner_and_outer(PlannerInfo *root, RelOptInfo *joinrel, RelOptInfo *outerrel, RelOptInfo *innerrel, JoinType jointype, JoinPathExtraData *extra) { JoinType\tsave_jointype = jointype; P...","count":6},{"name":"api-example","value":"static void startScanEntry(GinState *ginstate, GinScanEntry entry, Snapshot snapshot) { GinBtreeData btreeEntry; GinBtreeStack *stackEntry; Page\t\tpage; bool\t\tneedUnlock; restartScanEntry: entry->buffe...","count":6},{"name":"api-example","value":"static void stream_abort_internal(TransactionId xid, TransactionId subxid) { * If the two XIDs are the same, it's in fact abort of toplevel xact, so * just delete the files with serialized info. */ if...","count":6},{"name":"api-example","value":"static void swap_relation_files(Oid r1, Oid r2, bool target_is_pg_class, bool swap_toast_by_content, bool is_internal, TransactionId frozenXid, MultiXactId cutoffMulti, Oid *mapped_tables) { Relation\t...","count":6},{"name":"api-example","value":"static void switchToPresortedPrefixMode(PlanState *pstate) { IncrementalSortState *node = castNode(IncrementalSortState, pstate); ScanDirection dir; int64\t\tnTuples; TupleDesc\ttupDesc; PlanState  *oute...","count":6},{"name":"api-example","value":"static void test_open(void) { int\t\t\ttmpfile; * test if we can open the target file */ if ((tmpfile = open(filename, O_RDWR | O_CREAT | PG_BINARY, S_IRUSR | S_IWUSR)) == -1) die(\"could not open output ...","count":6},{"name":"api-example","value":"static void validateForeignKeyConstraint(char *conname, Relation rel, Relation pkrel, Oid pkindOid, Oid constraintOid) { TupleTableSlot *slot; TableScanDesc scan; Trigger\t\ttrig = {0}; Snapshot\tsnapsho...","count":6},{"name":"api-example","value":"static void write_stderr(const char *fmt,...) { va_list\t\tap; va_start(ap, fmt); #ifndef WIN32 vfprintf(stderr, fmt, ap); #else * On Win32, we print to stderr if running on a console, or write to * eve...","count":6},{"name":"api-example","value":"static zic_t getleapdatetime(char **fields, int nfields, bool expire_line) { const char *cp; const struct lookup *lp; zic_t\t\ti, j; int\t\t\tyear; int\t\t\tmonth, day; zic_t\t\tdayoff, tod; zic_t\t\tt; char\t\txs;...","count":6},{"name":"api-example","value":"struct ECPGstruct_member * ECPGstruct_member_dup(struct ECPGstruct_member *rm) { struct ECPGstruct_member *new = NULL; while (rm) { struct ECPGtype *type; switch (rm->type->type) { case ECPGt_struct: ...","count":6},{"name":"api-example","value":"struct config_generic ** get_explain_guc_options(int *num) { struct config_generic **result; dlist_iter\titer; *num = 0; * While only a fraction of all the GUC variables are marked GUC_EXPLAIN, * it do...","count":6},{"name":"api-example","value":"uint32 _hash_datum2hashkey_type(Relation rel, Datum key, Oid keytype) { RegProcedure hash_proc; Oid\t\t\tcollation; hash_proc = get_opfamily_proc(rel->rd_opfamily[0], keytype, keytype, HASHSTANDARD_PROC)...","count":6},{"name":"api-example","value":"uint64 DoCopyTo(CopyToState cstate) { bool\t\tpipe = (cstate->filename == NULL && cstate->data_dest_cb == NULL); bool\t\tfe_copy = (pipe && whereToSendOutput == DestRemote); TupleDesc\ttupDesc; int\t\t\tnum_p...","count":6},{"name":"api-example","value":"void * AlignedAllocRealloc(void *pointer, Size size, int flags) { MemoryChunk *redirchunk = PointerGetMemoryChunk(pointer); Size\t\talignto; void\t   *unaligned; MemoryContext ctx; Size\t\told_size; void\t ...","count":6},{"name":"api-example","value":"void * MemoryContextAlloc(MemoryContext context, Size size) { void\t   *ret; Assert(MemoryContextIsValid(context)); AssertNotInCriticalSection(context); context->isReset = false; * For efficiency reaso...","count":6},{"name":"api-example","value":"void AcquireDeletionLock(const ObjectAddress *object, int flags) { if (object->classId == RelationRelationId) { * In DROP INDEX CONCURRENTLY, take only ShareUpdateExclusiveLock on * the index for the ...","count":6},{"name":"api-example","value":"void AlignedAllocFree(void *pointer) { MemoryChunk *chunk = PointerGetMemoryChunk(pointer); void\t   *unaligned; VALGRIND_MAKE_MEM_DEFINED(chunk, sizeof(MemoryChunk)); Assert(!MemoryChunkIsExternal(chu...","count":6},{"name":"api-example","value":"void AlterObjectOwner_internal(Oid classId, Oid objectId, Oid new_ownerId) { Oid\t\t\tcatalogId = (classId == LargeObjectRelationId) ? LargeObjectMetadataRelationId : classId; AttrNumber\tAnum_oid = get_o...","count":6},{"name":"api-example","value":"void ApplyLauncherShmemInit(void) { bool\t\tfound; LogicalRepCtx = (LogicalRepCtxStruct *) ShmemInitStruct(\"Logical Replication Launcher Data\", ApplyLauncherShmemSize(), &found); if (!found) { int\t\t\tslo...","count":6},{"name":"api-example","value":"void CheckAttributeNamesTypes(TupleDesc tupdesc, char relkind, int flags) { int\t\t\ti; int\t\t\tj; int\t\t\tnatts = tupdesc->natts; if (natts < 0 || natts > MaxHeapAttributeNumber) ereport(ERROR, (errcode(ERR...","count":6},{"name":"api-example","value":"void ConditionVariablePrepareToSleep(ConditionVariable *cv) { int\t\t\tpgprocno = MyProcNumber; * If some other sleep is already prepared, cancel it; this is necessary * because we have just one static v...","count":6},{"name":"api-example","value":"void DecrTupleDescRefCount(TupleDesc tupdesc) { Assert(tupdesc->tdrefcount > 0); ResourceOwnerForgetTupleDesc(CurrentResourceOwner, tupdesc); if (--tupdesc->tdrefcount == 0) FreeTupleDesc(tupdesc); }","count":6},{"name":"api-example","value":"void DefineCustomBoolVariable(const char *name, const char *short_desc, const char *long_desc, bool *valueAddr, bool bootValue, GucContext context, int flags, GucBoolCheckHook check_hook, GucBoolAssig...","count":6},{"name":"api-example","value":"void DetachSession(void) { dsm_detach(CurrentSession->segment); CurrentSession->segment = NULL; dsa_detach(CurrentSession->area); CurrentSession->area = NULL; }","count":6},{"name":"api-example","value":"void DropRelationBuffers(SMgrRelation smgr_reln, ForkNumber *forkNum, int nforks, BlockNumber *firstDelBlock) { int\t\t\ti; int\t\t\tj; RelFileLocatorBackend rlocator; BlockNumber nForkBlock[MAX_FORKNUM]; u...","count":6},{"name":"api-example","value":"void ECPGdump_a_type(FILE *o, const char *name, struct ECPGtype *type, const int brace_level, const char *ind_name, struct ECPGtype *ind_type, const int ind_brace_level, const char *prefix, const char...","count":6},{"name":"api-example","value":"void EncodeDateTime(struct pg_tm *tm, fsec_t fsec, bool print_tz, int tz, const char *tzn, int style, char *str) { int\t\t\tday; Assert(tm->tm_mon >= 1 && tm->tm_mon <= MONTHS_PER_YEAR); * Negative tm_is...","count":6},{"name":"api-example","value":"void EventTriggerDDLCommandStart(Node *parsetree) { List\t   *runlist; EventTriggerData trigdata; * Event Triggers are completely disabled in standalone mode.  There are * (at least) two reasons for th...","count":6},{"name":"api-example","value":"void ExecBSUpdateTriggers(EState *estate, ResultRelInfo *relinfo) { TriggerDesc *trigdesc; int\t\t\ti; TriggerData LocTriggerData = {0}; Bitmapset  *updatedCols; trigdesc = relinfo->ri_TrigDesc; if (trig...","count":6},{"name":"api-example","value":"void ExecEvalConvertRowtype(ExprState *state, ExprEvalStep *op, ExprContext *econtext) { HeapTuple\tresult; Datum\t\ttupDatum; HeapTupleHeader tuple; HeapTupleData tmptup; TupleDesc\tindesc, outdesc; bool...","count":6},{"name":"api-example","value":"void ExecIndexBuildScanKeys(PlanState *planstate, Relation index, List *quals, bool isorderby, ScanKey *scanKeys, int *numScanKeys, IndexRuntimeKeyInfo **runtimeKeys, int *numRuntimeKeys, IndexArrayKe...","count":6},{"name":"api-example","value":"void ExecPartitionCheckEmitError(ResultRelInfo *resultRelInfo, TupleTableSlot *slot, EState *estate) { Oid\t\t\troot_relid; TupleDesc\ttupdesc; char\t   *val_desc; Bitmapset  *modifiedCols; * If the tuple ...","count":6},{"name":"api-example","value":"void ExecReScan(PlanState *node) { if (node->instrument) InstrEndLoop(node->instrument); * If we have changed parameters, propagate that info. * * Note: ExecReScanSetParamPlan() can add bits to node->...","count":6},{"name":"api-example","value":"void ExecuteGrantStmt(GrantStmt *stmt) { InternalGrant istmt; ListCell   *cell; const char *errormsg; AclMode\t\tall_privileges; if (stmt->grantor) { Oid\t\t\tgrantor; grantor = get_rolespec_oid(stmt->gran...","count":6},{"name":"api-example","value":"void FormIndexDatum(IndexInfo *indexInfo, TupleTableSlot *slot, EState *estate, Datum *values, bool *isnull) { ListCell   *indexpr_item; int\t\t\ti; if (indexInfo->ii_Expressions != NIL && indexInfo->ii_...","count":6},{"name":"api-example","value":"void FreeBackupManifest(backup_manifest_info *manifest) { pg_cryptohash_free(manifest->manifest_ctx); manifest->manifest_ctx = NULL; }","count":6},{"name":"api-example","value":"void GrantLock(LOCK *lock, PROCLOCK *proclock, LOCKMODE lockmode) { lock->nGranted++; lock->granted[lockmode]++; lock->grantMask |= LOCKBIT_ON(lockmode); if (lock->granted[lockmode] == lock->requested...","count":6},{"name":"api-example","value":"void HandleParallelMessages(void) { dlist_iter\titer; MemoryContext oldcontext; static MemoryContext hpm_context = NULL; * This is invoked from ProcessInterrupts(), and since some of the * functions it...","count":6},{"name":"api-example","value":"void ImportSnapshot(const char *idstr) { char\t\tpath[MAXPGPATH]; FILE\t   *f; struct stat stat_buf; char\t   *filebuf; int\t\t\txcnt; int\t\t\ti; VirtualTransactionId src_vxid; int\t\t\tsrc_pid; Oid\t\t\tsrc_dbid; i...","count":6},{"name":"api-example","value":"void InitPredicateLocks(void) { HASHCTL\t\tinfo; long\t\tmax_table_size; Size\t\trequestSize; bool\t\tfound; #ifndef EXEC_BACKEND Assert(!IsUnderPostmaster); #endif * Compute size of predicate lock target has...","count":6},{"name":"api-example","value":"void InitializeMaxBackends(void) { Assert(MaxBackends == 0); MaxBackends = MaxConnections + autovacuum_max_workers + max_worker_processes + max_wal_senders + NUM_SPECIAL_WORKER_PROCS; if (MaxBackends ...","count":6},{"name":"api-example","value":"void InitializeWalConsistencyChecking(void) { Assert(process_shared_preload_libraries_done); if (check_wal_consistency_checking_deferred) { struct config_generic *guc; guc = find_option(\"wal_consisten...","count":6},{"name":"api-example","value":"void InsertOneValue(char *value, int i) { Oid\t\t\ttypoid; int16\t\ttyplen; bool\t\ttypbyval; char\t\ttypalign; char\t\ttypdelim; Oid\t\t\ttypioparam; Oid\t\t\ttypinput; Oid\t\t\ttypoutput; Assert(i >= 0 && i < MAXATTR);...","count":6},{"name":"api-example","value":"void IsThereCollationInNamespace(const char *collname, Oid nspOid) { if (SearchSysCacheExists3(COLLNAMEENCNSP, CStringGetDatum(collname), Int32GetDatum(GetDatabaseEncoding()), ObjectIdGetDatum(nspOid)...","count":6},{"name":"api-example","value":"void LimitAdditionalPins(uint32 *additional_pins) { uint32\t\tmax_backends; int\t\t\tmax_proportional_pins; if (*additional_pins <= 1) return; max_backends = MaxBackends + NUM_AUXILIARY_PROCS; max_proporti...","count":6},{"name":"api-example","value":"void LockBufferForCleanup(Buffer buffer) { BufferDesc *bufHdr; TimestampTz waitStart = 0; bool\t\twaiting = false; bool\t\tlogged_recovery_conflict = false; Assert(BufferIsPinned(buffer)); Assert(PinCount...","count":6},{"name":"api-example","value":"void LockRelationOid(Oid relid, LOCKMODE lockmode) { LOCKTAG\t\ttag; LOCALLOCK  *locallock; LockAcquireResult res; SetLocktagRelationOid(&tag, relid); res = LockAcquireExtended(&tag, lockmode, false, fa...","count":6},{"name":"api-example","value":"void LogRecoveryConflict(ProcSignalReason reason, TimestampTz wait_start, TimestampTz now, VirtualTransactionId *wait_list, bool still_waiting) { long\t\tsecs; int\t\t\tusecs; long\t\tmsecs; StringInfoData b...","count":6},{"name":"api-example","value":"void PGReserveSemaphores(int maxSemas) { struct stat statbuf; * We use the data directory's inode number to seed the search for free * semaphore keys.  This minimizes the odds of collision with other ...","count":6},{"name":"api-example","value":"void PLy_elog_impl(int elevel, const char *fmt,...) { int\t\t\tsave_errno = errno; char\t   *volatile xmsg = NULL; char\t   *volatile tbmsg = NULL; int\t\t\ttb_depth; StringInfoData emsg; PyObject   *exc, *va...","count":6},{"name":"api-example","value":"void ParsePrepareRecord(uint8 info, xl_xact_prepare *xlrec, xl_xact_parsed_prepare *parsed) { char\t   *bufptr; bufptr = ((char *) xlrec) + MAXALIGN(sizeof(xl_xact_prepare)); memset(parsed, 0, sizeof(*...","count":6},{"name":"api-example","value":"void PathNameDeleteTemporaryDir(const char *dirname) { struct stat statbuf; if (stat(dirname, &statbuf) != 0 && errno == ENOENT) return; * Currently, walkdir doesn't offer a way for our passed in func...","count":6},{"name":"api-example","value":"void PrepareRedoAdd(char *buf, XLogRecPtr start_lsn, XLogRecPtr end_lsn, RepOriginId origin_id) { TwoPhaseFileHeader *hdr = (TwoPhaseFileHeader *) buf; char\t   *bufptr; const char *gid; GlobalTransact...","count":6},{"name":"api-example","value":"void RS_compile(Regis *r, bool issuffix, const char *str) { int\t\t\tlen = strlen(str); int\t\t\tstate = RS_IN_WAIT; const char *c = str; RegisNode  *ptr = NULL; memset(r, 0, sizeof(Regis)); r->issuffix = (...","count":6},{"name":"api-example","value":"void RangeVarAdjustRelationPersistence(RangeVar *newRelation, Oid nspid) { switch (newRelation->relpersistence) { case RELPERSISTENCE_TEMP: if (!isTempOrTempToastNamespace(nspid)) { if (isAnyTempNames...","count":6},{"name":"api-example","value":"void RelationMapInvalidate(bool shared) { if (shared) { if (shared_map.magic == RELMAPPER_FILEMAGIC) load_relmap_file(true, false); } else { if (local_map.magic == RELMAPPER_FILEMAGIC) load_relmap_fil...","count":6},{"name":"api-example","value":"void ReorderBufferQueueChange(ReorderBuffer *rb, TransactionId xid, XLogRecPtr lsn, ReorderBufferChange *change, bool toast_insert) { ReorderBufferTXN *txn; txn = ReorderBufferTXNByXid(rb, xid, true, ...","count":6},{"name":"api-example","value":"void ResetSequence(Oid seq_relid) { Relation\tseq_rel; SeqTable\telm; Form_pg_sequence_data seq; Buffer\t\tbuf; HeapTupleData seqdatatuple; HeapTuple\ttuple; HeapTuple\tpgstuple; Form_pg_sequence pgsform; i...","count":6},{"name":"api-example","value":"void SetDataDir(const char *dir) { char\t   *new; Assert(dir); new = make_absolute_path(dir); free(DataDir); DataDir = new; }","count":6},{"name":"api-example","value":"void SubTransSetParent(TransactionId xid, TransactionId parent) { int64\t\tpageno = TransactionIdToPage(xid); int\t\t\tentryno = TransactionIdToEntry(xid); int\t\t\tslotno; LWLock\t   *lock; TransactionId *ptr...","count":6},{"name":"api-example","value":"void SyncRepUpdateSyncStandbysDefined(void) { bool\t\tsync_standbys_defined = SyncStandbysDefined(); if (sync_standbys_defined != ((WalSndCtl->sync_standbys_status & SYNC_STANDBY_DEFINED) != 0)) { LWLoc...","count":6},{"name":"api-example","value":"void TruncateCLOG(TransactionId oldestXact, Oid oldestxid_datoid) { int64\t\tcutoffPage; * The cutoff point is the start of the segment containing oldestXact. We * pass the *page* containing oldestXact ...","count":6},{"name":"api-example","value":"void UpdateChangedParamSet(PlanState *node, Bitmapset *newchg) { Bitmapset  *parmset; * The plan node only depends on params listed in its allParam set. Don't * include anything else into its chgParam...","count":6},{"name":"api-example","value":"void WaitForParallelWorkersToAttach(ParallelContext *pcxt) { int\t\t\ti; if (pcxt->nworkers_launched == 0) return; for (;;) { * This will process any parallel messages that are pending and it may * also ...","count":6},{"name":"api-example","value":"void XactLockTableInsert(TransactionId xid) { LOCKTAG\t\ttag; SET_LOCKTAG_TRANSACTION(tag, xid); (void) LockAcquire(&tag, ExclusiveLock, false, false); }","count":6},{"name":"api-example","value":"void _bt_pagedel(Relation rel, Buffer leafbuf, BTVacState *vstate) { BlockNumber rightsib; bool\t\trightsib_empty; Page\t\tpage; BTPageOpaque opaque; * Save original leafbuf block number from caller.  Onl...","count":6},{"name":"api-example","value":"void _bt_set_cleanup_info(Relation rel, BlockNumber num_delpages) { Buffer\t\tmetabuf; Page\t\tmetapg; BTMetaPageData *metad; * On-disk compatibility note: The btm_last_cleanup_num_delpages metapage * fie...","count":6},{"name":"api-example","value":"void boot_openrel(char *relname) { int\t\t\ti; if (strlen(relname) >= NAMEDATALEN) relname[NAMEDATALEN - 1] = '\\0'; * pg_type must be filled before any OPEN command is executed, hence we * can now popula...","count":6},{"name":"api-example","value":"void brinGetStats(Relation index, BrinStatsData *stats) { Buffer\t\tmetabuffer; Page\t\tmetapage; BrinMetaPageData *metadata; metabuffer = ReadBuffer(index, BRIN_METAPAGE_BLKNO); LockBuffer(metabuffer, BU...","count":6},{"name":"api-example","value":"void brinSetHeapBlockItemptr(Buffer buf, BlockNumber pagesPerRange, BlockNumber heapBlk, ItemPointerData tid) { RevmapContents *contents; ItemPointerData *iptr; Page\t\tpage; page = BufferGetPage(buf); ...","count":6},{"name":"api-example","value":"void brin_page_cleanup(Relation idxrel, Buffer buf) { Page\t\tpage = BufferGetPage(buf); * If a page was left uninitialized, initialize it now; also record it in * FSM. * * Somebody else might be extend...","count":6},{"name":"api-example","value":"void build_aggregate_transfn_expr(Oid *agg_input_types, int agg_num_inputs, int agg_num_direct_inputs, bool agg_variadic, Oid agg_state_type, Oid agg_input_collation, Oid transfn_oid, Oid invtransfn_o...","count":6},{"name":"api-example","value":"void cost_incremental_sort(Path *path, PlannerInfo *root, List *pathkeys, int presorted_keys, Cost input_startup_cost, Cost input_total_cost, double input_tuples, int width, Cost comparison_cost, int ...","count":6},{"name":"api-example","value":"void cost_index(IndexPath *path, PlannerInfo *root, double loop_count, bool partial_path) { IndexOptInfo *index = path->indexinfo; RelOptInfo *baserel = index->rel; bool\t\tindexonly = (path->path.patht...","count":6},{"name":"api-example","value":"void dbase_redo(XLogReaderState *record) { uint8\t\tinfo = XLogRecGetInfo(record) & ~XLR_INFO_MASK; Assert(!XLogRecHasAnyBlockRefs(record)); if (info == XLOG_DBASE_CREATE_FILE_COPY) { xl_dbase_create_fi...","count":6},{"name":"api-example","value":"void do_pg_backup_start(const char *backupidstr, bool fast, List **tablespaces, BackupState *state, StringInfo tblspcmapfile) { bool\t\tbackup_started_in_recovery; Assert(state != NULL); backup_started_...","count":6},{"name":"api-example","value":"void dropdb(const char *dbname, bool missing_ok, bool force) { Oid\t\t\tdb_id; bool\t\tdb_istemplate; Relation\tpgdbrel; HeapTuple\ttup; ScanKeyData scankey; void\t   *inplace_state; Form_pg_database datform;...","count":6},{"name":"api-example","value":"void end_heap_rewrite(RewriteState state) { HASH_SEQ_STATUS seq_status; UnresolvedTup unresolved; * Write any remaining tuples in the UnresolvedTups table. If we have any * left, they should in fact b...","count":6},{"name":"api-example","value":"void fsync_fname(const char *fname, bool isdir) { fsync_fname_ext(fname, isdir, false, data_sync_elevel(ERROR)); }","count":6},{"name":"api-example","value":"void get_row_security_policies(Query *root, RangeTblEntry *rte, int rt_index, List **securityQuals, List **withCheckOptions, bool *hasRowSecurity, bool *hasSubLinks) { Oid\t\t\tuser_id; int\t\t\trls_status;...","count":6},{"name":"api-example","value":"void index_build(Relation heapRelation, Relation indexRelation, IndexInfo *indexInfo, bool isreindex, bool parallel) { IndexBuildResult *stats; Oid\t\t\tsave_userid; int\t\t\tsave_sec_context; int\t\t\tsave_ne...","count":6},{"name":"api-example","value":"void index_parallelscan_initialize(Relation heapRelation, Relation indexRelation, Snapshot snapshot, ParallelIndexScanDesc target) { Size\t\toffset; Assert(snapshot != InvalidSnapshot); RELATION_CHECKS;...","count":6},{"name":"api-example","value":"void index_rescan(IndexScanDesc scan, ScanKey keys, int nkeys, ScanKey orderbys, int norderbys) { SCAN_CHECKS; CHECK_SCAN_PROCEDURE(amrescan); Assert(nkeys == scan->numberOfKeys); Assert(norderbys == ...","count":6},{"name":"api-example","value":"void interpret_function_parameter_list(ParseState *pstate, List *parameters, Oid languageOid, ObjectType objtype, oidvector **parameterTypes, List **parameterTypes_list, ArrayType **allParameterTypes,...","count":6},{"name":"api-example","value":"void llvm_inline(LLVMModuleRef M) { LLVMContextRef lc = LLVMGetModuleContext(M); llvm::Module *mod = llvm::unwrap(M); std::unique_ptr<ImportMapTy> globalsToInline = llvm_build_inline_plan(lc, mod); if...","count":6},{"name":"api-example","value":"void logicalmsg_desc(StringInfo buf, XLogReaderState *record) { char\t   *rec = XLogRecGetData(record); uint8\t\tinfo = XLogRecGetInfo(record) & ~XLR_INFO_MASK; if (info == XLOG_LOGICAL_MESSAGE) { xl_log...","count":6},{"name":"api-example","value":"void mask_page_lsn_and_checksum(Page page) { PageHeader\tphdr = (PageHeader) page; PageXLogRecPtrSet(phdr->pd_lsn, (uint64) MASK_MARKER); phdr->pd_checksum = MASK_MARKER; }","count":6},{"name":"api-example","value":"void mdreadv(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum, void **buffers, BlockNumber nblocks) { while (nblocks > 0) { struct iovec iov[PG_IOV_MAX]; int\t\t\tiovcnt; off_t\t\tseekpos; int\t\t...","count":6},{"name":"api-example","value":"void on_proc_exit(pg_on_exit_callback function, Datum arg) { if (on_proc_exit_index >= MAX_ON_EXITS) ereport(FATAL, (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED), errmsg_internal(\"out of on_proc_exit slots...","count":6},{"name":"api-example","value":"void pg_re_throw(void) { if (PG_exception_stack != NULL) siglongjmp(*PG_exception_stack, 1); else { * If we get here, elog(ERROR) was thrown inside a PG_TRY block, which * we have now exited only to d...","count":6},{"name":"api-example","value":"void pg_usleep(long microsec) { if (unlikely(pgwin32_signal_event == NULL)) { * If we're reached by pgwin32_open_handle() early in startup before * the signal event is set up, just fall back to a regu...","count":6},{"name":"api-example","value":"void pgstat_progress_start_command(ProgressCommandType cmdtype, Oid relid) { volatile PgBackendStatus *beentry = MyBEEntry; if (!beentry || !pgstat_track_activities) return; PGSTAT_BEGIN_WRITE_ACTIVIT...","count":6},{"name":"api-example","value":"void pgstat_reset_replslot(const char *name) { ReplicationSlot *slot; Assert(name != NULL); LWLockAcquire(ReplicationSlotControlLock, LW_SHARED); slot = SearchNamedReplicationSlot(name, false); if (!s...","count":6},{"name":"api-example","value":"void pgwin32_dispatch_queued_signals(void) { int\t\t\texec_mask; Assert(pgwin32_signal_event != NULL); EnterCriticalSection(&pg_signal_crit_sec); while ((exec_mask = UNBLOCKED_SIGNAL_QUEUE()) != 0) { int...","count":6},{"name":"api-example","value":"void pq_sendcountedtext(StringInfo buf, const char *str, int slen) { char\t   *p; p = pg_server_to_client(str, slen); if (p != str)\t\t\t\t/* actual conversion has been done? */ { slen = strlen(p); pq_send...","count":6},{"name":"api-example","value":"void procsignal_sigusr1_handler(SIGNAL_ARGS) { if (CheckProcSignal(PROCSIG_CATCHUP_INTERRUPT)) HandleCatchupInterrupt(); if (CheckProcSignal(PROCSIG_NOTIFY_INTERRUPT)) HandleNotifyInterrupt(); if (Che...","count":6},{"name":"api-example","value":"void pushOperator(TSQueryParserState state, int8 oper, int16 distance) { QueryOperator *tmp; Assert(oper == OP_NOT || oper == OP_AND || oper == OP_OR || oper == OP_PHRASE); tmp = (QueryOperator *) pal...","count":6},{"name":"api-example","value":"void pushStop(TSQueryParserState state) { QueryOperand *tmp; tmp = (QueryOperand *) palloc0(sizeof(QueryOperand)); tmp->type = QI_VALSTOP; state->polstr = lcons(tmp, state->polstr); }","count":6},{"name":"api-example","value":"void range_set_contain_empty(RangeType *range) { char\t   *flagsp; flagsp = (char *) range + VARSIZE(range) - 1; *flagsp |= RANGE_CONTAIN_EMPTY; }","count":6},{"name":"api-example","value":"void relation_close(Relation relation, LOCKMODE lockmode) { LockRelId\trelid = relation->rd_lockInfo.lockRelId; Assert(lockmode >= NoLock && lockmode < MAX_LOCKMODES); RelationClose(relation); if (lock...","count":6},{"name":"api-example","value":"void seq_desc(StringInfo buf, XLogReaderState *record) { char\t   *rec = XLogRecGetData(record); uint8\t\tinfo = XLogRecGetInfo(record) & ~XLR_INFO_MASK; xl_seq_rec *xlrec = (xl_seq_rec *) rec; if (info ...","count":6},{"name":"api-example","value":"void setup_data_file_paths(void) { set_input(&bki_file, \"postgres.bki\"); set_input(&hba_file, \"pg_hba.conf.sample\"); set_input(&ident_file, \"pg_ident.conf.sample\"); set_input(&conf_file, \"postgresql.c...","count":6},{"name":"api-example","value":"void spg_desc(StringInfo buf, XLogReaderState *record) { char\t   *rec = XLogRecGetData(record); uint8\t\tinfo = XLogRecGetInfo(record) & ~XLR_INFO_MASK; switch (info) { case XLOG_SPGIST_ADD_LEAF: { spgx...","count":6},{"name":"api-example","value":"void toast_tuple_init(ToastTupleContext *ttc) { TupleDesc\ttupleDesc = ttc->ttc_rel->rd_att; int\t\t\tnumAttrs = tupleDesc->natts; int\t\t\ti; ttc->ttc_flags = 0; for (i = 0; i < numAttrs; i++) { Form_pg_att...","count":6},{"name":"api-example","value":"void transformRuleStmt(RuleStmt *stmt, const char *queryString, List **actions, Node **whereClause) { Relation\trel; ParseState *pstate; ParseNamespaceItem *oldnsitem; ParseNamespaceItem *newnsitem; * ...","count":6},{"name":"api-example","value":"void tuplesort_puttuple_common(Tuplesortstate *state, SortTuple *tuple, bool useAbbrev, Size tuplen) { MemoryContext oldcontext = MemoryContextSwitchTo(state->base.sortcontext); Assert(!LEADER(state))...","count":6},{"name":"api-example","value":"void usage(unsigned short int pager) { PQExpBufferData buf; int\t\t\tnlcount; FILE\t   *output; * To avoid counting the output lines manually, build the output in \"buf\" * and then count them. */ initPQExp...","count":6},{"name":"api-example","value":"void vacuum_delay_point(void) { double\t\tmsec = 0; CHECK_FOR_INTERRUPTS(); if (InterruptPending || (!VacuumCostActive && !ConfigReloadPending)) return; * Autovacuum workers should reload the configurat...","count":6},{"name":"arch-layer","value":"background","count":6},{"name":"arch-layer-description","value":"Background worker processes","count":6},{"name":"Feature","value":"ALTER TABLE ... SET LOGGED / UNLOGGED","count":5},{"name":"Feature","value":"Accelerated partition pruning","count":5},{"name":"Feature","value":"Background Writer","count":5},{"name":"Feature","value":"Fractional input for \"integer\" values","count":5},{"name":"Feature","value":"SQL/JSON: datetime()","count":5},{"name":"Feature","value":"SSL client certificate authentication","count":5},{"name":"Feature","value":"hstore","count":5},{"name":"arch-sublayer","value":"buffer-manager","count":5},{"name":"subsystem-desc","value":"src/backend/utils/resowner/README\n\nNotes About Resource Owners\n===========================\n\nResourceOwner objects are a concept invented to simplify management of\nquery-related resources, such as buffer pins and table locks.  These\nresources need to be tracked in a reliable way to ensure that they will\nbe released at query end, even if the query fails due to an error.\nRather than expecting the entire executor to have bulletproof data\nstructures, we localize the tracking of such resources into a single\nmodule.\n\nThe design of the ResourceOwner API is modeled on our MemoryContext API,\nwhich has proven very flexible and successful in preventing memory leaks.\nIn particular we allow ResourceOwners to have child ResourceOwner objects\nso that there can be forests of the things; releasing a parent\nResourceOwner acts on all its direct and indirect children as well.\n\n(It is tempting to consider unifying ResourceOwners and MemoryContexts\ninto a single object type, but their usage patterns are sufficiently\ndifferent that this is probably not really a helpful thing to do.)\n\nWe create a ResourceOwner for each transaction or subtransaction as\nwell as one for each Portal.  During execution of a Portal, the global\nvariable CurrentResourceOwner points to the Portal's ResourceOwner.\nThis causes operations such as ReadBuffer and LockAcquire to record\nownership of the acquired resources in that ResourceOwner object.\n\nWhen a Portal is closed, any remaining resources (typically only locks)\nbecome the responsibility of the current transaction.  This is represented\nby making the Portal's ResourceOwner a child of the current transaction's\nResourceOwner.  resowner.c automatically transfers the resources to the\nparent object when releasing the child.  Similarly, subtransaction\nResourceOwners are children of their immediate parent.\n\nWe need transaction-related ResourceOwners as well as Portal-related ones\nbecause transactions may initiate operations that require resources (such\nas query parsing) when no associated Portal exists yet.\n\n\nUsage\n-----\n\nThe basic operations on a ResourceOwner are:\n\n* create a ResourceOwner\n\n* associate or deassociate some resource with a ResourceOwner\n\n* release a ResourceOwner's assets (free all owned resources, but not the\n  owner object itself)\n\n* delete a ResourceOwner (including child owner objects); all resources\n  must have been released beforehand\n\nLocks are handled specially because in non-error situations a lock should\nbe held until end of transaction, even if it was originally taken by a\nsubtransaction or portal.  Therefore, the \"release\" operation on a child\nResourceOwner transfers lock ownership to the parent instead of actually\nreleasing the lock, if isCommit is true.\n\nWhenever we are inside a transaction, the global variable\nCurrentResourceOwner shows which resource owner should be assigned\nownership of acquired resources.  Note however that CurrentResourceOwner\nis NULL when not inside any transaction (or when inside a failed\ntransaction).  In this case it is not valid to acquire query-lifespan\nresources.\n\nWhen unpinning a buffer or releasing a lock or cache reference,\nCurrentResourceOwner must point to the same resource owner that was current\nwhen the buffer, lock, or cache reference was acquired.  It would be possible\nto relax this restriction given additional bookkeeping effort, but at present\nthere seems no need.\n\nAdding a new resource type\n--------------------------\n\nResourceOwner can track ownership of many different kinds of resources.  In\ncore PostgreSQL it is used for buffer pins, lmgr locks, and catalog cache\nreferences, to name a few examples.\n\nTo add a new kind of resource, define a ResourceOwnerDesc to describe it.\nFor example:\n\nstatic const ResourceOwnerDesc myresource_desc = {\n\t.name = \"My fancy resource\",\n\t.release_phase = RESOURCE_RELEASE_AFTER_LOCKS,\n\t.release_priority = RELEASE_PRIO_FIRST,\n\t.ReleaseResource = ReleaseMyResource,\n\t.DebugPrint = PrintMyResource\n};\n\nResourceOwnerRemember() and ResourceOwnerForget() functions take a pointer\nto that struct, along with a Datum to represent the resource.  The meaning\nof the Datum depends on the resource type.  Most resource types use it to\nstore a pointer to some struct, but it can also be a file descriptor or\nlibrary handle, for example.\n\nThe ReleaseResource callback is called when a resource owner is released or\ndeleted.  It should release any resources (e.g. close files, free memory)\nassociated with the resource.  Because the callback is called during\ntransaction abort, it must perform only low-level cleanup with no user\nvisible effects.  The callback should not perform operations that could\nfail, like allocate memory.\n\nThe optional DebugPrint callback is used in the warning at transaction\ncommit, if any resources are leaked.  If not specified, a generic\nimplementation that prints the resource name and the resource as a pointer\nis used.\n\nThere is another API for other modules to get control during ResourceOwner\nrelease, so that they can scan their own data structures to find the objects\nthat need to be deleted.  See RegisterResourceReleaseCallback function.\nThis used to be the only way for extensions to use the resource owner\nmechanism with new kinds of objects; nowadays it is easier to define a custom\nResourceOwnerDesc struct.\n\n\nReleasing\n---------\n\nReleasing the resources of a ResourceOwner happens in three phases:\n\n1. \"Before-locks\" resources\n\n2. Locks\n\n3. \"After-locks\" resources\n\nEach resource type specifies whether it needs to be released before or after\nlocks.  Each resource type also has a priority, which determines the order\nthat the resources are released in.  Note that the phases are performed fully\nfor the whole tree of resource owners, before moving to the next phase, but\nthe priority within each phase only determines the order within that\nResourceOwner.  Child resource owners are always handled before the parent,\nwithin each phase.\n\nFor example, imagine that you have two ResourceOwners, parent and child,\nas follows:\n\nParent\n  parent resource BEFORE_LOCKS priority 1\n  parent resource BEFORE_LOCKS priority 2\n  parent resource AFTER_LOCKS priority 10001\n  parent resource AFTER_LOCKS priority 10002\n  Child\n    child resource BEFORE_LOCKS priority 1\n    child resource BEFORE_LOCKS priority 2\n    child resource AFTER_LOCKS priority 10001\n    child resource AFTER_LOCKS priority 10002\n\nThese resources would be released in the following order:\n\nchild resource BEFORE_LOCKS priority 1\nchild resource BEFORE_LOCKS priority 2\nparent resource BEFORE_LOCKS priority 1\nparent resource BEFORE_LOCKS priority 2\n(locks)\nchild resource AFTER_LOCKS priority 10001\nchild resource AFTER_LOCKS priority 10002\nparent resource AFTER_LOCKS priority 10001\nparent resource AFTER_LOCKS priority 10002\n\nTo release all the resources, you need to call ResourceOwnerRelease() three\ntimes, once for each phase. You may perform additional tasks between the\nphases, but after the first call to ResourceOwnerRelease(), you cannot use\nthe ResourceOwner to remember any more resources. You also cannot call\nResourceOwnerForget on the resource owner to release any previously\nremembered resources \"in retail\", after you have started the release process.\n\nNormally, you are expected to call ResourceOwnerForget on every resource so\nthat at commit, the ResourceOwner is empty (locks are an exception). If there\nare any resources still held at commit, ResourceOwnerRelease will print a\nWARNING on each such resource. At abort, however, we truly rely on the\nResourceOwner mechanism and it is normal that there are resources to be\nreleased.","count":5},{"name":"subsystem-desc","value":"src/bin/pg_amcheck/README\n\npg_amcheck is a command-line tool for running the amcheck extension.\n\nRunning the regression tests\n============================\n\nNOTE: You must have given the --enable-tap-tests argument to configure.\nAlso, to use \"make installcheck\", you must have built and installed\ncontrib/amcheck and contrib/pageinspect in addition to the core code.\n\nRun\n    make check\nor\n    make installcheck\nYou can use \"make installcheck\" if you previously did \"make install\".\nIn that case, the code in the installation tree is tested.  With\n\"make check\", a temporary installation tree is built from the current\nsources and then tested.\n\nSee src/test/perl/README for more info about running these tests.","count":5},{"name":"subsystem-desc","value":"src/tools/ifaddrs/README\n\ntest_ifaddrs\n============\n\nThis program prints the addresses and netmasks of all the IPv4 and IPv6\ninterfaces on the local machine.  It is useful for testing that this\nfunctionality works on various platforms.  If \"samehost\" and \"samenet\"\nin pg_hba.conf don't seem to work right, run this program to see what\nis happening.\n\nUsage:\ttest_ifaddrs","count":5},{"name":"subsystem-name","value":"ifaddrs","count":5},{"name":"subsystem-name","value":"pg_amcheck","count":5},{"name":"subsystem-name","value":"resowner","count":5},{"name":"subsystem-path","value":"backend/utils/resowner/readme","count":5},{"name":"subsystem-path","value":"bin/pg_amcheck/readme","count":5},{"name":"subsystem-path","value":"tools/ifaddrs/readme","count":5},{"name":"Feature","value":"Column level permissions","count":4},{"name":"Feature","value":"GROUPING SETS, CUBE and ROLLUP support","count":4},{"name":"Feature","value":"KNN support for CUBE","count":4},{"name":"Feature","value":"Kerberos credential delegation","count":4},{"name":"Feature","value":"Multiranges","count":4},{"name":"Feature","value":"Multirow VALUES","count":4},{"name":"Feature","value":"Parallelized CREATE INDEX for B-tree indexes","count":4},{"name":"Feature","value":"Recursive Queries","count":4},{"name":"Feature","value":"Support using the client's OS trusted CA.","count":4},{"name":"Feature","value":"pg_receivewal (formerly pg_receivexlog)","count":4},{"name":"api-caller-count","value":"1003","count":4},{"name":"api-caller-count","value":"10209","count":4},{"name":"api-caller-count","value":"1027","count":4},{"name":"api-caller-count","value":"103","count":4},{"name":"api-caller-count","value":"10468","count":4},{"name":"api-caller-count","value":"10475","count":4},{"name":"api-caller-count","value":"1054","count":4},{"name":"api-caller-count","value":"107","count":4},{"name":"api-caller-count","value":"1077","count":4},{"name":"api-caller-count","value":"109","count":4},{"name":"api-caller-count","value":"1130","count":4},{"name":"api-caller-count","value":"1132","count":4},{"name":"api-caller-count","value":"11824","count":4},{"name":"api-caller-count","value":"1216","count":4},{"name":"api-caller-count","value":"124","count":4},{"name":"api-caller-count","value":"1264","count":4},{"name":"api-caller-count","value":"127","count":4},{"name":"api-caller-count","value":"128","count":4},{"name":"api-caller-count","value":"133","count":4},{"name":"api-caller-count","value":"134","count":4},{"name":"api-caller-count","value":"1342","count":4},{"name":"api-caller-count","value":"1393","count":4},{"name":"api-caller-count","value":"13976","count":4},{"name":"api-caller-count","value":"140","count":4},{"name":"api-caller-count","value":"14149","count":4},{"name":"api-caller-count","value":"143","count":4},{"name":"api-caller-count","value":"1434","count":4},{"name":"api-caller-count","value":"144","count":4},{"name":"api-caller-count","value":"14605","count":4},{"name":"api-caller-count","value":"14674","count":4},{"name":"api-caller-count","value":"15054","count":4},{"name":"api-caller-count","value":"1523","count":4},{"name":"api-caller-count","value":"15494","count":4},{"name":"api-caller-count","value":"155","count":4},{"name":"api-caller-count","value":"15711","count":4},{"name":"api-caller-count","value":"163","count":4},{"name":"api-caller-count","value":"163310","count":4},{"name":"api-caller-count","value":"16430","count":4},{"name":"api-caller-count","value":"16604","count":4},{"name":"api-caller-count","value":"168","count":4},{"name":"api-caller-count","value":"170","count":4},{"name":"api-caller-count","value":"171","count":4},{"name":"api-caller-count","value":"172","count":4},{"name":"api-caller-count","value":"175","count":4},{"name":"api-caller-count","value":"178","count":4},{"name":"api-caller-count","value":"179","count":4},{"name":"api-caller-count","value":"184","count":4},{"name":"api-caller-count","value":"185","count":4},{"name":"api-caller-count","value":"187","count":4},{"name":"api-caller-count","value":"193","count":4},{"name":"api-caller-count","value":"194987","count":4},{"name":"api-caller-count","value":"204","count":4},{"name":"api-caller-count","value":"205717","count":4},{"name":"api-caller-count","value":"206","count":4},{"name":"api-caller-count","value":"2101","count":4},{"name":"api-caller-count","value":"2146","count":4},{"name":"api-caller-count","value":"2164","count":4},{"name":"api-caller-count","value":"217","count":4},{"name":"api-caller-count","value":"21734","count":4},{"name":"api-caller-count","value":"225","count":4},{"name":"api-caller-count","value":"231","count":4},{"name":"api-caller-count","value":"238","count":4},{"name":"api-caller-count","value":"254","count":4},{"name":"api-caller-count","value":"256","count":4},{"name":"api-caller-count","value":"258","count":4},{"name":"api-caller-count","value":"259","count":4},{"name":"api-caller-count","value":"260","count":4},{"name":"api-caller-count","value":"265","count":4},{"name":"api-caller-count","value":"2669","count":4},{"name":"api-caller-count","value":"269","count":4},{"name":"api-caller-count","value":"272","count":4},{"name":"api-caller-count","value":"273","count":4},{"name":"api-caller-count","value":"278","count":4},{"name":"api-caller-count","value":"280","count":4},{"name":"api-caller-count","value":"281","count":4},{"name":"api-caller-count","value":"2829","count":4},{"name":"api-caller-count","value":"287","count":4},{"name":"api-caller-count","value":"2936","count":4},{"name":"api-caller-count","value":"300","count":4},{"name":"api-caller-count","value":"302","count":4},{"name":"api-caller-count","value":"311","count":4},{"name":"api-caller-count","value":"313","count":4},{"name":"api-caller-count","value":"31514","count":4},{"name":"api-caller-count","value":"326","count":4},{"name":"api-caller-count","value":"330","count":4},{"name":"api-caller-count","value":"331","count":4},{"name":"api-caller-count","value":"3359","count":4},{"name":"api-caller-count","value":"349","count":4},{"name":"api-caller-count","value":"35085","count":4},{"name":"api-caller-count","value":"365","count":4},{"name":"api-caller-count","value":"36543","count":4},{"name":"api-caller-count","value":"383","count":4},{"name":"api-caller-count","value":"3852","count":4},{"name":"api-caller-count","value":"397","count":4},{"name":"api-caller-count","value":"404","count":4},{"name":"api-caller-count","value":"417","count":4},{"name":"api-caller-count","value":"441","count":4},{"name":"api-caller-count","value":"445","count":4},{"name":"api-caller-count","value":"44676","count":4},{"name":"api-caller-count","value":"456","count":4},{"name":"api-caller-count","value":"462","count":4},{"name":"api-caller-count","value":"473","count":4},{"name":"api-caller-count","value":"4876","count":4},{"name":"api-caller-count","value":"490","count":4},{"name":"api-caller-count","value":"497","count":4},{"name":"api-caller-count","value":"518","count":4},{"name":"api-caller-count","value":"564","count":4},{"name":"api-caller-count","value":"570","count":4},{"name":"api-caller-count","value":"5777","count":4},{"name":"api-caller-count","value":"580","count":4},{"name":"api-caller-count","value":"5883","count":4},{"name":"api-caller-count","value":"598","count":4},{"name":"api-caller-count","value":"643","count":4},{"name":"api-caller-count","value":"64401","count":4},{"name":"api-caller-count","value":"646","count":4},{"name":"api-caller-count","value":"650","count":4},{"name":"api-caller-count","value":"662","count":4},{"name":"api-caller-count","value":"692","count":4},{"name":"api-caller-count","value":"7365","count":4},{"name":"api-caller-count","value":"757","count":4},{"name":"api-caller-count","value":"799","count":4},{"name":"api-caller-count","value":"819","count":4},{"name":"api-caller-count","value":"821","count":4},{"name":"api-caller-count","value":"8529","count":4},{"name":"api-caller-count","value":"871","count":4},{"name":"api-caller-count","value":"91","count":4},{"name":"api-caller-count","value":"94","count":4},{"name":"api-caller-count","value":"947","count":4},{"name":"api-typical-usage","value":"Often called from: ATExecAlterColumnType","count":4},{"name":"api-typical-usage","value":"Often called from: ATExecAlterConstrRecurse","count":4},{"name":"api-typical-usage","value":"Often called from: ATExecChangeOwner","count":4},{"name":"api-typical-usage","value":"Often called from: ATExecDropConstraint","count":4},{"name":"api-typical-usage","value":"Often called from: ATExecValidateConstraint","count":4},{"name":"api-typical-usage","value":"Often called from: ATPostAlterTypeCleanup","count":4},{"name":"api-typical-usage","value":"Often called from: ATPostAlterTypeParse","count":4},{"name":"api-typical-usage","value":"Often called from: ATPrepAlterColumnType","count":4},{"name":"api-typical-usage","value":"Often called from: AbortBufferIO","count":4},{"name":"api-typical-usage","value":"Often called from: AcquirePlannerLocks","count":4},{"name":"api-typical-usage","value":"Often called from: AddStmtToCache","count":4},{"name":"api-typical-usage","value":"Often called from: AddWALInfoToBackupManifest","count":4},{"name":"api-typical-usage","value":"Often called from: AdjustTimeForTypmod","count":4},{"name":"api-typical-usage","value":"Often called from: AdjustTimestampForTypmod","count":4},{"name":"api-typical-usage","value":"Often called from: AdvanceXLInsertBuffer","count":4},{"name":"api-typical-usage","value":"Often called from: AfterTriggerFreeQuery","count":4},{"name":"api-typical-usage","value":"Often called from: AfterTriggerPendingOnRel","count":4},{"name":"api-typical-usage","value":"Often called from: AlignedAllocRealloc","count":4},{"name":"api-typical-usage","value":"Often called from: AllocateRelationDesc","count":4},{"name":"api-typical-usage","value":"Often called from: AlterDomainDropConstraint","count":4},{"name":"api-typical-usage","value":"Often called from: AlterRelationNamespaceInternal","count":4},{"name":"api-typical-usage","value":"Often called from: AlterRoleSet","count":4},{"name":"api-typical-usage","value":"Often called from: AlterTableNamespace","count":4},{"name":"api-typical-usage","value":"Often called from: AlterTypeNamespace","count":4},{"name":"api-typical-usage","value":"Often called from: AppendIncrementalManifestData","count":4},{"name":"api-typical-usage","value":"Often called from: ApplyLauncherGetWorkerStartTime","count":4},{"name":"api-typical-usage","value":"Often called from: ArrayCastAndSet","count":4},{"name":"api-typical-usage","value":"Often called from: AtAbort_Portals","count":4},{"name":"api-typical-usage","value":"Often called from: AtEOXact_Snapshot","count":4},{"name":"api-typical-usage","value":"Often called from: AtPrepare_PredicateLocks","count":4},{"name":"api-typical-usage","value":"Often called from: AttachPartitionEnsureIndexes","count":4},{"name":"api-typical-usage","value":"Often called from: AttachSession","count":4},{"name":"api-typical-usage","value":"Often called from: AutoVacLauncherMain","count":4},{"name":"api-typical-usage","value":"Often called from: BackendStartup","count":4},{"name":"api-typical-usage","value":"Often called from: BackgroundWorkerStateChange","count":4},{"name":"api-typical-usage","value":"Often called from: BeginCopyTo","count":4},{"name":"api-typical-usage","value":"Often called from: BipartiteMatch","count":4},{"name":"api-typical-usage","value":"Often called from: BitmapHeapNext","count":4},{"name":"api-typical-usage","value":"Often called from: BlockRefTableEntryGetBlocks","count":4},{"name":"api-typical-usage","value":"Often called from: BlockRefTableReaderNextRelation","count":4},{"name":"api-typical-usage","value":"Often called from: BootStrapMultiXact","count":4},{"name":"api-typical-usage","value":"Often called from: BootStrapXLOG","count":4},{"name":"api-typical-usage","value":"Often called from: BootstrapModeMain","count":4},{"name":"api-typical-usage","value":"Often called from: BufFileSeek","count":4},{"name":"api-typical-usage","value":"Often called from: BufferSync","count":4},{"name":"api-typical-usage","value":"Often called from: BuildIndexInfo","count":4},{"name":"api-typical-usage","value":"Often called from: BuildParamLogString","count":4},{"name":"api-typical-usage","value":"Often called from: BumpAlloc","count":4},{"name":"api-typical-usage","value":"Often called from: BumpAllocLarge","count":4},{"name":"api-typical-usage","value":"Often called from: BumpContextCreate","count":4},{"name":"api-typical-usage","value":"Often called from: CacheInvalidateRelcache","count":4},{"name":"api-typical-usage","value":"Often called from: CalculateShmemSize","count":4},{"name":"api-typical-usage","value":"Often called from: CatalogOpenIndexes","count":4},{"name":"api-typical-usage","value":"Often called from: CatalogTuplesMultiInsertWithInfo","count":4},{"name":"api-typical-usage","value":"Often called from: CheckAttributeType","count":4},{"name":"api-typical-usage","value":"Often called from: CheckBufferIsPinnedOnce","count":4},{"name":"api-typical-usage","value":"Often called from: CheckCachedPlan","count":4},{"name":"api-typical-usage","value":"Often called from: CheckCmdReplicaIdentity","count":4},{"name":"api-typical-usage","value":"Often called from: CheckForSerializableConflictIn","count":4},{"name":"api-typical-usage","value":"Often called from: CheckForSerializableConflictOut","count":4},{"name":"api-typical-usage","value":"Often called from: CheckMyDatabase","count":4},{"name":"api-typical-usage","value":"Often called from: CheckPointReplicationOrigin","count":4},{"name":"api-typical-usage","value":"Often called from: CheckRADIUSAuth","count":4},{"name":"api-typical-usage","value":"Often called from: CheckRequiredParameterValues","count":4},{"name":"api-typical-usage","value":"Often called from: CheckServerVersionForStreaming","count":4},{"name":"api-typical-usage","value":"Often called from: CheckTableForSerializableConflictIn","count":4},{"name":"api-typical-usage","value":"Often called from: ChooseIndexName","count":4},{"name":"api-typical-usage","value":"Often called from: CleanupBackend","count":4},{"name":"api-typical-usage","value":"Often called from: CloneFkReferenced","count":4},{"name":"api-typical-usage","value":"Often called from: CloneFkReferencing","count":4},{"name":"api-typical-usage","value":"Often called from: ClosePipeStream","count":4},{"name":"api-typical-usage","value":"Often called from: CommentObject","count":4},{"name":"api-typical-usage","value":"Often called from: ConvertTimeZoneAbbrevs","count":4},{"name":"api-typical-usage","value":"Often called from: CopyAttributeOutCSV","count":4},{"name":"api-typical-usage","value":"Often called from: CopyFrom","count":4},{"name":"api-typical-usage","value":"Often called from: CopyMultiInsertBufferInit","count":4},{"name":"api-typical-usage","value":"Often called from: CopyMultiInsertInfoFlush","count":4},{"name":"api-typical-usage","value":"Often called from: CopyReadLineText","count":4},{"name":"api-typical-usage","value":"Often called from: CopySendEndOfRow","count":4},{"name":"api-typical-usage","value":"Often called from: CreateAuxProcessResourceOwner","count":4},{"name":"api-typical-usage","value":"Often called from: CreateDatabaseUsingWalLog","count":4},{"name":"api-typical-usage","value":"Often called from: CreateLockFile","count":4},{"name":"api-typical-usage","value":"Often called from: CreatePortal","count":4},{"name":"api-typical-usage","value":"Often called from: CreateSharedProcArray","count":4},{"name":"api-typical-usage","value":"Often called from: DCH_cache_getnew","count":4},{"name":"api-typical-usage","value":"Often called from: DecodeInsert","count":4},{"name":"api-typical-usage","value":"Often called from: DecodeNumberField","count":4},{"name":"api-typical-usage","value":"Often called from: DefineCollation","count":4},{"name":"api-typical-usage","value":"Often called from: DefineOperator","count":4},{"name":"api-typical-usage","value":"Often called from: DefineTSParser","count":4},{"name":"api-typical-usage","value":"Often called from: DeleteAllExportedSnapshotFiles","count":4},{"name":"api-typical-usage","value":"Often called from: DescribeQuery","count":4},{"name":"api-typical-usage","value":"Often called from: DoCopy","count":4},{"name":"api-typical-usage","value":"Often called from: DoPortalRunFetch","count":4},{"name":"api-typical-usage","value":"Often called from: DropClonedTriggersFromPartition","count":4},{"name":"api-typical-usage","value":"Often called from: DropPreparedStatement","count":4},{"name":"api-typical-usage","value":"Often called from: ECPGset_desc","count":4},{"name":"api-typical-usage","value":"Often called from: ER_get_flat_size","count":4},{"name":"api-typical-usage","value":"Often called from: EmitProcSignalBarrier","count":4},{"name":"api-typical-usage","value":"Often called from: EnableLockPagesPrivilege","count":4},{"name":"api-typical-usage","value":"Often called from: EndTransactionBlock","count":4},{"name":"api-typical-usage","value":"Often called from: EstablishVariableSpace","count":4},{"name":"api-typical-usage","value":"Often called from: EstimateUncommittedEnumsSpace","count":4},{"name":"api-typical-usage","value":"Often called from: EvalPlanQualFetchRowMark","count":4},{"name":"api-typical-usage","value":"Often called from: EvalPlanQualSetPlan","count":4},{"name":"api-typical-usage","value":"Often called from: EventTriggerSQLDropAddObject","count":4},{"name":"api-typical-usage","value":"Often called from: ExecARInsertTriggers","count":4},{"name":"api-typical-usage","value":"Often called from: ExecAlterExtensionContentsStmt","count":4},{"name":"api-typical-usage","value":"Often called from: ExecAppendAsyncEventWait","count":4},{"name":"api-typical-usage","value":"Often called from: ExecBRUpdateTriggersNew","count":4},{"name":"api-typical-usage","value":"Often called from: ExecBSUpdateTriggers","count":4},{"name":"api-typical-usage","value":"Often called from: ExecCheckOneRelPerms","count":4},{"name":"api-typical-usage","value":"Often called from: ExecCheckPermissionsModified","count":4},{"name":"api-typical-usage","value":"Often called from: ExecCleanupTupleRouting","count":4},{"name":"api-typical-usage","value":"Often called from: ExecComputeSlotInfo","count":4},{"name":"api-typical-usage","value":"Often called from: ExecCrossPartitionUpdate","count":4},{"name":"api-typical-usage","value":"Often called from: ExecEvalSQLValueFunction","count":4},{"name":"api-typical-usage","value":"Often called from: ExecEvalWholeRowVar","count":4},{"name":"api-typical-usage","value":"Often called from: ExecFetchSlotHeapTupleDatum","count":4},{"name":"api-typical-usage","value":"Often called from: ExecFindPartition","count":4},{"name":"api-typical-usage","value":"Often called from: ExecGatherMerge","count":4},{"name":"api-typical-usage","value":"Often called from: ExecGetAncestorResultRels","count":4},{"name":"api-typical-usage","value":"Often called from: ExecGrantStmt_oids","count":4},{"name":"api-typical-usage","value":"Often called from: ExecHashGetSkewBucket","count":4},{"name":"api-typical-usage","value":"Often called from: ExecHashJoinInitializeDSM","count":4},{"name":"api-typical-usage","value":"Often called from: ExecHashJoinNewBatch","count":4},{"name":"api-typical-usage","value":"Often called from: ExecHashSubPlan","count":4},{"name":"api-typical-usage","value":"Often called from: ExecHashTableResetMatchFlags","count":4},{"name":"api-typical-usage","value":"Often called from: ExecIRInsertTriggers","count":4},{"name":"api-typical-usage","value":"Often called from: ExecIRUpdateTriggers","count":4},{"name":"api-typical-usage","value":"Often called from: ExecIndexScan","count":4},{"name":"api-typical-usage","value":"Often called from: ExecInitBitmapHeapScan","count":4},{"name":"api-typical-usage","value":"Often called from: ExecInitCustomScan","count":4},{"name":"api-typical-usage","value":"Often called from: ExecInitExtraTupleSlot","count":4},{"name":"api-typical-usage","value":"Often called from: ExecInitIndexOnlyScan","count":4},{"name":"api-typical-usage","value":"Often called from: ExecInitLockRows","count":4},{"name":"api-typical-usage","value":"Often called from: ExecInitMergeJoin","count":4},{"name":"api-typical-usage","value":"Often called from: ExecInitModifyTable","count":4},{"name":"api-typical-usage","value":"Often called from: ExecInitTableFuncScan","count":4},{"name":"api-typical-usage","value":"Often called from: ExecInitUpdateProjection","count":4},{"name":"api-typical-usage","value":"Often called from: ExecOnConflictUpdate","count":4},{"name":"api-typical-usage","value":"Often called from: ExecParallelGetQueryDesc","count":4},{"name":"api-typical-usage","value":"Often called from: ExecParallelHashJoinOuterGetTuple","count":4},{"name":"api-typical-usage","value":"Often called from: ExecParallelHashJoinSetUpBatches","count":4},{"name":"api-typical-usage","value":"Often called from: ExecParallelHashRepartitionFirst","count":4},{"name":"api-typical-usage","value":"Often called from: ExecParallelHashTupleAlloc","count":4},{"name":"api-typical-usage","value":"Often called from: ExecPrepareCheck","count":4},{"name":"api-typical-usage","value":"Often called from: ExecPrepareTuplestoreResult","count":4},{"name":"api-typical-usage","value":"Often called from: ExecPushExprSetupSteps","count":4},{"name":"api-typical-usage","value":"Often called from: ExecReScan","count":4},{"name":"api-typical-usage","value":"Often called from: ExecReScanMergeJoin","count":4},{"name":"api-typical-usage","value":"Often called from: ExecReScanValuesScan","count":4},{"name":"api-typical-usage","value":"Often called from: ExecScanSubPlan","count":4},{"name":"api-typical-usage","value":"Often called from: ExecSimpleRelationInsert","count":4},{"name":"api-typical-usage","value":"Often called from: ExecSort","count":4},{"name":"api-typical-usage","value":"Often called from: ExecStoreAllNullTuple","count":4},{"name":"api-typical-usage","value":"Often called from: ExecUpdateEpilogue","count":4},{"name":"api-typical-usage","value":"Often called from: Exec_ListenPreCommit","count":4},{"name":"api-typical-usage","value":"Often called from: ExecuteSqlCommandBuf","count":4},{"name":"api-typical-usage","value":"Often called from: ExecutorStart","count":4},{"name":"api-typical-usage","value":"Often called from: ExpandConstraints","count":4},{"name":"api-typical-usage","value":"Often called from: ExplainDummyGroup","count":4},{"name":"api-typical-usage","value":"Often called from: ExplainOneUtility","count":4},{"name":"api-typical-usage","value":"Often called from: ExplainOpenSetAsideGroup","count":4},{"name":"api-typical-usage","value":"Often called from: ExplainPrintSerialize","count":4},{"name":"api-typical-usage","value":"Often called from: ExplainPrintSettings","count":4},{"name":"api-typical-usage","value":"Often called from: ExplainPropertyBool","count":4},{"name":"api-typical-usage","value":"Often called from: ExtendBufferedRelTo","count":4},{"name":"api-typical-usage","value":"Often called from: FPgt","count":4},{"name":"api-typical-usage","value":"Often called from: FastPathGetRelationLockEntry","count":4},{"name":"api-typical-usage","value":"Often called from: FigureColnameInternal","count":4},{"name":"api-typical-usage","value":"Often called from: FileWriteV","count":4},{"name":"api-typical-usage","value":"Often called from: FlushDatabaseBuffers","count":4},{"name":"api-typical-usage","value":"Often called from: FlushOneBuffer","count":4},{"name":"api-typical-usage","value":"Often called from: ForgetBackgroundWorker","count":4},{"name":"api-typical-usage","value":"Often called from: FreePageBtreeConsolidate","count":4},{"name":"api-typical-usage","value":"Often called from: FreePageManagerDumpBtree","count":4},{"name":"api-typical-usage","value":"Often called from: FreePagePopSpanLeader","count":4},{"name":"api-typical-usage","value":"Often called from: FreePagePushSpanLeader","count":4},{"name":"api-typical-usage","value":"Often called from: FreezeMultiXactId","count":4},{"name":"api-typical-usage","value":"Often called from: FullTransactionIdFromAllowableAt","count":4},{"name":"api-typical-usage","value":"Often called from: FunctionCall4Coll","count":4},{"name":"api-typical-usage","value":"Often called from: FunctionNext","count":4},{"name":"api-typical-usage","value":"Often called from: GetAllTablesPublicationRelations","count":4},{"name":"api-typical-usage","value":"Often called from: GetCommandLogLevel","count":4},{"name":"api-typical-usage","value":"Often called from: GetConfigOptionValues","count":4},{"name":"api-typical-usage","value":"Often called from: GetCopyDataEnd","count":4},{"name":"api-typical-usage","value":"Often called from: GetCurrentDateTime","count":4},{"name":"api-typical-usage","value":"Often called from: GetNewTransactionId","count":4},{"name":"api-typical-usage","value":"Often called from: GetOldestUnsummarizedLSN","count":4},{"name":"api-typical-usage","value":"Often called from: GetPGVariable","count":4},{"name":"api-typical-usage","value":"Often called from: GetPrivilegesToDelete","count":4},{"name":"api-typical-usage","value":"Often called from: GetPubPartitionOptionRelations","count":4},{"name":"api-typical-usage","value":"Often called from: GetResultRTEPermissionInfo","count":4},{"name":"api-typical-usage","value":"Often called from: GetSafeSnapshot","count":4},{"name":"api-typical-usage","value":"Often called from: GetSerializableTransactionSnapshotInt","count":4},{"name":"api-typical-usage","value":"Often called from: GetSessionDsmHandle","count":4},{"name":"api-typical-usage","value":"Often called from: GetTransactionSnapshot","count":4},{"name":"api-typical-usage","value":"Often called from: GetUserMapping","count":4},{"name":"api-typical-usage","value":"Often called from: GetVictimBuffer","count":4},{"name":"api-typical-usage","value":"Often called from: GinDataLeafPageGetItems","count":4},{"name":"api-typical-usage","value":"Often called from: GrantRole","count":4},{"name":"api-typical-usage","value":"Often called from: HandleAutoVacLauncherInterrupts","count":4},{"name":"api-typical-usage","value":"Often called from: HandleCopyResult","count":4},{"name":"api-typical-usage","value":"Often called from: HandlePgArchInterrupts","count":4},{"name":"api-typical-usage","value":"Often called from: HeapTupleGetDatum","count":4},{"name":"api-typical-usage","value":"Often called from: HeapTupleSatisfiesDirty","count":4},{"name":"api-typical-usage","value":"Often called from: HeapTupleSatisfiesSelf","count":4},{"name":"api-typical-usage","value":"Often called from: IndexOnlyNext","count":4},{"name":"api-typical-usage","value":"Often called from: InheritStdHandles","count":4},{"name":"api-typical-usage","value":"Often called from: InitArchiveFmt_Tar","count":4},{"name":"api-typical-usage","value":"Often called from: InitCatCachePhase2","count":4},{"name":"api-typical-usage","value":"Often called from: InitCatalogCache","count":4},{"name":"api-typical-usage","value":"Often called from: InitIndexAmRoutine","count":4},{"name":"api-typical-usage","value":"Often called from: InitPlanCache","count":4},{"name":"api-typical-usage","value":"Often called from: InitPostmasterDeathWatchHandle","count":4},{"name":"api-typical-usage","value":"Often called from: InitializeBackupManifest","count":4},{"name":"api-typical-usage","value":"Often called from: InitializeLogRepWorker","count":4},{"name":"api-typical-usage","value":"Often called from: InitializeRelfilenumberMap","count":4},{"name":"api-typical-usage","value":"Often called from: Insert","count":4},{"name":"api-typical-usage","value":"Often called from: InsertRule","count":4},{"name":"api-typical-usage","value":"Often called from: InstallXLogFileSegment","count":4},{"name":"api-typical-usage","value":"Often called from: InstrEndParallelQuery","count":4},{"name":"api-typical-usage","value":"Often called from: InvalidateBuffer","count":4},{"name":"api-typical-usage","value":"Often called from: IpcSemaphoreInitialize","count":4},{"name":"api-typical-usage","value":"Often called from: IsSubxactTopXidLogPending","count":4},{"name":"api-typical-usage","value":"Often called from: IssuePendingWritebacks","count":4},{"name":"api-typical-usage","value":"Often called from: JsObjectGetField","count":4},{"name":"api-typical-usage","value":"Often called from: JsonItemFromDatum","count":4},{"name":"api-typical-usage","value":"Often called from: JsonPathQuery","count":4},{"name":"api-typical-usage","value":"Often called from: JsonTablePlanJoinNextRow","count":4},{"name":"api-typical-usage","value":"Often called from: JsonbDeepContains","count":4},{"name":"api-typical-usage","value":"Often called from: JsonbToCStringWorker","count":4},{"name":"api-typical-usage","value":"Often called from: JsonbValueAsText","count":4},{"name":"api-typical-usage","value":"Often called from: KillExistingXLOG","count":4},{"name":"api-typical-usage","value":"Often called from: LWLockDequeueSelf","count":4},{"name":"api-typical-usage","value":"Often called from: LWLockQueueSelf","count":4},{"name":"api-typical-usage","value":"Often called from: LWLockWaitListLock","count":4},{"name":"api-typical-usage","value":"Often called from: LocalExecuteInvalidationMessage","count":4},{"name":"api-typical-usage","value":"Often called from: LocalToUtf","count":4},{"name":"api-typical-usage","value":"Often called from: LockBuffer","count":4},{"name":"api-typical-usage","value":"Often called from: LockRefindAndRelease","count":4},{"name":"api-typical-usage","value":"Often called from: LockReleaseAll","count":4},{"name":"api-typical-usage","value":"Often called from: LockSchemaList","count":4},{"name":"api-typical-usage","value":"Often called from: LockTuple","count":4},{"name":"api-typical-usage","value":"Often called from: LogCheckpointEnd","count":4},{"name":"api-typical-usage","value":"Often called from: LogRecoveryConflict","count":4},{"name":"api-typical-usage","value":"Often called from: LogicalIncreaseRestartDecodingForSlot","count":4},{"name":"api-typical-usage","value":"Often called from: LogicalRepApplyLoop","count":4},{"name":"api-typical-usage","value":"Often called from: LogicalTapeImport","count":4},{"name":"api-typical-usage","value":"Often called from: LookupCollation","count":4},{"name":"api-typical-usage","value":"Often called from: LookupFuncWithArgs","count":4},{"name":"api-typical-usage","value":"Often called from: MakeNewFileSetSegment","count":4},{"name":"api-typical-usage","value":"Often called from: MakeTransitionCaptureState","count":4},{"name":"api-typical-usage","value":"Often called from: MarkBufferDirtyHint","count":4},{"name":"api-typical-usage","value":"Often called from: MarkGUCPrefixReserved","count":4},{"name":"api-typical-usage","value":"Often called from: MaybeRemoveOldWalSummaries","count":4},{"name":"api-typical-usage","value":"Often called from: MemoryContextReset","count":4},{"name":"api-typical-usage","value":"Often called from: MergeAffix","count":4},{"name":"api-typical-usage","value":"Often called from: MergeAttributesIntoExisting","count":4},{"name":"api-typical-usage","value":"Often called from: MultiXactIdIsRunning","count":4},{"name":"api-typical-usage","value":"Often called from: MultiXactMemberFreezeThreshold","count":4},{"name":"api-typical-usage","value":"Often called from: MultiXactMemberPagePrecedes","count":4},{"name":"api-typical-usage","value":"Often called from: MultiXactOffsetPagePrecedes","count":4},{"name":"api-typical-usage","value":"Often called from: MultiXactShmemInit","count":4},{"name":"api-typical-usage","value":"Often called from: MultiXactShmemSize","count":4},{"name":"api-typical-usage","value":"Often called from: NISortAffixes","count":4},{"name":"api-typical-usage","value":"Often called from: NUM_cache_getnew","count":4},{"name":"api-typical-usage","value":"Often called from: NUM_numpart_to_char","count":4},{"name":"api-typical-usage","value":"Often called from: OpFamilyCacheLookup","count":4},{"name":"api-typical-usage","value":"Often called from: OpenTableList","count":4},{"name":"api-typical-usage","value":"Often called from: OperatorUpd","count":4},{"name":"api-typical-usage","value":"Often called from: PGSemaphoreLock","count":4},{"name":"api-typical-usage","value":"Often called from: PGTYPESdate_fmt_asc","count":4},{"name":"api-typical-usage","value":"Often called from: PGTYPESdate_from_asc","count":4},{"name":"api-typical-usage","value":"Often called from: PGTYPESinterval_from_asc","count":4},{"name":"api-typical-usage","value":"Often called from: PGTYPEStimestamp_defmt_asc","count":4},{"name":"api-typical-usage","value":"Often called from: PLy_cursor_fetch","count":4},{"name":"api-typical-usage","value":"Often called from: PLy_exception_set_with_details","count":4},{"name":"api-typical-usage","value":"Often called from: PLy_generate_spi_exceptions","count":4},{"name":"api-typical-usage","value":"Often called from: PLy_get_error_data","count":4},{"name":"api-typical-usage","value":"Often called from: PLy_info","count":4},{"name":"api-typical-usage","value":"Often called from: PLy_input_from_tuple","count":4},{"name":"api-typical-usage","value":"Often called from: PLy_input_setup_func","count":4},{"name":"api-typical-usage","value":"Often called from: PLy_modify_tuple","count":4},{"name":"api-typical-usage","value":"Often called from: PLy_plan_new","count":4},{"name":"api-typical-usage","value":"Often called from: PLy_procedure_create","count":4},{"name":"api-typical-usage","value":"Often called from: PLy_subtransaction_exit","count":4},{"name":"api-typical-usage","value":"Often called from: PQcancelStart","count":4},{"name":"api-typical-usage","value":"Often called from: PQdisplayTuples","count":4},{"name":"api-typical-usage","value":"Often called from: PQfmod","count":4},{"name":"api-typical-usage","value":"Often called from: PQgetCancel","count":4},{"name":"api-typical-usage","value":"Often called from: PQprint","count":4},{"name":"api-typical-usage","value":"Often called from: PQputCopyEnd","count":4},{"name":"api-typical-usage","value":"Often called from: PQreset","count":4},{"name":"api-typical-usage","value":"Often called from: PQsendQueryInternal","count":4},{"name":"api-typical-usage","value":"Often called from: PQsocketPoll","count":4},{"name":"api-typical-usage","value":"Often called from: PageGetTempPageCopySpecial","count":4},{"name":"api-typical-usage","value":"Often called from: PageSetChecksumInplace","count":4},{"name":"api-typical-usage","value":"Often called from: ParallelBackupStart","count":4},{"name":"api-typical-usage","value":"Often called from: ParallelWorkerMain","count":4},{"name":"api-typical-usage","value":"Often called from: ParallelWorkerShutdown","count":4},{"name":"api-typical-usage","value":"Often called from: ParseISO8601Number","count":4},{"name":"api-typical-usage","value":"Often called from: PerformMembersTruncation","count":4},{"name":"api-typical-usage","value":"Often called from: PerformWalRecovery","count":4},{"name":"api-typical-usage","value":"Often called from: PinBuffer","count":4},{"name":"api-typical-usage","value":"Often called from: PinBufferForBlock","count":4},{"name":"api-typical-usage","value":"Often called from: PortalDrop","count":4},{"name":"api-typical-usage","value":"Often called from: PortalRunSelect","count":4},{"name":"api-typical-usage","value":"Often called from: PortalRunUtility","count":4},{"name":"api-typical-usage","value":"Often called from: PostgresSingleUserMain","count":4},{"name":"api-typical-usage","value":"Often called from: PreCommit_CheckForSerializationFailure","count":4},{"name":"api-typical-usage","value":"Often called from: PredicateLockPageSplit","count":4},{"name":"api-typical-usage","value":"Often called from: PredicateLockShmemSize","count":4},{"name":"api-typical-usage","value":"Often called from: PrepareClientEncoding","count":4},{"name":"api-typical-usage","value":"Often called from: PrintTOCSummary","count":4},{"name":"api-typical-usage","value":"Often called from: ProcLockWakeup","count":4},{"name":"api-typical-usage","value":"Often called from: ProcReleaseLocks","count":4},{"name":"api-typical-usage","value":"Often called from: ProcessProcSignalBarrier","count":4},{"name":"api-typical-usage","value":"Often called from: ProcessQuery","count":4},{"name":"api-typical-usage","value":"Often called from: ProcessSyncRequests","count":4},{"name":"api-typical-usage","value":"Often called from: PushActiveSnapshotWithLevel","count":4},{"name":"api-typical-usage","value":"Often called from: QTNodeCompare","count":4},{"name":"api-typical-usage","value":"Often called from: QueryService","count":4},{"name":"api-typical-usage","value":"Often called from: RE_compile_and_cache","count":4},{"name":"api-typical-usage","value":"Often called from: RI_FKey_noaction_upd","count":4},{"name":"api-typical-usage","value":"Often called from: RI_FKey_pk_upd_check_required","count":4},{"name":"api-typical-usage","value":"Often called from: RI_FKey_setdefault_upd","count":4},{"name":"api-typical-usage","value":"Often called from: RS_isRegis","count":4},{"name":"api-typical-usage","value":"Often called from: RangeVarCallbackForDropRelation","count":4},{"name":"api-typical-usage","value":"Often called from: RangeVarGetCreationNamespace","count":4},{"name":"api-typical-usage","value":"Often called from: ReadBufferBI","count":4},{"name":"api-typical-usage","value":"Often called from: ReadHead","count":4},{"name":"api-typical-usage","value":"Often called from: ReadTempFileBlock","count":4},{"name":"api-typical-usage","value":"Often called from: ReadToc","count":4},{"name":"api-typical-usage","value":"Often called from: ReceiveCopyBinaryHeader","count":4},{"name":"api-typical-usage","value":"Often called from: ReceiveXlogStream","count":4},{"name":"api-typical-usage","value":"Often called from: RehashCatCacheLists","count":4},{"name":"api-typical-usage","value":"Often called from: ReindexMultipleTables","count":4},{"name":"api-typical-usage","value":"Often called from: RelationBuildPartitionDesc","count":4},{"name":"api-typical-usage","value":"Often called from: RelationCacheInitializePhase2","count":4},{"name":"api-typical-usage","value":"Often called from: RelationCloseCleanup","count":4},{"name":"api-typical-usage","value":"Often called from: RelationDestroyRelation","count":4},{"name":"api-typical-usage","value":"Often called from: RelationGetFKeyList","count":4},{"name":"api-typical-usage","value":"Often called from: RelationGetPartitionDesc","count":4},{"name":"api-typical-usage","value":"Often called from: RelationMapFinishBootstrap","count":4},{"name":"api-typical-usage","value":"Often called from: RelationReloadNailed","count":4},{"name":"api-typical-usage","value":"Often called from: RemovePgTempRelationFiles","count":4},{"name":"api-typical-usage","value":"Often called from: RemovePublicationSchemaById","count":4},{"name":"api-typical-usage","value":"Often called from: RenameConstraintById","count":4},{"name":"api-typical-usage","value":"Often called from: RenameRole","count":4},{"name":"api-typical-usage","value":"Often called from: ReorderBufferAllocate","count":4},{"name":"api-typical-usage","value":"Often called from: ReorderBufferRestoreChange","count":4},{"name":"api-typical-usage","value":"Often called from: ReorderBufferSerializeChange","count":4},{"name":"api-typical-usage","value":"Often called from: ReorderBufferSerializeTXN","count":4},{"name":"api-typical-usage","value":"Often called from: ReorderBufferSetBaseSnapshot","count":4},{"name":"api-typical-usage","value":"Often called from: ReorderBufferXidHasBaseSnapshot","count":4},{"name":"api-typical-usage","value":"Often called from: ReportGUCOption","count":4},{"name":"api-typical-usage","value":"Often called from: ReportSlotConnectionError","count":4},{"name":"api-typical-usage","value":"Often called from: ReservePrivateRefCountEntry","count":4},{"name":"api-typical-usage","value":"Often called from: ReserveXLogInsertLocation","count":4},{"name":"api-typical-usage","value":"Often called from: ResetCatalogCache","count":4},{"name":"api-typical-usage","value":"Often called from: ResourceOwnerForgetBufferIO","count":4},{"name":"api-typical-usage","value":"Often called from: ResourceOwnerRememberBuffer","count":4},{"name":"api-typical-usage","value":"Often called from: ResourceOwnerRememberLock","count":4},{"name":"api-typical-usage","value":"Often called from: RunIdentifySystem","count":4},{"name":"api-typical-usage","value":"Often called from: SHA256_Last","count":4},{"name":"api-typical-usage","value":"Often called from: SIInsertDataEntries","count":4},{"name":"api-typical-usage","value":"Often called from: SPI_cursor_open","count":4},{"name":"api-typical-usage","value":"Often called from: SPI_prepare_params","count":4},{"name":"api-typical-usage","value":"Often called from: SaveSlotToPath","count":4},{"name":"api-typical-usage","value":"Often called from: ScanECPGKeywordLookup","count":4},{"name":"api-typical-usage","value":"Often called from: ScanSourceDatabasePgClass","count":4},{"name":"api-typical-usage","value":"Often called from: SearchCatCache1","count":4},{"name":"api-typical-usage","value":"Often called from: SearchCatCacheList","count":4},{"name":"api-typical-usage","value":"Often called from: SearchSysCacheLocked1","count":4},{"name":"api-typical-usage","value":"Often called from: SendTimeLineHistory","count":4},{"name":"api-typical-usage","value":"Often called from: SeqNext","count":4},{"name":"api-typical-usage","value":"Often called from: SerialGetMinConflictCommitSeqNo","count":4},{"name":"api-typical-usage","value":"Often called from: SetResultVariables","count":4},{"name":"api-typical-usage","value":"Often called from: SharedRecordTypmodRegistryAttach","count":4},{"name":"api-typical-usage","value":"Often called from: ShowGUCOption","count":4},{"name":"api-typical-usage","value":"Often called from: ShutdownAuxiliaryProcess","count":4},{"name":"api-typical-usage","value":"Often called from: ShutdownWalRecovery","count":4},{"name":"api-typical-usage","value":"Often called from: SimpleLruDoesPhysicalPageExist","count":4},{"name":"api-typical-usage","value":"Often called from: SimpleLruTruncate","count":4},{"name":"api-typical-usage","value":"Often called from: SimpleLruWriteAll","count":4},{"name":"api-typical-usage","value":"Often called from: SlabContextCreate","count":4},{"name":"api-typical-usage","value":"Often called from: SlruInternalWritePage","count":4},{"name":"api-typical-usage","value":"Often called from: SnapBuildFindSnapshot","count":4},{"name":"api-typical-usage","value":"Often called from: SpGistUpdateMetaPage","count":4},{"name":"api-typical-usage","value":"Often called from: SplitGUCList","count":4},{"name":"api-typical-usage","value":"Often called from: StartPrepare","count":4},{"name":"api-typical-usage","value":"Often called from: StartupProcTriggerHandler","count":4},{"name":"api-typical-usage","value":"Often called from: StrictNamesCheck","count":4},{"name":"api-typical-usage","value":"Often called from: SummarizeSmgrRecord","count":4},{"name":"api-typical-usage","value":"Often called from: SummarizeWAL","count":4},{"name":"api-typical-usage","value":"Often called from: SwitchToUntrustedUser","count":4},{"name":"api-typical-usage","value":"Often called from: SyncRepCleanupAtProcExit","count":4},{"name":"api-typical-usage","value":"Often called from: SyncReplicationSlots","count":4},{"name":"api-typical-usage","value":"Often called from: SysLogger_Start","count":4},{"name":"api-typical-usage","value":"Often called from: TS_execute_recurse","count":4},{"name":"api-typical-usage","value":"Often called from: TerminateOtherDBBackends","count":4},{"name":"api-typical-usage","value":"Often called from: TidRangeEval","count":4},{"name":"api-typical-usage","value":"Often called from: TidStoreDestroy","count":4},{"name":"api-typical-usage","value":"Often called from: TransactionIdInArray","count":4},{"name":"api-typical-usage","value":"Often called from: TransactionIdInRecentPast","count":4},{"name":"api-typical-usage","value":"Often called from: TransactionIdSetPageStatus","count":4},{"name":"api-typical-usage","value":"Often called from: TransactionLogFetch","count":4},{"name":"api-typical-usage","value":"Often called from: TransactionTreeSetCommitTsData","count":4},{"name":"api-typical-usage","value":"Often called from: TransformGUCArray","count":4},{"name":"api-typical-usage","value":"Often called from: TransitionTableAddTuple","count":4},{"name":"api-typical-usage","value":"Often called from: TruncateMultiXact","count":4},{"name":"api-typical-usage","value":"Often called from: TupleHashTableHash_internal","count":4},{"name":"api-typical-usage","value":"Often called from: UnlockSharedObject","count":4},{"name":"api-typical-usage","value":"Often called from: UnpinBufferNoOwner","count":4},{"name":"api-typical-usage","value":"Often called from: UpdateIndexRelation","count":4},{"name":"api-typical-usage","value":"Often called from: UtfToLocal","count":4},{"name":"api-typical-usage","value":"Often called from: UtilityContainsQuery","count":4},{"name":"api-typical-usage","value":"Often called from: ValidateJoinEstimator","count":4},{"name":"api-typical-usage","value":"Often called from: ValidateOperatorReference","count":4},{"name":"api-typical-usage","value":"Often called from: WALInsertLockAcquire","count":4},{"name":"api-typical-usage","value":"Often called from: WaitEventCustomShmemSize","count":4},{"name":"api-typical-usage","value":"Often called from: WaitEventExtensionNew","count":4},{"name":"api-typical-usage","value":"Often called from: WaitForBackgroundWorkerStartup","count":4},{"name":"api-typical-usage","value":"Often called from: WaitOnLock","count":4},{"name":"api-typical-usage","value":"Often called from: WalRcvComputeNextWakeup","count":4},{"name":"api-typical-usage","value":"Often called from: WalSndDone","count":4},{"name":"api-typical-usage","value":"Often called from: WalSndLoop","count":4},{"name":"api-typical-usage","value":"Often called from: WalSndShmemInit","count":4},{"name":"api-typical-usage","value":"Often called from: WinRowsArePeers","count":4},{"name":"api-typical-usage","value":"Often called from: WriteBlockRefTable","count":4},{"name":"api-typical-usage","value":"Often called from: WriteEmptyXLOG","count":4},{"name":"api-typical-usage","value":"Often called from: WriteHead","count":4},{"name":"api-typical-usage","value":"Often called from: WriteToc","count":4},{"name":"api-typical-usage","value":"Often called from: XLOGfileslop","count":4},{"name":"api-typical-usage","value":"Often called from: XLogBackgroundFlush","count":4},{"name":"api-typical-usage","value":"Often called from: XLogBytePosToEndRecPtr","count":4},{"name":"api-typical-usage","value":"Often called from: XLogFileName","count":4},{"name":"api-typical-usage","value":"Often called from: XLogFindNextRecord","count":4},{"name":"api-typical-usage","value":"Often called from: XLogPageRead","count":4},{"name":"api-typical-usage","value":"Often called from: XLogPrefetchResetStats","count":4},{"name":"api-typical-usage","value":"Often called from: XLogPrefetchShmemInit","count":4},{"name":"api-typical-usage","value":"Often called from: XLogPrefetcherAddFilter","count":4},{"name":"api-typical-usage","value":"Often called from: XLogReadBufferForRedoExtended","count":4},{"name":"api-typical-usage","value":"Often called from: XLogSendPhysical","count":4},{"name":"api-typical-usage","value":"Often called from: XactLogCommitRecord","count":4},{"name":"api-typical-usage","value":"Often called from: ZeroAndLockBuffer","count":4},{"name":"api-typical-usage","value":"Often called from: _EndData","count":4},{"name":"api-typical-usage","value":"Often called from: _PrintFileData","count":4},{"name":"api-typical-usage","value":"Often called from: _SPI_prepare_oneshot_plan","count":4},{"name":"api-typical-usage","value":"Often called from: _SPI_rollback","count":4},{"name":"api-typical-usage","value":"Often called from: _StartLOs","count":4},{"name":"api-typical-usage","value":"Often called from: _WriteBuf","count":4},{"name":"api-typical-usage","value":"Often called from: _WriteData","count":4},{"name":"api-typical-usage","value":"Often called from: _allocAH","count":4},{"name":"api-typical-usage","value":"Often called from: _brin_end_parallel","count":4},{"name":"api-typical-usage","value":"Often called from: _bt_allocbuf","count":4},{"name":"api-typical-usage","value":"Often called from: _bt_binsrch_array_skey","count":4},{"name":"api-typical-usage","value":"Often called from: _bt_bottomupdel_pass","count":4},{"name":"api-typical-usage","value":"Often called from: _bt_check_unique","count":4},{"name":"api-typical-usage","value":"Often called from: _bt_dedup_start_pending","count":4},{"name":"api-typical-usage","value":"Often called from: _bt_doinsert","count":4},{"name":"api-typical-usage","value":"Often called from: _bt_findsplitloc","count":4},{"name":"api-typical-usage","value":"Often called from: _bt_insertonpg","count":4},{"name":"api-typical-usage","value":"Often called from: _bt_mark_page_halfdead","count":4},{"name":"api-typical-usage","value":"Often called from: _bt_metaversion","count":4},{"name":"api-typical-usage","value":"Often called from: _bt_moveright","count":4},{"name":"api-typical-usage","value":"Often called from: _bt_newlevel","count":4},{"name":"api-typical-usage","value":"Often called from: _bt_pagedel","count":4},{"name":"api-typical-usage","value":"Often called from: _bt_readnextpage","count":4},{"name":"api-typical-usage","value":"Often called from: _bt_search","count":4},{"name":"api-typical-usage","value":"Often called from: _bt_strategy","count":4},{"name":"api-typical-usage","value":"Often called from: _bt_walk_left","count":4},{"name":"api-typical-usage","value":"Often called from: _copyConst","count":4},{"name":"api-typical-usage","value":"Often called from: _doSetFixedOutputState","count":4},{"name":"api-typical-usage","value":"Often called from: _equalConst","count":4},{"name":"api-typical-usage","value":"Often called from: _hash_doinsert","count":4},{"name":"api-typical-usage","value":"Often called from: _hash_first","count":4},{"name":"api-typical-usage","value":"Often called from: _hash_get_totalbuckets","count":4},{"name":"api-typical-usage","value":"Often called from: _hash_init","count":4},{"name":"api-typical-usage","value":"Often called from: _hash_kill_items","count":4},{"name":"api-typical-usage","value":"Often called from: _hash_next","count":4},{"name":"api-typical-usage","value":"Often called from: _hash_ovflblkno_to_bitno","count":4},{"name":"api-typical-usage","value":"Often called from: _hash_readpage","count":4},{"name":"api-typical-usage","value":"Often called from: _outForeignKeyOptInfo","count":4},{"name":"api-typical-usage","value":"Often called from: _pgstat64","count":4},{"name":"api-typical-usage","value":"Often called from: _reconnectToDB","count":4},{"name":"api-typical-usage","value":"Often called from: _snscanf_s_l","count":4},{"name":"api-typical-usage","value":"Often called from: _tarPositionTo","count":4},{"name":"api-typical-usage","value":"Often called from: _tocEntryRequired","count":4},{"name":"api-typical-usage","value":"Often called from: _vfprintf_p_l","count":4},{"name":"api-typical-usage","value":"Often called from: _vfscanf_s_l","count":4},{"name":"api-typical-usage","value":"Often called from: _vsnprintf_l","count":4},{"name":"api-typical-usage","value":"Often called from: _yconv","count":4},{"name":"api-typical-usage","value":"Often called from: accumArrayResultArr","count":4},{"name":"api-typical-usage","value":"Often called from: aclconcat","count":4},{"name":"api-typical-usage","value":"Often called from: aclcontains","count":4},{"name":"api-typical-usage","value":"Often called from: aclitem_eq","count":4},{"name":"api-typical-usage","value":"Often called from: aclmerge","count":4},{"name":"api-typical-usage","value":"Often called from: addBoundaryDependencies","count":4},{"name":"api-typical-usage","value":"Often called from: addItemPointersToLeafTuple","count":4},{"name":"api-typical-usage","value":"Often called from: addLeafTuple","count":4},{"name":"api-typical-usage","value":"Often called from: addNode","count":4},{"name":"api-typical-usage","value":"Often called from: addNorm","count":4},{"name":"api-typical-usage","value":"Often called from: addRangeTableEntryForFunction","count":4},{"name":"api-typical-usage","value":"Often called from: add_enum_reloption","count":4},{"name":"api-typical-usage","value":"Often called from: add_local_int_reloption","count":4},{"name":"api-typical-usage","value":"Often called from: add_partial_path","count":4},{"name":"api-typical-usage","value":"Often called from: add_paths_to_grouping_rel","count":4},{"name":"api-typical-usage","value":"Often called from: add_rte_to_flat_rtable","count":4},{"name":"api-typical-usage","value":"Often called from: add_security_quals","count":4},{"name":"api-typical-usage","value":"Often called from: adjust_group_pathkeys_for_groupagg","count":4},{"name":"api-typical-usage","value":"Often called from: adjust_standard_join_alias_expression","count":4},{"name":"api-typical-usage","value":"Often called from: allocNewBuffer","count":4},{"name":"api-typical-usage","value":"Often called from: amvalidate","count":4},{"name":"api-typical-usage","value":"Often called from: analyzeCTE","count":4},{"name":"api-typical-usage","value":"Often called from: analyze_mcv_list","count":4},{"name":"api-typical-usage","value":"Often called from: appendStringLiteralConn","count":4},{"name":"api-typical-usage","value":"Often called from: apply_child_basequals","count":4},{"name":"api-typical-usage","value":"Often called from: apply_error_callback","count":4},{"name":"api-typical-usage","value":"Often called from: apply_handle_insert","count":4},{"name":"api-typical-usage","value":"Often called from: apply_projection_to_path","count":4},{"name":"api-typical-usage","value":"Often called from: apply_scanjoin_target_to_paths","count":4},{"name":"api-typical-usage","value":"Often called from: archive_close_connection","count":4},{"name":"api-typical-usage","value":"Often called from: array_agg_array_combine","count":4},{"name":"api-typical-usage","value":"Often called from: array_agg_deserialize","count":4},{"name":"api-typical-usage","value":"Often called from: array_agg_serialize","count":4},{"name":"api-typical-usage","value":"Often called from: array_bitmap_copy","count":4},{"name":"api-typical-usage","value":"Often called from: array_contain_compare","count":4},{"name":"api-typical-usage","value":"Often called from: array_extract_slice","count":4},{"name":"api-typical-usage","value":"Often called from: array_get_element_expanded","count":4},{"name":"api-typical-usage","value":"Often called from: array_get_slice","count":4},{"name":"api-typical-usage","value":"Often called from: array_iter_next","count":4},{"name":"api-typical-usage","value":"Often called from: array_iterate","count":4},{"name":"api-typical-usage","value":"Often called from: array_map","count":4},{"name":"api-typical-usage","value":"Often called from: array_out","count":4},{"name":"api-typical-usage","value":"Often called from: array_positions","count":4},{"name":"api-typical-usage","value":"Often called from: array_ref","count":4},{"name":"api-typical-usage","value":"Often called from: array_send","count":4},{"name":"api-typical-usage","value":"Often called from: array_subscript_transform","count":4},{"name":"api-typical-usage","value":"Often called from: array_to_json_internal","count":4},{"name":"api-typical-usage","value":"Often called from: array_upper","count":4},{"name":"api-typical-usage","value":"Often called from: assign_recovery_target_lsn","count":4},{"name":"api-typical-usage","value":"Often called from: assign_transaction_timeout","count":4},{"name":"api-typical-usage","value":"Often called from: assign_wal_sync_method","count":4},{"name":"api-typical-usage","value":"Often called from: associate","count":4},{"name":"api-typical-usage","value":"Often called from: asyncQueueProcessPageEntries","count":4},{"name":"api-typical-usage","value":"Often called from: asyncQueueReadAllNotifications","count":4},{"name":"api-typical-usage","value":"Often called from: attnameAttNum","count":4},{"name":"api-typical-usage","value":"Often called from: attnumAttName","count":4},{"name":"api-typical-usage","value":"Often called from: auto_mem_key_init","count":4},{"name":"api-typical-usage","value":"Often called from: autovac_report_activity","count":4},{"name":"api-typical-usage","value":"Often called from: basebackup_progress_transfer_wal","count":4},{"name":"api-typical-usage","value":"Often called from: bbstreamer_recovery_injector_content","count":4},{"name":"api-typical-usage","value":"Often called from: bbstreamer_tar_archiver_finalize","count":4},{"name":"api-typical-usage","value":"Often called from: bbstreamer_tar_header","count":4},{"name":"api-typical-usage","value":"Often called from: bbstreamer_tar_parser_content","count":4},{"name":"api-typical-usage","value":"Often called from: bbstreamer_tar_parser_free","count":4},{"name":"api-typical-usage","value":"Often called from: be_lo_from_bytea","count":4},{"name":"api-typical-usage","value":"Often called from: be_tls_read","count":4},{"name":"api-typical-usage","value":"Often called from: binary_oper_exact","count":4},{"name":"api-typical-usage","value":"Often called from: binary_upgrade_create_empty_extension","count":4},{"name":"api-typical-usage","value":"Often called from: binary_upgrade_replorigin_advance","count":4},{"name":"api-typical-usage","value":"Often called from: binary_upgrade_set_missing_value","count":4},{"name":"api-typical-usage","value":"Often called from: binary_upgrade_set_next_heap_pg_class_oid","count":4},{"name":"api-typical-usage","value":"Often called from: bit","count":4},{"name":"api-typical-usage","value":"Often called from: bit_or","count":4},{"name":"api-typical-usage","value":"Often called from: bitfromint8","count":4},{"name":"api-typical-usage","value":"Often called from: bitgt","count":4},{"name":"api-typical-usage","value":"Often called from: bloom_contains_value","count":4},{"name":"api-typical-usage","value":"Often called from: bms_get_singleton_member","count":4},{"name":"api-typical-usage","value":"Often called from: booltestsel","count":4},{"name":"api-typical-usage","value":"Often called from: bootstrap_signals","count":4},{"name":"api-typical-usage","value":"Often called from: box_add","count":4},{"name":"api-typical-usage","value":"Often called from: box_closept_lseg","count":4},{"name":"api-typical-usage","value":"Often called from: box_gt","count":4},{"name":"api-typical-usage","value":"Often called from: box_in","count":4},{"name":"api-typical-usage","value":"Often called from: box_mul","count":4},{"name":"api-typical-usage","value":"Often called from: box_ov","count":4},{"name":"api-typical-usage","value":"Often called from: box_send","count":4},{"name":"api-typical-usage","value":"Often called from: box_sub","count":4},{"name":"api-typical-usage","value":"Often called from: bpchar","count":4},{"name":"api-typical-usage","value":"Often called from: bpchar_pattern_le","count":4},{"name":"api-typical-usage","value":"Often called from: bpchar_sortsupport","count":4},{"name":"api-typical-usage","value":"Often called from: bpcharfastcmp_c","count":4},{"name":"api-typical-usage","value":"Often called from: breakconstraintloop","count":4},{"name":"api-typical-usage","value":"Often called from: brin_bloom_union","count":4},{"name":"api-typical-usage","value":"Often called from: brin_deconstruct_tuple","count":4},{"name":"api-typical-usage","value":"Often called from: brin_deform_tuple","count":4},{"name":"api-typical-usage","value":"Often called from: brin_doinsert","count":4},{"name":"api-typical-usage","value":"Often called from: brin_inclusion_add_value","count":4},{"name":"api-typical-usage","value":"Often called from: brin_minmax_add_value","count":4},{"name":"api-typical-usage","value":"Often called from: brin_minmax_consistent","count":4},{"name":"api-typical-usage","value":"Often called from: brin_minmax_multi_consistent","count":4},{"name":"api-typical-usage","value":"Often called from: brin_minmax_multi_distance_inet","count":4},{"name":"api-typical-usage","value":"Often called from: brin_minmax_multi_summary_out","count":4},{"name":"api-typical-usage","value":"Often called from: brin_minmax_multi_summary_send","count":4},{"name":"api-typical-usage","value":"Often called from: brin_minmax_multi_union","count":4},{"name":"api-typical-usage","value":"Often called from: brin_summarize_range","count":4},{"name":"api-typical-usage","value":"Often called from: brin_xlog_insert_update","count":4},{"name":"api-typical-usage","value":"Often called from: brin_xlog_revmap_extend","count":4},{"name":"api-typical-usage","value":"Often called from: brinbuild","count":4},{"name":"api-typical-usage","value":"Often called from: brininsert","count":4},{"name":"api-typical-usage","value":"Often called from: brinsummarize","count":4},{"name":"api-typical-usage","value":"Often called from: btarraycmp","count":4},{"name":"api-typical-usage","value":"Often called from: btcostestimate","count":4},{"name":"api-typical-usage","value":"Often called from: btfloat8fastcmp","count":4},{"name":"api-typical-usage","value":"Often called from: btgetbitmap","count":4},{"name":"api-typical-usage","value":"Often called from: btrecordcmp","count":4},{"name":"api-typical-usage","value":"Often called from: btrecordimagecmp","count":4},{"name":"api-typical-usage","value":"Often called from: btree_mask","count":4},{"name":"api-typical-usage","value":"Often called from: btrestrpos","count":4},{"name":"api-typical-usage","value":"Often called from: btvacuumpage","count":4},{"name":"api-typical-usage","value":"Often called from: buffertag_comparator","count":4},{"name":"api-typical-usage","value":"Often called from: buildMatViewRefreshDependencies","count":4},{"name":"api-typical-usage","value":"Often called from: buildMergedJoinVar","count":4},{"name":"api-typical-usage","value":"Often called from: build_base_rel_tlists","count":4},{"name":"api-typical-usage","value":"Often called from: build_expression_pathkey","count":4},{"name":"api-typical-usage","value":"Often called from: build_hash_table","count":4},{"name":"api-typical-usage","value":"Often called from: build_index_paths","count":4},{"name":"api-typical-usage","value":"Often called from: build_partition_pathkeys","count":4},{"name":"api-typical-usage","value":"Often called from: build_paths_for_OR","count":4},{"name":"api-typical-usage","value":"Often called from: build_startup_packet","count":4},{"name":"api-typical-usage","value":"Often called from: byteacat","count":4},{"name":"api-typical-usage","value":"Often called from: cache_multirange_element_properties","count":4},{"name":"api-typical-usage","value":"Often called from: cache_range_element_properties","count":4},{"name":"api-typical-usage","value":"Often called from: calc_joinrel_size_estimate","count":4},{"name":"api-typical-usage","value":"Often called from: calc_rank_or","count":4},{"name":"api-typical-usage","value":"Often called from: calculate_toast_table_size","count":4},{"name":"api-typical-usage","value":"Often called from: canonicalize_path_enc","count":4},{"name":"api-typical-usage","value":"Often called from: cash_mul_int4","count":4},{"name":"api-typical-usage","value":"Often called from: cfindloop","count":4},{"name":"api-typical-usage","value":"Often called from: changeDependencyFor","count":4},{"name":"api-typical-usage","value":"Often called from: chargt","count":4},{"name":"api-typical-usage","value":"Often called from: charin","count":4},{"name":"api-typical-usage","value":"Often called from: charout","count":4},{"name":"api-typical-usage","value":"Often called from: checkMembershipInCurrentExtension","count":4},{"name":"api-typical-usage","value":"Often called from: checkRuleResultList","count":4},{"name":"api-typical-usage","value":"Often called from: checkWellFormedRecursionWalker","count":4},{"name":"api-typical-usage","value":"Often called from: check_agg_arguments","count":4},{"name":"api-typical-usage","value":"Often called from: check_bin_dir","count":4},{"name":"api-typical-usage","value":"Often called from: check_cluster_versions","count":4},{"name":"api-typical-usage","value":"Often called from: check_data_dir","count":4},{"name":"api-typical-usage","value":"Often called from: check_db","count":4},{"name":"api-typical-usage","value":"Often called from: check_domain_for_new_tuple","count":4},{"name":"api-typical-usage","value":"Often called from: check_exclusion_or_unique_constraint","count":4},{"name":"api-typical-usage","value":"Often called from: check_functions_in_node","count":4},{"name":"api-typical-usage","value":"Often called from: check_generic_type_consistency","count":4},{"name":"api-typical-usage","value":"Often called from: check_ident_usermap","count":4},{"name":"api-typical-usage","value":"Often called from: check_log_duration","count":4},{"name":"api-typical-usage","value":"Often called from: check_multixact_offset_buffers","count":4},{"name":"api-typical-usage","value":"Often called from: check_publications","count":4},{"name":"api-typical-usage","value":"Often called from: check_publisher","count":4},{"name":"api-typical-usage","value":"Often called from: check_slru_buffers","count":4},{"name":"api-typical-usage","value":"Often called from: check_transaction_read_only","count":4},{"name":"api-typical-usage","value":"Often called from: checkcondition_str","count":4},{"name":"api-typical-usage","value":"Often called from: choose_bitmap_and","count":4},{"name":"api-typical-usage","value":"Often called from: choose_hashed_setop","count":4},{"name":"api-typical-usage","value":"Often called from: choose_next_subplan_locally","count":4},{"name":"api-typical-usage","value":"Often called from: circle_eq","count":4},{"name":"api-typical-usage","value":"Often called from: clamp_cardinality_to_long","count":4},{"name":"api-typical-usage","value":"Often called from: clause_selectivity_ext","count":4},{"name":"api-typical-usage","value":"Often called from: clean_NOT_intree","count":4},{"name":"api-typical-usage","value":"Often called from: clean_stopword_intree","count":4},{"name":"api-typical-usage","value":"Often called from: closeLOfd","count":4},{"name":"api-typical-usage","value":"Often called from: close_pb","count":4},{"name":"api-typical-usage","value":"Often called from: close_pl","count":4},{"name":"api-typical-usage","value":"Often called from: close_sb","count":4},{"name":"api-typical-usage","value":"Often called from: coerce_fn_result_column","count":4},{"name":"api-typical-usage","value":"Often called from: coerce_record_to_complex","count":4},{"name":"api-typical-usage","value":"Often called from: collectSecLabels","count":4},{"name":"api-typical-usage","value":"Often called from: combine","count":4},{"name":"api-typical-usage","value":"Often called from: compareDatetime","count":4},{"name":"api-typical-usage","value":"Often called from: compare_block_numbers","count":4},{"name":"api-typical-usage","value":"Often called from: comparecost","count":4},{"name":"api-typical-usage","value":"Often called from: comparetup_cluster_tiebreak","count":4},{"name":"api-typical-usage","value":"Often called from: comparetup_index_btree_tiebreak","count":4},{"name":"api-typical-usage","value":"Often called from: complex_abs_le","count":4},{"name":"api-typical-usage","value":"Often called from: computeIterativeZipfian","count":4},{"name":"api-typical-usage","value":"Often called from: compute_code_target","count":4},{"name":"api-typical-usage","value":"Often called from: compute_scalar_stats","count":4},{"name":"api-typical-usage","value":"Often called from: compute_semijoin_info","count":4},{"name":"api-typical-usage","value":"Often called from: connection_warnings","count":4},{"name":"api-typical-usage","value":"Often called from: conninfo_array_parse","count":4},{"name":"api-typical-usage","value":"Often called from: conninfo_uri_parse","count":4},{"name":"api-typical-usage","value":"Often called from: construct_empty_expanded_array","count":4},{"name":"api-typical-usage","value":"Often called from: construct_md_array","count":4},{"name":"api-typical-usage","value":"Often called from: contain_leaked_vars_walker","count":4},{"name":"api-typical-usage","value":"Often called from: contained2D","count":4},{"name":"api-typical-usage","value":"Often called from: convertJsonbObject","count":4},{"name":"api-typical-usage","value":"Often called from: convertJsonbScalar","count":4},{"name":"api-typical-usage","value":"Often called from: convertToJsonb","count":4},{"name":"api-typical-usage","value":"Often called from: convert_EXISTS_to_ANY","count":4},{"name":"api-typical-usage","value":"Often called from: convert_bytea_to_scalar","count":4},{"name":"api-typical-usage","value":"Often called from: convert_bytea_to_string","count":4},{"name":"api-typical-usage","value":"Often called from: convert_foreign_data_wrapper_priv_string","count":4},{"name":"api-typical-usage","value":"Often called from: convert_real_from_base_unit","count":4},{"name":"api-typical-usage","value":"Often called from: convert_saop_to_hashed_saop_walker","count":4},{"name":"api-typical-usage","value":"Often called from: convert_subquery_pathkeys","count":4},{"name":"api-typical-usage","value":"Often called from: cookConstraint","count":4},{"name":"api-typical-usage","value":"Often called from: copydir","count":4},{"name":"api-typical-usage","value":"Often called from: cost_append","count":4},{"name":"api-typical-usage","value":"Often called from: cost_index","count":4},{"name":"api-typical-usage","value":"Often called from: cost_resultscan","count":4},{"name":"api-typical-usage","value":"Often called from: cost_samplescan","count":4},{"name":"api-typical-usage","value":"Often called from: cr_circle","count":4},{"name":"api-typical-usage","value":"Often called from: crashDumpHandler","count":4},{"name":"api-typical-usage","value":"Often called from: createBoundaryObjects","count":4},{"name":"api-typical-usage","value":"Often called from: create_bitmap_subplan","count":4},{"name":"api-typical-usage","value":"Often called from: create_groupingsets_path","count":4},{"name":"api-typical-usage","value":"Often called from: create_indexscan_plan","count":4},{"name":"api-typical-usage","value":"Often called from: create_new_objects","count":4},{"name":"api-typical-usage","value":"Often called from: create_projection_plan","count":4},{"name":"api-typical-usage","value":"Often called from: create_scan_plan","count":4},{"name":"api-typical-usage","value":"Often called from: create_tidrangescan_path","count":4},{"name":"api-typical-usage","value":"Often called from: create_unique_plan","count":4},{"name":"api-typical-usage","value":"Often called from: createdb_failure_callback","count":4},{"name":"api-typical-usage","value":"Often called from: cstring_recv","count":4},{"name":"api-typical-usage","value":"Often called from: cstring_send","count":4},{"name":"api-typical-usage","value":"Often called from: cursor_to_xml","count":4},{"name":"api-typical-usage","value":"Often called from: cursor_to_xmlschema","count":4},{"name":"api-typical-usage","value":"Often called from: dataPlaceToPageLeafRecompress","count":4},{"name":"api-typical-usage","value":"Often called from: database_is_invalid_oid","count":4},{"name":"api-typical-usage","value":"Often called from: date2isoweek","count":4},{"name":"api-typical-usage","value":"Often called from: datumIsEqual","count":4},{"name":"api-typical-usage","value":"Often called from: datumSerialize","count":4},{"name":"api-typical-usage","value":"Often called from: datum_image_hash","count":4},{"name":"api-typical-usage","value":"Often called from: deccall2","count":4},{"name":"api-typical-usage","value":"Often called from: deccvasc","count":4},{"name":"api-typical-usage","value":"Often called from: deccvlong","count":4},{"name":"api-typical-usage","value":"Often called from: decdiv","count":4},{"name":"api-typical-usage","value":"Often called from: decompose_code","count":4},{"name":"api-typical-usage","value":"Often called from: deconstruct_distribute","count":4},{"name":"api-typical-usage","value":"Often called from: dectoasc","count":4},{"name":"api-typical-usage","value":"Often called from: deleteObjectsInList","count":4},{"name":"api-typical-usage","value":"Often called from: dense_alloc","count":4},{"name":"api-typical-usage","value":"Often called from: dependency_is_compatible_clause","count":4},{"name":"api-typical-usage","value":"Often called from: describeOneTSParser","count":4},{"name":"api-typical-usage","value":"Often called from: describeRoles","count":4},{"name":"api-typical-usage","value":"Often called from: deserialize_deflist","count":4},{"name":"api-typical-usage","value":"Often called from: destroy_tablespace_directories","count":4},{"name":"api-typical-usage","value":"Often called from: detoast_external_attr","count":4},{"name":"api-typical-usage","value":"Often called from: dir_existsfile","count":4},{"name":"api-typical-usage","value":"Often called from: disable_all_timeouts","count":4},{"name":"api-typical-usage","value":"Often called from: dispell_init","count":4},{"name":"api-typical-usage","value":"Often called from: div_mod_var","count":4},{"name":"api-typical-usage","value":"Often called from: do_copy","count":4},{"name":"api-typical-usage","value":"Often called from: do_edit","count":4},{"name":"api-typical-usage","value":"Often called from: do_lo_import","count":4},{"name":"api-typical-usage","value":"Often called from: do_numeric_accum","count":4},{"name":"api-typical-usage","value":"Often called from: do_pg_backup_stop","count":4},{"name":"api-typical-usage","value":"Often called from: do_start","count":4},{"name":"api-typical-usage","value":"Often called from: do_start_worker","count":4},{"name":"api-typical-usage","value":"Often called from: do_watch","count":4},{"name":"api-typical-usage","value":"Often called from: dopr","count":4},{"name":"api-typical-usage","value":"Often called from: dpow","count":4},{"name":"api-typical-usage","value":"Often called from: drandom","count":4},{"name":"api-typical-usage","value":"Often called from: dropDatabaseDependencies","count":4},{"name":"api-typical-usage","value":"Often called from: drop_primary_replication_slot","count":4},{"name":"api-typical-usage","value":"Often called from: dsa_attach","count":4},{"name":"api-typical-usage","value":"Often called from: dsa_free","count":4},{"name":"api-typical-usage","value":"Often called from: dshash_dump","count":4},{"name":"api-typical-usage","value":"Often called from: dshash_find","count":4},{"name":"api-typical-usage","value":"Often called from: dshash_seq_next","count":4},{"name":"api-typical-usage","value":"Often called from: dsimple_lexize","count":4},{"name":"api-typical-usage","value":"Often called from: dsm_cleanup_using_control_segment","count":4},{"name":"api-typical-usage","value":"Often called from: dsm_postmaster_startup","count":4},{"name":"api-typical-usage","value":"Often called from: dumpEventTrigger","count":4},{"name":"api-typical-usage","value":"Often called from: dumpIndex","count":4},{"name":"api-typical-usage","value":"Often called from: dumpLO","count":4},{"name":"api-typical-usage","value":"Often called from: dumpNamespace","count":4},{"name":"api-typical-usage","value":"Often called from: dumpProcLang","count":4},{"name":"api-typical-usage","value":"Often called from: dumpShellType","count":4},{"name":"api-typical-usage","value":"Often called from: dumpTSParser","count":4},{"name":"api-typical-usage","value":"Often called from: dumpTransform","count":4},{"name":"api-typical-usage","value":"Often called from: dump_if","count":4},{"name":"api-typical-usage","value":"Often called from: dump_lo_buf","count":4},{"name":"api-typical-usage","value":"Often called from: eclass","count":4},{"name":"api-typical-usage","value":"Often called from: ecpg_deallocate_all_conn","count":4},{"name":"api-typical-usage","value":"Often called from: ecpg_is_type_an_array","count":4},{"name":"api-typical-usage","value":"Often called from: ecpg_prepared","count":4},{"name":"api-typical-usage","value":"Often called from: ecpg_process_output","count":4},{"name":"api-typical-usage","value":"Often called from: ecpg_raise_backend","count":4},{"name":"api-typical-usage","value":"Often called from: ecpg_result_by_descriptor","count":4},{"name":"api-typical-usage","value":"Often called from: ecpg_set_compat_sqlda","count":4},{"name":"api-typical-usage","value":"Often called from: edge_failure","count":4},{"name":"api-typical-usage","value":"Often called from: enable_timeouts","count":4},{"name":"api-typical-usage","value":"Often called from: end_progress_output","count":4},{"name":"api-typical-usage","value":"Often called from: entryFindChildPtr","count":4},{"name":"api-typical-usage","value":"Often called from: entryGetItem","count":4},{"name":"api-typical-usage","value":"Often called from: entryLoadMoreItems","count":4},{"name":"api-typical-usage","value":"Often called from: entrySplitPage","count":4},{"name":"api-typical-usage","value":"Often called from: enum_ge","count":4},{"name":"api-typical-usage","value":"Often called from: eq_v","count":4},{"name":"api-typical-usage","value":"Often called from: errmsg_internal","count":4},{"name":"api-typical-usage","value":"Often called from: estimate_ln_dweight","count":4},{"name":"api-typical-usage","value":"Often called from: examine_variable","count":4},{"name":"api-typical-usage","value":"Often called from: exec_command_connect","count":4},{"name":"api-typical-usage","value":"Often called from: exec_command_copy","count":4},{"name":"api-typical-usage","value":"Often called from: exec_command_d","count":4},{"name":"api-typical-usage","value":"Often called from: exec_command_endif","count":4},{"name":"api-typical-usage","value":"Often called from: exec_command_html","count":4},{"name":"api-typical-usage","value":"Often called from: exec_command_include","count":4},{"name":"api-typical-usage","value":"Often called from: exec_command_lo","count":4},{"name":"api-typical-usage","value":"Often called from: exec_command_write","count":4},{"name":"api-typical-usage","value":"Often called from: exec_eval_simple_expr","count":4},{"name":"api-typical-usage","value":"Often called from: exec_for_query","count":4},{"name":"api-typical-usage","value":"Often called from: exec_stmt_block","count":4},{"name":"api-typical-usage","value":"Often called from: exec_stmt_call","count":4},{"name":"api-typical-usage","value":"Often called from: exec_stmt_execsql","count":4},{"name":"api-typical-usage","value":"Often called from: exec_stmt_if","count":4},{"name":"api-typical-usage","value":"Often called from: exec_stmt_loop","count":4},{"name":"api-typical-usage","value":"Often called from: executeJsonPath","count":4},{"name":"api-typical-usage","value":"Often called from: executeMetaCommand","count":4},{"name":"api-typical-usage","value":"Often called from: executeQueryOrDie","count":4},{"name":"api-typical-usage","value":"Often called from: execute_jsp_gin_node","count":4},{"name":"api-typical-usage","value":"Often called from: execute_sql_string","count":4},{"name":"api-typical-usage","value":"Often called from: exp_var","count":4},{"name":"api-typical-usage","value":"Often called from: expandRTE","count":4},{"name":"api-typical-usage","value":"Often called from: expand_appendrel_subquery","count":4},{"name":"api-typical-usage","value":"Often called from: expand_grouping_sets","count":4},{"name":"api-typical-usage","value":"Often called from: expand_table_name_patterns","count":4},{"name":"api-typical-usage","value":"Often called from: exprCollation","count":4},{"name":"api-typical-usage","value":"Often called from: exprTypmod","count":4},{"name":"api-typical-usage","value":"Often called from: expression_planner","count":4},{"name":"api-typical-usage","value":"Often called from: extract_jsp_bool_expr","count":4},{"name":"api-typical-usage","value":"Often called from: extract_jsp_query","count":4},{"name":"api-typical-usage","value":"Often called from: extract_lateral_references","count":4},{"name":"api-typical-usage","value":"Often called from: f2d_small_int","count":4},{"name":"api-typical-usage","value":"Often called from: fasthash64","count":4},{"name":"api-typical-usage","value":"Often called from: fe_sendint64","count":4},{"name":"api-typical-usage","value":"Often called from: fetch_search_path","count":4},{"name":"api-typical-usage","value":"Often called from: fillQueryRepresentationData","count":4},{"name":"api-typical-usage","value":"Often called from: fill_ident_line","count":4},{"name":"api-typical-usage","value":"Often called from: final_cost_hashjoin","count":4},{"name":"api-typical-usage","value":"Often called from: final_cost_mergejoin","count":4},{"name":"api-typical-usage","value":"Often called from: findFkeyCast","count":4},{"name":"api-typical-usage","value":"Often called from: findLoop","count":4},{"name":"api-typical-usage","value":"Often called from: findRangeSubtypeDiffFunction","count":4},{"name":"api-typical-usage","value":"Often called from: findTargetlistEntrySQL92","count":4},{"name":"api-typical-usage","value":"Often called from: findTypeTypmodoutFunction","count":4},{"name":"api-typical-usage","value":"Often called from: find_coercion_pathway","count":4},{"name":"api-typical-usage","value":"Often called from: find_compatible_trans","count":4},{"name":"api-typical-usage","value":"Often called from: find_in_bucket","count":4},{"name":"api-typical-usage","value":"Often called from: find_join_input_rel","count":4},{"name":"api-typical-usage","value":"Often called from: find_multixact_start","count":4},{"name":"api-typical-usage","value":"Often called from: find_nonnullable_rels_walker","count":4},{"name":"api-typical-usage","value":"Often called from: find_nonnullable_vars_walker","count":4},{"name":"api-typical-usage","value":"Often called from: find_partition_scheme","count":4},{"name":"api-typical-usage","value":"Often called from: find_window_run_conditions","count":4},{"name":"api-typical-usage","value":"Often called from: findeq","count":4},{"name":"api-typical-usage","value":"Often called from: findprefix","count":4},{"name":"api-typical-usage","value":"Often called from: finish_heap_swap","count":4},{"name":"api-typical-usage","value":"Often called from: fix_expr_common","count":4},{"name":"api-typical-usage","value":"Often called from: fix_infomask_from_infobits","count":4},{"name":"api-typical-usage","value":"Often called from: fix_scan_expr_walker","count":4},{"name":"api-typical-usage","value":"Often called from: fixempties","count":4},{"name":"api-typical-usage","value":"Often called from: float4_to_char","count":4},{"name":"api-typical-usage","value":"Often called from: float4eq","count":4},{"name":"api-typical-usage","value":"Often called from: float4in_internal","count":4},{"name":"api-typical-usage","value":"Often called from: floor_log2","count":4},{"name":"api-typical-usage","value":"Often called from: flush_ps_display","count":4},{"name":"api-typical-usage","value":"Often called from: fmgr_sql","count":4},{"name":"api-typical-usage","value":"Often called from: fmtQualifiedIdEnc","count":4},{"name":"api-typical-usage","value":"Often called from: fmtfloat","count":4},{"name":"api-typical-usage","value":"Often called from: for_both_cell_setup","count":4},{"name":"api-typical-usage","value":"Often called from: format_expr_params","count":4},{"name":"api-typical-usage","value":"Often called from: freePGconn","count":4},{"name":"api-typical-usage","value":"Often called from: free_if","count":4},{"name":"api-typical-usage","value":"Often called from: free_open","count":4},{"name":"api-typical-usage","value":"Often called from: fsm_readbuf","count":4},{"name":"api-typical-usage","value":"Often called from: fsm_search","count":4},{"name":"api-typical-usage","value":"Often called from: function_references","count":4},{"name":"api-typical-usage","value":"Often called from: gather_merge_getnext","count":4},{"name":"api-typical-usage","value":"Often called from: gen_partprune_steps_internal","count":4},{"name":"api-typical-usage","value":"Often called from: generateSerialExtraStmts","count":4},{"name":"api-typical-usage","value":"Often called from: generate_series_int8_support","count":4},{"name":"api-typical-usage","value":"Often called from: generate_series_timestamp","count":4},{"name":"api-typical-usage","value":"Often called from: genericcostestimate","count":4},{"name":"api-typical-usage","value":"Often called from: getJsonPathVariableFromJsonb","count":4},{"name":"api-typical-usage","value":"Often called from: getJsonbLength","count":4},{"name":"api-typical-usage","value":"Often called from: getLOs","count":4},{"name":"api-typical-usage","value":"Often called from: getNamespaces","count":4},{"name":"api-typical-usage","value":"Often called from: getNotify","count":4},{"name":"api-typical-usage","value":"Often called from: getRowDescriptions","count":4},{"name":"api-typical-usage","value":"Often called from: get_agg_clause_costs","count":4},{"name":"api-typical-usage","value":"Often called from: get_common_eclass_indexes","count":4},{"name":"api-typical-usage","value":"Often called from: get_db_conn","count":4},{"name":"api-typical-usage","value":"Often called from: get_dirent_type","count":4},{"name":"api-typical-usage","value":"Often called from: get_errno_symbol","count":4},{"name":"api-typical-usage","value":"Often called from: get_expr_result_type","count":4},{"name":"api-typical-usage","value":"Often called from: get_ext_ver_list","count":4},{"name":"api-typical-usage","value":"Often called from: get_flush_position","count":4},{"name":"api-typical-usage","value":"Often called from: get_from_clause_item","count":4},{"name":"api-typical-usage","value":"Often called from: get_hash_entry","count":4},{"name":"api-typical-usage","value":"Often called from: get_includeserver_path","count":4},{"name":"api-typical-usage","value":"Often called from: get_memoize_path","count":4},{"name":"api-typical-usage","value":"Often called from: get_nullingrels_recurse","count":4},{"name":"api-typical-usage","value":"Often called from: get_object_address_opf_member","count":4},{"name":"api-typical-usage","value":"Often called from: get_object_address_unqualified","count":4},{"name":"api-typical-usage","value":"Often called from: get_object_attnum_namespace","count":4},{"name":"api-typical-usage","value":"Often called from: get_object_type","count":4},{"name":"api-typical-usage","value":"Often called from: get_parallel_object_list","count":4},{"name":"api-typical-usage","value":"Often called from: get_proposed_default_constraint","count":4},{"name":"api-typical-usage","value":"Often called from: get_relids_in_jointree","count":4},{"name":"api-typical-usage","value":"Often called from: get_rels_with_domain","count":4},{"name":"api-typical-usage","value":"Often called from: get_steps_using_prefix_recurse","count":4},{"name":"api-typical-usage","value":"Often called from: get_sub_conninfo","count":4},{"name":"api-typical-usage","value":"Often called from: get_sublink_expr","count":4},{"name":"api-typical-usage","value":"Often called from: get_tablespace_paths","count":4},{"name":"api-typical-usage","value":"Often called from: get_th","count":4},{"name":"api-typical-usage","value":"Often called from: get_windowfunc_expr_helper","count":4},{"name":"api-typical-usage","value":"Often called from: getdatafield","count":4},{"name":"api-typical-usage","value":"Often called from: gethms","count":4},{"name":"api-typical-usage","value":"Often called from: getnameinfo_unix","count":4},{"name":"api-typical-usage","value":"Often called from: getrule","count":4},{"name":"api-typical-usage","value":"Often called from: ginDataFillRoot","count":4},{"name":"api-typical-usage","value":"Often called from: ginDeletePage","count":4},{"name":"api-typical-usage","value":"Often called from: ginVacuumEntryPage","count":4},{"name":"api-typical-usage","value":"Often called from: gin_extract_jsonb","count":4},{"name":"api-typical-usage","value":"Often called from: gin_extract_jsonb_path","count":4},{"name":"api-typical-usage","value":"Often called from: ginbulkdelete","count":4},{"name":"api-typical-usage","value":"Often called from: ginoptions","count":4},{"name":"api-typical-usage","value":"Often called from: gistFindCorrectParent","count":4},{"name":"api-typical-usage","value":"Often called from: gistGetFakeLSN","count":4},{"name":"api-typical-usage","value":"Often called from: gistPlaceItupToPage","count":4},{"name":"api-typical-usage","value":"Often called from: gistRelocateBuildBuffersOnSplit","count":4},{"name":"api-typical-usage","value":"Often called from: gistSplit","count":4},{"name":"api-typical-usage","value":"Often called from: gist_box_same","count":4},{"name":"api-typical-usage","value":"Often called from: gist_indexsortbuild","count":4},{"name":"api-typical-usage","value":"Often called from: gist_indexsortbuild_levelstate_flush","count":4},{"name":"api-typical-usage","value":"Often called from: gistbuild","count":4},{"name":"api-typical-usage","value":"Often called from: gistindex_keytest","count":4},{"name":"api-typical-usage","value":"Often called from: gistkillitems","count":4},{"name":"api-typical-usage","value":"Often called from: gistprunepage","count":4},{"name":"api-typical-usage","value":"Often called from: growalloc","count":4},{"name":"api-typical-usage","value":"Often called from: gss_read","count":4},{"name":"api-typical-usage","value":"Often called from: gtsvector_compress","count":4},{"name":"api-typical-usage","value":"Often called from: gtsvector_consistent","count":4},{"name":"api-typical-usage","value":"Often called from: handle_args","count":4},{"name":"api-typical-usage","value":"Often called from: handle_streamed_transaction","count":4},{"name":"api-typical-usage","value":"Often called from: has_any_column_privilege_id_id","count":4},{"name":"api-typical-usage","value":"Often called from: has_column_privilege_name_attnum","count":4},{"name":"api-typical-usage","value":"Often called from: has_column_privilege_name_name","count":4},{"name":"api-typical-usage","value":"Often called from: has_database_privilege_id_id","count":4},{"name":"api-typical-usage","value":"Often called from: has_foreign_data_wrapper_privilege_name","count":4},{"name":"api-typical-usage","value":"Often called from: has_language_privilege_name_name","count":4},{"name":"api-typical-usage","value":"Often called from: has_schema_privilege_name","count":4},{"name":"api-typical-usage","value":"Often called from: has_server_privilege_name","count":4},{"name":"api-typical-usage","value":"Often called from: has_tablespace_privilege_id_name","count":4},{"name":"api-typical-usage","value":"Often called from: has_type_privilege_name_id","count":4},{"name":"api-typical-usage","value":"Often called from: hashRowType","count":4},{"name":"api-typical-usage","value":"Often called from: hash_agg_check_limits","count":4},{"name":"api-typical-usage","value":"Often called from: hash_multirange_extended","count":4},{"name":"api-typical-usage","value":"Often called from: hash_numeric","count":4},{"name":"api-typical-usage","value":"Often called from: hash_search_with_hash_value","count":4},{"name":"api-typical-usage","value":"Often called from: hash_seq_search","count":4},{"name":"api-typical-usage","value":"Often called from: hash_xlog_add_ovfl_page","count":4},{"name":"api-typical-usage","value":"Often called from: hash_xlog_move_page_contents","count":4},{"name":"api-typical-usage","value":"Often called from: hashbeginscan","count":4},{"name":"api-typical-usage","value":"Often called from: hashbpchar","count":4},{"name":"api-typical-usage","value":"Often called from: hashbulkdelete","count":4},{"name":"api-typical-usage","value":"Often called from: hashoidextended","count":4},{"name":"api-typical-usage","value":"Often called from: hashtext","count":4},{"name":"api-typical-usage","value":"Often called from: hashtextextended","count":4},{"name":"api-typical-usage","value":"Often called from: heap2_desc","count":4},{"name":"api-typical-usage","value":"Often called from: heap_decode","count":4},{"name":"api-typical-usage","value":"Often called from: heap_delete","count":4},{"name":"api-typical-usage","value":"Often called from: heap_desc","count":4},{"name":"api-typical-usage","value":"Often called from: heap_get_latest_tid","count":4},{"name":"api-typical-usage","value":"Often called from: heap_page_prune_and_freeze","count":4},{"name":"api-typical-usage","value":"Often called from: heap_prepare_freeze_tuple","count":4},{"name":"api-typical-usage","value":"Often called from: heap_set_tidrange","count":4},{"name":"api-typical-usage","value":"Often called from: heap_tuple_should_freeze","count":4},{"name":"api-typical-usage","value":"Often called from: heapam_scan_analyze_next_tuple","count":4},{"name":"api-typical-usage","value":"Often called from: heapam_tuple_satisfies_snapshot","count":4},{"name":"api-typical-usage","value":"Often called from: heapgettup_continue_page","count":4},{"name":"api-typical-usage","value":"Often called from: hk_breadth_search","count":4},{"name":"api-typical-usage","value":"Often called from: idealsendbacklognotify","count":4},{"name":"api-typical-usage","value":"Often called from: identify_target_directory","count":4},{"name":"api-typical-usage","value":"Often called from: ignoreeof_substitute_hook","count":4},{"name":"api-typical-usage","value":"Often called from: in_range_timestamp_interval","count":4},{"name":"api-typical-usage","value":"Often called from: in_range_timetz_interval","count":4},{"name":"api-typical-usage","value":"Often called from: increase_size","count":4},{"name":"api-typical-usage","value":"Often called from: index_build","count":4},{"name":"api-typical-usage","value":"Often called from: index_copy_data","count":4},{"name":"api-typical-usage","value":"Often called from: index_parallelscan_estimate","count":4},{"name":"api-typical-usage","value":"Often called from: index_truncate_tuple","count":4},{"name":"api-typical-usage","value":"Often called from: index_vacuum_cleanup","count":4},{"name":"api-typical-usage","value":"Often called from: indexam_property","count":4},{"name":"api-typical-usage","value":"Often called from: inet_cidr_pton_ipv4","count":4},{"name":"api-typical-usage","value":"Often called from: inet_semi_join_sel","count":4},{"name":"api-typical-usage","value":"Often called from: initGenerateDataServerSide","count":4},{"name":"api-typical-usage","value":"Often called from: initPopulateTable","count":4},{"name":"api-typical-usage","value":"Often called from: init_dsm_registry","count":4},{"name":"api-typical-usage","value":"Often called from: init_enum_reloption","count":4},{"name":"api-typical-usage","value":"Often called from: init_execution_state","count":4},{"name":"api-typical-usage","value":"Often called from: init_htab","count":4},{"name":"api-typical-usage","value":"Often called from: init_libpq_conn","count":4},{"name":"api-typical-usage","value":"Often called from: init_slab_allocator","count":4},{"name":"api-typical-usage","value":"Often called from: init_tuple_slot","count":4},{"name":"api-typical-usage","value":"Often called from: initcm","count":4},{"name":"api-typical-usage","value":"Often called from: initial_cost_mergejoin","count":4},{"name":"api-typical-usage","value":"Often called from: initialize_data_directory","count":4},{"name":"api-typical-usage","value":"Often called from: initialize_mergeclause_eclasses","count":4},{"name":"api-typical-usage","value":"Often called from: inline_function","count":4},{"name":"api-typical-usage","value":"Often called from: int2div","count":4},{"name":"api-typical-usage","value":"Often called from: int8_avg_deserialize","count":4},{"name":"api-typical-usage","value":"Often called from: inter_lb","count":4},{"name":"api-typical-usage","value":"Often called from: internal_inetpl","count":4},{"name":"api-typical-usage","value":"Often called from: internal_putbytes","count":4},{"name":"api-typical-usage","value":"Often called from: interpret_AS_clause","count":4},{"name":"api-typical-usage","value":"Often called from: interpret_ident_response","count":4},{"name":"api-typical-usage","value":"Often called from: interval_cmp_internal","count":4},{"name":"api-typical-usage","value":"Often called from: interval_mul","count":4},{"name":"api-typical-usage","value":"Often called from: inv_truncate","count":4},{"name":"api-typical-usage","value":"Often called from: inzone","count":4},{"name":"api-typical-usage","value":"Often called from: inzsub","count":4},{"name":"api-typical-usage","value":"Often called from: irish_UTF_8_close_env","count":4},{"name":"api-typical-usage","value":"Often called from: isSimpleNode","count":4},{"name":"api-typical-usage","value":"Often called from: is_member_of_role_nosuper","count":4},{"name":"api-typical-usage","value":"Often called from: is_next_separator","count":4},{"name":"api-typical-usage","value":"Often called from: is_standard_join_alias_expression","count":4},{"name":"api-typical-usage","value":"Often called from: is_valid_ascii","count":4},{"name":"api-typical-usage","value":"Often called from: iso_to_win866","count":4},{"name":"api-typical-usage","value":"Often called from: iterate_jsonb_values","count":4},{"name":"api-typical-usage","value":"Often called from: itm2interval","count":4},{"name":"api-typical-usage","value":"Often called from: itsabbr","count":4},{"name":"api-typical-usage","value":"Often called from: itsdir","count":4},{"name":"api-typical-usage","value":"Often called from: join_tsqueries","count":4},{"name":"api-typical-usage","value":"Often called from: jointree_contains_lateral_outer_refs","count":4},{"name":"api-typical-usage","value":"Often called from: json_array_element","count":4},{"name":"api-typical-usage","value":"Often called from: json_categorize_type","count":4},{"name":"api-typical-usage","value":"Often called from: json_errdetail","count":4},{"name":"api-typical-usage","value":"Often called from: json_manifest_finalize_wal_range","count":4},{"name":"api-typical-usage","value":"Often called from: json_parse_manifest","count":4},{"name":"api-typical-usage","value":"Often called from: json_to_record","count":4},{"name":"api-typical-usage","value":"Often called from: jsonb_concat","count":4},{"name":"api-typical-usage","value":"Often called from: jsonb_delete_path","count":4},{"name":"api-typical-usage","value":"Often called from: jsonb_ge","count":4},{"name":"api-typical-usage","value":"Often called from: jsonb_object_agg_transfn_worker","count":4},{"name":"api-typical-usage","value":"Often called from: jsonb_object_field_text","count":4},{"name":"api-typical-usage","value":"Often called from: jsonb_path_exists_internal","count":4},{"name":"api-typical-usage","value":"Often called from: jspGetArraySubscript","count":4},{"name":"api-typical-usage","value":"Often called from: jspInitByBuffer","count":4},{"name":"api-typical-usage","value":"Often called from: jspIsMutableWalker","count":4},{"name":"api-typical-usage","value":"Often called from: lappend_int","count":4},{"name":"api-typical-usage","value":"Often called from: latin1_to_mic","count":4},{"name":"api-typical-usage","value":"Often called from: lazy_scan_heap","count":4},{"name":"api-typical-usage","value":"Often called from: lazy_scan_new_or_empty","count":4},{"name":"api-typical-usage","value":"Often called from: lazy_truncate_heap","count":4},{"name":"api-typical-usage","value":"Often called from: lazy_vacuum_all_indexes","count":4},{"name":"api-typical-usage","value":"Often called from: lc_collate_is_c","count":4},{"name":"api-typical-usage","value":"Often called from: libpq_queue_fetch_file","count":4},{"name":"api-typical-usage","value":"Often called from: libpqrcv_startstreaming","count":4},{"name":"api-typical-usage","value":"Often called from: like_selectivity","count":4},{"name":"api-typical-usage","value":"Often called from: line_out","count":4},{"name":"api-typical-usage","value":"Often called from: line_parallel","count":4},{"name":"api-typical-usage","value":"Often called from: line_perp","count":4},{"name":"api-typical-usage","value":"Often called from: listDefaultACLs","count":4},{"name":"api-typical-usage","value":"Often called from: listTables","count":4},{"name":"api-typical-usage","value":"Often called from: list_delete_int","count":4},{"name":"api-typical-usage","value":"Often called from: llvm_execute_inline_plan","count":4},{"name":"api-typical-usage","value":"Often called from: llvm_pg_func","count":4},{"name":"api-typical-usage","value":"Often called from: ln_var","count":4},{"name":"api-typical-usage","value":"Often called from: lo_get_fragment_internal","count":4},{"name":"api-typical-usage","value":"Often called from: load_dh_file","count":4},{"name":"api-typical-usage","value":"Often called from: log_heap_prune_and_freeze","count":4},{"name":"api-typical-usage","value":"Often called from: log_newpage_range","count":4},{"name":"api-typical-usage","value":"Often called from: log_var","count":4},{"name":"api-typical-usage","value":"Often called from: logical_rewrite_log_mapping","count":4},{"name":"api-typical-usage","value":"Often called from: logicalmsg_decode","count":4},{"name":"api-typical-usage","value":"Often called from: logicalrep_partition_open","count":4},{"name":"api-typical-usage","value":"Often called from: logicalrep_relmap_free_entry","count":4},{"name":"api-typical-usage","value":"Often called from: lookahead","count":4},{"name":"api-typical-usage","value":"Often called from: lookup_proof_cache","count":4},{"name":"api-typical-usage","value":"Often called from: lseg_contain_point","count":4},{"name":"api-typical-usage","value":"Often called from: lseg_interpt_lseg","count":4},{"name":"api-typical-usage","value":"Often called from: lseg_recv","count":4},{"name":"api-typical-usage","value":"Often called from: ltrim","count":4},{"name":"api-typical-usage","value":"Often called from: macaddr8_gt","count":4},{"name":"api-typical-usage","value":"Often called from: macaddr8_in","count":4},{"name":"api-typical-usage","value":"Often called from: macaddr8_recv","count":4},{"name":"api-typical-usage","value":"Often called from: makeArrayResultAny","count":4},{"name":"api-typical-usage","value":"Often called from: makeArrayTypeName","count":4},{"name":"api-typical-usage","value":"Often called from: makeDependencyGraphWalker","count":4},{"name":"api-typical-usage","value":"Often called from: makeJsonLexContextIncremental","count":4},{"name":"api-typical-usage","value":"Often called from: makeObjectName","count":4},{"name":"api-typical-usage","value":"Often called from: makeWholeRowVar","count":4},{"name":"api-typical-usage","value":"Often called from: make_array_ref","count":4},{"name":"api-typical-usage","value":"Often called from: make_bound_box","count":4},{"name":"api-typical-usage","value":"Often called from: make_distinct_op","count":4},{"name":"api-typical-usage","value":"Often called from: make_expanded_record_from_datum","count":4},{"name":"api-typical-usage","value":"Often called from: make_expanded_record_from_tupdesc","count":4},{"name":"api-typical-usage","value":"Often called from: make_greater_string","count":4},{"name":"api-typical-usage","value":"Often called from: make_grouping_rel","count":4},{"name":"api-typical-usage","value":"Often called from: make_pathkeys_for_window","count":4},{"name":"api-typical-usage","value":"Often called from: make_scalar_key","count":4},{"name":"api-typical-usage","value":"Often called from: make_sort_from_sortclauses","count":4},{"name":"api-typical-usage","value":"Often called from: make_unique_from_pathkeys","count":4},{"name":"api-typical-usage","value":"Often called from: map_multipart_sql_identifier_to_xml_name","count":4},{"name":"api-typical-usage","value":"Often called from: map_sql_schema_to_xmlschema_types","count":4},{"name":"api-typical-usage","value":"Often called from: map_sql_typecoll_to_xmlschema_types","count":4},{"name":"api-typical-usage","value":"Often called from: markQueryForLocking","count":4},{"name":"api-typical-usage","value":"Often called from: markRTEForSelectPriv","count":4},{"name":"api-typical-usage","value":"Often called from: match_boolean_index_clause","count":4},{"name":"api-typical-usage","value":"Often called from: match_opclause_to_indexcol","count":4},{"name":"api-typical-usage","value":"Often called from: matches_boolean_partition_clause","count":4},{"name":"api-typical-usage","value":"Often called from: maxcolor","count":4},{"name":"api-typical-usage","value":"Often called from: maybe_start_bgworkers","count":4},{"name":"api-typical-usage","value":"Often called from: mdregistersync","count":4},{"name":"api-typical-usage","value":"Often called from: merge_list_bounds","count":4},{"name":"api-typical-usage","value":"Often called from: mergeins","count":4},{"name":"api-typical-usage","value":"Often called from: mic2euc_tw","count":4},{"name":"api-typical-usage","value":"Often called from: mic_to_latin4","count":4},{"name":"api-typical-usage","value":"Often called from: mic_to_win866","count":4},{"name":"api-typical-usage","value":"Often called from: miss","count":4},{"name":"api-typical-usage","value":"Often called from: mkANode","count":4},{"name":"api-typical-usage","value":"Often called from: mkSPNode","count":4},{"name":"api-typical-usage","value":"Often called from: mq_putmessage","count":4},{"name":"api-typical-usage","value":"Often called from: multirange_adjacent_multirange","count":4},{"name":"api-typical-usage","value":"Often called from: multirange_cmp","count":4},{"name":"api-typical-usage","value":"Often called from: multirange_element_has_hashing","count":4},{"name":"api-typical-usage","value":"Often called from: multirange_intersect_internal","count":4},{"name":"api-typical-usage","value":"Often called from: multirange_minus","count":4},{"name":"api-typical-usage","value":"Often called from: multirange_minus_internal","count":4},{"name":"api-typical-usage","value":"Often called from: namelt","count":4},{"name":"api-typical-usage","value":"Often called from: negate_clause","count":4},{"name":"api-typical-usage","value":"Often called from: network_larger","count":4},{"name":"api-typical-usage","value":"Often called from: nextval_internal","count":4},{"name":"api-typical-usage","value":"Often called from: numeric","count":4},{"name":"api-typical-usage","value":"Often called from: numeric_accum_inv","count":4},{"name":"api-typical-usage","value":"Often called from: numeric_avg_serialize","count":4},{"name":"api-typical-usage","value":"Often called from: numeric_deserialize","count":4},{"name":"api-typical-usage","value":"Often called from: numeric_div_opt_error","count":4},{"name":"api-typical-usage","value":"Often called from: numeric_float4","count":4},{"name":"api-typical-usage","value":"Often called from: numeric_mul_opt_error","count":4},{"name":"api-typical-usage","value":"Often called from: numeric_out","count":4},{"name":"api-typical-usage","value":"Often called from: numeric_poly_deserialize","count":4},{"name":"api-typical-usage","value":"Often called from: numeric_send","count":4},{"name":"api-typical-usage","value":"Often called from: numeric_stddev_internal","count":4},{"name":"api-typical-usage","value":"Often called from: numeric_uminus","count":4},{"name":"api-typical-usage","value":"Often called from: numerictypmodin","count":4},{"name":"api-typical-usage","value":"Often called from: objectDescription","count":4},{"name":"api-typical-usage","value":"Often called from: oidlt","count":4},{"name":"api-typical-usage","value":"Often called from: oidvectorgt","count":4},{"name":"api-typical-usage","value":"Often called from: open_walfile","count":4},{"name":"api-typical-usage","value":"Often called from: opendir","count":4},{"name":"api-typical-usage","value":"Often called from: overlaps_time","count":4},{"name":"api-typical-usage","value":"Often called from: overlaps_timetz","count":4},{"name":"api-typical-usage","value":"Often called from: p_islower","count":4},{"name":"api-typical-usage","value":"Often called from: p_isprint","count":4},{"name":"api-typical-usage","value":"Often called from: p_isspace","count":4},{"name":"api-typical-usage","value":"Often called from: pa_free_worker_info","count":4},{"name":"api-typical-usage","value":"Often called from: pa_process_spooled_messages_if_required","count":4},{"name":"api-typical-usage","value":"Often called from: pairingheap_GISTSearchItem_cmp","count":4},{"name":"api-typical-usage","value":"Often called from: palloc","count":4},{"name":"api-typical-usage","value":"Often called from: parallel_exec_prog","count":4},{"name":"api-typical-usage","value":"Often called from: paraminfo_get_equal_hashops","count":4},{"name":"api-typical-usage","value":"Often called from: parseCheckAggregates","count":4},{"name":"api-typical-usage","value":"Often called from: parseCommandLine","count":4},{"name":"api-typical-usage","value":"Often called from: parseWorkerCommand","count":4},{"name":"api-typical-usage","value":"Often called from: parse_array","count":4},{"name":"api-typical-usage","value":"Often called from: parse_backup_label","count":4},{"name":"api-typical-usage","value":"Often called from: parse_extension_control_file","count":4},{"name":"api-typical-usage","value":"Often called from: parse_format","count":4},{"name":"api-typical-usage","value":"Often called from: path_contains_parent_reference","count":4},{"name":"api-typical-usage","value":"Often called from: patternToSQLRegex","count":4},{"name":"api-typical-usage","value":"Often called from: patternjoinsel","count":4},{"name":"api-typical-usage","value":"Often called from: perform_pullup_replace_vars","count":4},{"name":"api-typical-usage","value":"Often called from: perform_rewind","count":4},{"name":"api-typical-usage","value":"Often called from: permute","count":4},{"name":"api-typical-usage","value":"Often called from: pgTypeNameCompare","count":4},{"name":"api-typical-usage","value":"Often called from: pg_SASL_init","count":4},{"name":"api-typical-usage","value":"Often called from: pg_aclmask","count":4},{"name":"api-typical-usage","value":"Often called from: pg_advisory_lock_shared_int4","count":4},{"name":"api-typical-usage","value":"Often called from: pg_analyze_and_rewrite_varparams","count":4},{"name":"api-typical-usage","value":"Often called from: pg_any_to_server","count":4},{"name":"api-typical-usage","value":"Often called from: pg_atomic_compare_exchange_u32","count":4},{"name":"api-typical-usage","value":"Often called from: pg_checksum_block","count":4},{"name":"api-typical-usage","value":"Often called from: pg_copy_logical_replication_slot_a","count":4},{"name":"api-typical-usage","value":"Often called from: pg_create_logical_replication_slot","count":4},{"name":"api-typical-usage","value":"Often called from: pg_ctl_status","count":4},{"name":"api-typical-usage","value":"Often called from: pg_current_snapshot","count":4},{"name":"api-typical-usage","value":"Often called from: pg_encoding_mbcliplen","count":4},{"name":"api-typical-usage","value":"Often called from: pg_euc_dsplen","count":4},{"name":"api-typical-usage","value":"Often called from: pg_eucjp_verifychar","count":4},{"name":"api-typical-usage","value":"Often called from: pg_event_trigger_ddl_commands","count":4},{"name":"api-typical-usage","value":"Often called from: pg_extension_config_dump","count":4},{"name":"api-typical-usage","value":"Often called from: pg_get_constraintdef_worker","count":4},{"name":"api-typical-usage","value":"Often called from: pg_get_encoding_from_locale","count":4},{"name":"api-typical-usage","value":"Often called from: pg_get_function_result","count":4},{"name":"api-typical-usage","value":"Often called from: pg_get_functiondef","count":4},{"name":"api-typical-usage","value":"Often called from: pg_get_keywords","count":4},{"name":"api-typical-usage","value":"Often called from: pg_get_object_address","count":4},{"name":"api-typical-usage","value":"Often called from: pg_get_viewdef","count":4},{"name":"api-typical-usage","value":"Often called from: pg_has_role_name_name","count":4},{"name":"api-typical-usage","value":"Often called from: pg_hmac_init","count":4},{"name":"api-typical-usage","value":"Often called from: pg_identify_object_as_address","count":4},{"name":"api-typical-usage","value":"Often called from: pg_largeobject_aclmask_snapshot","count":4},{"name":"api-typical-usage","value":"Often called from: pg_latin1_verifystr","count":4},{"name":"api-typical-usage","value":"Often called from: pg_ls_logicalsnapdir","count":4},{"name":"api-typical-usage","value":"Often called from: pg_ls_replslotdir","count":4},{"name":"api-typical-usage","value":"Often called from: pg_md5_update","count":4},{"name":"api-typical-usage","value":"Often called from: pg_open_tzfile","count":4},{"name":"api-typical-usage","value":"Often called from: pg_parse_json_or_errsave","count":4},{"name":"api-typical-usage","value":"Often called from: pg_prng_int64p","count":4},{"name":"api-typical-usage","value":"Often called from: pg_replication_origin_session_is_setup","count":4},{"name":"api-typical-usage","value":"Often called from: pg_sha256_update","count":4},{"name":"api-typical-usage","value":"Often called from: pg_sha512_update","count":4},{"name":"api-typical-usage","value":"Often called from: pg_snapshot_xip","count":4},{"name":"api-typical-usage","value":"Often called from: pg_snapshot_xmax","count":4},{"name":"api-typical-usage","value":"Often called from: pg_stat_file","count":4},{"name":"api-typical-usage","value":"Often called from: pg_stat_get_backend_start","count":4},{"name":"api-typical-usage","value":"Often called from: pg_stat_get_bgwriter_maxwritten_clean","count":4},{"name":"api-typical-usage","value":"Often called from: pg_stat_get_checkpointer_restartpoints_performed","count":4},{"name":"api-typical-usage","value":"Often called from: pg_stat_get_last_vacuum_time","count":4},{"name":"api-typical-usage","value":"Often called from: pg_stat_get_recovery_prefetch","count":4},{"name":"api-typical-usage","value":"Often called from: pg_stat_get_xact_blocks_hit","count":4},{"name":"api-typical-usage","value":"Often called from: pg_stat_reset_shared","count":4},{"name":"api-typical-usage","value":"Often called from: pg_stats_ext_mcvlist_items","count":4},{"name":"api-typical-usage","value":"Often called from: pg_strxfrm_prefix","count":4},{"name":"api-typical-usage","value":"Often called from: pg_timer_thread","count":4},{"name":"api-typical-usage","value":"Often called from: pg_try_advisory_lock_shared_int8","count":4},{"name":"api-typical-usage","value":"Often called from: pg_u_prop_case_ignorable","count":4},{"name":"api-typical-usage","value":"Often called from: pg_unicode_to_server_noerror","count":4},{"name":"api-typical-usage","value":"Often called from: pg_utf8_verifystr","count":4},{"name":"api-typical-usage","value":"Often called from: pg_walfile_name","count":4},{"name":"api-typical-usage","value":"Often called from: pgkill","count":4},{"name":"api-typical-usage","value":"Often called from: pglz_decompress_datum","count":4},{"name":"api-typical-usage","value":"Often called from: pgoutput_rollback_prepared_txn","count":4},{"name":"api-typical-usage","value":"Often called from: pgstat_bgwriter_snapshot_cb","count":4},{"name":"api-typical-usage","value":"Often called from: pgstat_checkpointer_snapshot_cb","count":4},{"name":"api-typical-usage","value":"Often called from: pgstat_count_slru_flush","count":4},{"name":"api-typical-usage","value":"Often called from: pgstat_create_transactional","count":4},{"name":"api-typical-usage","value":"Often called from: pgstat_drop_relation","count":4},{"name":"api-typical-usage","value":"Often called from: pgstat_execute_transactional_drops","count":4},{"name":"api-typical-usage","value":"Often called from: pgstat_fetch_stat_funcentry","count":4},{"name":"api-typical-usage","value":"Often called from: pgstat_fetch_stat_wal","count":4},{"name":"api-typical-usage","value":"Often called from: pgstat_flush_wal","count":4},{"name":"api-typical-usage","value":"Often called from: pgstat_get_entry_ref","count":4},{"name":"api-typical-usage","value":"Often called from: pgstat_have_entry","count":4},{"name":"api-typical-usage","value":"Often called from: pgstat_init_entry","count":4},{"name":"api-typical-usage","value":"Often called from: pgstat_prep_snapshot","count":4},{"name":"api-typical-usage","value":"Often called from: pgstat_progress_parallel_incr_param","count":4},{"name":"api-typical-usage","value":"Often called from: pgstat_reinit_entry","count":4},{"name":"api-typical-usage","value":"Often called from: pgstat_relation_flush_cb","count":4},{"name":"api-typical-usage","value":"Often called from: pgstat_slru_flush","count":4},{"name":"api-typical-usage","value":"Often called from: pgsymlink","count":4},{"name":"api-typical-usage","value":"Often called from: pgtls_read","count":4},{"name":"api-typical-usage","value":"Often called from: pgwin32_doUnregister","count":4},{"name":"api-typical-usage","value":"Often called from: pgwin32_get_file_type","count":4},{"name":"api-typical-usage","value":"Often called from: pgwin32_is_service","count":4},{"name":"api-typical-usage","value":"Often called from: pgwin32_recv","count":4},{"name":"api-typical-usage","value":"Often called from: pgwin32_socket","count":4},{"name":"api-typical-usage","value":"Often called from: phraseto_tsquery","count":4},{"name":"api-typical-usage","value":"Often called from: phraseto_tsquery_byid","count":4},{"name":"api-typical-usage","value":"Often called from: pid_lock_file_exists","count":4},{"name":"api-typical-usage","value":"Often called from: planstate_tree_walker_impl","count":4},{"name":"api-typical-usage","value":"Often called from: plist_same","count":4},{"name":"api-typical-usage","value":"Often called from: plperl_call_perl_trigger_func","count":4},{"name":"api-typical-usage","value":"Often called from: pltcl_SPI_execute","count":4},{"name":"api-typical-usage","value":"Often called from: pltcl_SPI_prepare","count":4},{"name":"api-typical-usage","value":"Often called from: pltcl_event_trigger_handler","count":4},{"name":"api-typical-usage","value":"Often called from: pltcl_init_interp","count":4},{"name":"api-typical-usage","value":"Often called from: point_out","count":4},{"name":"api-typical-usage","value":"Often called from: poly_overlap_internal","count":4},{"name":"api-typical-usage","value":"Often called from: poly_recv","count":4},{"name":"api-typical-usage","value":"Often called from: pop_stmt_mcontext","count":4},{"name":"api-typical-usage","value":"Often called from: populate_recordset_worker","count":4},{"name":"api-typical-usage","value":"Often called from: populate_scalar","count":4},{"name":"api-typical-usage","value":"Often called from: portuguese_UTF_8_create_env","count":4},{"name":"api-typical-usage","value":"Often called from: pqClosePGconn","count":4},{"name":"api-typical-usage","value":"Often called from: pqConnectDBStart","count":4},{"name":"api-typical-usage","value":"Often called from: pqEndcopy3","count":4},{"name":"api-typical-usage","value":"Often called from: pqFunctionCall3","count":4},{"name":"api-typical-usage","value":"Often called from: pqGetHomeDirectory","count":4},{"name":"api-typical-usage","value":"Often called from: pqPutInt","count":4},{"name":"api-typical-usage","value":"Often called from: pqReadData","count":4},{"name":"api-typical-usage","value":"Often called from: pqSendSome","count":4},{"name":"api-typical-usage","value":"Often called from: pqTraceOutputNoTypeByteMessage","count":4},{"name":"api-typical-usage","value":"Often called from: pqTraceOutput_ReadyForQuery","count":4},{"name":"api-typical-usage","value":"Often called from: pq_check_connection","count":4},{"name":"api-typical-usage","value":"Often called from: pq_getmessage","count":4},{"name":"api-typical-usage","value":"Often called from: pq_getmsgint","count":4},{"name":"api-typical-usage","value":"Often called from: pr_comment","count":4},{"name":"api-typical-usage","value":"Often called from: predicate_implied_by_recurse","count":4},{"name":"api-typical-usage","value":"Often called from: predicatelock_twophase_recover","count":4},{"name":"api-typical-usage","value":"Often called from: prep_status_progress","count":4},{"name":"api-typical-usage","value":"Often called from: print_function_sqlbody","count":4},{"name":"api-typical-usage","value":"Often called from: print_troff_ms_vertical","count":4},{"name":"api-typical-usage","value":"Often called from: print_unaligned_vertical","count":4},{"name":"api-typical-usage","value":"Often called from: printsimple","count":4},{"name":"api-typical-usage","value":"Often called from: process_duplicate_ors","count":4},{"name":"api-typical-usage","value":"Often called from: process_equivalence","count":4},{"name":"api-typical-usage","value":"Often called from: process_owned_by","count":4},{"name":"api-typical-usage","value":"Often called from: process_pm_reload_request","count":4},{"name":"api-typical-usage","value":"Often called from: process_syncing_tables_for_apply","count":4},{"name":"api-typical-usage","value":"Often called from: processlacon","count":4},{"name":"api-typical-usage","value":"Often called from: prsd_headline","count":4},{"name":"api-typical-usage","value":"Often called from: pthread_mutex_lock","count":4},{"name":"api-typical-usage","value":"Often called from: pull_up_constant_function","count":4},{"name":"api-typical-usage","value":"Often called from: pull_up_sublinks_jointree_recurse","count":4},{"name":"api-typical-usage","value":"Often called from: pull_up_subqueries_recurse","count":4},{"name":"api-typical-usage","value":"Often called from: push","count":4},{"name":"api-typical-usage","value":"Often called from: pushval_morph","count":4},{"name":"api-typical-usage","value":"Often called from: pwrite","count":4},{"name":"api-typical-usage","value":"Often called from: query_is_distinct_for","count":4},{"name":"api-typical-usage","value":"Often called from: quickdie","count":4},{"name":"api-typical-usage","value":"Often called from: r_Step_1b","count":4},{"name":"api-typical-usage","value":"Often called from: r_Step_2","count":4},{"name":"api-typical-usage","value":"Often called from: r_Suffix_Verb_Step2a","count":4},{"name":"api-typical-usage","value":"Often called from: r_check_vowel_harmony","count":4},{"name":"api-typical-usage","value":"Often called from: r_mark_nU","count":4},{"name":"api-typical-usage","value":"Often called from: r_mark_ylA","count":4},{"name":"api-typical-usage","value":"Often called from: r_postlude","count":4},{"name":"api-typical-usage","value":"Often called from: r_remove_tense_suffix","count":4},{"name":"api-typical-usage","value":"Often called from: r_shortv","count":4},{"name":"api-typical-usage","value":"Often called from: r_stem_nominal_verb_suffixes","count":4},{"name":"api-typical-usage","value":"Often called from: r_tidy","count":4},{"name":"api-typical-usage","value":"Often called from: r_undouble","count":4},{"name":"api-typical-usage","value":"Often called from: random_var","count":4},{"name":"api-typical-usage","value":"Often called from: range","count":4},{"name":"api-typical-usage","value":"Often called from: range_add_value","count":4},{"name":"api-typical-usage","value":"Often called from: range_adjacent","count":4},{"name":"api-typical-usage","value":"Often called from: range_adjacent_multirange_internal","count":4},{"name":"api-typical-usage","value":"Often called from: range_gist_consistent_leaf_element","count":4},{"name":"api-typical-usage","value":"Often called from: range_gist_consistent_leaf_range","count":4},{"name":"api-typical-usage","value":"Often called from: range_merge_from_multirange","count":4},{"name":"api-typical-usage","value":"Often called from: range_ne_internal","count":4},{"name":"api-typical-usage","value":"Often called from: range_split_internal","count":4},{"name":"api-typical-usage","value":"Often called from: rbt_delete_node","count":4},{"name":"api-typical-usage","value":"Often called from: read_backup_label","count":4},{"name":"api-typical-usage","value":"Often called from: read_dump_filters","count":4},{"name":"api-typical-usage","value":"Often called from: read_local_xlog_page_guts","count":4},{"name":"api-typical-usage","value":"Often called from: read_or_wait","count":4},{"name":"api-typical-usage","value":"Often called from: reapply_stacked_values","count":4},{"name":"api-typical-usage","value":"Often called from: rebuild_database_list","count":4},{"name":"api-typical-usage","value":"Often called from: recheck_cast_function_args","count":4},{"name":"api-typical-usage","value":"Often called from: recompose_code","count":4},{"name":"api-typical-usage","value":"Often called from: reconsider_full_join_clause","count":4},{"name":"api-typical-usage","value":"Often called from: reconsider_outer_join_clause","count":4},{"name":"api-typical-usage","value":"Often called from: recordDependencyOnCurrentExtension","count":4},{"name":"api-typical-usage","value":"Often called from: recordDependencyOnOwner","count":4},{"name":"api-typical-usage","value":"Often called from: recordDependencyOnSingleRelExpr","count":4},{"name":"api-typical-usage","value":"Often called from: recordMultipleDependencies","count":4},{"name":"api-typical-usage","value":"Often called from: record_fields_have_hashing","count":4},{"name":"api-typical-usage","value":"Often called from: recursive_revoke","count":4},{"name":"api-typical-usage","value":"Often called from: reduce_outer_joins","count":4},{"name":"api-typical-usage","value":"Often called from: regclassin","count":4},{"name":"api-typical-usage","value":"Often called from: regcollationrecv","count":4},{"name":"api-typical-usage","value":"Often called from: regconfigin","count":4},{"name":"api-typical-usage","value":"Often called from: regdictionarysend","count":4},{"name":"api-typical-usage","value":"Often called from: regexeqjoinsel","count":4},{"name":"api-typical-usage","value":"Often called from: regexeqsel","count":4},{"name":"api-typical-usage","value":"Often called from: regexp_instr","count":4},{"name":"api-typical-usage","value":"Often called from: regexp_instr_no_n","count":4},{"name":"api-typical-usage","value":"Often called from: regprocout","count":4},{"name":"api-typical-usage","value":"Often called from: reindex_all_databases","count":4},{"name":"api-typical-usage","value":"Often called from: relation_excluded_by_constraints","count":4},{"name":"api-typical-usage","value":"Often called from: relation_is_updatable","count":4},{"name":"api-typical-usage","value":"Often called from: relation_needs_vacanalyze","count":4},{"name":"api-typical-usage","value":"Often called from: relation_openrv_extended","count":4},{"name":"api-typical-usage","value":"Often called from: remove_nulling_relids_mutator","count":4},{"name":"api-typical-usage","value":"Often called from: remove_rel_from_query","count":4},{"name":"api-typical-usage","value":"Often called from: remove_rel_from_restrictinfo","count":4},{"name":"api-typical-usage","value":"Often called from: repairDependencyLoop","count":4},{"name":"api-typical-usage","value":"Often called from: replace_s","count":4},{"name":"api-typical-usage","value":"Often called from: reschedule_timeouts","count":4},{"name":"api-typical-usage","value":"Often called from: reserve_wal_for_local_slot","count":4},{"name":"api-typical-usage","value":"Often called from: resolve_special_varno","count":4},{"name":"api-typical-usage","value":"Often called from: rewriteValuesRTE","count":4},{"name":"api-typical-usage","value":"Often called from: ri_ReportViolation","count":4},{"name":"api-typical-usage","value":"Often called from: runInitSteps","count":4},{"name":"api-typical-usage","value":"Often called from: schema_does_not_exist_skipping","count":4},{"name":"api-typical-usage","value":"Often called from: selectDumpableObject","count":4},{"name":"api-typical-usage","value":"Often called from: select_mergejoin_clauses","count":4},{"name":"api-typical-usage","value":"Often called from: serialize_variable","count":4},{"name":"api-typical-usage","value":"Often called from: setNamespaceForMergeWhen","count":4},{"name":"api-typical-usage","value":"Often called from: setPathArray","count":4},{"name":"api-typical-usage","value":"Often called from: setQFout","count":4},{"name":"api-typical-usage","value":"Often called from: set_append_rel_size","count":4},{"name":"api-typical-usage","value":"Often called from: set_info_version","count":4},{"name":"api-typical-usage","value":"Often called from: set_interp_require","count":4},{"name":"api-typical-usage","value":"Often called from: set_join_column_names","count":4},{"name":"api-typical-usage","value":"Often called from: set_joinrel_partition_key_exprs","count":4},{"name":"api-typical-usage","value":"Often called from: set_locale_and_encoding","count":4},{"name":"api-typical-usage","value":"Often called from: set_values_size_estimates","count":4},{"name":"api-typical-usage","value":"Often called from: setlocales","count":4},{"name":"api-typical-usage","value":"Often called from: setup_connection","count":4},{"name":"api-typical-usage","value":"Often called from: shiftList","count":4},{"name":"api-typical-usage","value":"Often called from: shift_jis_20042euc_jis_2004","count":4},{"name":"api-typical-usage","value":"Often called from: shm_mq_receive","count":4},{"name":"api-typical-usage","value":"Often called from: show_incremental_sort_group_info","count":4},{"name":"api-typical-usage","value":"Often called from: show_merge_append_keys","count":4},{"name":"api-typical-usage","value":"Often called from: show_modifytable_info","count":4},{"name":"api-typical-usage","value":"Often called from: show_sort_group_keys","count":4},{"name":"api-typical-usage","value":"Often called from: simple_table_tuple_insert","count":4},{"name":"api-typical-usage","value":"Often called from: simplify_boolean_equality","count":4},{"name":"api-typical-usage","value":"Often called from: sind_0_to_30","count":4},{"name":"api-typical-usage","value":"Often called from: slotNoNulls","count":4},{"name":"api-typical-usage","value":"Often called from: slurpFile","count":4},{"name":"api-typical-usage","value":"Often called from: smgr_bulk_start_smgr","count":4},{"name":"api-typical-usage","value":"Often called from: socket_putmessage","count":4},{"name":"api-typical-usage","value":"Often called from: spgFormInnerTuple","count":4},{"name":"api-typical-usage","value":"Often called from: spgFormLeafTuple","count":4},{"name":"api-typical-usage","value":"Often called from: spg_quad_picksplit","count":4},{"name":"api-typical-usage","value":"Often called from: spg_range_quad_choose","count":4},{"name":"api-typical-usage","value":"Often called from: spg_range_quad_leaf_consistent","count":4},{"name":"api-typical-usage","value":"Often called from: spg_text_choose","count":4},{"name":"api-typical-usage","value":"Often called from: spg_text_leaf_consistent","count":4},{"name":"api-typical-usage","value":"Often called from: spgcanreturn","count":4},{"name":"api-typical-usage","value":"Often called from: spginsert","count":4},{"name":"api-typical-usage","value":"Often called from: spgvacuumpage","count":4},{"name":"api-typical-usage","value":"Often called from: spi_dest_startup","count":4},{"name":"api-typical-usage","value":"Often called from: splitTzLine","count":4},{"name":"api-typical-usage","value":"Often called from: standard_ExecutorEnd","count":4},{"name":"api-typical-usage","value":"Often called from: standard_qp_callback","count":4},{"name":"api-typical-usage","value":"Often called from: statement_timestamp","count":4},{"name":"api-typical-usage","value":"Often called from: stream_open_file","count":4},{"name":"api-typical-usage","value":"Often called from: strip_implicit_coercions","count":4},{"name":"api-typical-usage","value":"Often called from: strip_lineno_from_objdesc","count":4},{"name":"api-typical-usage","value":"Often called from: sts_puttuple","count":4},{"name":"api-typical-usage","value":"Often called from: sts_read_tuple","count":4},{"name":"api-typical-usage","value":"Often called from: subcoloronerange","count":4},{"name":"api-typical-usage","value":"Often called from: sv2cstr","count":4},{"name":"api-typical-usage","value":"Often called from: switchToPresortedPrefixMode","count":4},{"name":"api-typical-usage","value":"Often called from: table_to_xml_and_xmlschema","count":4},{"name":"api-typical-usage","value":"Often called from: tar_get_file_size","count":4},{"name":"api-typical-usage","value":"Often called from: tbm_advance_schunkbit","count":4},{"name":"api-typical-usage","value":"Often called from: tbm_begin_iterate","count":4},{"name":"api-typical-usage","value":"Often called from: test_lockmode_for_conflict","count":4},{"name":"api-typical-usage","value":"Often called from: test_open_syncs","count":4},{"name":"api-typical-usage","value":"Often called from: test_strlower","count":4},{"name":"api-typical-usage","value":"Often called from: text_format_parse_format","count":4},{"name":"api-typical-usage","value":"Often called from: text_format_string_conversion","count":4},{"name":"api-typical-usage","value":"Often called from: text_left","count":4},{"name":"api-typical-usage","value":"Often called from: text_name","count":4},{"name":"api-typical-usage","value":"Often called from: text_overlay","count":4},{"name":"api-typical-usage","value":"Often called from: text_pattern_ge","count":4},{"name":"api-typical-usage","value":"Often called from: texticregexne","count":4},{"name":"api-typical-usage","value":"Often called from: textne","count":4},{"name":"api-typical-usage","value":"Often called from: textnlike","count":4},{"name":"api-typical-usage","value":"Often called from: textregexeq_support","count":4},{"name":"api-typical-usage","value":"Often called from: textregexreplace","count":4},{"name":"api-typical-usage","value":"Often called from: tfuncInitialize","count":4},{"name":"api-typical-usage","value":"Often called from: thesaurusRead","count":4},{"name":"api-typical-usage","value":"Often called from: thesaurus_lexize","count":4},{"name":"api-typical-usage","value":"Often called from: time_recv","count":4},{"name":"api-typical-usage","value":"Often called from: timerange_option","count":4},{"name":"api-typical-usage","value":"Often called from: timestamp_eq_date","count":4},{"name":"api-typical-usage","value":"Often called from: timestamp_eq_timestamptz","count":4},{"name":"api-typical-usage","value":"Often called from: timestamptz_ge_date","count":4},{"name":"api-typical-usage","value":"Often called from: timestamptz_timetz","count":4},{"name":"api-typical-usage","value":"Often called from: timetz_time","count":4},{"name":"api-typical-usage","value":"Often called from: timetz_zone","count":4},{"name":"api-typical-usage","value":"Often called from: to_ascii_encname","count":4},{"name":"api-typical-usage","value":"Often called from: to_bin64","count":4},{"name":"api-typical-usage","value":"Often called from: toast_flatten_tuple","count":4},{"name":"api-typical-usage","value":"Often called from: toast_save_datum","count":4},{"name":"api-typical-usage","value":"Often called from: toast_tuple_externalize","count":4},{"name":"api-typical-usage","value":"Often called from: toast_tuple_init","count":4},{"name":"api-typical-usage","value":"Often called from: tokenize_auth_file","count":4},{"name":"api-typical-usage","value":"Often called from: transfer_all_new_tablespaces","count":4},{"name":"api-typical-usage","value":"Often called from: transformCaseExpr","count":4},{"name":"api-typical-usage","value":"Often called from: transformCreateSchemaStmtElements","count":4},{"name":"api-typical-usage","value":"Often called from: transformGroupingSet","count":4},{"name":"api-typical-usage","value":"Often called from: transformJoinUsingClause","count":4},{"name":"api-typical-usage","value":"Often called from: transformJsonObjectAgg","count":4},{"name":"api-typical-usage","value":"Often called from: transformJsonParseExpr","count":4},{"name":"api-typical-usage","value":"Often called from: transformOfType","count":4},{"name":"api-typical-usage","value":"Often called from: transformXmlExpr","count":4},{"name":"api-typical-usage","value":"Often called from: transientrel_shutdown","count":4},{"name":"api-typical-usage","value":"Often called from: transtime","count":4},{"name":"api-typical-usage","value":"Often called from: trim_directory","count":4},{"name":"api-typical-usage","value":"Often called from: ts_lexize","count":4},{"name":"api-typical-usage","value":"Often called from: ts_rankcd_ttf","count":4},{"name":"api-typical-usage","value":"Often called from: tsquery_opr_selec","count":4},{"name":"api-typical-usage","value":"Often called from: tsquery_requires_match","count":4},{"name":"api-typical-usage","value":"Often called from: tsquerysend","count":4},{"name":"api-typical-usage","value":"Often called from: tsvector_lt","count":4},{"name":"api-typical-usage","value":"Often called from: tsvector_ne","count":4},{"name":"api-typical-usage","value":"Often called from: tts_buffer_heap_copyslot","count":4},{"name":"api-typical-usage","value":"Often called from: tts_heap_store_tuple","count":4},{"name":"api-typical-usage","value":"Often called from: tts_minimal_copy_minimal_tuple","count":4},{"name":"api-typical-usage","value":"Often called from: tuplesort_begin_index_hash","count":4},{"name":"api-typical-usage","value":"Often called from: tuplesort_heap_delete_top","count":4},{"name":"api-typical-usage","value":"Often called from: tuplesort_heap_replace_top","count":4},{"name":"api-typical-usage","value":"Often called from: tuplesort_putdatum","count":4},{"name":"api-typical-usage","value":"Often called from: tuplesort_puttupleslot","count":4},{"name":"api-typical-usage","value":"Often called from: tuplestore_puttuple_common","count":4},{"name":"api-typical-usage","value":"Often called from: typeDepNeeded","count":4},{"name":"api-typical-usage","value":"Often called from: uniqueWORD","count":4},{"name":"api-typical-usage","value":"Often called from: unlink_segment","count":4},{"name":"api-typical-usage","value":"Often called from: updateAclDependenciesWorker","count":4},{"name":"api-typical-usage","value":"Often called from: utf8_to_iso8859_1","count":4},{"name":"api-typical-usage","value":"Often called from: utf8_to_win","count":4},{"name":"api-typical-usage","value":"Often called from: utf_e2u","count":4},{"name":"api-typical-usage","value":"Often called from: utf_u2e","count":4},{"name":"api-typical-usage","value":"Often called from: uuid_lt","count":4},{"name":"api-typical-usage","value":"Often called from: vac_truncate_clog","count":4},{"name":"api-typical-usage","value":"Often called from: vacuumLeafRoot","count":4},{"name":"api-typical-usage","value":"Often called from: vacuum_open_relation","count":4},{"name":"api-typical-usage","value":"Often called from: validatePartitionedIndex","count":4},{"name":"api-typical-usage","value":"Often called from: validate_compress_specification","count":4},{"name":"api-typical-usage","value":"Often called from: var_eq_const","count":4},{"name":"api-typical-usage","value":"Often called from: varbit","count":4},{"name":"api-typical-usage","value":"Often called from: varbit_support","count":4},{"name":"api-typical-usage","value":"Often called from: varlenafastcmp_locale","count":4},{"name":"api-typical-usage","value":"Often called from: varstr_abbrev_abort","count":4},{"name":"api-typical-usage","value":"Often called from: varstr_abbrev_convert","count":4},{"name":"api-typical-usage","value":"Often called from: verify_btree_slot_handler","count":4},{"name":"api-typical-usage","value":"Often called from: verify_control_file","count":4},{"name":"api-typical-usage","value":"Often called from: verify_file_checksum","count":4},{"name":"api-typical-usage","value":"Often called from: visibilitymap_set","count":4},{"name":"api-typical-usage","value":"Often called from: wait_for_postmaster_promote","count":4},{"name":"api-typical-usage","value":"Often called from: wait_for_postmaster_stop","count":4},{"name":"api-typical-usage","value":"Often called from: wait_for_relation_state_change","count":4},{"name":"api-typical-usage","value":"Often called from: wait_on_socket_set","count":4},{"name":"api-typical-usage","value":"Often called from: wait_result_is_any_signal","count":4},{"name":"api-typical-usage","value":"Often called from: whenever_action","count":4},{"name":"api-typical-usage","value":"Often called from: win32_read_locale","count":4},{"name":"api-typical-usage","value":"Often called from: window_lead_with_offset","count":4},{"name":"api-typical-usage","value":"Often called from: write_csvlog","count":4},{"name":"api-typical-usage","value":"Often called from: write_reconstructed_file","count":4},{"name":"api-typical-usage","value":"Often called from: writetup_cluster","count":4},{"name":"api-typical-usage","value":"Often called from: xactGetCommittedInvalidationMessages","count":4},{"name":"api-typical-usage","value":"Often called from: xact_redo_commit","count":4},{"name":"api-typical-usage","value":"Often called from: xid8_smaller","count":4},{"name":"api-typical-usage","value":"Often called from: xidin","count":4},{"name":"api-typical-usage","value":"Often called from: xml_is_well_formed_content","count":4},{"name":"arch-layer","value":"backend-entry","count":4},{"name":"arch-layer-description","value":"Backend entry points (main, postmaster)","count":4},{"name":"coupling-score","value":"137","count":4},{"name":"coupling-score","value":"64","count":4},{"name":"coupling-score","value":"65","count":4},{"name":"coupling-score","value":"66","count":4},{"name":"coupling-score","value":"69","count":4},{"name":"coupling-score","value":"74","count":4},{"name":"coupling-score","value":"79","count":4},{"name":"coupling-score","value":"81","count":4},{"name":"coupling-score","value":"83","count":4},{"name":"coupling-score","value":"84","count":4},{"name":"coupling-score","value":"86","count":4},{"name":"coupling-score","value":"87","count":4},{"name":"coupling-score","value":"89","count":4},{"name":"coupling-score","value":"92","count":4},{"name":"coupling-score","value":"97","count":4},{"name":"cyclomatic-complexity","value":"1038","count":4},{"name":"cyclomatic-complexity","value":"1056","count":4},{"name":"cyclomatic-complexity","value":"106","count":4},{"name":"cyclomatic-complexity","value":"1077","count":4},{"name":"cyclomatic-complexity","value":"1114","count":4},{"name":"cyclomatic-complexity","value":"1120","count":4},{"name":"cyclomatic-complexity","value":"1137","count":4},{"name":"cyclomatic-complexity","value":"1156","count":4},{"name":"cyclomatic-complexity","value":"1201","count":4},{"name":"cyclomatic-complexity","value":"1211","count":4},{"name":"cyclomatic-complexity","value":"1212","count":4},{"name":"cyclomatic-complexity","value":"125","count":4},{"name":"cyclomatic-complexity","value":"137","count":4},{"name":"cyclomatic-complexity","value":"149","count":4},{"name":"cyclomatic-complexity","value":"1496","count":4},{"name":"cyclomatic-complexity","value":"151","count":4},{"name":"cyclomatic-complexity","value":"1535","count":4},{"name":"cyclomatic-complexity","value":"156","count":4},{"name":"cyclomatic-complexity","value":"1615","count":4},{"name":"cyclomatic-complexity","value":"162","count":4},{"name":"cyclomatic-complexity","value":"1649","count":4},{"name":"cyclomatic-complexity","value":"1659","count":4},{"name":"cyclomatic-complexity","value":"169","count":4},{"name":"cyclomatic-complexity","value":"179","count":4},{"name":"cyclomatic-complexity","value":"180","count":4},{"name":"cyclomatic-complexity","value":"181","count":4},{"name":"cyclomatic-complexity","value":"183","count":4},{"name":"cyclomatic-complexity","value":"186","count":4},{"name":"cyclomatic-complexity","value":"189","count":4},{"name":"cyclomatic-complexity","value":"192","count":4},{"name":"cyclomatic-complexity","value":"195","count":4},{"name":"cyclomatic-complexity","value":"198","count":4},{"name":"cyclomatic-complexity","value":"203","count":4},{"name":"cyclomatic-complexity","value":"205","count":4},{"name":"cyclomatic-complexity","value":"207","count":4},{"name":"cyclomatic-complexity","value":"210","count":4},{"name":"cyclomatic-complexity","value":"212","count":4},{"name":"cyclomatic-complexity","value":"215","count":4},{"name":"cyclomatic-complexity","value":"218","count":4},{"name":"cyclomatic-complexity","value":"219","count":4},{"name":"cyclomatic-complexity","value":"222","count":4},{"name":"cyclomatic-complexity","value":"2224","count":4},{"name":"cyclomatic-complexity","value":"223","count":4},{"name":"cyclomatic-complexity","value":"225","count":4},{"name":"cyclomatic-complexity","value":"226","count":4},{"name":"cyclomatic-complexity","value":"227","count":4},{"name":"cyclomatic-complexity","value":"2318","count":4},{"name":"cyclomatic-complexity","value":"233","count":4},{"name":"cyclomatic-complexity","value":"238","count":4},{"name":"cyclomatic-complexity","value":"239","count":4},{"name":"cyclomatic-complexity","value":"242","count":4},{"name":"cyclomatic-complexity","value":"243","count":4},{"name":"cyclomatic-complexity","value":"245","count":4},{"name":"cyclomatic-complexity","value":"252","count":4},{"name":"cyclomatic-complexity","value":"255","count":4},{"name":"cyclomatic-complexity","value":"256","count":4},{"name":"cyclomatic-complexity","value":"258","count":4},{"name":"cyclomatic-complexity","value":"263","count":4},{"name":"cyclomatic-complexity","value":"265","count":4},{"name":"cyclomatic-complexity","value":"266","count":4},{"name":"cyclomatic-complexity","value":"269","count":4},{"name":"cyclomatic-complexity","value":"271","count":4},{"name":"cyclomatic-complexity","value":"273","count":4},{"name":"cyclomatic-complexity","value":"274","count":4},{"name":"cyclomatic-complexity","value":"277","count":4},{"name":"cyclomatic-complexity","value":"278","count":4},{"name":"cyclomatic-complexity","value":"279","count":4},{"name":"cyclomatic-complexity","value":"288","count":4},{"name":"cyclomatic-complexity","value":"295","count":4},{"name":"cyclomatic-complexity","value":"297","count":4},{"name":"cyclomatic-complexity","value":"300","count":4},{"name":"cyclomatic-complexity","value":"301","count":4},{"name":"cyclomatic-complexity","value":"303","count":4},{"name":"cyclomatic-complexity","value":"304","count":4},{"name":"cyclomatic-complexity","value":"307","count":4},{"name":"cyclomatic-complexity","value":"315","count":4},{"name":"cyclomatic-complexity","value":"316","count":4},{"name":"cyclomatic-complexity","value":"318","count":4},{"name":"cyclomatic-complexity","value":"319","count":4},{"name":"cyclomatic-complexity","value":"321","count":4},{"name":"cyclomatic-complexity","value":"322","count":4},{"name":"cyclomatic-complexity","value":"325","count":4},{"name":"cyclomatic-complexity","value":"330","count":4},{"name":"cyclomatic-complexity","value":"337","count":4},{"name":"cyclomatic-complexity","value":"344","count":4},{"name":"cyclomatic-complexity","value":"346","count":4},{"name":"cyclomatic-complexity","value":"349","count":4},{"name":"cyclomatic-complexity","value":"355","count":4},{"name":"cyclomatic-complexity","value":"358","count":4},{"name":"cyclomatic-complexity","value":"359","count":4},{"name":"cyclomatic-complexity","value":"361","count":4},{"name":"cyclomatic-complexity","value":"362","count":4},{"name":"cyclomatic-complexity","value":"363","count":4},{"name":"cyclomatic-complexity","value":"3659","count":4},{"name":"cyclomatic-complexity","value":"366","count":4},{"name":"cyclomatic-complexity","value":"370","count":4},{"name":"cyclomatic-complexity","value":"371","count":4},{"name":"cyclomatic-complexity","value":"374","count":4},{"name":"cyclomatic-complexity","value":"382","count":4},{"name":"cyclomatic-complexity","value":"383","count":4},{"name":"cyclomatic-complexity","value":"399","count":4},{"name":"cyclomatic-complexity","value":"404","count":4},{"name":"cyclomatic-complexity","value":"412","count":4},{"name":"cyclomatic-complexity","value":"415","count":4},{"name":"cyclomatic-complexity","value":"417","count":4},{"name":"cyclomatic-complexity","value":"419","count":4},{"name":"cyclomatic-complexity","value":"421","count":4},{"name":"cyclomatic-complexity","value":"425","count":4},{"name":"cyclomatic-complexity","value":"430","count":4},{"name":"cyclomatic-complexity","value":"440","count":4},{"name":"cyclomatic-complexity","value":"450","count":4},{"name":"cyclomatic-complexity","value":"455","count":4},{"name":"cyclomatic-complexity","value":"459","count":4},{"name":"cyclomatic-complexity","value":"467","count":4},{"name":"cyclomatic-complexity","value":"472","count":4},{"name":"cyclomatic-complexity","value":"476","count":4},{"name":"cyclomatic-complexity","value":"477","count":4},{"name":"cyclomatic-complexity","value":"490","count":4},{"name":"cyclomatic-complexity","value":"491","count":4},{"name":"cyclomatic-complexity","value":"495","count":4},{"name":"cyclomatic-complexity","value":"497","count":4},{"name":"cyclomatic-complexity","value":"503","count":4},{"name":"cyclomatic-complexity","value":"508","count":4},{"name":"cyclomatic-complexity","value":"511","count":4},{"name":"cyclomatic-complexity","value":"512","count":4},{"name":"cyclomatic-complexity","value":"516","count":4},{"name":"cyclomatic-complexity","value":"526","count":4},{"name":"cyclomatic-complexity","value":"530","count":4},{"name":"cyclomatic-complexity","value":"536","count":4},{"name":"cyclomatic-complexity","value":"539","count":4},{"name":"cyclomatic-complexity","value":"548","count":4},{"name":"cyclomatic-complexity","value":"549","count":4},{"name":"cyclomatic-complexity","value":"569","count":4},{"name":"cyclomatic-complexity","value":"574","count":4},{"name":"cyclomatic-complexity","value":"578","count":4},{"name":"cyclomatic-complexity","value":"583","count":4},{"name":"cyclomatic-complexity","value":"585","count":4},{"name":"cyclomatic-complexity","value":"590","count":4},{"name":"cyclomatic-complexity","value":"592","count":4},{"name":"cyclomatic-complexity","value":"596","count":4},{"name":"cyclomatic-complexity","value":"598","count":4},{"name":"cyclomatic-complexity","value":"604","count":4},{"name":"cyclomatic-complexity","value":"608","count":4},{"name":"cyclomatic-complexity","value":"610","count":4},{"name":"cyclomatic-complexity","value":"631","count":4},{"name":"cyclomatic-complexity","value":"632","count":4},{"name":"cyclomatic-complexity","value":"643","count":4},{"name":"cyclomatic-complexity","value":"671","count":4},{"name":"cyclomatic-complexity","value":"676","count":4},{"name":"cyclomatic-complexity","value":"688","count":4},{"name":"cyclomatic-complexity","value":"704","count":4},{"name":"cyclomatic-complexity","value":"710","count":4},{"name":"cyclomatic-complexity","value":"720","count":4},{"name":"cyclomatic-complexity","value":"722","count":4},{"name":"cyclomatic-complexity","value":"732","count":4},{"name":"cyclomatic-complexity","value":"740","count":4},{"name":"cyclomatic-complexity","value":"752","count":4},{"name":"cyclomatic-complexity","value":"777","count":4},{"name":"cyclomatic-complexity","value":"778","count":4},{"name":"cyclomatic-complexity","value":"796","count":4},{"name":"cyclomatic-complexity","value":"803","count":4},{"name":"cyclomatic-complexity","value":"815","count":4},{"name":"cyclomatic-complexity","value":"825","count":4},{"name":"cyclomatic-complexity","value":"841","count":4},{"name":"cyclomatic-complexity","value":"864","count":4},{"name":"cyclomatic-complexity","value":"873","count":4},{"name":"cyclomatic-complexity","value":"884","count":4},{"name":"cyclomatic-complexity","value":"888","count":4},{"name":"cyclomatic-complexity","value":"892","count":4},{"name":"cyclomatic-complexity","value":"896","count":4},{"name":"cyclomatic-complexity","value":"908","count":4},{"name":"cyclomatic-complexity","value":"950","count":4},{"name":"cyclomatic-complexity","value":"967","count":4},{"name":"cyclomatic-complexity","value":"991","count":4},{"name":"lines-of-code","value":"0","count":4},{"name":"lines-of-code","value":"1005","count":4},{"name":"lines-of-code","value":"1007","count":4},{"name":"lines-of-code","value":"1009","count":4},{"name":"lines-of-code","value":"1012","count":4},{"name":"lines-of-code","value":"1017","count":4},{"name":"lines-of-code","value":"1024","count":4},{"name":"lines-of-code","value":"1025","count":4},{"name":"lines-of-code","value":"1029","count":4},{"name":"lines-of-code","value":"1030","count":4},{"name":"lines-of-code","value":"1036","count":4},{"name":"lines-of-code","value":"1039","count":4},{"name":"lines-of-code","value":"1040","count":4},{"name":"lines-of-code","value":"1042","count":4},{"name":"lines-of-code","value":"1043","count":4},{"name":"lines-of-code","value":"1044","count":4},{"name":"lines-of-code","value":"1045","count":4},{"name":"lines-of-code","value":"1046","count":4},{"name":"lines-of-code","value":"1047","count":4},{"name":"lines-of-code","value":"1052","count":4},{"name":"lines-of-code","value":"1054","count":4},{"name":"lines-of-code","value":"1055","count":4},{"name":"lines-of-code","value":"1057","count":4},{"name":"lines-of-code","value":"10600","count":4},{"name":"lines-of-code","value":"1061","count":4},{"name":"lines-of-code","value":"1064","count":4},{"name":"lines-of-code","value":"1069","count":4},{"name":"lines-of-code","value":"1076","count":4},{"name":"lines-of-code","value":"1079","count":4},{"name":"lines-of-code","value":"1083","count":4},{"name":"lines-of-code","value":"1084","count":4},{"name":"lines-of-code","value":"1088","count":4},{"name":"lines-of-code","value":"1090","count":4},{"name":"lines-of-code","value":"1091","count":4},{"name":"lines-of-code","value":"1092","count":4},{"name":"lines-of-code","value":"1095","count":4},{"name":"lines-of-code","value":"1099","count":4},{"name":"lines-of-code","value":"1103","count":4},{"name":"lines-of-code","value":"1104","count":4},{"name":"lines-of-code","value":"1105","count":4},{"name":"lines-of-code","value":"1114","count":4},{"name":"lines-of-code","value":"1124","count":4},{"name":"lines-of-code","value":"1125","count":4},{"name":"lines-of-code","value":"1126","count":4},{"name":"lines-of-code","value":"1127","count":4},{"name":"lines-of-code","value":"1128","count":4},{"name":"lines-of-code","value":"1131","count":4},{"name":"lines-of-code","value":"1133","count":4},{"name":"lines-of-code","value":"1138","count":4},{"name":"lines-of-code","value":"1141","count":4},{"name":"lines-of-code","value":"1152","count":4},{"name":"lines-of-code","value":"1154","count":4},{"name":"lines-of-code","value":"1158","count":4},{"name":"lines-of-code","value":"1164","count":4},{"name":"lines-of-code","value":"1169","count":4},{"name":"lines-of-code","value":"1181","count":4},{"name":"lines-of-code","value":"1183","count":4},{"name":"lines-of-code","value":"1190","count":4},{"name":"lines-of-code","value":"1192","count":4},{"name":"lines-of-code","value":"1195","count":4},{"name":"lines-of-code","value":"1196","count":4},{"name":"lines-of-code","value":"1197","count":4},{"name":"lines-of-code","value":"1202","count":4},{"name":"lines-of-code","value":"1204","count":4},{"name":"lines-of-code","value":"1206","count":4},{"name":"lines-of-code","value":"1209","count":4},{"name":"lines-of-code","value":"1212","count":4},{"name":"lines-of-code","value":"1222","count":4},{"name":"lines-of-code","value":"1223","count":4},{"name":"lines-of-code","value":"12280","count":4},{"name":"lines-of-code","value":"1232","count":4},{"name":"lines-of-code","value":"1234","count":4},{"name":"lines-of-code","value":"1239","count":4},{"name":"lines-of-code","value":"1246","count":4},{"name":"lines-of-code","value":"1251","count":4},{"name":"lines-of-code","value":"1252","count":4},{"name":"lines-of-code","value":"1253","count":4},{"name":"lines-of-code","value":"1256","count":4},{"name":"lines-of-code","value":"1258","count":4},{"name":"lines-of-code","value":"1259","count":4},{"name":"lines-of-code","value":"1261","count":4},{"name":"lines-of-code","value":"1262","count":4},{"name":"lines-of-code","value":"1270","count":4},{"name":"lines-of-code","value":"1271","count":4},{"name":"lines-of-code","value":"1275","count":4},{"name":"lines-of-code","value":"1279","count":4},{"name":"lines-of-code","value":"1280","count":4},{"name":"lines-of-code","value":"1293","count":4},{"name":"lines-of-code","value":"1303","count":4},{"name":"lines-of-code","value":"1311","count":4},{"name":"lines-of-code","value":"1314","count":4},{"name":"lines-of-code","value":"1322","count":4},{"name":"lines-of-code","value":"1323","count":4},{"name":"lines-of-code","value":"1336","count":4},{"name":"lines-of-code","value":"13379","count":4},{"name":"lines-of-code","value":"1341","count":4},{"name":"lines-of-code","value":"1344","count":4},{"name":"lines-of-code","value":"1352","count":4},{"name":"lines-of-code","value":"1357","count":4},{"name":"lines-of-code","value":"1360","count":4},{"name":"lines-of-code","value":"1386","count":4},{"name":"lines-of-code","value":"1388","count":4},{"name":"lines-of-code","value":"1392","count":4},{"name":"lines-of-code","value":"1393","count":4},{"name":"lines-of-code","value":"1397","count":4},{"name":"lines-of-code","value":"1399","count":4},{"name":"lines-of-code","value":"1401","count":4},{"name":"lines-of-code","value":"1403","count":4},{"name":"lines-of-code","value":"1405","count":4},{"name":"lines-of-code","value":"1430","count":4},{"name":"lines-of-code","value":"1445","count":4},{"name":"lines-of-code","value":"1447","count":4},{"name":"lines-of-code","value":"1448","count":4},{"name":"lines-of-code","value":"1454","count":4},{"name":"lines-of-code","value":"1460","count":4},{"name":"lines-of-code","value":"1468","count":4},{"name":"lines-of-code","value":"1492","count":4},{"name":"lines-of-code","value":"1503","count":4},{"name":"lines-of-code","value":"1513","count":4},{"name":"lines-of-code","value":"1516","count":4},{"name":"lines-of-code","value":"1522","count":4},{"name":"lines-of-code","value":"1523","count":4},{"name":"lines-of-code","value":"1530","count":4},{"name":"lines-of-code","value":"1532","count":4},{"name":"lines-of-code","value":"1535","count":4},{"name":"lines-of-code","value":"1549","count":4},{"name":"lines-of-code","value":"1557","count":4},{"name":"lines-of-code","value":"1558","count":4},{"name":"lines-of-code","value":"1569","count":4},{"name":"lines-of-code","value":"1579","count":4},{"name":"lines-of-code","value":"1584","count":4},{"name":"lines-of-code","value":"1588","count":4},{"name":"lines-of-code","value":"1593","count":4},{"name":"lines-of-code","value":"1597","count":4},{"name":"lines-of-code","value":"1598","count":4},{"name":"lines-of-code","value":"1617","count":4},{"name":"lines-of-code","value":"1628","count":4},{"name":"lines-of-code","value":"1633","count":4},{"name":"lines-of-code","value":"1637","count":4},{"name":"lines-of-code","value":"1639","count":4},{"name":"lines-of-code","value":"1649","count":4},{"name":"lines-of-code","value":"1652","count":4},{"name":"lines-of-code","value":"1678","count":4},{"name":"lines-of-code","value":"1687","count":4},{"name":"lines-of-code","value":"1691","count":4},{"name":"lines-of-code","value":"1693","count":4},{"name":"lines-of-code","value":"1701","count":4},{"name":"lines-of-code","value":"1706","count":4},{"name":"lines-of-code","value":"1709","count":4},{"name":"lines-of-code","value":"1714","count":4},{"name":"lines-of-code","value":"1722","count":4},{"name":"lines-of-code","value":"1724","count":4},{"name":"lines-of-code","value":"1726","count":4},{"name":"lines-of-code","value":"1742","count":4},{"name":"lines-of-code","value":"1743","count":4},{"name":"lines-of-code","value":"1747","count":4},{"name":"lines-of-code","value":"1759","count":4},{"name":"lines-of-code","value":"1761","count":4},{"name":"lines-of-code","value":"1765","count":4},{"name":"lines-of-code","value":"1768","count":4},{"name":"lines-of-code","value":"1777","count":4},{"name":"lines-of-code","value":"1788","count":4},{"name":"lines-of-code","value":"17925","count":4},{"name":"lines-of-code","value":"1797","count":4},{"name":"lines-of-code","value":"1799","count":4},{"name":"lines-of-code","value":"1801","count":4},{"name":"lines-of-code","value":"1816","count":4},{"name":"lines-of-code","value":"1837","count":4},{"name":"lines-of-code","value":"1849","count":4},{"name":"lines-of-code","value":"1870","count":4},{"name":"lines-of-code","value":"1877","count":4},{"name":"lines-of-code","value":"1886","count":4},{"name":"lines-of-code","value":"1890","count":4},{"name":"lines-of-code","value":"1894","count":4},{"name":"lines-of-code","value":"1906","count":4},{"name":"lines-of-code","value":"1907","count":4},{"name":"lines-of-code","value":"19159","count":4},{"name":"lines-of-code","value":"1917","count":4},{"name":"lines-of-code","value":"1946","count":4},{"name":"lines-of-code","value":"1947","count":4},{"name":"lines-of-code","value":"1949","count":4},{"name":"lines-of-code","value":"1958","count":4},{"name":"lines-of-code","value":"1962","count":4},{"name":"lines-of-code","value":"1963","count":4},{"name":"lines-of-code","value":"1969","count":4},{"name":"lines-of-code","value":"1971","count":4},{"name":"lines-of-code","value":"1998","count":4},{"name":"lines-of-code","value":"2000","count":4},{"name":"lines-of-code","value":"2015","count":4},{"name":"lines-of-code","value":"20299","count":4},{"name":"lines-of-code","value":"2032","count":4},{"name":"lines-of-code","value":"2033","count":4},{"name":"lines-of-code","value":"2035","count":4},{"name":"lines-of-code","value":"2038","count":4},{"name":"lines-of-code","value":"2084","count":4},{"name":"lines-of-code","value":"2090","count":4},{"name":"lines-of-code","value":"2095","count":4},{"name":"lines-of-code","value":"2101","count":4},{"name":"lines-of-code","value":"2104","count":4},{"name":"lines-of-code","value":"2110","count":4},{"name":"lines-of-code","value":"2117","count":4},{"name":"lines-of-code","value":"2126","count":4},{"name":"lines-of-code","value":"2131","count":4},{"name":"lines-of-code","value":"2146","count":4},{"name":"lines-of-code","value":"2148","count":4},{"name":"lines-of-code","value":"2172","count":4},{"name":"lines-of-code","value":"2175","count":4},{"name":"lines-of-code","value":"2189","count":4},{"name":"lines-of-code","value":"2191","count":4},{"name":"lines-of-code","value":"2194","count":4},{"name":"lines-of-code","value":"2200","count":4},{"name":"lines-of-code","value":"2208","count":4},{"name":"lines-of-code","value":"2224","count":4},{"name":"lines-of-code","value":"2245","count":4},{"name":"lines-of-code","value":"2263","count":4},{"name":"lines-of-code","value":"2267","count":4},{"name":"lines-of-code","value":"2281","count":4},{"name":"lines-of-code","value":"2282","count":4},{"name":"lines-of-code","value":"2298","count":4},{"name":"lines-of-code","value":"2323","count":4},{"name":"lines-of-code","value":"2339","count":4},{"name":"lines-of-code","value":"2342","count":4},{"name":"lines-of-code","value":"2357","count":4},{"name":"lines-of-code","value":"2361","count":4},{"name":"lines-of-code","value":"2390","count":4},{"name":"lines-of-code","value":"2406","count":4},{"name":"lines-of-code","value":"2409","count":4},{"name":"lines-of-code","value":"2418","count":4},{"name":"lines-of-code","value":"2426","count":4},{"name":"lines-of-code","value":"2432","count":4},{"name":"lines-of-code","value":"2433","count":4},{"name":"lines-of-code","value":"2439","count":4},{"name":"lines-of-code","value":"2445","count":4},{"name":"lines-of-code","value":"2453","count":4},{"name":"lines-of-code","value":"2504","count":4},{"name":"lines-of-code","value":"2581","count":4},{"name":"lines-of-code","value":"2589","count":4},{"name":"lines-of-code","value":"2597","count":4},{"name":"lines-of-code","value":"2606","count":4},{"name":"lines-of-code","value":"2617","count":4},{"name":"lines-of-code","value":"2646","count":4},{"name":"lines-of-code","value":"2674","count":4},{"name":"lines-of-code","value":"268","count":4},{"name":"lines-of-code","value":"2682","count":4},{"name":"lines-of-code","value":"2685","count":4},{"name":"lines-of-code","value":"2724","count":4},{"name":"lines-of-code","value":"2782","count":4},{"name":"lines-of-code","value":"2812","count":4},{"name":"lines-of-code","value":"282","count":4},{"name":"lines-of-code","value":"2823","count":4},{"name":"lines-of-code","value":"2855","count":4},{"name":"lines-of-code","value":"2880","count":4},{"name":"lines-of-code","value":"2882","count":4},{"name":"lines-of-code","value":"2891","count":4},{"name":"lines-of-code","value":"2926","count":4},{"name":"lines-of-code","value":"2953","count":4},{"name":"lines-of-code","value":"2974","count":4},{"name":"lines-of-code","value":"300","count":4},{"name":"lines-of-code","value":"3001","count":4},{"name":"lines-of-code","value":"3004","count":4},{"name":"lines-of-code","value":"3010","count":4},{"name":"lines-of-code","value":"3017","count":4},{"name":"lines-of-code","value":"3023","count":4},{"name":"lines-of-code","value":"303","count":4},{"name":"lines-of-code","value":"3039","count":4},{"name":"lines-of-code","value":"3044","count":4},{"name":"lines-of-code","value":"3057","count":4},{"name":"lines-of-code","value":"3064","count":4},{"name":"lines-of-code","value":"3066","count":4},{"name":"lines-of-code","value":"3114","count":4},{"name":"lines-of-code","value":"312","count":4},{"name":"lines-of-code","value":"3137","count":4},{"name":"lines-of-code","value":"317","count":4},{"name":"lines-of-code","value":"3172","count":4},{"name":"lines-of-code","value":"3195","count":4},{"name":"lines-of-code","value":"3209","count":4},{"name":"lines-of-code","value":"3215","count":4},{"name":"lines-of-code","value":"322","count":4},{"name":"lines-of-code","value":"324","count":4},{"name":"lines-of-code","value":"3261","count":4},{"name":"lines-of-code","value":"328","count":4},{"name":"lines-of-code","value":"3300","count":4},{"name":"lines-of-code","value":"331","count":4},{"name":"lines-of-code","value":"335","count":4},{"name":"lines-of-code","value":"337","count":4},{"name":"lines-of-code","value":"3377","count":4},{"name":"lines-of-code","value":"3384","count":4},{"name":"lines-of-code","value":"343","count":4},{"name":"lines-of-code","value":"3437","count":4},{"name":"lines-of-code","value":"3473","count":4},{"name":"lines-of-code","value":"3541","count":4},{"name":"lines-of-code","value":"3554","count":4},{"name":"lines-of-code","value":"357","count":4},{"name":"lines-of-code","value":"3579","count":4},{"name":"lines-of-code","value":"3598","count":4},{"name":"lines-of-code","value":"3606","count":4},{"name":"lines-of-code","value":"3609","count":4},{"name":"lines-of-code","value":"3613","count":4},{"name":"lines-of-code","value":"365","count":4},{"name":"lines-of-code","value":"3653","count":4},{"name":"lines-of-code","value":"3672","count":4},{"name":"lines-of-code","value":"370","count":4},{"name":"lines-of-code","value":"3716","count":4},{"name":"lines-of-code","value":"374","count":4},{"name":"lines-of-code","value":"3759","count":4},{"name":"lines-of-code","value":"3767","count":4},{"name":"lines-of-code","value":"3772","count":4},{"name":"lines-of-code","value":"3776","count":4},{"name":"lines-of-code","value":"378","count":4},{"name":"lines-of-code","value":"3792","count":4},{"name":"lines-of-code","value":"380","count":4},{"name":"lines-of-code","value":"3822","count":4},{"name":"lines-of-code","value":"387","count":4},{"name":"lines-of-code","value":"3890","count":4},{"name":"lines-of-code","value":"3918","count":4},{"name":"lines-of-code","value":"393","count":4},{"name":"lines-of-code","value":"398","count":4},{"name":"lines-of-code","value":"4015","count":4},{"name":"lines-of-code","value":"403","count":4},{"name":"lines-of-code","value":"404","count":4},{"name":"lines-of-code","value":"4048","count":4},{"name":"lines-of-code","value":"4082","count":4},{"name":"lines-of-code","value":"409","count":4},{"name":"lines-of-code","value":"414","count":4},{"name":"lines-of-code","value":"416","count":4},{"name":"lines-of-code","value":"419","count":4},{"name":"lines-of-code","value":"420","count":4},{"name":"lines-of-code","value":"4229","count":4},{"name":"lines-of-code","value":"4233","count":4},{"name":"lines-of-code","value":"4247","count":4},{"name":"lines-of-code","value":"4290","count":4},{"name":"lines-of-code","value":"4297","count":4},{"name":"lines-of-code","value":"436","count":4},{"name":"lines-of-code","value":"4362","count":4},{"name":"lines-of-code","value":"4363","count":4},{"name":"lines-of-code","value":"438","count":4},{"name":"lines-of-code","value":"440","count":4},{"name":"lines-of-code","value":"442","count":4},{"name":"lines-of-code","value":"447","count":4},{"name":"lines-of-code","value":"448","count":4},{"name":"lines-of-code","value":"4487","count":4},{"name":"lines-of-code","value":"4494","count":4},{"name":"lines-of-code","value":"4500","count":4},{"name":"lines-of-code","value":"452","count":4},{"name":"lines-of-code","value":"454","count":4},{"name":"lines-of-code","value":"455","count":4},{"name":"lines-of-code","value":"4560","count":4},{"name":"lines-of-code","value":"4584","count":4},{"name":"lines-of-code","value":"463","count":4},{"name":"lines-of-code","value":"4664","count":4},{"name":"lines-of-code","value":"470","count":4},{"name":"lines-of-code","value":"4700","count":4},{"name":"lines-of-code","value":"4707","count":4},{"name":"lines-of-code","value":"474","count":4},{"name":"lines-of-code","value":"4752","count":4},{"name":"lines-of-code","value":"4755","count":4},{"name":"lines-of-code","value":"479","count":4},{"name":"lines-of-code","value":"4795","count":4},{"name":"lines-of-code","value":"481","count":4},{"name":"lines-of-code","value":"483","count":4},{"name":"lines-of-code","value":"485","count":4},{"name":"lines-of-code","value":"487","count":4},{"name":"lines-of-code","value":"4893","count":4},{"name":"lines-of-code","value":"492","count":4},{"name":"lines-of-code","value":"495","count":4},{"name":"lines-of-code","value":"4968","count":4},{"name":"lines-of-code","value":"4979","count":4},{"name":"lines-of-code","value":"498","count":4},{"name":"lines-of-code","value":"499","count":4},{"name":"lines-of-code","value":"502","count":4},{"name":"lines-of-code","value":"503","count":4},{"name":"lines-of-code","value":"504","count":4},{"name":"lines-of-code","value":"5048","count":4},{"name":"lines-of-code","value":"5049","count":4},{"name":"lines-of-code","value":"5053","count":4},{"name":"lines-of-code","value":"506","count":4},{"name":"lines-of-code","value":"5062","count":4},{"name":"lines-of-code","value":"5087","count":4},{"name":"lines-of-code","value":"510","count":4},{"name":"lines-of-code","value":"511","count":4},{"name":"lines-of-code","value":"5118","count":4},{"name":"lines-of-code","value":"514","count":4},{"name":"lines-of-code","value":"5142","count":4},{"name":"lines-of-code","value":"5159","count":4},{"name":"lines-of-code","value":"516","count":4},{"name":"lines-of-code","value":"517","count":4},{"name":"lines-of-code","value":"5182","count":4},{"name":"lines-of-code","value":"5184","count":4},{"name":"lines-of-code","value":"521","count":4},{"name":"lines-of-code","value":"5258","count":4},{"name":"lines-of-code","value":"526","count":4},{"name":"lines-of-code","value":"5266","count":4},{"name":"lines-of-code","value":"5317","count":4},{"name":"lines-of-code","value":"532","count":4},{"name":"lines-of-code","value":"534","count":4},{"name":"lines-of-code","value":"535","count":4},{"name":"lines-of-code","value":"538","count":4},{"name":"lines-of-code","value":"539","count":4},{"name":"lines-of-code","value":"5441","count":4},{"name":"lines-of-code","value":"548","count":4},{"name":"lines-of-code","value":"5492","count":4},{"name":"lines-of-code","value":"551","count":4},{"name":"lines-of-code","value":"554","count":4},{"name":"lines-of-code","value":"5562","count":4},{"name":"lines-of-code","value":"5592","count":4},{"name":"lines-of-code","value":"5600","count":4},{"name":"lines-of-code","value":"561","count":4},{"name":"lines-of-code","value":"562","count":4},{"name":"lines-of-code","value":"565","count":4},{"name":"lines-of-code","value":"566","count":4},{"name":"lines-of-code","value":"568","count":4},{"name":"lines-of-code","value":"570","count":4},{"name":"lines-of-code","value":"575","count":4},{"name":"lines-of-code","value":"577","count":4},{"name":"lines-of-code","value":"580","count":4},{"name":"lines-of-code","value":"581","count":4},{"name":"lines-of-code","value":"582","count":4},{"name":"lines-of-code","value":"585","count":4},{"name":"lines-of-code","value":"587","count":4},{"name":"lines-of-code","value":"588","count":4},{"name":"lines-of-code","value":"591","count":4},{"name":"lines-of-code","value":"596","count":4},{"name":"lines-of-code","value":"5978","count":4},{"name":"lines-of-code","value":"598","count":4},{"name":"lines-of-code","value":"600","count":4},{"name":"lines-of-code","value":"601","count":4},{"name":"lines-of-code","value":"605","count":4},{"name":"lines-of-code","value":"6075","count":4},{"name":"lines-of-code","value":"608","count":4},{"name":"lines-of-code","value":"611","count":4},{"name":"lines-of-code","value":"6114","count":4},{"name":"lines-of-code","value":"6122","count":4},{"name":"lines-of-code","value":"613","count":4},{"name":"lines-of-code","value":"615","count":4},{"name":"lines-of-code","value":"618","count":4},{"name":"lines-of-code","value":"621","count":4},{"name":"lines-of-code","value":"622","count":4},{"name":"lines-of-code","value":"628","count":4},{"name":"lines-of-code","value":"630","count":4},{"name":"lines-of-code","value":"631","count":4},{"name":"lines-of-code","value":"634","count":4},{"name":"lines-of-code","value":"637","count":4},{"name":"lines-of-code","value":"6384","count":4},{"name":"lines-of-code","value":"640","count":4},{"name":"lines-of-code","value":"641","count":4},{"name":"lines-of-code","value":"645","count":4},{"name":"lines-of-code","value":"648","count":4},{"name":"lines-of-code","value":"649","count":4},{"name":"lines-of-code","value":"650","count":4},{"name":"lines-of-code","value":"6504","count":4},{"name":"lines-of-code","value":"6513","count":4},{"name":"lines-of-code","value":"652","count":4},{"name":"lines-of-code","value":"653","count":4},{"name":"lines-of-code","value":"6542","count":4},{"name":"lines-of-code","value":"655","count":4},{"name":"lines-of-code","value":"656","count":4},{"name":"lines-of-code","value":"658","count":4},{"name":"lines-of-code","value":"661","count":4},{"name":"lines-of-code","value":"662","count":4},{"name":"lines-of-code","value":"6667","count":4},{"name":"lines-of-code","value":"6683","count":4},{"name":"lines-of-code","value":"6701","count":4},{"name":"lines-of-code","value":"676","count":4},{"name":"lines-of-code","value":"679","count":4},{"name":"lines-of-code","value":"682","count":4},{"name":"lines-of-code","value":"687","count":4},{"name":"lines-of-code","value":"690","count":4},{"name":"lines-of-code","value":"6901","count":4},{"name":"lines-of-code","value":"692","count":4},{"name":"lines-of-code","value":"6924","count":4},{"name":"lines-of-code","value":"6949","count":4},{"name":"lines-of-code","value":"695","count":4},{"name":"lines-of-code","value":"696","count":4},{"name":"lines-of-code","value":"699","count":4},{"name":"lines-of-code","value":"6996","count":4},{"name":"lines-of-code","value":"7025","count":4},{"name":"lines-of-code","value":"706","count":4},{"name":"lines-of-code","value":"707","count":4},{"name":"lines-of-code","value":"7092","count":4},{"name":"lines-of-code","value":"710","count":4},{"name":"lines-of-code","value":"711","count":4},{"name":"lines-of-code","value":"712","count":4},{"name":"lines-of-code","value":"713","count":4},{"name":"lines-of-code","value":"714","count":4},{"name":"lines-of-code","value":"715","count":4},{"name":"lines-of-code","value":"717","count":4},{"name":"lines-of-code","value":"719","count":4},{"name":"lines-of-code","value":"721","count":4},{"name":"lines-of-code","value":"722","count":4},{"name":"lines-of-code","value":"725","count":4},{"name":"lines-of-code","value":"726","count":4},{"name":"lines-of-code","value":"728","count":4},{"name":"lines-of-code","value":"7319","count":4},{"name":"lines-of-code","value":"732","count":4},{"name":"lines-of-code","value":"733","count":4},{"name":"lines-of-code","value":"737","count":4},{"name":"lines-of-code","value":"744","count":4},{"name":"lines-of-code","value":"745","count":4},{"name":"lines-of-code","value":"748","count":4},{"name":"lines-of-code","value":"749","count":4},{"name":"lines-of-code","value":"752","count":4},{"name":"lines-of-code","value":"756","count":4},{"name":"lines-of-code","value":"759","count":4},{"name":"lines-of-code","value":"762","count":4},{"name":"lines-of-code","value":"763","count":4},{"name":"lines-of-code","value":"769","count":4},{"name":"lines-of-code","value":"772","count":4},{"name":"lines-of-code","value":"7772","count":4},{"name":"lines-of-code","value":"778","count":4},{"name":"lines-of-code","value":"780","count":4},{"name":"lines-of-code","value":"781","count":4},{"name":"lines-of-code","value":"785","count":4},{"name":"lines-of-code","value":"791","count":4},{"name":"lines-of-code","value":"7926","count":4},{"name":"lines-of-code","value":"793","count":4},{"name":"lines-of-code","value":"795","count":4},{"name":"lines-of-code","value":"796","count":4},{"name":"lines-of-code","value":"7962","count":4},{"name":"lines-of-code","value":"798","count":4},{"name":"lines-of-code","value":"801","count":4},{"name":"lines-of-code","value":"802","count":4},{"name":"lines-of-code","value":"803","count":4},{"name":"lines-of-code","value":"808","count":4},{"name":"lines-of-code","value":"810","count":4},{"name":"lines-of-code","value":"811","count":4},{"name":"lines-of-code","value":"813","count":4},{"name":"lines-of-code","value":"818","count":4},{"name":"lines-of-code","value":"819","count":4},{"name":"lines-of-code","value":"821","count":4},{"name":"lines-of-code","value":"8214","count":4},{"name":"lines-of-code","value":"822","count":4},{"name":"lines-of-code","value":"8254","count":4},{"name":"lines-of-code","value":"826","count":4},{"name":"lines-of-code","value":"830","count":4},{"name":"lines-of-code","value":"832","count":4},{"name":"lines-of-code","value":"835","count":4},{"name":"lines-of-code","value":"836","count":4},{"name":"lines-of-code","value":"840","count":4},{"name":"lines-of-code","value":"846","count":4},{"name":"lines-of-code","value":"852","count":4},{"name":"lines-of-code","value":"854","count":4},{"name":"lines-of-code","value":"860","count":4},{"name":"lines-of-code","value":"861","count":4},{"name":"lines-of-code","value":"864","count":4},{"name":"lines-of-code","value":"865","count":4},{"name":"lines-of-code","value":"867","count":4},{"name":"lines-of-code","value":"868","count":4},{"name":"lines-of-code","value":"872","count":4},{"name":"lines-of-code","value":"873","count":4},{"name":"lines-of-code","value":"877","count":4},{"name":"lines-of-code","value":"879","count":4},{"name":"lines-of-code","value":"8899","count":4},{"name":"lines-of-code","value":"892","count":4},{"name":"lines-of-code","value":"895","count":4},{"name":"lines-of-code","value":"898","count":4},{"name":"lines-of-code","value":"906","count":4},{"name":"lines-of-code","value":"908","count":4},{"name":"lines-of-code","value":"9114","count":4},{"name":"lines-of-code","value":"917","count":4},{"name":"lines-of-code","value":"922","count":4},{"name":"lines-of-code","value":"925","count":4},{"name":"lines-of-code","value":"930","count":4},{"name":"lines-of-code","value":"932","count":4},{"name":"lines-of-code","value":"933","count":4},{"name":"lines-of-code","value":"938","count":4},{"name":"lines-of-code","value":"941","count":4},{"name":"lines-of-code","value":"945","count":4},{"name":"lines-of-code","value":"948","count":4},{"name":"lines-of-code","value":"9528","count":4},{"name":"lines-of-code","value":"953","count":4},{"name":"lines-of-code","value":"957","count":4},{"name":"lines-of-code","value":"964","count":4},{"name":"lines-of-code","value":"966","count":4},{"name":"lines-of-code","value":"967","count":4},{"name":"lines-of-code","value":"968","count":4},{"name":"lines-of-code","value":"969","count":4},{"name":"lines-of-code","value":"972","count":4},{"name":"lines-of-code","value":"976","count":4},{"name":"lines-of-code","value":"979","count":4},{"name":"lines-of-code","value":"980","count":4},{"name":"lines-of-code","value":"985","count":4},{"name":"lines-of-code","value":"986","count":4},{"name":"lines-of-code","value":"998","count":4},{"name":"loop-depth","value":"39","count":4},{"name":"loop-depth","value":"45","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, common\\checksum_helper.c, port\\snprintf.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\msxml.h, interfaces\\libpq\\fe-lobj.c, backend\\storage\\file\\copydir.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\utils\\adt\\formatting.c, interfaces\\libpq\\fe-exec.c, interfaces\\ecpg\\pgtypeslib\\dt_common.c, interfaces\\ecpg\\pgtypeslib\\datetime.c, backend\\utils\\adt\\datetime.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, include\\port\\pg_bswap.h","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, interfaces\\ecpg\\ecpglib\\connect.c, interfaces\\libpq\\fe-exec.c, interfaces\\ecpg\\ecpglib\\memory.c, backend\\nodes\\readfuncs.c, interfaces\\ecpg\\preproc\\output.c, interfaces\\ecpg\\ecpglib\\descriptor.c, port\\snprintf.c, interfaces\\ecpg\\ecpglib\\error.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, port\\win32setlocale.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, port\\pgstrcasecmp.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\winbase.h, port\\win32stat.c, port\\strlcpy.c, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\errhandlingapi.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\winbase.h, interfaces\\libpq\\win32.c, interfaces\\libpq\\fe-exec.c, port\\snprintf.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\libloaderapi.h, backend\\main\\main.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\fileapi.h, backend\\port\\win32\\crashdump.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\backup\\walsummary.c, interfaces\\libpq\\fe-exec.c, port\\win32stat.c, backend\\storage\\file\\fd.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\fileapi.h, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\port\\posix_sema.c, backend\\utils\\error\\elog.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\errhandlingapi.h, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, C:\\mingw64\\x86_64-w64-mingw32\\include\\winbase.h, backend\\storage\\ipc\\dsm_impl.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\fileapi.h, port\\win32error.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\errhandlingapi.h, port\\open.c, port\\pg_strong_random.c, backend\\utils\\error\\elog.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\backup\\walsummary.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\fileapi.h, port\\win32stat.c, interfaces\\libpq\\fe-exec.c, bin\\pgevent\\pgevent.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\processthreadsapi.h, backend\\storage\\ipc\\dsm_impl.c, port\\win32dlopen.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\libloaderapi.h, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h, backend\\utils\\error\\elog.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\storage\\file\\fd.c, port\\tar.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\fileapi.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\errhandlingapi.h, backend\\postmaster\\syslogger.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h, backend\\utils\\error\\elog.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\storage\\file\\fd.c, port\\tar.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\fileapi.h, port\\win32error.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\errhandlingapi.h","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h, backend\\utils\\error\\elog.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\storage\\file\\fd.c, port\\win32ntdll.c, interfaces\\libpq\\fe-exec.c, port\\win32error.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\libloaderapi.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\winbase.h, port\\snprintf.c, interfaces\\libpq\\fe-exec.c, backend\\libpq\\ifaddr.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\libloaderapi.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\winuser.h, interfaces\\libpq\\fe-exec.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\winreg.h, bin\\initdb\\findtimezone.c, backend\\nodes\\readfuncs.c, backend\\utils\\error\\elog.c, backend\\commands\\collationcmds.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\libloaderapi.h, interfaces\\libpq\\fe-exec.c, port\\win32error.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\errhandlingapi.h, port\\pg_strong_random.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\locale.h, backend\\nodes\\readfuncs.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, port\\quotes.c, common\\fe_memutils.c, interfaces\\libpq\\pqexpbuffer.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, port\\pgstrcasecmp.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\locale.h, interfaces\\libpq\\fe-exec.c, pl\\plperl\\plperl.c, port\\strlcpy.c, backend\\utils\\mb\\mbutils.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, common\\string.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\msxml.h, interfaces\\libpq\\fe-lobj.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-misc.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\winsock2.h","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\processenv.h, backend\\utils\\error\\elog.c, common\\d2s.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\consoleapi.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, backend\\lib\\dshash.c, interfaces\\libpq\\fe-exec.c, backend\\main\\main.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\processthreadsapi.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\winsock2.h, backend\\main\\main.c, bin\\pg_dump\\pg_backup_archiver.c, bin\\pg_dump\\pg_backup_utils.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, interfaces\\libpq\\pqexpbuffer.c, bin\\pg_dump\\pg_backup_db.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\processthreadsapi.h, interfaces\\ecpg\\ecpglib\\misc.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, interfaces\\ecpg\\ecpglib\\prepare.c, interfaces\\libpq\\fe-connect.c, interfaces\\ecpg\\ecpglib\\memory.c, interfaces\\ecpg\\ecpglib\\error.c, port\\path.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\backup\\walsummary.c, backend\\utils\\activity\\pgstat_io.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\activity\\pgstat_function.c, backend\\utils\\activity\\pgstat_bgwriter.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, common\\unicode\\case_test.c, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, interfaces\\libpq\\fe-exec.c, port\\snprintf.c, bin\\psql\\command.c, interfaces\\libpq\\fe-connect.c, bin\\psql\\common.c, fe_utils\\cancel.c, interfaces\\libpq\\fe-lobj.c, common\\fe_memutils.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\synchapi.h, backend\\storage\\ipc\\dsm_impl.c, bin\\pg_basebackup\\pg_basebackup.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-misc.c, backend\\bootstrap\\bootstrap.c, backend\\storage\\file\\fd.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\sys\\stat.h, backend\\utils\\adt\\genfile.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, port\\dirent.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, port\\strlcpy.c, include\\access\\xlog_internal.h","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\sys\\stat.h, common\\controldata_utils.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\genfile.c, common\\config_info.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-secure-gssapi.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\sys\\stat.h, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\genfile.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\storage\\file\\fd.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\msxml.h, interfaces\\libpq\\fe-lobj.c, backend\\storage\\file\\copydir.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\sysinfoapi.h","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\winbase.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\errhandlingapi.h, port\\win32error.c, backend\\storage\\ipc\\dsm_impl.c, backend\\port\\win32\\signal.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\backup\\walsummary.c, port\\pg_strong_random.c","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\winbase.h, bin\\pg_upgrade\\version.c, port\\win32error.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\errhandlingapi.h, bin\\pg_upgrade\\util.c, port\\win32link.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\msxml.h, interfaces\\libpq\\fe-lobj.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\sys\\stat.h","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\winbase.h, interfaces\\libpq\\fe-exec.c, port\\win32error.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\errhandlingapi.h","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\winnt.h","count":4},{"name":"module-depends-on","value":"<unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\winsock2.h, backend\\port\\win32\\socket.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\brin\\brin.c, backend\\access\\gin\\ginpostinglist.c, backend\\utils\\mmgr\\mcxt.c, backend\\jit\\llvm\\port.h, backend\\utils\\cache\\lsyscache.c, backend\\jit\\llvm\\postgres.h, backend\\access\\brin\\brin_bloom.c, include\\access\\tupmacs.h, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\brin\\brin.c, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\index\\amvalidate.c, backend\\utils\\adt\\regproc.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\format_type.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\brin\\brin.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\brin\\brin_revmap.c, include\\storage\\bufmgr.h, backend\\storage\\buffer\\bufmgr.c, include\\storage\\bufpage.h, backend\\storage\\freespace\\freespace.c, backend\\access\\brin\\brin_tuple.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\brin\\brin.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\gin\\ginpostinglist.c, backend\\utils\\mmgr\\mcxt.c, common\\hashfn.c, backend\\utils\\cache\\typcache.c, backend\\access\\gin\\ginutil.c, backend\\jit\\llvm\\postgres.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\common\\attmap.c, backend\\nodes\\readfuncs.c, backend\\utils\\mmgr\\mcxt.c, backend\\access\\common\\reloptions.c, interfaces\\libpq\\fe-exec.c, backend\\access\\common\\heaptuple.c, include\\executor\\tuptable.h, backend\\executor\\execTuples.c, backend\\nodes\\bitmapset.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\common\\relation.c, backend\\nodes\\readfuncs.c, backend\\access\\index\\genam.c, backend\\utils\\cache\\relcache.c, backend\\storage\\lmgr\\lmgr.c, backend\\access\\index\\amapi.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\catalog\\index.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\common\\relation.c, backend\\utils\\error\\elog.c, backend\\catalog\\pg_class.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\common\\relation.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, backend\\catalog\\pg_class.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\common\\reloptions.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\common\\heaptuple.c, backend\\jit\\llvm\\postgres.h, backend\\access\\common\\detoast.c, backend\\access\\common\\toast_internals.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\common\\scankey.c, backend\\jit\\llvm\\postgres.h, backend\\access\\table\\table.c, backend\\access\\index\\genam.c, interfaces\\libpq\\fe-exec.c, backend\\access\\common\\heaptuple.c, backend\\utils\\init\\globals.c, backend\\utils\\misc\\timeout.c, include\\utils\\ps_status.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\gin\\ginpostinglist.c, backend\\access\\gin\\ginscan.c, backend\\access\\gin\\ginget.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\fmgr\\fmgr.c, include\\access\\gin.h, backend\\access\\gin\\ginutil.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\gin\\ginpostinglist.c, backend\\storage\\ipc\\shmem.c, backend\\access\\transam\\xlogreader.c, backend\\access\\transam\\xlogfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\storage\\lmgr\\lwlock.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\gin\\ginpostinglist.c, backend\\storage\\ipc\\shmem.c, backend\\postmaster\\checkpointer.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\port\\atomics.c, backend\\bootstrap\\bootstrap.c, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\gin\\ginpostinglist.c, backend\\storage\\ipc\\shmem.c, backend\\postmaster\\postmaster.c, backend\\nodes\\readfuncs.c, backend\\utils\\mmgr\\mcxt.c, backend\\storage\\ipc\\barrier.c, backend\\storage\\ipc\\dsm.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\gin\\ginpostinglist.c, backend\\storage\\ipc\\shmem.c, backend\\storage\\ipc\\shm_mq.c, backend\\storage\\lmgr\\spin.c, backend\\storage\\ipc\\barrier.c, backend\\storage\\ipc\\dsm.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\storage\\lmgr\\lwlock.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\gin\\ginpostinglist.c, backend\\storage\\ipc\\shmem.c, backend\\storage\\lmgr\\lwlock.c, backend\\storage\\ipc\\dsm.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\storage\\ipc\\barrier.c, include\\port\\atomics.h, include\\utils\\wait_event.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\gin\\ginpostinglist.c, backend\\storage\\ipc\\shmem.c, backend\\storage\\lmgr\\spin.c, backend\\storage\\lmgr\\lwlock.c, backend\\storage\\lmgr\\condition_variable.c, backend\\storage\\ipc\\ipc.c, backend\\nodes\\readfuncs.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\gin\\ginpostinglist.c, backend\\utils\\mmgr\\mcxt.c, common\\d2s.c, common\\controldata_utils.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, common\\config_info.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\gin\\ginpostinglist.c, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\nodes\\makefuncs.c, backend\\utils\\cache\\lsyscache.c, backend\\utils\\adt\\datum.c, include\\nodes\\nodes.h, backend\\storage\\ipc\\shmem.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\gin\\ginpostinglist.c, backend\\utils\\sort\\logtape.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\storage\\lmgr\\lwlock.c, backend\\utils\\mmgr\\mcxt.c, backend\\storage\\file\\buffile.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\gin\\ginscan.c, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\access\\gin\\ginutil.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\regproc.c, backend\\access\\gin\\ginpostinglist.c, backend\\access\\index\\amvalidate.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\gin\\ginutil.c, backend\\jit\\llvm\\postgres.h, backend\\access\\gin\\ginpostinglist.c, backend\\access\\common\\indextuple.c, backend\\access\\gin\\ginxlog.c, include\\access\\itup.h, backend\\access\\gin\\ginscan.c, include\\storage\\itemptr.h, backend\\access\\gin\\ginvacuum.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\gin\\ginutil.c, backend\\storage\\buffer\\bufmgr.c, include\\storage\\bufmgr.h, backend\\access\\gin\\ginvacuum.c, include\\storage\\bufpage.h, backend\\access\\gin\\ginpostinglist.c, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, backend\\storage\\lmgr\\predicate.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\gist\\gist.c, backend\\storage\\buffer\\bufmgr.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\access\\index\\indexam.c, backend\\utils\\sort\\tuplesortvariants.c, backend\\nodes\\readfuncs.c, include\\access\\tableam.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\gist\\gist.c, backend\\storage\\buffer\\bufmgr.c, include\\storage\\bufmgr.h, backend\\access\\gist\\gistutil.c, include\\storage\\bufpage.h, include\\storage\\itemptr.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\utils\\float.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\gist\\gist.c, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\regproc.c, backend\\access\\index\\amvalidate.c, backend\\access\\gist\\gistbuild.c, backend\\utils\\cache\\lsyscache.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\gist\\gist.c, include\\storage\\bufpage.h, backend\\storage\\page\\bufpage.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, backend\\access\\gist\\gistsplit.c, include\\access\\itup.h, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\hash\\hash.c, backend\\access\\hash\\hashutil.c, include\\storage\\block.h, backend\\access\\hash\\hashpage.c, backend\\access\\hash\\hashovfl.c, backend\\storage\\buffer\\bufmgr.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, backend\\storage\\lmgr\\predicate.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\hash\\hash.c, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\hash\\hashfunc.c, backend\\utils\\adt\\regproc.c, backend\\access\\hash\\hashpage.c, backend\\nodes\\list.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\hash\\hash.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\storage\\buffer\\bufmgr.c, backend\\access\\hash\\hashutil.c, interfaces\\libpq\\fe-exec.c, include\\storage\\bufmgr.h, include\\storage\\bufpage.h, backend\\access\\hash\\hashovfl.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\hash\\hash.c, interfaces\\libpq\\fe-exec.c, backend\\access\\hash\\hashutil.c, backend\\access\\hash\\hash_xlog.c, backend\\access\\hash\\hashpage.c, include\\storage\\bufmgr.h, include\\storage\\bufpage.h, backend\\access\\hash\\hashfunc.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\hash\\hashutil.c, backend\\access\\hash\\hashfunc.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\hash\\hash.c, interfaces\\libpq\\fe-exec.c, backend\\storage\\buffer\\bufmgr.c, include\\storage\\bufmgr.h, include\\storage\\bufpage.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\heap\\heapam.c, backend\\access\\common\\heaptuple.c, backend\\access\\table\\toast_helper.c, interfaces\\libpq\\fe-exec.c, backend\\access\\heap\\heapam_handler.c, backend\\utils\\mmgr\\mcxt.c, backend\\jit\\llvm\\postgres.h, backend\\access\\common\\detoast.c, include\\storage\\itemptr.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\heap\\heapam.c, include\\storage\\bufmgr.h, backend\\storage\\buffer\\bufmgr.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\storage\\bufpage.h, backend\\access\\transam\\xlog.c, backend\\access\\heap\\hio.c, include\\port\\pg_bitutils.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\heap\\heapam_handler.c, include\\storage\\bufmgr.h, backend\\access\\transam\\xlog.c, backend\\storage\\ipc\\procarray.c, backend\\access\\heap\\heapam.c, backend\\access\\heap\\hio.c, include\\storage\\bufpage.h, backend\\storage\\page\\bufpage.c, backend\\storage\\buffer\\bufmgr.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\index\\amapi.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\list.c, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\nbtree\\nbtdedup.c, backend\\access\\nbtree\\nbtutils.c, backend\\nodes\\readfuncs.c, backend\\access\\nbtree\\nbtpage.c, backend\\storage\\lmgr\\lmgr.c, backend\\storage\\lmgr\\predicate.c, backend\\storage\\buffer\\bufmgr.c, backend\\utils\\mmgr\\mcxt.c, include\\storage\\bufmgr.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\nbtree\\nbtdedup.c, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\nbtree\\nbtsearch.c, backend\\access\\index\\amvalidate.c, backend\\access\\nbtree\\nbtutils.c, backend\\access\\nbtree\\nbtree.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\nbtree\\nbtdedup.c, include\\storage\\bufpage.h, backend\\storage\\page\\bufpage.c, backend\\access\\nbtree\\nbtinsert.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\nbtree\\nbtsort.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\nbtree\\nbtdedup.c, interfaces\\libpq\\fe-exec.c, backend\\access\\nbtree\\nbtpage.c, backend\\storage\\buffer\\bufmgr.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\activity\\backend_progress.c, backend\\utils\\sort\\tuplesortvariants.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\nbtree\\nbtinsert.c, backend\\access\\nbtree\\nbtdedup.c, backend\\access\\nbtree\\nbtsearch.c, include\\access\\nbtree.h, include\\storage\\itemptr.h, backend\\utils\\mmgr\\mcxt.c, backend\\access\\gin\\ginpostinglist.c, backend\\access\\nbtree\\nbtpage.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\nbtree\\nbtinsert.c, backend\\access\\nbtree\\nbtdedup.c, backend\\storage\\page\\bufpage.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\transam\\xlogutils.c, backend\\access\\transam\\xlogreader.c, include\\storage\\bufmgr.h, backend\\access\\nbtree\\nbtpage.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\nbtree\\nbtinsert.c, include\\storage\\bufpage.h, backend\\access\\nbtree\\nbtdedup.c, include\\storage\\bufmgr.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\storage\\buffer\\bufmgr.c, backend\\access\\transam\\xloginsert.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\rmgrdesc\\genericdesc.c, backend\\access\\rmgrdesc\\gindesc.c, common\\stringinfo.c, backend\\access\\rmgrdesc\\heapdesc.c, backend\\access\\transam\\xlogreader.c, interfaces\\libpq\\fe-exec.c, backend\\access\\rmgrdesc\\rmgrdesc_utils.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\rmgrdesc\\genericdesc.c, backend\\access\\rmgrdesc\\gindesc.c, common\\stringinfo.c, backend\\access\\rmgrdesc\\xactdesc.c, backend\\utils\\adt\\timestamp.c, interfaces\\libpq\\fe-exec.c, backend\\access\\rmgrdesc\\heapdesc.c, backend\\access\\transam\\xlogreader.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\rmgrdesc\\heapdesc.c, common\\stringinfo.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\rmgrdesc\\logicalmsgdesc.c, common\\stringinfo.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\spgist\\spgdoinsert.c, backend\\access\\spgist\\spgutils.c, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\index\\amvalidate.c, backend\\utils\\adt\\regproc.c, backend\\commands\\foreigncmds.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\table\\table.c, backend\\catalog\\pg_collation.c, backend\\utils\\adt\\name.c, backend\\utils\\mmgr\\mcxt.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\arrayfuncs.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\catalog\\catalog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\table\\table.c, backend\\catalog\\pg_constraint.c, backend\\catalog\\pg_collation.c, backend\\catalog\\catalog.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\init\\miscinit.c, backend\\access\\common\\heaptuple.c, backend\\catalog\\indexing.c, backend\\access\\common\\scankey.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\table\\table.c, backend\\catalog\\pg_constraint.c, backend\\catalog\\pg_collation.c, backend\\catalog\\pg_class.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\common\\scankey.c, backend\\jit\\llvm\\postgres.h, backend\\access\\index\\genam.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\table\\table.c, backend\\catalog\\pg_constraint.c, backend\\jit\\llvm\\postgres.h, backend\\access\\common\\heaptuple.c, backend\\catalog\\pg_collation.c, backend\\catalog\\indexing.c, backend\\catalog\\dependency.c, backend\\catalog\\pg_depend.c, backend\\access\\common\\scankey.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\table\\table.c, backend\\catalog\\pg_constraint.c, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\catalog\\pg_operator.c, backend\\catalog\\pg_collation.c, backend\\utils\\error\\elog.c, backend\\utils\\adt\\format_type.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\table\\table.c, backend\\catalog\\pg_constraint.c, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, backend\\executor\\execTuples.c, backend\\catalog\\pg_collation.c, include\\executor\\tuptable.h, backend\\jit\\llvm\\postgres.h, backend\\catalog\\indexing.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\table\\table.c, backend\\commands\\seclabel.c, backend\\access\\common\\scankey.c, backend\\jit\\llvm\\postgres.h, backend\\access\\index\\genam.c, interfaces\\libpq\\fe-exec.c, backend\\commands\\alter.c, backend\\commands\\aggregatecmds.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\table\\table.c, backend\\commands\\seclabel.c, backend\\utils\\misc\\superuser.c, backend\\commands\\aggregatecmds.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\jit\\llvm\\postgres.h, backend\\utils\\cache\\syscache.c, backend\\commands\\alter.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\table\\table.c, backend\\optimizer\\util\\appendinfo.c, backend\\utils\\error\\elog.c, backend\\catalog\\pg_class.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\transam\\xlog.c, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\bitmapset.c, backend\\catalog\\catalog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\table\\table.c, backend\\rewrite\\rewriteDefine.c, backend\\access\\common\\scankey.c, backend\\jit\\llvm\\postgres.h, backend\\access\\index\\genam.c, interfaces\\libpq\\fe-exec.c, backend\\rewrite\\rewriteHandler.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\table\\table.c, backend\\rewrite\\rewriteDefine.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\nodeFuncs.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\nodes\\pg_list.h, backend\\parser\\parse_relation.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\table\\table.c, backend\\utils\\mmgr\\aset.c, backend\\jit\\llvm\\utils\\palloc.h, include\\nodes\\pg_list.h, backend\\utils\\activity\\backend_progress.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\statistics\\dependencies.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\table\\tableam.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\storage\\buffer\\bufmgr.c, backend\\storage\\buffer\\freelist.c, backend\\access\\common\\syncscan.c, include\\storage\\itemptr.h, backend\\utils\\activity\\pgstat_relation.c, include\\storage\\bufpage.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\tablesample\\system.c, include\\nodes\\nodes.h, backend\\nodes\\list.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\access\\gin\\ginutil.c, backend\\jit\\llvm\\postgres.h, include\\nodes\\pg_list.h, backend\\optimizer\\util\\clauses.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\varsup.c, backend\\access\\transam\\transam.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\varsup.c, backend\\nodes\\readfuncs.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\access\\transam.h, backend\\utils\\adt\\geo_spgist.c, backend\\jit\\llvm\\port.h, include\\lib\\qunique.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\xact.c, backend\\catalog\\namespace.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\fmgr\\fmgr.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\nodes\\list.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\mb\\conv.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\xact.c, backend\\utils\\misc\\conffiles.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\misc\\guc.c, backend\\utils\\misc\\superuser.c, backend\\nodes\\list.c, include\\nodes\\pg_list.h, backend\\utils\\time\\snapmgr.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\xact.c, backend\\utils\\time\\snapmgr.c, backend\\access\\table\\table.c, backend\\access\\table\\tableam.c, interfaces\\libpq\\fe-exec.c, backend\\access\\heap\\heapam.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\list.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\xact.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\hash\\dynahash.c, include\\nodes\\pg_list.h, backend\\access\\table\\table.c, backend\\catalog\\pg_constraint.c, backend\\utils\\mmgr\\mcxt.c, backend\\catalog\\catalog.c, backend\\jit\\llvm\\port.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\xact.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\hash\\dynahash.c, backend\\storage\\ipc\\shmem.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\xlogfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\xlogfuncs.c, backend\\access\\transam\\clog.c, backend\\utils\\mmgr\\mcxt.c, backend\\storage\\ipc\\procarray.c, backend\\access\\transam\\transam.c, backend\\access\\transam\\xact.c, backend\\storage\\lmgr\\lwlock.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\xlogfuncs.c, backend\\access\\transam\\commit_ts.c, include\\access\\transam.h, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, backend\\access\\transam\\varsup.c, backend\\access\\transam\\subtrans.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\xlogfuncs.c, backend\\access\\transam\\xlog.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, backend\\storage\\buffer\\bufmgr.c, include\\storage\\bufmgr.h, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\xlogfuncs.c, backend\\access\\transam\\xlogprefetcher.c, backend\\utils\\mmgr\\mcxt.c, include\\storage\\bufmgr.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\access\\transam\\xloginsert.c, backend\\storage\\buffer\\bufmgr.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\xlogfuncs.c, backend\\utils\\mmgr\\mcxt.c, backend\\access\\gin\\ginpostinglist.c, include\\port\\atomics.h, backend\\utils\\adt\\timestamp.c, backend\\storage\\ipc\\shmem.c, backend\\utils\\hash\\dynahash.c, include\\lib\\ilist.h, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\xlogfuncs.c, common\\stringinfo.c, timezone\\strftime.c, timezone\\localtime.c, include\\access\\xlog_internal.h, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\xlogfuncs.c, include\\access\\slru.h, backend\\storage\\lmgr\\lwlock.c, backend\\access\\transam\\slru.c, backend\\access\\transam\\xlogrecovery.c, backend\\access\\transam\\xlogreader.c, backend\\access\\transam\\transam.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\xlogfuncs.c, include\\access\\slru.h, backend\\storage\\lmgr\\lwlock.c, backend\\access\\transam\\slru.c, backend\\nodes\\readfuncs.c, include\\port\\atomics.h, backend\\access\\transam\\xlogprefetcher.c, include\\utils\\wait_event.h, backend\\port\\posix_sema.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\xlogfuncs.c, port\\snprintf.c, backend\\access\\transam\\xlogreader.c, backend\\access\\transam\\xlogprefetcher.c, backend\\storage\\ipc\\shmem.c, include\\port\\atomics.h, backend\\utils\\activity\\pgstat_slru.c, backend\\storage\\lmgr\\lwlock.c, port\\strlcpy.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\xlogprefetcher.c, backend\\access\\transam\\xlogrecovery.c, backend\\access\\transam\\xlogfuncs.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\transam\\xloginsert.c, backend\\access\\transam\\transam.c, port\\pg_crc32c_sb8.c, backend\\access\\transam\\xlogreader.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\xlogreader.c, backend\\access\\transam\\xlogfuncs.c, include\\access\\xlog_internal.h, backend\\access\\transam\\xlogarchive.c, backend\\utils\\mmgr\\mcxt.c, backend\\access\\transam\\xlogprefetcher.c, backend\\nodes\\list.c, backend\\storage\\file\\fd.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\xlogreader.c, backend\\nodes\\readfuncs.c, port\\snprintf.c, backend\\access\\transam\\xlogrecovery.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\sys\\stat.h, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\backup\\walsummary.c, backend\\access\\transam\\xlogfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\xlogreader.c, interfaces\\libpq\\fe-exec.c, bin\\pg_rewind\\pg_rewind.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, C:\\mingw64\\x86_64-w64-mingw32\\include\\winsock2.h, port\\snprintf.c, include\\access\\xlog_internal.h, bin\\pg_rewind\\filemap.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\msxml.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\xlogutils.c, backend\\access\\brin\\brin.c, include\\storage\\bufmgr.h, backend\\access\\brin\\brin_pageops.c, include\\storage\\bufpage.h, backend\\storage\\buffer\\bufmgr.c, backend\\access\\transam\\xlogreader.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\xlogutils.c, backend\\access\\hash\\hash.c, backend\\access\\hash\\hashpage.c, include\\storage\\bufmgr.h, include\\storage\\bufpage.h, backend\\storage\\buffer\\bufmgr.c, backend\\access\\transam\\xlogreader.c, interfaces\\libpq\\fe-exec.c, backend\\access\\hash\\hashovfl.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\xlogutils.c, backend\\storage\\buffer\\bufmgr.c, include\\storage\\bufmgr.h, include\\storage\\bufpage.h, backend\\storage\\page\\bufpage.c, backend\\storage\\freespace\\fsmpage.c, backend\\storage\\smgr\\smgr.c, include\\utils\\rel.h, backend\\access\\transam\\xlog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\xlogutils.c, include\\storage\\bufmgr.h, backend\\access\\gin\\ginvacuum.c, include\\storage\\bufpage.h, backend\\storage\\buffer\\bufmgr.c, backend\\access\\gin\\ginutil.c, backend\\access\\gin\\ginpostinglist.c, include\\storage\\itemptr.h, backend\\storage\\page\\bufpage.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\access\\transam\\xlogutils.c, include\\storage\\bufmgr.h, backend\\access\\gist\\gist.c, include\\storage\\bufpage.h, backend\\storage\\buffer\\bufmgr.c, backend\\access\\transam\\xlogreader.c, backend\\storage\\page\\bufpage.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\backup\\basebackup.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\list.c, backend\\backup\\basebackup_zstd.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\backup\\basebackup_server.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\backup\\walsummary.c, backend\\backup\\basebackup_throttle.c, backend\\utils\\resowner\\resowner.c, interfaces\\libpq\\fe-exec.c, backend\\access\\transam\\xlog.c, backend\\backup\\backup_manifest.c, backend\\utils\\mmgr\\mcxt.c, common\\stringinfo.c, backend\\backup\\basebackup_progress.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\catalog\\dependency.c, backend\\commands\\statscmds.c, interfaces\\libpq\\fe-exec.c, backend\\catalog\\objectaddress.c, backend\\commands\\alter.c, backend\\commands\\aggregatecmds.c, backend\\utils\\cache\\lsyscache.c, backend\\utils\\error\\elog.c, backend\\catalog\\namespace.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\catalog\\index.c, backend\\catalog\\pg_collation.c, backend\\utils\\error\\elog.c, backend\\catalog\\pg_class.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\catalog\\catalog.c, backend\\utils\\cache\\lsyscache.c, backend\\catalog\\namespace.c, backend\\utils\\adt\\format_type.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\catalog\\namespace.c, backend\\catalog\\aclchk.c, backend\\utils\\init\\miscinit.c, backend\\commands\\aggregatecmds.c, backend\\utils\\cache\\lsyscache.c, common\\encnames.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\parser\\parse_func.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\catalog\\pg_class.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\catalog\\aclchk.c, interfaces\\libpq\\fe-exec.c, backend\\catalog\\pg_collation.c, backend\\catalog\\catalog.c, backend\\utils\\cache\\lsyscache.c, backend\\utils\\cache\\relcache.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\catalog\\pg_class.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\catalog\\pg_inherits.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\cache\\syscache.c, backend\\catalog\\pg_collation.c, backend\\catalog\\aclchk.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\catalog\\pg_class.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\jit\\llvm\\postgres.h, backend\\utils\\cache\\syscache.c, backend\\catalog\\pg_collation.c, common\\encnames.c, backend\\access\\table\\table.c, backend\\catalog\\pg_constraint.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\catalog\\pg_collation.c, backend\\access\\table\\table.c, backend\\catalog\\pg_constraint.c, backend\\nodes\\outfuncs.c, backend\\catalog\\catalog.c, backend\\jit\\llvm\\postgres.h, backend\\catalog\\pg_depend.c, backend\\utils\\adt\\varlena.c, backend\\access\\common\\heaptuple.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\catalog\\pg_collation.c, backend\\access\\table\\table.c, backend\\catalog\\pg_constraint.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\name.c, backend\\jit\\llvm\\postgres.h, backend\\catalog\\heap.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\catalog\\pg_collation.c, backend\\catalog\\pg_proc.c, backend\\catalog\\pg_class.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\parser\\parse_coerce.c, backend\\catalog\\namespace.c, backend\\utils\\adt\\format_type.c, backend\\utils\\cache\\syscache.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\catalog\\pg_collation.c, backend\\utils\\cache\\relcache.c, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\catalog\\pg_class.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\catalog\\aclchk.c, backend\\nodes\\list.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\catalog\\pg_collation.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\acl.c, backend\\utils\\mmgr\\mcxt.c, backend\\catalog\\pg_class.c, backend\\utils\\init\\miscinit.c, backend\\catalog\\pg_depend.c, backend\\catalog\\pg_constraint.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\catalog\\pg_collation.c, interfaces\\libpq\\fe-exec.c, include\\nodes\\pg_list.h, backend\\catalog\\pg_constraint.c, backend\\parser\\parse_func.c, backend\\parser\\parse_oper.c, backend\\catalog\\namespace.c, backend\\utils\\adt\\oid.c, backend\\catalog\\pg_largeobject.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\catalog\\pg_constraint.c, backend\\catalog\\pg_collation.c, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\parser\\parse_oper.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\cache\\lsyscache.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\commands\\aggregatecmds.c, backend\\commands\\amcmds.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\catalog\\namespace.c, backend\\catalog\\aclchk.c, backend\\utils\\init\\miscinit.c, backend\\commands\\collationcmds.c, backend\\utils\\cache\\lsyscache.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\commands\\aggregatecmds.c, backend\\commands\\seclabel.c, backend\\commands\\subscriptioncmds.c, backend\\commands\\define.c, backend\\utils\\adt\\varlena.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\list.c, backend\\catalog\\namespace.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\commands\\aggregatecmds.c, backend\\commands\\seclabel.c, backend\\utils\\mmgr\\mcxt.c, backend\\commands\\define.c, backend\\nodes\\readfuncs.c, backend\\replication\\slot.c, backend\\utils\\misc\\guc.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\commands\\aggregatecmds.c, backend\\commands\\seclabel.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\varlena.c, backend\\utils\\error\\elog.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\commands\\tablespace.c, backend\\nodes\\list.c, backend\\commands\\subscriptioncmds.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\commands\\aggregatecmds.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\nodes\\pg_list.h, backend\\catalog\\objectaddress.c, backend\\utils\\init\\miscinit.c, backend\\catalog\\pg_class.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\commands\\aggregatecmds.c, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, backend\\access\\transam\\xact.c, backend\\access\\transam\\parallel.c, backend\\storage\\ipc\\shmem.c, backend\\storage\\ipc\\shm_toc.c, backend\\commands\\tablecmds.c, backend\\commands\\statscmds.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\commands\\aggregatecmds.c, common\\relpath.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\sys\\stat.h, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\backup\\walsummary.c, backend\\storage\\lmgr\\lwlock.c, backend\\utils\\adt\\genfile.c, backend\\storage\\file\\fd.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\commands\\aggregatecmds.c, interfaces\\libpq\\fe-exec.c, backend\\commands\\define.c, backend\\utils\\error\\elog.c, backend\\parser\\parse_node.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\catalog\\namespace.c, backend\\access\\table\\table.c, backend\\utils\\cache\\relcache.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\commands\\alter.c, backend\\commands\\aggregatecmds.c, port\\strlcpy.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\commands\\seclabel.c, backend\\catalog\\namespace.c, backend\\utils\\init\\miscinit.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\commands\\alter.c, backend\\commands\\dbcommands.c, backend\\commands\\aggregatecmds.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\catalog\\objectaddress.c, backend\\commands\\seclabel.c, backend\\utils\\init\\miscinit.c, backend\\catalog\\pg_class.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\commands\\alter.c, backend\\storage\\ipc\\shmem.c, backend\\access\\gin\\ginpostinglist.c, backend\\access\\transam\\slru.c, backend\\commands\\aggregatecmds.c, backend\\commands\\seclabel.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\format_type.c, backend\\utils\\adt\\varlena.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\commands\\analyze.c, backend\\commands\\aggregatecmds.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\storage\\itemptr.h, backend\\access\\table\\tableam.c, interfaces\\libpq\\fe-exec.c, include\\access\\tableam.h, backend\\executor\\execTuples.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\commands\\copy.c, include\\nodes\\nodes.h, backend\\commands\\statscmds.c, backend\\nodes\\makefuncs.c, backend\\nodes\\nodeFuncs.c, backend\\utils\\cache\\lsyscache.c, backend\\commands\\alter.c, backend\\commands\\aggregatecmds.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\commands\\copyfrom.c, include\\nodes\\nodes.h, interfaces\\libpq\\fe-exec.c, backend\\commands\\aggregatecmds.c, backend\\commands\\tablecmds.c, backend\\access\\transam\\xact.c, backend\\access\\common\\reloptions.c, backend\\commands\\seclabel.c, backend\\catalog\\toasting.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\commands\\define.c, backend\\commands\\alter.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\parser\\parse_func.c, backend\\commands\\aggregatecmds.c, backend\\utils\\cache\\lsyscache.c, backend\\utils\\adt\\format_type.c, backend\\jit\\llvm\\postgres.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\commands\\event_trigger.c, backend\\catalog\\pg_collation.c, backend\\access\\table\\table.c, backend\\catalog\\pg_constraint.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\tcop\\postgres.c, backend\\catalog\\catalog.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\commands\\explain.c, backend\\commands\\aggregatecmds.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\transam\\xact.c, backend\\utils\\init\\miscinit.c, backend\\rewrite\\rewriteHandler.c, include\\nodes\\pg_list.h, backend\\commands\\alter.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\commands\\seclabel.c, backend\\catalog\\index.c, backend\\commands\\aggregatecmds.c, include\\nodes\\pg_list.h, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\commands\\cluster.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\commands\\seclabel.c, backend\\commands\\aggregatecmds.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\utils\\misc\\superuser.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\catalog\\namespace.c, backend\\commands\\statscmds.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\commands\\seclabel.c, backend\\utils\\error\\elog.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\commands\\aggregatecmds.c, backend\\nodes\\readfuncs.c, backend\\commands\\subscriptioncmds.c, backend\\commands\\define.c, backend\\utils\\misc\\guc.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\commands\\statscmds.c, backend\\catalog\\namespace.c, backend\\utils\\cache\\lsyscache.c, backend\\commands\\alter.c, backend\\commands\\aggregatecmds.c, backend\\utils\\error\\elog.c, backend\\catalog\\pg_class.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\commands\\dropcmds.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\execExprInterp.c, backend\\access\\common\\tupconvert.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, backend\\executor\\execTuples.c, backend\\utils\\sort\\tuplestore.c, include\\executor\\tuptable.h, backend\\jit\\llvm\\postgres.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\execExprInterp.c, backend\\executor\\execScan.c, backend\\executor\\nodeBitmapHeapscan.c, include\\nodes\\nodes.h, backend\\executor\\execUtils.c, backend\\nodes\\readfuncs.c, backend\\executor\\execTuples.c, backend\\executor\\execMain.c, backend\\access\\table\\tableam.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\execExprInterp.c, backend\\utils\\sort\\tuplesort.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\executor\\nodeWindowAgg.c, backend\\executor\\execUtils.c, backend\\utils\\sort\\tuplesortvariants.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\execMain.c, backend\\executor\\nodeWindowAgg.c, backend\\executor\\execExprInterp.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\executor\\spi.c, backend\\nodes\\nodeFuncs.c, backend\\utils\\adt\\format_type.c, backend\\executor\\execIndexing.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\execParallel.c, include\\nodes\\nodes.h, backend\\executor\\execExprInterp.c, interfaces\\libpq\\fe-exec.c, backend\\executor\\execPartition.c, include\\nodes\\pg_list.h, backend\\nodes\\bitmapset.c, backend\\nodes\\readfuncs.c, backend\\executor\\execTuples.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\execTuples.c, backend\\jit\\llvm\\postgres.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\execTuples.c, backend\\nodes\\list.c, backend\\utils\\time\\snapmgr.c, interfaces\\libpq\\fe-exec.c, backend\\storage\\ipc\\shmem.c, include\\access\\tableam.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\table\\table.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\execTuples.c, backend\\storage\\ipc\\shm_mq.c, backend\\executor\\execExprInterp.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\execTuples.c, backend\\utils\\mmgr\\mcxt.c, backend\\executor\\nodeValuesscan.c, backend\\executor\\execExprInterp.c, interfaces\\libpq\\fe-exec.c, include\\nodes\\nodes.h, include\\nodes\\pg_list.h, include\\executor\\tuptable.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\execUtils.c, backend\\executor\\nodeWindowAgg.c, backend\\executor\\execExprInterp.c, backend\\executor\\execGrouping.c, backend\\executor\\nodeValuesscan.c, backend\\executor\\nodeHashjoin.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, include\\executor\\executor.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\instrument.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\executor\\execUtils.c, backend\\executor\\nodeSubplan.c, backend\\executor\\nodeGather.c, backend\\executor\\nodeResult.c, backend\\executor\\nodeProjectSet.c, backend\\executor\\nodeModifyTable.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\nodeAgg.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\utils\\mmgr\\mcxt.c, include\\nodes\\pg_list.h, backend\\utils\\adt\\varlena.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\nodeLockRows.c, backend\\executor\\execExprInterp.c, backend\\utils\\mmgr\\mcxt.c, include\\nodes\\nodeFuncs.h, backend\\executor\\execExpr.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\nodes\\pg_list.h, backend\\nodes\\list.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\nodeNestloop.c, backend\\executor\\nodeWindowAgg.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, backend\\executor\\nodeIncrementalSort.c, backend\\executor\\nodeMergejoin.c, backend\\executor\\execUtils.c, backend\\utils\\sort\\tuplesortvariants.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\nodeValuesscan.c, backend\\executor\\nodeWindowAgg.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, backend\\utils\\mmgr\\mcxt.c, backend\\executor\\execExprInterp.c, interfaces\\libpq\\fe-exec.c, include\\executor\\executor.h, include\\executor\\tuptable.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\nodeValuesscan.c, backend\\executor\\nodeWindowAgg.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, include\\executor\\executor.h, backend\\executor\\execExprInterp.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c, backend\\executor\\execAmi.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\nodeValuesscan.c, backend\\executor\\nodeWindowAgg.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, include\\executor\\executor.h, include\\executor\\tuptable.h, backend\\nodes\\readfuncs.c, backend\\executor\\execExprInterp.c, include\\nodes\\nodes.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\nodeValuesscan.c, backend\\executor\\nodeWindowAgg.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, include\\executor\\executor.h, include\\executor\\tuptable.h, backend\\executor\\execExprInterp.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\nodeValuesscan.c, backend\\executor\\nodeWindowAgg.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\sort\\tuplestore.c, backend\\executor\\execExprInterp.c, backend\\executor\\execMain.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\nodeValuesscan.c, backend\\executor\\nodeWindowAgg.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, interfaces\\libpq\\fe-exec.c, include\\executor\\executor.h, backend\\executor\\execExprInterp.c, include\\executor\\tuptable.h, include\\nodes\\nodes.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\nodeValuesscan.c, backend\\utils\\sort\\tuplestore.c, interfaces\\libpq\\fe-exec.c, backend\\executor\\execExprInterp.c, include\\executor\\executor.h, backend\\executor\\nodeWindowAgg.c, include\\executor\\tuptable.h, backend\\executor\\execScan.c, backend\\executor\\execMain.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\nodeValuesscan.c, include\\nodes\\nodes.h, backend\\executor\\execExprInterp.c, interfaces\\libpq\\fe-exec.c, backend\\executor\\execPartition.c, include\\nodes\\pg_list.h, backend\\nodes\\bitmapset.c, backend\\nodes\\readfuncs.c, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\nodeWindowAgg.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, backend\\executor\\execExprInterp.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\jit\\llvm\\postgres.h, include\\executor\\executor.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\nodeWindowAgg.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, backend\\executor\\nodeMergejoin.c, backend\\utils\\mmgr\\mcxt.c, include\\executor\\executor.h, interfaces\\libpq\\fe-exec.c, backend\\executor\\execExprInterp.c, include\\executor\\tuptable.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\nodeWindowAgg.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, include\\executor\\executor.h, backend\\executor\\execMain.c, interfaces\\libpq\\fe-exec.c, backend\\executor\\execExprInterp.c, include\\executor\\tuptable.h, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\nodeWindowAgg.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, interfaces\\libpq\\fe-exec.c, include\\executor\\tuptable.h, backend\\nodes\\readfuncs.c, backend\\executor\\execExprInterp.c, backend\\executor\\execMain.c, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\nodeWindowAgg.c, backend\\utils\\mmgr\\mcxt.c, backend\\executor\\spi.c, backend\\utils\\fmgr\\fmgr.c, backend\\executor\\execExprInterp.c, backend\\utils\\error\\elog.c, backend\\utils\\adt\\format_type.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\cache\\syscache.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\nodeWindowAgg.c, backend\\utils\\mmgr\\mcxt.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, backend\\executor\\execExprInterp.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, include\\executor\\executor.h, backend\\executor\\nodeHash.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\executor\\nodeWindowAgg.c, include\\nodes\\nodes.h, backend\\executor\\execExprInterp.c, backend\\executor\\spi.c, backend\\executor\\execExpr.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c, backend\\jit\\llvm\\utils\\palloc.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\jit\\llvm\\llvmjit.c, interfaces\\libpq\\fe-exec.c, include\\jit\\llvmjit_emit.h, backend\\utils\\mmgr\\mcxt.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\jit\\llvmjit.h, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\jit\\llvm\\postgres.h, backend\\utils\\activity\\pgstat_relation.c, backend\\utils\\fmgr\\fmgr.c, include\\utils\\timestamp.h, backend\\utils\\adt\\format_type.c, backend\\utils\\activity\\pgstat_function.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\float.c, backend\\libpq\\be-fsstubs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\adt\\datum.c, include\\utils\\expandeddatum.h, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\jit\\llvm\\postgres.h, backend\\utils\\cache\\syscache.c, backend\\catalog\\pg_depend.c, backend\\utils\\error\\elog.c, common\\encnames.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\table\\table.c, backend\\utils\\mb\\mbutils.c, backend\\utils\\adt\\name.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\jit\\llvm\\postgres.h, backend\\utils\\hash\\dynahash.c, backend\\nodes\\readfuncs.c, backend\\utils\\cache\\lsyscache.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\cache\\inval.c, backend\\utils\\cache\\catcache.c, backend\\utils\\cache\\syscache.c, backend\\utils\\cache\\relfilenumbermap.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\jit\\llvm\\postgres.h, include\\executor\\tuptable.h, backend\\executor\\execExprInterp.c, backend\\executor\\execUtils.c, backend\\executor\\nodeWindowAgg.c, backend\\executor\\execGrouping.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\port\\win32\\signal.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\jit\\llvm\\postgres.h, include\\utils\\varbit.h, backend\\utils\\fmgr\\fmgr.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\jit\\llvm\\utils\\palloc.h, backend\\access\\spgist\\spgdoinsert.c, backend\\utils\\mmgr\\mcxt.c, backend\\storage\\buffer\\bufmgr.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\spgist\\spgutils.c, include\\storage\\bufmgr.h, backend\\utils\\mmgr\\aset.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\jit\\llvm\\utils\\palloc.h, backend\\executor\\execExprInterp.c, backend\\executor\\nodeWindowAgg.c, backend\\utils\\mmgr\\mcxt.c, include\\executor\\executor.h, backend\\executor\\nodeValuesscan.c, interfaces\\libpq\\fe-exec.c, backend\\executor\\execScan.c, include\\nodes\\nodes.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\jit\\llvm\\utils\\palloc.h, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, backend\\storage\\lmgr\\proc.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\lib\\ilist.h, backend\\storage\\lmgr\\lock.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\jit\\llvm\\utils\\palloc.h, backend\\utils\\mmgr\\mcxt.c, common\\stringinfo.c, backend\\nodes\\readfuncs.c, common\\parse_manifest.c, backend\\backup\\walsummary.c, backend\\backup\\basebackup_throttle.c, include\\nodes\\pg_list.h, backend\\backup\\basebackup_zstd.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\jit\\llvm\\utils\\palloc.h, include\\port\\pg_bitutils.h, backend\\utils\\adt\\datum.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\fmgr\\fmgr.c, include\\common\\hashfn.h, backend\\executor\\execTuples.c, backend\\executor\\execExprInterp.c, include\\executor\\tuptable.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\lib\\dshash.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\lib\\hyperloglog.c, backend\\utils\\mmgr\\mcxt.c, backend\\access\\gin\\ginpostinglist.c, backend\\lib\\dshash.c, include\\port\\pg_bitutils.h, backend\\jit\\llvm\\postgres.h, include\\common\\hashfn.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\libpq\\auth-scram.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\libpq\\auth-sasl.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\libpq\\auth-scram.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-secure-openssl.c, backend\\libpq\\be-secure.c, interfaces\\libpq\\fe-exec.c, backend\\libpq\\be-gssapi-common.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\libpq\\auth-scram.c, common\\percentrepl.c, backend\\storage\\file\\fd.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, port\\explicit_bzero.c, common\\wait_error.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\libpq\\auth-scram.c, common\\stringinfo.c, backend\\libpq\\auth-sasl.c, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, backend\\regex\\regfree.c, backend\\utils\\mb\\mbutils.c, backend\\regex\\regcomp.c, backend\\regex\\regerror.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\libpq\\auth.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\sort\\tuplestore.c, backend\\access\\common\\tupdesc.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\libpq\\be-fsstubs.c, backend\\utils\\fmgr\\fmgr.c, backend\\jit\\llvm\\postgres.h, backend\\foreign\\foreign.c, backend\\utils\\adt\\json.c, backend\\utils\\adt\\varlena.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\bitmapset.c, backend\\nodes\\copyfuncs.c, include\\nodes\\nodes.h, include\\nodes\\pg_list.h, backend\\nodes\\list.c, backend\\optimizer\\util\\appendinfo.c, backend\\rewrite\\rewriteManip.c, backend\\nodes\\nodeFuncs.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\bitmapset.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\list.c, backend\\optimizer\\util\\relnode.c, backend\\optimizer\\util\\var.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\optimizer\\util\\joininfo.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\copyfuncs.c, backend\\executor\\execExprInterp.c, include\\nodes\\nodes.h, backend\\utils\\activity\\backend_status.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\list.c, backend\\nodes\\outfuncs.c, backend\\nodes\\readfuncs.c, backend\\executor\\nodeSeqscan.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\makefuncs.c, backend\\nodes\\readfuncs.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\nodes\\pg_list.h, backend\\nodes\\tidbitmap.c, backend\\utils\\cache\\lsyscache.c, backend\\nodes\\extensible.c, backend\\utils\\adt\\format_type.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\nodeFuncs.c, backend\\nodes\\readfuncs.c, backend\\rewrite\\rewriteDefine.c, interfaces\\libpq\\fe-exec.c, include\\nodes\\pg_list.h, backend\\nodes\\list.c, backend\\nodes\\bitmapset.c, backend\\rewrite\\rewriteHandler.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\outfuncs.c, backend\\utils\\adt\\name.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\varlena.c, backend\\access\\table\\table.c, backend\\utils\\cache\\syscache.c, backend\\utils\\error\\elog.c, backend\\utils\\cache\\lsyscache.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\outfuncs.c, backend\\utils\\mmgr\\mcxt.c, port\\snprintf.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, interfaces\\libpq\\fe-print.c, backend\\nodes\\extensible.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, common\\stringinfo.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\access\\index\\indexam.c, backend\\executor\\nodeWindowAgg.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, include\\executor\\executor.h, backend\\executor\\nodeBitmapHeapscan.c, backend\\executor\\execExprInterp.c, include\\executor\\tuptable.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\catalog\\pg_collation.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\jit\\llvm\\postgres.h, backend\\catalog\\pg_constraint.c, backend\\catalog\\pg_class.c, backend\\parser\\parse_coerce.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\commands\\aggregatecmds.c, backend\\commands\\async.c, backend\\commands\\define.c, backend\\commands\\seclabel.c, backend\\utils\\error\\elog.c, backend\\parser\\parse_node.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\nodes\\queryjumble.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\executor\\execExprInterp.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, include\\lib\\ilist.h, backend\\access\\transam\\xact.c, backend\\utils\\mmgr\\aset.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\executor\\execProcnode.c, backend\\executor\\nodeWindowAgg.c, backend\\executor\\execExprInterp.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\tidbitmap.c, interfaces\\libpq\\fe-exec.c, include\\access\\tableam.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\executor\\execSRF.c, backend\\executor\\nodeWindowAgg.c, backend\\utils\\sort\\tuplestore.c, backend\\executor\\nodeAppend.c, backend\\executor\\execExprInterp.c, include\\executor\\tuptable.h, interfaces\\libpq\\fe-exec.c, backend\\jit\\llvm\\postgres.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\executor\\nodeMergejoin.c, include\\nodes\\nodes.h, interfaces\\libpq\\fe-exec.c, backend\\executor\\execExprInterp.c, backend\\nodes\\list.c, backend\\nodes\\makefuncs.c, backend\\utils\\cache\\lsyscache.c, backend\\nodes\\nodeFuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\access\\common\\tupdesc.c, interfaces\\libpq\\fe-exec.c, backend\\access\\brin\\brin.c, backend\\utils\\mmgr\\mcxt.c, backend\\jit\\llvm\\postgres.h, backend\\access\\common\\detoast.c, backend\\access\\common\\toast_internals.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\libpq\\auth-sasl.c, backend\\libpq\\auth-scram.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\libpq\\be-secure-common.c, backend\\utils\\misc\\guc.c, common\\protocol_openssl.c, interfaces\\libpq\\fe-secure-openssl.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\nodes\\nodeFuncs.c, interfaces\\libpq\\fe-exec.c, backend\\optimizer\\util\\appendinfo.c, backend\\optimizer\\util\\paramassign.c, backend\\nodes\\bitmapset.c, backend\\optimizer\\util\\clauses.c, backend\\optimizer\\util\\inherit.c, backend\\nodes\\list.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\optimizer\\prep\\prepjointree.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\makefuncs.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\cache\\lsyscache.c, include\\nodes\\nodes.h, backend\\nodes\\list.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\optimizer\\prep\\prepjointree.c, include\\nodes\\pg_list.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\table\\table.c, backend\\optimizer\\util\\appendinfo.c, backend\\optimizer\\util\\var.c, backend\\nodes\\list.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\optimizer\\util\\appendinfo.c, backend\\optimizer\\util\\joininfo.c, backend\\optimizer\\util\\restrictinfo.c, backend\\nodes\\bitmapset.c, backend\\optimizer\\util\\clauses.c, include\\nodes\\nodeFuncs.h, backend\\nodes\\list.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\optimizer\\util\\relnode.c, backend\\optimizer\\plan\\analyzejoins.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\optimizer\\util\\inherit.c, backend\\optimizer\\util\\var.c, backend\\nodes\\bitmapset.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\parser\\parse_agg.c, interfaces\\libpq\\fe-exec.c, backend\\parser\\analyze.c, backend\\parser\\parse_coerce.c, backend\\parser\\parse_clause.c, include\\nodes\\pg_list.h, backend\\utils\\error\\elog.c, backend\\parser\\parse_node.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\parser\\parse_expr.c, backend\\nodes\\makefuncs.c, backend\\parser\\analyze.c, include\\nodes\\pg_list.h, backend\\nodes\\list.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\nodeFuncs.c, backend\\parser\\parse_coerce.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\postmaster\\checkpointer.c, backend\\port\\win32\\signal.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h, backend\\utils\\mmgr\\aset.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\libpq\\pqsignal.c, interfaces\\libpq\\legacy-pqsignal.c, backend\\bootstrap\\bootstrap.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\replication\\logical\\applyparallelworker.c, backend\\utils\\hash\\dynahash.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\aset.c, backend\\replication\\logical\\launcher.c, backend\\utils\\cache\\inval.c, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\bitmapset.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\statistics\\extended_stats.c, backend\\utils\\mmgr\\mcxt.c, backend\\access\\gin\\ginpostinglist.c, backend\\statistics\\dependencies.c, port\\bsearch_arg.c, backend\\utils\\cache\\typcache.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\storage\\buffer\\buf_table.c, backend\\utils\\hash\\dynahash.c, interfaces\\libpq\\fe-exec.c, include\\storage\\buf_internals.h, backend\\storage\\lmgr\\lwlock.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\storage\\buffer\\localbuf.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\storage\\page\\itemptr.c, backend\\utils\\mmgr\\mcxt.c, backend\\access\\spgist\\spgdoinsert.c, interfaces\\libpq\\fe-exec.c, include\\storage\\bufmgr.h, include\\storage\\bufpage.h, backend\\utils\\error\\elog.c, backend\\storage\\buffer\\bufmgr.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\tcop\\postgres.c, backend\\executor\\nodeResult.c, backend\\executor\\nodeProjectSet.c, backend\\executor\\nodeModifyTable.c, backend\\executor\\nodeAppend.c, backend\\executor\\nodeMergeAppend.c, backend\\executor\\nodeRecursiveunion.c, backend\\executor\\nodeBitmapAnd.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\utils\\adt\\datum.c, backend\\nodes\\extensible.c, backend\\nodes\\bitmapset.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\tidbitmap.c, interfaces\\libpq\\fe-exec.c, backend\\tcop\\postgres.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\backup\\walsummary.c, backend\\storage\\file\\fd.c, backend\\port\\sysv_sema.c, interfaces\\libpq\\fe-exec.c, interfaces\\libpq\\fe-secure-gssapi.c, backend\\port\\posix_sema.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-secure-gssapi.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h, backend\\access\\transam\\xlogrecovery.c, common\\exec.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\sys\\stat.h, backend\\utils\\adt\\genfile.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\utils\\cache\\lsyscache.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\common\\scankey.c, backend\\jit\\llvm\\postgres.h, backend\\access\\table\\table.c, backend\\utils\\time\\snapmgr.c, backend\\access\\index\\genam.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\utils\\cache\\lsyscache.c, include\\nodes\\nodes.h, backend\\nodes\\makefuncs.c, backend\\parser\\analyze.c, backend\\parser\\parse_type.c, backend\\parser\\parse_node.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\fmgr\\fmgr.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mb\\mbutils.c, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-connect.c, backend\\storage\\ipc\\latch.c, backend\\replication\\walreceiver.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\nodes\\pg_list.h, backend\\nodes\\list.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\bitmapset.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\utils\\fmgr\\dfmgr.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\access\\common\\tupdesc.c, backend\\executor\\execTuples.c, backend\\utils\\sort\\tuplestore.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\utils\\misc\\pg_rusage.c, backend\\utils\\adt\\timestamp.c, backend\\utils\\activity\\backend_progress.c, backend\\access\\heap\\heapam.c, backend\\utils\\mmgr\\mcxt.c, backend\\commands\\dbcommands.c, backend\\utils\\cache\\lsyscache.c, backend\\commands\\vacuum.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\utils\\mmgr\\mcxt.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\bitmapset.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\expandedrecord.c, backend\\executor\\nodeAgg.c, backend\\utils\\adt\\format_type.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\utils\\adt\\array_expanded.c, backend\\utils\\fmgr\\fmgr.c, backend\\utils\\adt\\formatting.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, backend\\access\\gist\\gist.c, backend\\utils\\mmgr\\generation.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\lib\\integerset.c, backend\\access\\transam\\xlog.c, backend\\access\\gist\\gistutil.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, backend\\partitioning\\partbounds.c, backend\\optimizer\\util\\relnode.c, backend\\optimizer\\path\\joinrels.c, backend\\nodes\\bitmapset.c, backend\\nodes\\list.c, include\\nodes\\nodes.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, port\\explicit_bzero.c, common\\controldata_utils.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, common\\cryptohash.c, common\\config_info.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, backend\\utils\\sort\\tuplestore.c, backend\\executor\\execExprInterp.c, backend\\executor\\nodeValuesscan.c, backend\\executor\\execScan.c, include\\nodes\\nodes.h, backend\\executor\\execUtils.c, backend\\access\\common\\tupdesc.c, backend\\executor\\execTuples.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, bin\\pg_combinebackup\\copy_file.c, interfaces\\libpq\\fe-exec.c, common\\fe_memutils.c, bin\\pg_combinebackup\\backup_label.c, port\\snprintf.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\sys\\stat.h, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, common\\psprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, bin\\psql\\command.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, common\\cryptohash.c, common\\hmac.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, common\\fe_memutils.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, bin\\pg_dump\\pg_backup_archiver.c, bin\\pg_dump\\pg_backup_utils.c, interfaces\\libpq\\fe-print.c, interfaces\\libpq\\fe-exec.c, bin\\pg_dump\\compress_io.c, backend\\storage\\file\\buffile.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, common\\fe_memutils.c, fe_utils\\parallel_slot.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, port\\snprintf.c, interfaces\\libpq\\fe-exec.c, fe_utils\\mbprint.c, interfaces\\libpq\\fe-print.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, common\\relpath.c, backend\\commands\\aggregatecmds.c, backend\\utils\\cache\\relmapper.c, backend\\commands\\seclabel.c, backend\\storage\\lmgr\\lmgr.c, backend\\storage\\buffer\\bufmgr.c, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\list.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, common\\stringinfo.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, common\\d2s.c, backend\\nodes\\list.c, include\\nodes\\pg_list.h, backend\\nodes\\bitmapset.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, include\\access\\tableam.h, interfaces\\libpq\\fe-exec.c, backend\\executor\\execExprInterp.c, backend\\executor\\execScan.c, backend\\executor\\nodeBitmapHeapscan.c, include\\nodes\\nodes.h, backend\\executor\\execUtils.c, backend\\executor\\execTuples.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, include\\jit\\llvmjit.h, backend\\jit\\llvm\\llvmjit.c, include\\portability\\instr_time.h, include\\jit\\llvmjit_emit.h, backend\\utils\\mmgr\\mcxt.c, backend\\executor\\execExprInterp.c, interfaces\\libpq\\fe-exec.c, backend\\jit\\llvm\\llvmjit_deform.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, include\\utils\\guc.h, backend\\utils\\misc\\conffiles.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\hash\\dynahash.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\misc\\guc_internal.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-connect.c, backend\\storage\\file\\fd.c, backend\\utils\\error\\elog.c, backend\\storage\\ipc\\latch.c, backend\\tcop\\postgres.c, interfaces\\libpq\\fe-exec.c, interfaces\\libpq\\fe-cancel.c, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-connect.c, bin\\pg_basebackup\\pg_basebackup.c, port\\snprintf.c, bin\\pg_basebackup\\bbstreamer_file.c, port\\dirent.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\regex\\regerror.c, backend\\regex\\regc_pg_locale.c, backend\\regex\\regexport.c, backend\\regex\\regexec.c, backend\\utils\\mmgr\\mcxt.c, backend\\regex\\regc_color.c, backend\\regex\\regc_nfa.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\acl.c, backend\\utils\\init\\miscinit.c, backend\\commands\\aggregatecmds.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\commands\\seclabel.c, backend\\access\\table\\table.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\fmgr\\dfmgr.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\common\\heaptuple.c, backend\\optimizer\\util\\clauses.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\fmgr\\funcapi.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, pl\\plpython\\plpy_elog.c, backend\\executor\\spi.c, pl\\plpython\\plpy_typeio.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, bin\\pg_basebackup\\bbstreamer_file.c, interfaces\\libpq\\fe-connect.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, common\\fe_memutils.c, common\\sprompt.c, bin\\pg_basebackup\\pg_basebackup.c, bin\\pg_basebackup\\pg_createsubscriber.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, bin\\pg_dump\\pg_dump.c, common\\logging.c, bin\\pg_dump\\parallel.c, bin\\pg_dump\\pg_backup_archiver.c, port\\path.c, bin\\pg_dump\\pg_backup_utils.c, port\\getopt_long.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, common\\fe_memutils.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, bin\\pg_dump\\pg_backup_archiver.c, bin\\pg_dump\\pg_backup_utils.c, interfaces\\libpq\\fe-print.c, port\\snprintf.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, common\\fe_memutils.c, interfaces\\libpq\\fe-misc.c, bin\\psql\\command.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, interfaces\\libpq\\pqexpbuffer.c, interfaces\\libpq\\fe-misc.c, interfaces\\libpq\\fe-auth-scram.c, interfaces\\libpq\\fe-gssapi-common.c, interfaces\\libpq\\fe-connect.c, common\\md5_common.c, common\\username.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, port\\chklocale.c, common\\logging.c, port\\path.c, fe_utils\\option_utils.c, port\\getopt_long.c, common\\fe_memutils.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-lobj.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\winsock2.h, interfaces\\libpq\\pqexpbuffer.c, interfaces\\libpq\\fe-misc.c, interfaces\\libpq\\win32.c, interfaces\\libpq\\fe-exec.c, interfaces\\libpq\\fe-secure-common.c, port\\inet_aton.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, interfaces\\libpq\\pqexpbuffer.c, interfaces\\libpq\\fe-misc.c, port\\snprintf.c, backend\\access\\gin\\ginpostinglist.c, interfaces\\libpq\\libpq-fe.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, interfaces\\libpq\\fe-protocol3.c, interfaces\\libpq\\libpq-events.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, port\\pg_strong_random.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-secure-gssapi.c, interfaces\\libpq\\fe-print.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, backend\\access\\index\\amvalidate.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, port\\pgstrcasecmp.c, backend\\tcop\\backend_startup.c, backend\\utils\\adt\\numutils.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, port\\snprintf.c, port\\pgstrcasecmp.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, C:\\mingw64\\x86_64-w64-mingw32\\include\\locale.h, pl\\plperl\\plperl.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, tools\\pg_bsd_indent\\args.c, interfaces\\libpq\\fe-exec.c, tools\\pg_bsd_indent\\err.c, tools\\pg_bsd_indent\\lexi.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, interfaces\\libpq\\fe-print.c, tools\\pg_bsd_indent\\io.c, backend\\regex\\regcomp.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\readfuncs.c, tools\\pg_bsd_indent\\args.c, tools\\pg_bsd_indent\\io.c, tools\\pg_bsd_indent\\indent.c, tools\\pg_bsd_indent\\err.c, interfaces\\libpq\\fe-exec.c, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\nodes\\tidbitmap.c, backend\\parser\\scansup.c, backend\\nodes\\readfuncs.c, backend\\utils\\mmgr\\mcxt.c, backend\\jit\\llvm\\postgres.h, include\\common\\hashfn.h, interfaces\\libpq\\fe-exec.c, backend\\tcop\\postgres.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\optimizer\\geqo\\geqo_copy.c, backend\\optimizer\\geqo\\geqo_random.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\optimizer\\geqo\\geqo_random.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\optimizer\\geqo\\geqo_random.c, backend\\optimizer\\geqo\\geqo_pool.c, backend\\optimizer\\geqo\\geqo_erx.c, backend\\optimizer\\geqo\\geqo_selection.c, backend\\optimizer\\geqo\\geqo_eval.c, backend\\nodes\\readfuncs.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\optimizer\\path\\allpaths.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\optimizer\\path\\clausesel.c, backend\\jit\\llvm\\utils\\palloc.h, include\\nodes\\nodes.h, backend\\nodes\\list.c, backend\\optimizer\\path\\indxpath.c, backend\\utils\\cache\\lsyscache.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\optimizer\\path\\allpaths.c, backend\\utils\\fmgr\\fmgr.c, backend\\jit\\llvm\\postgres.h, interfaces\\libpq\\fe-exec.c, backend\\access\\tablesample\\system.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\optimizer\\path\\allpaths.c, include\\nodes\\nodeFuncs.h, backend\\nodes\\nodeFuncs.c, backend\\nodes\\equalfuncs.c, backend\\utils\\cache\\lsyscache.c, include\\nodes\\nodes.h, backend\\optimizer\\util\\restrictinfo.c, backend\\nodes\\readfuncs.c, backend\\nodes\\list.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\optimizer\\path\\allpaths.c, include\\nodes\\pg_list.h, backend\\nodes\\bitmapset.c, backend\\optimizer\\util\\joininfo.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\readfuncs.c, backend\\optimizer\\util\\pathnode.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\optimizer\\path\\allpaths.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\bitmapset.c, backend\\optimizer\\plan\\analyzejoins.c, backend\\optimizer\\path\\costsize.c, include\\nodes\\pg_list.h, backend\\nodes\\list.c, backend\\optimizer\\util\\clauses.c, backend\\utils\\cache\\typcache.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\optimizer\\path\\equivclass.c, backend\\optimizer\\path\\allpaths.c, backend\\optimizer\\path\\costsize.c, backend\\nodes\\list.c, backend\\optimizer\\util\\pathnode.c, backend\\nodes\\readfuncs.c, backend\\nodes\\bitmapset.c, include\\nodes\\pg_list.h, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\optimizer\\plan\\analyzejoins.c, include\\nodes\\pg_list.h, backend\\utils\\cache\\lsyscache.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\optimizer\\plan\\subselect.c, backend\\nodes\\nodeFuncs.c, backend\\optimizer\\util\\relnode.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\optimizer\\plan\\planagg.c, include\\nodes\\pg_list.h, backend\\nodes\\nodeFuncs.c, backend\\optimizer\\plan\\analyzejoins.c, backend\\nodes\\copyfuncs.c, backend\\optimizer\\plan\\planner.c, interfaces\\libpq\\fe-exec.c, backend\\optimizer\\util\\relnode.c, backend\\optimizer\\plan\\createplan.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\optimizer\\prep\\prepjointree.c, backend\\optimizer\\util\\relnode.c, backend\\tcop\\postgres.c, interfaces\\libpq\\fe-exec.c, backend\\optimizer\\plan\\planner.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\optimizer\\path\\costsize.c, backend\\optimizer\\util\\tlist.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\optimizer\\prep\\prepjointree.c, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\parser\\parse_agg.c, backend\\optimizer\\prep\\prepunion.c, include\\nodes\\pg_list.h, backend\\nodes\\nodeFuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\optimizer\\util\\appendinfo.c, backend\\access\\table\\table.c, backend\\optimizer\\prep\\preptlist.c, backend\\parser\\parse_relation.c, backend\\catalog\\pg_inherits.c, backend\\nodes\\readfuncs.c, backend\\optimizer\\util\\relnode.c, include\\nodes\\pg_list.h, backend\\nodes\\makefuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\optimizer\\util\\appendinfo.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\nodes\\list.c, backend\\nodes\\readfuncs.c, backend\\nodes\\bitmapset.c, backend\\optimizer\\path\\pathkeys.c, backend\\port\\win32\\signal.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\optimizer\\util\\appendinfo.c, include\\nodes\\pg_list.h, backend\\nodes\\bitmapset.c, backend\\optimizer\\path\\equivclass.c, backend\\optimizer\\plan\\initsplan.c, backend\\optimizer\\util\\restrictinfo.c, backend\\nodes\\makefuncs.c, backend\\optimizer\\util\\relnode.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\optimizer\\util\\appendinfo.c, include\\nodes\\pg_list.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\nodes\\nodeFuncs.h, backend\\utils\\fmgr\\fmgr.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\arrayutils.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\optimizer\\util\\joininfo.c, backend\\nodes\\equalfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\optimizer\\util\\restrictinfo.c, include\\nodes\\pg_list.h, backend\\nodes\\makefuncs.c, backend\\nodes\\copyfuncs.c, backend\\optimizer\\util\\appendinfo.c, backend\\nodes\\list.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\optimizer\\util\\paramassign.c, include\\nodes\\nodes.h, interfaces\\libpq\\fe-exec.c, backend\\optimizer\\util\\appendinfo.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\copyfuncs.c, backend\\optimizer\\util\\var.c, backend\\nodes\\bitmapset.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\parser\\analyze.c, backend\\nodes\\readfuncs.c, backend\\catalog\\namespace.c, backend\\parser\\parse_agg.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\cache\\lsyscache.c, backend\\utils\\error\\elog.c, backend\\parser\\parse_node.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\parser\\analyze.c, backend\\utils\\error\\elog.c, backend\\parser\\parse_node.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\nodes\\list.c, include\\nodes\\nodes.h, backend\\parser\\parse_expr.c, backend\\nodes\\copyfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\parser\\parse_agg.c, backend\\nodes\\nodeFuncs.c, backend\\nodes\\readfuncs.c, backend\\parser\\analyze.c, backend\\utils\\error\\elog.c, backend\\utils\\cache\\lsyscache.c, backend\\parser\\parse_node.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\list.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\parser\\parse_agg.c, backend\\parser\\parse_relation.c, backend\\parser\\analyze.c, backend\\nodes\\list.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\readfuncs.c, backend\\access\\table\\table.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\parser\\parse_agg.c, include\\nodes\\pg_list.h, backend\\parser\\analyze.c, include\\nodes\\nodes.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\parser\\parse_cte.c, interfaces\\libpq\\fe-exec.c, backend\\parser\\parse_clause.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\parser\\parse_expr.c, backend\\catalog\\namespace.c, backend\\parser\\parse_agg.c, backend\\parser\\analyze.c, backend\\utils\\error\\elog.c, backend\\parser\\parse_node.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\parser\\parse_clause.c, include\\nodes\\pg_list.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\parser\\parse_node.c, backend\\nodes\\readfuncs.c, backend\\catalog\\namespace.c, backend\\parser\\parse_agg.c, backend\\catalog\\pg_depend.c, backend\\parser\\analyze.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\parser\\parse_node.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\parser\\parse_param.c, include\\nodes\\queryjumble.h, backend\\nodes\\queryjumblefuncs.c, backend\\utils\\activity\\backend_status.c, include\\nodes\\nodes.h, backend\\parser\\parse_merge.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\parser\\parse_type.c, backend\\nodes\\readfuncs.c, backend\\commands\\aggregatecmds.c, backend\\commands\\alter.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\cache\\syscache.c, backend\\commands\\amcmds.c, backend\\catalog\\namespace.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\port\\atomics.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\port\\atomics.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, include\\common\\hashfn_unstable.h, backend\\utils\\activity\\pgstat.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\port\\atomics.c, backend\\utils\\activity\\pgstat_bgwriter.c, common\\stringinfo.c, backend\\libpq\\pqformat.c, include\\libpq\\pqformat.h, backend\\utils\\activity\\pgstat_database.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\port\\atomics.c, include\\port\\atomics.h, backend\\utils\\resowner\\resowner.c, backend\\jit\\llvm\\postgres.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\port\\win32\\crashdump.c, port\\path.c, backend\\utils\\misc\\ps_status.c, backend\\utils\\mmgr\\mcxt.c, pl\\plperl\\plperl.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\bootstrap\\bootstrap.c, backend\\utils\\misc\\help_config.c, backend\\tcop\\postgres.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\postmaster\\auxprocess.c, interfaces\\libpq\\legacy-pqsignal.c, backend\\bootstrap\\bootstrap.c, backend\\storage\\file\\fd.c, backend\\nodes\\readfuncs.c, backend\\storage\\ipc\\ipc.c, backend\\utils\\mmgr\\aset.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\postmaster\\checkpointer.c, backend\\access\\transam\\xlogrecovery.c, backend\\storage\\ipc\\ipc.c, backend\\utils\\mmgr\\mcxt.c, include\\utils\\guc.h, backend\\postmaster\\pgarch.c, backend\\storage\\ipc\\pmsignal.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\storage\\ipc\\procsignal.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\postmaster\\checkpointer.c, backend\\postmaster\\fork_process.c, backend\\postmaster\\postmaster.c, backend\\utils\\init\\miscinit.c, backend\\storage\\ipc\\dsm.c, backend\\port\\sysv_shmem.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\utils\\mmgr\\mcxt.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\postmaster\\checkpointer.c, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\misc\\ps_status.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\port\\win32\\signal.c, interfaces\\libpq\\legacy-pqsignal.c, backend\\bootstrap\\bootstrap.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\regex\\regc_color.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\regex\\regc_locale.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\regex\\regc_locale.c, backend\\regex\\regc_nfa.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\regex\\regexec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\replication\\logical\\applyparallelworker.c, backend\\access\\transam\\transam.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\replication\\logical\\snapbuild.c, backend\\storage\\lmgr\\spin.c, backend\\storage\\lmgr\\s_lock.c, backend\\replication\\logical\\logical.c, backend\\replication\\logical\\launcher.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\replication\\logical\\applyparallelworker.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\transam\\xlog.c, port\\pgstrcasecmp.c, backend\\replication\\logical\\launcher.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\varlena.c, backend\\utils\\cache\\syscache.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\replication\\logical\\applyparallelworker.c, backend\\utils\\mmgr\\aset.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\mmgr\\slab.c, backend\\utils\\mmgr\\generation.c, backend\\utils\\hash\\dynahash.c, interfaces\\libpq\\fe-exec.c, backend\\lib\\pairingheap.c, backend\\replication\\logical\\launcher.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\replication\\logical\\reorderbuffer.c, include\\access\\xlog_internal.h, interfaces\\libpq\\fe-exec.c, backend\\replication\\logical\\snapbuild.c, backend\\replication\\logical\\applyparallelworker.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\rmgrdesc\\xactdesc.c, backend\\replication\\logical\\logical.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\replication\\syncrep.c, backend\\access\\transam\\xlog.c, backend\\storage\\ipc\\pmsignal.c, backend\\replication\\slot.c, backend\\storage\\lmgr\\lwlock.c, backend\\utils\\mmgr\\mcxt.c, backend\\storage\\lmgr\\condition_variable.c, include\\utils\\wait_event.h, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\replication\\walsender.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\rewrite\\rewriteHandler.c, backend\\rewrite\\rewriteDefine.c, backend\\parser\\parse_relation.c, backend\\rewrite\\rewriteManip.c, backend\\utils\\init\\miscinit.c, backend\\utils\\misc\\rls.c, backend\\access\\table\\table.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\snowball\\libstemmer\\utilities.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\buffer\\bufmgr.c, backend\\access\\brin\\brin.c, backend\\access\\brin\\brin_pageops.c, include\\storage\\bufmgr.h, include\\storage\\bufpage.h, backend\\utils\\mmgr\\mcxt.c, include\\storage\\itemptr.h, backend\\nodes\\readfuncs.c, backend\\port\\win32\\signal.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\buffer\\bufmgr.c, include\\storage\\buf_internals.h, backend\\nodes\\readfuncs.c, backend\\utils\\hash\\dynahash.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\resowner\\resowner.c, backend\\storage\\buffer\\buf_table.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\buffer\\bufmgr.c, include\\utils\\rel.h, backend\\catalog\\catalog.c, backend\\utils\\cache\\spccache.c, backend\\storage\\buffer\\freelist.c, backend\\storage\\buffer\\localbuf.c, backend\\access\\gin\\ginpostinglist.c, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\file\\buffile.c, backend\\storage\\file\\fd.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, port\\snprintf.c, common\\file_utils.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\file\\buffile.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\readfuncs.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\numutils.c, interfaces\\libpq\\fe-lobj.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\file\\buffile.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\aset.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\postmaster\\startup.c, backend\\storage\\file\\fd.c, backend\\nodes\\readfuncs.c, backend\\storage\\file\\copydir.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\file\\copydir.c, backend\\utils\\mmgr\\aset.c, interfaces\\libpq\\fe-exec.c, backend\\storage\\smgr\\bulk_write.c, backend\\commands\\tablespace.c, common\\relpath.c, backend\\storage\\file\\fd.c, interfaces\\libpq\\fe-lobj.c, backend\\utils\\adt\\float.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\file\\fd.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\file\\fd.c, interfaces\\libpq\\fe-exec.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\list.c, port\\snprintf.c, interfaces\\libpq\\fe-lobj.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\freespace\\freespace.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\barrier.c, backend\\storage\\ipc\\shm_mq.c, backend\\storage\\lmgr\\spin.c, interfaces\\libpq\\fe-exec.c, backend\\storage\\lmgr\\s_lock.c, backend\\access\\gin\\ginpostinglist.c, backend\\storage\\ipc\\dsm.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\barrier.c, backend\\storage\\lmgr\\spin.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\storage\\ipc\\dsm.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\storage\\lmgr\\s_lock.c, backend\\storage\\ipc\\dsm_registry.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\dsm.c, backend\\nodes\\readfuncs.c, backend\\libpq\\auth-scram.c, backend\\storage\\ipc\\shm_mq.c, interfaces\\libpq\\fe-exec.c, backend\\libpq\\auth-sasl.c, backend\\replication\\logical\\worker.c, backend\\storage\\ipc\\procsignal.c, backend\\storage\\ipc\\latch.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\dsm.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\storage\\ipc\\barrier.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\dsm.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\storage\\ipc\\shmem.c, backend\\storage\\lmgr\\proc.c, backend\\storage\\lmgr\\spin.c, backend\\port\\posix_sema.c, backend\\utils\\hash\\dynahash.c, backend\\storage\\ipc\\dsm_registry.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\dsm_registry.c, backend\\storage\\ipc\\barrier.c, backend\\storage\\lmgr\\spin.c, interfaces\\libpq\\fe-exec.c, include\\port\\atomics.h, backend\\access\\gin\\ginpostinglist.c, backend\\storage\\lmgr\\s_lock.c, backend\\storage\\ipc\\latch.c, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\ipc.c, backend\\storage\\smgr\\bulk_write.c, backend\\nodes\\readfuncs.c, backend\\utils\\hash\\dynahash.c, include\\lib\\ilist.h, backend\\storage\\smgr\\md.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\ipc.c, common\\psprintf.c, backend\\libpq\\auth-scram.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, backend\\libpq\\hba.c, backend\\libpq\\auth-sasl.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\ipc.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\init\\miscinit.c, backend\\utils\\misc\\guc.c, port\\getopt.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, common\\psprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\latch.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\processthreadsapi.h, bin\\pg_ctl\\pg_ctl.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\errhandlingapi.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\securitybaseapi.h, port\\win32security.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\handleapi.h, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\procarray.c, backend\\nodes\\readfuncs.c, backend\\storage\\ipc\\dsm.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\misc\\superuser.c, backend\\utils\\adt\\acl.c, backend\\utils\\init\\miscinit.c, backend\\utils\\adt\\float.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\shmem.c, backend\\access\\common\\reloptions.c, backend\\access\\common\\scankey.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\storage\\lmgr\\lwlock.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\shmem.c, backend\\access\\gin\\ginpostinglist.c, include\\port\\atomics.h, backend\\storage\\ipc\\pmsignal.c, backend\\storage\\lmgr\\condition_variable.c, backend\\storage\\ipc\\dsm.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\port\\atomics.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\shmem.c, backend\\access\\transam\\xlogfuncs.c, backend\\access\\transam\\xact.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\transam\\xloginsert.c, include\\access\\transam.h, backend\\access\\transam\\xlog.c, backend\\storage\\lmgr\\lwlock.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\shmem.c, backend\\port\\posix_sema.c, backend\\storage\\lmgr\\proc.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\shmem.c, backend\\postmaster\\checkpointer.c, backend\\postmaster\\pgarch.c, backend\\storage\\lmgr\\condition_variable.c, backend\\postmaster\\auxprocess.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\legacy-pqsignal.c, backend\\bootstrap\\bootstrap.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\shmem.c, backend\\postmaster\\checkpointer.c, include\\port\\atomics.h, backend\\nodes\\readfuncs.c, backend\\postmaster\\auxprocess.c, interfaces\\libpq\\legacy-pqsignal.c, backend\\bootstrap\\bootstrap.c, backend\\storage\\file\\fd.c, backend\\port\\win32\\signal.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\shmem.c, backend\\replication\\slot.c, backend\\storage\\lmgr\\condition_variable.c, backend\\storage\\lmgr\\spin.c, include\\port\\atomics.h, interfaces\\libpq\\fe-exec.c, backend\\replication\\syncrep.c, backend\\storage\\lmgr\\s_lock.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\shmem.c, backend\\storage\\buffer\\localbuf.c, backend\\storage\\buffer\\buf_table.c, include\\storage\\buf_internals.h, include\\port\\atomics.h, backend\\storage\\lmgr\\lwlock.c, backend\\storage\\lmgr\\condition_variable.c, backend\\storage\\buffer\\freelist.c, backend\\storage\\buffer\\bufmgr.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\shmem.c, backend\\storage\\lmgr\\lwlock.c, backend\\utils\\mmgr\\dsa.c, backend\\lib\\dshash.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\storage\\ipc\\barrier.c, backend\\storage\\ipc\\dsm.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\shmem.c, backend\\storage\\lmgr\\proc.c, backend\\storage\\lmgr\\spin.c, backend\\utils\\hash\\dynahash.c, backend\\jit\\llvm\\postgres.h, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\storage\\lmgr\\lwlock.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\shmem.c, backend\\storage\\lmgr\\proc.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\storage\\lmgr\\lock.c, backend\\storage\\lmgr\\spin.c, backend\\storage\\lmgr\\s_lock.c, include\\port\\pg_bitutils.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\shmem.c, backend\\storage\\lmgr\\spin.c, backend\\storage\\ipc\\latch.c, backend\\storage\\lmgr\\condition_variable.c, backend\\access\\transam\\xlogfuncs.c, backend\\postmaster\\startup.c, backend\\utils\\mmgr\\mcxt.c, backend\\access\\transam\\xlogreader.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\shmem.c, backend\\utils\\activity\\pgstat_bgwriter.c, backend\\storage\\ipc\\ipc.c, backend\\utils\\init\\miscinit.c, backend\\utils\\activity\\pgstat_database.c, backend\\utils\\activity\\backend_progress.c, backend\\port\\atomics.c, port\\strlcpy.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\ipc\\shmem.c, include\\lib\\ilist.h, interfaces\\libpq\\fe-exec.c, include\\port\\atomics.h, backend\\port\\posix_sema.c, backend\\storage\\ipc\\latch.c, backend\\storage\\lmgr\\lwlock.c, backend\\storage\\lmgr\\spin.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\lmgr\\lwlock.c, backend\\access\\transam\\transam.c, include\\access\\slru.h, backend\\access\\transam\\slru.c, backend\\access\\transam\\xlogfuncs.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\transam\\xlog.c, backend\\utils\\adt\\xid.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\lmgr\\proc.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\tcop\\postgres.c, backend\\libpq\\auth.c, backend\\storage\\file\\fd.c, backend\\port\\win32\\signal.c, backend\\libpq\\pqcomm.c, interfaces\\libpq\\legacy-pqsignal.c, backend\\bootstrap\\bootstrap.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\lmgr\\proc.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\storage\\s_lock.h, backend\\storage\\lmgr\\spin.c, include\\utils\\wait_event.h, backend\\port\\win32\\signal.c, common\\pg_prng.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\lmgr\\proc.c, include\\lib\\ilist.h, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\transam\\transam.c, backend\\access\\transam\\slru.c, backend\\storage\\ipc\\shmem.c, backend\\storage\\lmgr\\lwlock.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\lmgr\\spin.c, backend\\storage\\file\\fileset.c, backend\\storage\\ipc\\dsm.c, backend\\jit\\llvm\\postgres.h, backend\\storage\\lmgr\\s_lock.c, backend\\storage\\file\\buffile.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\lmgr\\spin.c, backend\\storage\\lmgr\\condition_variable.c, backend\\storage\\lmgr\\s_lock.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\lmgr\\spin.c, backend\\storage\\lmgr\\s_lock.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\storage\\lmgr\\spin.c, include\\storage\\proclist.h, backend\\nodes\\readfuncs.c, backend\\storage\\lmgr\\s_lock.c, backend\\storage\\lmgr\\proc.c, include\\portability\\instr_time.h, backend\\storage\\ipc\\latch.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\tcop\\backend_startup.c, backend\\libpq\\pqformat.c, include\\libpq\\pqformat.h, backend\\utils\\cache\\lsyscache.c, backend\\utils\\fmgr\\fmgr.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\tcop\\dest.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\tcop\\postgres.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-secure-gssapi.c, interfaces\\libpq\\fe-exec.c, backend\\port\\win32\\socket.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\processthreadsapi.h, port\\win32error.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\errhandlingapi.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\tcop\\postgres.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\tsearch\\dict_ispell.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, port\\path.c, backend\\utils\\mmgr\\mcxt.c, port\\snprintf.c, backend\\nodes\\readfuncs.c, backend\\tsearch\\ts_locale.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\tsearch\\ts_locale.c, backend\\tsearch\\dict_synonym.c, backend\\tsearch\\dict_ispell.c, backend\\tsearch\\dict_thesaurus.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mb\\mbutils.c, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\tsearch\\ts_locale.c, backend\\utils\\mb\\mbutils.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\tsearch\\dict_ispell.c, backend\\nodes\\readfuncs.c, backend\\commands\\define.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\activity\\backend_status.c, backend\\utils\\activity\\pgstat_shmem.c, backend\\storage\\ipc\\shmem.c, backend\\utils\\hash\\dynahash.c, backend\\storage\\lmgr\\spin.c, backend\\utils\\activity\\pgstat_io.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\storage\\lmgr\\lwlock.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\activity\\pgstat.c, backend\\utils\\activity\\pgstat_database.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\activity\\pgstat_xact.c, backend\\utils\\activity\\pgstat_shmem.c, backend\\utils\\activity\\pgstat_bgwriter.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\activity\\pgstat_bgwriter.c, backend\\storage\\ipc\\shmem.c, backend\\utils\\mmgr\\dsa.c, backend\\lib\\dshash.c, backend\\nodes\\readfuncs.c, include\\port\\atomics.h, backend\\storage\\lmgr\\lwlock.c, backend\\jit\\llvm\\utils\\palloc.h, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\activity\\pgstat_bgwriter.c, backend\\utils\\activity\\pgstat_database.c, include\\portability\\instr_time.h, backend\\utils\\activity\\pgstat.c, backend\\storage\\lmgr\\lwlock.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\activity\\pgstat_bgwriter.c, include\\utils\\pgstat_internal.h, backend\\utils\\activity\\pgstat_io.c, backend\\utils\\activity\\pgstat.c, backend\\storage\\lmgr\\lwlock.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\activity\\pgstat_io.c, backend\\utils\\activity\\pgstat.c, backend\\utils\\activity\\pgstat_bgwriter.c, backend\\executor\\instrument.c, backend\\storage\\lmgr\\lwlock.c, backend\\utils\\activity\\pgstat_database.c, include\\portability\\instr_time.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\activity\\pgstat_shmem.c, backend\\utils\\activity\\pgstat_database.c, backend\\utils\\activity\\pgstat_bgwriter.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\activity\\pgstat_xact.c, backend\\access\\transam\\xact.c, backend\\utils\\adt\\timestamp.c, backend\\utils\\activity\\pgstat_io.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\array_userfuncs.c, backend\\parser\\parse_expr.c, backend\\parser\\parse_coerce.c, backend\\nodes\\nodeFuncs.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c, backend\\parser\\parse_node.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\arraysubs.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c, backend\\parser\\parse_node.c, backend\\nodes\\nodeFuncs.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\parser\\parse_expr.c, backend\\parser\\parse_coerce.c, backend\\utils\\adt\\format_type.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\arrayutils.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\format_type.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\formatting.c, port\\snprintf.c, backend\\utils\\adt\\float.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\arrayutils.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\varbit.c, backend\\utils\\adt\\format_type.c, backend\\utils\\mmgr\\mcxt.c, port\\snprintf.c, backend\\utils\\mb\\mbutils.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\arrayutils.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, common\\psprintf.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\date.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\arrayutils.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, common\\psprintf.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\json.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\datum.c, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\extensible.c, include\\nodes\\nodes.h, backend\\nodes\\bitmapset.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\expandedrecord.c, backend\\executor\\nodeWindowAgg.c, backend\\libpq\\be-fsstubs.c, backend\\utils\\fmgr\\fmgr.c, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\access\\gin\\ginutil.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, backend\\utils\\mmgr\\mcxt.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\arpa\\inet.h, backend\\utils\\error\\elog.c, backend\\utils\\adt\\formatting.c, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\adt\\tsvector.c, backend\\utils\\mb\\mbutils.c, backend\\tsearch\\ts_locale.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\nodes\\read.c, backend\\utils\\error\\elog.c, port\\pgstrcasecmp.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\adt\\tsvector_op.c, include\\access\\tableam.h, backend\\jit\\llvm\\postgres.h, interfaces\\libpq\\fe-exec.c, backend\\access\\table\\table.c, backend\\utils\\error\\elog.c, backend\\utils\\cache\\relcache.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\float.c, backend\\parser\\parse_coerce.c, backend\\utils\\fmgr\\fmgr.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\array_typanalyze.c, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c, common\\encnames.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\regexp.c, backend\\utils\\fmgr\\fmgr.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\format_type.c, backend\\utils\\adt\\float.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\expandedrecord.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\genfile.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\varlena.c, backend\\utils\\mb\\mbutils.c, backend\\utils\\fmgr\\fmgr.c, backend\\utils\\sort\\tuplestore.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\backup\\walsummary.c, backend\\storage\\file\\fd.c, backend\\port\\posix_sema.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\init\\miscinit.c, backend\\storage\\ipc\\shmem.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\storage\\file\\fd.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\utils\\error\\elog.c, interfaces\\ecpg\\pgtypeslib\\timestamp.c, interfaces\\ecpg\\pgtypeslib\\datetime.c, port\\snprintf.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\utils\\error\\elog.c, interfaces\\libpq\\fe-secure-gssapi.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\fileapi.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\errhandlingapi.h, port\\win32error.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, port\\snprintf.c, common\\pg_lzcompress.c, common\\controldata_utils.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-exec.c, common\\stringinfo.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\error\\elog.c, pl\\plpython\\plpy_cursorobject.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-exec.c, interfaces\\libpq\\fe-secure-gssapi.c, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-exec.c, port\\snprintf.c, backend\\lib\\dshash.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, port\\strerror.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-secure-gssapi.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\processthreadsapi.h, backend\\storage\\ipc\\dsm_impl.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\init\\miscinit.c, port\\win32error.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\errhandlingapi.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, port\\chklocale.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-secure-gssapi.c, backend\\backup\\walsummary.c, backend\\storage\\file\\fd.c, backend\\storage\\ipc\\dsm_impl.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, port\\win32gettimeofday.c, interfaces\\libpq\\legacy-pqsignal.c, backend\\bootstrap\\bootstrap.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\signal.h, backend\\storage\\file\\fd.c, backend\\port\\win32\\signal.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\access\\gist\\gistget.c, backend\\access\\index\\genam.c, backend\\access\\gist\\gist.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\aset.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\llvmjit.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, port\\pgstrcasecmp.c, backend\\utils\\error\\elog.c, backend\\utils\\adt\\date.c, include\\utils\\numeric.h, backend\\utils\\adt\\formatting.c, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, backend\\access\\gin\\ginutil.c, common\\psprintf.c, backend\\libpq\\pqformat.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, backend\\utils\\error\\elog.c, backend\\utils\\mmgr\\mcxt.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\arpa\\inet.h, backend\\utils\\adt\\formatting.c, port\\snprintf.c, backend\\libpq\\pqformat.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\access\\brin\\brin_minmax_multi.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\arpa\\inet.h, backend\\access\\gist\\gistproc.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\adt\\network_selfuncs.c, backend\\utils\\adt\\tsquery_gist.c, include\\storage\\bufpage.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\access\\gin\\ginutil.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\varbit.c, backend\\utils\\adt\\expandedrecord.c, include\\nodes\\nodeFuncs.h, include\\nodes\\pg_list.h, backend\\utils\\adt\\tsvector_op.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\access\\nbtree\\nbtcompare.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\varbit.c, backend\\libpq\\pqformat.c, include\\libpq\\pqformat.h, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\access\\spgist\\spgdoinsert.c, backend\\utils\\fmgr\\fmgr.c, include\\utils\\geo_decls.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\access\\spgist\\spgdoinsert.c, backend\\utils\\mmgr\\mcxt.c, backend\\executor\\execExprInterp.c, backend\\utils\\fmgr\\fmgr.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, include\\common\\int.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\access\\spgist\\spgdoinsert.c, include\\utils\\geo_decls.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, backend\\jit\\llvm\\port.h, backend\\utils\\fmgr\\fmgr.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\backup\\walsummaryfuncs.c, backend\\utils\\adt\\format_type.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\catalog\\catalog.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\tsvector_op.c, backend\\catalog\\namespace.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\commands\\analyze.c, backend\\utils\\cache\\lsyscache.c, backend\\utils\\adt\\formatting.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\cache\\typcache.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\foreign\\foreign.c, backend\\access\\gist\\gistproc.c, backend\\utils\\adt\\format_type.c, include\\utils\\rangetypes.h, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\adt\\rangetypes.c, backend\\utils\\adt\\tsquery_gist.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\libpq\\be-fsstubs.c, backend\\utils\\fmgr\\fmgr.c, backend\\utils\\adt\\numutils.c, backend\\backup\\walsummaryfuncs.c, backend\\utils\\mmgr\\mcxt.c, backend\\libpq\\pqformat.c, include\\libpq\\pqformat.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\libpq\\pqformat.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\jsonb_gin.c, include\\utils\\jsonpath.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\nodes\\readfuncs.c, backend\\utils\\mmgr\\mcxt.c, backend\\lib\\pairingheap.c, include\\storage\\itemptr.h, backend\\access\\spgist\\spgdoinsert.c, interfaces\\libpq\\fe-exec.c, backend\\jit\\llvm\\utils\\palloc.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\expandedrecord.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\arpa\\inet.h, backend\\utils\\adt\\network_selfuncs.c, backend\\utils\\adt\\inet_cidr_ntop.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\network.c, backend\\utils\\adt\\formatting.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\expandedrecord.c, backend\\libpq\\pqformat.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, include\\utils\\jsonb.h, backend\\utils\\adt\\genfile.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\adt\\rangetypes.c, include\\utils\\rangetypes.h, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\jit\\llvm\\port.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\format_type.c, backend\\tcop\\postgres.c, backend\\utils\\fmgr\\fmgr.c, backend\\utils\\adt\\expandedrecord.c, include\\utils\\rangetypes.h, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\format_type.c, backend\\utils\\adt\\array_userfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\cache\\lsyscache.c, backend\\utils\\fmgr\\fmgr.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\format_type.c, backend\\utils\\adt\\expandedrecord.c, backend\\tcop\\postgres.c, backend\\utils\\error\\elog.c, backend\\utils\\cache\\typcache.c, backend\\nodes\\readfuncs.c, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\format_type.c, backend\\utils\\adt\\selfuncs.c, backend\\utils\\fmgr\\fmgr.c, backend\\utils\\adt\\varbit.c, backend\\utils\\cache\\lsyscache.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\format_type.c, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, backend\\utils\\error\\elog.c, port\\pgstrcasecmp.c, backend\\utils\\fmgr\\fmgr.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\numutils.c, backend\\utils\\mmgr\\mcxt.c, backend\\libpq\\pqformat.c, include\\libpq\\pqformat.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\numutils.c, interfaces\\libpq\\fe-exec.c, backend\\catalog\\catalog.c, backend\\utils\\adt\\format_type.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\formatting.c, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\numutils.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\formatting.c, port\\snprintf.c, backend\\libpq\\pqformat.c, include\\libpq\\pqformat.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\rangetypes.c, backend\\utils\\cache\\lsyscache.c, backend\\utils\\adt\\multirangetypes.c, backend\\nodes\\readfuncs.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\adt\\formatting.c, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\regproc.c, backend\\utils\\mb\\mbutils.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\format_type.c, backend\\utils\\adt\\varchar.c, backend\\catalog\\catalog.c, backend\\libpq\\pqformat.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\selfuncs.c, backend\\utils\\fmgr\\fmgr.c, backend\\tsearch\\dict_thesaurus.c, include\\tsearch\\ts_type.h, backend\\utils\\cache\\lsyscache.c, backend\\tsearch\\ts_parse.c, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\varlena.c, backend\\utils\\adt\\expandedrecord.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\cache\\syscache.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\varlena.c, backend\\utils\\adt\\jsonfuncs.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\adt\\format_type.c, backend\\foreign\\foreign.c, backend\\utils\\adt\\formatting.c, backend\\utils\\fmgr\\fmgr.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\error\\elog.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\utils\\mmgr\\mcxt.c, include\\storage\\itemptr.h, backend\\utils\\adt\\formatting.c, port\\snprintf.c, backend\\libpq\\pqformat.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\fmgr\\fmgr.c, backend\\storage\\ipc\\procarray.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\activity\\wait_event.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\adt\\arrayfuncs.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\fmgr\\fmgr.c, include\\utils\\geo_decls.h, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\formatting.c, backend\\utils\\adt\\format_type.c, backend\\utils\\adt\\rowtypes.c, backend\\executor\\execUtils.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\hash\\dynahash.c, backend\\commands\\vacuum.c, include\\tsearch\\ts_type.h, backend\\utils\\mmgr\\mcxt.c, backend\\tsearch\\dict_ispell.c, backend\\nodes\\readfuncs.c, backend\\tsearch\\ts_selfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\mb\\mbutils.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\mb\\mbutils.c, backend\\utils\\mb\\conv.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\mb\\mbutils.c, backend\\utils\\mb\\conv.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\mb\\mbutils.c, backend\\utils\\mb\\conv.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\mb\\mbutils.c, common\\wchar.c, backend\\utils\\mb\\conversion_procs\\euc_tw_and_big5\\big5.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\mmgr\\mcxt.c, backend\\libpq\\pqformat.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\arrayfuncs.c, backend\\utils\\adt\\enum.c, backend\\utils\\adt\\rangetypes.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\mmgr\\mcxt.c, backend\\tsearch\\dict_ispell.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\tsearch\\ts_utils.c, backend\\commands\\define.c, backend\\access\\gin\\ginutil.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\mmgr\\mcxt.c, backend\\tsearch\\spell.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\tsearch\\ts_utils.c, backend\\commands\\define.c, backend\\access\\gin\\ginutil.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\tsquery_op.c, include\\tsearch\\ts_type.h, backend\\utils\\adt\\tsgistidx.c, include\\tsearch\\ts_utils.h, backend\\access\\gin\\ginutil.c, backend\\utils\\adt\\tsrank.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\mmgr\\mcxt.c, include\\utils\\uuid.h, backend\\utils\\adt\\expandedrecord.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, backend\\nodes\\readfuncs.c, backend\\utils\\error\\elog.c, backend\\libpq\\pqformat.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\optimizer\\path\\allpaths.c, backend\\utils\\cache\\spccache.c, backend\\nodes\\readfuncs.c, include\\nodes\\pg_list.h, backend\\access\\tablesample\\tablesample.c, backend\\nodes\\list.c, backend\\optimizer\\path\\equivclass.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, backend\\utils\\adt\\formatting.c, common\\stringinfo.c, backend\\utils\\mmgr\\mcxt.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c, backend\\nodes\\readfuncs.c, backend\\jit\\llvm\\postgres.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\float.c, include\\utils\\float.h, backend\\utils\\adt\\geo_ops.c, backend\\utils\\mmgr\\mcxt.c, include\\utils\\geo_decls.h, backend\\jit\\llvm\\postgres.h, backend\\utils\\fmgr\\fmgr.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\format_type.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\float.c, backend\\tcop\\utility.c, backend\\storage\\large_object\\inv_api.c, backend\\access\\transam\\xact.c, backend\\utils\\time\\snapmgr.c, backend\\libpq\\auth-scram.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\format_type.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\formatting.c, backend\\utils\\fmgr\\fmgr.c, backend\\tsearch\\dict_ispell.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\cache\\ts_cache.c, backend\\tsearch\\dict_thesaurus.c, backend\\utils\\adt\\float.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\format_type.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\cache\\typcache.c, backend\\utils\\mmgr\\mcxt.c, backend\\access\\brin\\brin.c, backend\\access\\gin\\ginutil.c, backend\\utils\\adt\\float.c, backend\\foreign\\foreign.c, backend\\utils\\adt\\formatting.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\format_type.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\float.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\adt\\formatting.c, backend\\utils\\fmgr\\fmgr.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\format_type.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\mmgr\\mcxt.c, backend\\access\\brin\\brin.c, backend\\utils\\cache\\typcache.c, backend\\access\\gin\\ginutil.c, backend\\utils\\adt\\float.c, backend\\foreign\\foreign.c, backend\\utils\\adt\\formatting.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\format_type.c, backend\\storage\\ipc\\procarray.c, backend\\access\\transam\\transam.c, backend\\catalog\\pg_enum.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\format_type.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\jsonb_gin.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\readfuncs.c, backend\\utils\\adt\\jsonb_op.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\formatting.c, backend\\utils\\fmgr\\fmgr.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\float.c, backend\\access\\transam\\xlog.c, backend\\utils\\adt\\varlena.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\formatting.c, backend\\utils\\fmgr\\fmgr.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\tsvector_op.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\adt\\geo_ops.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\float.c, include\\tsearch\\ts_type.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\formatting.c, backend\\utils\\fmgr\\fmgr.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\varlena.c, backend\\utils\\adt\\ruleutils.c, backend\\utils\\adt\\format_type.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\ascii.c, backend\\utils\\adt\\geo_ops.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\formatting.c, backend\\utils\\fmgr\\fmgr.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\varlena.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\format_type.c, backend\\utils\\adt\\float.c, backend\\utils\\mb\\mbutils.c, backend\\utils\\adt\\expandedrecord.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\formatting.c, backend\\utils\\fmgr\\fmgr.c, backend\\jit\\llvm\\postgres.h, interfaces\\libpq\\fe-exec.c, common\\md5_common.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\format_type.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\formatting.c, port\\snprintf.c, backend\\utils\\adt\\expandedrecord.c, include\\common\\int.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\utils\\float.h, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\formatting.c, port\\snprintf.c, backend\\utils\\adt\\genfile.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\varlena.c, backend\\utils\\adt\\int.c, backend\\utils\\fmgr\\funcapi.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\access\\common\\tupdesc.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\genfile.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\varlena.c, common\\psprintf.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\adt\\arrayfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\libpq\\auth.c, backend\\nodes\\list.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\genfile.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\cache\\syscache.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\cache\\lsyscache.c, backend\\utils\\adt\\format_type.c, backend\\utils\\adt\\int.c, backend\\utils\\fmgr\\funcapi.c, backend\\jit\\llvm\\utils\\palloc.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\genfile.c, backend\\storage\\file\\fd.c, backend\\nodes\\readfuncs.c, backend\\utils\\adt\\geo_ops.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, backend\\utils\\adt\\formatting.c, port\\snprintf.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\sys\\stat.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\genfile.c, backend\\utils\\adt\\tsrank.c, backend\\utils\\adt\\expandedrecord.c, include\\tsearch\\ts_type.h, backend\\jit\\llvm\\postgres.h, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\tsvector.c, backend\\utils\\adt\\geo_ops.c, backend\\access\\gin\\ginutil.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\json.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\mmgr\\aset.c, backend\\utils\\adt\\hbafuncs.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\mb\\mbutils.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\regex\\regcomp.c, backend\\regex\\regerror.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\jsonb.c, include\\utils\\jsonb.h, backend\\utils\\adt\\formatting.c, backend\\utils\\fmgr\\fmgr.c, backend\\jit\\llvm\\postgres.h, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\jsonb_gin.c, backend\\utils\\adt\\jsonb_util.c, backend\\utils\\adt\\float.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\jsonb.c, port\\pgstrcasecmp.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\formatting.c, backend\\utils\\adt\\ruleutils.c, backend\\utils\\adt\\float.c, backend\\utils\\adt\\format_type.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\regproc.c, backend\\utils\\adt\\format_type.c, backend\\jit\\llvm\\postgres.h, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\float.c, common\\stringinfo.c, backend\\executor\\spi.c, backend\\utils\\adt\\ri_triggers.c, backend\\utils\\adt\\expandedrecord.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\regproc.c, common\\jsonapi.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\fmgr\\fmgr.c, backend\\utils\\adt\\jsonb.c, backend\\utils\\mb\\mbutils.c, backend\\utils\\adt\\int.c, include\\utils\\jsonb.h, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\timestamp.c, backend\\utils\\activity\\pgstat_bgwriter.c, backend\\utils\\activity\\pgstat.c, interfaces\\libpq\\fe-exec.c, backend\\storage\\lmgr\\lwlock.c, backend\\utils\\activity\\pgstat_database.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\timestamp.c, include\\utils\\pgstat_internal.h, backend\\utils\\activity\\pgstat.c, backend\\storage\\lmgr\\lwlock.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\timestamp.c, interfaces\\libpq\\fe-exec.c, backend\\access\\transam\\xact.c, backend\\nodes\\readfuncs.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\numutils.c, include\\common\\int.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\timestamp.c, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\tsrank.c, backend\\utils\\adt\\tsquery_util.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, backend\\tcop\\postgres.c, backend\\utils\\adt\\geo_ops.c, backend\\port\\win32\\signal.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\tsrank.c, include\\common\\int.h, backend\\utils\\adt\\geo_spgist.c, backend\\jit\\llvm\\port.h, backend\\utils\\adt\\tsvector_op.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\tsrank.c, include\\tsearch\\ts_type.h, backend\\utils\\adt\\geo_ops.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\float.c, backend\\utils\\adt\\tsquery_util.c, backend\\access\\gin\\ginutil.c, backend\\utils\\adt\\tsvector_op.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\tsvector_op.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\jit\\llvm\\postgres.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\tsvector_op.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\mmgr\\mcxt.c, backend\\jit\\llvm\\port.h, backend\\utils\\adt\\jsonb.c, backend\\utils\\adt\\float.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\varbit.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\adt\\regproc.c, backend\\utils\\adt\\float.c, backend\\utils\\error\\elog.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\utils\\adt\\formatting.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\adt\\varlena.c, port\\path.c, backend\\utils\\adt\\acl.c, backend\\utils\\init\\miscinit.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\format_type.c, backend\\storage\\file\\fd.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\cache\\lsyscache.c, backend\\nodes\\readfuncs.c, backend\\executor\\execExprInterp.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\portalmem.c, interfaces\\libpq\\fe-exec.c, backend\\executor\\nodeLockRows.c, include\\storage\\itemptr.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\cache\\lsyscache.c, backend\\utils\\cache\\catcache.c, backend\\utils\\cache\\relcache.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\jit\\llvm\\port.h, include\\lib\\qunique.h, include\\storage\\itemptr.h, backend\\storage\\lmgr\\lock.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\cache\\lsyscache.c, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\executor\\execIndexing.c, backend\\executor\\nodeWindowAgg.c, backend\\executor\\execExprInterp.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\common\\scankey.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\cache\\lsyscache.c, backend\\utils\\fmgr\\fmgr.c, backend\\jit\\llvm\\postgres.h, interfaces\\libpq\\fe-exec.c, backend\\access\\table\\tableam.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\access\\transam\\xact.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\cache\\lsyscache.c, backend\\utils\\fmgr\\fmgr.c, backend\\jit\\llvm\\postgres.h, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\cache\\syscache.c, backend\\utils\\adt\\format_type.c, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\cache\\partcache.c, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\jit\\llvm\\port.h, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\datum.c, backend\\nodes\\bitmapset.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\cache\\plancache.c, backend\\commands\\sequence.c, backend\\catalog\\namespace.c, backend\\commands\\alter.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\transam\\xact.c, backend\\utils\\mmgr\\portalmem.c, backend\\utils\\misc\\guc_funcs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\cache\\relcache.c, backend\\utils\\cache\\lsyscache.c, backend\\storage\\lmgr\\lwlock.c, backend\\access\\transam\\xact.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, port\\snprintf.c, backend\\storage\\file\\fd.c, interfaces\\libpq\\fe-lobj.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\cache\\relcache.c, include\\nodes\\pg_list.h, backend\\utils\\mmgr\\mcxt.c, backend\\access\\index\\indexam.c, backend\\catalog\\index.c, backend\\nodes\\list.c, backend\\nodes\\readfuncs.c, backend\\executor\\execExprInterp.c, backend\\executor\\execUtils.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\catalog\\pg_constraint.c, interfaces\\libpq\\fe-exec.c, backend\\catalog\\pg_class.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\catalog\\aclchk.c, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\commands\\seclabel.c, backend\\commands\\alter.c, backend\\catalog\\aclchk.c, backend\\utils\\init\\miscinit.c, backend\\catalog\\objectaddress.c, backend\\utils\\cache\\lsyscache.c, backend\\catalog\\catalog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\storage\\page\\itemptr.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\utils\\adt\\varlena.c, pl\\plpgsql\\src\\pl_scanner.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c, backend\\access\\common\\reloptions.c, backend\\nodes\\readfuncs.c, backend\\utils\\adt\\varlena.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, common\\psprintf.c, backend\\libpq\\auth-scram.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\varlena.c, include\\utils\\timestamp.h, backend\\utils\\adt\\timestamp.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\cache\\ts_cache.c, backend\\tsearch\\dict_thesaurus.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\jit\\llvm\\utils\\palloc.h, backend\\utils\\mmgr\\mcxt.c, backend\\jit\\llvm\\postgres.h, backend\\optimizer\\path\\allpaths.c, backend\\utils\\fmgr\\fmgr.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\cache\\typcache.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, backend\\utils\\adt\\format_type.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\aset.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\expandeddatum.c, backend\\access\\common\\tupdesc.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\error\\csvlog.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, backend\\jit\\llvm\\utils\\palloc.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, backend\\storage\\ipc\\ipc.c, backend\\port\\win32\\signal.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\commands\\aggregatecmds.c, backend\\utils\\cache\\lsyscache.c, backend\\catalog\\objectaddress.c, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, include\\access\\htup_details.h, backend\\utils\\misc\\superuser.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\storage\\ipc\\shmem.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\sys\\stat.h, backend\\storage\\ipc\\ipc.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-secure-gssapi.c, interfaces\\libpq\\fe-misc.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\utils\\adt\\varlena.c, backend\\commands\\define.c, backend\\commands\\subscriptioncmds.c, port\\pgstrcasecmp.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\varlena.c, include\\utils\\xml.h, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\mb\\mbutils.c, backend\\libpq\\pqformat.c, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, backend\\lib\\dshash.c, include\\port\\pg_bitutils.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, pl\\plpython\\plpy_elog.c, pl\\plpython\\plpy_main.c, backend\\nodes\\readfuncs.c, backend\\utils\\mmgr\\aset.c, pl\\plpython\\plpy_typeio.c, pl\\plpython\\plpy_spi.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\error\\elog.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\utils\\misc\\guc.c, port\\pgstrcasecmp.c, backend\\utils\\misc\\conffiles.c, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\error\\elog.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c, port\\path.c, common\\percentrepl.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\error\\elog.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, backend\\lib\\dshash.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\error\\elog.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\winbase.h, interfaces\\libpq\\fe-exec.c, port\\win32security.c, port\\snprintf.c, backend\\lib\\dshash.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, interfaces\\libpq\\fe-print.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\sys\\stat.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\error\\elog.c, backend\\utils\\adt\\pg_locale.c, backend\\utils\\mb\\mbutils.c, common\\unicode_category.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\corecrt_wctype.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, port\\pgstrcasecmp.c, common\\unicode_case.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\error\\elog.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\mb\\mbutils.c, backend\\nodes\\readfuncs.c, backend\\access\\heap\\heapam.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\list.c, backend\\commands\\seclabel.c, backend\\commands\\aggregatecmds.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\fmgr\\dfmgr.c, pl\\plpython\\plpy_cursorobject.c, pl\\plpython\\plpy_exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, pl\\plpython\\plpy_plpymodule.c, pl\\plpython\\plpy_elog.c, pl\\plpython\\plpy_procedure.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\fmgr\\fmgr.c, backend\\access\\common\\reloptions.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\fmgr\\fmgr.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\float.c, backend\\utils\\cache\\lsyscache.c, backend\\utils\\adt\\arrayfuncs.c, backend\\access\\gin\\ginutil.c, backend\\utils\\adt\\genfile.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\fmgr\\fmgr.c, backend\\jit\\llvm\\postgres.h, include\\utils\\varbit.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\fmgr\\fmgr.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\adt\\format_type.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\arrayutils.c, backend\\utils\\adt\\genfile.c, backend\\utils\\adt\\float.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\regproc.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\fmgr\\funcapi.c, backend\\backup\\walsummary.c, backend\\backup\\basebackup_throttle.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, backend\\utils\\fmgr\\fmgr.c, include\\utils\\pg_lsn.h, backend\\access\\common\\heaptuple.c, backend\\utils\\sort\\tuplestore.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\fmgr\\funcapi.c, common\\config_info.c, backend\\utils\\misc\\guc.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\varlena.c, backend\\utils\\sort\\tuplestore.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\fmgr\\funcapi.c, interfaces\\libpq\\fe-exec.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\varlena.c, backend\\utils\\sort\\tuplestore.c, backend\\utils\\activity\\wait_event.c, common\\stringinfo.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\fmgr\\funcapi.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\misc\\guc.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\storage\\lmgr\\lwlock.c, common\\controldata_utils.c, backend\\utils\\misc\\conffiles.c, backend\\jit\\llvm\\postgres.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\hash\\dynahash.c, backend\\catalog\\pg_collation.c, backend\\catalog\\pg_class.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\storage\\smgr\\smgr.c, backend\\utils\\mmgr\\mcxt.c, backend\\access\\transam\\xact.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\hash\\dynahash.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\cache\\ts_cache.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\cache\\catcache.c, backend\\utils\\mmgr\\aset.c, backend\\utils\\cache\\inval.c, backend\\jit\\llvm\\utils\\palloc.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\hash\\dynahash.c, interfaces\\libpq\\fe-exec.c, pl\\plpython\\plpy_main.c, pl\\plpython\\plpy_cursorobject.c, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\init\\globals.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, backend\\postmaster\\postmaster.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, backend\\lib\\dshash.c, backend\\storage\\ipc\\ipc.c, backend\\storage\\ipc\\latch.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\init\\miscinit.c, backend\\nodes\\readfuncs.c, backend\\utils\\misc\\superuser.c, backend\\commands\\aggregatecmds.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\commands\\tablespace.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\cache\\syscache.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\init\\miscinit.c, backend\\utils\\adt\\acl.c, backend\\commands\\aggregatecmds.c, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\commands\\alter.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\init\\miscinit.c, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\catalog\\aclchk.c, backend\\utils\\misc\\conffiles.c, backend\\utils\\error\\elog.c, backend\\utils\\cache\\lsyscache.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\format_type.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\init\\miscinit.c, backend\\utils\\misc\\superuser.c, backend\\commands\\aggregatecmds.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\parser\\parse_func.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\cache\\lsyscache.c, backend\\catalog\\namespace.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\init\\miscinit.c, interfaces\\libpq\\fe-exec.c, backend\\commands\\aggregatecmds.c, include\\nodes\\pg_list.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\common\\relation.c, backend\\commands\\seclabel.c, backend\\catalog\\pg_class.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mb\\mbutils.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, backend\\utils\\adt\\pg_locale.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\corecrt_wctype.h, backend\\utils\\adt\\formatting.c, backend\\storage\\file\\fd.c, backend\\nodes\\readfuncs.c, backend\\tsearch\\dict_ispell.c, common\\stringinfo.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mb\\mbutils.c, backend\\nodes\\readfuncs.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\hash\\dynahash.c, backend\\utils\\misc\\guc.c, interfaces\\libpq\\fe-exec.c, port\\snprintf.c, backend\\utils\\init\\miscinit.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mb\\mbutils.c, backend\\utils\\adt\\varlena.c, backend\\utils\\error\\elog.c, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mb\\mbutils.c, backend\\utils\\mmgr\\mcxt.c, include\\lib\\radixtree.h, pl\\plperl\\plperl.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mb\\mbutils.c, common\\wchar.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mb\\mbutils.c, port\\pgstrcasecmp.c, backend\\utils\\adt\\pg_locale.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\formatting.c, backend\\executor\\execExprInterp.c, backend\\utils\\fmgr\\fmgr.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mb\\mbutils.c, port\\pgstrcasecmp.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\mmgr\\mcxt.c, backend\\tsearch\\ts_utils.c, backend\\commands\\define.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mb\\wstrncmp.c, backend\\regex\\regc_cvec.c, backend\\regex\\regc_pg_locale.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\misc\\conffiles.c, backend\\utils\\init\\miscinit.c, port\\snprintf.c, include\\utils\\ps_status.h, backend\\utils\\misc\\guc.c, backend\\utils\\error\\elog.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\handleapi.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\synchapi.h, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\misc\\guc.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\varlena.c, backend\\utils\\cache\\syscache.c, backend\\catalog\\pg_collation.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, backend\\access\\table\\table.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\misc\\guc.c, backend\\nodes\\readfuncs.c, backend\\utils\\misc\\conffiles.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\formatting.c, backend\\optimizer\\geqo\\geqo_eval.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\misc\\guc.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\misc\\conffiles.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\misc\\guc.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\misc\\conffiles.c, backend\\utils\\adt\\timestamp.c, backend\\port\\win32\\timer.c, interfaces\\libpq\\fe-exec.c, backend\\storage\\ipc\\latch.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\misc\\guc_funcs.c, backend\\access\\table\\table.c, backend\\catalog\\pg_constraint.c, backend\\access\\common\\scankey.c, backend\\jit\\llvm\\postgres.h, backend\\access\\index\\genam.c, backend\\catalog\\pg_collation.c, interfaces\\libpq\\fe-exec.c, include\\access\\htup_details.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\misc\\guc_tables.c, backend\\utils\\misc\\conffiles.c, common\\pg_prng.c, backend\\utils\\misc\\guc.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\misc\\queryenvironment.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\aset.c, backend\\executor\\nodeWindowAgg.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\executor\\execMain.c, include\\nodes\\nodes.h, interfaces\\libpq\\fe-exec.c, backend\\executor\\execExprInterp.c, backend\\executor\\execPartition.c, include\\nodes\\pg_list.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\aset.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\lib\\dshash.c, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\bitmapset.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\aset.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, backend\\access\\heap\\hio.c, backend\\storage\\buffer\\bufmgr.c, backend\\storage\\smgr\\bulk_write.c, backend\\utils\\hash\\dynahash.c, include\\storage\\itemptr.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\aset.c, backend\\jit\\llvm\\utils\\palloc.h, include\\nodes\\pg_list.h, interfaces\\libpq\\fe-exec.c, backend\\nodes\\list.c, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, backend\\optimizer\\path\\joinrels.c, backend\\optimizer\\path\\allpaths.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\aset.c, backend\\replication\\logical\\applyparallelworker.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\replication\\logical\\reorderbuffer.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\aset.c, backend\\utils\\hash\\dynahash.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\resowner\\resowner.c, backend\\access\\transam\\xact.c, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\aset.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\expandeddatum.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\expandedrecord.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, include\\utils\\expandeddatum.h, backend\\jit\\llvm\\utils\\palloc.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\aset.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\hash\\dynahash.c, backend\\postmaster\\checkpointer.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\backup\\walsummary.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\aset.c, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, backend\\tsearch\\dict_thesaurus.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\tsearch\\ts_locale.c, backend\\tsearch\\dict_synonym.c, backend\\utils\\mb\\mbutils.c, backend\\tsearch\\dict_ispell.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\aset.c, include\\lib\\ilist.h, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\readfuncs.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\mmgr\\bump.c, include\\utils\\memutils_memorychunk.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\aset.c, include\\utils\\memutils_memorychunk.h, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\mmgr\\bump.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\dsa.c, backend\\access\\common\\tupdesc.c, backend\\nodes\\readfuncs.c, backend\\utils\\hash\\dynahash.c, backend\\utils\\cache\\inval.c, backend\\utils\\cache\\catcache.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\winsock2.h, backend\\libpq\\auth-scram.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-misc.c, backend\\storage\\ipc\\ipc.c, backend\\storage\\ipc\\latch.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\access\\common\\reloptions.c, backend\\access\\common\\tupdesc.c, backend\\utils\\error\\elog.c, backend\\utils\\adt\\format_type.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\access\\gin\\ginpostinglist.c, backend\\statistics\\dependencies.c, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\fmgr\\fmgr.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\access\\gist\\gistutil.c, backend\\access\\gist\\gist.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\fmgr\\fmgr.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\access\\spgist\\spgdoinsert.c, include\\storage\\bufpage.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\storage\\page\\bufpage.c, backend\\access\\transam\\xlogutils.c, backend\\access\\spgist\\spgutils.c, include\\storage\\bufmgr.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\access\\transam\\xact.c, backend\\utils\\adt\\acl.c, backend\\utils\\init\\miscinit.c, backend\\backup\\basebackup_zstd.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, port\\pgcheckdir.c, backend\\storage\\file\\fd.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\backup\\basebackup_sink.c, backend\\utils\\adt\\timestamp.c, backend\\storage\\ipc\\latch.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\executor\\execIndexing.c, interfaces\\libpq\\fe-exec.c, backend\\executor\\execUtils.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\executor\\execMain.c, backend\\executor\\execExprInterp.c, backend\\executor\\nodeWindowAgg.c, backend\\port\\win32\\signal.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\utils\\adt\\datum.c, backend\\executor\\execExprInterp.c, include\\executor\\executor.h, backend\\jit\\llvm\\postgres.h, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\lib\\dshash.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\lib\\hyperloglog.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\read.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\nodes\\bitmapset.c, include\\nodes\\nodes.h, backend\\nodes\\extensible.c, backend\\tcop\\postgres.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\utils\\cache\\relmapper.c, interfaces\\libpq\\fe-exec.c, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, backend\\lib\\dshash.c, interfaces\\libpq\\fe-exec.c, backend\\lib\\hyperloglog.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, backend\\statistics\\extended_stats.c, backend\\utils\\cache\\typcache.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\aset.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\access\\gin\\ginpostinglist.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, backend\\storage\\ipc\\dsm.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\storage\\ipc\\shmem.c, backend\\utils\\cache\\typcache.c, backend\\storage\\ipc\\shm_toc.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\dsa.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, backend\\utils\\adt\\formatting.c, backend\\utils\\fmgr\\fmgr.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\varlena.c, backend\\utils\\adt\\geo_ops.c, backend\\utils\\adt\\float.c, backend\\utils\\adt\\jsonb.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, backend\\utils\\adt\\network_selfuncs.c, backend\\utils\\adt\\inet_cidr_ntop.c, backend\\utils\\adt\\inet_net_pton.c, backend\\access\\brin\\brin_minmax_multi.c, backend\\utils\\adt\\network_spgist.c, backend\\utils\\adt\\float.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, backend\\utils\\cache\\lsyscache.c, backend\\executor\\execExpr.c, interfaces\\libpq\\fe-exec.c, backend\\executor\\execExprInterp.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\fmgr\\fmgr.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\jit\\llvm\\utils\\palloc.h, backend\\nodes\\list.c, interfaces\\libpq\\fe-exec.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\fmgr\\fmgr.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, backend\\utils\\mb\\mbutils.c, backend\\tsearch\\dict_ispell.c, backend\\utils\\adt\\pg_locale.c, interfaces\\libpq\\fe-exec.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\corecrt_wctype.h, backend\\tsearch\\dict_thesaurus.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\access\\common\\reloptions.c, common\\stringinfo.c, backend\\utils\\mmgr\\aset.c, backend\\tcop\\pquery.c, include\\nodes\\pg_list.h, backend\\libpq\\pqformat.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\access\\index\\amapi.c, backend\\access\\transam\\xact.c, backend\\utils\\misc\\rls.c, backend\\access\\index\\amvalidate.c, backend\\catalog\\aclchk.c, backend\\utils\\init\\miscinit.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\jit\\llvm\\utils\\palloc.h, common\\config_info.c, backend\\jit\\llvm\\port.h, common\\d2s.c, common\\exec.c, port\\pg_crc32c_sb8.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\storage\\file\\fd.c, backend\\commands\\tablespace.c, port\\snprintf.c, backend\\storage\\file\\fileset.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\tsearch\\dict_ispell.c, backend\\tsearch\\ts_utils.c, backend\\tsearch\\ts_locale.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mb\\mbutils.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\optimizer\\geqo\\geqo_random.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\optimizer\\geqo\\geqo_recombination.c, backend\\optimizer\\geqo\\geqo_eval.c, backend\\optimizer\\geqo\\geqo_erx.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\jit\\llvm\\port.h, backend\\optimizer\\geqo\\geqo_copy.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\parser\\analyze.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\access\\table\\table.c, backend\\nodes\\readfuncs.c, backend\\utils\\mb\\mbutils.c, backend\\utils\\cache\\lsyscache.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\parser\\parse_agg.c, backend\\parser\\analyze.c, backend\\utils\\error\\elog.c, backend\\parser\\parse_node.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\nodes\\nodes.h, backend\\utils\\cache\\lsyscache.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\storage\\file\\buffile.c, backend\\access\\gist\\gist.c, backend\\utils\\hash\\dynahash.c, backend\\access\\gist\\gistbuild.c, backend\\jit\\llvm\\utils\\palloc.h, interfaces\\libpq\\fe-exec.c, backend\\nodes\\list.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\tcop\\postgres.c, backend\\utils\\adt\\tsrank.c, backend\\utils\\adt\\tsvector_op.c, backend\\utils\\adt\\tsquery_op.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\geo_spgist.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\tcop\\postgres.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\tsrank.c, backend\\utils\\adt\\tsvector_op.c, backend\\nodes\\readfuncs.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\adt\\array_typanalyze.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\format_type.c, backend\\utils\\adt\\int.c, backend\\utils\\adt\\json.c, backend\\utils\\fmgr\\fmgr.c, backend\\utils\\adt\\formatting.c, backend\\utils\\mb\\mbutils.c, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\int.c, backend\\lib\\hyperloglog.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, backend\\lib\\dshash.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\timestamp.c, backend\\libpq\\pqformat.c, include\\nodes\\pg_list.h, include\\libpq\\pqformat.h, interfaces\\libpq\\fe-exec.c, backend\\tcop\\dest.c, backend\\access\\common\\tupdesc.c, backend\\executor\\execTuples.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\cache\\typcache.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c, backend\\utils\\adt\\format_type.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\cache\\lsyscache.c, backend\\utils\\fmgr\\fmgr.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\mb\\mbutils.c, backend\\utils\\adt\\formatting.c, backend\\utils\\error\\elog.c, backend\\utils\\adt\\expandedrecord.c, backend\\nodes\\readfuncs.c, backend\\utils\\adt\\tsvector.c, backend\\tsearch\\ts_locale.c, backend\\utils\\adt\\float.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\misc\\conffiles.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\list.c, backend\\nodes\\readfuncs.c, backend\\access\\table\\table.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\mmgr\\aset.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\storage\\lmgr\\spin.c, backend\\storage\\ipc\\shmem.c, backend\\storage\\lmgr\\s_lock.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\mmgr\\bump.c, backend\\utils\\mmgr\\aset.c, backend\\utils\\mmgr\\dsa.c, backend\\access\\common\\reloptions.c, backend\\access\\gin\\ginpostinglist.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\storage\\itemptr.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\mmgr\\dsa.c, backend\\storage\\lmgr\\lwlock.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, common\\hashfn.c, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\sort\\logtape.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\sort\\sharedtuplestore.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\storage\\file\\buffile.c, backend\\nodes\\readfuncs.c, backend\\jit\\llvm\\utils\\palloc.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\time\\snapmgr.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\tcop\\backend_startup.c, backend\\executor\\execMain.c, include\\tcop\\cmdtag.h, include\\nodes\\pg_list.h, backend\\tcop\\utility.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, bin\\pg_basebackup\\bbstreamer_file.c, interfaces\\libpq\\fe-exec.c, bin\\pg_basebackup\\bbstreamer.h, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, port\\strlcpy.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, common\\config_info.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-exec.c, common\\psprintf.c, common\\controldata_utils.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, common\\d2s.c, common\\jsonapi.c, interfaces\\libpq\\fe-exec.c, common\\cryptohash.c, backend\\nodes\\readfuncs.c, common\\config_info.c, common\\checksum_helper.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, common\\stringinfo.c, bin\\pg_basebackup\\bbstreamer_file.c, bin\\pg_basebackup\\bbstreamer.h, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, port\\strlcpy.c, port\\tar.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, include\\port\\pg_bitutils.h, backend\\utils\\sort\\tuplesortvariants.c, backend\\nodes\\readfuncs.c, backend\\utils\\sort\\tuplesort.c, backend\\access\\hash\\hash.c, interfaces\\libpq\\fe-exec.c, backend\\access\\hash\\hashinsert.c, backend\\access\\hash\\hashpage.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, include\\portability\\instr_time.h, backend\\executor\\execExprInterp.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, include\\storage\\bufmgr.h, backend\\storage\\buffer\\bufmgr.c, backend\\access\\heap\\heapam.c, include\\storage\\itemptr.h, backend\\access\\heap\\pruneheap.c, backend\\executor\\execTuples.c, backend\\access\\heap\\heapam_visibility.c, backend\\storage\\page\\itemptr.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, include\\utils\\float.h, include\\utils\\geo_decls.h, backend\\utils\\adt\\geo_ops.c, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\expandedrecord.c, backend\\jit\\llvm\\port.h, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\lib\\dshash.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, common\\cryptohash.c, port\\explicit_bzero.c, common\\config_info.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, common\\md5.c, common\\sha1.c, common\\sha2.c, port\\explicit_bzero.c, common\\config_info.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, port\\strlcpy.c, port\\path.c, backend\\nodes\\readfuncs.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\storage\\file\\fd.c, common\\psprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\mmgr\\mcxt.c, port\\strlcpy.c, port\\path.c, port\\strlcat.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\resowner\\resowner.c, backend\\jit\\llvm\\postgres.h, backend\\nodes\\readfuncs.c, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, port\\explicit_bzero.c, common\\controldata_utils.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\resowner\\resowner.c, backend\\jit\\llvm\\postgres.h, interfaces\\libpq\\fe-exec.c, backend\\storage\\ipc\\barrier.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, common\\pg_prng.c, backend\\storage\\ipc\\dsm_impl.c, backend\\storage\\ipc\\ipc.c","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\sort\\logtape.c, backend\\executor\\execExprInterp.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\fmgr\\fmgr.c, backend\\utils\\cache\\lsyscache.c, backend\\optimizer\\path\\allpaths.c, backend\\jit\\llvm\\postgres.h","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\sort\\tuplesort.c, backend\\executor\\nodeNestloop.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\cache\\lsyscache.c, interfaces\\libpq\\fe-exec.c, backend\\executor\\nodeWindowAgg.c, backend\\executor\\execExprInterp.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, backend\\utils\\sort\\tuplesort.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\utils\\sort\\logtape.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\sort\\sortsupport.c, backend\\catalog\\index.c, backend\\access\\nbtree\\nbtutils.c","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\pg_basebackup\\bbstreamer_file.c, common\\rmtree.c, interfaces\\libpq\\fe-exec.c, interfaces\\libpq\\fe-connect.c, common\\fe_memutils.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, port\\path.c, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\pg_basebackup\\bbstreamer_file.c, interfaces\\libpq\\fe-exec.c, bin\\pg_basebackup\\pg_basebackup.c, port\\snprintf.c, interfaces\\libpq\\pqexpbuffer.c, fe_utils\\string_utils.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-connect.c, common\\fe_memutils.c","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\pg_basebackup\\bbstreamer_file.c, port\\snprintf.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, bin\\pg_basebackup\\pg_basebackup.c, bin\\pg_basebackup\\walmethods.c, include\\access\\xlog_internal.h, common\\fe_memutils.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\pg_combinebackup\\backup_label.c, common\\fe_memutils.c, port\\snprintf.c, common\\stringinfo.c, bin\\pg_combinebackup\\copy_file.c, common\\checksum_helper.c, common\\wchar.c, interfaces\\libpq\\fe-exec.c, bin\\pg_combinebackup\\reconstruct.c","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\pg_combinebackup\\backup_label.c, interfaces\\libpq\\fe-exec.c, common\\logging.c, port\\path.c, fe_utils\\option_utils.c, port\\getopt_long.c, bin\\pg_combinebackup\\copy_file.c, common\\checksum_helper.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\pg_dump\\pg_backup_archiver.c, backend\\jit\\llvm\\port.h, bin\\pg_dump\\common.c, common\\fe_memutils.c, common\\binaryheap.c, interfaces\\libpq\\fe-exec.c, bin\\pg_dump\\pg_backup_utils.c, bin\\pg_dump\\pg_dump.c, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\pg_dump\\pg_backup_archiver.c, bin\\pg_dump\\pg_backup_db.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\processthreadsapi.h, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\pg_dump\\pg_backup_archiver.c, common\\psprintf.c, bin\\pg_dump\\pg_dump.c, common\\compression.c, interfaces\\libpq\\fe-exec.c, common\\fe_memutils.c, bin\\pg_dump\\compress_none.c, bin\\pg_dump\\compress_gzip.c, bin\\pg_dump\\compress_lz4.c","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\pg_dump\\pg_backup_directory.c, common\\fe_memutils.c, bin\\pg_dump\\pg_backup_archiver.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, bin\\pg_dump\\pg_backup_utils.c, port\\strerror.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\pg_dump\\pg_dump.c, interfaces\\libpq\\fe-exec.c, bin\\pg_dump\\pg_backup_archiver.c, common\\logging.c, port\\path.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, common\\exec.c, port\\strlcpy.c, interfaces\\libpq\\pqexpbuffer.c","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\pg_rewind\\pg_rewind.c, port\\snprintf.c, interfaces\\libpq\\fe-lobj.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\msxml.h, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, C:\\mingw64\\x86_64-w64-mingw32\\include\\winsock2.h, bin\\pg_amcheck\\pg_amcheck.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h, backend\\storage\\file\\buffile.c","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\pg_upgrade\\check.c, bin\\pg_upgrade\\controldata.c, port\\snprintf.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, interfaces\\libpq\\fe-exec.c, interfaces\\libpq\\fe-print.c, bin\\pg_upgrade\\util.c, backend\\storage\\file\\fd.c, common\\wait_error.c","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\pg_upgrade\\check.c, bin\\pg_upgrade\\version.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, common\\fe_memutils.c, port\\snprintf.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, interfaces\\libpq\\fe-print.c, bin\\pg_upgrade\\util.c","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\pg_upgrade\\controldata.c, interfaces\\libpq\\fe-exec.c, port\\snprintf.c, bin\\pg_upgrade\\exec.c, bin\\pg_upgrade\\version.c, common\\fe_memutils.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, backend\\nodes\\readfuncs.c, bin\\pg_upgrade\\util.c","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\pg_upgrade\\util.c, bin\\pg_upgrade\\parallel.c, interfaces\\libpq\\fe-exec.c, bin\\pg_upgrade\\version.c, bin\\initdb\\initdb.c, backend\\nodes\\readfuncs.c, bin\\pg_upgrade\\info.c, common\\fe_memutils.c, bin\\pg_upgrade\\check.c","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\pg_upgrade\\util.c, bin\\pg_upgrade\\server.c, bin\\pg_upgrade\\info.c, bin\\pg_upgrade\\check.c, port\\snprintf.c, interfaces\\libpq\\fe-exec.c, common\\fe_memutils.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\sys\\stat.h, backend\\utils\\adt\\float.c","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\pg_upgrade\\version.c, bin\\pg_upgrade\\util.c, interfaces\\libpq\\fe-exec.c, common\\fe_memutils.c, bin\\pg_upgrade\\server.c, backend\\nodes\\readfuncs.c, port\\snprintf.c, interfaces\\libpq\\pqexpbuffer.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\pg_upgrade\\version.c, common\\fe_memutils.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, bin\\pg_upgrade\\util.c, bin\\pg_upgrade\\check.c, port\\snprintf.c, bin\\pg_upgrade\\server.c, interfaces\\libpq\\fe-connect.c","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\pg_waldump\\pg_waldump.c, bin\\psql\\command.c, interfaces\\libpq\\fe-print.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, include\\fe_utils\\psqlscan.h, fe_utils\\conditional.c, interfaces\\libpq\\pqexpbuffer.c, bin\\psql\\input.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\psql\\command.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, common\\fe_memutils.c, fe_utils\\print.c, backend\\jit\\llvm\\port.h, bin\\psql\\psqlscanslash.h, include\\common\\int.h","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\psql\\command.c, interfaces\\libpq\\fe-exec.c, common\\fe_memutils.c, port\\pgstrcasecmp.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, port\\snprintf.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\psql\\command.c, port\\strlcpy.c, interfaces\\libpq\\fe-connect.c, include\\libpq\\pqcomm.h, port\\snprintf.c, bin\\psql\\common.c, interfaces\\libpq\\fe-exec.c, fe_utils\\conditional.c, bin\\pg_dump\\pg_dump.c","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\psql\\psqlscanslash.h, fe_utils\\conditional.c, interfaces\\libpq\\fe-exec.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, port\\pgstrcasecmp.c, bin\\psql\\common.c, common\\fe_memutils.c, bin\\psql\\variables.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\scripts\\clusterdb.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, common\\logging.c, port\\path.c, fe_utils\\option_utils.c, port\\getopt_long.c, common\\fe_memutils.c, fe_utils\\simple_list.c","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\scripts\\clusterdb.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, common\\logging.c, port\\path.c, fe_utils\\option_utils.c, port\\getopt_long.c, fe_utils\\simple_list.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\scripts\\clusterdb.c, interfaces\\libpq\\fe-exec.c, common\\logging.c, port\\path.c, fe_utils\\option_utils.c, port\\getopt_long.c, common\\fe_memutils.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, common\\sprompt.c","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\scripts\\clusterdb.c, interfaces\\libpq\\fe-exec.c, common\\logging.c, port\\path.c, fe_utils\\option_utils.c, port\\getopt_long.c, common\\fe_memutils.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, bin\\scripts\\clusterdb.c, interfaces\\libpq\\fe-misc.c, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-connect.c, interfaces\\libpq\\pqexpbuffer.c, fe_utils\\string_utils.c, bin\\pg_dump\\pg_dumpall.c, interfaces\\libpq\\fe-exec.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, common\\config_info.c, common\\d2s.c, backend\\storage\\file\\fd.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h","count":4},{"name":"module-depends-on","value":"<unknown>, common\\config_info.c, common\\d2s.c, common\\ryu_common.h, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\config_info.c, common\\d2s.c, common\\wchar.c, interfaces\\libpq\\fe-exec.c, common\\string.c, backend\\utils\\mmgr\\mcxt.c, common\\stringinfo.c, fe_utils\\mbprint.c, common\\unicode_norm.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\config_info.c, common\\d2s_intrinsics.h, common\\ryu_common.h, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\config_info.c, port\\pgstrcasecmp.c, port\\strlcpy.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\sys\\stat.h, backend\\utils\\adt\\genfile.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\storage\\file\\fd.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\config_info.c, port\\snprintf.c, backend\\utils\\mmgr\\mcxt.c, backend\\storage\\file\\fd.c, interfaces\\libpq\\fe-lobj.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h, port\\pg_crc32c_sb8.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\controldata_utils.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, common\\config_info.c, backend\\utils\\mmgr\\mcxt.c, common\\psprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\cryptohash.c, interfaces\\libpq\\fe-exec.c, common\\d2s.c, backend\\nodes\\readfuncs.c, common\\config_info.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\d2s.c, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, common\\config_info.c, common\\exec.c, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\d2s.c, common\\config_info.c, backend\\nodes\\readfuncs.c, common\\psprintf.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c, port\\pgstrcasecmp.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\d2s.c, interfaces\\libpq\\fe-exec.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, common\\config_info.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\d2s.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\utils\\mmgr\\mcxt.c, common\\stringinfo.c, common\\config_info.c, backend\\tcop\\postgres.c, common\\wchar.c, include\\mb\\pg_wchar.h","count":4},{"name":"module-depends-on","value":"<unknown>, common\\d2s.c, interfaces\\libpq\\fe-exec.c, common\\exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\d2s.c, port\\pgstrcasecmp.c, common\\config_info.c, common\\cryptohash.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, port\\pg_crc32c_sb8.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\encnames.c, common\\config_info.c, common\\d2s.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\exec.c, port\\snprintf.c, common\\config_info.c, backend\\utils\\mmgr\\mcxt.c, common\\d2s.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\fe_memutils.c, backend\\nodes\\readfuncs.c, bin\\pg_dump\\pg_backup_archiver.c, bin\\pg_dump\\pg_backup_utils.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\sys\\stat.h, backend\\utils\\adt\\genfile.c, port\\dirent.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h","count":4},{"name":"module-depends-on","value":"<unknown>, common\\fe_memutils.c, bin\\pg_basebackup\\bbstreamer_file.c, port\\snprintf.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\msxml.h, interfaces\\libpq\\fe-lobj.c, bin\\pg_basebackup\\pg_basebackup.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\fe_memutils.c, bin\\pg_combinebackup\\backup_label.c, port\\snprintf.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\msxml.h, interfaces\\libpq\\fe-lobj.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\backup\\walsummary.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\fe_memutils.c, bin\\pg_dump\\pg_backup_archiver.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, fe_utils\\string_utils.c, interfaces\\libpq\\pqexpbuffer.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, port\\pgstrcasecmp.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\fe_memutils.c, bin\\pg_rewind\\pg_rewind.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\fe_memutils.c, common\\stringinfo.c, interfaces\\libpq\\fe-exec.c, bin\\pg_rewind\\pg_rewind.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, tools\\ifaddrs\\test_ifaddrs.c, bin\\pg_rewind\\file_ops.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\fe_memutils.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, bin\\pg_dump\\compress_io.c, bin\\pg_dump\\pg_backup_utils.c, backend\\nodes\\readfuncs.c, bin\\pg_dump\\pg_backup_db.c, backend\\access\\transam\\xact.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\fe_memutils.c, interfaces\\libpq\\fe-exec.c, bin\\pg_rewind\\file_ops.c, bin\\pg_rewind\\pg_rewind.c, port\\snprintf.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\msxml.h, interfaces\\libpq\\fe-lobj.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h","count":4},{"name":"module-depends-on","value":"<unknown>, common\\fe_memutils.c, interfaces\\libpq\\fe-exec.c, fe_utils\\parallel_slot.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\fe_memutils.c, interfaces\\libpq\\fe-exec.c, fe_utils\\parallel_slot.c, backend\\access\\gin\\ginpostinglist.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\hashfn.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\hash\\dynahash.c, backend\\access\\common\\reloptions.c, interfaces\\libpq\\fe-exec.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\utils\\adt\\datum.c, backend\\utils\\adt\\expandeddatum.c, include\\access\\tupmacs.h","count":4},{"name":"module-depends-on","value":"<unknown>, common\\hmac.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\ip.c, backend\\libpq\\hba.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\kwlookup.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\md5.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\pg_lzcompress.c, common\\d2s.c, include\\port\\pg_bitutils.h, backend\\utils\\adt\\geo_ops.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\pg_prng.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\pg_prng.c, interfaces\\libpq\\fe-exec.c, include\\common\\int128.h, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\psprintf.c, bin\\psql\\common.c, bin\\psql\\command.c, interfaces\\libpq\\fe-exec.c, common\\fe_memutils.c, bin\\psql\\stringutils.c, port\\pgstrcasecmp.c, backend\\nodes\\readfuncs.c, port\\path.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\relpath.c, backend\\access\\transam\\xlogfuncs.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, backend\\access\\transam\\xlogrecovery.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\hash\\dynahash.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\relpath.c, common\\stringinfo.c, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\string.c, include\\mb\\pg_wchar.h, fe_utils\\mbprint.c, interfaces\\libpq\\fe-exec.c, include\\utils\\ascii.h, common\\d2s.c, common\\config_info.c, common\\encnames.c, port\\strnlen.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\stringinfo.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, bin\\pg_dump\\pg_backup_db.c, interfaces\\libpq\\fe-print.c, interfaces\\libpq\\fe-exec.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, port\\pgstrcasecmp.c, bin\\pg_dump\\pg_backup_archiver.c, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\stringinfo.c, backend\\access\\rmgrdesc\\genericdesc.c, include\\storage\\block.h, backend\\access\\transam\\xlogreader.c, interfaces\\libpq\\fe-exec.c, include\\storage\\itemptr.h, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\stringinfo.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\libpq\\crypt.c, backend\\libpq\\auth-sasl.c, common\\psprintf.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, common\\unicode_case.c, port\\snprintf.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, common\\unicode_norm.c, include\\port\\pg_bswap.h, common\\hmac.c, interfaces\\libpq\\fe-exec.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, common\\cryptohash.c, backend\\nodes\\readfuncs.c, common\\config_info.c","count":4},{"name":"module-depends-on","value":"<unknown>, fe_utils\\recovery_gen.c, port\\snprintf.c, common\\archive.c, interfaces\\libpq\\fe-exec.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, backend\\utils\\mmgr\\mcxt.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\sys\\stat.h, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, C:\\mingw64\\x86_64-w64-mingw32\\include\\msxml.h","count":4},{"name":"module-depends-on","value":"<unknown>, include\\access\\hash.h","count":4},{"name":"module-depends-on","value":"<unknown>, include\\access\\htup_details.h, backend\\utils\\fmgr\\fmgr.c, backend\\jit\\llvm\\postgres.h","count":4},{"name":"module-depends-on","value":"<unknown>, include\\access\\htup_details.h, include\\access\\tupmacs.h, backend\\access\\common\\indextuple.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\access\\tupmacs.h","count":4},{"name":"module-depends-on","value":"<unknown>, include\\access\\tupmacs.h, backend\\access\\common\\heaptuple.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\access\\xlog_internal.h, interfaces\\libpq\\fe-exec.c, backend\\access\\transam\\xlogfuncs.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\readfuncs.c, include\\access\\rmgr.h, port\\pgstrcasecmp.c, backend\\utils\\fmgr\\funcapi.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\common\\hashfn.h, interfaces\\libpq\\fe-exec.c, include\\common\\int.h, backend\\nodes\\readfuncs.c, backend\\jit\\llvm\\port.h, common\\psprintf.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, include\\common\\int.h, common\\fe_memutils.c, bin\\pg_upgrade\\server.c, interfaces\\libpq\\fe-exec.c, interfaces\\libpq\\fe-connect.c, bin\\pg_upgrade\\info.c, bin\\pg_upgrade\\version.c, backend\\nodes\\readfuncs.c, bin\\pg_upgrade\\check.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\executor\\executor.h, backend\\executor\\execExprInterp.c, backend\\executor\\nodeValuesscan.c, backend\\executor\\execScan.c, include\\nodes\\nodes.h, backend\\executor\\execUtils.c, backend\\executor\\execProcnode.c, backend\\executor\\execTuples.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\executor\\tuptable.h, backend\\executor\\execAmi.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\jit\\llvm\\postgres.h, backend\\utils\\mmgr\\mcxt.c, include\\nodes\\pg_list.h","count":4},{"name":"module-depends-on","value":"<unknown>, include\\executor\\tuptable.h, backend\\executor\\execUtils.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\executor\\execExpr.c, interfaces\\libpq\\fe-exec.c, backend\\executor\\execExprInterp.c, include\\executor\\executor.h, backend\\utils\\adt\\expandeddatum.c, backend\\executor\\execTuples.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\executor\\tuptable.h, backend\\utils\\adt\\expandeddatum.c, backend\\jit\\llvm\\postgres.h, interfaces\\libpq\\fe-exec.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\format_type.c, backend\\utils\\cache\\typcache.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\lib\\radixtree.h","count":4},{"name":"module-depends-on","value":"<unknown>, include\\nodes\\nodeFuncs.h, interfaces\\libpq\\fe-exec.c, backend\\executor\\execExprInterp.c, backend\\executor\\execExpr.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, backend\\executor\\nodeBitmapHeapscan.c, backend\\nodes\\list.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\nodes\\nodes.h","count":4},{"name":"module-depends-on","value":"<unknown>, include\\nodes\\nodes.h, backend\\access\\gin\\ginpostinglist.c, backend\\access\\gin\\ginscan.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\jit\\llvm\\postgres.h, backend\\access\\common\\tupdesc.c, backend\\access\\index\\indexam.c, backend\\utils\\fmgr\\fmgr.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\nodes\\nodes.h, backend\\access\\nbtree\\nbtdedup.c, interfaces\\libpq\\fe-exec.c, backend\\access\\gin\\ginutil.c, backend\\jit\\llvm\\postgres.h, backend\\access\\nbtree\\nbtutils.c, backend\\storage\\smgr\\bulk_write.c, backend\\access\\nbtree\\nbtpage.c, backend\\access\\nbtree\\nbtinsert.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\nodes\\nodes.h, backend\\access\\spgist\\spgdoinsert.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\access\\gin\\ginutil.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\cache\\lsyscache.c, backend\\utils\\cache\\relcache.c, include\\nodes\\pg_list.h","count":4},{"name":"module-depends-on","value":"<unknown>, include\\nodes\\nodes.h, backend\\catalog\\namespace.c, backend\\commands\\seclabel.c, backend\\commands\\alter.c, backend\\catalog\\pg_depend.c, backend\\commands\\aggregatecmds.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\nodes\\nodes.h, backend\\nodes\\list.c, backend\\nodes\\value.c, backend\\nodes\\readfuncs.c, backend\\nodes\\nodeFuncs.c, backend\\utils\\cache\\lsyscache.c, backend\\nodes\\extensible.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, include\\nodes\\nodes.h, backend\\nodes\\list.c, interfaces\\libpq\\fe-exec.c, backend\\access\\gin\\ginutil.c, backend\\jit\\llvm\\postgres.h, include\\nodes\\pg_list.h, backend\\optimizer\\util\\clauses.c, backend\\utils\\adt\\float.c, backend\\optimizer\\path\\costsize.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\nodes\\nodes.h, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\access\\gin\\ginutil.c, backend\\jit\\llvm\\postgres.h, backend\\jit\\llvm\\utils\\palloc.h, backend\\utils\\mmgr\\mcxt.c, backend\\access\\brin\\brin_revmap.c, include\\storage\\itemptr.h","count":4},{"name":"module-depends-on","value":"<unknown>, include\\nodes\\nodes.h, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\list.c, backend\\nodes\\readfuncs.c, backend\\nodes\\makefuncs.c, backend\\utils\\cache\\syscache.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\nodes\\nodes.h, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\mmgr\\dsa.c, include\\port\\atomics.h, interfaces\\libpq\\fe-exec.c, include\\storage\\itemptr.h, backend\\nodes\\readfuncs.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, include\\nodes\\nodes.h, include\\nodes\\pg_list.h, backend\\nodes\\makefuncs.c, backend\\nodes\\list.c, backend\\nodes\\value.c, backend\\rewrite\\rewriteDefine.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\copyfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\nodes\\nodes.h, interfaces\\libpq\\fe-exec.c, backend\\executor\\execIndexing.c, backend\\catalog\\pg_collation.c, backend\\utils\\mmgr\\mcxt.c, backend\\catalog\\pg_constraint.c, backend\\executor\\execTuples.c, backend\\catalog\\pg_db_role_setting.c, backend\\catalog\\index.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\nodes\\nodes.h, interfaces\\libpq\\fe-exec.c, backend\\nodes\\makefuncs.c, backend\\nodes\\list.c, include\\nodes\\pg_list.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\readfuncs.c, backend\\rewrite\\rewriteManip.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\nodes\\nodes.h, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\access\\gin\\ginutil.c, backend\\jit\\llvm\\postgres.h, backend\\storage\\buffer\\bufmgr.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\optimizer\\util\\plancat.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\nodes\\nodes.h, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\access\\gin\\ginutil.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\mmgr\\aset.c, backend\\storage\\buffer\\bufmgr.c, backend\\access\\gist\\gistutil.c, backend\\access\\transam\\xloginsert.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\nodes\\nodes.h, interfaces\\libpq\\fe-exec.c, backend\\optimizer\\plan\\analyzejoins.c, backend\\optimizer\\util\\clauses.c, backend\\nodes\\readfuncs.c, backend\\optimizer\\util\\relnode.c, backend\\optimizer\\plan\\createplan.c, backend\\executor\\execAmi.c, backend\\optimizer\\plan\\subselect.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\nodes\\pg_list.h, backend\\libpq\\pqformat.c, include\\libpq\\pqformat.h, backend\\commands\\aggregatecmds.c, backend\\commands\\copyfromparse.c, common\\stringinfo.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h","count":4},{"name":"module-depends-on","value":"<unknown>, include\\nodes\\pg_list.h, backend\\libpq\\pqformat.c, include\\libpq\\pqformat.h, common\\stringinfo.c, backend\\commands\\async.c, backend\\commands\\aggregatecmds.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h","count":4},{"name":"module-depends-on","value":"<unknown>, include\\nodes\\pg_list.h, backend\\optimizer\\plan\\analyzejoins.c, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\list.c, backend\\optimizer\\plan\\initsplan.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\optimizer\\path\\joinrels.c, backend\\optimizer\\util\\relnode.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\nodes\\pg_list.h, backend\\parser\\analyze.c, backend\\nodes\\list.c, backend\\nodes\\makefuncs.c, interfaces\\libpq\\fe-exec.c, backend\\parser\\parse_clause.c, backend\\optimizer\\util\\tlist.c, backend\\utils\\error\\elog.c, backend\\utils\\adt\\format_type.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\nodes\\pg_list.h, backend\\utils\\mmgr\\mcxt.c, backend\\executor\\execExprInterp.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\executor\\execExpr.c, backend\\utils\\cache\\lsyscache.c, backend\\executor\\nodeWindowAgg.c, backend\\optimizer\\path\\allpaths.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\nodes\\pg_list.h, backend\\utils\\mmgr\\mcxt.c, backend\\optimizer\\util\\paramassign.c, interfaces\\libpq\\fe-exec.c, backend\\optimizer\\util\\appendinfo.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\optimizer\\util\\placeholder.c, include\\nodes\\nodes.h","count":4},{"name":"module-depends-on","value":"<unknown>, include\\parser\\scanner.h, backend\\parser\\analyze.c, interfaces\\libpq\\fe-exec.c, interfaces\\ecpg\\preproc\\preproc_extern.h, backend\\parser\\scansup.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\mb\\pg_wchar.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h","count":4},{"name":"module-depends-on","value":"<unknown>, include\\port\\atomics.h, backend\\storage\\buffer\\bufmgr.c, backend\\storage\\lmgr\\spin.c, backend\\storage\\lmgr\\s_lock.c, interfaces\\libpq\\fe-exec.c, backend\\storage\\ipc\\latch.c, include\\storage\\buf_internals.h, backend\\storage\\buffer\\buf_table.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\port\\pg_bitutils.h, backend\\nodes\\readfuncs.c, backend\\utils\\adt\\expandedrecord.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, backend\\utils\\adt\\float.c, backend\\utils\\error\\elog.c, backend\\utils\\adt\\int.c, backend\\utils\\adt\\arrayfuncs.c, backend\\utils\\adt\\int8.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\port\\pg_bitutils.h, backend\\utils\\mmgr\\bump.c, backend\\storage\\ipc\\dsm.c, backend\\jit\\llvm\\postgres.h, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\aset.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\storage\\lmgr\\lwlock.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\port\\pg_bitutils.h, common\\exec.c, common\\config_info.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\port\\pg_bswap.h, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, common\\config_info.c, common\\d2s.c, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\port\\simd.h, include\\port\\pg_bitutils.h, backend\\jit\\llvm\\utils\\palloc.h, backend\\utils\\mmgr\\dsa.c, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\port\\win32_port.h","count":4},{"name":"module-depends-on","value":"<unknown>, include\\portability\\instr_time.h, port\\snprintf.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, include\\common\\int.h, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, common\\pg_prng.c, include\\port\\pg_bitutils.h, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, include\\replication\\worker_internal.h, backend\\replication\\logical\\worker.c, backend\\replication\\logical\\tablesync.c, backend\\storage\\ipc\\shmem.c, backend\\storage\\ipc\\shm_toc.c, backend\\storage\\ipc\\dsm.c, backend\\storage\\lmgr\\spin.c, include\\port\\atomics.h, backend\\storage\\ipc\\shm_mq.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\storage\\block.h, backend\\jit\\llvm\\postgres.h","count":4},{"name":"module-depends-on","value":"<unknown>, include\\storage\\bufmgr.h, backend\\access\\gin\\ginutil.c, backend\\access\\gin\\ginxlog.c, backend\\access\\gin\\ginscan.c, backend\\access\\gin\\ginvacuum.c, backend\\storage\\page\\bufpage.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\gin\\ginpostinglist.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\storage\\bufmgr.h, include\\storage\\bufpage.h, backend\\access\\gin\\ginvacuum.c, backend\\access\\gin\\ginpostinglist.c, backend\\access\\gin\\ginbtree.c, backend\\access\\gin\\ginutil.c, backend\\storage\\buffer\\bufmgr.c, backend\\access\\gin\\ginscan.c, backend\\storage\\lmgr\\predicate.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\storage\\bufmgr.h, include\\storage\\bufpage.h, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, backend\\storage\\page\\bufpage.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\nbtree\\nbtutils.c, backend\\storage\\buffer\\bufmgr.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\storage\\bufpage.h","count":4},{"name":"module-depends-on","value":"<unknown>, include\\storage\\bufpage.h, backend\\access\\common\\reloptions.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, include\\storage\\bufpage.h, backend\\access\\transam\\xlog.c, include\\storage\\checksum_impl.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\activity\\pgstat_database.c, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\storage\\bufpage.h, backend\\storage\\freespace\\freespace.c, include\\storage\\bufmgr.h, backend\\storage\\buffer\\bufmgr.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, include\\storage\\bufpage.h, include\\access\\gist.h, include\\access\\transam.h, backend\\storage\\ipc\\procarray.c, include\\storage\\itemptr.h, include\\access\\hash.h","count":4},{"name":"module-depends-on","value":"<unknown>, include\\storage\\bufpage.h, include\\access\\transam.h","count":4},{"name":"module-depends-on","value":"<unknown>, include\\storage\\itemptr.h","count":4},{"name":"module-depends-on","value":"<unknown>, include\\storage\\itemptr.h, backend\\storage\\page\\bufpage.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\storage\\itemptr.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, backend\\access\\spgist\\spgutils.c, backend\\jit\\llvm\\postgres.h, include\\common\\int.h, interfaces\\libpq\\fe-exec.c, backend\\jit\\llvm\\port.h","count":4},{"name":"module-depends-on","value":"<unknown>, include\\storage\\itemptr.h, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\tidbitmap.c, include\\access\\gin_private.h","count":4},{"name":"module-depends-on","value":"<unknown>, include\\storage\\itemptr.h, include\\common\\int.h","count":4},{"name":"module-depends-on","value":"<unknown>, include\\utils\\float.h, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, include\\utils\\geo_decls.h, backend\\access\\gist\\gist.c, interfaces\\libpq\\fe-exec.c, include\\storage\\bufpage.h, backend\\utils\\mmgr\\mcxt.c, backend\\access\\gin\\ginutil.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\utils\\jsonb.h, backend\\utils\\adt\\jsonb_gin.c, include\\utils\\jsonpath.h, backend\\nodes\\readfuncs.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\adt\\genfile.c, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\utils\\pgstat_internal.h, backend\\utils\\activity\\pgstat_io.c, backend\\utils\\activity\\pgstat.c, backend\\storage\\lmgr\\lwlock.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\utils\\rangetypes.h, backend\\utils\\fmgr\\fmgr.c, backend\\jit\\llvm\\postgres.h","count":4},{"name":"module-depends-on","value":"<unknown>, include\\utils\\rel.h, backend\\utils\\mmgr\\mcxt.c, backend\\storage\\smgr\\smgr.c, backend\\access\\transam\\xlog.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\jit\\llvm\\port.h, backend\\access\\transam\\xloginsert.c, backend\\storage\\page\\bufpage.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\utils\\relptr.h, backend\\utils\\mmgr\\aset.c, interfaces\\libpq\\fe-exec.c, common\\stringinfo.c, backend\\nodes\\readfuncs.c, backend\\tcop\\postgres.c, backend\\utils\\mmgr\\dsa.c, backend\\utils\\mmgr\\bump.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\utils\\sortsupport.h, backend\\nodes\\readfuncs.c, backend\\utils\\sort\\logtape.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\aset.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\misc\\pg_rusage.c","count":4},{"name":"module-depends-on","value":"<unknown>, include\\utils\\varbit.h","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\ecpg\\ecpglib\\connect.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, port\\pgstrcasecmp.c, interfaces\\ecpg\\ecpglib\\misc.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, interfaces\\ecpg\\ecpglib\\error.c, interfaces\\ecpg\\ecpglib\\typename.c, interfaces\\ecpg\\pgtypeslib\\numeric.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\ecpg\\ecpglib\\error.c, interfaces\\ecpg\\ecpglib\\connect.c, interfaces\\libpq\\fe-exec.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\processthreadsapi.h, interfaces\\ecpg\\ecpglib\\misc.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\ecpg\\ecpglib\\memory.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, interfaces\\ecpg\\ecpglib\\connect.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, backend\\tsearch\\wparser_def.c, port\\snprintf.c, interfaces\\ecpg\\ecpglib\\error.c, interfaces\\ecpg\\ecpglib\\typename.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\ecpg\\ecpglib\\misc.c, interfaces\\libpq\\fe-exec.c, interfaces\\ecpg\\ecpglib\\memory.c, interfaces\\ecpg\\ecpglib\\data.c, port\\snprintf.c, interfaces\\ecpg\\ecpglib\\connect.c, interfaces\\ecpg\\ecpglib\\descriptor.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-connect.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\ecpg\\pgtypeslib\\common.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\utils\\adt\\formatting.c, backend\\utils\\adt\\datetime.c, backend\\utils\\adt\\timestamp.c, port\\snprintf.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\ecpg\\pgtypeslib\\common.c, interfaces\\libpq\\fe-exec.c, interfaces\\ecpg\\pgtypeslib\\datetime.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, port\\pgstrcasecmp.c, interfaces\\ecpg\\pgtypeslib\\dt_common.c, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\ecpg\\pgtypeslib\\dt_common.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\ecpg\\pgtypeslib\\dt_common.c, backend\\utils\\adt\\datetime.c, interfaces\\ecpg\\pgtypeslib\\datetime.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\timestamp.c, backend\\nodes\\readfuncs.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\ecpg\\pgtypeslib\\numeric.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\utils\\error\\elog.c, interfaces\\ecpg\\pgtypeslib\\datetime.c, interfaces\\ecpg\\pgtypeslib\\timestamp.c, interfaces\\ecpg\\pgtypeslib\\interval.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\ecpg\\preproc\\descriptor.c, port\\snprintf.c, interfaces\\ecpg\\preproc\\ecpg.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, interfaces\\ecpg\\preproc\\type.c, interfaces\\ecpg\\preproc\\variable.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\ecpg\\preproc\\ecpg.c, backend\\parser\\parser.c, interfaces\\ecpg\\preproc\\preproc_extern.h, interfaces\\ecpg\\preproc\\descriptor.c, common\\psprintf.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\ecpg\\preproc\\type.c, interfaces\\ecpg\\preproc\\variable.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, interfaces\\ecpg\\preproc\\preproc_extern.h, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, port\\snprintf.c, interfaces\\ecpg\\preproc\\output.c, port\\strlcpy.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\ecpg\\preproc\\type.c, interfaces\\libpq\\fe-exec.c, interfaces\\ecpg\\preproc\\preproc_extern.h, interfaces\\ecpg\\preproc\\descriptor.c, backend\\nodes\\readfuncs.c, interfaces\\ecpg\\preproc\\ecpg.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-connect.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, interfaces\\libpq\\fe-misc.c, interfaces\\libpq\\pqexpbuffer.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\winsock2.h, port\\strlcpy.c, interfaces\\libpq\\fe-secure-openssl.c, backend\\libpq\\auth.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-connect.c, bin\\pg_dump\\pg_backup_archiver.c, bin\\pg_dump\\pg_backup_utils.c, common\\fe_memutils.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, common\\sprompt.c, bin\\pg_dump\\parallel.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\msxml.h, interfaces\\libpq\\fe-lobj.c, bin\\pg_combinebackup\\backup_label.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, C:\\mingw64\\x86_64-w64-mingw32\\include\\winsock2.h, common\\checksum_helper.c, common\\fe_memutils.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\processenv.h, backend\\nodes\\readfuncs.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\libloaderapi.h, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-secure-gssapi.c, port\\chklocale.c, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, port\\win32gettimeofday.c, interfaces\\libpq\\fe-gssapi-common.c, port\\snprintf.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, interfaces\\libpq\\fe-print.c, interfaces\\libpq\\fe-misc.c, include\\port\\pg_bswap.h","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\winbase.h, common\\psprintf.c, common\\config_info.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\errhandlingapi.h, port\\snprintf.c, backend\\lib\\dshash.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\access\\common\\reloptions.c, backend\\jit\\llvm\\postgres.h, backend\\access\\common\\toast_compression.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\readfuncs.c, backend\\utils\\mmgr\\mcxt.c, backend\\access\\transam\\xact.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\access\\gin\\ginscan.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, backend\\access\\gin\\ginpostinglist.c, include\\access\\gin_private.h, backend\\access\\gin\\ginutil.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\access\\index\\indexam.c, backend\\executor\\execExprInterp.c, backend\\nodes\\readfuncs.c, backend\\executor\\nodeWindowAgg.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, include\\storage\\itemptr.h, backend\\access\\heap\\visibilitymap.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\access\\table\\table.c, backend\\access\\index\\indexam.c, backend\\access\\common\\scankey.c, backend\\jit\\llvm\\postgres.h, backend\\access\\index\\genam.c, backend\\access\\common\\detoast.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\catalog\\namespace.c, backend\\catalog\\aclchk.c, backend\\utils\\init\\miscinit.c, backend\\utils\\cache\\lsyscache.c, include\\nodes\\pg_list.h, backend\\commands\\define.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\commands\\aggregatecmds.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, common\\psprintf.c, backend\\parser\\parse_type.c, backend\\catalog\\namespace.c, backend\\utils\\mmgr\\mcxt.c, backend\\commands\\alter.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\commands\\aggregatecmds.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\nodes\\nodes.h, backend\\utils\\cache\\plancache.c, backend\\tcop\\utility.c, include\\nodes\\pg_list.h, backend\\commands\\indexcmds.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\commands\\subscriptioncmds.c, backend\\commands\\define.c, backend\\nodes\\readfuncs.c, backend\\commands\\aggregatecmds.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\commands\\copyto.c, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\commands\\tablespace.c, backend\\storage\\file\\fd.c, backend\\storage\\file\\buffile.c, port\\snprintf.c, include\\common\\hashfn.h","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\executor\\execAmi.c, backend\\executor\\instrument.c, backend\\executor\\execParallel.c, backend\\executor\\nodeForeignscan.c, backend\\executor\\execExprInterp.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\executor\\nodeAppend.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\executor\\nodeValuesscan.c, backend\\executor\\execUtils.c, backend\\executor\\execTuples.c, backend\\executor\\execScan.c, backend\\executor\\execExpr.c, backend\\executor\\nodeWindowAgg.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\jit\\llvm\\postgres.h, backend\\access\\common\\detoast.c, backend\\access\\common\\toast_internals.c, backend\\utils\\mmgr\\mcxt.c, backend\\access\\table\\tableam.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\nodes\\bitmapset.c, include\\libpq\\pqformat.h, backend\\libpq\\pqformat.c, backend\\replication\\logical\\applyparallelworker.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, port\\strlcpy.c, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\locale.h","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\catalog\\namespace.c, backend\\catalog\\aclchk.c, backend\\utils\\init\\miscinit.c, backend\\utils\\cache\\lsyscache.c, backend\\commands\\tablecmds.c, backend\\commands\\aggregatecmds.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\mb\\mbutils.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, backend\\utils\\adt\\pg_locale.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, bin\\pg_dump\\pg_backup_archiver.c, bin\\pg_dump\\pg_backup_utils.c, interfaces\\libpq\\pqexpbuffer.c, fe_utils\\string_utils.c, bin\\pg_dump\\pg_backup_db.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, common\\config_info.c, fe_utils\\mbprint.c, include\\mb\\pg_wchar.h, common\\encnames.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, common\\logging.c, port\\path.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, port\\getopt_long.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, common\\fe_memutils.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, common\\stringinfo.c, backend\\libpq\\auth.c, backend\\utils\\mmgr\\mcxt.c, backend\\libpq\\pqcomm.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\libpq\\pqformat.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, port\\snprintf.c, backend\\lib\\dshash.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h, interfaces\\libpq\\fe-misc.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\optimizer\\path\\allpaths.c, include\\nodes\\nodeFuncs.h, include\\nodes\\pg_list.h, backend\\optimizer\\path\\equivclass.c, backend\\nodes\\bitmapset.c, backend\\optimizer\\util\\clauses.c, backend\\optimizer\\util\\var.c, backend\\optimizer\\util\\restrictinfo.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\optimizer\\path\\joinrels.c, backend\\nodes\\bitmapset.c, backend\\optimizer\\util\\relnode.c, backend\\nodes\\readfuncs.c, backend\\optimizer\\util\\plancat.c, backend\\optimizer\\path\\costsize.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\optimizer\\util\\relnode.c, backend\\optimizer\\plan\\analyzejoins.c, include\\nodes\\pg_list.h, backend\\optimizer\\util\\clauses.c, backend\\optimizer\\util\\pathnode.c, backend\\optimizer\\plan\\initsplan.c, backend\\optimizer\\util\\placeholder.c, backend\\optimizer\\path\\equivclass.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\port\\posix_sema.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\storage\\ipc\\ipc.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\handleapi.h, backend\\storage\\ipc\\latch.c, backend\\nodes\\readfuncs.c, backend\\commands\\collationcmds.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, backend\\commands\\vacuum.c, backend\\commands\\seclabel.c, backend\\access\\common\\relation.c, backend\\storage\\buffer\\bufmgr.c, backend\\commands\\aggregatecmds.c, backend\\foreign\\foreign.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\regex\\regerror.c, backend\\regex\\regc_pg_locale.c, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, backend\\regex\\rege_dfa.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\regex\\regerror.c, backend\\regex\\regexec.c, backend\\regex\\regc_pg_locale.c, backend\\utils\\mmgr\\mcxt.c, backend\\regex\\regexport.c, backend\\regex\\regc_color.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\storage\\file\\buffile.c, backend\\backup\\walsummary.c, common\\cryptohash.c, backend\\backup\\walsummaryfuncs.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\float.c, backend\\utils\\error\\elog.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\adt\\arrayfuncs.c, backend\\nodes\\readfuncs.c, include\\common\\int.h, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\cache\\lsyscache.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\aset.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\varlena.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\utils\\hash\\dynahash.c, backend\\nodes\\readfuncs.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\utils\\mb\\mbutils.c, backend\\utils\\mmgr\\mcxt.c, common\\stringinfo.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, backend\\tsearch\\dict_ispell.c, backend\\utils\\cache\\ts_cache.c, backend\\jit\\llvm\\postgres.h, backend\\tsearch\\dict_thesaurus.c, backend\\utils\\fmgr\\fmgr.c, backend\\utils\\adt\\network_selfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\cache\\lsyscache.c, backend\\access\\transam\\xact.c, backend\\utils\\cache\\relcache.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\time\\snapmgr.c, backend\\utils\\cache\\catcache.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\utils\\memutils_internal.h, include\\utils\\memutils_memorychunk.h, backend\\nodes\\readfuncs.c, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c, common\\pg_lzcompress.c, backend\\access\\common\\reloptions.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c, include\\storage\\bufmgr.h, backend\\access\\gin\\ginpostinglist.c, backend\\access\\transam\\xloginsert.c, backend\\access\\gin\\ginutil.c, include\\storage\\bufpage.h, backend\\storage\\buffer\\bufmgr.c, backend\\storage\\lmgr\\predicate.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c, port\\path.c, common\\percentrepl.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, bin\\pg_dump\\pg_backup_archiver.c, backend\\nodes\\readfuncs.c, common\\logging.c, bin\\pg_dump\\parallel.c, port\\path.c, bin\\pg_dump\\pg_backup_utils.c, port\\getopt_long.c, common\\fe_memutils.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, bin\\pg_rewind\\pg_rewind.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, common\\fe_memutils.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, bin\\pg_upgrade\\util.c, bin\\pg_upgrade\\server.c, backend\\nodes\\readfuncs.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, interfaces\\libpq\\pqexpbuffer.c, fe_utils\\string_utils.c, port\\snprintf.c, backend\\utils\\adt\\ruleutils.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, bin\\pg_upgrade\\version.c, common\\logging.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h, bin\\pg_upgrade\\option.c, common\\restricted_token.c, bin\\pg_ctl\\pg_ctl.c, common\\file_perm.c, bin\\pg_upgrade\\util.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, bin\\pg_upgrade\\version.c, port\\path.c, bin\\pg_upgrade\\util.c, common\\fe_memutils.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, port\\getopt_long.c, common\\psprintf.c, fe_utils\\option_utils.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, bin\\scripts\\clusterdb.c, common\\logging.c, port\\path.c, fe_utils\\option_utils.c, port\\getopt_long.c, common\\fe_memutils.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, common\\fe_memutils.c, bin\\pg_rewind\\pg_rewind.c, backend\\nodes\\readfuncs.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, bin\\pg_rewind\\datapagemap.c, port\\path.c, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, common\\logging.c, port\\path.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, fe_utils\\simple_list.c, port\\getopt_long.c, backend\\nodes\\readfuncs.c, backend\\utils\\mmgr\\mcxt.c, common\\fe_memutils.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, common\\logging.c, port\\path.c, fe_utils\\option_utils.c, port\\getopt_long.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, C:\\mingw64\\x86_64-w64-mingw32\\include\\msxml.h, interfaces\\libpq\\fe-lobj.c, common\\blkreftable.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, common\\logging.c, port\\path.c, fe_utils\\option_utils.c, port\\getopt_long.c, common\\fe_memutils.c, fe_utils\\simple_list.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, common\\saslprep.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-misc.c, port\\pg_strong_random.c, common\\base64.c, interfaces\\libpq\\pqexpbuffer.c, common\\hmac.c, common\\scram-common.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, common\\stringinfo.c, backend\\utils\\error\\elog.c, backend\\utils\\misc\\ps_status.c, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, backend\\access\\transam\\xact.c, backend\\utils\\activity\\backend_status.c, backend\\postmaster\\syslogger.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, fe_utils\\cancel.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\winsock2.h, backend\\nodes\\readfuncs.c, backend\\libpq\\ifaddr.c, interfaces\\libpq\\win32.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-misc.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, fe_utils\\parallel_slot.c, common\\sprompt.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-connect.c, fe_utils\\recovery_gen.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, bin\\pg_dump\\pg_dumpall.c, interfaces\\libpq\\fe-cancel.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, interfaces\\ecpg\\ecpglib\\error.c, interfaces\\ecpg\\ecpglib\\connect.c, interfaces\\ecpg\\ecpglib\\descriptor.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\processthreadsapi.h, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-connect.c, port\\snprintf.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, interfaces\\ecpg\\ecpglib\\typename.c, interfaces\\ecpg\\pgtypeslib\\numeric.c, backend\\nodes\\readfuncs.c, interfaces\\ecpg\\ecpglib\\memory.c, interfaces\\ecpg\\ecpglib\\misc.c, interfaces\\ecpg\\ecpglib\\connect.c, interfaces\\ecpg\\ecpglib\\data.c, interfaces\\ecpg\\ecpglib\\execute.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, interfaces\\ecpg\\preproc\\preproc_extern.h, backend\\nodes\\readfuncs.c, interfaces\\ecpg\\preproc\\descriptor.c, interfaces\\ecpg\\preproc\\variable.c, port\\snprintf.c, interfaces\\ecpg\\preproc\\output.c, interfaces\\ecpg\\ecpglib\\typename.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, interfaces\\libpq\\fe-connect.c, bin\\pg_upgrade\\util.c, bin\\pg_upgrade\\option.c, port\\snprintf.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\pqexpbuffer.c, fe_utils\\string_utils.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, interfaces\\libpq\\fe-misc.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ws2tcpip.h, port\\strlcpy.c, backend\\nodes\\readfuncs.c, backend\\libpq\\auth.c, backend\\access\\gin\\ginpostinglist.c, common\\exec.c, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, interfaces\\libpq\\fe-misc.c, interfaces\\libpq\\pqexpbuffer.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\msxml.h, port\\strerror.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h, backend\\libpq\\be-fsstubs.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, interfaces\\libpq\\pqexpbuffer.c, fe_utils\\parallel_slot.c, common\\kwlookup.c, common\\wchar.c, port\\snprintf.c, interfaces\\libpq\\fe-misc.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-connect.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, interfaces\\libpq\\pqexpbuffer.c, include\\port\\pg_bswap.h, interfaces\\libpq\\fe-lobj.c, interfaces\\libpq\\fe-trace.c, interfaces\\libpq\\fe-secure.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\winsock2.h, interfaces\\libpq\\fe-connect.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, pl\\plpgsql\\src\\pl_comp.c, backend\\utils\\mmgr\\mcxt.c, backend\\access\\gin\\ginpostinglist.c, backend\\nodes\\readfuncs.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\executor\\spi.c, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, pl\\plpython\\plpy_cursorobject.c, pl\\plpython\\plpy_elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mb\\mbutils.c, backend\\utils\\error\\elog.c, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, pl\\plpython\\plpy_main.c, pl\\plpython\\plpy_elog.c, pl\\plpython\\plpy_planobject.c, backend\\utils\\mmgr\\aset.c, pl\\plpython\\plpy_cursorobject.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, pl\\plpython\\plpy_planobject.c, pl\\plpython\\plpy_resultobject.c, pl\\plpython\\plpy_subxactobject.c, pl\\plpython\\plpy_cursorobject.c, pl\\plpython\\plpy_elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\hash\\dynahash.c, pl\\plpython\\plpy_util.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, port\\pgstrcasecmp.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-misc.c, interfaces\\libpq\\fe-lobj.c, port\\inet_aton.c, port\\inet_net_ntop.c, port\\strerror.c, backend\\utils\\adt\\float.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, port\\snprintf.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, backend\\nodes\\readfuncs.c, backend\\tsearch\\spell.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, tools\\pg_bsd_indent\\err.c, interfaces\\libpq\\fe-print.c, tools\\pg_bsd_indent\\lexi.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, port\\snprintf.c, backend\\access\\transam\\xlogfuncs.c, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, backend\\access\\transam\\xlogprefetcher.c, include\\access\\xlogreader.h, backend\\access\\transam\\xloginsert.c, include\\access\\rmgr.h","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, port\\snprintf.c, backend\\lib\\dshash.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, common\\config_info.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, port\\strnlen.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-exec.c, port\\snprintf.c, interfaces\\ecpg\\pgtypeslib\\datetime.c, backend\\utils\\adt\\datetime.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\nodes\\readfuncs.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, port\\pgstrcasecmp.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-lobj.c, interfaces\\libpq\\fe-secure-openssl.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\winsock2.h, interfaces\\libpq\\fe-misc.c, interfaces\\libpq\\win32.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\msxml.h, interfaces\\libpq\\fe-exec.c, port\\snprintf.c, port\\strlcat.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-misc.c, interfaces\\libpq\\fe-exec.c, port\\strlcpy.c, interfaces\\libpq\\fe-trace.c, interfaces\\libpq\\fe-connect.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-lobj.c, interfaces\\libpq\\pqexpbuffer.c, common\\wchar.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-print.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, common\\logging.c, bin\\initdb\\initdb.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, bin\\pg_waldump\\pg_waldump.c, port\\path.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-print.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, bin\\psql\\command.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, fe_utils\\print.c, backend\\storage\\file\\fd.c, backend\\lib\\dshash.c, fe_utils\\conditional.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-protocol3.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-secure-common.c, backend\\libpq\\auth.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ws2tcpip.h, interfaces\\libpq\\fe-exec.c, port\\snprintf.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\winsock2.h, backend\\main\\main.c, backend\\lib\\dshash.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-secure-common.c, backend\\libpq\\auth.c, backend\\nodes\\readfuncs.c, include\\port\\pg_bswap.h, interfaces\\libpq\\fe-exec.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ws2tcpip.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\winsock2.h, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\fe-secure-gssapi.c, bin\\initdb\\findtimezone.c, backend\\backup\\walsummary.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\winsock2.h, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\legacy-pqsignal.c, port\\pg_crc32c_armv8.c, port\\pg_crc32c_sb8.c, backend\\bootstrap\\bootstrap.c, port\\path.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\libpq-fe.h, interfaces\\libpq\\fe-misc.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, port\\snprintf.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\pqexpbuffer.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-secure.c, backend\\nodes\\readfuncs.c, backend\\libpq\\be-gssapi-common.c, interfaces\\libpq\\fe-exec.c, interfaces\\libpq\\fe-misc.c, interfaces\\libpq\\fe-lobj.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\pqexpbuffer.c, bin\\psql\\common.c, bin\\psql\\command.c, interfaces\\libpq\\fe-exec.c, fe_utils\\print.c, fe_utils\\string_utils.c, backend\\nodes\\readfuncs.c, port\\snprintf.c, port\\pgstrcasecmp.c","count":4},{"name":"module-depends-on","value":"<unknown>, interfaces\\libpq\\pqexpbuffer.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-connect.c, interfaces\\libpq\\fe-misc.c, port\\snprintf.c, backend\\libpq\\be-gssapi-common.c","count":4},{"name":"module-depends-on","value":"<unknown>, pl\\plperl\\plperl.h, backend\\utils\\misc\\guc.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\hash\\dynahash.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\init\\miscinit.c, backend\\storage\\ipc\\ipc.c","count":4},{"name":"module-depends-on","value":"<unknown>, pl\\plpgsql\\src\\pl_comp.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\expandeddatum.c, backend\\utils\\adt\\array_expanded.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\jit\\llvm\\utils\\palloc.h, backend\\access\\common\\tupdesc.c","count":4},{"name":"module-depends-on","value":"<unknown>, pl\\plpgsql\\src\\pl_comp.c, common\\kwlookup.c, include\\common\\kwlookup.h, include\\parser\\scanner.h, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, pl\\plpgsql\\src\\pl_exec.c, common\\stringinfo.c","count":4},{"name":"module-depends-on","value":"<unknown>, pl\\plpython\\plpy_cursorobject.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\access\\common\\tupdesc.c, pl\\plpython\\plpy_elog.c, pl\\plpython\\plpy_util.c, pl\\plpython\\plpy_procedure.c","count":4},{"name":"module-depends-on","value":"<unknown>, pl\\plpython\\plpy_cursorobject.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\executor\\spi.c, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, pl\\plpython\\plpy_spi.c","count":4},{"name":"module-depends-on","value":"<unknown>, pl\\plpython\\plpy_cursorobject.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, pl\\plpython\\plpy_elog.c, backend\\nodes\\readfuncs.c, backend\\utils\\mmgr\\mcxt.c, backend\\access\\transam\\xact.c, backend\\jit\\llvm\\utils\\palloc.h","count":4},{"name":"module-depends-on","value":"<unknown>, pl\\plpython\\plpy_main.c, backend\\utils\\mmgr\\mcxt.c, backend\\jit\\llvm\\utils\\palloc.h, pl\\plpython\\plpy_cursorobject.c, backend\\executor\\execTuples.c, backend\\nodes\\readfuncs.c, backend\\tcop\\postgres.c, backend\\utils\\cache\\typcache.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, port\\dirent.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h","count":4},{"name":"module-depends-on","value":"<unknown>, port\\path.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, fe_utils\\query_utils.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, fe_utils\\parallel_slot.c, backend\\nodes\\read.c","count":4},{"name":"module-depends-on","value":"<unknown>, port\\path.c, interfaces\\libpq\\fe-exec.c, port\\snprintf.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, port\\getopt_long.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\lib\\dshash.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h","count":4},{"name":"module-depends-on","value":"<unknown>, port\\pg_bitutils.c","count":4},{"name":"module-depends-on","value":"<unknown>, port\\pg_crc32c_armv8.c","count":4},{"name":"module-depends-on","value":"<unknown>, port\\pg_strong_random.c, interfaces\\libpq\\fe-exec.c, interfaces\\ecpg\\ecpglib\\misc.c, port\\win32gettimeofday.c","count":4},{"name":"module-depends-on","value":"<unknown>, port\\pg_strong_random.c, interfaces\\libpq\\fe-exec.c, port\\snprintf.c, backend\\lib\\dshash.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h","count":4},{"name":"module-depends-on","value":"<unknown>, port\\pg_strong_random.c, port\\dirent.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\backup\\walsummary.c","count":4},{"name":"module-depends-on","value":"<unknown>, port\\pgstrcasecmp.c, backend\\utils\\adt\\expandedrecord.c, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, backend\\utils\\error\\elog.c, backend\\utils\\mmgr\\mcxt.c, backend\\libpq\\pqformat.c, include\\libpq\\pqformat.h","count":4},{"name":"module-depends-on","value":"<unknown>, port\\pgstrcasecmp.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\varlena.c, backend\\nodes\\list.c, pl\\plpgsql\\src\\pl_comp.c, pl\\plpgsql\\src\\pl_exec.c, backend\\utils\\misc\\guc.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, port\\snprintf.c, backend\\lib\\dshash.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, port\\snprintf.c, bin\\pg_waldump\\rmgrdesc.c, port\\dirent.c, interfaces\\libpq\\fe-exec.c, port\\pgcheckdir.c, port\\pgmkdirp.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\readfuncs.c, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"<unknown>, port\\snprintf.c, common\\unicode_norm.c, common\\unicode\\case_test.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"<unknown>, port\\snprintf.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, port\\win32security.c, port\\strlcpy.c, port\\win32error.c, backend\\storage\\file\\fd.c, backend\\port\\win32\\socket.c, backend\\utils\\adt\\inet_cidr_ntop.c","count":4},{"name":"module-depends-on","value":"<unknown>, port\\strlcpy.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\msxml.h, interfaces\\libpq\\fe-lobj.c, interfaces\\libpq\\fe-exec.c, timezone\\localtime.c, backend\\nodes\\readfuncs.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\winreg.h, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, port\\strlcpy.c, common\\stringinfo.c, common\\relpath.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\timestamp.c, backend\\access\\rmgrdesc\\standbydesc.c, backend\\access\\rmgrdesc\\genericdesc.c, backend\\access\\rmgrdesc\\gindesc.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"<unknown>, port\\strlcpy.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\genfile.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, port\\win32dlopen.c, backend\\nodes\\readfuncs.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\sys\\stat.h, interfaces\\libpq\\fe-exec.c, backend\\access\\gin\\ginpostinglist.c, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, timezone\\localtime.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\nodes\\read.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"<unknown>, timezone\\localtime.c, port\\path.c, port\\strlcpy.c, backend\\nodes\\readfuncs.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\msxml.h, interfaces\\libpq\\fe-lobj.c, backend\\storage\\file\\fd.c, interfaces\\libpq\\fe-exec.c, port\\pgstrcasecmp.c","count":4},{"name":"module-depends-on","value":"<unknown>, timezone\\localtime.c, port\\snprintf.c, backend\\lib\\dshash.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, common\\fe_memutils.c, interfaces\\libpq\\fe-exec.c, port\\strerror.c, backend\\utils\\adt\\float.c","count":4},{"name":"module-depends-on","value":"<unknown>, timezone\\localtime.c, timezone\\pgtz.c","count":4},{"name":"module-depends-on","value":"<unknown>, tools\\pg_bsd_indent\\args.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, port\\snprintf.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, tools\\pg_bsd_indent\\err.c, interfaces\\libpq\\fe-print.c, backend\\lib\\dshash.c","count":4},{"name":"module-depends-on","value":"<unknown>, tools\\pg_bsd_indent\\args.c, tools\\pg_bsd_indent\\io.c, interfaces\\libpq\\fe-exec.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, tools\\pg_bsd_indent\\err.c, tools\\pg_bsd_indent\\indent.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"<unknown>, tools\\pg_bsd_indent\\indent.c","count":4},{"name":"module-depends-on","value":"<unknown>, tools\\pg_bsd_indent\\indent.c, tools\\pg_bsd_indent\\args.c, tools\\pg_bsd_indent\\io.c, tools\\pg_bsd_indent\\err.c","count":4},{"name":"module-depends-on","value":"C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\ecpg\\ecpglib\\connect.c, <unknown>","count":4},{"name":"module-depends-on","value":"C:\\mingw64\\x86_64-w64-mingw32\\include\\processthreadsapi.h, interfaces\\libpq\\fe-exec.c, <unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\winbase.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\synchapi.h, interfaces\\libpq\\fe-secure-gssapi.c","count":4},{"name":"module-depends-on","value":"C:\\mingw64\\x86_64-w64-mingw32\\include\\signal.h","count":4},{"name":"module-depends-on","value":"C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, <unknown>, backend\\access\\transam\\rmgr.c","count":4},{"name":"module-depends-on","value":"C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, <unknown>, interfaces\\libpq\\fe-print.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\sec_api\\stdio_s.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\guiddef.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\winnt.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\memoryapi.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\oleauto.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\winuser.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\stralign.h","count":4},{"name":"module-depends-on","value":"C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, interfaces\\libpq\\fe-print.c, <unknown>, backend\\nodes\\readfuncs.c, interfaces\\libpq\\pqexpbuffer.c, bin\\psql\\command.c, interfaces\\libpq\\fe-exec.c, common\\fe_memutils.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"C:\\mingw64\\x86_64-w64-mingw32\\include\\synchapi.h, <unknown>, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-cancel.c, backend\\port\\win32\\signal.c, fe_utils\\parallel_slot.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, backend\\commands\\collationcmds.c","count":4},{"name":"module-depends-on","value":"C:\\mingw64\\x86_64-w64-mingw32\\include\\winsock2.h, interfaces\\libpq\\win32.c, <unknown>, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-secure-gssapi.c, backend\\libpq\\ifaddr.c, backend\\utils\\adt\\inet_cidr_ntop.c, backend\\storage\\file\\fd.c, interfaces\\libpq\\fe-secure-openssl.c","count":4},{"name":"module-depends-on","value":"backend\\access\\common\\reloptions.c, <unknown>, backend\\access\\common\\toast_internals.c, backend\\storage\\lmgr\\lmgr.c, backend\\utils\\cache\\relcache.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\activity\\pgstat_relation.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\cache\\syscache.c","count":4},{"name":"module-depends-on","value":"backend\\access\\common\\toast_internals.c, <unknown>, backend\\access\\common\\toast_compression.c, backend\\access\\common\\reloptions.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\adt\\expandeddatum.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\common\\int.h","count":4},{"name":"module-depends-on","value":"backend\\access\\gin\\ginpostinglist.c, <unknown>, backend\\access\\gin\\ginutil.c, backend\\access\\gin\\ginentrypage.c, backend\\nodes\\readfuncs.c, backend\\access\\gin\\ginvacuum.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c, backend\\access\\gin\\gindatapage.c, backend\\access\\gin\\ginscan.c","count":4},{"name":"module-depends-on","value":"backend\\access\\gin\\ginpostinglist.c, <unknown>, backend\\access\\index\\genam.c, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\aset.c, backend\\access\\gin\\ginutil.c, backend\\nodes\\readfuncs.c, include\\storage\\itemptr.h, backend\\access\\gin\\ginlogic.c","count":4},{"name":"module-depends-on","value":"backend\\access\\gin\\ginxlog.c, <unknown>, include\\storage\\bufpage.h, include\\storage\\itemptr.h, backend\\access\\gin\\ginpostinglist.c, include\\access\\gin_private.h, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\tidbitmap.c, backend\\access\\gin\\ginvacuum.c","count":4},{"name":"module-depends-on","value":"backend\\access\\hash\\hash.c, <unknown>, backend\\access\\index\\indexam.c, backend\\access\\hash\\hashpage.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\fmgr\\fmgr.c, backend\\utils\\cache\\lsyscache.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\port\\pg_bitutils.h","count":4},{"name":"module-depends-on","value":"backend\\access\\heap\\heapam.c, <unknown>, include\\storage\\bufmgr.h, backend\\storage\\page\\bufpage.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\storage\\itemptr.h, backend\\storage\\buffer\\bufmgr.c, include\\storage\\bufpage.h, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"backend\\access\\heap\\heapam_handler.c, <unknown>, backend\\access\\transam\\transam.c, backend\\storage\\buffer\\bufmgr.c, backend\\access\\transam\\xlog.c, backend\\access\\heap\\heapam.c, backend\\access\\transam\\xact.c, backend\\storage\\ipc\\procarray.c, backend\\utils\\time\\combocid.c, backend\\access\\transam\\multixact.c","count":4},{"name":"module-depends-on","value":"backend\\access\\nbtree\\nbtpage.c, <unknown>, backend\\access\\nbtree\\nbtdedup.c, backend\\storage\\buffer\\bufmgr.c, backend\\access\\nbtree\\nbtinsert.c, backend\\nodes\\readfuncs.c, include\\storage\\bufmgr.h, interfaces\\libpq\\fe-exec.c, include\\storage\\bufpage.h, include\\access\\nbtree.h","count":4},{"name":"module-depends-on","value":"backend\\access\\transam\\clog.c, <unknown>, backend\\access\\transam\\xlogfuncs.c, backend\\access\\transam\\subtrans.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"backend\\access\\transam\\xact.c, backend\\utils\\activity\\pgstat.c, backend\\replication\\logical\\applyparallelworker.c, <unknown>, backend\\access\\transam\\xlog.c, backend\\utils\\error\\elog.c, backend\\utils\\cache\\lsyscache.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\replication\\logical\\launcher.c, backend\\storage\\ipc\\ipc.c","count":4},{"name":"module-depends-on","value":"backend\\access\\transam\\xlogfuncs.c, <unknown>, backend\\jit\\llvm\\utils\\palloc.h, backend\\utils\\mmgr\\mcxt.c, backend\\access\\transam\\xact.c, include\\lib\\ilist.h, backend\\utils\\time\\snapmgr.c, backend\\storage\\ipc\\shmem.c, backend\\access\\common\\session.c, backend\\utils\\fmgr\\dfmgr.c","count":4},{"name":"module-depends-on","value":"backend\\backup\\basebackup_throttle.c, <unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\activity\\backend_progress.c, backend\\backup\\basebackup.c, include\\nodes\\pg_list.h, backend\\backup\\basebackup_sink.c","count":4},{"name":"module-depends-on","value":"backend\\backup\\basebackup_throttle.c, <unknown>, include\\backup\\basebackup_sink.h","count":4},{"name":"module-depends-on","value":"backend\\backup\\basebackup_zstd.c, <unknown>, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"backend\\backup\\basebackup_zstd.c, <unknown>, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"backend\\catalog\\aclchk.c, backend\\utils\\init\\miscinit.c, <unknown>, backend\\nodes\\readfuncs.c, backend\\commands\\aggregatecmds.c, backend\\commands\\seclabel.c, interfaces\\libpq\\fe-exec.c, backend\\commands\\define.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"backend\\catalog\\catalog.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\cache\\ts_cache.c, <unknown>, backend\\utils\\adt\\tsvector_op.c, backend\\tsearch\\dict_ispell.c, backend\\utils\\mmgr\\mcxt.c, backend\\tsearch\\dict_synonym.c, backend\\jit\\llvm\\port.h, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"backend\\catalog\\namespace.c, <unknown>, backend\\commands\\alter.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\commands\\seclabel.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\commands\\aggregatecmds.c","count":4},{"name":"module-depends-on","value":"backend\\catalog\\pg_collation.c, <unknown>, backend\\catalog\\index.c, backend\\access\\table\\table.c, backend\\nodes\\makefuncs.c, backend\\nodes\\readfuncs.c, backend\\catalog\\pg_class.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\catalog\\pg_constraint.c","count":4},{"name":"module-depends-on","value":"backend\\catalog\\pg_collation.c, <unknown>, backend\\catalog\\pg_depend.c, backend\\access\\table\\table.c, backend\\catalog\\pg_constraint.c, backend\\catalog\\catalog.c, backend\\nodes\\readfuncs.c, backend\\access\\common\\scankey.c, backend\\jit\\llvm\\postgres.h, backend\\access\\index\\genam.c","count":4},{"name":"module-depends-on","value":"backend\\catalog\\pg_collation.c, <unknown>, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"backend\\catalog\\pg_collation.c, <unknown>, interfaces\\libpq\\fe-exec.c, backend\\catalog\\pg_depend.c, backend\\utils\\mmgr\\mcxt.c, backend\\access\\table\\table.c, backend\\catalog\\pg_constraint.c, backend\\access\\common\\scankey.c, backend\\jit\\llvm\\postgres.h, backend\\access\\index\\genam.c","count":4},{"name":"module-depends-on","value":"backend\\catalog\\pg_depend.c, <unknown>, backend\\catalog\\namespace.c, backend\\catalog\\pg_collation.c, backend\\access\\transam\\varsup.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, backend\\access\\common\\scankey.c, backend\\catalog\\pg_constraint.c, backend\\jit\\llvm\\postgres.h","count":4},{"name":"module-depends-on","value":"backend\\commands\\aggregatecmds.c, <unknown>, backend\\access\\table\\table.c, backend\\commands\\seclabel.c, backend\\commands\\alter.c, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\commands\\analyze.c","count":4},{"name":"module-depends-on","value":"backend\\commands\\tablecmds.c, <unknown>, backend\\nodes\\readfuncs.c, backend\\commands\\aggregatecmds.c, backend\\commands\\alter.c, interfaces\\libpq\\fe-exec.c, backend\\access\\table\\table.c, backend\\commands\\sequence.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"backend\\executor\\execExprInterp.c, <unknown>, backend\\executor\\execParallel.c, include\\nodes\\nodes.h, backend\\executor\\execUtils.c, backend\\executor\\execProcnode.c, backend\\executor\\execTuples.c, interfaces\\libpq\\fe-exec.c, backend\\executor\\nodeAppend.c, backend\\executor\\nodeWindowAgg.c","count":4},{"name":"module-depends-on","value":"backend\\executor\\execExprInterp.c, <unknown>, backend\\executor\\nodeValuesscan.c, include\\nodes\\nodes.h, backend\\executor\\execUtils.c, backend\\executor\\nodeWindowAgg.c, backend\\executor\\execProcnode.c, backend\\executor\\execTuples.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"backend\\executor\\execExprInterp.c, <unknown>, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\readfuncs.c, backend\\executor\\instrument.c, backend\\executor\\nodeWindowAgg.c, include\\executor\\executor.h, backend\\storage\\ipc\\barrier.c, backend\\utils\\sort\\sharedtuplestore.c","count":4},{"name":"module-depends-on","value":"backend\\executor\\execExprInterp.c, <unknown>, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\executor\\instrument.c, backend\\executor\\execAmi.c, backend\\nodes\\tidbitmap.c, backend\\nodes\\readfuncs.c, backend\\access\\index\\indexam.c","count":4},{"name":"module-depends-on","value":"backend\\executor\\execExprInterp.c, <unknown>, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, include\\storage\\itemptr.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\expandeddatum.c, include\\executor\\tuptable.h","count":4},{"name":"module-depends-on","value":"backend\\executor\\execExprInterp.c, <unknown>, backend\\utils\\sort\\tuplestore.c, backend\\executor\\nodeValuesscan.c, backend\\executor\\execScan.c, include\\nodes\\nodes.h, backend\\utils\\misc\\queryenvironment.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\executor\\execMain.c","count":4},{"name":"module-depends-on","value":"backend\\executor\\execExprInterp.c, <unknown>, backend\\utils\\sort\\tuplestore.c, backend\\executor\\nodeValuesscan.c, backend\\nodes\\readfuncs.c, backend\\jit\\llvm\\postgres.h, backend\\executor\\execUtils.c, backend\\executor\\execScan.c, include\\nodes\\nodes.h, backend\\executor\\execTuples.c","count":4},{"name":"module-depends-on","value":"backend\\executor\\execTuples.c, <unknown>","count":4},{"name":"module-depends-on","value":"backend\\jit\\llvm\\postgres.h, backend\\utils\\cache\\syscache.c, <unknown>, backend\\access\\table\\table.c, backend\\rewrite\\rewriteDefine.c, backend\\rewrite\\rewriteHandler.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\catalog\\indexing.c, backend\\utils\\cache\\inval.c","count":4},{"name":"module-depends-on","value":"backend\\jit\\llvm\\postgres.h, backend\\utils\\cache\\syscache.c, <unknown>, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\cache\\catcache.c, backend\\nodes\\list.c, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\datum.c","count":4},{"name":"module-depends-on","value":"backend\\jit\\llvm\\postgres.h, backend\\utils\\fmgr\\fmgr.c","count":4},{"name":"module-depends-on","value":"backend\\jit\\llvm\\postgres.h, common\\hashfn.c, <unknown>","count":4},{"name":"module-depends-on","value":"backend\\libpq\\auth-scram.c, <unknown>, backend\\tcop\\postgres.c, backend\\libpq\\be-secure-gssapi.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-misc.c, interfaces\\libpq\\fe-secure-gssapi.c, backend\\storage\\ipc\\latch.c, backend\\libpq\\pqcomm.c","count":4},{"name":"module-depends-on","value":"backend\\libpq\\pqformat.c, <unknown>, include\\libpq\\pqformat.h, backend\\access\\common\\tupdesc.c, include\\executor\\tuptable.h, backend\\executor\\execExprInterp.c, backend\\utils\\fmgr\\fmgr.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\numutils.c, backend\\access\\common\\reloptions.c","count":4},{"name":"module-depends-on","value":"backend\\nodes\\readfuncs.c, <unknown>, backend\\optimizer\\util\\appendinfo.c, backend\\nodes\\nodeFuncs.c, backend\\rewrite\\rewriteManip.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\list.c, backend\\optimizer\\path\\costsize.c","count":4},{"name":"module-depends-on","value":"backend\\nodes\\tidbitmap.c, <unknown>, backend\\nodes\\readfuncs.c, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, port\\pg_bitutils.c, include\\port\\pg_bitutils.h, backend\\jit\\llvm\\postgres.h","count":4},{"name":"module-depends-on","value":"backend\\nodes\\tidbitmap.c, <unknown>, include\\port\\pg_bitutils.h, backend\\utils\\mmgr\\mcxt.c, backend\\access\\gin\\ginpostinglist.c, backend\\nodes\\bitmapset.c, include\\nodes\\pg_list.h, backend\\nodes\\equalfuncs.c, backend\\nodes\\readfuncs.c, backend\\nodes\\copyfuncs.c","count":4},{"name":"module-depends-on","value":"backend\\optimizer\\path\\allpaths.c, <unknown>, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, include\\nodes\\pg_list.h, backend\\statistics\\extended_stats.c, backend\\nodes\\bitmapset.c, include\\nodes\\nodeFuncs.h, backend\\optimizer\\util\\clauses.c, backend\\utils\\cache\\lsyscache.c","count":4},{"name":"module-depends-on","value":"backend\\optimizer\\plan\\analyzejoins.c, <unknown>, backend\\nodes\\readfuncs.c, backend\\optimizer\\util\\tlist.c, backend\\optimizer\\plan\\subselect.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\tcop\\postgres.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\list.c","count":4},{"name":"module-depends-on","value":"backend\\parser\\analyze.c, <unknown>, backend\\nodes\\readfuncs.c, backend\\tcop\\postgres.c, backend\\parser\\parse_node.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\parser\\parse_agg.c, backend\\utils\\cache\\lsyscache.c, backend\\nodes\\nodeFuncs.c","count":4},{"name":"module-depends-on","value":"backend\\parser\\analyze.c, <unknown>, backend\\parser\\parse_agg.c, backend\\nodes\\makefuncs.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, include\\nodes\\pg_list.h, backend\\utils\\error\\elog.c, backend\\catalog\\namespace.c, backend\\parser\\parse_node.c","count":4},{"name":"module-depends-on","value":"backend\\parser\\analyze.c, <unknown>, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\mb\\mbutils.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, backend\\parser\\parse_expr.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"backend\\parser\\analyze.c, <unknown>, include\\nodes\\pg_list.h, backend\\utils\\error\\elog.c, backend\\parser\\parse_node.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\list.c, backend\\parser\\parse_expr.c, backend\\parser\\parse_coerce.c","count":4},{"name":"module-depends-on","value":"backend\\partitioning\\partbounds.c, <unknown>, backend\\utils\\time\\snapmgr.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\cache\\partcache.c, backend\\catalog\\pg_inherits.c, include\\nodes\\pg_list.h, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\cache\\syscache.c","count":4},{"name":"module-depends-on","value":"backend\\port\\atomics.c, <unknown>, include\\port\\atomics\\generic.h, include\\port\\atomics\\generic-gcc.h, backend\\utils\\adt\\formatting.c","count":4},{"name":"module-depends-on","value":"backend\\port\\win32\\signal.c, <unknown>, backend\\postmaster\\postmaster.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\synchapi.h, backend\\storage\\ipc\\dsm_impl.c, bin\\pg_basebackup\\pg_basebackup.c, bin\\pg_upgrade\\parallel.c, backend\\utils\\error\\elog.c, backend\\nodes\\readfuncs.c, backend\\commands\\collationcmds.c","count":4},{"name":"module-depends-on","value":"backend\\postmaster\\checkpointer.c, <unknown>, backend\\postmaster\\auxprocess.c, interfaces\\libpq\\legacy-pqsignal.c, backend\\bootstrap\\bootstrap.c, backend\\storage\\file\\fd.c, backend\\utils\\adt\\timestamp.c, backend\\utils\\mmgr\\aset.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\storage\\buffer\\bufmgr.c","count":4},{"name":"module-depends-on","value":"backend\\postmaster\\checkpointer.c, <unknown>, backend\\postmaster\\auxprocess.c, interfaces\\libpq\\legacy-pqsignal.c, backend\\bootstrap\\bootstrap.c, backend\\storage\\file\\fd.c, backend\\utils\\mmgr\\aset.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\nodes\\readfuncs.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"backend\\postmaster\\checkpointer.c, <unknown>, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\misc\\ps_status.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\msxml.h, interfaces\\libpq\\fe-lobj.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\winsock2.h, bin\\pg_test_fsync\\pg_test_fsync.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h","count":4},{"name":"module-depends-on","value":"backend\\postmaster\\checkpointer.c, <unknown>, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\misc\\ps_status.c, backend\\postmaster\\autovacuum.c, backend\\storage\\lmgr\\proc.c, backend\\utils\\init\\postinit.c, backend\\storage\\ipc\\procsignal.c, backend\\utils\\resowner\\resowner.c","count":4},{"name":"module-depends-on","value":"backend\\regex\\regexec.c, <unknown>, backend\\tcop\\postgres.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"backend\\replication\\logical\\applyparallelworker.c, <unknown>, backend\\access\\transam\\xact.c, backend\\access\\transam\\xloginsert.c, backend\\replication\\logical\\decode.c, backend\\access\\transam\\xlog.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"backend\\replication\\logical\\launcher.c, <unknown>, backend\\replication\\logical\\applyparallelworker.c, port\\snprintf.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\transam\\xact.c, backend\\utils\\time\\snapmgr.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\libpq\\pqformat.c","count":4},{"name":"module-depends-on","value":"backend\\replication\\slot.c, <unknown>, backend\\catalog\\catalog.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\float.c, backend\\utils\\fmgr\\funcapi.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\utils\\pg_lsn.h","count":4},{"name":"module-depends-on","value":"backend\\replication\\slot.c, <unknown>, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\postmaster\\auxprocess.c, backend\\replication\\slotfuncs.c, backend\\storage\\lmgr\\spin.c","count":4},{"name":"module-depends-on","value":"backend\\replication\\slot.c, <unknown>, backend\\replication\\logical\\applyparallelworker.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\transam\\xlog.c, backend\\utils\\mmgr\\aset.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\utils\\mmgr\\mcxt.c, backend\\replication\\logical\\launcher.c","count":4},{"name":"module-depends-on","value":"backend\\replication\\slot.c, <unknown>, backend\\replication\\slotfuncs.c, backend\\storage\\lmgr\\lwlock.c, port\\snprintf.c, backend\\utils\\misc\\ps_status.c, backend\\storage\\ipc\\latch.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\port\\atomics.c","count":4},{"name":"module-depends-on","value":"backend\\storage\\ipc\\barrier.c, <unknown>, backend\\storage\\ipc\\dsm.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, port\\snprintf.c, interfaces\\libpq\\fe-exec.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\memoryapi.h, port\\win32error.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\errhandlingapi.h","count":4},{"name":"module-depends-on","value":"backend\\storage\\ipc\\barrier.c, <unknown>, backend\\utils\\hash\\dynahash.c, backend\\storage\\ipc\\sinvaladt.c, backend\\storage\\lmgr\\lock.c, backend\\nodes\\readfuncs.c, backend\\storage\\ipc\\procarray.c, interfaces\\libpq\\fe-exec.c, backend\\access\\transam\\xlogrecovery.c, backend\\port\\win32\\signal.c","count":4},{"name":"module-depends-on","value":"backend\\storage\\ipc\\procsignal.c, <unknown>, backend\\postmaster\\checkpointer.c, include\\utils\\guc.h, backend\\storage\\ipc\\ipc.c, backend\\utils\\mmgr\\mcxt.c, backend\\storage\\ipc\\latch.c","count":4},{"name":"module-depends-on","value":"backend\\storage\\ipc\\sinvaladt.c, <unknown>, backend\\storage\\ipc\\dsm.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\storage\\ipc\\barrier.c, backend\\storage\\ipc\\latch.c, backend\\access\\transam\\xact.c, backend\\utils\\cache\\inval.c, backend\\jit\\llvm\\utils\\palloc.h","count":4},{"name":"module-depends-on","value":"backend\\storage\\lmgr\\proc.c, <unknown>, backend\\catalog\\catalog.c, backend\\storage\\lmgr\\lock.c, backend\\utils\\cache\\inval.c, include\\storage\\itemptr.h, backend\\storage\\ipc\\procarray.c, backend\\port\\win32\\signal.c, backend\\tcop\\postgres.c, backend\\access\\transam\\subtrans.c","count":4},{"name":"module-depends-on","value":"backend\\tcop\\backend_startup.c, <unknown>, backend\\access\\common\\printtup.c, backend\\executor\\tstoreReceiver.c, backend\\commands\\createas.c, interfaces\\libpq\\fe-exec.c, backend\\commands\\copyto.c, backend\\executor\\functions.c, backend\\commands\\matview.c, backend\\executor\\tqueue.c","count":4},{"name":"module-depends-on","value":"backend\\tcop\\backend_startup.c, <unknown>, backend\\tcop\\fastpath.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\access\\transam\\xact.c, backend\\access\\transam\\xlog.c, backend\\utils\\init\\miscinit.c, backend\\tcop\\postgres.c, backend\\nodes\\copyfuncs.c","count":4},{"name":"module-depends-on","value":"backend\\tcop\\cmdtag.c, backend\\tcop\\utility.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\activity\\backend_status.c, <unknown>, backend\\executor\\execExprInterp.c, backend\\access\\transam\\xact.c, backend\\executor\\execUtils.c, backend\\jit\\llvm\\utils\\palloc.h, include\\nodes\\pg_list.h, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"backend\\utils\\activity\\pgstat_bgwriter.c, <unknown>, backend\\storage\\lmgr\\lwlock.c, backend\\replication\\slot.c, backend\\utils\\activity\\pgstat_function.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\activity\\pgstat.c, backend\\utils\\activity\\pgstat_database.c, backend\\utils\\activity\\pgstat_shmem.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\activity\\pgstat_database.c, <unknown>, interfaces\\libpq\\fe-exec.c, backend\\utils\\activity\\pgstat_bgwriter.c, backend\\utils\\activity\\pgstat_relation.c, backend\\utils\\activity\\pgstat.c, include\\lib\\ilist.h, backend\\utils\\activity\\pgstat_shmem.c, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\activity\\pgstat_xact.c, <unknown>, backend\\nodes\\readfuncs.c, backend\\utils\\activity\\pgstat.c, backend\\utils\\cache\\inval.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\cache\\syscache.c, backend\\utils\\activity\\pgstat_shmem.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"backend\\utils\\activity\\pgstat_xact.c, <unknown>, backend\\utils\\activity\\pgstat_bgwriter.c, backend\\utils\\activity\\pgstat_shmem.c, backend\\utils\\adt\\timestamp.c, backend\\utils\\activity\\pgstat.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\adt\\expandedrecord.c, <unknown>, backend\\jit\\llvm\\postgres.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\adt\\expandeddatum.c, backend\\utils\\mmgr\\mcxt.c, backend\\access\\common\\detoast.c, backend\\utils\\adt\\rowtypes.c, backend\\utils\\fmgr\\fmgr.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\adt\\expandedrecord.c, <unknown>, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\jit\\llvm\\postgres.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, port\\pgstrcasecmp.c, include\\utils\\float.h, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\adt\\expandedrecord.c, <unknown>, interfaces\\libpq\\fe-exec.c, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\error\\elog.c, backend\\utils\\adt\\numeric.c, include\\utils\\pg_lsn.h, port\\snprintf.c, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\adt\\expandedrecord.c, <unknown>, port\\pg_strong_random.c, common\\pg_prng.c, backend\\utils\\adt\\timestamp.c, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\fmgr\\fmgr.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, <unknown>, port\\snprintf.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\storage\\file\\fd.c, backend\\utils\\fmgr\\dfmgr.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\adt\\float.c, backend\\utils\\fmgr\\fmgr.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\adt\\float.c, backend\\utils\\fmgr\\fmgr.c, <unknown>, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\format_type.c, backend\\utils\\adt\\formatting.c, backend\\utils\\cache\\lsyscache.c, backend\\utils\\adt\\expandedrecord.c, backend\\executor\\execExprInterp.c, include\\storage\\itemptr.h","count":4},{"name":"module-depends-on","value":"backend\\utils\\adt\\format_type.c, backend\\utils\\adt\\varlena.c, backend\\jit\\llvm\\postgres.h","count":4},{"name":"module-depends-on","value":"backend\\utils\\adt\\inet_cidr_ntop.c, <unknown>, backend\\libpq\\auth.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-exec.c, interfaces\\libpq\\fe-secure-gssapi.c, port\\snprintf.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\adt\\inet_cidr_ntop.c, <unknown>, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\ctype.h, backend\\backup\\walsummary.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\adt\\selfuncs.c, <unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\format_type.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\fmgr\\fmgr.c, backend\\utils\\adt\\varbit.c, backend\\utils\\cache\\lsyscache.c, backend\\utils\\adt\\multirangetypes.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\adt\\selfuncs.c, <unknown>, backend\\utils\\adt\\float.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\format_type.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\fmgr\\fmgr.c, backend\\utils\\adt\\varbit.c, backend\\utils\\cache\\lsyscache.c, backend\\utils\\adt\\rangetypes.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\adt\\selfuncs.c, <unknown>, backend\\utils\\adt\\varbit.c, backend\\utils\\cache\\typcache.c, backend\\utils\\adt\\array_typanalyze.c, backend\\utils\\adt\\formatting.c, backend\\utils\\adt\\format_type.c, backend\\utils\\cache\\lsyscache.c, backend\\utils\\adt\\expandedrecord.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\cache\\lsyscache.c, <unknown>, backend\\utils\\hash\\dynahash.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\nodes\\readfuncs.c, backend\\utils\\cache\\catcache.c, backend\\utils\\fmgr\\fmgr.c, backend\\utils\\cache\\inval.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\error\\elog.c, <unknown>, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"backend\\utils\\error\\elog.c, <unknown>, interfaces\\libpq\\fe-exec.c, common\\stringinfo.c, backend\\utils\\adt\\json.c, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\utils\\mmgr\\mcxt.c, common\\psprintf.c, backend\\utils\\error\\csvlog.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\fmgr\\fmgr.c, <unknown>, backend\\jit\\llvm\\postgres.h","count":4},{"name":"module-depends-on","value":"backend\\utils\\hash\\dynahash.c, <unknown>, backend\\nodes\\readfuncs.c, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\cache\\lsyscache.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\cache\\catcache.c, backend\\utils\\cache\\inval.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\hash\\dynahash.c, <unknown>, backend\\storage\\ipc\\shmem.c, backend\\nodes\\readfuncs.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"backend\\utils\\hash\\dynahash.c, <unknown>, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, backend\\utils\\cache\\lsyscache.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\cache\\spccache.c, backend\\utils\\cache\\catcache.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\init\\miscinit.c, <unknown>, backend\\utils\\adt\\acl.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\utils\\misc\\guc.c, backend\\utils\\init\\globals.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\init\\miscinit.c, <unknown>, backend\\utils\\misc\\rls.c, backend\\utils\\misc\\conffiles.c, backend\\utils\\cache\\syscache.c, backend\\jit\\llvm\\postgres.h, backend\\utils\\misc\\guc.c, backend\\utils\\cache\\inval.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\misc\\guc.c, <unknown>, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, port\\snprintf.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\misc\\ps_status.c, <unknown>","count":4},{"name":"module-depends-on","value":"backend\\utils\\mmgr\\aset.c, <unknown>, backend\\nodes\\readfuncs.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\lib\\ilist.h, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\bump.c, include\\utils\\memutils_internal.h","count":4},{"name":"module-depends-on","value":"backend\\utils\\mmgr\\aset.c, <unknown>, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, port\\snprintf.c, backend\\lib\\dshash.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, backend\\tcop\\postgres.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\mmgr\\aset.c, <unknown>, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\mcxt.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\lib\\ilist.h, include\\utils\\memutils_internal.h, backend\\nodes\\readfuncs.c, include\\port\\pg_bitutils.h","count":4},{"name":"module-depends-on","value":"backend\\utils\\resowner\\resowner.c, backend\\jit\\llvm\\postgres.h, <unknown>, backend\\access\\common\\reloptions.c, backend\\utils\\mmgr\\mcxt.c, backend\\access\\gin\\ginpostinglist.c, backend\\nodes\\readfuncs.c, backend\\utils\\adt\\datum.c, interfaces\\libpq\\fe-exec.c, include\\common\\hashfn.h","count":4},{"name":"module-depends-on","value":"backend\\utils\\resowner\\resowner.c, backend\\jit\\llvm\\postgres.h, <unknown>, backend\\storage\\ipc\\barrier.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, backend\\commands\\collationcmds.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\synchapi.h, backend\\storage\\ipc\\dsm_impl.c, backend\\storage\\ipc\\dsm.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\resowner\\resowner.c, backend\\jit\\llvm\\postgres.h, <unknown>, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, interfaces\\libpq\\fe-misc.c, port\\win32fdatasync.c, backend\\storage\\file\\buffile.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\sys\\stat.h, backend\\utils\\adt\\genfile.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\resowner\\resowner.c, backend\\jit\\llvm\\postgres.h, <unknown>, backend\\utils\\cache\\inval.c, backend\\utils\\cache\\lsyscache.c, backend\\utils\\mmgr\\aset.c, backend\\jit\\llvm\\utils\\palloc.h, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\copyfuncs.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\resowner\\resowner.c, backend\\jit\\llvm\\postgres.h, <unknown>, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\jit\\llvmjit.h, backend\\utils\\mmgr\\mcxt.c, backend\\nodes\\readfuncs.c, backend\\nodes\\list.c, common\\psprintf.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\resowner\\resowner.c, backend\\jit\\llvm\\postgres.h, <unknown>, backend\\utils\\time\\combocid.c, backend\\access\\transam\\xact.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, backend\\storage\\lmgr\\predicate.c, backend\\storage\\ipc\\procarray.c, backend\\lib\\pairingheap.c","count":4},{"name":"module-depends-on","value":"backend\\utils\\resowner\\resowner.c, backend\\jit\\llvm\\postgres.h, <unknown>, include\\common\\hashfn.h, backend\\utils\\cache\\lsyscache.c, backend\\utils\\fmgr\\fmgr.c, backend\\utils\\adt\\formatting.c, backend\\executor\\execExprInterp.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"bin\\pg_basebackup\\bbstreamer_file.c, <unknown>, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"bin\\pg_basebackup\\pg_basebackup.c, port\\snprintf.c, <unknown>, bin\\pg_basebackup\\pg_receivewal.c, bin\\pg_basebackup\\bbstreamer_file.c, bin\\pg_basebackup\\streamutil.c, interfaces\\libpq\\fe-exec.c, interfaces\\libpq\\fe-connect.c, backend\\nodes\\readfuncs.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"bin\\pg_dump\\pg_backup_archiver.c, <unknown>, bin\\pg_dump\\pg_dump.c, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-exec.c, bin\\pg_dump\\pg_backup_utils.c, common\\fe_memutils.c, backend\\utils\\mmgr\\mcxt.c, fe_utils\\simple_list.c, bin\\pg_dump\\pg_backup_tar.c","count":4},{"name":"module-depends-on","value":"bin\\pg_upgrade\\util.c, bin\\pg_upgrade\\exec.c, interfaces\\libpq\\fe-exec.c, <unknown>, bin\\pg_upgrade\\version.c, bin\\pg_upgrade\\server.c, bin\\initdb\\initdb.c, bin\\pg_upgrade\\check.c, interfaces\\libpq\\pqexpbuffer.c, fe_utils\\string_utils.c","count":4},{"name":"module-depends-on","value":"common\\d2s.c, <unknown>","count":4},{"name":"module-depends-on","value":"common\\logging.c, <unknown>, port\\path.c, backend\\bootstrap\\bootstrap.c, common\\pg_prng.c, interfaces\\libpq\\fe-exec.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, port\\snprintf.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, port\\getopt_long.c","count":4},{"name":"module-depends-on","value":"common\\stringinfo.c, <unknown>","count":4},{"name":"module-depends-on","value":"common\\stringinfo.c, <unknown>, backend\\access\\rmgrdesc\\genericdesc.c, backend\\access\\rmgrdesc\\gindesc.c, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"common\\stringinfo.c, <unknown>, backend\\access\\rmgrdesc\\genericdesc.c, backend\\access\\rmgrdesc\\gindesc.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"common\\stringinfo.c, <unknown>, backend\\access\\rmgrdesc\\rmgrdesc_utils.c, backend\\nodes\\readfuncs.c, backend\\access\\gin\\ginpostinglist.c, interfaces\\libpq\\fe-exec.c, backend\\access\\rmgrdesc\\genericdesc.c, backend\\access\\rmgrdesc\\gindesc.c, backend\\access\\transam\\xlogreader.c, include\\storage\\itemptr.h","count":4},{"name":"module-depends-on","value":"common\\stringinfo.c, <unknown>, backend\\nodes\\readfuncs.c","count":4},{"name":"module-depends-on","value":"common\\stringinfo.c, <unknown>, backend\\replication\\logical\\applyparallelworker.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, include\\utils\\pg_lsn.h, backend\\jit\\llvm\\postgres.h, backend\\utils\\adt\\varlena.c, backend\\utils\\sort\\tuplestore.c, backend\\replication\\slot.c","count":4},{"name":"module-depends-on","value":"common\\stringinfo.c, <unknown>, backend\\utils\\adt\\float.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stddef.h, backend\\utils\\mmgr\\mcxt.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, common\\d2s.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h","count":4},{"name":"module-depends-on","value":"common\\stringinfo.c, <unknown>, backend\\utils\\mb\\mbutils.c, include\\libpq\\pqformat.h, backend\\utils\\mmgr\\mcxt.c, backend\\libpq\\pqcomm.c, backend\\nodes\\readfuncs.c, backend\\libpq\\auth-scram.c, backend\\libpq\\be-fsstubs.c, backend\\utils\\error\\elog.c","count":4},{"name":"module-depends-on","value":"common\\stringinfo.c, <unknown>, common\\controldata_utils.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, common\\d2s.c, interfaces\\libpq\\fe-exec.c, backend\\access\\index\\amvalidate.c","count":4},{"name":"module-depends-on","value":"common\\stringinfo.c, bin\\pg_waldump\\pg_waldump.c, <unknown>, interfaces\\libpq\\fe-exec.c, port\\snprintf.c, include\\access\\rmgr.h","count":4},{"name":"module-depends-on","value":"fe_utils\\parallel_slot.c, <unknown>, interfaces\\libpq\\pqexpbuffer.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, interfaces\\libpq\\fe-connect.c, interfaces\\libpq\\fe-exec.c, fe_utils\\string_utils.c, port\\snprintf.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, port\\quotes.c","count":4},{"name":"module-depends-on","value":"include\\access\\transam.h, backend\\jit\\llvm\\postgres.h, <unknown>","count":4},{"name":"module-depends-on","value":"include\\common\\hashfn.h, <unknown>, backend\\access\\nbtree\\nbtcompare.c, backend\\jit\\llvm\\postgres.h, backend\\backup\\walsummaryfuncs.c, backend\\utils\\adt\\float.c, backend\\utils\\adt\\format_type.c, include\\utils\\float.h, backend\\utils\\adt\\jsonb_op.c, backend\\utils\\adt\\formatting.c","count":4},{"name":"module-depends-on","value":"include\\common\\hashfn_unstable.h, <unknown>, backend\\catalog\\pg_collation.c, interfaces\\libpq\\fe-exec.c, backend\\utils\\mmgr\\aset.c, backend\\utils\\mmgr\\mcxt.c, backend\\catalog\\pg_operator.c, backend\\commands\\dbcommands.c, backend\\utils\\error\\elog.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"include\\nodes\\nodeFuncs.h, <unknown>, backend\\optimizer\\util\\appendinfo.c, backend\\nodes\\readfuncs.c, include\\nodes\\nodes.h, backend\\optimizer\\util\\clauses.c, include\\nodes\\pg_list.h, backend\\optimizer\\util\\var.c, backend\\nodes\\bitmapset.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"include\\utils\\expandeddatum.h, <unknown>, backend\\utils\\adt\\expandedrecord.c","count":4},{"name":"module-depends-on","value":"interfaces\\ecpg\\ecpglib\\connect.c, <unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\processthreadsapi.h, interfaces\\ecpg\\ecpglib\\misc.c, interfaces\\libpq\\fe-exec.c, interfaces\\ecpg\\ecpglib\\error.c, backend\\nodes\\readfuncs.c, backend\\access\\index\\amvalidate.c, interfaces\\ecpg\\ecpglib\\typename.c, interfaces\\ecpg\\ecpglib\\memory.c","count":4},{"name":"module-depends-on","value":"interfaces\\libpq\\fe-exec.c, <unknown>, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, interfaces\\libpq\\fe-print.c, backend\\lib\\dshash.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\consoleapi.h, common\\config_info.c, common\\pg_get_line.c, common\\fe_memutils.c","count":4},{"name":"module-depends-on","value":"interfaces\\libpq\\fe-exec.c, <unknown>, backend\\utils\\error\\elog.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\securitybaseapi.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\errhandlingapi.h, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, C:\\mingw64\\x86_64-w64-mingw32\\include\\processenv.h, port\\snprintf.c, backend\\lib\\dshash.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h","count":4},{"name":"module-depends-on","value":"interfaces\\libpq\\fe-exec.c, <unknown>, bin\\pg_upgrade\\option.c, port\\snprintf.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, common\\rmtree.c, bin\\pg_upgrade\\version.c, port\\pgcheckdir.c, bin\\pg_upgrade\\check.c, bin\\pg_upgrade\\controldata.c","count":4},{"name":"module-depends-on","value":"interfaces\\libpq\\fe-secure.c, <unknown>, interfaces\\libpq\\fe-exec.c, interfaces\\libpq\\fe-cancel.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h, backend\\nodes\\readfuncs.c, interfaces\\libpq\\fe-misc.c, port\\pg_strong_random.c, common\\pg_prng.c, port\\win32gettimeofday.c","count":4},{"name":"module-depends-on","value":"interfaces\\libpq\\pqexpbuffer.c, <unknown>, fe_utils\\print.c, backend\\nodes\\readfuncs.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, interfaces\\libpq\\fe-connect.c, interfaces\\libpq\\fe-exec.c, bin\\psql\\command.c, port\\snprintf.c, port\\pgstrcasecmp.c","count":4},{"name":"module-depends-on","value":"port\\snprintf.c, <unknown>, interfaces\\ecpg\\preproc\\type.c, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, port\\path.c, common\\exec.c, backend\\lib\\dshash.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"port\\snprintf.c, <unknown>, interfaces\\libpq\\fe-exec.c, backend\\lib\\dshash.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, C:\\mingw64\\x86_64-w64-mingw32\\include\\io.h, backend\\storage\\file\\copydir.c, interfaces\\libpq\\fe-lobj.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\msxml.h, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib","count":4},{"name":"module-depends-on","value":"port\\snprintf.c, <unknown>, interfaces\\libpq\\fe-exec.c, backend\\nodes\\readfuncs.c, common\\logging.c, port\\path.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, port\\getopt_long.c, common\\fe_memutils.c, fe_utils\\option_utils.c","count":4},{"name":"module-depends-on","value":"port\\snprintf.c, <unknown>, interfaces\\libpq\\fe-exec.c, common\\logging.c, port\\path.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, port\\getopt_long.c, backend\\nodes\\readfuncs.c, common\\controldata_utils.c, include\\access\\xlog_internal.h","count":4},{"name":"module-depends-on","value":"port\\snprintf.c, <unknown>, interfaces\\libpq\\fe-exec.c, fe_utils\\parallel_slot.c, interfaces\\libpq\\fe-connect.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, fe_utils\\cancel.c","count":4},{"name":"module-depends-on","value":"port\\snprintf.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, interfaces\\libpq\\fe-print.c, common\\stringinfo.c, <unknown>, interfaces\\libpq\\fe-exec.c, backend\\tcop\\fastpath.c, backend\\port\\win32\\signal.c, backend\\tcop\\backend_startup.c, backend\\libpq\\pqcomm.c","count":4},{"name":"module-depends-on","value":"port\\snprintf.c, backend\\lib\\dshash.c, C:\\mingw64\\x86_64-w64-mingw32\\include\\stdio.h, <unknown>, port\\path.c, C:\\mingw64\\lib\\gcc\\x86_64-w64-mingw32\\15.2.0\\include\\c++\\cstdlib, common\\exec.c, common\\config_info.c, interfaces\\libpq\\fe-exec.c","count":4},{"name":"module-depends-on","value":"port\\win32getrusage.c, backend\\tcop\\postgres.c, <unknown>, port\\win32gettimeofday.c, interfaces\\libpq\\fe-exec.c, port\\snprintf.c, backend\\utils\\misc\\guc_funcs.c","count":4},{"name":"test-count","value":"102","count":4},{"name":"test-count","value":"115","count":4},{"name":"test-count","value":"12","count":4},{"name":"test-count","value":"120","count":4},{"name":"test-count","value":"128","count":4},{"name":"test-count","value":"134","count":4},{"name":"test-count","value":"149","count":4},{"name":"test-count","value":"153","count":4},{"name":"test-count","value":"171","count":4},{"name":"test-count","value":"175","count":4},{"name":"test-count","value":"1869","count":4},{"name":"test-count","value":"213","count":4},{"name":"test-count","value":"2207","count":4},{"name":"test-count","value":"2332","count":4},{"name":"test-count","value":"261","count":4},{"name":"test-count","value":"28","count":4},{"name":"test-count","value":"284","count":4},{"name":"test-count","value":"309","count":4},{"name":"test-count","value":"311","count":4},{"name":"test-count","value":"320","count":4},{"name":"test-count","value":"383","count":4},{"name":"test-count","value":"443","count":4},{"name":"test-count","value":"47","count":4},{"name":"test-count","value":"51","count":4},{"name":"test-count","value":"52","count":4},{"name":"test-count","value":"543","count":4},{"name":"test-count","value":"56","count":4},{"name":"test-count","value":"58","count":4},{"name":"test-count","value":"61","count":4},{"name":"test-count","value":"63","count":4},{"name":"test-count","value":"697","count":4},{"name":"test-count","value":"81","count":4},{"name":"tested-by","value":"GlobalVisTestFor","count":4},{"name":"tested-by","value":"GlobalVisTestIsRemovableFullXid","count":4},{"name":"tested-by","value":"GlobalVisTestIsRemovableXid","count":4},{"name":"tested-by","value":"HeapKeyTest","count":4},{"name":"tested-by","value":"RI_FKey_check_ins","count":4},{"name":"tested-by","value":"RI_FKey_check_upd","count":4},{"name":"tested-by","value":"RI_FKey_pk_upd_check_required","count":4},{"name":"tested-by","value":"TestConfiguration","count":4},{"name":"tested-by","value":"TestConfiguration, TestConfiguration, TestConfiguration","count":4},{"name":"tested-by","value":"_bt_check_natts, _bt_check_natts, _bt_check_natts","count":4},{"name":"tested-by","value":"_bt_check_natts, _bt_check_natts, table_tuple_get_latest_tid","count":4},{"name":"tested-by","value":"_bt_check_natts, _bt_check_third_page","count":4},{"name":"tested-by","value":"_bt_check_natts, _bt_check_third_page, _bt_check_third_page","count":4},{"name":"tested-by","value":"_bt_check_rowcompare, check_agglevels_and_constraints, check_agg_arguments_walker, check_ungrouped_columns_walker, r_check_vowel_harmony, r_check_vowel_harmony, r_check_vowel_harmony, r_check_vowel_ha","count":4},{"name":"tested-by","value":"_bt_check_rowcompare, check_wal_buffers, check_wal_buffers, check_functional_grouping, check_encoding_locale_matches, check_encoding_locale_matches, check_timezone, check_timezone, check_timezone, che","count":4},{"name":"tested-by","value":"_bt_check_third_page, _bt_check_third_page, _bt_check_third_page, _bt_check_third_page","count":4},{"name":"tested-by","value":"_bt_check_third_page, _bt_check_third_page, _bt_check_third_page, _bt_check_third_page, check_timezone, pq_check_connection, check_log_duration, check_log_duration, check_log_duration, check_max_stack","count":4},{"name":"tested-by","value":"_bt_check_third_page, _bt_check_third_page, _bt_check_third_page, _bt_check_third_page, spgInnerTest, spgInnerTest, check_wal_segment_size, check_wal_segment_size, check_wal_segment_size, check_wal_co","count":4},{"name":"tested-by","value":"_bt_check_unique, _bt_check_natts, _bt_check_natts","count":4},{"name":"tested-by","value":"_bt_check_unique, _bt_check_natts, _bt_check_natts, _bt_check_natts, _bt_check_natts","count":4},{"name":"tested-by","value":"_bt_check_unique, _bt_check_rowcompare, _bt_check_natts, _bt_check_third_page, _bt_check_third_page, check_wal_segment_size, check_wal_consistency_checking, check_wal_consistency_checking, check_wal_c","count":4},{"name":"tested-by","value":"_bt_check_unique, _bt_check_unique, _bt_check_third_page, _bt_check_third_page, _bt_check_third_page, _bt_check_third_page, _bt_check_third_page, _bt_check_third_page, _bt_check_third_page, _bt_check_","count":4},{"name":"tested-by","value":"_bt_check_unique, _bt_check_unique, _bt_check_third_page, check_exclusion_or_unique_constraint, check_exclusion_or_unique_constraint","count":4},{"name":"tested-by","value":"_bt_check_unique, _bt_check_unique, _bt_check_unique, _bt_check_compare, _bt_check_rowcompare, _bt_check_rowcompare, _bt_check_natts, _bt_check_natts, _bt_check_natts, _bt_check_third_page, check_slru","count":4},{"name":"tested-by","value":"_bt_check_unique, _bt_check_unique, _bt_check_unique, _bt_check_unique, _bt_check_unique","count":4},{"name":"tested-by","value":"_bt_check_unique, check_createrole_self_grant, check_createrole_self_grant, check_output_expressions, check_output_expressions, check_output_expressions, check_output_expressions, add_with_check_optio","count":4},{"name":"tested-by","value":"_bt_check_unique, check_exclusion_or_unique_constraint, check_exclusion_or_unique_constraint","count":4},{"name":"tested-by","value":"aclcheck_error_type, check_generic_type_consistency, check_generic_type_consistency","count":4},{"name":"tested-by","value":"aclcheck_error_type, check_object_ownership, check_object_ownership, check_of_type, check_sql_fn_retval, check_sql_fn_retval, check_sql_fn_retval, check_sql_fn_retval, check_sql_fn_retval, check_sql_f","count":4},{"name":"tested-by","value":"add_with_check_options","count":4},{"name":"tested-by","value":"call_enum_check_hook","count":4},{"name":"tested-by","value":"check_agg_arguments, check_agg_arguments, check_agg_arguments","count":4},{"name":"tested-by","value":"check_agg_arguments_walker, check_agg_arguments_walker, check_agg_arguments_walker, test_timing, test_timing","count":4},{"name":"tested-by","value":"check_agglevels_and_constraints, check_srf_call_placement","count":4},{"name":"tested-by","value":"check_and_drop_existing_subscriptions, check_for_data_types_usage, check_is_install_user, check_is_install_user, check_proper_datallowconn, check_for_prepared_transactions, check_for_isn_and_int8_pass","count":4},{"name":"tested-by","value":"check_and_dump_old_cluster, check_new_cluster","count":4},{"name":"tested-by","value":"check_and_push_window_quals","count":4},{"name":"tested-by","value":"check_and_push_window_quals, check_and_push_window_quals","count":4},{"name":"tested-by","value":"check_attrmap_match, check_attrmap_match, check_attrmap_match, check_attrmap_match, check_hash_func_signature, check_hash_func_signature, check_hash_func_signature, check_hash_func_signature, check_ha","count":4},{"name":"tested-by","value":"check_attrmap_match, check_attrmap_match, heap_get_latest_tid, heap_get_latest_tid, heap_get_latest_tid, heap_get_latest_tid, heap_get_latest_tid, heap_get_latest_tid, heap_get_latest_tid, test_lockmo","count":4},{"name":"tested-by","value":"check_attrmap_match, check_hash_func_signature, check_amproc_signature, check_amop_signature, _bt_check_unique, _bt_check_compare, _bt_check_third_page, _bt_check_third_page, _bt_check_third_page, _bt","count":4},{"name":"tested-by","value":"check_attrmap_match, check_hash_func_signature, check_hash_func_signature, check_hash_func_signature, check_hash_func_signature, heap_get_latest_tid, index_delete_check_htid, index_delete_check_htid, ","count":4},{"name":"tested-by","value":"check_backtrace_functions","count":4},{"name":"tested-by","value":"check_backup_label_files, check_control_files","count":4},{"name":"tested-by","value":"check_bin_dir","count":4},{"name":"tested-by","value":"check_client_connection_check_interval","count":4},{"name":"tested-by","value":"check_cluster_compatibility, check_cluster_compatibility","count":4},{"name":"tested-by","value":"check_data_dir","count":4},{"name":"tested-by","value":"check_datestyle","count":4},{"name":"tested-by","value":"check_datestyle, check_client_encoding, check_application_name, check_cluster_name, check_default_text_search_config","count":4},{"name":"tested-by","value":"check_datestyle, check_datestyle, check_datestyle, check_datestyle, check_client_encoding, check_application_name, check_cluster_name, check_default_text_search_config, call_string_check_hook","count":4},{"name":"tested-by","value":"check_datestyle, check_datestyle, check_datestyle, check_datestyle, check_synchronized_standby_slots, check_loadable_libraries","count":4},{"name":"tested-by","value":"check_datestyle, check_datestyle, check_datestyle, check_ident_usermap, check_loadable_libraries","count":4},{"name":"tested-by","value":"check_db_file_conflict, check_default_partition_contents, check_default_partition_contents, check_default_partition_contents","count":4},{"name":"tested-by","value":"check_default_partition_contents, check_domain_for_new_field, check_domain_for_new_tuple, check_domain_for_new_tuple","count":4},{"name":"tested-by","value":"check_default_partition_contents, domain_check_input","count":4},{"name":"tested-by","value":"check_default_table_access_method","count":4},{"name":"tested-by","value":"check_default_table_access_method, check_default_tablespace, check_temp_tablespaces, check_transaction_read_only, check_transaction_isolation, check_client_encoding, check_session_authorization, check","count":4},{"name":"tested-by","value":"check_default_tablespace, check_temp_tablespaces","count":4},{"name":"tested-by","value":"check_domain_for_new_field, check_domain_for_new_field, check_domain_for_new_tuple","count":4},{"name":"tested-by","value":"check_domain_for_new_field, check_domain_for_new_tuple, check_domain_for_new_tuple","count":4},{"name":"tested-by","value":"check_encoding_locale_matches, check_encoding_locale_matches, check_encoding_locale_matches, check_encoding_locale_matches, check_client_encoding","count":4},{"name":"tested-by","value":"check_exclusion_or_unique_constraint, check_default_partition_contents, check_default_partition_contents","count":4},{"name":"tested-by","value":"check_exclusion_or_unique_constraint, check_exclusion_or_unique_constraint","count":4},{"name":"tested-by","value":"check_expected_areq, check_expected_areq, check_expected_areq, check_expected_areq, check_expected_areq","count":4},{"name":"tested-by","value":"check_field_number, check_tuple_field_number, check_tuple_field_number, check_param_number","count":4},{"name":"tested-by","value":"check_for_data_types_usage, check_and_dump_old_cluster, check_and_dump_old_cluster, check_and_dump_old_cluster, check_and_dump_old_cluster, check_and_dump_old_cluster, check_and_dump_old_cluster, chec","count":4},{"name":"tested-by","value":"check_for_data_types_usage, check_cluster_versions, check_for_new_tablespace_dir, check_is_install_user, check_proper_datallowconn, check_for_prepared_transactions, check_for_isn_and_int8_passing_mism","count":4},{"name":"tested-by","value":"check_for_data_types_usage, check_for_data_types_usage, check_for_data_types_usage, check_proper_datallowconn, check_proper_datallowconn, check_for_isn_and_int8_passing_mismatch, check_for_isn_and_int","count":4},{"name":"tested-by","value":"check_for_data_types_usage, check_is_install_user, check_is_install_user, check_proper_datallowconn, check_for_prepared_transactions, check_for_isn_and_int8_passing_mismatch, check_for_user_defined_po","count":4},{"name":"tested-by","value":"check_for_data_types_usage, output_check_banner, output_check_banner, check_proper_datallowconn, check_for_isn_and_int8_passing_mismatch, check_for_user_defined_postfix_ops, check_for_incompatible_pol","count":4},{"name":"tested-by","value":"check_for_freed_segments, check_for_freed_segments","count":4},{"name":"tested-by","value":"check_for_freed_segments_locked","count":4},{"name":"tested-by","value":"check_for_incompatible_polymorphics, check_for_incompatible_polymorphics, check_for_incompatible_polymorphics","count":4},{"name":"tested-by","value":"check_functional_grouping","count":4},{"name":"tested-by","value":"check_functions_in_node, check_and_push_window_quals","count":4},{"name":"tested-by","value":"check_functions_in_node, check_functions_in_node, check_functions_in_node, check_functions_in_node, check_functions_in_node, check_functions_in_node, check_functions_in_node, check_functions_in_node","count":4},{"name":"tested-by","value":"check_generic_type_consistency, check_generic_type_consistency, check_generic_type_consistency, check_generic_type_consistency","count":4},{"name":"tested-by","value":"check_generic_type_consistency, check_generic_type_consistency, check_generic_type_consistency, check_generic_type_consistency, check_generic_type_consistency, check_generic_type_consistency","count":4},{"name":"tested-by","value":"check_hash_func_signature, check_amproc_signature","count":4},{"name":"tested-by","value":"check_hash_func_signature, check_amproc_signature, check_amop_signature, pg_attribute_aclcheck_all_ext, check_object_ownership, check_session_authorization, check_role, check_default_text_search_confi","count":4},{"name":"tested-by","value":"check_hash_func_signature, check_amproc_signature, check_amop_signature, pg_attribute_aclcheck_all_ext, pg_attribute_aclcheck_all_ext, pg_attribute_aclcheck_all_ext, index_check_primary_key, check_obj","count":4},{"name":"tested-by","value":"check_hash_func_signature, check_hash_func_signature, check_hash_func_signature, check_hash_func_signature, check_hash_func_signature, check_hash_func_signature, check_hash_func_signature, check_hash_","count":4},{"name":"tested-by","value":"check_hash_func_signature, check_hash_func_signature, heap_get_latest_tid, heap_get_latest_tid, heap_get_latest_tid, heap_get_latest_tid, heap_get_latest_tid, heap_get_latest_tid, heap_get_latest_tid,","count":4},{"name":"tested-by","value":"check_hash_func_signature, check_hash_func_signature, index_delete_check_htid, index_delete_check_htid, index_delete_check_htid, lazy_check_wraparound_failsafe, check_amproc_signature, check_amproc_si","count":4},{"name":"tested-by","value":"check_hashjoinable","count":4},{"name":"tested-by","value":"check_hba, check_hba","count":4},{"name":"tested-by","value":"check_hostname, check_hostname","count":4},{"name":"tested-by","value":"check_icu_locale_encoding","count":4},{"name":"tested-by","value":"check_index_predicates, check_redundant_nullability_qual, exec_check_rw_parameter","count":4},{"name":"tested-by","value":"check_input, check_data_directory, check_data_directory, check_for_new_tablespace_dir, pg_check_dir","count":4},{"name":"tested-by","value":"check_input, check_input, check_input, check_input, check_input, check_input, check_locale_name, check_locale_name, check_locale_name, check_locale_name, check_locale_name, check_locale_encoding, chec","count":4},{"name":"tested-by","value":"check_input_dir_permissions","count":4},{"name":"tested-by","value":"check_ip","count":4},{"name":"tested-by","value":"check_loadable_libraries, ecpg_check_PQresult","count":4},{"name":"tested-by","value":"check_locale, check_locale, check_locale, check_locale_name","count":4},{"name":"tested-by","value":"check_locale_monetary","count":4},{"name":"tested-by","value":"check_locale_name, check_publisher, check_subscriber, _check_database_version, check_required_directory, check_required_directory","count":4},{"name":"tested-by","value":"check_locale_numeric","count":4},{"name":"tested-by","value":"check_locale_time","count":4},{"name":"tested-by","value":"check_log_of_query","count":4},{"name":"tested-by","value":"check_log_statement","count":4},{"name":"tested-by","value":"check_max_stack_depth","count":4},{"name":"tested-by","value":"check_mergejoinable, check_hashjoinable, check_memoizable","count":4},{"name":"tested-by","value":"check_nested_generated_walker, check_and_push_window_quals, check_and_push_window_quals, convert_testexpr_mutator, check_ungrouped_columns_walker, check_new_partition_bound, check_new_partition_bound,","count":4},{"name":"tested-by","value":"check_nested_generated_walker, check_nested_generated_walker, check_simple_rowfilter_expr_walker, check_agglevels_and_constraints, check_agglevels_and_constraints, check_agg_arguments, check_agg_argum","count":4},{"name":"tested-by","value":"check_network_callback","count":4},{"name":"tested-by","value":"check_new_cluster_logical_replication_slots","count":4},{"name":"tested-by","value":"check_null_keys, check_attrmap_match, check_amproc_signature, _bt_check_unique, _bt_check_compare, _bt_check_rowcompare, _bt_check_rowcompare, spgInnerTest, spgInnerTest, spgInnerTest, check_wal_consi","count":4},{"name":"tested-by","value":"check_null_keys, check_attrmap_match, check_attrmap_match, check_attrmap_match, check_attrmap_match, check_hash_func_signature, check_hash_func_signature, test_lockmode_for_conflict, test_lockmode_for","count":4},{"name":"tested-by","value":"check_null_keys, check_attrmap_match, check_attrmap_match, check_attrmap_match, check_hash_func_signature, check_hash_func_signature, check_hash_func_signature, check_hash_func_signature, check_hash_f","count":4},{"name":"tested-by","value":"check_null_keys, check_attrmap_match, heap_get_latest_tid, check_amproc_signature, check_amproc_signature, _bt_check_unique, _bt_check_unique, _bt_check_compare, _bt_check_rowcompare, _bt_check_rowcom","count":4},{"name":"tested-by","value":"check_null_keys, check_null_keys, check_attrmap_match, check_attrmap_match, check_attrmap_match, check_hash_func_signature, check_hash_func_signature, check_hash_func_signature, check_hash_func_signat","count":4},{"name":"tested-by","value":"check_null_keys, check_null_keys, check_null_keys, check_hash_func_signature, check_hash_func_signature, heap_get_latest_tid, heap_get_latest_tid, heap_get_latest_tid, heap_get_latest_tid, test_lockmo","count":4},{"name":"tested-by","value":"check_null_keys, check_null_keys, check_null_keys, check_null_keys, check_null_keys, check_null_keys, check_attrmap_match, check_attrmap_match, check_attrmap_match, check_attrmap_match, check_attrmap_","count":4},{"name":"tested-by","value":"check_null_keys, check_null_keys, check_null_keys, check_null_keys, check_null_keys, check_null_keys, check_attrmap_match, check_attrmap_match, check_attrmap_match, check_attrmap_match, check_hash_fun","count":4},{"name":"tested-by","value":"check_null_keys, check_null_keys, check_null_keys, heap_get_latest_tid, heap_get_latest_tid, heap_get_latest_tid, heap_get_latest_tid, heap_get_latest_tid, index_delete_check_htid, _bt_check_unique, _","count":4},{"name":"tested-by","value":"check_object_ownership, check_object_ownership, check_object_ownership","count":4},{"name":"tested-by","value":"check_object_ownership, check_object_ownership, check_object_ownership, check_object_ownership, check_object_ownership, check_object_ownership, check_object_ownership, check_object_ownership, check_ob","count":4},{"name":"tested-by","value":"check_object_ownership, check_object_ownership, check_object_ownership, check_sql_fn_retval, check_sql_fn_retval, check_and_push_window_quals, check_and_push_window_quals, check_mergejoinable, check_h","count":4},{"name":"tested-by","value":"check_object_ownership, check_role_membership_authorization","count":4},{"name":"tested-by","value":"check_output_expressions, check_mergejoinable, check_hashjoinable","count":4},{"name":"tested-by","value":"check_output_expressions, check_output_expressions, check_output_expressions","count":4},{"name":"tested-by","value":"check_primary_slot_name","count":4},{"name":"tested-by","value":"check_primary_slot_name, check_recovery_target, check_recovery_target, check_recovery_target_lsn, check_recovery_target_time, check_recovery_target_time, check_recovery_target_time, check_recovery_tar","count":4},{"name":"tested-by","value":"check_publication_add_schema, check_publication_add_schema, check_publications_origin, check_default_text_search_config","count":4},{"name":"tested-by","value":"check_publications, check_index_predicates","count":4},{"name":"tested-by","value":"check_publications, check_publications, check_publications_origin, check_publications_origin","count":4},{"name":"tested-by","value":"check_publications, check_publications, check_publications_origin, check_temp_tablespaces, check_sql_fn_retval, check_sql_fn_retval, check_and_push_window_quals, check_mergejoinable, check_hashjoinabl","count":4},{"name":"tested-by","value":"check_publications, check_publications_origin, check_exclusion_or_unique_constraint, check_default_partition_contents","count":4},{"name":"tested-by","value":"check_publications, check_publications_origin, check_sql_fn_retval","count":4},{"name":"tested-by","value":"check_publications, check_publications_origin, convert_and_check_filename","count":4},{"name":"tested-by","value":"check_publications_origin, add_with_check_options, add_with_check_options","count":4},{"name":"tested-by","value":"check_publisher, check_for_data_types_usage, check_exec","count":4},{"name":"tested-by","value":"check_publisher, check_publisher, check_publisher, check_publisher, check_publisher, check_publisher, check_subscriber, check_subscriber, check_subscriber, check_subscriber, check_subscriber, check_an","count":4},{"name":"tested-by","value":"check_publisher, check_publisher, check_publisher, check_publisher, check_publisher, check_subscriber, check_subscriber, check_subscriber, check_new_cluster_logical_replication_slots, check_new_cluste","count":4},{"name":"tested-by","value":"check_publisher, check_publisher, check_publisher, check_subscriber, check_subscriber, check_subscriber, check_and_drop_existing_subscriptions","count":4},{"name":"tested-by","value":"check_publisher, check_subscriber, check_and_drop_existing_subscriptions, _check_database_version, check_for_data_types_usage, check_is_install_user, check_is_install_user, check_proper_datallowconn, ","count":4},{"name":"tested-by","value":"check_publisher, check_subscriber, check_and_drop_existing_subscriptions, check_loadable_libraries","count":4},{"name":"tested-by","value":"check_publisher, check_subscriber, check_and_drop_existing_subscriptions, check_loadable_libraries, ecpg_check_PQresult","count":4},{"name":"tested-by","value":"check_publisher, check_subscriber, check_and_drop_existing_subscriptions, ecpg_check_PQresult","count":4},{"name":"tested-by","value":"check_recovery_target_lsn","count":4},{"name":"tested-by","value":"check_recovery_target_timeline, check_is_install_user","count":4},{"name":"tested-by","value":"check_recovery_target_timeline, check_recovery_target_timeline, check_recovery_target_timeline, check_recovery_target_xid, check_recovery_target_xid, check_recovery_target_xid, check_same_host_or_net,","count":4},{"name":"tested-by","value":"check_redundant_nullability_qual","count":4},{"name":"tested-by","value":"check_relation_updatable, check_relation_updatable","count":4},{"name":"tested-by","value":"check_required_directory","count":4},{"name":"tested-by","value":"check_required_directory, check_pghost_envvar","count":4},{"name":"tested-by","value":"check_restricted_library_name, check_file_excluded","count":4},{"name":"tested-by","value":"check_role, check_can_set_role","count":4},{"name":"tested-by","value":"check_role, check_db, check_db, check_db, check_db, check_db, check_db","count":4},{"name":"tested-by","value":"check_role, check_db, check_ident_usermap, check_ident_usermap","count":4},{"name":"tested-by","value":"check_role_grantor, check_role_grantor","count":4},{"name":"tested-by","value":"check_role_grantor, check_role_grantor, check_role_for_policy, convert_and_check_filename","count":4},{"name":"tested-by","value":"check_rolespec_name","count":4},{"name":"tested-by","value":"check_root, check_input, check_input, check_ok, check_ok, check_locale_name, check_locale_name, check_locale_name, check_locale_name, check_authmethod_valid, check_need_password, check_data_directory,","count":4},{"name":"tested-by","value":"check_simple_rowfilter_expr_walker, check_agg_arguments_walker, check_srf_call_placement","count":4},{"name":"tested-by","value":"check_simple_rowfilter_expr_walker, check_sql_fn_retval, check_sql_fn_retval, check_functions_in_node, check_mergejoinable, check_hashjoinable, check_memoizable, check_memoizable, recheck_cast_functio","count":4},{"name":"tested-by","value":"check_single_dir, check_single_dir, check_bin_dir, check_bin_dir, check_ok","count":4},{"name":"tested-by","value":"check_slru_buffers, check_new_partition_bound, check_new_partition_bound, check_new_partition_bound, check_new_partition_bound, check_log_duration, test_config_settings","count":4},{"name":"tested-by","value":"check_slru_buffers, check_slru_buffers","count":4},{"name":"tested-by","value":"check_spi_usage_allowed, check_spi_usage_allowed","count":4},{"name":"tested-by","value":"check_sql_fn_retval, check_sql_fn_retval","count":4},{"name":"tested-by","value":"check_sql_fn_retval, check_sql_fn_retval, add_with_check_options","count":4},{"name":"tested-by","value":"check_sql_fn_retval, check_sql_fn_retval, check_sql_fn_retval","count":4},{"name":"tested-by","value":"check_sql_fn_retval, check_sql_fn_retval, check_sql_fn_retval, check_index_predicates, check_index_predicates, add_with_check_options, add_with_check_options","count":4},{"name":"tested-by","value":"check_ssl_key_file_permissions, check_input","count":4},{"name":"tested-by","value":"check_ssl_key_file_permissions, check_input, check_data_directory, check_data_directory, check_input_dir_permissions, check_for_new_tablespace_dir, check_single_dir, check_bin_dir","count":4},{"name":"tested-by","value":"check_synchronized_standby_slots","count":4},{"name":"tested-by","value":"check_timezone, check_new_partition_bound, check_synchronized_standby_slots, check_synchronized_standby_slots","count":4},{"name":"tested-by","value":"check_timezone, test_timing, test_timing, test_timing, test_timing, test_timing, test_timing, test_timing, test_timing, test_timing","count":4},{"name":"tested-by","value":"check_timezone_abbreviations","count":4},{"name":"tested-by","value":"check_transaction_read_only, check_transaction_isolation, check_transaction_deferrable","count":4},{"name":"tested-by","value":"check_transaction_read_only, check_transaction_isolation, replorigin_check_prerequisites","count":4},{"name":"tested-by","value":"check_uescapechar, check_uescapechar","count":4},{"name":"tested-by","value":"check_unicode_value","count":4},{"name":"tested-by","value":"check_valid_extension_name, check_valid_version_name, check_ident_usermap, check_file_excluded, check_file_excluded, check_file_excluded","count":4},{"name":"tested-by","value":"check_wal_buffers","count":4},{"name":"tested-by","value":"check_wal_consistency_checking, check_recovery_target_lsn, check_recovery_target_timeline, check_recovery_target_xid, check_temp_tablespaces, check_createrole_self_grant, check_datestyle, check_datest","count":4},{"name":"tested-by","value":"check_wal_consistency_checking, check_search_path, check_temp_tablespaces, check_createrole_self_grant, check_datestyle, check_restrict_nonsystem_relation_kind, check_log_destination, plpgsql_extra_ch","count":4},{"name":"tested-by","value":"check_wal_consistency_checking, check_temp_tablespaces, check_ident_usermap, check_ident_usermap, recheck_cast_function_args, check_synchronous_standby_names, check_circularity, check_domain_for_new_f","count":4},{"name":"tested-by","value":"check_wal_consistency_checking, check_wal_consistency_checking","count":4},{"name":"tested-by","value":"check_wal_consistency_checking, check_wal_consistency_checking, check_wal_consistency_checking","count":4},{"name":"tested-by","value":"check_wal_consistency_checking, check_wal_consistency_checking, check_wal_consistency_checking, check_search_path, check_search_path, check_temp_tablespaces, check_temp_tablespaces, check_createrole_s","count":4},{"name":"tested-by","value":"double_to_shortest_decimal_bufn, float_to_shortest_decimal_bufn","count":4},{"name":"tested-by","value":"ecpg_check_PQresult, ecpg_check_PQresult, ecpg_check_PQresult","count":4},{"name":"tested-by","value":"ecpg_check_PQresult, ecpg_check_PQresult, ecpg_check_PQresult, ecpg_check_PQresult","count":4},{"name":"tested-by","value":"exec_check_rw_parameter","count":4},{"name":"tested-by","value":"float_to_shortest_decimal","count":4},{"name":"tested-by","value":"get_btree_test_op","count":4},{"name":"tested-by","value":"hash_agg_check_limits","count":4},{"name":"tested-by","value":"hash_agg_check_limits, hash_agg_check_limits","count":4},{"name":"tested-by","value":"heap_get_latest_tid, heap_get_latest_tid, _bt_check_unique, _bt_check_compare, _bt_check_compare, _bt_check_rowcompare, _bt_check_rowcompare, _bt_check_natts, restrict_and_check_grant, restrict_and_ch","count":4},{"name":"tested-by","value":"heap_get_latest_tid, heap_get_latest_tid, check_amproc_signature, _bt_check_unique, _bt_check_unique, _bt_check_unique, _bt_check_rowcompare, _bt_check_natts, _bt_check_natts, _bt_check_natts, _bt_che","count":4},{"name":"tested-by","value":"heap_get_latest_tid, heap_get_latest_tid, heap_get_latest_tid, heap_get_latest_tid, heap_get_latest_tid","count":4},{"name":"tested-by","value":"heap_get_latest_tid, heap_get_latest_tid, test_lockmode_for_conflict, test_lockmode_for_conflict, check_amproc_signature, _bt_check_unique, _bt_check_unique, _bt_check_unique, _bt_check_unique, _bt_ch","count":4},{"name":"tested-by","value":"heap_get_latest_tid, index_delete_check_htid, _bt_check_natts, _bt_check_third_page","count":4},{"name":"tested-by","value":"heap_get_latest_tid, index_delete_check_htid, index_delete_check_htid, index_delete_check_htid, _bt_check_third_page","count":4},{"name":"tested-by","value":"heap_get_latest_tid, test_lockmode_for_conflict, check_exclusion_or_unique_constraint","count":4},{"name":"tested-by","value":"heap_get_latest_tid, test_lockmode_for_conflict, index_delete_check_htid, check_amproc_signature, _bt_check_compare, _bt_check_rowcompare, _bt_check_rowcompare, _bt_check_natts, spgLeafTest, check_wal","count":4},{"name":"tested-by","value":"heap_truncate_check_FKs","count":4},{"name":"tested-by","value":"heap_truncate_check_FKs, check_functional_grouping","count":4},{"name":"tested-by","value":"heap_truncate_check_FKs, check_sql_fn_retval, check_sql_fn_retval, check_ident_usermap, check_ident_usermap, check_index_predicates, check_default_partition_contents","count":4},{"name":"tested-by","value":"heap_truncate_check_FKs, heap_truncate_check_FKs","count":4},{"name":"tested-by","value":"heap_truncate_check_FKs, heap_truncate_check_FKs, check_publications_origin, check_new_partition_bound, check_new_partition_bound, check_new_partition_bound, check_new_partition_bound, check_new_parti","count":4},{"name":"tested-by","value":"index_check_primary_key","count":4},{"name":"tested-by","value":"jsonb_9_4_check_applicable","count":4},{"name":"tested-by","value":"lazy_check_wraparound_failsafe, _bt_check_unique, _bt_check_unique, check_wal_consistency_checking, check_recovery_target_time, check_recovery_target_time, check_recovery_target_time, check_publicatio","count":4},{"name":"tested-by","value":"lazy_check_wraparound_failsafe, lazy_check_wraparound_failsafe","count":4},{"name":"tested-by","value":"lazy_check_wraparound_failsafe, lazy_check_wraparound_failsafe, check_wal_consistency_checking, heap_truncate_check_FKs, heap_truncate_check_FKs, heap_truncate_check_FKs, heap_truncate_check_FKs, chec","count":4},{"name":"tested-by","value":"libpqrcv_check_conninfo","count":4},{"name":"tested-by","value":"libpqrcv_check_conninfo, check_and_drop_existing_subscriptions","count":4},{"name":"tested-by","value":"libpqrcv_check_conninfo, libpqrcv_check_conninfo, check_pghost_envvar","count":4},{"name":"tested-by","value":"object_aclcheck_ext","count":4},{"name":"tested-by","value":"pg_attribute_aclcheck_all_ext, check_circularity","count":4},{"name":"tested-by","value":"pg_attribute_aclcheck_all_ext, index_check_primary_key, check_for_column_name_collision","count":4},{"name":"tested-by","value":"pg_attribute_aclcheck_ext","count":4},{"name":"tested-by","value":"pg_class_aclcheck_ext","count":4},{"name":"tested-by","value":"pg_isolation_test_session_is_blocked, pg_isolation_test_session_is_blocked","count":4},{"name":"tested-by","value":"pg_isolation_test_session_is_blocked, pg_isolation_test_session_is_blocked, pg_isolation_test_session_is_blocked, pg_isolation_test_session_is_blocked, pg_isolation_test_session_is_blocked","count":4},{"name":"tested-by","value":"pg_largeobject_aclcheck_snapshot","count":4},{"name":"tested-by","value":"pq_check_connection, libpqrcv_check_conninfo, check_for_freed_segments_locked","count":4},{"name":"tested-by","value":"pq_check_connection, pq_check_connection","count":4},{"name":"tested-by","value":"r_check_category_2","count":4},{"name":"tested-by","value":"r_check_vowel_harmony, r_check_vowel_harmony, r_check_vowel_harmony","count":4},{"name":"tested-by","value":"r_check_vowel_harmony, r_check_vowel_harmony, r_check_vowel_harmony, r_check_vowel_harmony, r_check_vowel_harmony, r_check_vowel_harmony, r_check_vowel_harmony, r_check_vowel_harmony, r_check_vowel_ha","count":4},{"name":"tested-by","value":"restrict_and_check_grant, r_check_category_2, r_check_category_2, check_circularity, check_circularity, check_circularity, check_circularity, check_circularity, check_weight, check_replace_text_has_es","count":4},{"name":"tested-by","value":"spgInnerTest, check_exclusion_or_unique_constraint","count":4},{"name":"tested-by","value":"spgLeafTest, spgInnerTest","count":4},{"name":"tested-by","value":"table_recheck_autovac, json_unique_check_key","count":4},{"name":"tested-by","value":"table_tuple_get_latest_tid","count":4},{"name":"tested-by","value":"table_tuple_get_latest_tid, table_tuple_get_latest_tid, check_publications, check_publications_origin, call_bool_check_hook, call_int_check_hook, call_real_check_hook, call_string_check_hook, call_enu","count":4},{"name":"tested-by","value":"test_config_settings, test_config_settings, test_config_settings, test_config_settings, test_specific_config_settings, check_ok, check_ok, check_ok, test_sync, test_sync, test_sync, test_sync, test_sy","count":4},{"name":"tested-by","value":"test_indoption","count":4},{"name":"tested-by","value":"test_lockmode_for_conflict, test_lockmode_for_conflict","count":4},{"name":"tested-by","value":"test_lockmode_for_conflict, test_lockmode_for_conflict, test_lockmode_for_conflict, test_lockmode_for_conflict","count":4},{"name":"tested-by","value":"test_open, test_sync, test_file_descriptor_sync, test_file_descriptor_sync","count":4},{"name":"tested-by","value":"test_open, test_sync, test_sync, test_file_descriptor_sync, test_file_descriptor_sync, test_file_descriptor_sync, test_file_descriptor_sync, test_non_sync, win32_check_directory_write_permissions","count":4},{"name":"tested-by","value":"test_specific_config_settings, check_for_data_types_usage, check_for_incompatible_polymorphics","count":4},{"name":"tested-by","value":"test_specific_config_settings, check_for_incompatible_polymorphics","count":4},{"name":"tested-by","value":"test_specific_config_settings, test_specific_config_settings, check_and_drop_existing_subscriptions, check_for_data_types_usage","count":4},{"name":"tested-by","value":"test_strlower","count":4},{"name":"tested-by","value":"test_strlower, test_strlower, test_strlower","count":4},{"name":"tested-by","value":"test_sync, test_sync, test_sync, test_sync, test_file_descriptor_sync, test_file_descriptor_sync, test_file_descriptor_sync, test_file_descriptor_sync, test_non_sync, test_non_sync","count":4},{"name":"tested-by","value":"test_timing","count":4},{"name":"tested-by","value":"test_timing, test_timing, test_timing, test_timing","count":4},{"name":"tested-by","value":"transformBooleanTest","count":4},{"name":"tested-by","value":"transformBooleanTest, make_nulltest_from_distinct","count":4},{"name":"tested-by","value":"win32_check_directory_write_permissions, check_file_clone, check_file_clone, check_copy_file_range, check_copy_file_range, check_hard_link, check_hard_link","count":4},{"name":"tested-by","value":"win32_check_directory_write_permissions, win32_check_directory_write_permissions","count":4},{"name":"Feature","value":"Enable/Disable page checksums in an offline cluster","count":3},{"name":"Feature","value":"FETCH FIRST .. WITH TIES","count":3},{"name":"Feature","value":"Hashing support for FULL OUTER JOIN, LEFT OUTER JOIN and RIGHT OUTER JOIN","count":3},{"name":"Feature","value":"Materialized views with concurrent refresh","count":3},{"name":"Feature","value":"Multi-core scalability for read-only workloads","count":3},{"name":"Feature","value":"Radix tree memory structure for vacuum","count":3},{"name":"Feature","value":"SQL/JSON JSON_TABLE","count":3},{"name":"Feature","value":"SQL/JSON constructors","count":3},{"name":"Feature","value":"Savepoints","count":3},{"name":"Feature","value":"ltree","count":3},{"name":"Feature","value":"pg_trgm regular expressions indexing","count":3},{"name":"api-example","value":"Acl * aclcopy(const Acl *orig_acl) { Acl\t\t   *result_acl; result_acl = allocacl(ACL_NUM(orig_acl)); memcpy(ACL_DAT(result_acl), ACL_DAT(orig_acl), ACL_NUM(orig_acl) * sizeof(AclItem)); return result_a...","count":3},{"name":"api-example","value":"Acl * make_empty_acl(void) { return allocacl(0); }","count":3},{"name":"api-example","value":"AclResult pg_class_aclcheck(Oid table_oid, Oid roleid, AclMode mode) { return pg_class_aclcheck_ext(table_oid, roleid, mode, NULL); }","count":3},{"name":"api-example","value":"AppendState * ExecInitAppend(Append *node, EState *estate, int eflags) { AppendState *appendstate = makeNode(AppendState); PlanState **appendplanstates; Bitmapset  *validsubplans; Bitmapset  *asyncpla...","count":3},{"name":"api-example","value":"ArrayType * strlist_to_textarray(List *list) { ArrayType  *arr; Datum\t   *datums; bool\t   *nulls; int\t\t\tj = 0; ListCell   *cell; MemoryContext memcxt; MemoryContext oldcxt; int\t\t\tlb[1]; memcxt = Alloc...","count":3},{"name":"api-example","value":"AttrMap * build_attrmap_by_name(TupleDesc indesc, TupleDesc outdesc, bool missing_ok) { AttrMap    *attrMap; int\t\t\toutnatts; int\t\t\tinnatts; int\t\t\ti; int\t\t\tnextindesc = -1; outnatts = outdesc->natts; i...","count":3},{"name":"api-example","value":"AttrMap * build_attrmap_by_name_if_req(TupleDesc indesc, TupleDesc outdesc, bool missing_ok) { AttrMap    *attrMap; attrMap = build_attrmap_by_name(indesc, outdesc, missing_ok); if (check_attrmap_matc...","count":3},{"name":"api-example","value":"AttrNumber ExecFindJunkAttribute(JunkFilter *junkfilter, const char *attrName) { return ExecFindJunkAttributeInTlist(junkfilter->jf_targetList, attrName); }","count":3},{"name":"api-example","value":"BOOL AddUserToTokenDacl(HANDLE hToken) { int\t\t\ti; ACL_SIZE_INFORMATION asi; ACCESS_ALLOWED_ACE *pace; DWORD\t\tdwNewAclSize; DWORD\t\tdwSize = 0; DWORD\t\tdwTokenInfoLength = 0; PACL\t\tpacl = NULL; PTOKEN_US...","count":3},{"name":"api-example","value":"BitmapIndexScanState * ExecInitBitmapIndexScan(BitmapIndexScan *node, EState *estate, int eflags) { BitmapIndexScanState *indexstate; LOCKMODE\tlockmode; Assert(!(eflags & (EXEC_FLAG_BACKWARD | EXEC_FL...","count":3},{"name":"api-example","value":"Bitmapset * bms_copy(const Bitmapset *a) { Bitmapset  *result; size_t\t\tsize; Assert(bms_is_valid_set(a)); if (a == NULL) return NULL; size = BITMAPSET_SIZE(a->nwords); result = (Bitmapset *) palloc(si...","count":3},{"name":"api-example","value":"BlockNumber RecordAndGetPageWithFreeSpace(Relation rel, BlockNumber oldPage, Size oldSpaceAvail, Size spaceNeeded) { int\t\t\told_cat = fsm_space_avail_to_cat(oldSpaceAvail); int\t\t\tsearch_cat = fsm_space...","count":3},{"name":"api-example","value":"BlockNumber _hash_freeovflpage(Relation rel, Buffer bucketbuf, Buffer ovflbuf, Buffer wbuf, IndexTuple *itups, OffsetNumber *itup_offsets, Size *tups_size, uint16 nitups, BufferAccessStrategy bstrateg...","count":3},{"name":"api-example","value":"BlockNumber createPostingTree(Relation index, ItemPointerData *items, uint32 nitems, GinStatsData *buildStats, Buffer entrybuffer) { BlockNumber blkno; Buffer\t\tbuffer; Page\t\ttmppage; Page\t\tpage; Point...","count":3},{"name":"api-example","value":"BlockRefTableReader * CreateBlockRefTableReader(io_callback_fn read_callback, void *read_callback_arg, char *error_filename, report_error_fn error_callback, void *error_callback_arg) { BlockRefTableRe...","count":3},{"name":"api-example","value":"BrinTuple * brinGetTupleForHeapBlock(BrinRevmap *revmap, BlockNumber heapBlk, Buffer *buf, OffsetNumber *off, Size *size, int mode) { Relation\tidxRel = revmap->rm_irel; BlockNumber mapBlk; RevmapConte...","count":3},{"name":"api-example","value":"Buffer GinNewBuffer(Relation index) { Buffer\t\tbuffer; for (;;) { BlockNumber blkno = GetFreeIndexPage(index); if (blkno == InvalidBlockNumber) break; buffer = ReadBuffer(index, blkno); * We have to gu...","count":3},{"name":"api-example","value":"Buffer _bt_getroot(Relation rel, Relation heaprel, int access) { Buffer\t\tmetabuf; Buffer\t\trootbuf; Page\t\trootpage; BTPageOpaque rootopaque; BlockNumber rootblkno; uint32\t\trootlevel; BTMetaPageData *me...","count":3},{"name":"api-example","value":"Buffer _bt_getstackbuf(Relation rel, Relation heaprel, BTStack stack, BlockNumber child) { BlockNumber blkno; OffsetNumber start; blkno = stack->bts_blkno; start = stack->bts_offset; for (;;) { Buffer...","count":3},{"name":"api-example","value":"Buffer _hash_addovflpage(Relation rel, Buffer metabuf, Buffer buf, bool retain_pin) { Buffer\t\tovflbuf; Page\t\tpage; Page\t\tovflpage; HashPageOpaque pageopaque; HashPageOpaque ovflopaque; HashMetaPage me...","count":3},{"name":"api-example","value":"Buffer _hash_getbuf_with_condlock_cleanup(Relation rel, BlockNumber blkno, int flags) { Buffer\t\tbuf; if (blkno == P_NEW) elog(ERROR, \"hash AM does not use P_NEW\"); buf = ReadBuffer(rel, blkno); if (!C...","count":3},{"name":"api-example","value":"CastInfo * getCasts(Archive *fout, int *numCasts) { PGresult   *res; int\t\t\tntups; int\t\t\ti; PQExpBuffer query = createPQExpBuffer(); CastInfo   *castinfo; int\t\t\ti_tableoid; int\t\t\ti_oid; int\t\t\ti_castsou...","count":3},{"name":"api-example","value":"CatalogIndexState CatalogOpenIndexes(Relation heapRel) { ResultRelInfo *resultRelInfo; resultRelInfo = makeNode(ResultRelInfo); resultRelInfo->ri_RangeTableIndex = 0;\t/* dummy */ resultRelInfo->ri_Rel...","count":3},{"name":"api-example","value":"CommandTag CreateCommandTag(Node *parsetree) { CommandTag\ttag; switch (nodeTag(parsetree)) { case T_RawStmt: tag = CreateCommandTag(((RawStmt *) parsetree)->stmt); break; case T_InsertStmt: tag = CMDT...","count":3},{"name":"api-example","value":"CompressFileHandle * InitDiscoverCompressFileHandle(const char *path, const char *mode) { CompressFileHandle *CFH = NULL; struct stat st; char\t   *fname; pg_compress_specification compression_spec = {...","count":3},{"name":"api-example","value":"CteScanState * ExecInitCteScan(CteScan *node, EState *estate, int eflags) { CteScanState *scanstate; ParamExecData *prmdata; Assert(!(eflags & EXEC_FLAG_MARK)); * For the moment we have to force the t...","count":3},{"name":"api-example","value":"DEFINE_ENUM_FLAG_OPERATORS (AR_STATE)","count":3},{"name":"api-example","value":"DEFINE_ENUM_FLAG_OPERATORS (ORIENTATION_PREFERENCE)","count":3},{"name":"api-example","value":"DEFINE_ENUM_FLAG_OPERATORS(FILE_WRITE_FLAGS)","count":3},{"name":"api-example","value":"DEFINE_ENUM_FLAG_OPERATORS(JOB_OBJECT_IO_RATE_CONTROL_FLAGS)","count":3},{"name":"api-example","value":"DEFINE_ENUM_FLAG_OPERATORS(JOB_OBJECT_NET_RATE_CONTROL_FLAGS)","count":3},{"name":"api-example","value":"DEFINE_ENUM_FLAG_OPERATORS(MACHINE_ATTRIBUTES)","count":3},{"name":"api-example","value":"DWORD pgwin32_get_file_type(HANDLE hFile) { DWORD\t\tfileType = FILE_TYPE_UNKNOWN; DWORD\t\tlastError; errno = 0; * When stdin, stdout, and stderr aren't associated with a stream the * special value -2 is...","count":3},{"name":"api-example","value":"Datum ExecMakeFunctionResultSet(SetExprState *fcache, ExprContext *econtext, MemoryContext argContext, bool *isNull, ExprDoneCond *isDone) { List\t   *arguments; Datum\t\tresult; FunctionCallInfo fcinfo;...","count":3},{"name":"api-example","value":"Datum PLy_exec_function(FunctionCallInfo fcinfo, PLyProcedure *proc) { bool\t\tis_setof = proc->is_setof; Datum\t\trv; PyObject   *volatile plargs = NULL; PyObject   *volatile plrv = NULL; FuncCallContext...","count":3},{"name":"api-example","value":"Datum RI_FKey_check_ins(PG_FUNCTION_ARGS) { ri_CheckTrigger(fcinfo, \"RI_FKey_check_ins\", RI_TRIGTYPE_INSERT); return RI_FKey_check((TriggerData *) fcinfo->context); }","count":3},{"name":"api-example","value":"Datum RI_FKey_check_upd(PG_FUNCTION_ARGS) { ri_CheckTrigger(fcinfo, \"RI_FKey_check_upd\", RI_TRIGTYPE_UPDATE); return RI_FKey_check((TriggerData *) fcinfo->context); }","count":3},{"name":"api-example","value":"Datum aclitemin(PG_FUNCTION_ARGS) { const char *s = PG_GETARG_CSTRING(0); Node\t   *escontext = fcinfo->context; AclItem    *aip; aip = (AclItem *) palloc(sizeof(AclItem)); s = aclparse(s, aip, esconte...","count":3},{"name":"api-example","value":"Datum amvalidate(PG_FUNCTION_ARGS) { Oid\t\t\topclassoid = PG_GETARG_OID(0); bool\t\tresult; HeapTuple\tclasstup; Form_pg_opclass classform; Oid\t\t\tamoid; IndexAmRoutine *amroutine; classtup = SearchSysCache...","count":3},{"name":"api-example","value":"Datum array_agg_array_transfn(PG_FUNCTION_ARGS) { Oid\t\t\targ1_typeid = get_fn_expr_argtype(fcinfo->flinfo, 1); MemoryContext aggcontext; ArrayBuildStateArr *state; if (arg1_typeid == InvalidOid) erepor...","count":3},{"name":"api-example","value":"Datum array_agg_finalfn(PG_FUNCTION_ARGS) { Datum\t\tresult; ArrayBuildState *state; int\t\t\tdims[1]; int\t\t\tlbs[1]; Assert(AggCheckCallContext(fcinfo, NULL)); state = PG_ARGISNULL(0) ? NULL : (ArrayBuildS...","count":3},{"name":"api-example","value":"Datum array_agg_transfn(PG_FUNCTION_ARGS) { Oid\t\t\targ1_typeid = get_fn_expr_argtype(fcinfo->flinfo, 1); MemoryContext aggcontext; ArrayBuildState *state; Datum\t\telem; if (arg1_typeid == InvalidOid) er...","count":3},{"name":"api-example","value":"Datum array_eq(PG_FUNCTION_ARGS) { LOCAL_FCINFO(locfcinfo, 2); AnyArrayType *array1 = PG_GETARG_ANY_ARRAY_P(0); AnyArrayType *array2 = PG_GETARG_ANY_ARRAY_P(1); Oid\t\t\tcollation = PG_GET_COLLATION(); i...","count":3},{"name":"api-example","value":"Datum array_get_slice(Datum arraydatum, int nSubscripts, int *upperIndx, int *lowerIndx, bool *upperProvided, bool *lowerProvided, int arraytyplen, int elmlen, bool elmbyval, char elmalign) { ArrayTyp...","count":3},{"name":"api-example","value":"Datum array_in(PG_FUNCTION_ARGS) { char\t   *string = PG_GETARG_CSTRING(0);\t/* external form */ Oid\t\t\telement_type = PG_GETARG_OID(1);\t/* type of an array * element */ int32\t\ttypmod = PG_GETARG_INT32(2...","count":3},{"name":"api-example","value":"Datum array_lt(PG_FUNCTION_ARGS) { PG_RETURN_BOOL(array_cmp(fcinfo) < 0); }","count":3},{"name":"api-example","value":"Datum array_prepend(PG_FUNCTION_ARGS) { ExpandedArrayHeader *eah; Datum\t\tnewelem; bool\t\tisNull; Datum\t\tresult; int\t\t   *lb; int\t\t\tindx; int\t\t\tlb0; ArrayMetaState *my_extra; isNull = PG_ARGISNULL(0); i...","count":3},{"name":"api-example","value":"Datum be_lo_lseek(PG_FUNCTION_ARGS) { int32\t\tfd = PG_GETARG_INT32(0); int32\t\toffset = PG_GETARG_INT32(1); int32\t\twhence = PG_GETARG_INT32(2); int64\t\tstatus; if (fd < 0 || fd >= cookies_size || cookies...","count":3},{"name":"api-example","value":"Datum be_loread(PG_FUNCTION_ARGS) { int32\t\tfd = PG_GETARG_INT32(0); int32\t\tlen = PG_GETARG_INT32(1); bytea\t   *retval; int\t\t\ttotalread; if (len < 0) len = 0; retval = (bytea *) palloc(VARHDRSZ + len);...","count":3},{"name":"api-example","value":"Datum be_lowrite(PG_FUNCTION_ARGS) { int32\t\tfd = PG_GETARG_INT32(0); bytea\t   *wbuf = PG_GETARG_BYTEA_PP(1); int\t\t\tbytestowrite; int\t\t\ttotalwritten; PreventCommandIfReadOnly(\"lowrite()\"); bytestowrite...","count":3},{"name":"api-example","value":"Datum big5_to_utf8(PG_FUNCTION_ARGS) { unsigned char *src = (unsigned char *) PG_GETARG_CSTRING(2); unsigned char *dest = (unsigned char *) PG_GETARG_CSTRING(3); int\t\t\tlen = PG_GETARG_INT32(4); bool\t\t...","count":3},{"name":"api-example","value":"Datum binary_upgrade_set_next_pg_tablespace_oid(PG_FUNCTION_ARGS) { Oid\t\t\ttbspoid = PG_GETARG_OID(0); CHECK_IS_BINARY_UPGRADE; binary_upgrade_next_pg_tablespace_oid = tbspoid; PG_RETURN_VOID(); }","count":3},{"name":"api-example","value":"Datum biteq(PG_FUNCTION_ARGS) { VarBit\t   *arg1 = PG_GETARG_VARBIT_P(0); VarBit\t   *arg2 = PG_GETARG_VARBIT_P(1); bool\t\tresult; int\t\t\tbitlen1, bitlen2; bitlen1 = VARBITLEN(arg1); bitlen2 = VARBITLEN(a...","count":3},{"name":"api-example","value":"Datum box_diagonal(PG_FUNCTION_ARGS) { BOX\t\t   *box = PG_GETARG_BOX_P(0); LSEG\t   *result = (LSEG *) palloc(sizeof(LSEG)); statlseg_construct(result, &box->high, &box->low); PG_RETURN_LSEG_P(result); ...","count":3},{"name":"api-example","value":"Datum box_distance(PG_FUNCTION_ARGS) { BOX\t\t   *box1 = PG_GETARG_BOX_P(0); BOX\t\t   *box2 = PG_GETARG_BOX_P(1); Point\t\ta, b; box_cn(&a, box1); box_cn(&b, box2); PG_RETURN_FLOAT8(point_dt(&a, &b)); }","count":3},{"name":"api-example","value":"Datum box_lt(PG_FUNCTION_ARGS) { BOX\t\t   *box1 = PG_GETARG_BOX_P(0); BOX\t\t   *box2 = PG_GETARG_BOX_P(1); PG_RETURN_BOOL(FPlt(box_ar(box1), box_ar(box2))); }","count":3},{"name":"api-example","value":"Datum box_out(PG_FUNCTION_ARGS) { BOX\t\t   *box = PG_GETARG_BOX_P(0); PG_RETURN_CSTRING(path_encode(PATH_NONE, 2, &(box->high))); }","count":3},{"name":"api-example","value":"Datum box_overlap(PG_FUNCTION_ARGS) { BOX\t\t   *box1 = PG_GETARG_BOX_P(0); BOX\t\t   *box2 = PG_GETARG_BOX_P(1); PG_RETURN_BOOL(box_ov(box1, box2)); }","count":3},{"name":"api-example","value":"Datum box_same(PG_FUNCTION_ARGS) { BOX\t\t   *box1 = PG_GETARG_BOX_P(0); BOX\t\t   *box2 = PG_GETARG_BOX_P(1); PG_RETURN_BOOL(point_eq_point(&box1->high, &box2->high) && point_eq_point(&box1->low, &box2->...","count":3},{"name":"api-example","value":"Datum bpchar(PG_FUNCTION_ARGS) { BpChar\t   *source = PG_GETARG_BPCHAR_PP(0); int32\t\tmaxlen = PG_GETARG_INT32(1); bool\t\tisExplicit = PG_GETARG_BOOL(2); BpChar\t   *result; int32\t\tlen; char\t   *r; char\t ...","count":3},{"name":"api-example","value":"Datum bpchar_pattern_lt(PG_FUNCTION_ARGS) { BpChar\t   *arg1 = PG_GETARG_BPCHAR_PP(0); BpChar\t   *arg2 = PG_GETARG_BPCHAR_PP(1); int\t\t\tresult; result = internal_bpchar_pattern_compare(arg1, arg2); PG_F...","count":3},{"name":"api-example","value":"Datum bpcharin(PG_FUNCTION_ARGS) { char\t   *s = PG_GETARG_CSTRING(0); #ifdef NOT_USED Oid\t\t\ttypelem = PG_GETARG_OID(1); #endif int32\t\tatttypmod = PG_GETARG_INT32(2); BpChar\t   *result; result = bpchar...","count":3},{"name":"api-example","value":"Datum bpcharlen(PG_FUNCTION_ARGS) { BpChar\t   *arg = PG_GETARG_BPCHAR_PP(0); int\t\t\tlen; len = bcTruelen(arg); if (pg_database_encoding_max_length() != 1) len = pg_mbstrlen_with_len(VARDATA_ANY(arg), l...","count":3},{"name":"api-example","value":"Datum brin_bloom_opcinfo(PG_FUNCTION_ARGS) { BrinOpcInfo *result; * opaque->strategy_procinfos is initialized lazily; here it is set to * all-uninitialized by palloc0 which sets fn_oid to InvalidOid. ...","count":3},{"name":"api-example","value":"Datum brin_bloom_options(PG_FUNCTION_ARGS) { local_relopts *relopts = (local_relopts *) PG_GETARG_POINTER(0); init_local_reloptions(relopts, sizeof(BloomOptions)); add_local_real_reloption(relopts, \"n...","count":3},{"name":"api-example","value":"Datum brin_bloom_summary_send(PG_FUNCTION_ARGS) { return byteasend(fcinfo); }","count":3},{"name":"api-example","value":"Datum brin_bloom_union(PG_FUNCTION_ARGS) { int\t\t\ti; int\t\t\tnbytes; BrinValues *col_a = (BrinValues *) PG_GETARG_POINTER(1); BrinValues *col_b = (BrinValues *) PG_GETARG_POINTER(2); BloomFilter *filter_...","count":3},{"name":"api-example","value":"Datum brin_minmax_multi_add_value(PG_FUNCTION_ARGS) { BrinDesc   *bdesc = (BrinDesc *) PG_GETARG_POINTER(0); BrinValues *column = (BrinValues *) PG_GETARG_POINTER(1); Datum\t\tnewval = PG_GETARG_DATUM(2...","count":3},{"name":"api-example","value":"Datum brin_minmax_multi_distance_float8(PG_FUNCTION_ARGS) { double\t\ta1 = PG_GETARG_FLOAT8(0); double\t\ta2 = PG_GETARG_FLOAT8(1); if (isnan(a1) && isnan(a2)) PG_RETURN_FLOAT8(0.0); if (isnan(a1) || isna...","count":3},{"name":"api-example","value":"Datum btnamesortsupport(PG_FUNCTION_ARGS) { SortSupport ssup = (SortSupport) PG_GETARG_POINTER(0); Oid\t\t\tcollid = ssup->ssup_collation; MemoryContext oldcontext; oldcontext = MemoryContextSwitchTo(ssu...","count":3},{"name":"api-example","value":"Datum btrim(PG_FUNCTION_ARGS) { text\t   *string = PG_GETARG_TEXT_PP(0); text\t   *set = PG_GETARG_TEXT_PP(1); text\t   *ret; ret = dotrim(VARDATA_ANY(string), VARSIZE_ANY_EXHDR(string), VARDATA_ANY(set)...","count":3},{"name":"api-example","value":"Datum cash_mul_int8(PG_FUNCTION_ARGS) { Cash\t\tc = PG_GETARG_CASH(0); int64\t\ti = PG_GETARG_INT64(1); PG_RETURN_CASH(cash_mul_int64(c, i)); }","count":3},{"name":"api-example","value":"Datum cash_numeric(PG_FUNCTION_ARGS) { Cash\t\tmoney = PG_GETARG_CASH(0); Datum\t\tresult; int\t\t\tfpoint; struct lconv *lconvert = PGLC_localeconv(); fpoint = lconvert->frac_digits; if (fpoint < 0 || fpoin...","count":3},{"name":"api-example","value":"Datum cash_words(PG_FUNCTION_ARGS) { Cash\t\tvalue = PG_GETARG_CASH(0); uint64\t\tval; char\t\tbuf[256]; char\t   *p = buf; Cash\t\tm0; Cash\t\tm1; Cash\t\tm2; Cash\t\tm3; Cash\t\tm4; Cash\t\tm5; Cash\t\tm6; if (value < 0...","count":3},{"name":"api-example","value":"Datum charin(PG_FUNCTION_ARGS) { char\t   *ch = PG_GETARG_CSTRING(0); if (strlen(ch) == 4 && ch[0] == '\\\\' && ISOCTAL(ch[1]) && ISOCTAL(ch[2]) && ISOCTAL(ch[3])) PG_RETURN_CHAR((FROMOCTAL(ch[1]) << 6) ...","count":3},{"name":"api-example","value":"Datum charout(PG_FUNCTION_ARGS) { char\t\tch = PG_GETARG_CHAR(0); char\t   *result = (char *) palloc(5); if (IS_HIGHBIT_SET(ch)) { result[0] = '\\\\'; result[1] = TOOCTAL(((unsigned char) ch) >> 6); result...","count":3},{"name":"api-example","value":"Datum chr\t\t\t(PG_FUNCTION_ARGS) { int32\t\targ = PG_GETARG_INT32(0); uint32\t\tcvalue; text\t   *result; int\t\t\tencoding = GetDatabaseEncoding(); * Error out on arguments that make no sense or that we can't ...","count":3},{"name":"api-example","value":"Datum circle_eq(PG_FUNCTION_ARGS) { CIRCLE\t   *circle1 = PG_GETARG_CIRCLE_P(0); CIRCLE\t   *circle2 = PG_GETARG_CIRCLE_P(1); PG_RETURN_BOOL(FPeq(circle_ar(circle1), circle_ar(circle2))); }","count":3},{"name":"api-example","value":"Datum circle_in(PG_FUNCTION_ARGS) { char\t   *str = PG_GETARG_CSTRING(0); Node\t   *escontext = fcinfo->context; CIRCLE\t   *circle = (CIRCLE *) palloc(sizeof(CIRCLE)); char\t   *s, *cp; int\t\t\tdepth = 0; ...","count":3},{"name":"api-example","value":"Datum complex_abs_lt(PG_FUNCTION_ARGS) { Complex    *a = (Complex *) PG_GETARG_POINTER(0); Complex    *b = (Complex *) PG_GETARG_POINTER(1); PG_RETURN_BOOL(complex_abs_cmp_internal(a, b) < 0); }","count":3},{"name":"api-example","value":"Datum current_database(PG_FUNCTION_ARGS) { Name\t\tdb; db = (Name) palloc(NAMEDATALEN); namestrcpy(db, get_database_name(MyDatabaseId)); PG_RETURN_NAME(db); }","count":3},{"name":"api-example","value":"Datum date_eq_timestamp(PG_FUNCTION_ARGS) { DateADT\t\tdateVal = PG_GETARG_DATEADT(0); Timestamp\tdt2 = PG_GETARG_TIMESTAMP(1); PG_RETURN_BOOL(date_cmp_timestamp_internal(dateVal, dt2) == 0); }","count":3},{"name":"api-example","value":"Datum date_eq_timestamptz(PG_FUNCTION_ARGS) { DateADT\t\tdateVal = PG_GETARG_DATEADT(0); TimestampTz dt2 = PG_GETARG_TIMESTAMPTZ(1); PG_RETURN_BOOL(date_cmp_timestamptz_internal(dateVal, dt2) == 0); }","count":3},{"name":"api-example","value":"Datum date_timestamp(PG_FUNCTION_ARGS) { DateADT\t\tdateVal = PG_GETARG_DATEADT(0); Timestamp\tresult; result = date2timestamp(dateVal); PG_RETURN_TIMESTAMP(result); }","count":3},{"name":"api-example","value":"Datum dispell_init(PG_FUNCTION_ARGS) { List\t   *dictoptions = (List *) PG_GETARG_POINTER(0); DictISpell *d; bool\t\taffloaded = false, dictloaded = false, stoploaded = false; ListCell   *l; d = (DictISp...","count":3},{"name":"api-example","value":"Datum dist_pb(PG_FUNCTION_ARGS) { Point\t   *pt = PG_GETARG_POINT_P(0); BOX\t\t   *box = PG_GETARG_BOX_P(1); PG_RETURN_FLOAT8(box_closept_point(NULL, box, pt)); }","count":3},{"name":"api-example","value":"Datum dist_pl(PG_FUNCTION_ARGS) { Point\t   *pt = PG_GETARG_POINT_P(0); LINE\t   *line = PG_GETARG_LINE_P(1); PG_RETURN_FLOAT8(line_closept_point(NULL, line, pt)); }","count":3},{"name":"api-example","value":"Datum dist_ps(PG_FUNCTION_ARGS) { Point\t   *pt = PG_GETARG_POINT_P(0); LSEG\t   *lseg = PG_GETARG_LSEG_P(1); PG_RETURN_FLOAT8(lseg_closept_point(NULL, lseg, pt)); }","count":3},{"name":"api-example","value":"Datum dist_sb(PG_FUNCTION_ARGS) { LSEG\t   *lseg = PG_GETARG_LSEG_P(0); BOX\t\t   *box = PG_GETARG_BOX_P(1); PG_RETURN_FLOAT8(box_closept_lseg(NULL, box, lseg)); }","count":3},{"name":"api-example","value":"Datum dist_sl(PG_FUNCTION_ARGS) { LSEG\t   *lseg = PG_GETARG_LSEG_P(0); LINE\t   *line = PG_GETARG_LINE_P(1); PG_RETURN_FLOAT8(lseg_closept_line(NULL, lseg, line)); }","count":3},{"name":"api-example","value":"Datum dlog10(PG_FUNCTION_ARGS) { float8\t\targ1 = PG_GETARG_FLOAT8(0); float8\t\tresult; * Emit particular SQLSTATE error codes for log(). The SQL spec doesn't * define log(), but it does define ln(), so ...","count":3},{"name":"api-example","value":"Datum drandom(PG_FUNCTION_ARGS) { float8\t\tresult; initialize_prng(); result = pg_prng_double(&prng_state); PG_RETURN_FLOAT8(result); }","count":3},{"name":"api-example","value":"Datum dsin(PG_FUNCTION_ARGS) { float8\t\targ1 = PG_GETARG_FLOAT8(0); float8\t\tresult; if (isnan(arg1)) PG_RETURN_FLOAT8(get_float8_nan()); errno = 0; result = sin(arg1); if (errno != 0 || isinf(arg1)) er...","count":3},{"name":"api-example","value":"Datum dsnowball_lexize(PG_FUNCTION_ARGS) { DictSnowball *d = (DictSnowball *) PG_GETARG_POINTER(0); char\t   *in = (char *) PG_GETARG_POINTER(1); int32\t\tlen = PG_GETARG_INT32(2); char\t   *txt = lowerst...","count":3},{"name":"api-example","value":"Datum dtoi2(PG_FUNCTION_ARGS) { float8\t\tnum = PG_GETARG_FLOAT8(0); * Get rid of any fractional part in the input.  This is so we don't fail * on just-out-of-range values that would round into range.  ...","count":3},{"name":"api-example","value":"Datum enum_lt(PG_FUNCTION_ARGS) { Oid\t\t\ta = PG_GETARG_OID(0); Oid\t\t\tb = PG_GETARG_OID(1); PG_RETURN_BOOL(enum_cmp_internal(a, b, fcinfo) < 0); }","count":3},{"name":"api-example","value":"Datum enum_recv(PG_FUNCTION_ARGS) { StringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0); Oid\t\t\tenumtypoid = PG_GETARG_OID(1); Oid\t\t\tenumoid; HeapTuple\ttup; char\t   *name; int\t\t\tnbytes; name = pq_getmsg...","count":3},{"name":"api-example","value":"Datum enum_send(PG_FUNCTION_ARGS) { Oid\t\t\tenumval = PG_GETARG_OID(0); StringInfoData buf; HeapTuple\ttup; Form_pg_enum en; tup = SearchSysCache1(ENUMOID, ObjectIdGetDatum(enumval)); if (!HeapTupleIsVal...","count":3},{"name":"api-example","value":"Datum float4in(PG_FUNCTION_ARGS) { char\t   *num = PG_GETARG_CSTRING(0); PG_RETURN_FLOAT4(float4in_internal(num, NULL, \"real\", num, fcinfo->context)); }","count":3},{"name":"api-example","value":"Datum float4out(PG_FUNCTION_ARGS) { float4\t\tnum = PG_GETARG_FLOAT4(0); char\t   *ascii = (char *) palloc(32); int\t\t\tndig = FLT_DIG + extra_float_digits; if (extra_float_digits > 0) { float_to_shortest_...","count":3},{"name":"api-example","value":"Datum float8out(PG_FUNCTION_ARGS) { float8\t\tnum = PG_GETARG_FLOAT8(0); PG_RETURN_CSTRING(float8out_internal(num)); }","count":3},{"name":"api-example","value":"Datum float8recv(PG_FUNCTION_ARGS) { StringInfo\tbuf = (StringInfo) PG_GETARG_POINTER(0); PG_RETURN_FLOAT8(pq_getmsgfloat8(buf)); }","count":3},{"name":"api-example","value":"Datum float8send(PG_FUNCTION_ARGS) { float8\t\tnum = PG_GETARG_FLOAT8(0); StringInfoData buf; pq_begintypsend(&buf); pq_sendfloat8(&buf, num); PG_RETURN_BYTEA_P(pq_endtypsend(&buf)); }","count":3},{"name":"api-example","value":"Datum fmgr_sql(PG_FUNCTION_ARGS) { SQLFunctionCachePtr fcache; ErrorContextCallback sqlerrcontext; MemoryContext oldcontext; bool\t\trandomAccess; bool\t\tlazyEvalOK; bool\t\tis_first; bool\t\tpushed_snapshot...","count":3},{"name":"api-example","value":"Datum format_type(PG_FUNCTION_ARGS) { Oid\t\t\ttype_oid; int32\t\ttypemod; char\t   *result; bits16\t\tflags = FORMAT_TYPE_ALLOW_INVALID; if (PG_ARGISNULL(0)) PG_RETURN_NULL(); type_oid = PG_GETARG_OID(0); if...","count":3},{"name":"api-example","value":"Datum get_current_ts_config(PG_FUNCTION_ARGS) { PG_RETURN_OID(getTSCurrentConfig(true)); }","count":3},{"name":"api-example","value":"Datum getmissingattr(TupleDesc tupleDesc, int attnum, bool *isnull) { Form_pg_attribute att; Assert(attnum <= tupleDesc->natts); Assert(attnum > 0); att = TupleDescAttr(tupleDesc, attnum - 1); if (att...","count":3},{"name":"api-example","value":"Datum gin_extract_tsquery(PG_FUNCTION_ARGS) { TSQuery\t\tquery = PG_GETARG_TSQUERY(0); int32\t   *nentries = (int32 *) PG_GETARG_POINTER(1); bool\t  **ptr_partialmatch = (bool **) PG_GETARG_POINTER(3); Po...","count":3},{"name":"api-example","value":"Datum ginarrayextract_2args(PG_FUNCTION_ARGS) { if (PG_NARGS() < 3)\t\t\t/* should not happen */ elog(ERROR, \"ginarrayextract requires three arguments\"); return ginarrayextract(fcinfo); }","count":3},{"name":"api-example","value":"Datum gist_box_penalty(PG_FUNCTION_ARGS) { GISTENTRY  *origentry = (GISTENTRY *) PG_GETARG_POINTER(0); GISTENTRY  *newentry = (GISTENTRY *) PG_GETARG_POINTER(1); float\t   *result = (float *) PG_GETARG...","count":3},{"name":"api-example","value":"Datum gist_box_union(PG_FUNCTION_ARGS) { GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0); int\t\t   *sizep = (int *) PG_GETARG_POINTER(1); int\t\t\tnumranges, i; BOX\t\t   *cur, *pageuni...","count":3},{"name":"api-example","value":"Datum gist_point_compress(PG_FUNCTION_ARGS) { GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0); if (entry->leafkey)\t\t\t/* Point, actually */ { BOX\t\t   *box = palloc(sizeof(BOX)); Point\t   *point ...","count":3},{"name":"api-example","value":"Datum gtsquery_compress(PG_FUNCTION_ARGS) { GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0); GISTENTRY  *retval = entry; if (entry->leafkey) { TSQuerySign sign; retval = (GISTENTRY *) palloc(si...","count":3},{"name":"api-example","value":"Datum gtsquery_consistent(PG_FUNCTION_ARGS) { GISTENTRY  *entry = (GISTENTRY *) PG_GETARG_POINTER(0); TSQuery\t\tquery = PG_GETARG_TSQUERY(1); StrategyNumber strategy = (StrategyNumber) PG_GETARG_UINT16...","count":3},{"name":"api-example","value":"Datum has_any_column_privilege_name_name(PG_FUNCTION_ARGS) { Name\t\trolename = PG_GETARG_NAME(0); text\t   *tablename = PG_GETARG_TEXT_PP(1); text\t   *priv_type_text = PG_GETARG_TEXT_PP(2); Oid\t\t\troleid...","count":3},{"name":"api-example","value":"Datum has_database_privilege_name_name(PG_FUNCTION_ARGS) { Name\t\tusername = PG_GETARG_NAME(0); text\t   *databasename = PG_GETARG_TEXT_PP(1); text\t   *priv_type_text = PG_GETARG_TEXT_PP(2); Oid\t\t\trolei...","count":3},{"name":"api-example","value":"Datum has_foreign_data_wrapper_privilege_name_name(PG_FUNCTION_ARGS) { Name\t\tusername = PG_GETARG_NAME(0); text\t   *fdwname = PG_GETARG_TEXT_PP(1); text\t   *priv_type_text = PG_GETARG_TEXT_PP(2); Oid\t...","count":3},{"name":"api-example","value":"Datum has_function_privilege_name_name(PG_FUNCTION_ARGS) { Name\t\tusername = PG_GETARG_NAME(0); text\t   *functionname = PG_GETARG_TEXT_PP(1); text\t   *priv_type_text = PG_GETARG_TEXT_PP(2); Oid\t\t\trolei...","count":3},{"name":"api-example","value":"Datum has_language_privilege_name_name(PG_FUNCTION_ARGS) { Name\t\tusername = PG_GETARG_NAME(0); text\t   *languagename = PG_GETARG_TEXT_PP(1); text\t   *priv_type_text = PG_GETARG_TEXT_PP(2); Oid\t\t\trolei...","count":3},{"name":"api-example","value":"Datum has_schema_privilege_name_name(PG_FUNCTION_ARGS) { Name\t\tusername = PG_GETARG_NAME(0); text\t   *schemaname = PG_GETARG_TEXT_PP(1); text\t   *priv_type_text = PG_GETARG_TEXT_PP(2); Oid\t\t\troleid; O...","count":3},{"name":"api-example","value":"Datum has_sequence_privilege_name_name(PG_FUNCTION_ARGS) { Name\t\trolename = PG_GETARG_NAME(0); text\t   *sequencename = PG_GETARG_TEXT_PP(1); text\t   *priv_type_text = PG_GETARG_TEXT_PP(2); Oid\t\t\trolei...","count":3},{"name":"api-example","value":"Datum has_server_privilege_name_name(PG_FUNCTION_ARGS) { Name\t\tusername = PG_GETARG_NAME(0); text\t   *servername = PG_GETARG_TEXT_PP(1); text\t   *priv_type_text = PG_GETARG_TEXT_PP(2); Oid\t\t\troleid; O...","count":3},{"name":"api-example","value":"Datum has_tablespace_privilege_name_name(PG_FUNCTION_ARGS) { Name\t\tusername = PG_GETARG_NAME(0); text\t   *tablespacename = PG_GETARG_TEXT_PP(1); text\t   *priv_type_text = PG_GETARG_TEXT_PP(2); Oid\t\t\tr...","count":3},{"name":"api-example","value":"Datum has_type_privilege_name_name(PG_FUNCTION_ARGS) { Name\t\tusername = PG_GETARG_NAME(0); text\t   *typename = PG_GETARG_TEXT_PP(1); text\t   *priv_type_text = PG_GETARG_TEXT_PP(2); Oid\t\t\troleid; Oid\t\t...","count":3},{"name":"api-example","value":"Datum hashcharextended(PG_FUNCTION_ARGS) { return hash_uint32_extended((int32) PG_GETARG_CHAR(0), PG_GETARG_INT64(1)); }","count":3},{"name":"api-example","value":"Datum in_range_date_interval(PG_FUNCTION_ARGS) { DateADT\t\tval = PG_GETARG_DATEADT(0); DateADT\t\tbase = PG_GETARG_DATEADT(1); Interval   *offset = PG_GETARG_INTERVAL_P(2); bool\t\tsub = PG_GETARG_BOOL(3);...","count":3},{"name":"api-example","value":"Datum inet_spg_inner_consistent(PG_FUNCTION_ARGS) { spgInnerConsistentIn *in = (spgInnerConsistentIn *) PG_GETARG_POINTER(0); spgInnerConsistentOut *out = (spgInnerConsistentOut *) PG_GETARG_POINTER(1...","count":3},{"name":"api-example","value":"Datum interval_eq(PG_FUNCTION_ARGS) { Interval   *interval1 = PG_GETARG_INTERVAL_P(0); Interval   *interval2 = PG_GETARG_INTERVAL_P(1); PG_RETURN_BOOL(interval_cmp_internal(interval1, interval2) == 0)...","count":3},{"name":"api-example","value":"Datum interval_mul(PG_FUNCTION_ARGS) { Interval   *span = PG_GETARG_INTERVAL_P(0); float8\t\tfactor = PG_GETARG_FLOAT8(1); double\t\tmonth_remainder_days, sec_remainder, result_double; int32\t\torig_month =...","count":3},{"name":"api-example","value":"Datum json_object_field(PG_FUNCTION_ARGS) { text\t   *json = PG_GETARG_TEXT_PP(0); text\t   *fname = PG_GETARG_TEXT_PP(1); char\t   *fnamestr = text_to_cstring(fname); text\t   *result; result = get_worke...","count":3},{"name":"api-example","value":"Datum json_string_to_tsvector_byid(PG_FUNCTION_ARGS) { Oid\t\t\tcfgId = PG_GETARG_OID(0); text\t   *json = PG_GETARG_TEXT_P(1); TSVector\tresult; result = json_to_tsvector_worker(cfgId, json, jtiString); P...","count":3},{"name":"api-example","value":"Datum json_typeof(PG_FUNCTION_ARGS) { text\t   *json = PG_GETARG_TEXT_PP(0); JsonLexContext lex; char\t   *type; JsonParseErrorType result; makeJsonLexContext(&lex, json, false); result = json_lex(&lex)...","count":3},{"name":"api-example","value":"Datum jsonb_array_element(PG_FUNCTION_ARGS) { Jsonb\t   *jb = PG_GETARG_JSONB_P(0); int\t\t\telement = PG_GETARG_INT32(1); JsonbValue *v; if (!JB_ROOT_IS_ARRAY(jb)) PG_RETURN_NULL(); if (element < 0) { ui...","count":3},{"name":"api-example","value":"Datum jsonb_bool(PG_FUNCTION_ARGS) { Jsonb\t   *in = PG_GETARG_JSONB_P(0); JsonbValue\tv; if (!JsonbExtractScalar(&in->root, &v) || v.type != jbvBool) cannotCastJsonbValue(v.type, \"boolean\"); PG_FREE_IF...","count":3},{"name":"api-example","value":"Datum jsonb_ne(PG_FUNCTION_ARGS) { Jsonb\t   *jba = PG_GETARG_JSONB_P(0); Jsonb\t   *jbb = PG_GETARG_JSONB_P(1); bool\t\tres; res = (compareJsonbContainers(&jba->root, &jbb->root) != 0); PG_FREE_IF_COPY(j...","count":3},{"name":"api-example","value":"Datum jsonb_object_field_text(PG_FUNCTION_ARGS) { Jsonb\t   *jb = PG_GETARG_JSONB_P(0); text\t   *key = PG_GETARG_TEXT_PP(1); JsonbValue *v; JsonbValue\tvbuf; if (!JB_ROOT_IS_OBJECT(jb)) PG_RETURN_NULL()...","count":3},{"name":"api-example","value":"Datum jsonb_out(PG_FUNCTION_ARGS) { Jsonb\t   *jb = PG_GETARG_JSONB_P(0); char\t   *out; out = JsonbToCString(NULL, &jb->root, VARSIZE(jb)); PG_RETURN_CSTRING(out); }","count":3},{"name":"api-example","value":"Datum jsonb_populate_record(PG_FUNCTION_ARGS) { return populate_record_worker(fcinfo, \"jsonb_populate_record\", false, true, NULL); }","count":3},{"name":"api-example","value":"Datum koi8r_to_win1251(PG_FUNCTION_ARGS) { unsigned char *src = (unsigned char *) PG_GETARG_CSTRING(2); unsigned char *dest = (unsigned char *) PG_GETARG_CSTRING(3); int\t\t\tlen = PG_GETARG_INT32(4); bo...","count":3},{"name":"api-example","value":"Datum line_intersect(PG_FUNCTION_ARGS) { LINE\t   *l1 = PG_GETARG_LINE_P(0); LINE\t   *l2 = PG_GETARG_LINE_P(1); PG_RETURN_BOOL(line_interpt_line(NULL, l1, l2)); }","count":3},{"name":"api-example","value":"Datum macaddr8_cmp(PG_FUNCTION_ARGS) { macaddr8   *a1 = PG_GETARG_MACADDR8_P(0); macaddr8   *a2 = PG_GETARG_MACADDR8_P(1); PG_RETURN_INT32(macaddr8_cmp_internal(a1, a2)); }","count":3},{"name":"api-example","value":"Datum macaddr_cmp(PG_FUNCTION_ARGS) { macaddr    *a1 = PG_GETARG_MACADDR_P(0); macaddr    *a2 = PG_GETARG_MACADDR_P(1); PG_RETURN_INT32(macaddr_cmp_internal(a1, a2)); }","count":3},{"name":"api-example","value":"Datum makeaclitem(PG_FUNCTION_ARGS) { Oid\t\t\tgrantee = PG_GETARG_OID(0); Oid\t\t\tgrantor = PG_GETARG_OID(1); text\t   *privtext = PG_GETARG_TEXT_PP(2); bool\t\tgoption = PG_GETARG_BOOL(3); AclItem    *resul...","count":3},{"name":"api-example","value":"Datum mic_to_koi8r(PG_FUNCTION_ARGS) { unsigned char *src = (unsigned char *) PG_GETARG_CSTRING(2); unsigned char *dest = (unsigned char *) PG_GETARG_CSTRING(3); int\t\t\tlen = PG_GETARG_INT32(4); bool\t\t...","count":3},{"name":"api-example","value":"Datum nameeq(PG_FUNCTION_ARGS) { Name\t\targ1 = PG_GETARG_NAME(0); Name\t\targ2 = PG_GETARG_NAME(1); PG_RETURN_BOOL(namecmp(arg1, arg2, PG_GET_COLLATION()) == 0); }","count":3},{"name":"api-example","value":"Datum namelike(PG_FUNCTION_ARGS) { Name\t\tstr = PG_GETARG_NAME(0); text\t   *pat = PG_GETARG_TEXT_PP(1); bool\t\tresult; char\t   *s, *p; int\t\t\tslen, plen; s = NameStr(*str); slen = strlen(s); p = VARDATA_...","count":3},{"name":"api-example","value":"Datum network_cmp(PG_FUNCTION_ARGS) { inet\t   *a1 = PG_GETARG_INET_PP(0); inet\t   *a2 = PG_GETARG_INET_PP(1); PG_RETURN_INT32(network_cmp_internal(a1, a2)); }","count":3},{"name":"api-example","value":"Datum nextval(PG_FUNCTION_ARGS) { text\t   *seqin = PG_GETARG_TEXT_PP(0); RangeVar   *sequence; Oid\t\t\trelid; sequence = makeRangeVarFromNameList(textToQualifiedNameList(seqin)); * XXX: This is not safe...","count":3},{"name":"api-example","value":"Datum numeric_accum_inv(PG_FUNCTION_ARGS) { NumericAggState *state; state = PG_ARGISNULL(0) ? NULL : (NumericAggState *) PG_GETARG_POINTER(0); if (state == NULL) elog(ERROR, \"numeric_accum_inv called ...","count":3},{"name":"api-example","value":"Datum numeric_avg_deserialize(PG_FUNCTION_ARGS) { bytea\t   *sstate; NumericAggState *result; StringInfoData buf; NumericVar\ttmp_var; if (!AggCheckCallContext(fcinfo, NULL)) elog(ERROR, \"aggregate func...","count":3},{"name":"api-example","value":"Datum numeric_div(PG_FUNCTION_ARGS) { Numeric\t\tnum1 = PG_GETARG_NUMERIC(0); Numeric\t\tnum2 = PG_GETARG_NUMERIC(1); Numeric\t\tres; res = numeric_div_opt_error(num1, num2, NULL); PG_RETURN_NUMERIC(res); }","count":3},{"name":"api-example","value":"Datum numeric_ln(PG_FUNCTION_ARGS) { Numeric\t\tnum = PG_GETARG_NUMERIC(0); Numeric\t\tres; NumericVar\targ; NumericVar\tresult; int\t\t\tln_dweight; int\t\t\trscale; * Handle NaN and infinities */ if (NUMERIC_IS...","count":3},{"name":"api-example","value":"Datum numeric_round(PG_FUNCTION_ARGS) { Numeric\t\tnum = PG_GETARG_NUMERIC(0); int32\t\tscale = PG_GETARG_INT32(1); Numeric\t\tres; NumericVar\targ; * Handle NaN and infinities */ if (NUMERIC_IS_SPECIAL(num)...","count":3},{"name":"api-example","value":"Datum numeric_sign(PG_FUNCTION_ARGS) { Numeric\t\tnum = PG_GETARG_NUMERIC(0); * Handle NaN (infinities can be handled normally) */ if (NUMERIC_IS_NAN(num)) PG_RETURN_NUMERIC(make_result(&const_nan)); sw...","count":3},{"name":"api-example","value":"Datum numeric_support(PG_FUNCTION_ARGS) { Node\t   *rawreq = (Node *) PG_GETARG_POINTER(0); Node\t   *ret = NULL; if (IsA(rawreq, SupportRequestSimplify)) { SupportRequestSimplify *req = (SupportRequest...","count":3},{"name":"api-example","value":"Datum numeric_uminus(PG_FUNCTION_ARGS) { Numeric\t\tnum = PG_GETARG_NUMERIC(0); Numeric\t\tres; * Do it the easy way directly on the packed format */ res = duplicate_numeric(num); if (NUMERIC_IS_SPECIAL(n...","count":3},{"name":"api-example","value":"Datum oidin(PG_FUNCTION_ARGS) { char\t   *s = PG_GETARG_CSTRING(0); Oid\t\t\tresult; result = uint32in_subr(s, NULL, \"oid\", fcinfo->context); PG_RETURN_OID(result); }","count":3},{"name":"api-example","value":"Datum oidvectoreq(PG_FUNCTION_ARGS) { int32\t\tcmp = DatumGetInt32(btoidvectorcmp(fcinfo)); PG_RETURN_BOOL(cmp == 0); }","count":3},{"name":"api-example","value":"Datum path_distance(PG_FUNCTION_ARGS) { PATH\t   *p1 = PG_GETARG_PATH_P(0); PATH\t   *p2 = PG_GETARG_PATH_P(1); float8\t\tmin = 0.0;\t\t/* initialize to keep compiler quiet */ bool\t\thave_min = false; float8...","count":3},{"name":"api-example","value":"Datum path_inter(PG_FUNCTION_ARGS) { PATH\t   *p1 = PG_GETARG_PATH_P(0); PATH\t   *p2 = PG_GETARG_PATH_P(1); BOX\t\t\tb1, b2; int\t\t\ti, j; LSEG\t\tseg1, seg2; Assert(p1->npts > 0 && p2->npts > 0); b1.high.x =...","count":3},{"name":"api-example","value":"Datum pg_advisory_lock_int4(PG_FUNCTION_ARGS) { int32\t\tkey1 = PG_GETARG_INT32(0); int32\t\tkey2 = PG_GETARG_INT32(1); LOCKTAG\t\ttag; SET_LOCKTAG_INT32(tag, key1, key2); (void) LockAcquire(&tag, Exclusive...","count":3},{"name":"api-example","value":"Datum pg_advisory_lock_int8(PG_FUNCTION_ARGS) { int64\t\tkey = PG_GETARG_INT64(0); LOCKTAG\t\ttag; SET_LOCKTAG_INT64(tag, key); (void) LockAcquire(&tag, ExclusiveLock, true, false); PG_RETURN_VOID(); }","count":3},{"name":"api-example","value":"Datum pg_available_wal_summaries(PG_FUNCTION_ARGS) { ReturnSetInfo *rsi; List\t   *wslist; ListCell   *lc; Datum\t\tvalues[NUM_WS_ATTS]; bool\t\tnulls[NUM_WS_ATTS]; InitMaterializedSRF(fcinfo, 0); rsi = (R...","count":3},{"name":"api-example","value":"Datum pg_collation_for(PG_FUNCTION_ARGS) { Oid\t\t\ttypeid; Oid\t\t\tcollid; typeid = get_fn_expr_argtype(fcinfo->flinfo, 0); if (!typeid) PG_RETURN_NULL(); if (!type_is_collatable(typeid) && typeid != UNKN...","count":3},{"name":"api-example","value":"Datum pg_control_system(PG_FUNCTION_ARGS) { Datum\t\tvalues[4]; bool\t\tnulls[4]; TupleDesc\ttupdesc; HeapTuple\thtup; ControlFileData *ControlFile; bool\t\tcrc_ok; if (get_call_result_type(fcinfo, NULL, &tup...","count":3},{"name":"api-example","value":"Datum pg_copy_logical_replication_slot_a(PG_FUNCTION_ARGS) { return copy_replication_slot(fcinfo, true); }","count":3},{"name":"api-example","value":"Datum pg_current_wal_flush_lsn(PG_FUNCTION_ARGS) { XLogRecPtr\tcurrent_recptr; if (RecoveryInProgress()) ereport(ERROR, (errcode(ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE), errmsg(\"recovery is in progre...","count":3},{"name":"api-example","value":"Datum pg_event_trigger_ddl_commands(PG_FUNCTION_ARGS) { ReturnSetInfo *rsinfo = (ReturnSetInfo *) fcinfo->resultinfo; ListCell   *lc; * Protect this function from being called out of context */ if (!c...","count":3},{"name":"api-example","value":"Datum pg_get_indexdef(PG_FUNCTION_ARGS) { Oid\t\t\tindexrelid = PG_GETARG_OID(0); int\t\t\tprettyFlags; char\t   *res; prettyFlags = PRETTYFLAG_INDENT; res = pg_get_indexdef_worker(indexrelid, 0, NULL, false...","count":3},{"name":"api-example","value":"Datum pg_get_keywords(PG_FUNCTION_ARGS) { FuncCallContext *funcctx; if (SRF_IS_FIRSTCALL()) { MemoryContext oldcontext; TupleDesc\ttupdesc; funcctx = SRF_FIRSTCALL_INIT(); oldcontext = MemoryContextSwi...","count":3},{"name":"api-example","value":"Datum pg_get_publication_tables(PG_FUNCTION_ARGS) { #define NUM_PUBLICATION_TABLES_ELEM\t4 FuncCallContext *funcctx; List\t   *table_infos = NIL; if (SRF_IS_FIRSTCALL()) { TupleDesc\ttupdesc; MemoryConte...","count":3},{"name":"api-example","value":"Datum pg_get_ruledef_ext(PG_FUNCTION_ARGS) { Oid\t\t\truleoid = PG_GETARG_OID(0); bool\t\tpretty = PG_GETARG_BOOL(1); int\t\t\tprettyFlags; char\t   *res; prettyFlags = GET_PRETTY_FLAGS(pretty); res = pg_get_r...","count":3},{"name":"api-example","value":"Datum pg_get_wait_events(PG_FUNCTION_ARGS) { #define PG_GET_WAIT_EVENTS_COLS 3 ReturnSetInfo *rsinfo = (ReturnSetInfo *) fcinfo->resultinfo; char\t  **waiteventnames; int\t\t\tnbwaitevents; InitMaterializ...","count":3},{"name":"api-example","value":"Datum pg_import_system_collations(PG_FUNCTION_ARGS) { Oid\t\t\tnspid = PG_GETARG_OID(0); int\t\t\tncreated = 0; if (!superuser()) ereport(ERROR, (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE), errmsg(\"must be sup...","count":3},{"name":"api-example","value":"Datum pg_lock_status(PG_FUNCTION_ARGS) { FuncCallContext *funcctx; PG_Lock_Status *mystatus; LockData   *lockData; PredicateLockData *predLockData; if (SRF_IS_FIRSTCALL()) { TupleDesc\ttupdesc; MemoryC...","count":3},{"name":"api-example","value":"Datum pg_ls_logdir(PG_FUNCTION_ARGS) { return pg_ls_dir_files(fcinfo, Log_directory, false); }","count":3},{"name":"api-example","value":"Datum pg_notify(PG_FUNCTION_ARGS) { const char *channel; const char *payload; if (PG_ARGISNULL(0)) channel = \"\"; else channel = text_to_cstring(PG_GETARG_TEXT_PP(0)); if (PG_ARGISNULL(1)) payload = \"\"...","count":3},{"name":"api-example","value":"Datum pg_prepared_xact(PG_FUNCTION_ARGS) { FuncCallContext *funcctx; Working_State *status; if (SRF_IS_FIRSTCALL()) { TupleDesc\ttupdesc; MemoryContext oldcontext; funcctx = SRF_FIRSTCALL_INIT(); * Swi...","count":3},{"name":"api-example","value":"Datum pg_relation_size(PG_FUNCTION_ARGS) { Oid\t\t\trelOid = PG_GETARG_OID(0); text\t   *forkName = PG_GETARG_TEXT_PP(1); Relation\trel; int64\t\tsize; rel = try_relation_open(relOid, AccessShareLock); * Bef...","count":3},{"name":"api-example","value":"Datum pg_replication_origin_create(PG_FUNCTION_ARGS) { char\t   *name; RepOriginId roident; replorigin_check_prerequisites(false, false); name = text_to_cstring((text *) DatumGetPointer(PG_GETARG_DATUM...","count":3},{"name":"api-example","value":"Datum pg_size_pretty_numeric(PG_FUNCTION_ARGS) { Numeric\t\tsize = PG_GETARG_NUMERIC(0); char\t   *result = NULL; const struct size_pretty_unit *unit; for (unit = size_pretty_units; unit->name != NULL; u...","count":3},{"name":"api-example","value":"Datum pg_snapshot_out(PG_FUNCTION_ARGS) { pg_snapshot *snap = (pg_snapshot *) PG_GETARG_VARLENA_P(0); StringInfoData str; uint32\t\ti; initStringInfo(&str); appendStringInfo(&str, UINT64_FORMAT \":\", U64...","count":3},{"name":"api-example","value":"Datum pg_stat_file(PG_FUNCTION_ARGS) { text\t   *filename_t = PG_GETARG_TEXT_PP(0); char\t   *filename; struct stat fst; Datum\t\tvalues[6]; bool\t\tisnull[6]; HeapTuple\ttuple; TupleDesc\ttupdesc; bool\t\tmiss...","count":3},{"name":"api-example","value":"Datum pg_stat_get_backend_pid(PG_FUNCTION_ARGS) { int32\t\tprocNumber = PG_GETARG_INT32(0); PgBackendStatus *beentry; if ((beentry = pgstat_get_beentry_by_proc_number(procNumber)) == NULL) PG_RETURN_NUL...","count":3},{"name":"api-example","value":"Datum pg_stat_get_bgwriter_buf_written_clean(PG_FUNCTION_ARGS) { PG_RETURN_INT64(pgstat_fetch_stat_bgwriter()->buf_written_clean); }","count":3},{"name":"api-example","value":"Datum pg_stat_get_checkpointer_num_timed(PG_FUNCTION_ARGS) { PG_RETURN_INT64(pgstat_fetch_stat_checkpointer()->num_timed); }","count":3},{"name":"api-example","value":"Datum pg_stat_get_progress_info(PG_FUNCTION_ARGS) { #define PG_STAT_GET_PROGRESS_COLS\tPGSTAT_NUM_PROGRESS_PARAM + 3 int\t\t\tnum_backends = pgstat_fetch_stat_numbackends(); int\t\t\tcurr_backend; char\t   *c...","count":3},{"name":"api-example","value":"Datum pg_stat_get_wal_senders(PG_FUNCTION_ARGS) { #define PG_STAT_GET_WAL_SENDERS_COLS\t12 ReturnSetInfo *rsinfo = (ReturnSetInfo *) fcinfo->resultinfo; SyncRepStandbyData *sync_standbys; int\t\t\tnum_sta...","count":3},{"name":"api-example","value":"Datum pg_stat_reset_shared(PG_FUNCTION_ARGS) { char\t   *target = NULL; if (PG_ARGISNULL(0)) { pgstat_reset_of_kind(PGSTAT_KIND_ARCHIVER); pgstat_reset_of_kind(PGSTAT_KIND_BGWRITER); pgstat_reset_of_ki...","count":3},{"name":"api-example","value":"Datum pg_walfile_name(PG_FUNCTION_ARGS) { XLogSegNo\txlogsegno; XLogRecPtr\tlocationpoint = PG_GETARG_LSN(0); char\t\txlogfilename[MAXFNAMELEN]; if (RecoveryInProgress()) ereport(ERROR, (errcode(ERRCODE_O...","count":3},{"name":"api-example","value":"Datum plperl_inline_handler(PG_FUNCTION_ARGS) { LOCAL_FCINFO(fake_fcinfo, 0); InlineCodeBlock *codeblock = (InlineCodeBlock *) PG_GETARG_POINTER(0); FmgrInfo\tflinfo; plperl_proc_desc desc; plperl_call...","count":3},{"name":"api-example","value":"Datum point_add(PG_FUNCTION_ARGS) { Point\t   *p1 = PG_GETARG_POINT_P(0); Point\t   *p2 = PG_GETARG_POINT_P(1); Point\t   *result; result = (Point *) palloc(sizeof(Point)); point_add_point(result, p1, p2...","count":3},{"name":"api-example","value":"Datum point_div(PG_FUNCTION_ARGS) { Point\t   *p1 = PG_GETARG_POINT_P(0); Point\t   *p2 = PG_GETARG_POINT_P(1); Point\t   *result; result = (Point *) palloc(sizeof(Point)); point_div_point(result, p1, p2...","count":3},{"name":"api-example","value":"Datum point_mul(PG_FUNCTION_ARGS) { Point\t   *p1 = PG_GETARG_POINT_P(0); Point\t   *p2 = PG_GETARG_POINT_P(1); Point\t   *result; result = (Point *) palloc(sizeof(Point)); point_mul_point(result, p1, p2...","count":3},{"name":"api-example","value":"Datum point_sub(PG_FUNCTION_ARGS) { Point\t   *p1 = PG_GETARG_POINT_P(0); Point\t   *p2 = PG_GETARG_POINT_P(1); Point\t   *result; result = (Point *) palloc(sizeof(Point)); point_sub_point(result, p1, p2...","count":3},{"name":"api-example","value":"Datum poly_in(PG_FUNCTION_ARGS) { char\t   *str = PG_GETARG_CSTRING(0); Node\t   *escontext = fcinfo->context; POLYGON    *poly; int\t\t\tnpts; int\t\t\tsize; int\t\t\tbase_size; bool\t\tisopen; if ((npts = pair_c...","count":3},{"name":"api-example","value":"Datum range_constructor2(PG_FUNCTION_ARGS) { Datum\t\targ1 = PG_GETARG_DATUM(0); Datum\t\targ2 = PG_GETARG_DATUM(1); Oid\t\t\trngtypid = get_fn_expr_rettype(fcinfo->flinfo); RangeType  *range; TypeCacheEntry...","count":3},{"name":"api-example","value":"Datum range_contains(PG_FUNCTION_ARGS) { RangeType  *r1 = PG_GETARG_RANGE_P(0); RangeType  *r2 = PG_GETARG_RANGE_P(1); TypeCacheEntry *typcache; typcache = range_get_typcache(fcinfo, RangeTypeGetOid(r...","count":3},{"name":"api-example","value":"Datum range_contains_elem(PG_FUNCTION_ARGS) { RangeType  *r = PG_GETARG_RANGE_P(0); Datum\t\tval = PG_GETARG_DATUM(1); TypeCacheEntry *typcache; typcache = range_get_typcache(fcinfo, RangeTypeGetOid(r))...","count":3},{"name":"api-example","value":"Datum range_contains_multirange(PG_FUNCTION_ARGS) { RangeType  *r = PG_GETARG_RANGE_P(0); MultirangeType *mr = PG_GETARG_MULTIRANGE_P(1); TypeCacheEntry *typcache; typcache = multirange_get_typcache(f...","count":3},{"name":"api-example","value":"Datum range_eq(PG_FUNCTION_ARGS) { RangeType  *r1 = PG_GETARG_RANGE_P(0); RangeType  *r2 = PG_GETARG_RANGE_P(1); TypeCacheEntry *typcache; typcache = range_get_typcache(fcinfo, RangeTypeGetOid(r1)); P...","count":3},{"name":"api-example","value":"Datum range_gist_union(PG_FUNCTION_ARGS) { GistEntryVector *entryvec = (GistEntryVector *) PG_GETARG_POINTER(0); GISTENTRY  *ent = entryvec->vector; RangeType  *result_range; TypeCacheEntry *typcache;...","count":3},{"name":"api-example","value":"Datum range_overlaps_multirange(PG_FUNCTION_ARGS) { RangeType  *r = PG_GETARG_RANGE_P(0); MultirangeType *mr = PG_GETARG_MULTIRANGE_P(1); TypeCacheEntry *typcache; typcache = multirange_get_typcache(f...","count":3},{"name":"api-example","value":"Datum rangesel(PG_FUNCTION_ARGS) { PlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0); Oid\t\t\toperator = PG_GETARG_OID(1); List\t   *args = (List *) PG_GETARG_POINTER(2); int\t\t\tvarRelid = PG_GETAR...","count":3},{"name":"api-example","value":"Datum record_image_lt(PG_FUNCTION_ARGS) { PG_RETURN_BOOL(record_image_cmp(fcinfo) < 0); }","count":3},{"name":"api-example","value":"Datum record_lt(PG_FUNCTION_ARGS) { PG_RETURN_BOOL(record_cmp(fcinfo) < 0); }","count":3},{"name":"api-example","value":"Datum regexeqjoinsel(PG_FUNCTION_ARGS) { PG_RETURN_FLOAT8(patternjoinsel(fcinfo, Pattern_Type_Regex, false)); }","count":3},{"name":"api-example","value":"Datum regexeqsel(PG_FUNCTION_ARGS) { PG_RETURN_FLOAT8(patternsel(fcinfo, Pattern_Type_Regex, false)); }","count":3},{"name":"api-example","value":"Datum regexp_count(PG_FUNCTION_ARGS) { text\t   *str = PG_GETARG_TEXT_PP(0); text\t   *pattern = PG_GETARG_TEXT_PP(1); int\t\t\tstart = 1; text\t   *flags = PG_GETARG_TEXT_PP_IF_EXISTS(3); pg_re_flags re_fl...","count":3},{"name":"api-example","value":"Datum regexp_instr_no_start(PG_FUNCTION_ARGS) { return regexp_instr(fcinfo); }","count":3},{"name":"api-example","value":"Datum regprocin(PG_FUNCTION_ARGS) { char\t   *pro_name_or_oid = PG_GETARG_CSTRING(0); Node\t   *escontext = fcinfo->context; RegProcedure result; List\t   *names; FuncCandidateList clist; if (parseDashOr...","count":3},{"name":"api-example","value":"Datum regprocrecv(PG_FUNCTION_ARGS) { return oidrecv(fcinfo); }","count":3},{"name":"api-example","value":"Datum regprocsend(PG_FUNCTION_ARGS) { return oidsend(fcinfo); }","count":3},{"name":"api-example","value":"Datum replace_text(PG_FUNCTION_ARGS) { text\t   *src_text = PG_GETARG_TEXT_PP(0); text\t   *from_sub_text = PG_GETARG_TEXT_PP(1); text\t   *to_sub_text = PG_GETARG_TEXT_PP(2); int\t\t\tsrc_text_len; int\t\t\tf...","count":3},{"name":"api-example","value":"Datum spg_kd_inner_consistent(PG_FUNCTION_ARGS) { spgInnerConsistentIn *in = (spgInnerConsistentIn *) PG_GETARG_POINTER(0); spgInnerConsistentOut *out = (spgInnerConsistentOut *) PG_GETARG_POINTER(1);...","count":3},{"name":"api-example","value":"Datum spg_text_choose(PG_FUNCTION_ARGS) { spgChooseIn *in = (spgChooseIn *) PG_GETARG_POINTER(0); spgChooseOut *out = (spgChooseOut *) PG_GETARG_POINTER(1); text\t   *inText = DatumGetTextPP(in->datum)...","count":3},{"name":"api-example","value":"Datum spg_text_leaf_consistent(PG_FUNCTION_ARGS) { spgLeafConsistentIn *in = (spgLeafConsistentIn *) PG_GETARG_POINTER(0); spgLeafConsistentOut *out = (spgLeafConsistentOut *) PG_GETARG_POINTER(1); in...","count":3},{"name":"api-example","value":"Datum stringTypeDatum(Type tp, char *string, int32 atttypmod) { Form_pg_type typform = (Form_pg_type) GETSTRUCT(tp); Oid\t\t\ttypinput = typform->typinput; Oid\t\t\ttypioparam = getTypeIOParam(tp); return O...","count":3},{"name":"api-example","value":"Datum table_to_xml(PG_FUNCTION_ARGS) { Oid\t\t\trelid = PG_GETARG_OID(0); bool\t\tnulls = PG_GETARG_BOOL(1); bool\t\ttableforest = PG_GETARG_BOOL(2); const char *targetns = text_to_cstring(PG_GETARG_TEXT_PP(...","count":3},{"name":"api-example","value":"Datum text_format(PG_FUNCTION_ARGS) { text\t   *fmt; StringInfoData str; const char *cp; const char *start_ptr; const char *end_ptr; text\t   *result; int\t\t\targ; bool\t\tfuncvariadic; int\t\t\tnargs; Datum\t ...","count":3},{"name":"api-example","value":"Datum text_pattern_lt(PG_FUNCTION_ARGS) { text\t   *arg1 = PG_GETARG_TEXT_PP(0); text\t   *arg2 = PG_GETARG_TEXT_PP(1); int\t\t\tresult; result = internal_text_pattern_compare(arg1, arg2); PG_FREE_IF_COPY(...","count":3},{"name":"api-example","value":"Datum text_substr(PG_FUNCTION_ARGS) { PG_RETURN_TEXT_P(text_substring(PG_GETARG_DATUM(0), PG_GETARG_INT32(1), PG_GETARG_INT32(2), false)); }","count":3},{"name":"api-example","value":"Datum texteq(PG_FUNCTION_ARGS) { Oid\t\t\tcollid = PG_GET_COLLATION(); bool\t\tlocale_is_c = false; pg_locale_t mylocale = 0; bool\t\tresult; check_collation_set(collid); if (lc_collate_is_c(collid)) locale_...","count":3},{"name":"api-example","value":"Datum textlike_support(PG_FUNCTION_ARGS) { Node\t   *rawreq = (Node *) PG_GETARG_POINTER(0); PG_RETURN_POINTER(like_regex_support(rawreq, Pattern_Type_Like)); }","count":3},{"name":"api-example","value":"Datum textregexreplace(PG_FUNCTION_ARGS) { text\t   *s = PG_GETARG_TEXT_PP(0); text\t   *p = PG_GETARG_TEXT_PP(1); text\t   *r = PG_GETARG_TEXT_PP(2); text\t   *opt = PG_GETARG_TEXT_PP(3); pg_re_flags fla...","count":3},{"name":"api-example","value":"Datum textregexreplace_extended(PG_FUNCTION_ARGS) { text\t   *s = PG_GETARG_TEXT_PP(0); text\t   *p = PG_GETARG_TEXT_PP(1); text\t   *r = PG_GETARG_TEXT_PP(2); int\t\t\tstart = 1; int\t\t\tn = 1; text\t   *flag...","count":3},{"name":"api-example","value":"Datum thesaurus_init(PG_FUNCTION_ARGS) { List\t   *dictoptions = (List *) PG_GETARG_POINTER(0); DictThesaurus *d; char\t   *subdictname = NULL; bool\t\tfileloaded = false; List\t   *namelist; ListCell   *l...","count":3},{"name":"api-example","value":"Datum time_in(PG_FUNCTION_ARGS) { char\t   *str = PG_GETARG_CSTRING(0); #ifdef NOT_USED Oid\t\t\ttypelem = PG_GETARG_OID(1); #endif int32\t\ttypmod = PG_GETARG_INT32(2); Node\t   *escontext = fcinfo->context...","count":3},{"name":"api-example","value":"Datum time_interval(PG_FUNCTION_ARGS) { TimeADT\t\ttime = PG_GETARG_TIMEADT(0); Interval   *result; result = (Interval *) palloc(sizeof(Interval)); result->time = time; result->day = 0; result->month = ...","count":3},{"name":"api-example","value":"Datum timestamp_mi_interval(PG_FUNCTION_ARGS) { Timestamp\ttimestamp = PG_GETARG_TIMESTAMP(0); Interval   *span = PG_GETARG_INTERVAL_P(1); Interval\ttspan; interval_um_internal(span, &tspan); return Dir...","count":3},{"name":"api-example","value":"Datum timetz_eq(PG_FUNCTION_ARGS) { TimeTzADT  *time1 = PG_GETARG_TIMETZADT_P(0); TimeTzADT  *time2 = PG_GETARG_TIMETZADT_P(1); PG_RETURN_BOOL(timetz_cmp_internal(time1, time2) == 0); }","count":3},{"name":"api-example","value":"Datum timetz_in(PG_FUNCTION_ARGS) { char\t   *str = PG_GETARG_CSTRING(0); #ifdef NOT_USED Oid\t\t\ttypelem = PG_GETARG_OID(1); #endif int32\t\ttypmod = PG_GETARG_INT32(2); Node\t   *escontext = fcinfo->conte...","count":3},{"name":"api-example","value":"Datum to_ascii_encname(PG_FUNCTION_ARGS) { text\t   *data = PG_GETARG_TEXT_P_COPY(0); char\t   *encname = NameStr(*PG_GETARG_NAME(1)); int\t\t\tenc = pg_char_to_encoding(encname); if (enc < 0) ereport(ERRO...","count":3},{"name":"api-example","value":"Datum to_bin32(PG_FUNCTION_ARGS) { uint64\t\tvalue = (uint32) PG_GETARG_INT32(0); PG_RETURN_TEXT_P(convert_to_base(value, 2)); }","count":3},{"name":"api-example","value":"Datum to_timestamp(PG_FUNCTION_ARGS) { text\t   *date_txt = PG_GETARG_TEXT_PP(0); text\t   *fmt = PG_GETARG_TEXT_PP(1); Oid\t\t\tcollid = PG_GET_COLLATION(); Timestamp\tresult; int\t\t\ttz; struct pg_tm tm; st...","count":3},{"name":"api-example","value":"Datum ts_rank_wttf(PG_FUNCTION_ARGS) { ArrayType  *win = (ArrayType *) PG_DETOAST_DATUM(PG_GETARG_DATUM(0)); TSVector\ttxt = PG_GETARG_TSVECTOR(1); TSQuery\t\tquery = PG_GETARG_TSQUERY(2); int\t\t\tmethod =...","count":3},{"name":"api-example","value":"Datum tsquery_cmp(PG_FUNCTION_ARGS) { TSQuery\t\ta = PG_GETARG_TSQUERY_COPY(0); TSQuery\t\tb = PG_GETARG_TSQUERY_COPY(1); int\t\t\tres = CompareTSQ(a, b); PG_FREE_IF_COPY(a, 0); PG_FREE_IF_COPY(b, 1); PG_RET...","count":3},{"name":"api-example","value":"Datum unicode_normalize_func(PG_FUNCTION_ARGS) { text\t   *input = PG_GETARG_TEXT_PP(0); char\t   *formstr = text_to_cstring(PG_GETARG_TEXT_PP(1)); UnicodeNormalizationForm form; int\t\t\tsize; pg_wchar   ...","count":3},{"name":"api-example","value":"Datum utf8_to_big5(PG_FUNCTION_ARGS) { unsigned char *src = (unsigned char *) PG_GETARG_CSTRING(2); unsigned char *dest = (unsigned char *) PG_GETARG_CSTRING(3); int\t\t\tlen = PG_GETARG_INT32(4); bool\t\t...","count":3},{"name":"api-example","value":"Datum uuid_lt(PG_FUNCTION_ARGS) { pg_uuid_t  *arg1 = PG_GETARG_UUID_P(0); pg_uuid_t  *arg2 = PG_GETARG_UUID_P(1); PG_RETURN_BOOL(uuid_internal_cmp(arg1, arg2) < 0); }","count":3},{"name":"api-example","value":"Datum uuid_out(PG_FUNCTION_ARGS) { pg_uuid_t  *uuid = PG_GETARG_UUID_P(0); static const char hex_chars[] = \"0123456789abcdef\"; char\t   *buf, *p; int\t\t\ti; buf = palloc(2 * UUID_LEN + 5); p = buf; for (...","count":3},{"name":"api-example","value":"Datum window_lag(PG_FUNCTION_ARGS) { return leadlag_common(fcinfo, false, false, false); }","count":3},{"name":"api-example","value":"Datum window_row_number(PG_FUNCTION_ARGS) { WindowObject winobj = PG_WINDOW_OBJECT(); int64\t\tcurpos = WinGetCurrentPosition(winobj); WinSetMarkPosition(winobj, curpos); PG_RETURN_INT64(curpos + 1); }","count":3},{"name":"api-example","value":"Datum xml_in(PG_FUNCTION_ARGS) { #ifdef USE_LIBXML char\t   *s = PG_GETARG_CSTRING(0); xmltype    *vardata; xmlDocPtr\tdoc; vardata = (xmltype *) cstring_to_text(s); * Parse the data to check if it is w...","count":3},{"name":"api-example","value":"Datum xmlconcat2(PG_FUNCTION_ARGS) { if (PG_ARGISNULL(0)) { if (PG_ARGISNULL(1)) PG_RETURN_NULL(); else PG_RETURN_XML_P(PG_GETARG_XML_P(1)); } else if (PG_ARGISNULL(1)) PG_RETURN_XML_P(PG_GETARG_XML_P...","count":3},{"name":"api-example","value":"EquivalenceClass * get_eclass_for_sort_expr(PlannerInfo *root, Expr *expr, List *opfamilies, Oid opcintype, Oid collation, Index sortref, Relids rel, bool create_it) { JoinDomain *jdomain; Relids\t\texp...","count":3},{"name":"api-example","value":"Expr * expression_planner(Expr *expr) { Node\t   *result; * Convert named-argument function calls, insert default arguments and * simplify constant subexprs */ result = eval_const_expressions(NULL, (No...","count":3},{"name":"api-example","value":"Expr * make_ands_explicit(List *andclauses) { if (andclauses == NIL) return (Expr *) makeBoolConst(true, false); else if (list_length(andclauses) == 1) return (Expr *) linitial(andclauses); else retur...","count":3},{"name":"api-example","value":"File OpenTemporaryFile(bool interXact) { File\t\tfile = 0; Assert(temporary_files_allowed);\t/* check temp file access is up */ * Make sure the current resource owner has space for this File before we * ...","count":3},{"name":"api-example","value":"File OpenWalSummaryFile(WalSummaryFile *ws, bool missing_ok) { char\t\tpath[MAXPGPATH]; File\t\tfile; snprintf(path, MAXPGPATH, XLOGDIR \"/summaries/%08X%08X%08X%08X%08X.summary\", ws->tli, LSN_FORMAT_ARGS(...","count":3},{"name":"api-example","value":"FullTransactionId GetNewTransactionId(bool isSubXact) { FullTransactionId full_xid; TransactionId xid; * Workers synchronize transaction state at the beginning of each parallel * operation, so we can'...","count":3},{"name":"api-example","value":"GISTBuildBuffers * gistInitBuildBuffers(int pagesPerBuffer, int levelStep, int maxLevel) { GISTBuildBuffers *gfbb; HASHCTL\t\thashCtl; gfbb = palloc(sizeof(GISTBuildBuffers)); gfbb->pagesPerBuffer = pag...","count":3},{"name":"api-example","value":"HRESULT STDMETHODCALLTYPE QueryInterface(Q **pp) { return QueryInterface(__uuidof(Q), (void **)pp); }","count":3},{"name":"api-example","value":"HTAB * hash_create(const char *tabname, long nelem, const HASHCTL *info, int flags) { HTAB\t   *hashp; HASHHDR    *hctl; * Hash tables now allocate space for key and data, but you have to say * how muc...","count":3},{"name":"api-example","value":"HashJoinTable ExecHashTableCreate(HashState *state, List *hashOperators, List *hashCollations, bool keepNulls) { Hash\t   *node; HashJoinTable hashtable; Plan\t   *outerNode; size_t\t\tspace_allowed; int\t...","count":3},{"name":"api-example","value":"HeapTuple PLy_exec_trigger(FunctionCallInfo fcinfo, PLyProcedure *proc) { HeapTuple\trv = NULL; PyObject   *volatile plargs = NULL; PyObject   *volatile plrv = NULL; TriggerData *tdata; TupleDesc\trel_d...","count":3},{"name":"api-example","value":"HeapTuple SPI_copytuple(HeapTuple tuple) { MemoryContext oldcxt; HeapTuple\tctuple; if (tuple == NULL) { SPI_result = SPI_ERROR_ARGUMENT; return NULL; } if (_SPI_current == NULL) { SPI_result = SPI_ERR...","count":3},{"name":"api-example","value":"HeapTuple SearchCatCache(CatCache *cache, Datum v1, Datum v2, Datum v3, Datum v4) { return SearchCatCacheInternal(cache, cache->cc_nkeys, v1, v2, v3, v4); }","count":3},{"name":"api-example","value":"HeapTuple get_catalog_object_by_oid_extended(Relation catalog, AttrNumber oidcol, Oid objectId, bool locktup) { HeapTuple\ttuple; Oid\t\t\tclassId = RelationGetRelid(catalog); int\t\t\toidCacheId = get_objec...","count":3},{"name":"api-example","value":"HeapTuple plpgsql_exec_trigger(PLpgSQL_function *func, TriggerData *trigdata) { PLpgSQL_execstate estate; ErrorContextCallback plerrcontext; int\t\t\trc; TupleDesc\ttupdesc; PLpgSQL_rec *rec_new, *rec_old...","count":3},{"name":"api-example","value":"IndexAmRoutine * GetIndexAmRoutineByAmId(Oid amoid, bool noerror) { HeapTuple\ttuple; Form_pg_am\tamform; regproc\t\tamhandler; tuple = SearchSysCache1(AMOID, ObjectIdGetDatum(amoid)); if (!HeapTupleIsVal...","count":3},{"name":"api-example","value":"IndexBuildResult * hashbuild(Relation heap, Relation index, IndexInfo *indexInfo) { IndexBuildResult *result; BlockNumber relpages; double\t\treltuples; double\t\tallvisfrac; uint32\t\tnum_buckets; long\t\tso...","count":3},{"name":"api-example","value":"IndexBuildResult * spgbuild(Relation heap, Relation index, IndexInfo *indexInfo) { IndexBuildResult *result; double\t\treltuples; SpGistBuildState buildstate; Buffer\t\tmetabuffer, rootbuffer, nullbuffer;...","count":3},{"name":"api-example","value":"IndexInfo * BuildIndexInfo(Relation index) { IndexInfo  *ii; Form_pg_index indexStruct = index->rd_index; int\t\t\ti; int\t\t\tnumAtts; numAtts = indexStruct->indnatts; if (numAtts < 1 || numAtts > INDEX_MA...","count":3},{"name":"api-example","value":"IndexScanDesc btbeginscan(Relation rel, int nkeys, int norderbys) { IndexScanDesc scan; BTScanOpaque so; Assert(norderbys == 0); scan = RelationGetIndexScan(rel, nkeys, norderbys); so = (BTScanOpaque)...","count":3},{"name":"api-example","value":"ItemPointer ginReadTuple(GinState *ginstate, OffsetNumber attnum, IndexTuple itup, int *nitems) { Pointer\t\tptr = GinGetPosting(itup); int\t\t\tnipd = GinGetNPosting(itup); ItemPointer ipd; int\t\t\tndecoded...","count":3},{"name":"api-example","value":"JoinExpr * convert_ANY_sublink_to_join(PlannerInfo *root, SubLink *sublink, Relids available_rels) { JoinExpr   *result; Query\t   *parse = root->parse; Query\t   *subselect = (Query *) sublink->subsele...","count":3},{"name":"api-example","value":"JsonLexContext * makeJsonLexContextIncremental(JsonLexContext *lex, int encoding, bool need_escapes) { if (lex == NULL) { lex = palloc0(sizeof(JsonLexContext)); lex->flags |= JSONLEX_FREE_STRUCT; } el...","count":3},{"name":"api-example","value":"JsonParseErrorType pg_parse_json(JsonLexContext *lex, JsonSemAction *sem) { #ifdef FORCE_JSON_PSTACK lex->incremental = true; lex->inc_state = palloc0(sizeof(JsonIncrementalState)); * We don't need pa...","count":3},{"name":"api-example","value":"JsonParseErrorType pg_parse_json_incremental(JsonLexContext *lex, JsonSemAction *sem, const char *json, size_t len, bool is_last) { JsonTokenType tok; JsonParseErrorType result; JsonParseContext ctx =...","count":3},{"name":"api-example","value":"LLVMValueRef llvm_pg_func(LLVMModuleRef mod, const char *funcname) { LLVMValueRef v_srcfn; LLVMValueRef v_fn; v_fn = LLVMGetNamedFunction(mod, funcname); if (v_fn) return v_fn; v_srcfn = LLVMGetNamedF...","count":3},{"name":"api-example","value":"List * GetPubPartitionOptionRelations(List *result, PublicationPartOpt pub_partopt, Oid relid) { if (get_rel_relkind(relid) == RELKIND_PARTITIONED_TABLE && pub_partopt != PUBLICATION_PART_ROOT) { List...","count":3},{"name":"api-example","value":"List * GetSchemaPublicationRelations(Oid schemaid, PublicationPartOpt pub_partopt) { Relation\tclassRel; ScanKeyData key[1]; TableScanDesc scan; HeapTuple\ttuple; List\t   *result = NIL; Assert(OidIsVali...","count":3},{"name":"api-example","value":"List * TS_execute_locations(QueryItem *curitem, void *arg, uint32 flags, TSExecuteCallback chkcond) { List\t   *result; Assert(flags == TS_EXEC_EMPTY); if (TS_execute_locations_recurse(curitem, arg, ch...","count":3},{"name":"api-example","value":"List * append_pathkeys(List *target, List *source) { ListCell   *lc; Assert(target != NIL); foreach(lc, source) { PathKey    *pk = lfirst_node(PathKey, lc); if (!pathkey_is_redundant(pk, target)) targ...","count":3},{"name":"api-example","value":"List * convert_subquery_pathkeys(PlannerInfo *root, RelOptInfo *rel, List *subquery_pathkeys, List *subquery_tlist) { List\t   *retval = NIL; int\t\t\tretvallen = 0; int\t\t\touter_query_keys = list_length(r...","count":3},{"name":"api-example","value":"List * deconstruct_jointree(PlannerInfo *root) { List\t   *result; JoinDomain *top_jdomain; List\t   *item_list = NIL; ListCell   *lc; * After this point, no more PlaceHolderInfos may be made, because *...","count":3},{"name":"api-example","value":"List * find_inheritance_children_extended(Oid parentrelId, bool omit_detached, LOCKMODE lockmode, bool *detached_exist, TransactionId *detached_xmin) { List\t   *list = NIL; Relation\trelation; SysScanD...","count":3},{"name":"api-example","value":"List * find_nonnullable_vars(Node *clause) { return find_nonnullable_vars_walker(clause, true); }","count":3},{"name":"api-example","value":"List * list_delete_last(List *list) { check_list_invariants(list); if (list == NIL) return NIL;\t\t\t\t/* would an error be better? */ if (list_length(list) <= 1) { list_free(list); return NIL; } return l...","count":3},{"name":"api-example","value":"List * list_union_ptr(const List *list1, const List *list2) { List\t   *result; const ListCell *cell; Assert(IsPointerList(list1)); Assert(IsPointerList(list2)); result = list_copy(list1); foreach(cell...","count":3},{"name":"api-example","value":"List * make_pathkeys_for_sortclauses(PlannerInfo *root, List *sortclauses, List *tlist) { List\t   *result; bool\t\tsortable; result = make_pathkeys_for_sortclauses_extended(root, &sortclauses, tlist, fa...","count":3},{"name":"api-example","value":"List * mbms_int_members(List *a, const List *b) { ListCell   *lca, *lcb; a = list_truncate(a, list_length(b)); forboth(lca, a, lcb, b) { Bitmapset  *bmsa = lfirst_node(Bitmapset, lca); const Bitmapset...","count":3},{"name":"api-example","value":"List * transformCreateSchemaStmtElements(List *schemaElts, const char *schemaName) { CreateSchemaStmtContext cxt; List\t   *result; ListCell   *elements; cxt.schemaname = schemaName; cxt.sequences = NI...","count":3},{"name":"api-example","value":"LockRowsState * ExecInitLockRows(LockRows *node, EState *estate, int eflags) { LockRowsState *lrstate; Plan\t   *outerPlan = outerPlan(node); List\t   *epq_arowmarks; ListCell   *lc; Assert(!(eflags & E...","count":3},{"name":"api-example","value":"MultirangeType * multirange_intersect_internal(Oid mltrngtypoid, TypeCacheEntry *rangetyp, int32 range_count1, RangeType **ranges1, int32 range_count2, RangeType **ranges2) { RangeType  *r1; RangeType...","count":3},{"name":"api-example","value":"MultirangeType * multirange_minus_internal(Oid mltrngtypoid, TypeCacheEntry *rangetyp, int32 range_count1, RangeType **ranges1, int32 range_count2, RangeType **ranges2) { RangeType  *r1; RangeType  *r...","count":3},{"name":"api-example","value":"NestPath * create_nestloop_path(PlannerInfo *root, RelOptInfo *joinrel, JoinType jointype, JoinCostWorkspace *workspace, JoinPathExtraData *extra, Path *outer_path, Path *inner_path, List *restrict_cl...","count":3},{"name":"api-example","value":"Node * MultiExecBitmapAnd(BitmapAndState *node) { PlanState **bitmapplans; int\t\t\tnplans; int\t\t\ti; TIDBitmap  *result = NULL; if (node->ps.instrument) InstrStartNode(node->ps.instrument); * get informa...","count":3},{"name":"api-example","value":"Node * TemporalSimplify(int32 max_precis, Node *node) { FuncExpr   *expr = castNode(FuncExpr, node); Node\t   *ret = NULL; Node\t   *typmod; Assert(list_length(expr->args) >= 2); typmod = (Node *) lseco...","count":3},{"name":"api-example","value":"Node * TupleDescGetDefault(TupleDesc tupdesc, AttrNumber attnum) { Node\t   *result = NULL; if (tupdesc->constr) { AttrDefault *attrdef = tupdesc->constr->defval; for (int i = 0; i < tupdesc->constr->n...","count":3},{"name":"api-example","value":"Node * coerce_type(ParseState *pstate, Node *node, Oid inputTypeId, Oid targetTypeId, int32 targetTypeMod, CoercionContext ccontext, CoercionForm cformat, int location) { Node\t   *result; CoercionPath...","count":3},{"name":"api-example","value":"Node * eval_const_expressions(PlannerInfo *root, Node *node) { eval_const_expressions_context context; if (root) context.boundParams = root->glob->boundParams;\t/* bound Params */ else context.boundPar...","count":3},{"name":"api-example","value":"Node * relabel_to_typmod(Node *expr, int32 typmod) { return applyRelabelType(expr, exprType(expr), typmod, exprCollation(expr), COERCE_EXPLICIT_CAST, -1, false); }","count":3},{"name":"api-example","value":"Node * transformExpr(ParseState *pstate, Node *expr, ParseExprKind exprKind) { Node\t   *result; ParseExprKind sv_expr_kind; Assert(exprKind != EXPR_KIND_NONE); sv_expr_kind = pstate->p_expr_kind; psta...","count":3},{"name":"api-example","value":"ObjectAddress AlterTSDictionary(AlterTSDictionaryStmt *stmt) { HeapTuple\ttup, newtup; Relation\trel; Oid\t\t\tdictId; ListCell   *pl; List\t   *dictoptions; Datum\t\topt; bool\t\tisnull; Datum\t\trepl_val[Natts_...","count":3},{"name":"api-example","value":"ObjectAddress CreateAccessMethod(CreateAmStmt *stmt) { Relation\trel; ObjectAddress myself; ObjectAddress referenced; Oid\t\t\tamoid; Oid\t\t\tamhandler; bool\t\tnulls[Natts_pg_am]; Datum\t\tvalues[Natts_pg_am];...","count":3},{"name":"api-example","value":"ObjectAddress CreateForeignDataWrapper(ParseState *pstate, CreateFdwStmt *stmt) { Relation\trel; Datum\t\tvalues[Natts_pg_foreign_data_wrapper]; bool\t\tnulls[Natts_pg_foreign_data_wrapper]; HeapTuple\ttupl...","count":3},{"name":"api-example","value":"ObjectAddress CreatePolicy(CreatePolicyStmt *stmt) { Relation\tpg_policy_rel; Oid\t\t\tpolicy_id; Relation\ttarget_table; Oid\t\t\ttable_id; char\t\tpolcmd; Datum\t   *role_oids; int\t\t\tnitems = 0; ArrayType  *ro...","count":3},{"name":"api-example","value":"ObjectAddress CreateTriggerFiringOn(CreateTrigStmt *stmt, const char *queryString, Oid relOid, Oid refRelOid, Oid constraintOid, Oid indexOid, Oid funcoid, Oid parentTriggerOid, Node *whenClause, bool...","count":3},{"name":"api-example","value":"ObjectAddress DefineTSParser(List *names, List *parameters) { char\t   *prsname; ListCell   *pl; Relation\tprsRel; HeapTuple\ttup; Datum\t\tvalues[Natts_pg_ts_parser]; bool\t\tnulls[Natts_pg_ts_parser]; Name...","count":3},{"name":"api-example","value":"ObjectAddress ExecAlterObjectDependsStmt(AlterObjectDependsStmt *stmt, ObjectAddress *refAddress) { ObjectAddress address; ObjectAddress refAddr; Relation\trel; address = get_object_address_rv(stmt->ob...","count":3},{"name":"api-example","value":"ObjectAddress ExecAlterObjectSchemaStmt(AlterObjectSchemaStmt *stmt, ObjectAddress *oldSchemaAddr) { ObjectAddress address; Oid\t\t\toldNspOid; switch (stmt->objectType) { case OBJECT_EXTENSION: address ...","count":3},{"name":"api-example","value":"ObjectAddress RenameConstraint(RenameStmt *stmt) { Oid\t\t\trelid = InvalidOid; Oid\t\t\ttypid = InvalidOid; if (stmt->renameType == OBJECT_DOMCONSTRAINT) { Relation\trel; HeapTuple\ttup; typid = typenameType...","count":3},{"name":"api-example","value":"ObjectAddress get_object_address_rv(ObjectType objtype, RangeVar *rel, List *object, Relation *relp, LOCKMODE lockmode, bool missing_ok) { if (rel) { object = lcons(makeString(rel->relname), object); ...","count":3},{"name":"api-example","value":"ObjectAddress makeOperatorDependencies(HeapTuple tuple, bool makeExtensionDep, bool isUpdate) { Form_pg_operator oper = (Form_pg_operator) GETSTRUCT(tuple); ObjectAddress myself, referenced; ObjectAdd...","count":3},{"name":"api-example","value":"OffsetNumber gintuple_get_attrnum(GinState *ginstate, IndexTuple tuple) { OffsetNumber colN; if (ginstate->oneCol) { colN = FirstOffsetNumber; } else { Datum\t\tres; bool\t\tisnull; * First attribute is a...","count":3},{"name":"api-example","value":"Oid AlterDatabase(ParseState *pstate, AlterDatabaseStmt *stmt, bool isTopLevel) { Relation\trel; Oid\t\t\tdboid; HeapTuple\ttuple, newtuple; Form_pg_database datform; ScanKeyData scankey; SysScanDesc scan;...","count":3},{"name":"api-example","value":"Oid AlterRole(ParseState *pstate, AlterRoleStmt *stmt) { Datum\t\tnew_record[Natts_pg_authid] = {0}; bool\t\tnew_record_nulls[Natts_pg_authid] = {0}; bool\t\tnew_record_repl[Natts_pg_authid] = {0}; Relation...","count":3},{"name":"api-example","value":"Oid CreateConstraintEntry(const char *constraintName, Oid constraintNamespace, char constraintType, bool isDeferrable, bool isDeferred, bool isValidated, Oid parentConstrId, Oid relId, const int16 *co...","count":3},{"name":"api-example","value":"Oid GetDefaultOpClass(Oid type_id, Oid am_id) { Oid\t\t\tresult = InvalidOid; int\t\t\tnexact = 0; int\t\t\tncompatible = 0; int\t\t\tncompatiblepreferred = 0; Relation\trel; ScanKeyData skey[1]; SysScanDesc scan;...","count":3},{"name":"api-example","value":"Oid GetDefaultTablespace(char relpersistence, bool partitioned) { Oid\t\t\tresult; if (relpersistence == RELPERSISTENCE_TEMP) { PrepareTempTablespaces(); return GetNextTempTableSpace(); } if (default_tab...","count":3},{"name":"api-example","value":"Oid GetTopMostAncestorInPublication(Oid puboid, List *ancestors, int *ancestor_level) { ListCell   *lc; Oid\t\t\ttopmost_relid = InvalidOid; int\t\t\tlevel = 0; * Find the \"topmost\" ancestor that is in this...","count":3},{"name":"api-example","value":"Oid OpclassnameGetOpcid(Oid amid, const char *opcname) { Oid\t\t\topcid; ListCell   *l; recomputeNamespacePath(); foreach(l, activeSearchPath) { Oid\t\t\tnamespaceId = lfirst_oid(l); if (namespaceId == myTe...","count":3},{"name":"api-example","value":"Oid RangeVarGetRelidExtended(const RangeVar *relation, LOCKMODE lockmode, uint32 flags, RangeVarGetRelidCallback callback, void *callback_arg) { uint64\t\tinval_count; Oid\t\t\trelId; Oid\t\t\toldRelId = Inva...","count":3},{"name":"api-example","value":"Oid ResolveOpClass(const List *opclass, Oid attrType, const char *accessMethodName, Oid accessMethodId) { char\t   *schemaname; char\t   *opcname; HeapTuple\ttuple; Form_pg_opclass opform; Oid\t\t\topClassI...","count":3},{"name":"api-example","value":"Oid get_collation_oid(List *collname, bool missing_ok) { char\t   *schemaname; char\t   *collation_name; int32\t\tdbencoding = GetDatabaseEncoding(); Oid\t\t\tnamespaceId; Oid\t\t\tcolloid; ListCell   *l; Decon...","count":3},{"name":"api-example","value":"Oid get_object_namespace(const ObjectAddress *address) { int\t\t\tcache; HeapTuple\ttuple; Oid\t\t\toid; const ObjectPropertyType *property; property = get_object_property_data(address->classId); if (propert...","count":3},{"name":"api-example","value":"Oid get_statistics_object_oid(List *names, bool missing_ok) { char\t   *schemaname; char\t   *stats_name; Oid\t\t\tnamespaceId; Oid\t\t\tstats_oid = InvalidOid; ListCell   *l; DeconstructQualifiedName(names, ...","count":3},{"name":"api-example","value":"Oid select_common_type(ParseState *pstate, List *exprs, const char *context, Node **which_expr) { Node\t   *pexpr; Oid\t\t\tptype; TYPCATEGORY pcategory; bool\t\tpispreferred; ListCell   *lc; Assert(exprs !...","count":3},{"name":"api-example","value":"PGShmemHeader * PGSharedMemoryCreate(Size size, PGShmemHeader **shim) { void\t   *memAddress; PGShmemHeader *hdr; HANDLE\t\thmap, hmap2; char\t   *szShareMem; int\t\t\ti; DWORD\t\tsize_high; DWORD\t\tsize_low; S...","count":3},{"name":"api-example","value":"PG_STAT_GET_RELENTRY_INT64(analyze_count)","count":3},{"name":"api-example","value":"PG_STAT_GET_XACT_RELENTRY_INT64(numscans)","count":3},{"name":"api-example","value":"PGcancel * PQgetCancel(PGconn *conn) { PGcancel   *cancel; if (!conn) return NULL; if (conn->sock == PGINVALID_SOCKET) return NULL; cancel = malloc(sizeof(PGcancel)); if (cancel == NULL) return NULL; ...","count":3},{"name":"api-example","value":"PGresult * ExecuteSqlQueryForSingleRow(Archive *fout, const char *query) { PGresult   *res; int\t\t\tntups; res = ExecuteSqlQuery(fout, query, PGRES_TUPLES_OK); ntups = PQntuples(res); if (ntups != 1) pg...","count":3},{"name":"api-example","value":"PGresult * PQdescribePrepared(PGconn *conn, const char *stmt) { if (!PQexecStart(conn)) return NULL; if (!PQsendTypedCommand(conn, PqMsg_Describe, 'S', stmt)) return NULL; return PQexecFinish(conn); }","count":3},{"name":"api-example","value":"PGresult * PSQLexec(const char *query) { PGresult   *res; if (!pset.db) { pg_log_error(\"You are currently not connected to a database.\"); return NULL; } if (pset.echo_hidden != PSQL_ECHO_HIDDEN_OFF) {...","count":3},{"name":"api-example","value":"PQconninfoOption * PQconndefaults(void) { PQExpBufferData errorBuf; PQconninfoOption *connOptions; initPQExpBuffer(&errorBuf); if (PQExpBufferDataBroken(errorBuf)) return NULL;\t\t\t/* out of memory alre...","count":3},{"name":"api-example","value":"ParallelVacuumState * parallel_vacuum_init(Relation rel, Relation *indrels, int nindexes, int nrequested_workers, int vac_work_mem, int elevel, BufferAccessStrategy bstrategy) { ParallelVacuumState *p...","count":3},{"name":"api-example","value":"PartitionBoundSpec * transformPartitionBound(ParseState *pstate, Relation parent, PartitionBoundSpec *spec) { PartitionBoundSpec *result_spec; PartitionKey key = RelationGetPartitionKey(parent); char\t...","count":3},{"name":"api-example","value":"Path * create_seqscan_path(PlannerInfo *root, RelOptInfo *rel, Relids required_outer, int parallel_workers) { Path\t   *pathnode = makeNode(Path); pathnode->pathtype = T_SeqScan; pathnode->parent = rel...","count":3},{"name":"api-example","value":"PgStat_ArchiverStats * pgstat_fetch_stat_archiver(void) { pgstat_snapshot_fixed(PGSTAT_KIND_ARCHIVER); return &pgStatLocal.snapshot.archiver; }","count":3},{"name":"api-example","value":"PgStat_EntryRef * pgstat_get_entry_ref(PgStat_Kind kind, Oid dboid, Oid objoid, bool create, bool *created_entry) { PgStat_HashKey key; PgStatShared_HashEntry *shhashent; PgStatShared_Common *shheader...","count":3},{"name":"api-example","value":"PgStat_StatDBEntry * pgstat_fetch_stat_dbentry(Oid dboid) { return (PgStat_StatDBEntry *) pgstat_fetch_entry(PGSTAT_KIND_DATABASE, dboid, InvalidOid); }","count":3},{"name":"api-example","value":"Plan * set_plan_references(PlannerInfo *root, Plan *plan) { Plan\t   *result; PlannerGlobal *glob = root->glob; int\t\t\trtoffset = list_length(glob->finalrtable); ListCell   *lc; * Add all the query's RT...","count":3},{"name":"api-example","value":"PostgresPollingStatusType PQcancelPoll(PGcancelConn *cancelConn) { PGconn\t   *conn = &cancelConn->conn; int\t\t\tn; * We leave most of the connection establishment to PQconnectPoll, since * it's very sim...","count":3},{"name":"api-example","value":"PostgresPollingStatusType pgtls_open_client(PGconn *conn) { if (conn->ssl == NULL) { * Create a connection-specific SSL object, and load client * certificate, private key, and trusted CA certs. */ if ...","count":3},{"name":"api-example","value":"PredicateLockData * GetPredicateLockStatusData(void) { PredicateLockData *data; int\t\t\ti; int\t\t\tels, el; HASH_SEQ_STATUS seqstat; PREDICATELOCK *predlock; data = (PredicateLockData *) palloc(sizeof(Pre...","count":3},{"name":"api-example","value":"ProcNumber GetTempNamespaceProcNumber(Oid namespaceId) { int\t\t\tresult; char\t   *nspname; nspname = get_namespace_name(namespaceId); if (!nspname) return INVALID_PROC_NUMBER; /* no such namespace? */ i...","count":3},{"name":"api-example","value":"ProjectionInfo * ExecBuildUpdateProjection(List *targetList, bool evalTargetList, List *targetColnos, TupleDesc relDesc, ExprContext *econtext, TupleTableSlot *slot, PlanState *parent) { ProjectionInf...","count":3},{"name":"api-example","value":"PublicationInfo * getPublications(Archive *fout, int *numPublications) { DumpOptions *dopt = fout->dopt; PQExpBuffer query; PGresult   *res; PublicationInfo *pubinfo; int\t\t\ti_tableoid; int\t\t\ti_oid; in...","count":3},{"name":"api-example","value":"RBTree * rbt_create(Size node_size, rbt_comparator comparator, rbt_combiner combiner, rbt_allocfunc allocfunc, rbt_freefunc freefunc, void *arg) { RBTree\t   *tree = (RBTree *) palloc(sizeof(RBTree)); ...","count":3},{"name":"api-example","value":"RelOptInfo * plan_set_operations(PlannerInfo *root) { Query\t   *parse = root->parse; SetOperationStmt *topop = castNode(SetOperationStmt, parse->setOperations); Node\t   *node; RangeTblEntry *leftmostR...","count":3},{"name":"api-example","value":"Relation RelationIdGetRelation(Oid relationId) { Relation\trd; Assert(IsTransactionState()); * first try to find reldesc in the cache */ RelationIdCacheLookup(relationId, rd); if (RelationIsValid(rd)) ...","count":3},{"name":"api-example","value":"Relation table_openrv(const RangeVar *relation, LOCKMODE lockmode) { Relation\tr; r = relation_openrv(relation, lockmode); validate_relation_kind(r); return r; }","count":3},{"name":"api-example","value":"Relation try_index_open(Oid relationId, LOCKMODE lockmode) { Relation\tr; r = try_relation_open(relationId, lockmode); if (!r) return NULL; validate_relation_kind(r); return r; }","count":3},{"name":"api-example","value":"Relids find_nonnullable_rels(Node *clause) { return find_nonnullable_rels_walker(clause, true); }","count":3},{"name":"api-example","value":"ReorderBuffer * ReorderBufferAllocate(void) { ReorderBuffer *buffer; HASHCTL\t\thash_ctl; MemoryContext new_ctx; Assert(MyReplicationSlot != NULL); new_ctx = AllocSetContextCreate(CurrentMemoryContext, ...","count":3},{"name":"api-example","value":"SPIPlanPtr SPI_prepare_cursor(const char *src, int nargs, Oid *argtypes, int cursorOptions) { _SPI_plan\tplan; SPIPlanPtr\tresult; if (src == NULL || nargs < 0 || (nargs > 0 && argtypes == NULL)) { SPI_...","count":3},{"name":"api-example","value":"SV * plperl_spi_fetchrow(char *cursor) { SV\t\t   *row; * Execute the FETCH inside a sub-transaction, so we can cope with errors * sanely */ MemoryContext oldcontext = CurrentMemoryContext; ResourceOwne...","count":3},{"name":"api-example","value":"SV * plperl_spi_query(char *query) { SV\t\t   *cursor; * Execute the query inside a sub-transaction, so we can cope with errors * sanely */ MemoryContext oldcontext = CurrentMemoryContext; ResourceOwner...","count":3},{"name":"api-example","value":"SampleScanState * ExecInitSampleScan(SampleScan *node, EState *estate, int eflags) { SampleScanState *scanstate; TableSampleClause *tsc = node->tablesample; TsmRoutine *tsm; Assert(outerPlan(node) == ...","count":3},{"name":"api-example","value":"Size BackendStatusShmemSize(void) { Size\t\tsize; size = mul_size(sizeof(PgBackendStatus), NumBackendStatSlots); size = add_size(size, mul_size(NAMEDATALEN, NumBackendStatSlots)); size = add_size(size, ...","count":3},{"name":"api-example","value":"Size BufTableShmemSize(int size) { return hash_estimate_size(size, sizeof(BufferLookupEnt)); }","count":3},{"name":"api-example","value":"Size CLOGShmemSize(void) { return SimpleLruShmemSize(CLOGShmemBuffers(), CLOG_LSNS_PER_PAGE); }","count":3},{"name":"api-example","value":"Size GetRecordedFreeSpace(Relation rel, BlockNumber heapBlk) { FSMAddress\taddr; uint16\t\tslot; Buffer\t\tbuf; uint8\t\tcat; addr = fsm_get_location(heapBlk, &slot); buf = fsm_readbuf(rel, addr, false); if ...","count":3},{"name":"api-example","value":"Size ProcArrayShmemSize(void) { Size\t\tsize; #define PROCARRAY_MAXPROCS\t(MaxBackends + max_prepared_xacts) size = offsetof(ProcArrayStruct, pgprocnos); size = add_size(size, mul_size(sizeof(int), PROCA...","count":3},{"name":"api-example","value":"Size ProcSignalShmemSize(void) { Size\t\tsize; size = mul_size(NumProcSignalSlots, sizeof(ProcSignalSlot)); size = add_size(size, offsetof(ProcSignalHeader, psh_slot)); return size; }","count":3},{"name":"api-example","value":"Size SimpleLruShmemSize(int nslots, int nlsns) { int\t\t\tnbanks = nslots / SLRU_BANK_SIZE; Size\t\tsz; Assert(nslots <= SLRU_MAX_ALLOWED_BUFFERS); Assert(nslots % SLRU_BANK_SIZE == 0); sz = MAXALIGN(sizeo...","count":3},{"name":"api-example","value":"Size StatsShmemSize(void) { Size\t\tsz; sz = MAXALIGN(sizeof(PgStat_ShmemControl)); sz = add_size(sz, pgstat_dsa_init_size()); return sz; }","count":3},{"name":"api-example","value":"Size WaitEventCustomShmemSize(void) { Size\t\tsz; sz = MAXALIGN(sizeof(WaitEventCustomCounterData)); sz = add_size(sz, hash_estimate_size(WAIT_EVENT_CUSTOM_HASH_MAX_SIZE, sizeof(WaitEventCustomEntryByIn...","count":3},{"name":"api-example","value":"Size index_parallelscan_estimate(Relation indexRelation, int nkeys, int norderbys, Snapshot snapshot) { Size\t\tnbytes; Assert(snapshot != InvalidSnapshot); RELATION_CHECKS; nbytes = offsetof(ParallelIn...","count":3},{"name":"api-example","value":"Size table_block_parallelscan_initialize(Relation rel, ParallelTableScanDesc pscan) { ParallelBlockTableScanDesc bpscan = (ParallelBlockTableScanDesc) pscan; bpscan->base.phs_relid = RelationGetRelid(...","count":3},{"name":"api-example","value":"Size toast_raw_datum_size(Datum value) { struct varlena *attr = (struct varlena *) DatumGetPointer(value); Size\t\tresult; if (VARATT_IS_EXTERNAL_ONDISK(attr)) { struct varatt_external toast_pointer; VA...","count":3},{"name":"api-example","value":"Snapshot GetSnapshotData(Snapshot snapshot) { ProcArrayStruct *arrayP = procArray; TransactionId *other_xids = ProcGlobal->xids; TransactionId xmin; TransactionId xmax; int\t\t\tcount = 0; int\t\t\tsubcount...","count":3},{"name":"api-example","value":"Snapshot GetTransactionSnapshot(void) { * Return historic snapshot if doing logical decoding. We'll never need a * non-historic transaction snapshot in this (sub-)transaction, so there's * no need to ...","count":3},{"name":"api-example","value":"Snapshot SnapBuildGetOrBuildSnapshot(SnapBuild *builder) { Assert(builder->state == SNAPBUILD_CONSISTENT); if (builder->snapshot == NULL) { builder->snapshot = SnapBuildBuildSnapshot(builder); SnapBui...","count":3},{"name":"api-example","value":"Snapshot SnapBuildInitialSnapshot(SnapBuild *builder) { Snapshot\tsnap; TransactionId xid; TransactionId safeXid; TransactionId *newxip; int\t\t\tnewxcnt = 0; Assert(XactIsoLevel == XACT_REPEATABLE_READ);...","count":3},{"name":"api-example","value":"SubPlanState * ExecInitSubPlan(SubPlan *subplan, PlanState *parent) { SubPlanState *sstate = makeNode(SubPlanState); EState\t   *estate = parent->state; sstate->subplan = subplan; sstate->planstate = (...","count":3},{"name":"api-example","value":"TSVECTORCMPFUNC(lt, <, BOOL)","count":3},{"name":"api-example","value":"TableInfo * findTableByOid(Oid oid) { CatalogId\tcatId; DumpableObject *dobj; catId.tableoid = RelationRelationId; catId.oid = oid; dobj = findObjectByCatalogId(catId); Assert(dobj == NULL || dobj->obj...","count":3},{"name":"api-example","value":"TableScanDesc heap_beginscan(Relation relation, Snapshot snapshot, int nkeys, ScanKey key, ParallelTableScanDesc parallel_scan, uint32 flags) { HeapScanDesc scan; * increment relation ref count while ...","count":3},{"name":"api-example","value":"TempNamespaceStatus checkTempNamespaceStatus(Oid namespaceId) { PGPROC\t   *proc; ProcNumber\tprocNumber; Assert(OidIsValid(MyDatabaseId)); procNumber = GetTempNamespaceProcNumber(namespaceId); if (proc...","count":3},{"name":"api-example","value":"TimestampTz pgstat_get_stat_snapshot_timestamp(bool *have_snapshot) { if (force_stats_snapshot_clear) pgstat_clear_snapshot(); if (pgStatLocal.snapshot.mode == PGSTAT_FETCH_CONSISTENCY_SNAPSHOT) { *ha...","count":3},{"name":"api-example","value":"TsmRoutine * GetTsmRoutine(Oid tsmhandler) { Datum\t\tdatum; TsmRoutine *routine; datum = OidFunctionCall1(tsmhandler, PointerGetDatum(NULL)); routine = (TsmRoutine *) DatumGetPointer(datum); if (routin...","count":3},{"name":"api-example","value":"TupleConversionMap * convert_tuples_by_name(TupleDesc indesc, TupleDesc outdesc) { AttrMap    *attrMap; attrMap = build_attrmap_by_name_if_req(indesc, outdesc, false); if (attrMap == NULL) { return NU...","count":3},{"name":"api-example","value":"TupleDesc getSpGistTupleDesc(Relation index, SpGistTypeDesc *keyType) { TupleDesc\toutTupDesc; Form_pg_attribute att; if (keyType->type == TupleDescAttr(RelationGetDescr(index), spgKeyColumn)->atttypid...","count":3},{"name":"api-example","value":"TupleHashTable BuildTupleHashTable(PlanState *parent, TupleDesc inputDesc, int numCols, AttrNumber *keyColIdx, const Oid *eqfuncoids, FmgrInfo *hashfunctions, Oid *collations, long nbuckets, Size addi...","count":3},{"name":"api-example","value":"TupleTableSlot * EvalPlanQual(EPQState *epqstate, Relation relation, Index rti, TupleTableSlot *inputslot) { TupleTableSlot *slot; TupleTableSlot *testslot; Assert(rti > 0); * Need to run a recheck su...","count":3},{"name":"api-example","value":"TupleTableSlot * table_slot_create(Relation relation, List **reglist) { const TupleTableSlotOps *tts_cb; TupleTableSlot *slot; tts_cb = table_slot_callbacks(relation); slot = MakeSingleTupleTableSlot(...","count":3},{"name":"api-example","value":"Tuplestorestate * ExecMakeTableFunctionResult(SetExprState *setexpr, ExprContext *econtext, MemoryContext argContext, TupleDesc expectedDesc, bool randomAccess) { Tuplestorestate *tupstore = NULL; Tup...","count":3},{"name":"api-example","value":"TypeInfo * getTypes(Archive *fout, int *numTypes) { PGresult   *res; int\t\t\tntups; int\t\t\ti; PQExpBuffer query = createPQExpBuffer(); TypeInfo   *tyinfo; ShellTypeInfo *stinfo; int\t\t\ti_tableoid; int\t\t\ti...","count":3},{"name":"api-example","value":"ValuesScanState * ExecInitValuesScan(ValuesScan *node, EState *estate, int eflags) { ValuesScanState *scanstate; TupleDesc\ttupdesc; ListCell   *vtl; int\t\t\ti; PlanState  *planstate; * ValuesScan should...","count":3},{"name":"api-example","value":"WS2TCPIP_INLINE int idealsendbacklogquery(SOCKET s, ULONG *isb) { DWORD bytes; return WSAIoctl(s, SIO_IDEAL_SEND_BACKLOG_QUERY, NULL, 0, isb, sizeof(*isb), &bytes, NULL, NULL); }","count":3},{"name":"api-example","value":"XidStatus TransactionIdGetStatus(TransactionId xid, XLogRecPtr *lsn) { int64\t\tpageno = TransactionIdToPage(xid); int\t\t\tbyteno = TransactionIdToByte(xid); int\t\t\tbshift = TransactionIdToBIndex(xid) * CL...","count":3},{"name":"api-example","value":"__mingw_ovr _off_t ftello(FILE *_File) { return ftell(_File); }","count":3},{"name":"api-example","value":"__mingw_ovr int __cdecl _vfprintf_p_l(FILE *_File, const char *_Format, _locale_t _Locale, va_list _ArgList) { return __stdio_common_vfprintf_p(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _File, _Format, _Loc...","count":3},{"name":"api-example","value":"__mingw_ovr int __cdecl _vfprintf_s_l(FILE *_File, const char *_Format, _locale_t _Locale, va_list _ArgList) { return __stdio_common_vfprintf_s(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _File, _Format, _Loc...","count":3},{"name":"api-example","value":"__mingw_ovr int __cdecl _vfscanf_s_l(FILE *_File, const char *_Format, _locale_t _Locale, va_list _ArgList) { return __stdio_common_vfscanf(_CRT_INTERNAL_SCANF_SECURECRT, _File, _Format, _Locale, _Arg...","count":3},{"name":"api-example","value":"__mingw_ovr int __cdecl _vscprintf_p_l(const char *_Format, _locale_t _Locale, va_list _ArgList) { return __stdio_common_vsprintf_p(_CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR, NULL, 0, _Format, _...","count":3},{"name":"api-example","value":"__mingw_ovr int __cdecl _vsprintf_p_l(char *_DstBuf, size_t _MaxCount, const char *_Format, _locale_t _Locale, va_list _ArgList) { return __stdio_common_vsprintf_p(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, ...","count":3},{"name":"api-example","value":"__mingw_ovr int __cdecl _vsscanf_s_l(const char *_Src, const char *_Format, _locale_t _Locale, va_list _ArgList) { return __stdio_common_vsscanf(_CRT_INTERNAL_SCANF_SECURECRT, _Src, (size_t)-1, _Forma...","count":3},{"name":"api-example","value":"__mingw_ovr int __cdecl _vswscanf_s_l(const wchar_t *_Src, const wchar_t *_Format, _locale_t _Locale, va_list _ArgList) { return __stdio_common_vswscanf(_CRT_INTERNAL_LOCAL_SCANF_OPTIONS | _CRT_INTERN...","count":3},{"name":"api-example","value":"backslashResult HandleSlashCmds(PsqlScanState scan_state, ConditionalStack cstack, PQExpBuffer query_buf, PQExpBuffer previous_buf) { backslashResult status; char\t   *cmd; char\t   *arg; Assert(scan_st...","count":3},{"name":"api-example","value":"bool CheckIndexCompatible(Oid oldId, const char *accessMethodName, const List *attributeList, const List *exclusionOpNames) { bool\t\tisconstraint; Oid\t\t   *typeIds; Oid\t\t   *collationIds; Oid\t\t   *opcl...","count":3},{"name":"api-example","value":"bool CompareIndexInfo(const IndexInfo *info1, const IndexInfo *info2, const Oid *collations1, const Oid *collations2, const Oid *opfamilies1, const Oid *opfamilies2, const AttrMap *attmap) { int\t\t\ti; ...","count":3},{"name":"api-example","value":"bool ConstraintImpliedByRelConstraint(Relation scanrel, List *testConstraint, List *provenConstraint) { List\t   *existConstraint = list_copy(provenConstraint); TupleConstr *constr = RelationGetDescr(s...","count":3},{"name":"api-example","value":"bool DecodeXLogRecord(XLogReaderState *state, DecodedXLogRecord *decoded, XLogRecord *record, XLogRecPtr lsn, char **errormsg) { * read next _size bytes from record buffer, but check for overrun first...","count":3},{"name":"api-example","value":"bool ECPGallocate_desc(int line, const char *name) { struct descriptor *new; struct sqlca_t *sqlca = ECPGget_sqlca(); if (sqlca == NULL) { ecpg_raise(line, ECPG_OUT_OF_MEMORY, ECPG_SQLSTATE_ECPG_OUT_O...","count":3},{"name":"api-example","value":"bool ECPGget_desc(int lineno, const char *desc_name, int index,...) { va_list\t\targs; PGresult   *ECPGresult; enum ECPGdtype type; int\t\t\tntuples, act_tuple; struct variable data_var; struct sqlca_t *sq...","count":3},{"name":"api-example","value":"bool EvalPlanQualFetchRowMark(EPQState *epqstate, Index rti, TupleTableSlot *slot) { ExecAuxRowMark *earm = epqstate->relsubs_rowmark[rti - 1]; ExecRowMark *erm; Datum\t\tdatum; bool\t\tisNull; Assert(ear...","count":3},{"name":"api-example","value":"bool ExecBRDeleteTriggersNew(EState *estate, EPQState *epqstate, ResultRelInfo *relinfo, ItemPointer tupleid, HeapTuple fdw_trigtuple, TupleTableSlot **epqslot, TM_Result *tmresult, TM_FailureData *tm...","count":3},{"name":"api-example","value":"bool ExecBRInsertTriggers(EState *estate, ResultRelInfo *relinfo, TupleTableSlot *slot) { TriggerDesc *trigdesc = relinfo->ri_TrigDesc; HeapTuple\tnewtuple = NULL; bool\t\tshould_free; TriggerData LocTri...","count":3},{"name":"api-example","value":"bool ExecCheckOneRelPerms(RTEPermissionInfo *perminfo) { AclMode\t\trequiredPerms; AclMode\t\trelPerms; AclMode\t\tremainingPerms; Oid\t\t\tuserid; Oid\t\t\trelOid = perminfo->relid; requiredPerms = perminfo->req...","count":3},{"name":"api-example","value":"bool ExecParallelPrepHashTableForUnmatched(HashJoinState *hjstate) { HashJoinTable hashtable = hjstate->hj_HashTable; int\t\t\tcurbatch = hashtable->curbatch; ParallelHashJoinBatch *batch = hashtable->ba...","count":3},{"name":"api-example","value":"bool IsBackendPid(int pid) { return (BackendPidGetProc(pid) != NULL); }","count":3},{"name":"api-example","value":"bool IsSystemClass(Oid relid, Form_pg_class reltuple) { return (IsCatalogRelationOid(relid) || IsToastClass(reltuple)); }","count":3},{"name":"api-example","value":"bool IsToastRelation(Relation relation) { * What we actually check is whether the relation belongs to a pg_toast * namespace.  This should be equivalent because of restrictions that are * enforced els...","count":3},{"name":"api-example","value":"bool LogicalReplicationSlotHasPendingWal(XLogRecPtr end_of_wal) { bool\t\thas_pending_wal = false; Assert(MyReplicationSlot); PG_TRY(); { LogicalDecodingContext *ctx; * Create our decoding context in fa...","count":3},{"name":"api-example","value":"bool PGSharedMemoryIsInUse(unsigned long id1, unsigned long id2) { char\t   *szShareMem; HANDLE\t\thmap; szShareMem = GetSharedMemName(); hmap = OpenFileMapping(FILE_MAP_READ, FALSE, szShareMem); free(sz...","count":3},{"name":"api-example","value":"bool PageIsPredicateLocked(Relation relation, BlockNumber blkno) { PREDICATELOCKTARGETTAG targettag; uint32\t\ttargettaghash; LWLock\t   *partitionLock; PREDICATELOCKTARGET *target; SET_PREDICATELOCKTARG...","count":3},{"name":"api-example","value":"bool PortalRun(Portal portal, long count, bool isTopLevel, bool run_once, DestReceiver *dest, DestReceiver *altdest, QueryCompletion *qc) { bool\t\tresult; uint64\t\tnprocessed; ResourceOwner saveTopTrans...","count":3},{"name":"api-example","value":"bool RE_compile_and_execute(text *text_re, char *dat, int dat_len, int cflags, Oid collation, int nmatch, regmatch_t *pmatch) { regex_t    *re; if (nmatch < 2) cflags |= REG_NOSUB; re = RE_compile_and...","count":3},{"name":"api-example","value":"bool RecheckDataDirLockFile(void) { int\t\t\tfd; int\t\t\tlen; long\t\tfile_pid; char\t\tbuffer[BLCKSZ]; fd = open(DIRECTORY_LOCK_FILE, O_RDWR | PG_BINARY, 0); if (fd < 0) { * There are many foreseeable false-p...","count":3},{"name":"api-example","value":"bool TS_execute(QueryItem *curitem, void *arg, uint32 flags, TSExecuteCallback chkcond) { * If we get TS_MAYBE from the recursion, return true.  We could only see * that result if the caller passed TS...","count":3},{"name":"api-example","value":"bool WalSummariesAreComplete(List *wslist, XLogRecPtr start_lsn, XLogRecPtr end_lsn, XLogRecPtr *missing_lsn) { XLogRecPtr\tcurrent_lsn = start_lsn; ListCell   *lc; if (wslist == NIL) { *missing_lsn = ...","count":3},{"name":"api-example","value":"bool XLogHaveInvalidPages(void) { if (invalid_page_tab != NULL && hash_get_num_entries(invalid_page_tab) > 0) return true; return false; }","count":3},{"name":"api-example","value":"bool analyze_requires_snapshot(RawStmt *parseTree) { * Currently, this should return true in exactly the same cases that * stmt_requires_parse_analysis() does, so we just invoke that function * rather...","count":3},{"name":"api-example","value":"bool brinRevmapDesummarizeRange(Relation idxrel, BlockNumber heapBlk) { BrinRevmap *revmap; BlockNumber pagesPerRange; RevmapContents *contents; ItemPointerData *iptr; ItemPointerData invalidIptr; Blo...","count":3},{"name":"api-example","value":"bool brin_can_do_samepage_update(Buffer buffer, Size origsz, Size newsz) { return ((newsz <= origsz) || PageGetExactFreeSpace(BufferGetPage(buffer)) >= (newsz - origsz)); }","count":3},{"name":"api-example","value":"bool btgettuple(IndexScanDesc scan, ScanDirection dir) { BTScanOpaque so = (BTScanOpaque) scan->opaque; bool\t\tres; scan->xs_recheck = false; do { * If we've already initialized this scan, we can just ...","count":3},{"name":"api-example","value":"bool buildDefaultACLCommands(const char *type, const char *nspname, const char *acls, const char *acldefault, const char *owner, int remoteVersion, PQExpBuffer sql) { PQExpBuffer prefix; prefix = crea...","count":3},{"name":"api-example","value":"bool check_functional_grouping(Oid relid, Index varno, Index varlevelsup, List *grouping_columns, List **constraintDeps) { Bitmapset  *pkattnos; Bitmapset  *groupbyattnos; Oid\t\t\tconstraintOid; ListCel...","count":3},{"name":"api-example","value":"bool check_functions_in_node(Node *node, check_function_callback checker, void *context) { switch (nodeTag(node)) { case T_Aggref: { Aggref\t   *expr = (Aggref *) node; if (checker(expr->aggfnoid, cont...","count":3},{"name":"api-example","value":"bool check_role(char **newval, void **extra, GucSource source) { HeapTuple\troleTup; Oid\t\t\troleid; bool\t\tis_superuser; role_auth_extra *myextra; Form_pg_authid roleform; if (strcmp(*newval, \"none\") == ...","count":3},{"name":"api-example","value":"bool check_transaction_buffers(int *newval, void **extra, GucSource source) { return check_slru_buffers(\"transaction_buffers\", newval); }","count":3},{"name":"api-example","value":"bool check_transaction_read_only(bool *newval, void **extra, GucSource source) { if (*newval == false && XactReadOnly && IsTransactionState() && !InitializingParallelWorker) { if (IsSubTransaction()) ...","count":3},{"name":"api-example","value":"bool debugtup(TupleTableSlot *slot, DestReceiver *self) { TupleDesc\ttypeinfo = slot->tts_tupleDescriptor; int\t\t\tnatts = typeinfo->natts; int\t\t\ti; Datum\t\tattr; char\t   *value; bool\t\tisnull; Oid\t\t\ttypou...","count":3},{"name":"api-example","value":"bool describeAggregates(const char *pattern, bool verbose, bool showSystem) { PQExpBufferData buf; PGresult   *res; printQueryOpt myopt = pset.popt; initPQExpBuffer(&buf); printfPQExpBuffer(&buf, \"SEL...","count":3},{"name":"api-example","value":"bool describeRoles(const char *pattern, bool verbose, bool showSystem) { PQExpBufferData buf; PGresult   *res; printTableContent cont; printTableOpt myopt = pset.popt.topt; int\t\t\tncols = 2; int\t\t\tnrow...","count":3},{"name":"api-example","value":"bool describeTablespaces(const char *pattern, bool verbose) { PQExpBufferData buf; PGresult   *res; printQueryOpt myopt = pset.popt; initPQExpBuffer(&buf); printfPQExpBuffer(&buf, \"SELECT spcname AS \\...","count":3},{"name":"api-example","value":"bool do_lo_export(const char *loid_arg, const char *filename_arg) { int\t\t\tstatus; bool\t\town_transaction; if (!start_lo_xact(\"\\\\lo_export\", &own_transaction)) return false; SetCancelConn(NULL); status ...","count":3},{"name":"api-example","value":"bool ecpg_build_params(struct statement *stmt) { struct variable *var; int\t\t\tdesc_counter = 0; int\t\t\tposition = 0; const char *value; bool\t\tstd_strings = false; value = PQparameterStatus(stmt->connect...","count":3},{"name":"api-example","value":"bool ecpg_do_prologue(int lineno, const int compat, const int force_indicator, const char *connection_name, const bool questionmarks, enum ECPG_statement_type statement_type, const char *query, va_lis...","count":3},{"name":"api-example","value":"bool ecpg_register_prepared_stmt(struct statement *stmt) { struct statement *prep_stmt; struct prepared_statement *this; struct connection *con = stmt->connection; struct prepared_statement *prev = NU...","count":3},{"name":"api-example","value":"bool equalTupleDescs(TupleDesc tupdesc1, TupleDesc tupdesc2) { int\t\t\ti, n; if (tupdesc1->natts != tupdesc2->natts) return false; if (tupdesc1->tdtypeid != tupdesc2->tdtypeid) return false; for (i = 0;...","count":3},{"name":"api-example","value":"bool extract_query_dependencies_walker(Node *node, PlannerInfo *context) { if (node == NULL) return false; Assert(!IsA(node, PlaceHolderVar)); if (IsA(node, Query)) { Query\t   *query = (Query *) node;...","count":3},{"name":"api-example","value":"bool gistinsert(Relation r, Datum *values, bool *isnull, ItemPointer ht_ctid, Relation heapRel, IndexUniqueCheck checkUnique, bool indexUnchanged, IndexInfo *indexInfo) { GISTSTATE  *giststate = (GIST...","count":3},{"name":"api-example","value":"bool gistvalidate(Oid opclassoid) { bool\t\tresult = true; HeapTuple\tclasstup; Form_pg_opclass classform; Oid\t\t\topfamilyoid; Oid\t\t\topcintype; Oid\t\t\topckeytype; char\t   *opclassname; HeapTuple\tfamilytup;...","count":3},{"name":"api-example","value":"bool has_drive_prefix(const char *path) { #ifdef WIN32 return skip_drive(path) != path; #else return false; #endif }","count":3},{"name":"api-example","value":"bool has_privs_of_role(Oid member, Oid role) { if (member == role) return true; if (superuser_arg(member)) return true; * Find all the roles that member has the privileges of, including * multi-level ...","count":3},{"name":"api-example","value":"bool heap_getnextslot(TableScanDesc sscan, ScanDirection direction, TupleTableSlot *slot) { HeapScanDesc scan = (HeapScanDesc) sscan; if (sscan->rs_flags & SO_ALLOW_PAGEMODE) heapgettup_pagemode(scan,...","count":3},{"name":"api-example","value":"bool index_insert(Relation indexRelation, Datum *values, bool *isnull, ItemPointer heap_t_ctid, Relation heapRelation, IndexUniqueCheck checkUnique, bool indexUnchanged, IndexInfo *indexInfo) { RELATI...","count":3},{"name":"api-example","value":"bool is_publishable_relation(Relation rel) { return is_publishable_class(RelationGetRelid(rel), rel->rd_rel); }","count":3},{"name":"api-example","value":"bool jspIsMutable(JsonPath *path, List *varnames, List *varexprs) { struct JsonPathMutableContext cxt; JsonPathItem jpi; cxt.varnames = varnames; cxt.varexprs = varexprs; cxt.current = jpdsNonDateTime...","count":3},{"name":"api-example","value":"bool listTables(const char *tabtypes, const char *pattern, bool verbose, bool showSystem) { bool\t\tshowTables = strchr(tabtypes, 't') != NULL; bool\t\tshowIndexes = strchr(tabtypes, 'i') != NULL; bool\t\ts...","count":3},{"name":"api-example","value":"bool moveArrayTypeName(Oid typeOid, const char *typeName, Oid typeNamespace) { Oid\t\t\telemOid; char\t   *newname; if (!get_typisdefined(typeOid)) return true; elemOid = get_element_type(typeOid); if (!O...","count":3},{"name":"api-example","value":"bool multirange_contains_range_internal(TypeCacheEntry *rangetyp, const MultirangeType *mr, const RangeType *r) { RangeBound\tbounds[2]; bool\t\tempty; * Every multirange contains an infinite number of e...","count":3},{"name":"api-example","value":"bool numeric_is_inf(Numeric num) { return NUMERIC_IS_INF(num); }","count":3},{"name":"api-example","value":"bool numeric_is_nan(Numeric num) { return NUMERIC_IS_NAN(num); }","count":3},{"name":"api-example","value":"bool object_ownercheck(Oid classid, Oid objectid, Oid roleid) { int\t\t\tcacheid; Oid\t\t\townerId; if (superuser_arg(roleid)) return true; if (classid == LargeObjectRelationId) classid = LargeObjectMetadat...","count":3},{"name":"api-example","value":"bool path_is_reparameterizable_by_child(Path *path, RelOptInfo *child_rel) { #define REJECT_IF_PATH_NOT_REPARAMETERIZABLE(path) \\ do { \\ if (!path_is_reparameterizable_by_child(path, child_rel)) \\ ret...","count":3},{"name":"api-example","value":"bool pg_file_exists(const char *name) { struct stat st; Assert(name != NULL); if (stat(name, &st) == 0) return !S_ISDIR(st.st_mode); else if (!(errno == ENOENT || errno == ENOTDIR || errno == EACCES))...","count":3},{"name":"api-example","value":"bool pgstat_flush_wal(bool nowait) { PgStatShared_Wal *stats_shmem = &pgStatLocal.shmem->wal; WalUsage\twal_usage_diff = {0}; Assert(IsUnderPostmaster || !IsPostmasterEnvironment); Assert(pgStatLocal.s...","count":3},{"name":"api-example","value":"bool pgstat_slru_flush(bool nowait) { PgStatShared_SLRU *stats_shmem = &pgStatLocal.shmem->slru; int\t\t\ti; if (!have_slrustats) return false; if (!nowait) LWLockAcquire(&stats_shmem->lock, LW_EXCLUSIVE...","count":3},{"name":"api-example","value":"bool plan_cluster_use_sort(Oid tableOid, Oid indexOid) { PlannerInfo *root; Query\t   *query; PlannerGlobal *glob; RangeTblEntry *rte; RelOptInfo *rel; IndexOptInfo *indexInfo; QualCost\tindexExprCost; ...","count":3},{"name":"api-example","value":"bool planstate_tree_walker_impl(PlanState *planstate, planstate_tree_walker_callback walker, void *context) { Plan\t   *plan = planstate->plan; ListCell   *lc; #define PSWALK(n) walker(n, context) chec...","count":3},{"name":"api-example","value":"bool pqGetHomeDirectory(char *buf, int bufsize) { #ifndef WIN32 const char *home; home = getenv(\"HOME\"); if (home == NULL || home[0] == '\\0') return pg_get_user_home_dir(geteuid(), buf, bufsize); strl...","count":3},{"name":"api-example","value":"bool predicate_implied_by(List *predicate_list, List *clause_list, bool weak) { Node\t   *p, *c; if (predicate_list == NIL) return true;\t\t\t/* no predicate: implication is vacuous */ if (clause_list == ...","count":3},{"name":"api-example","value":"bool predicate_refuted_by(List *predicate_list, List *clause_list, bool weak) { Node\t   *p, *c; if (predicate_list == NIL) return false;\t\t\t/* no predicate: no refutation is possible */ if (clause_list...","count":3},{"name":"api-example","value":"bool range_adjacent_multirange_internal(TypeCacheEntry *rangetyp, const RangeType *r, const MultirangeType *mr) { RangeBound\tlower1, upper1, lower2, upper2; bool\t\tempty; int32\t\trange_count; if (RangeI...","count":3},{"name":"api-example","value":"bool spgcanreturn(Relation index, int attno) { SpGistCache *cache; if (attno > 1) return true; cache = spgGetCache(index); return cache->config.canReturnData; }","count":3},{"name":"api-example","value":"bool std_typanalyze(VacAttrStats *stats) { Oid\t\t\tltopr; Oid\t\t\teqopr; StdAnalyzeData *mystats; if (stats->attstattarget < 0) stats->attstattarget = default_statistics_target; get_sort_group_operators(s...","count":3},{"name":"api-example","value":"bool tuplesort_skiptuples(Tuplesortstate *state, int64 ntuples, bool forward) { MemoryContext oldcontext; * We don't actually support backwards skip yet, because no callers need * it.  The API is desi...","count":3},{"name":"api-example","value":"bool typeInheritsFrom(Oid subclassTypeId, Oid superclassTypeId) { bool\t\tresult = false; Oid\t\t\tsubclassRelid; Oid\t\t\tsuperclassRelid; Relation\tinhrel; List\t   *visited, *queue; ListCell   *queue_item; s...","count":3},{"name":"api-example","value":"bool vacuum_get_cutoffs(Relation rel, const VacuumParams *params, struct VacuumCutoffs *cutoffs) { int\t\t\tfreeze_min_age, multixact_freeze_min_age, freeze_table_age, multixact_freeze_table_age, effecti...","count":3},{"name":"api-example","value":"bool visibilitymap_clear(Relation rel, BlockNumber heapBlk, Buffer vmbuf, uint8 flags) { BlockNumber mapBlock = HEAPBLK_TO_MAPBLOCK(heapBlk); int\t\t\tmapByte = HEAPBLK_TO_MAPBYTE(heapBlk); int\t\t\tmapOffs...","count":3},{"name":"api-example","value":"char * ChooseConstraintName(const char *name1, const char *name2, const char *label, Oid namespaceid, List *others) { int\t\t\tpass = 0; char\t   *conname = NULL; char\t\tmodlabel[NAMEDATALEN]; Relation\tcon...","count":3},{"name":"api-example","value":"char * DebugPrintBufferRefcount(Buffer buffer) { BufferDesc *buf; int32\t\tloccount; char\t   *path; char\t   *result; ProcNumber\tbackend; uint32\t\tbuf_state; Assert(BufferIsValid(buffer)); if (BufferIsLoc...","count":3},{"name":"api-example","value":"char * ExportSnapshot(Snapshot snapshot) { TransactionId topXid; TransactionId *children; ExportedSnapshot *esnap; int\t\t\tnchildren; int\t\t\taddTopXid; StringInfoData buf; FILE\t   *f; int\t\t\ti; MemoryCont...","count":3},{"name":"api-example","value":"char * FigureColname(Node *node) { char\t   *name = NULL; (void) FigureColnameInternal(node, &name); if (name != NULL) return name; return \"?column?\"; }","count":3},{"name":"api-example","value":"char * GetIncrementalFilePath(Oid dboid, Oid spcoid, RelFileNumber relfilenumber, ForkNumber forknum, unsigned segno) { char\t   *path; char\t   *lastslash; char\t   *ipath; path = GetRelationPath(dboid,...","count":3},{"name":"api-example","value":"char * PGTYPESdate_to_asc(date dDate) { struct tm\ttt, *tm = &tt; char\t\tbuf[MAXDATELEN + 1]; int\t\t\tDateStyle = 1; bool\t\tEuroDates = false; j2date(dDate + date2j(2000, 1, 1), &(tm->tm_year), &(tm->tm_mo...","count":3},{"name":"api-example","value":"char * PQencryptPasswordConn(PGconn *conn, const char *passwd, const char *user, const char *algorithm) { #define MAX_ALGORITHM_NAME_LEN 50 char\t\talgobuf[MAX_ALGORITHM_NAME_LEN + 1]; char\t   *crypt_pw...","count":3},{"name":"api-example","value":"char * SPI_fname(TupleDesc tupdesc, int fnumber) { const FormData_pg_attribute *att; SPI_result = 0; if (fnumber > tupdesc->natts || fnumber == 0 || fnumber <= FirstLowInvalidHeapAttributeNumber) { SP...","count":3},{"name":"api-example","value":"char * encrypt_password(PasswordType target_type, const char *role, const char *password) { PasswordType guessed_type = get_password_type(password); char\t   *encrypted_password; const char *errstr = N...","count":3},{"name":"api-example","value":"char * float8out_internal(double num) { char\t   *ascii = (char *) palloc(32); int\t\t\tndig = DBL_DIG + extra_float_digits; if (extra_float_digits > 0) { double_to_shortest_decimal_buf(num, ascii); retur...","count":3},{"name":"api-example","value":"char * format_type_extended(Oid type_oid, int32 typemod, bits16 flags) { HeapTuple\ttuple; Form_pg_type typeform; Oid\t\t\tarray_base_type; bool\t\tis_array; char\t   *buf; bool\t\twith_typemod; if (type_oid =...","count":3},{"name":"api-example","value":"char * json_errdetail(JsonParseErrorType error, JsonLexContext *lex) { if (lex->errormsg) resetStringInfo(lex->errormsg); else lex->errormsg = makeStringInfo(); * A helper for error messages that shou...","count":3},{"name":"api-example","value":"char * pg_get_querydef(Query *query, bool pretty) { StringInfoData buf; int\t\t\tprettyFlags; prettyFlags = GET_PRETTY_FLAGS(pretty); initStringInfo(&buf); get_query_def(query, &buf, NIL, NULL, true, pre...","count":3},{"name":"api-example","value":"char * pg_perm_setlocale(int category, const char *locale) { char\t   *result; const char *envvar; #ifndef WIN32 result = setlocale(category, locale); #else * On Windows, setlocale(LC_MESSAGES) does no...","count":3},{"name":"api-example","value":"char * plperl_sv_to_literal(SV *sv, char *fqtypename) { Oid\t\t\ttypid; Oid\t\t\ttypoutput; Datum\t\tdatum; bool\t\ttypisvarlena, isnull; check_spi_usage_allowed(); typid = DirectFunctionCall1(regtypein, CStrin...","count":3},{"name":"api-example","value":"char * simple_prompt_extended(const char *prompt, bool echo, PromptInterruptContext *prompt_ctx) { char\t   *result; FILE\t   *termin, *termout; #if defined(HAVE_TERMIOS_H) struct termios t_orig, t; #el...","count":3},{"name":"api-example","value":"char * str_tolower(const char *buff, size_t nbytes, Oid collid) { char\t   *result; if (!buff) return NULL; if (!OidIsValid(collid)) { * This typically means that the parser could not resolve a conflic...","count":3},{"name":"api-example","value":"char * supports_compression(const pg_compress_specification compression_spec) { const pg_compress_algorithm algorithm = compression_spec.algorithm; bool\t\tsupported = false; if (algorithm == PG_COMPRES...","count":3},{"name":"api-example","value":"char max_parallel_hazard(Query *parse) { max_parallel_hazard_context context; context.max_hazard = PROPARALLEL_SAFE; context.max_interesting = PROPARALLEL_UNSAFE; context.safe_param_ids = NIL; (void) ...","count":3},{"name":"api-example","value":"const char * GetLWLockIdentifier(uint32 classId, uint16 eventId) { Assert(classId == PG_WAIT_LWLOCK); return GetLWTrancheName(eventId); }","count":3},{"name":"api-example","value":"const char * __ubsan_default_options(void) { if (!reached_main) return \"\"; return getenv(\"UBSAN_OPTIONS\"); }","count":3},{"name":"api-example","value":"const char * fmtIdEnc(const char *rawid, int encoding) { PQExpBuffer id_return = getLocalPQExpBuffer(); const char *cp; bool\t\tneed_quotes = false; size_t\t\tremaining = strlen(rawid); * These checks nee...","count":3},{"name":"api-example","value":"const char * quote_identifier(const char *ident) { * Can avoid quoting if ident starts with a lowercase letter or underscore * and contains only lowercase letters, digits, and underscores, *and* is * ...","count":3},{"name":"api-example","value":"double defGetNumeric(DefElem *def) { if (def->arg == NULL) ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg(\"%s requires a numeric value\", def->defname))); switch (nodeTag(def->arg)) { case T_Int...","count":3},{"name":"api-example","value":"double var_eq_const(VariableStatData *vardata, Oid oproid, Oid collation, Datum constval, bool constisnull, bool varonleft, bool negate) { double\t\tselec; double\t\tnullfrac = 0.0; bool\t\tisdefault; Oid\t\t...","count":3},{"name":"api-example","value":"dsm_segment * dsm_attach(dsm_handle h) { dsm_segment *seg; dlist_iter\titer; uint32\t\ti; uint32\t\tnitems; Assert(IsUnderPostmaster); if (!dsm_init_done) dsm_backend_startup(); * Since this is just a debu...","count":3},{"name":"api-example","value":"extern int arabic_UTF_8_stem(struct SN_env * z) { z->I[2] = 1; z->I[1] = 1; z->I[0] = 0; {   int c1 = z->c; {   int ret = r_Checks1(z); if (ret < 0) return ret; } z->c = c1; } {   int ret = r_Normaliz...","count":3},{"name":"api-example","value":"extern int eq_v(struct SN_env * z, const symbol * p) { return eq_s(z, SIZE(p), p); }","count":3},{"name":"api-example","value":"extern struct SN_env * basque_ISO_8859_1_create_env(void) { return SN_create_env(0, 3); }","count":3},{"name":"api-example","value":"float gistpenalty(GISTSTATE *giststate, int attno, GISTENTRY *orig, bool isNullOrig, GISTENTRY *add, bool isNullAdd) { float\t\tpenalty = 0.0; if (giststate->penaltyFn[attno].fn_strict == false || (isNu...","count":3},{"name":"api-example","value":"int #ifdef LEVENSHTEIN_LESS_EQUAL varstr_levenshtein_less_equal(const char *source, int slen, const char *target, int tlen, int ins_c, int del_c, int sub_c, int max_d, bool trusted) #else varstr_leven...","count":3},{"name":"api-example","value":"int BasicOpenFilePerm(const char *fileName, int fileFlags, mode_t fileMode) { int\t\t\tfd; tryAgain: #ifdef PG_O_DIRECT_USE_F_NOCACHE * The value we defined to stand in for O_DIRECT when simulating it wi...","count":3},{"name":"api-example","value":"int BufFileSeek(BufFile *file, int fileno, off_t offset, int whence) { int\t\t\tnewFile; off_t\t\tnewOffset; switch (whence) { case SEEK_SET: if (fileno < 0) return EOF; newFile = fileno; newOffset = offse...","count":3},{"name":"api-example","value":"int BufTableLookup(BufferTag *tagPtr, uint32 hashcode) { BufferLookupEnt *result; result = (BufferLookupEnt *) hash_search_with_hash_value(SharedBufHash, tagPtr, hashcode, HASH_FIND, NULL); if (!resul...","count":3},{"name":"api-example","value":"int DecodeTimezone(const char *str, int *tzp) { int\t\t\ttz; int\t\t\thr, min, sec = 0; char\t   *cp; if (*str != '+' && *str != '-') return DTERR_BAD_FORMAT; errno = 0; hr = strtoint(str + 1, &cp, 10); if (...","count":3},{"name":"api-example","value":"int FreeFile(FILE *file) { int\t\t\ti; DO_DB(elog(LOG, \"FreeFile: Allocated %d\", numAllocatedDescs)); for (i = numAllocatedDescs; --i >= 0;) { AllocateDesc *desc = &allocatedDescs[i]; if (desc->kind == A...","count":3},{"name":"api-example","value":"int GinDataLeafPageGetItemsToTbm(Page page, TIDBitmap *tbm) { ItemPointer uncompressed; int\t\t\tnitems; if (GinPageIsCompressed(page)) { GinPostingList *segment = GinDataLeafPageGetPostingList(page); Si...","count":3},{"name":"api-example","value":"int LocalToUtf(const unsigned char *iso, int len, unsigned char *utf, const pg_mb_radix_tree *map, const pg_local_to_utf_combined *cmap, int cmapsize, utf_local_conversion_func conv_func, int encoding...","count":3},{"name":"api-example","value":"int MakePGDirectory(const char *directoryName) { return mkdir(directoryName, pg_dir_create_mode); }","count":3},{"name":"api-example","value":"int PGTYPESdate_fmt_asc(date dDate, const char *fmtstring, char *outbuf) { static struct { char\t   *format; int\t\t\tcomponent; }\t\t\tmapping[] = { * format items have to be sorted according to their lengt...","count":3},{"name":"api-example","value":"int PQcancelBlocking(PGcancelConn *cancelConn) { if (!PQcancelStart(cancelConn)) return 0; return pqConnectDBComplete(&cancelConn->conn); }","count":3},{"name":"api-example","value":"int PQcancelStart(PGcancelConn *cancelConn) { if (!cancelConn || cancelConn->conn.status == CONNECTION_BAD) return 0; if (cancelConn->conn.status != CONNECTION_ALLOCATED) { libpq_append_conn_error(&ca...","count":3},{"name":"api-example","value":"int PQconsumeInput(PGconn *conn) { if (!conn) return 0; * for non-blocking connections try to flush the send-queue, otherwise we * may never get a response for something that may not have already been...","count":3},{"name":"api-example","value":"int PQisBusy(PGconn *conn) { if (!conn) return false; parseInput(conn); * PQgetResult will return immediately in all states except BUSY.  Also, * if we've detected read EOF and dropped the connection,...","count":3},{"name":"api-example","value":"int PQsendPrepare(PGconn *conn, const char *stmtName, const char *query, int nParams, const Oid *paramTypes) { PGcmdQueueEntry *entry = NULL; if (!PQsendQueryStart(conn, true)) return 0; if (!stmtName...","count":3},{"name":"api-example","value":"int PQsendQueryParams(PGconn *conn, const char *command, int nParams, const Oid *paramTypes, const char *const *paramValues, const int *paramLengths, const int *paramFormats, int resultFormat) { if (!...","count":3},{"name":"api-example","value":"int SPI_connect(void) { return SPI_connect_ext(0); }","count":3},{"name":"api-example","value":"int SPI_execp(SPIPlanPtr plan, Datum *Values, const char *Nulls, long tcount) { return SPI_execute_plan(plan, Values, Nulls, false, tcount); }","count":3},{"name":"api-example","value":"int SPI_execute_plan(SPIPlanPtr plan, Datum *Values, const char *Nulls, bool read_only, long tcount) { SPIExecuteOptions options; int\t\t\tres; if (plan == NULL || plan->magic != _SPI_PLAN_MAGIC || tcoun...","count":3},{"name":"api-example","value":"int SPI_finish(void) { int\t\t\tres; res = _SPI_begin_call(false);\t/* just check we're connected */ if (res < 0) return res; MemoryContextSwitchTo(_SPI_current->savedcxt); MemoryContextDelete(_SPI_curren...","count":3},{"name":"api-example","value":"int SPI_register_trigger_data(TriggerData *tdata) { if (tdata == NULL) return SPI_ERROR_ARGUMENT; if (tdata->tg_newtable) { EphemeralNamedRelation enr = palloc(sizeof(EphemeralNamedRelationData)); int...","count":3},{"name":"api-example","value":"int SysLogger_Start(void) { pid_t\t\tsysloggerPid; char\t   *filename; #ifdef EXEC_BACKEND SysloggerStartupData startup_data; #endif\t\t\t\t\t\t\t/* EXEC_BACKEND */ if (!Logging_collector) return 0; * If first ...","count":3},{"name":"api-example","value":"int UtfToLocal(const unsigned char *utf, int len, unsigned char *iso, const pg_mb_radix_tree *map, const pg_utf_to_local_combined *cmap, int cmapsize, utf_local_conversion_func conv_func, int encoding...","count":3},{"name":"api-example","value":"int bms_singleton_member(const Bitmapset *a) { int\t\t\tresult = -1; int\t\t\tnwords; int\t\t\twordnum; Assert(bms_is_valid_set(a)); if (a == NULL) elog(ERROR, \"bitmapset is empty\"); nwords = a->nwords; wordnu...","count":3},{"name":"api-example","value":"int err_generic_string(int field, const char *str) { ErrorData  *edata = &errordata[errordata_stack_depth]; CHECK_STACK_DEPTH(); switch (field) { case PG_DIAG_SCHEMA_NAME: set_errdata_field(edata->ass...","count":3},{"name":"api-example","value":"int errmsg(const char *fmt,...) { ErrorData  *edata = &errordata[errordata_stack_depth]; MemoryContext oldcontext; recursion_depth++; CHECK_STACK_DEPTH(); oldcontext = MemoryContextSwitchTo(edata->ass...","count":3},{"name":"api-example","value":"int exprLocation(const Node *expr) { int\t\t\tloc; if (expr == NULL) return -1; switch (nodeTag(expr)) { case T_RangeVar: loc = ((const RangeVar *) expr)->location; break; case T_TableFunc: loc = ((const...","count":3},{"name":"api-example","value":"int fsync_fname_ext(const char *fname, bool isdir, bool ignore_perm, int elevel) { int\t\t\tfd; int\t\t\tflags; int\t\t\treturncode; * Some OSs require directories to be opened read-only whereas other * system...","count":3},{"name":"api-example","value":"int gimme_tour(PlannerInfo *root, Edge *edge_table, Gene *new_gene, int num_gene) { int\t\t\ti; int\t\t\tedge_failures = 0; new_gene[0] = (Gene) geqo_randint(root, num_gene, 1); for (i = 1; i < num_gene; i+...","count":3},{"name":"api-example","value":"int lexi(struct parser_state *state) { int         unary_delim;\t/* this is set to 1 if the current token * forces a following operator to be unary */ int         code;\t\t/* internal code to be returned...","count":3},{"name":"api-example","value":"int list_int_cmp(const ListCell *p1, const ListCell *p2) { int\t\t\tv1 = lfirst_int(p1); int\t\t\tv2 = lfirst_int(p2); return pg_cmp_s32(v1, v2); }","count":3},{"name":"api-example","value":"int local2local(const unsigned char *l, unsigned char *p, int len, int src_encoding, int dest_encoding, const unsigned char *tab, bool noError) { const unsigned char *start = l; unsigned char c1, c2; ...","count":3},{"name":"api-example","value":"int main(int argc, char **argv) { int\t\t\tc; const char *filename = NULL; const char *format = \"p\"; TableInfo  *tblinfo; int\t\t\tnumTables; DumpableObject **dobjs; int\t\t\tnumObjs; DumpableObject *boundaryO...","count":3},{"name":"api-example","value":"int main(int argc, char *argv[]) { static int\tif_exists = 0; static struct option long_options[] = { {\"host\", required_argument, NULL, 'h'}, {\"port\", required_argument, NULL, 'p'}, {\"username\", requir...","count":3},{"name":"api-example","value":"int main(int argc, char *argv[]) { static struct option long_options[] = { {\"with-admin\", required_argument, NULL, 'a'}, {\"connection-limit\", required_argument, NULL, 'c'}, {\"createdb\", no_argument, N...","count":3},{"name":"api-example","value":"int pg_cryptohash_final(pg_cryptohash_ctx *ctx, uint8 *dest, size_t len) { if (ctx == NULL) return -1; switch (ctx->type) { case PG_MD5: if (len < MD5_DIGEST_LENGTH) { ctx->error = PG_CRYPTOHASH_ERROR...","count":3},{"name":"api-example","value":"int pg_cryptohash_init(pg_cryptohash_ctx *ctx) { int\t\t\tstatus = 0; if (ctx == NULL) return -1; switch (ctx->type) { case PG_MD5: status = EVP_DigestInit_ex(ctx->evpctx, EVP_md5(), NULL); break; case P...","count":3},{"name":"api-example","value":"int pg_fsync_no_writethrough(int fd) { int\t\t\trc; if (!enableFsync) return 0; retry: rc = fsync(fd); if (rc == -1 && errno == EINTR) goto retry; return rc; }","count":3},{"name":"api-example","value":"int pg_hmac_init(pg_hmac_ctx *ctx, const uint8 *key, size_t len) { int\t\t\tstatus = 0; if (ctx == NULL) return -1; switch (ctx->type) { case PG_MD5: status = HMAC_Init_ex(ctx->hmacctx, key, len, EVP_md5...","count":3},{"name":"api-example","value":"int pg_strcoll(const char *arg1, const char *arg2, pg_locale_t locale) { int\t\t\tresult; if (!locale || locale->provider == COLLPROVIDER_LIBC) result = pg_strcoll_libc(arg1, arg2, locale); #ifdef USE_IC...","count":3},{"name":"api-example","value":"int pgwin32_connect(SOCKET s, const struct sockaddr *addr, int addrlen) { int\t\t\tr; r = WSAConnect(s, addr, addrlen, NULL, NULL, NULL, NULL); if (r == 0) return 0; if (WSAGetLastError() != WSAEWOULDBLO...","count":3},{"name":"api-example","value":"int pgwin32_recv(SOCKET s, char *buf, int len, int f) { WSABUF\t\twbuf; int\t\t\tr; DWORD\t\tb; DWORD\t\tflags = f; int\t\t\tn; if (pgwin32_poll_signals()) return -1; wbuf.len = len; wbuf.buf = buf; r = WSARecv(s...","count":3},{"name":"api-example","value":"int pqConnectDBStart(PGconn *conn) { if (!conn) return 0; if (!conn->options_valid) goto connect_errReturn; * Check for bad linking to backend-internal versions of src/common * functions (see comments...","count":3},{"name":"api-example","value":"int pqPutc(char c, PGconn *conn) { if (pqPutMsgBytes(&c, 1, conn)) return EOF; return 0; }","count":3},{"name":"api-example","value":"int pq_getmessage(StringInfo s, int maxlen) { int32\t\tlen; Assert(PqCommReadingMsg); resetStringInfo(s); if (pq_getbytes((char *) &len, 4) == EOF) { ereport(COMMERROR, (errcode(ERRCODE_PROTOCOL_VIOLATI...","count":3},{"name":"api-example","value":"int relation_is_updatable(Oid reloid, List *outer_reloids, bool include_triggers, Bitmapset *include_cols) { int\t\t\tevents = 0; Relation\trel; RuleLock   *rulelocks; #define ALL_EVENTS ((1 << CMD_INSERT...","count":3},{"name":"api-example","value":"int rsetnull(int t, char *ptr) { ECPGset_noind_null(t, ptr); return 0; }","count":3},{"name":"api-example","value":"int32 anytime_typmod_check(bool istz, int32 typmod) { if (typmod < 0) ereport(ERROR, (errcode(ERRCODE_INVALID_PARAMETER_VALUE), errmsg(\"TIME(%d)%s precision must not be negative\", typmod, (istz ? \" WI...","count":3},{"name":"api-example","value":"int64 pq_getmsgint64(StringInfo msg) { uint64\t\tn64; pq_copymsgbytes(msg, (char *) &n64, sizeof(n64)); return pg_ntoh64(n64); }","count":3},{"name":"api-example","value":"interval * PGTYPESinterval_from_asc(char *str, char **endptr) { interval   *result = NULL; fsec_t\t\tfsec; struct tm\ttt, *tm = &tt; int\t\t\tdtype; int\t\t\tnf; char\t   *field[MAXDATEFIELDS]; int\t\t\tftype[MAXD...","count":3},{"name":"api-example","value":"long clamp_cardinality_to_long(Cardinality x) { * Just for paranoia's sake, ensure we do something sane with negative or * NaN values. */ if (isnan(x)) return LONG_MAX; if (x <= 0) return 0; * If \"lon...","count":3},{"name":"api-example","value":"pg_hmac_ctx * pg_hmac_create(pg_cryptohash_type type) { pg_hmac_ctx *ctx; ctx = ALLOC(sizeof(pg_hmac_ctx)); if (ctx == NULL) return NULL; memset(ctx, 0, sizeof(pg_hmac_ctx)); ctx->type = type; ctx->er...","count":3},{"name":"api-example","value":"size_t WriteStr(ArchiveHandle *AH, const char *c) { size_t\t\tres; if (c) { int\t\t\tlen = strlen(c); res = WriteInt(AH, len); AH->WriteBufPtr(AH, c, len); res += len; } else res = WriteInt(AH, -1); return...","count":3},{"name":"api-example","value":"size_t pg_strftime(char *s, size_t maxsize, const char *format, const struct pg_tm *t) { char\t   *p; int\t\t\tsaved_errno = errno; enum warn\twarn = IN_NONE; p = _fmt(format, t, s, s + maxsize, &warn); if...","count":3},{"name":"api-example","value":"ssize_t pgtls_read(PGconn *conn, void *ptr, size_t len) { ssize_t\t\tn; int\t\t\tresult_errno = 0; char\t\tsebuf[PG_STRERROR_R_BUFLEN]; int\t\t\terr; unsigned long ecode; rloop: * Prepare to call SSL_get_error(...","count":3},{"name":"api-example","value":"ssize_t secure_read(Port *port, void *ptr, size_t len) { ssize_t\t\tn; int\t\t\twaitfor; ProcessClientReadInterrupt(false); retry: #ifdef USE_SSL waitfor = 0; if (port->ssl_in_use) { n = be_tls_read(port, ...","count":3},{"name":"api-example","value":"static AclMode pg_aclmask(ObjectType objtype, Oid object_oid, AttrNumber attnum, Oid roleid, AclMode mask, AclMaskHow how) { switch (objtype) { case OBJECT_COLUMN: return pg_class_aclmask(object_oid, ...","count":3},{"name":"api-example","value":"static AclMode pg_class_aclmask_ext(Oid table_oid, Oid roleid, AclMode mask, AclMaskHow how, bool *is_missing) { AclMode\t\tresult; HeapTuple\ttuple; Form_pg_class classForm; Datum\t\taclDatum; bool\t\tisNul...","count":3},{"name":"api-example","value":"static AclMode pg_type_aclmask_ext(Oid type_oid, Oid roleid, AclMode mask, AclMaskHow how, bool *is_missing) { AclMode\t\tresult; HeapTuple\ttuple; Form_pg_type typeForm; Datum\t\taclDatum; bool\t\tisNull; A...","count":3},{"name":"api-example","value":"static AttrNumber renameatt_internal(Oid myrelid, const char *oldattname, const char *newattname, bool recurse, bool recursing, int expected_parents, DropBehavior behavior) { Relation\ttargetrelation; ...","count":3},{"name":"api-example","value":"static Bitmapset * afterTriggerCopyBitmap(Bitmapset *src) { Bitmapset  *dst; MemoryContext oldcxt; if (src == NULL) return NULL; oldcxt = MemoryContextSwitchTo(afterTriggers.event_cxt); dst = bms_copy...","count":3},{"name":"api-example","value":"static Bitmapset * finalize_plan(PlannerInfo *root, Plan *plan, int gather_param, Bitmapset *valid_params, Bitmapset *scan_params) { finalize_primnode_context context; int\t\t\tlocally_added_param; Bitma...","count":3},{"name":"api-example","value":"static BlockNumber * _bt_deadblocks(Page page, OffsetNumber *deletable, int ndeletable, IndexTuple newitem, int *nblocks) { int\t\t\tspacentids, ntids; BlockNumber *tidblocks; * Accumulate each TID's blo...","count":3},{"name":"api-example","value":"static BlockNumber bitno_to_blkno(HashMetaPage metap, uint32 ovflbitnum) { uint32\t\tsplitnum = metap->hashm_ovflpoint; uint32\t\ti; ovflbitnum += 1; for (i = 1; i < splitnum && ovflbitnum > metap->hashm_...","count":3},{"name":"api-example","value":"static BlockNumber entryLocateEntry(GinBtree btree, GinBtreeStack *stack) { OffsetNumber low, high, maxoff; IndexTuple\titup = NULL; int\t\t\tresult; Page\t\tpage = BufferGetPage(stack->buffer); Assert(!Gin...","count":3},{"name":"api-example","value":"static BlockNumber fsm_logical_to_physical(FSMAddress addr) { BlockNumber pages; int\t\t\tleafno; int\t\t\tl; * Calculate the logical page number of the first leaf page below the * given page. */ leafno = a...","count":3},{"name":"api-example","value":"static BlockNumber gistbufferinginserttuples(GISTBuildState *buildstate, Buffer buffer, int level, IndexTuple *itup, int ntup, OffsetNumber oldoffnum, BlockNumber parentblk, OffsetNumber downlinkoffnu...","count":3},{"name":"api-example","value":"static BoolExpr * _readBoolExpr(void) { READ_LOCALS(BoolExpr); token = pg_strtok(&length); /* skip :boolop */ token = pg_strtok(&length); /* get field value */ if (length == 3 && strncmp(token, \"and\",...","count":3},{"name":"api-example","value":"static BpChar * bpchar_input(const char *s, size_t len, int32 atttypmod, Node *escontext) { BpChar\t   *result; char\t   *r; size_t\t\tmaxlen; if (atttypmod < (int32) VARHDRSZ) maxlen = len; else { size_t...","count":3},{"name":"api-example","value":"static Buffer GetVictimBuffer(BufferAccessStrategy strategy, IOContext io_context) { BufferDesc *buf_hdr; Buffer\t\tbuf; uint32\t\tbuf_state; bool\t\tfrom_ring; * Ensure, while the spinlock's not yet held, ...","count":3},{"name":"api-example","value":"static CoercionPathType findFkeyCast(Oid targetTypeId, Oid sourceTypeId, Oid *funcid) { CoercionPathType ret; if (targetTypeId == sourceTypeId) { ret = COERCION_PATH_RELABELTYPE; *funcid = InvalidOid;...","count":3},{"name":"api-example","value":"static Command * process_backslash_command(PsqlScanState sstate, const char *source) { Command    *my_command; PQExpBufferData word_buf; int\t\t\tword_offset; int\t\t\toffsets[MAX_ARGS];\t/* offsets of argum...","count":3},{"name":"api-example","value":"static CommandTag EventTriggerGetTag(Node *parsetree, EventTriggerEvent event) { if (event == EVT_Login) return CMDTAG_LOGIN; else return CreateCommandTag(parsetree); }","count":3},{"name":"api-example","value":"static Const * _copyConst(const Const *from) { Const\t   *newnode = makeNode(Const); COPY_SCALAR_FIELD(consttype); COPY_SCALAR_FIELD(consttypmod); COPY_SCALAR_FIELD(constcollid); COPY_SCALAR_FIELD(cons...","count":3},{"name":"api-example","value":"static CopyMultiInsertBuffer * CopyMultiInsertBufferInit(ResultRelInfo *rri) { CopyMultiInsertBuffer *buffer; buffer = (CopyMultiInsertBuffer *) palloc(sizeof(CopyMultiInsertBuffer)); memset(buffer->s...","count":3},{"name":"api-example","value":"static Cost append_nonpartial_cost(List *subpaths, int numpaths, int parallel_workers) { Cost\t   *costarr; int\t\t\tarrlen; ListCell   *l; ListCell   *cell; int\t\t\tpath_index; int\t\t\tmin_index; int\t\t\tmax_i...","count":3},{"name":"api-example","value":"static DCHCacheEntry * DCH_cache_fetch(const char *str, bool std) { DCHCacheEntry *ent; if ((ent = DCH_cache_search(str, std)) == NULL) { * Not in the cache, must run parser and save a new format-pict...","count":3},{"name":"api-example","value":"static DH  * load_dh_file(char *filename, bool isServerStart) { FILE\t   *fp; DH\t\t   *dh = NULL; int\t\t\tcodes; if ((fp = AllocateFile(filename, \"r\")) == NULL) { ereport(isServerStart ? FATAL : LOG, (err...","count":3},{"name":"api-example","value":"static Datum _bt_find_extreme_element(IndexScanDesc scan, ScanKey skey, Oid elemtype, StrategyNumber strat, Datum *elems, int nelems) { Relation\trel = scan->indexRelation; Oid\t\t\tcmp_op; RegProcedure c...","count":3},{"name":"api-example","value":"static Datum jsonPathFromCstring(char *in, int len, struct Node *escontext) { JsonPathParseResult *jsonpath = parsejsonpath(in, len, escontext); JsonPath   *res; StringInfoData buf; if (SOFT_ERROR_OCC...","count":3},{"name":"api-example","value":"static Datum plperl_hash_to_datum(SV *src, TupleDesc td) { HeapTuple\ttup = plperl_build_tuple_result((HV *) SvRV(src), td); return HeapTupleGetDatum(tup); }","count":3},{"name":"api-example","value":"static Datum populate_composite(CompositeIOData *io, Oid typid, const char *colname, MemoryContext mcxt, HeapTupleHeader defaultval, JsValue *jsv, bool *isnull, Node *escontext) { Datum\t\tresult; updat...","count":3},{"name":"api-example","value":"static Datum populate_record_worker(FunctionCallInfo fcinfo, const char *funcname, bool is_json, bool have_record_arg, Node *escontext) { int\t\t\tjson_arg_num = have_record_arg ? 1 : 0; JsValue\t\tjsv = {...","count":3},{"name":"api-example","value":"static Datum scalarineqsel_wrapper(PG_FUNCTION_ARGS, bool isgt, bool iseq) { PlannerInfo *root = (PlannerInfo *) PG_GETARG_POINTER(0); Oid\t\t\toperator = PG_GETARG_OID(1); List\t   *args = (List *) PG_GE...","count":3},{"name":"api-example","value":"static FSMAddress fsm_get_location(BlockNumber heapblk, uint16 *slot) { FSMAddress\taddr; addr.level = FSM_BOTTOM_LEVEL; addr.logpageno = heapblk / SlotsPerFSMPage; *slot = heapblk % SlotsPerFSMPage; r...","count":3},{"name":"api-example","value":"static File MakeNewFileSetSegment(BufFile *buffile, int segment) { char\t\tname[MAXPGPATH]; File\t\tfile; * It is possible that there are files left over from before a crash * restart with the same name. ...","count":3},{"name":"api-example","value":"static FreePageBtree * FreePageBtreeFindLeftSibling(char *base, FreePageBtree *btp) { FreePageBtree *p = btp; int\t\t\tlevels = 0; for (;;) { Size\t\tfirst_page; Size\t\tindex; first_page = FreePageBtreeFirs...","count":3},{"name":"api-example","value":"static GISTNodeBufferPage * gistAllocateNewPageBuffer(GISTBuildBuffers *gfbb) { GISTNodeBufferPage *pageBuffer; pageBuffer = (GISTNodeBufferPage *) MemoryContextAllocZero(gfbb->context, BLCKSZ); pageB...","count":3},{"name":"api-example","value":"static Gather * create_gather_plan(PlannerInfo *root, GatherPath *best_path) { Gather\t   *gather_plan; Plan\t   *subplan; List\t   *tlist; * Push projection down to the child node.  That way, the projec...","count":3},{"name":"api-example","value":"static GinTernaryValue execute_jsp_gin_node(JsonPathGinNode *node, void *check, bool ternary) { GinTernaryValue res; GinTernaryValue v; int\t\t\ti; switch (node->type) { case JSP_GIN_AND: res = GIN_TRUE;...","count":3},{"name":"api-example","value":"static HeapTuple plperl_build_tuple_result(HV *perlhash, TupleDesc td) { dTHX; Datum\t   *values; bool\t   *nulls; HE\t\t   *he; HeapTuple\ttup; values = palloc0(sizeof(Datum) * td->natts); nulls = palloc(...","count":3},{"name":"api-example","value":"static IndexClause * match_boolean_index_clause(PlannerInfo *root, RestrictInfo *rinfo, int indexcol, IndexOptInfo *index) { Node\t   *clause = (Node *) rinfo->clause; Expr\t   *op = NULL; if (match_ind...","count":3},{"name":"api-example","value":"static IndexClause * match_clause_to_indexcol(PlannerInfo *root, RestrictInfo *rinfo, int indexcol, IndexOptInfo *index) { IndexClause *iclause; Expr\t   *clause = rinfo->clause; Oid\t\t\topfamily; Assert...","count":3},{"name":"api-example","value":"static IndexClause * match_opclause_to_indexcol(PlannerInfo *root, RestrictInfo *rinfo, int indexcol, IndexOptInfo *index) { IndexClause *iclause; OpExpr\t   *clause = (OpExpr *) rinfo->clause; Node\t  ...","count":3},{"name":"api-example","value":"static IndexTuple GinFormInteriorTuple(IndexTuple itup, Page page, BlockNumber childblk) { IndexTuple\tnitup; if (GinPageIsLeaf(page) && !GinIsPostingTree(itup)) { uint32\t\torigsize = GinGetPostingOffse...","count":3},{"name":"api-example","value":"static IpcSemaphoreId InternalIpcSemaphoreCreate(IpcSemaphoreKey semKey, int numSems) { int\t\t\tsemId; semId = semget(semKey, numSems, IPC_CREAT | IPC_EXCL | IPCProtection); if (semId < 0) { int\t\t\tsaved...","count":3},{"name":"api-example","value":"static IpcSemaphoreId IpcSemaphoreCreate(int numSems) { IpcSemaphoreId semId; union semun semun; PGSemaphoreData mysema; for (nextSemaKey++;; nextSemaKey++) { pid_t\t\tcreatorPID; semId = InternalIpcSem...","count":3},{"name":"api-example","value":"static JsonParseErrorType jsonb_in_object_start(void *pstate) { JsonbInState *_state = (JsonbInState *) pstate; _state->res = pushJsonbValue(&_state->parseState, WJB_BEGIN_OBJECT, NULL); _state->parse...","count":3},{"name":"api-example","value":"static JsonPathBool executeLikeRegex(JsonPathItem *jsp, JsonbValue *str, JsonbValue *rarg, void *param) { JsonLikeRegexContext *cxt = param; if (!(str = getScalar(str, jbvString))) return jpbUnknown; ...","count":3},{"name":"api-example","value":"static JsonPathExecResult executeBinaryArithmExpr(JsonPathExecContext *cxt, JsonPathItem *jsp, JsonbValue *jb, BinaryArithmFunc func, JsonValueList *found) { JsonPathExecResult jper; JsonPathItem elem...","count":3},{"name":"api-example","value":"static JsonPathExecResult executeDateTimeMethod(JsonPathExecContext *cxt, JsonPathItem *jsp, JsonbValue *jb, JsonValueList *found) { JsonbValue\tjbvbuf; Datum\t\tvalue; text\t   *datetime; Oid\t\t\tcollid; O...","count":3},{"name":"api-example","value":"static JsonPathExecResult executeItem(JsonPathExecContext *cxt, JsonPathItem *jsp, JsonbValue *jb, JsonValueList *found) { return executeItemOptUnwrapTarget(cxt, jsp, jb, found, jspAutoUnwrap(cxt)); }","count":3},{"name":"api-example","value":"static JsonPathExecResult executeJsonPath(JsonPath *path, void *vars, JsonPathGetVarCallback getVar, JsonPathCountVarsCallback countVars, Jsonb *json, bool throwErrors, JsonValueList *result, bool use...","count":3},{"name":"api-example","value":"static List * RewriteQuery(Query *parsetree, List *rewrite_events, int orig_rt_length) { CmdType\t\tevent = parsetree->commandType; bool\t\tinstead = false; bool\t\treturning = false; bool\t\tupdatableview = ...","count":3},{"name":"api-example","value":"static List * build_index_paths(PlannerInfo *root, RelOptInfo *rel, IndexOptInfo *index, IndexClauseSet *clauses, bool useful_predicate, ScanTypeControl scantype, bool *skip_nonnative_saop) { List\t   ...","count":3},{"name":"api-example","value":"static List * build_path_tlist(PlannerInfo *root, Path *path) { List\t   *tlist = NIL; Index\t   *sortgrouprefs = path->pathtarget->sortgrouprefs; int\t\t\tresno = 1; ListCell   *v; foreach(v, path->pathta...","count":3},{"name":"api-example","value":"static List * generate_bitmap_or_paths(PlannerInfo *root, RelOptInfo *rel, List *clauses, List *other_clauses) { List\t   *result = NIL; List\t   *all_clauses; ListCell   *lc; * We can use both the curr...","count":3},{"name":"api-example","value":"static List * generate_join_implied_equalities_broken(PlannerInfo *root, EquivalenceClass *ec, Relids nominal_join_relids, Relids outer_relids, Relids nominal_inner_relids, RelOptInfo *inner_rel) { Li...","count":3},{"name":"api-example","value":"static List * generate_join_implied_equalities_normal(PlannerInfo *root, EquivalenceClass *ec, Relids join_relids, Relids outer_relids, Relids inner_relids) { List\t   *result = NIL; List\t   *new_membe...","count":3},{"name":"api-example","value":"static List * generate_setop_tlist(List *colTypes, List *colCollations, int flag, Index varno, bool hack_constants, List *input_tlist, List *refnames_tlist, bool *trivial_tlist) { List\t   *tlist = NIL...","count":3},{"name":"api-example","value":"static List * getTokenTypes(Oid prsId, List *tokennames) { TSParserCacheEntry *prs = lookup_ts_parser_cache(prsId); LexDescr   *list; List\t   *result = NIL; int\t\t\tntoken; ListCell   *tn; ntoken = list...","count":3},{"name":"api-example","value":"static List * get_ext_ver_list(ExtensionControlFile *control) { List\t   *evi_list = NIL; int\t\t\textnamelen = strlen(control->name); char\t   *location; DIR\t\t   *dir; struct dirent *de; location = get_ex...","count":3},{"name":"api-example","value":"static List * get_qual_for_list(Relation parent, PartitionBoundSpec *spec) { PartitionKey key = RelationGetPartitionKey(parent); List\t   *result; Expr\t   *keyCol; Expr\t   *opexpr; NullTest   *nulltest...","count":3},{"name":"api-example","value":"static List * select_mergejoin_clauses(PlannerInfo *root, RelOptInfo *joinrel, RelOptInfo *outerrel, RelOptInfo *innerrel, List *restrictlist, JoinType jointype, bool *mergejoin_allowed) { List\t   *re...","count":3},{"name":"api-example","value":"static MinimalTuple hashagg_batch_read(HashAggBatch *batch, uint32 *hashp) { LogicalTape *tape = batch->input_tape; MinimalTuple tuple; uint32\t\tt_len; size_t\t\tnread; uint32\t\thash; nread = LogicalTapeR...","count":3},{"name":"api-example","value":"static NODE * clean_NOT_intree(NODE *node) { check_stack_depth(); if (node->valnode->type == QI_VAL) return node; if (node->valnode->qoperator.oper == OP_NOT) { freetree(node); return NULL; } if (node...","count":3},{"name":"api-example","value":"static NestLoop * create_nestloop_plan(PlannerInfo *root, NestPath *best_path) { NestLoop   *join_plan; Plan\t   *outer_plan; Plan\t   *inner_plan; List\t   *tlist = build_path_tlist(root, &best_path->jp...","count":3},{"name":"api-example","value":"static Node * ParseComplexProjection(ParseState *pstate, const char *funcname, Node *first_arg, int location) { TupleDesc\ttupdesc; int\t\t\ti; * Special case for whole-row Vars so that we can resolve (fo...","count":3},{"name":"api-example","value":"static Node * build_subplan(PlannerInfo *root, Plan *plan, Path *path, PlannerInfo *subroot, List *plan_params, SubLinkType subLinkType, int subLinkId, Node *testexpr, List *testexpr_paramids, bool un...","count":3},{"name":"api-example","value":"static Node * coerce_record_to_complex(ParseState *pstate, Node *node, Oid targetTypeId, CoercionContext ccontext, CoercionForm cformat, int location) { RowExpr    *rowexpr; Oid\t\t\tbaseTypeId; int32\t\tb...","count":3},{"name":"api-example","value":"static Node * cookConstraint(ParseState *pstate, Node *raw_constraint, char *relname) { Node\t   *expr; * Transform raw parsetree to executable expression. */ expr = transformExpr(pstate, raw_constrain...","count":3},{"name":"api-example","value":"static Node * fix_scan_expr_mutator(Node *node, fix_scan_expr_context *context) { if (node == NULL) return NULL; if (IsA(node, Var)) { Var\t\t   *var = copyVar((Var *) node); Assert(var->varlevelsup == ...","count":3},{"name":"api-example","value":"static Node * flatten_grouping_sets(Node *expr, bool toplevel, bool *hasGroupingSets) { check_stack_depth(); if (expr == (Node *) NIL) return (Node *) NIL; switch (expr->type) { case T_RowExpr: { RowE...","count":3},{"name":"api-example","value":"static Node * like_regex_support(Node *rawreq, Pattern_Type ptype) { Node\t   *ret = NULL; if (IsA(rawreq, SupportRequestSelectivity)) { * Make a selectivity estimate for a function call, just as we'd ...","count":3},{"name":"api-example","value":"static Node * pull_up_sublinks_jointree_recurse(PlannerInfo *root, Node *jtnode, Relids *relids) { check_stack_depth(); if (jtnode == NULL) { *relids = NULL; } else if (IsA(jtnode, RangeTblRef)) { int...","count":3},{"name":"api-example","value":"static Node * pullup_replace_vars_callback(Var *var, replace_rte_variables_context *context) { pullup_replace_vars_context *rcon = (pullup_replace_vars_context *) context->callback_arg; int\t\t\tvarattno...","count":3},{"name":"api-example","value":"static Node * transformFromClauseItem(ParseState *pstate, Node *n, ParseNamespaceItem **top_nsitem, List **namespace) { check_stack_depth(); if (IsA(n, RangeVar)) { RangeVar   *rv = (RangeVar *) n; Ra...","count":3},{"name":"api-example","value":"static Node * transformJsonFuncExpr(ParseState *pstate, JsonFuncExpr *func) { JsonExpr   *jsexpr; Node\t   *path_spec; const char *func_name = NULL; JsonFormatType default_format; switch (func->op) { c...","count":3},{"name":"api-example","value":"static Node * transformXmlExpr(ParseState *pstate, XmlExpr *x) { XmlExpr    *newx; ListCell   *lc; int\t\t\ti; newx = makeNode(XmlExpr); newx->op = x->op; if (x->name) newx->name = map_sql_identifier_to_...","count":3},{"name":"api-example","value":"static ObjectAddress ATExecColumnDefault(Relation rel, const char *colName, Node *newDefault, LOCKMODE lockmode) { TupleDesc\ttupdesc = RelationGetDescr(rel); AttrNumber\tattnum; ObjectAddress address; ...","count":3},{"name":"api-example","value":"static ObjectAddress ATExecDropColumn(List **wqueue, Relation rel, const char *colName, DropBehavior behavior, bool recurse, bool recursing, bool missing_ok, LOCKMODE lockmode, ObjectAddresses *addrs)...","count":3},{"name":"api-example","value":"static ObjectAddress ATExecDropIdentity(Relation rel, const char *colName, bool missing_ok, LOCKMODE lockmode, bool recurse, bool recursing) { HeapTuple\ttuple; Form_pg_attribute attTup; AttrNumber\tatt...","count":3},{"name":"api-example","value":"static ObjectAddress create_ctas_nodata(List *tlist, IntoClause *into) { List\t   *attrList; ListCell   *t, *lc; * Build list of ColumnDefs from non-junk elements of the tlist.  If a * column name list...","count":3},{"name":"api-example","value":"static ObjectAddress get_object_address_usermapping(List *object, bool missing_ok) { ObjectAddress address; Oid\t\t\tuserid; char\t   *username; char\t   *servername; ForeignServer *server; HeapTuple\ttp; O...","count":3},{"name":"api-example","value":"static ObjectAddress get_relation_by_qualified_name(ObjectType objtype, List *object, Relation *relp, LOCKMODE lockmode, bool missing_ok) { Relation\trelation; ObjectAddress address; address.classId = ...","count":3},{"name":"api-example","value":"static Oid AlterObjectNamespace_internal(Relation rel, Oid objid, Oid nspOid) { Oid\t\t\tclassId = RelationGetRelid(rel); int\t\t\toidCacheId = get_object_catcache_oid(classId); int\t\t\tnameCacheId = get_obje...","count":3},{"name":"api-example","value":"static Oid ValidateOperatorReference(List *name, Oid leftTypeId, Oid rightTypeId) { Oid\t\t\toid; bool\t\tdefined; oid = OperatorLookup(name, leftTypeId, rightTypeId, &defined); if (!OidIsValid(oid)) erepo...","count":3},{"name":"api-example","value":"static Oid do_start_worker(void) { List\t   *dblist; ListCell   *cell; TransactionId xidForceLimit; MultiXactId multiForceLimit; bool\t\tfor_xid_wrap; bool\t\tfor_multi_wrap; avw_dbase  *avdb; TimestampTz ...","count":3},{"name":"api-example","value":"static Oid get_other_operator(List *otherOp, Oid otherLeftTypeId, Oid otherRightTypeId, const char *operatorName, Oid operatorNamespace, Oid leftTypeId, Oid rightTypeId) { Oid\t\t\tother_oid; bool\t\tother...","count":3},{"name":"api-example","value":"static Oid insert_event_trigger_tuple(const char *trigname, const char *eventname, Oid evtOwner, Oid funcoid, List *taglist) { Relation\ttgrel; Oid\t\t\ttrigoid; HeapTuple\ttuple; Datum\t\tvalues[Natts_pg_tr...","count":3},{"name":"api-example","value":"static Oid lookup_am_handler_func(List *handler_name, char amtype) { Oid\t\t\thandlerOid; Oid\t\t\tfuncargtypes[1] = {INTERNALOID}; Oid\t\t\texpectedType = InvalidOid; if (handler_name == NIL) ereport(ERROR, (...","count":3},{"name":"api-example","value":"static Oid select_equality_operator(EquivalenceClass *ec, Oid lefttype, Oid righttype) { ListCell   *lc; foreach(lc, ec->ec_opfamilies) { Oid\t\t\topfamily = lfirst_oid(lc); Oid\t\t\topno; opno = get_opfami...","count":3},{"name":"api-example","value":"static PGresult * ecpg_result_by_descriptor(int line, const char *name) { struct descriptor *desc = ecpg_find_desc(line, name); if (desc == NULL) return NULL; return desc->result; }","count":3},{"name":"api-example","value":"static PGresult * libpqrcv_PQexec(PGconn *streamConn, const char *query) { PGresult   *lastResult = NULL; * PQexec() silently discards any prior query results on the connection. * This is not required...","count":3},{"name":"api-example","value":"static PQExpBuffer createViewAsClause(Archive *fout, const TableInfo *tbinfo) { PQExpBuffer query = createPQExpBuffer(); PQExpBuffer result = createPQExpBuffer(); PGresult   *res; int\t\t\tlen; appendPQE...","count":3},{"name":"api-example","value":"static PQconninfoOption * conninfo_parse(const char *conninfo, PQExpBuffer errorMessage, bool use_defaults) { char\t   *pname; char\t   *pval; char\t   *buf; char\t   *cp; char\t   *cp2; PQconninfoOption *...","count":3},{"name":"api-example","value":"static PTOKEN_PRIVILEGES GetPrivilegesToDelete(HANDLE hToken) { int\t\t\ti, j; DWORD\t\tlength; PTOKEN_PRIVILEGES tokenPrivs; LUID\t\tluidLockPages; LUID\t\tluidChangeNotify; if (!LookupPrivilegeValue(NULL, SE...","count":3},{"name":"api-example","value":"static PartitionBoundInfo create_list_bounds(PartitionBoundSpec **boundspecs, int nparts, PartitionKey key, int **mapping) { PartitionBoundInfo boundinfo; PartitionListValue *all_values; int\t\t\ti; int\t...","count":3},{"name":"api-example","value":"static Path * get_cheapest_parameterized_child_path(PlannerInfo *root, RelOptInfo *rel, Relids required_outer) { Path\t   *cheapest; ListCell   *lc; * Look up the cheapest existing path with no more th...","count":3},{"name":"api-example","value":"static PathKey * make_pathkey_from_sortop(PlannerInfo *root, Expr *expr, Oid ordering_op, bool nulls_first, Index sortref, bool create_it) { Oid\t\t\topfamily, opcintype, collation; int16\t\tstrategy; if (...","count":3},{"name":"api-example","value":"static Plan * set_indexonlyscan_references(PlannerInfo *root, IndexOnlyScan *plan, int rtoffset) { indexed_tlist *index_itlist; List\t   *stripped_indextlist; ListCell   *lc; * Vars in the plan node's ...","count":3},{"name":"api-example","value":"static PrivateRefCountEntry * GetPrivateRefCountEntry(Buffer buffer, bool do_move) { PrivateRefCountEntry *res; int\t\t\ti; Assert(BufferIsValid(buffer)); Assert(!BufferIsLocal(buffer)); * First search f...","count":3},{"name":"api-example","value":"static PyObject * PLy_debug(PyObject *self, PyObject *args, PyObject *kw) { return PLy_output(DEBUG2, self, args, kw); }","count":3},{"name":"api-example","value":"static PyObject * PLy_function_build_args(FunctionCallInfo fcinfo, PLyProcedure *proc) { PyObject   *volatile arg = NULL; PyObject   *args; int\t\t\ti; * Make any Py*_New() calls before the PG_TRY block ...","count":3},{"name":"api-example","value":"static PyObject * PLy_output(volatile int level, PyObject *self, PyObject *args, PyObject *kw) { int\t\t\tsqlstate = 0; char\t   *volatile sqlstatestr = NULL; char\t   *volatile message = NULL; char\t   *vo...","count":3},{"name":"api-example","value":"static PyObject * PLy_result_colnames(PyObject *self, PyObject *unused) { PLyResultObject *ob = (PLyResultObject *) self; PyObject   *list; int\t\t\ti; if (!ob->tupdesc) { PLy_exception_set(PLy_exc_error...","count":3},{"name":"api-example","value":"static PyObject * PLy_trigger_build_args(FunctionCallInfo fcinfo, PLyProcedure *proc, HeapTuple *rv) { TriggerData *tdata = (TriggerData *) fcinfo->context; TupleDesc\trel_descr = RelationGetDescr(tdat...","count":3},{"name":"api-example","value":"static Query * transformPLAssignStmt(ParseState *pstate, PLAssignStmt *stmt) { Query\t   *qry = makeNode(Query); ColumnRef  *cref = makeNode(ColumnRef); List\t   *indirection = stmt->indirection; int\t\t\t...","count":3},{"name":"api-example","value":"static RTEPermissionInfo * GetResultRTEPermissionInfo(ResultRelInfo *relinfo, EState *estate) { Index\t\trti; RangeTblEntry *rte; RTEPermissionInfo *perminfo = NULL; if (relinfo->ri_RootResultRelInfo) {...","count":3},{"name":"api-example","value":"static Ranges * brin_range_deserialize(int maxvalues, SerializedRanges *serialized) { int\t\t\ti, nvalues; char\t   *ptr, *dataptr; bool\t\ttypbyval; int\t\t\ttyplen; Size\t\tdatalen; Ranges\t   *range; Assert(se...","count":3},{"name":"api-example","value":"static RelOptInfo * create_grouping_paths(PlannerInfo *root, RelOptInfo *input_rel, PathTarget *target, bool target_parallel_safe, grouping_sets_data *gd) { Query\t   *parse = root->parse; RelOptInfo *...","count":3},{"name":"api-example","value":"static RelOptInfo * generate_recursion_path(SetOperationStmt *setOp, PlannerInfo *root, List *refnames_tlist, List **pTargetList) { RelOptInfo *result_rel; Path\t   *path; RelOptInfo *lrel, *rrel; Path...","count":3},{"name":"api-example","value":"static Relation AllocateRelationDesc(Form_pg_class relp) { Relation\trelation; MemoryContext oldcxt; Form_pg_class relationForm; oldcxt = MemoryContextSwitchTo(CacheMemoryContext); * allocate and zero ...","count":3},{"name":"api-example","value":"static ReorderBufferTXN * ReorderBufferTXNByXid(ReorderBuffer *rb, TransactionId xid, bool create, bool *is_new, XLogRecPtr lsn, bool create_as_top) { ReorderBufferTXN *txn; ReorderBufferTXNByIdEnt *e...","count":3},{"name":"api-example","value":"static Result * create_minmaxagg_plan(PlannerInfo *root, MinMaxAggPath *best_path) { Result\t   *plan; List\t   *tlist; ListCell   *lc; foreach(lc, best_path->mmaggregates) { MinMaxAggInfo *mminfo = (Mi...","count":3},{"name":"api-example","value":"static SASLStatus scram_exchange(void *opaq, char *input, int inputlen, char **output, int *outputlen) { fe_scram_state *state = (fe_scram_state *) opaq; PGconn\t   *conn = state->conn; const char *err...","count":3},{"name":"api-example","value":"static SPIPlanPtr ri_FetchPreparedPlan(RI_QueryKey *key) { RI_QueryHashEntry *entry; SPIPlanPtr\tplan; * On the first call initialize the hashtable */ if (!ri_query_cache) ri_InitHashTables(); * Lookup...","count":3},{"name":"api-example","value":"static SPIPlanPtr ri_PlanCheck(const char *querystr, int nargs, Oid *argtypes, RI_QueryKey *qkey, Relation fk_rel, Relation pk_rel) { SPIPlanPtr\tqplan; Relation\tquery_rel; Oid\t\t\tsave_userid; int\t\t\tsav...","count":3},{"name":"api-example","value":"static SV  * make_array_ref(plperl_array_info *info, int first, int last) { dTHX; int\t\t\ti; AV\t\t   *result = newAV(); for (i = first; i < last; i++) { if (info->nulls[i]) { * We can't use &PL_sv_undef ...","count":3},{"name":"api-example","value":"static SV  * plperl_call_perl_func(plperl_proc_desc *desc, FunctionCallInfo fcinfo) { dTHX; dSP; SV\t\t   *retval; int\t\t\ti; int\t\t\tcount; Oid\t\t   *argtypes = NULL; int\t\t\tnargs = 0; ENTER; SAVETMPS; PUSHM...","count":3},{"name":"api-example","value":"static SV  * split_array(plperl_array_info *info, int first, int last, int nest) { dTHX; int\t\t\ti; AV\t\t   *result; Assert(info->ndims > 0); check_stack_depth(); * Base case, return a reference to a sin...","count":3},{"name":"api-example","value":"static Selectivity like_selectivity(const char *patt, int pattlen, bool case_insensitive) { Selectivity sel = 1.0; int\t\t\tpos; for (pos = 0; pos < pattlen; pos++) { if (patt[pos] != '%' && patt[pos] !=...","count":3},{"name":"api-example","value":"static Selectivity mcelem_array_contained_selec(Datum *mcelem, int nmcelem, float4 *numbers, int nnumbers, Datum *array_data, int nitems, float4 *hist, int nhist, Oid operator, TypeCacheEntry *typentr...","count":3},{"name":"api-example","value":"static Size EstimateParamExecSpace(EState *estate, Bitmapset *params) { int\t\t\tparamid; Size\t\tsz = sizeof(int); paramid = -1; while ((paramid = bms_next_member(params, paramid)) >= 0) { Oid\t\t\ttypeOid; ...","count":3},{"name":"api-example","value":"static SpecialJoinInfo * build_child_join_sjinfo(PlannerInfo *root, SpecialJoinInfo *parent_sjinfo, Relids left_relids, Relids right_relids) { SpecialJoinInfo *sjinfo = makeNode(SpecialJoinInfo); Appe...","count":3},{"name":"api-example","value":"static SpecialJoinInfo * make_outerjoininfo(PlannerInfo *root, Relids left_rels, Relids right_rels, Relids inner_join_rels, JoinType jointype, Index ojrelid, List *clause) { SpecialJoinInfo *sjinfo = ...","count":3},{"name":"api-example","value":"static TSLexeme * LexizeExec(LexizeData *ld, ParsedLex **correspondLexem) { int\t\t\ti; ListDictionary *map; TSDictionaryCacheEntry *dict; TSLexeme   *res; if (ld->curDictId == InvalidOid) { * usual mode...","count":3},{"name":"api-example","value":"static TidScan * create_tidscan_plan(PlannerInfo *root, TidPath *best_path, List *tlist, List *scan_clauses) { TidScan    *scan_plan; Index\t\tscan_relid = best_path->path.parent->relid; List\t   *tidqua...","count":3},{"name":"api-example","value":"static TimestampTz ApplyLauncherGetWorkerStartTime(Oid subid) { LauncherLastStartTimesEntry *entry; TimestampTz ret; logicalrep_launcher_attach_dshmem(); entry = dshash_find(last_start_times, &subid, ...","count":3},{"name":"api-example","value":"static TimestampTz timestamptz_mi_interval_internal(TimestampTz timestamp, Interval *span, pg_tz *attimezone) { Interval\ttspan; interval_um_internal(span, &tspan); return timestamptz_pl_interval_inter...","count":3},{"name":"api-example","value":"static TransactionId RecordTransactionCommit(void) { TransactionId xid = GetTopTransactionIdIfAny(); bool\t\tmarkXidCommitted = TransactionIdIsValid(xid); TransactionId latestXid = InvalidTransactionId;...","count":3},{"name":"api-example","value":"static TupleTableSlot * CteScanNext(CteScanState *node) { EState\t   *estate; ScanDirection dir; bool\t\tforward; Tuplestorestate *tuplestorestate; bool\t\teof_tuplestore; TupleTableSlot *slot; * get state...","count":3},{"name":"api-example","value":"static TupleTableSlot * ExecBitmapHeapScan(PlanState *pstate) { BitmapHeapScanState *node = castNode(BitmapHeapScanState, pstate); return ExecScan(&node->ss, (ExecScanAccessMtd) BitmapHeapNext, (ExecS...","count":3},{"name":"api-example","value":"static TupleTableSlot * ExecMemoize(PlanState *pstate) { MemoizeState *node = castNode(MemoizeState, pstate); ExprContext *econtext = node->ss.ps.ps_ExprContext; PlanState  *outerNode; TupleTableSlot ...","count":3},{"name":"api-example","value":"static TupleTableSlot * IndexNextWithReorder(IndexScanState *node) { EState\t   *estate; ExprContext *econtext; IndexScanDesc scandesc; TupleTableSlot *slot; ReorderTuple *topmost = NULL; bool\t\twas_exa...","count":3},{"name":"api-example","value":"static TupleTableSlot * fetch_input_tuple(AggState *aggstate) { TupleTableSlot *slot; if (aggstate->sort_in) { CHECK_FOR_INTERRUPTS(); if (!tuplesort_gettupleslot(aggstate->sort_in, true, false, aggst...","count":3},{"name":"api-example","value":"static Tuplestorestate * GetCurrentFDWTuplestore(void) { Tuplestorestate *ret; ret = afterTriggers.query_stack[afterTriggers.query_depth].fdw_tuplestore; if (ret == NULL) { MemoryContext oldcxt; Resou...","count":3},{"name":"api-example","value":"static WalRcvExecResult * libpqrcv_exec(WalReceiverConn *conn, const char *query, const int nRetTypes, const Oid *retTypes) { PGresult   *pgres = NULL; WalRcvExecResult *walres = palloc0(sizeof(WalRcv...","count":3},{"name":"api-example","value":"static Walfile * dir_open_for_write(WalWriteMethod *wwmethod, const char *pathname, const char *temp_suffix, size_t pad_to_size) { DirectoryMethodData *dir_data = (DirectoryMethodData *) wwmethod; cha...","count":3},{"name":"api-example","value":"static XLogPageReadResult WaitForWALToBecomeAvailable(XLogRecPtr RecPtr, bool randAccess, bool fetching_ckpt, XLogRecPtr tliRecPtr, TimeLineID replayTLI, XLogRecPtr replayLSN, bool nonblocking) { stat...","count":3},{"name":"api-example","value":"static XLogRecData * XLogRecordAssemble(RmgrId rmid, uint8 info, XLogRecPtr RedoRecPtr, bool doPageWrites, XLogRecPtr *fpw_lsn, int *num_fpi, bool *topxid_included) { XLogRecData *rdt; uint64\t\ttotal_l...","count":3},{"name":"api-example","value":"static XLogRecPtr WalSndWaitForWal(XLogRecPtr loc) { int\t\t\twakeEvents; uint32\t\twait_event = 0; static XLogRecPtr RecentFlushPtr = InvalidXLogRecPtr; TimestampTz last_flush = 0; * Fast path to avoid ac...","count":3},{"name":"api-example","value":"static XLogRecord * ReadRecord(XLogPrefetcher *xlogprefetcher, int emode, bool fetching_ckpt, TimeLineID replayTLI) { XLogRecord *record; XLogReaderState *xlogreader = XLogPrefetcherGetReader(xlogpref...","count":3},{"name":"api-example","value":"static backslashResult exec_command_a(PsqlScanState scan_state, bool active_branch) { bool\t\tsuccess = true; if (active_branch) { if (pset.popt.topt.format != PRINT_ALIGNED) success = do_pset(\"format\",...","count":3},{"name":"api-example","value":"static backslashResult exec_command_bind(PsqlScanState scan_state, bool active_branch) { backslashResult status = PSQL_CMD_SKIP_LINE; if (active_branch) { char\t   *opt; int\t\t\tnparams = 0; int\t\t\tnalloc...","count":3},{"name":"api-example","value":"static backslashResult exec_command_conninfo(PsqlScanState scan_state, bool active_branch) { if (active_branch) { char\t   *db = PQdb(pset.db); if (db == NULL) printf(_(\"You are currently not connected...","count":3},{"name":"api-example","value":"static backslashResult exec_command_copy(PsqlScanState scan_state, bool active_branch) { bool\t\tsuccess = true; if (active_branch) { char\t   *opt = psql_scan_slash_option(scan_state, OT_WHOLE_LINE, NUL...","count":3},{"name":"api-example","value":"static backslashResult exec_command_elif(PsqlScanState scan_state, ConditionalStack cstack, PQExpBuffer query_buf) { bool\t\tsuccess = true; switch (conditional_stack_peek(cstack)) { case IFSTATE_TRUE: ...","count":3},{"name":"api-example","value":"static backslashResult exec_command_encoding(PsqlScanState scan_state, bool active_branch) { if (active_branch) { char\t   *encoding = psql_scan_slash_option(scan_state, OT_NORMAL, NULL, false); if (!e...","count":3},{"name":"api-example","value":"static backslashResult exec_command_reset(PsqlScanState scan_state, bool active_branch, PQExpBuffer query_buf) { if (active_branch) { resetPQExpBuffer(query_buf); psql_scan_reset(scan_state); if (!pse...","count":3},{"name":"api-example","value":"static bool * mcv_get_match_bitmap(PlannerInfo *root, List *clauses, Bitmapset *keys, List *exprs, MCVList *mcvlist, bool is_or) { ListCell   *l; bool\t   *matches; Assert(clauses != NIL); Assert(mcvli...","count":3},{"name":"api-example","value":"static bool AdjustFractDays(double frac, int scale, struct pg_itm_in *itm_in) { int\t\t\textra_days; if (frac == 0) return true; * We assume the input frac has abs value less than 1, so overflow of frac ...","count":3},{"name":"api-example","value":"static bool CleanupBackgroundWorker(int pid, int exitstatus) /* child's exit status */ { char\t\tnamebuf[MAXPGPATH]; slist_mutable_iter iter; slist_foreach_modify(iter, &BackgroundWorkerList) { Register...","count":3},{"name":"api-example","value":"static bool CopyReadLineText(CopyFromState cstate) { char\t   *copy_input_buf; int\t\t\tinput_buf_ptr; int\t\t\tcopy_buf_len; bool\t\tneed_data = false; bool\t\thit_eof = false; bool\t\tresult = false; bool\t\tfirst...","count":3},{"name":"api-example","value":"static bool CreateOptsFile(int argc, char *argv[], char *fullprogname) { FILE\t   *fp; int\t\t\ti; #define OPTS_FILE\t\"postmaster.opts\" if ((fp = fopen(OPTS_FILE, \"w\")) == NULL) { ereport(LOG, (errcode_for...","count":3},{"name":"api-example","value":"static bool DescribeQuery(const char *query, double *elapsed_msec) { bool\t\ttiming = pset.timing; PGresult   *result; bool\t\tOK; instr_time\tbefore, after; *elapsed_msec = 0; if (timing) INSTR_TIME_SET_C...","count":3},{"name":"api-example","value":"static bool EnableLockPagesPrivilege(int elevel) { HANDLE\t\thToken; TOKEN_PRIVILEGES tp; LUID\t\tluid; if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) { erepor...","count":3},{"name":"api-example","value":"static bool ExecQueryTuples(const PGresult *result) { bool\t\tsuccess = true; int\t\t\tnrows = PQntuples(result); int\t\t\tncolumns = PQnfields(result); int\t\t\tr, c; * We must turn off gexec_flag to avoid infi...","count":3},{"name":"api-example","value":"static bool FastPathGrantRelationLock(Oid relid, LOCKMODE lockmode) { uint32\t\tf; uint32\t\tunused_slot = FP_LOCK_SLOTS_PER_BACKEND; for (f = 0; f < FP_LOCK_SLOTS_PER_BACKEND; f++) { if (FAST_PATH_GET_BI...","count":3},{"name":"api-example","value":"static bool FunctionIsVisibleExt(Oid funcid, bool *is_missing) { HeapTuple\tproctup; Form_pg_proc procform; Oid\t\t\tpronamespace; bool\t\tvisible; proctup = SearchSysCache1(PROCOID, ObjectIdGetDatum(funcid...","count":3},{"name":"api-example","value":"static bool HeapTupleSatisfiesHistoricMVCC(HeapTuple htup, Snapshot snapshot, Buffer buffer) { HeapTupleHeader tuple = htup->t_data; TransactionId xmin = HeapTupleHeaderGetXmin(tuple); TransactionId x...","count":3},{"name":"api-example","value":"static bool HeapTupleSatisfiesMVCC(HeapTuple htup, Snapshot snapshot, Buffer buffer) { HeapTupleHeader tuple = htup->t_data; Assert(ItemPointerIsValid(&htup->t_self)); Assert(htup->t_tableOid != Inval...","count":3},{"name":"api-example","value":"static bool HeapTupleSatisfiesNonVacuumable(HeapTuple htup, Snapshot snapshot, Buffer buffer) { TransactionId dead_after = InvalidTransactionId; HTSV_Result res; res = HeapTupleSatisfiesVacuumHorizon(...","count":3},{"name":"api-example","value":"static bool InvalidateVictimBuffer(BufferDesc *buf_hdr) { uint32\t\tbuf_state; uint32\t\thash; LWLock\t   *partition_lock; BufferTag\ttag; Assert(GetPrivateRefCount(BufferDescriptorGetBuffer(buf_hdr)) == 1)...","count":3},{"name":"api-example","value":"static bool IsAffixFlagInUse(IspellDict *Conf, int affix, const char *affixflag) { char\t   *flagcur; char\t\tflag[BUFSIZ]; if (*affixflag == 0) return true; Assert(affix < Conf->nAffixData); flagcur = C...","count":3},{"name":"api-example","value":"static bool IsBooleanOpfamily(Oid opfamily) { if (opfamily < FirstNormalObjectId) return IsBuiltinBooleanOpfamily(opfamily); else return op_in_opfamily(BooleanEqualOperator, opfamily); }","count":3},{"name":"api-example","value":"static bool JsonTablePlanScanNextRow(JsonTablePlanState *planstate) { JsonbValue *jbv; MemoryContext oldcxt; * If planstate already has an active row and there is a nested plan, * check if it has an a...","count":3},{"name":"api-example","value":"static bool MergeWithExistingConstraint(Relation rel, const char *ccname, Node *expr, bool allow_merge, bool is_local, bool is_initially_valid, bool is_no_inherit) { bool\t\tfound; Relation\tconDesc; Sys...","count":3},{"name":"api-example","value":"static bool NotNullImpliedByRelConstraints(Relation rel, Form_pg_attribute attr) { NullTest   *nnulltest = makeNode(NullTest); nnulltest->arg = (Expr *) makeVar(1, attr->attnum, attr->atttypid, attr->...","count":3},{"name":"api-example","value":"static bool OperatorIsVisibleExt(Oid oprid, bool *is_missing) { HeapTuple\toprtup; Form_pg_operator oprform; Oid\t\t\toprnamespace; bool\t\tvisible; oprtup = SearchSysCache1(OPEROID, ObjectIdGetDatum(oprid)...","count":3},{"name":"api-example","value":"static bool PinBuffer(BufferDesc *buf, BufferAccessStrategy strategy) { Buffer\t\tb = BufferDescriptorGetBuffer(buf); bool\t\tresult; PrivateRefCountEntry *ref; Assert(!BufferIsLocal(b)); Assert(ReservedR...","count":3},{"name":"api-example","value":"static bool PrintQueryTuples(const PGresult *result, const printQueryOpt *opt, FILE *printQueryFout) { bool\t\tok = true; FILE\t   *fout = printQueryFout ? printQueryFout : pset.queryFout; printQuery(res...","count":3},{"name":"api-example","value":"static bool RWConflictExists(const SERIALIZABLEXACT *reader, const SERIALIZABLEXACT *writer) { dlist_iter\titer; Assert(reader != writer); if (SxactIsDoomed(reader) || SxactIsDoomed(writer) || dlist_is...","count":3},{"name":"api-example","value":"static bool ReindexRelationConcurrently(const ReindexStmt *stmt, Oid relationOid, const ReindexParams *params) { typedef struct ReindexIndexInfo { Oid\t\t\tindexId; Oid\t\t\ttableId; Oid\t\t\tamId; bool\t\tsafe;...","count":3},{"name":"api-example","value":"static bool SlruPhysicalWritePage(SlruCtl ctl, int64 pageno, int slotno, SlruWriteAll fdata) { SlruShared\tshared = ctl->shared; int64\t\tsegno = pageno / SLRU_PAGES_PER_SEGMENT; int\t\t\trpageno = pageno %...","count":3},{"name":"api-example","value":"static bool TransactionIdInArray(TransactionId xid, TransactionId *xip, Size num) { return num > 0 && bsearch(&xid, xip, num, sizeof(TransactionId), xidComparator) != NULL; }","count":3},{"name":"api-example","value":"static bool _bt_mark_page_halfdead(Relation rel, Relation heaprel, Buffer leafbuf, BTStack stack) { BlockNumber leafblkno; BlockNumber leafrightsib; BlockNumber topparent; BlockNumber topparentrightsi...","count":3},{"name":"api-example","value":"static bool _bt_rightsib_halfdeadflag(Relation rel, BlockNumber leafrightsib) { Buffer\t\tbuf; Page\t\tpage; BTPageOpaque opaque; bool\t\tresult; Assert(leafrightsib != P_NONE); buf = _bt_getbuf(rel, leafri...","count":3},{"name":"api-example","value":"static bool _equalConst(const Const *a, const Const *b) { COMPARE_SCALAR_FIELD(consttype); COMPARE_SCALAR_FIELD(consttypmod); COMPARE_SCALAR_FIELD(constcollid); COMPARE_SCALAR_FIELD(constlen); COMPARE...","count":3},{"name":"api-example","value":"static bool add_values_to_range(Relation idxRel, BrinDesc *bdesc, BrinMemTuple *dtup, const Datum *values, const bool *nulls) { int\t\t\tkeyno; bool\t\tmodified = dtup->bt_empty_range; * Compare the key va...","count":3},{"name":"api-example","value":"static bool append_db_pattern_cte(PQExpBuffer buf, const PatternInfoArray *pia, PGconn *conn, bool inclusive) { int\t\t\tpattern_id; const char *comma; bool\t\thave_values; comma = \"\"; have_values = false;...","count":3},{"name":"api-example","value":"static bool array_element_has_equality(TypeCacheEntry *typentry) { if (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES)) cache_array_element_properties(typentry); return (typentry->flags & TCFLAGS...","count":3},{"name":"api-example","value":"static bool array_element_has_extended_hashing(TypeCacheEntry *typentry) { if (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES)) cache_array_element_properties(typentry); return (typentry->flags &...","count":3},{"name":"api-example","value":"static bool array_element_has_hashing(TypeCacheEntry *typentry) { if (!(typentry->flags & TCFLAGS_CHECKED_ELEM_PROPERTIES)) cache_array_element_properties(typentry); return (typentry->flags & TCFLAGS_...","count":3},{"name":"api-example","value":"static bool asyncQueueIsFull(void) { int64\t\theadPage = QUEUE_POS_PAGE(QUEUE_HEAD); int64\t\ttailPage = QUEUE_POS_PAGE(QUEUE_TAIL); int64\t\toccupied = headPage - tailPage; return occupied >= max_notify_qu...","count":3},{"name":"api-example","value":"static bool bbstreamer_tar_header(bbstreamer_tar_parser *mystreamer) { bool\t\thas_nonzero_byte = false; int\t\t\ti; bbstreamer_member *member = &mystreamer->member; char\t   *buffer = mystreamer->base.bbs_...","count":3},{"name":"api-example","value":"static bool build_minmax_path(PlannerInfo *root, MinMaxAggInfo *mminfo, Oid eqop, Oid sortop, bool nulls_first) { PlannerInfo *subroot; Query\t   *parse; TargetEntry *tle; List\t   *tlist; NullTest   *n...","count":3},{"name":"api-example","value":"static bool canChangeResultMode(PGconn *conn) { * Only allow changing the mode when we have launched a query and not yet * received any results. */ if (!conn) return false; if (conn->asyncStatus != PG...","count":3},{"name":"api-example","value":"static bool checkExtensionMembership(DumpableObject *dobj, Archive *fout) { ExtensionInfo *ext = findOwningExtension(dobj->catId); if (ext == NULL) return false; dobj->ext_member = true; addObjectDepe...","count":3},{"name":"api-example","value":"static bool checkStringLen(size_t len, Node *escontext) { if (len > JENTRY_OFFLENMASK) ereturn(escontext, false, (errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED), errmsg(\"string too long to represent as jsonb...","count":3},{"name":"api-example","value":"static bool check_hash_func_signature(Oid funcid, int16 amprocnum, Oid argtype) { bool\t\tresult = true; Oid\t\t\trestype; int16\t\tnargs; HeapTuple\ttp; Form_pg_proc procform; switch (amprocnum) { case HASHS...","count":3},{"name":"api-example","value":"static bool check_hostname(hbaPort *port, const char *hostname) { struct addrinfo *gai_result, *gai; int\t\t\tret; bool\t\tfound; if (port->remote_hostname_resolv < 0) return false; if (!port->remote_hostn...","count":3},{"name":"api-example","value":"static bool check_log_statement(List *stmt_list) { ListCell   *stmt_item; if (log_statement == LOGSTMT_NONE) return false; if (log_statement == LOGSTMT_ALL) return true; foreach(stmt_item, stmt_list) ...","count":3},{"name":"api-example","value":"static bool check_nested_generated_walker(Node *node, void *context) { ParseState *pstate = context; if (node == NULL) return false; else if (IsA(node, Var)) { Var\t\t   *var = (Var *) node; Oid\t\t\trelid...","count":3},{"name":"api-example","value":"static bool check_simple_rowfilter_expr_walker(Node *node, ParseState *pstate) { char\t   *errdetail_msg = NULL; if (node == NULL) return false; switch (nodeTag(node)) { case T_Var: if (((Var *) node)-...","count":3},{"name":"api-example","value":"static bool choose_hashed_setop(PlannerInfo *root, List *groupClauses, Path *input_path, double dNumGroups, double dNumOutputRows, const char *construct) { int\t\t\tnumGroupCols = list_length(groupClause...","count":3},{"name":"api-example","value":"static bool coerce_fn_result_column(TargetEntry *src_tle, Oid res_type, int32 res_typmod, bool tlist_is_modifiable, List **upper_tlist, bool *upper_tlist_nontrivial) { TargetEntry *new_tle; Expr\t   *n...","count":3},{"name":"api-example","value":"static bool command_no_begin(const char *query) { int\t\t\twordlen; * First we must advance over any whitespace and comments. */ query = skip_white_space(query); * Check word length (since \"beginx\" is no...","count":3},{"name":"api-example","value":"static bool contain_mutable_or_user_functions_checker(Oid func_id, void *context) { return (func_volatile(func_id) != PROVOLATILE_IMMUTABLE || func_id >= FirstNormalObjectId); }","count":3},{"name":"api-example","value":"static bool convert_to_base_unit(double value, const char *unit, int base_unit, double *base_value) { char\t\tunitstr[MAX_UNIT_LEN + 1]; int\t\t\tunitlen; const unit_conversion *table; int\t\t\ti; unitlen = 0...","count":3},{"name":"api-example","value":"static bool dataIsMoveRight(GinBtree btree, Page page) { ItemPointer iptr = GinDataPageGetRightBound(page); if (GinPageRightMost(page)) return false; if (GinPageIsDeleted(page)) return true; return (g...","count":3},{"name":"api-example","value":"static bool doRetry(CState *st, pg_time_usec_t *now) { Assert(st->estatus != ESTATUS_NO_ERROR); if (!canRetryError(st->estatus)) return false; * We must have at least one option to limit the retrying ...","count":3},{"name":"api-example","value":"static bool do_edit(const char *filename_arg, PQExpBuffer query_buf, int lineno, bool discard_on_quit, bool *edited) { char\t\tfnametmp[MAXPGPATH]; FILE\t   *stream = NULL; const char *fname; bool\t\terror...","count":3},{"name":"api-example","value":"static bool dsm_impl_windows(dsm_op op, dsm_handle handle, Size request_size, void **impl_private, void **mapped_address, Size *mapped_size, int elevel) { char\t   *address; HANDLE\t\thmap; char\t\tname[64...","count":3},{"name":"api-example","value":"static bool find_window_run_conditions(Query *subquery, RangeTblEntry *rte, Index rti, AttrNumber attno, WindowFunc *wfunc, OpExpr *opexpr, bool wfunc_left, bool *keep_original, Bitmapset **run_cond_a...","count":3},{"name":"api-example","value":"static bool flattenJsonPathParseItem(StringInfo buf, int *result, struct Node *escontext, JsonPathParseItem *item, int nestingLevel, bool insideArraySubscript) { int32\t\tpos = buf->len - JSONPATH_HDRSZ...","count":3},{"name":"api-example","value":"static bool getPublicationSchemaInfo(const ObjectAddress *object, bool missing_ok, char **pubname, char **nspname) { HeapTuple\ttup; Form_pg_publication_namespace pnform; tup = SearchSysCache1(PUBLICAT...","count":3},{"name":"api-example","value":"static bool get_create_object_cmd(EditableObjectType obj_type, Oid oid, PQExpBuffer buf) { bool\t\tresult = true; PQExpBuffer query = createPQExpBuffer(); PGresult   *res; switch (obj_type) { case Edita...","count":3},{"name":"api-example","value":"static bool get_nextfield(char **str, char *next) { int\t\t\tstate = PAE_WAIT_MASK; int\t\t\tavail = BUFSIZ; while (**str) { if (state == PAE_WAIT_MASK) { if (t_iseq(*str, '#')) return false; else if (!t_is...","count":3},{"name":"api-example","value":"static bool get_object_type(const char *keyword, int size, FilterObjectType *objtype) { if (is_keyword_str(\"table_data\", keyword, size)) *objtype = FILTER_OBJECT_TYPE_TABLE_DATA; else if (is_keyword_s...","count":3},{"name":"api-example","value":"static bool gistdeletepage(IndexVacuumInfo *info, IndexBulkDeleteResult *stats, Buffer parentBuffer, OffsetNumber downlink, Buffer leafBuffer) { Page\t\tparentPage = BufferGetPage(parentBuffer); Page\t\tl...","count":3},{"name":"api-example","value":"static bool has_indexed_join_quals(NestPath *path) { JoinPath   *joinpath = &path->jpath; Relids\t\tjoinrelids = joinpath->path.parent->relids; Path\t   *innerpath = joinpath->innerjoinpath; List\t   *ind...","count":3},{"name":"api-example","value":"static bool has_matching_range(BrinDesc *bdesc, Oid colloid, Ranges *ranges, Datum newval, AttrNumber attno, Oid typid) { Datum\t\tcompar; Datum\t\tminvalue; Datum\t\tmaxvalue; FmgrInfo   *cmpLessFn; FmgrIn...","count":3},{"name":"api-example","value":"static bool has_param_priv_byname(Oid roleid, const text *parameter, AclMode priv) { char\t   *paramstr = text_to_cstring(parameter); return pg_parameter_aclcheck(paramstr, roleid, priv) == ACLCHECK_OK...","count":3},{"name":"api-example","value":"static bool heap_acquire_tuplock(Relation relation, ItemPointer tid, LockTupleMode mode, LockWaitPolicy wait_policy, bool *have_tuple_lock) { if (*have_tuple_lock) return true; switch (wait_policy) { ...","count":3},{"name":"api-example","value":"static bool heapam_scan_bitmap_next_tuple(TableScanDesc scan, TBMIterateResult *tbmres, TupleTableSlot *slot) { HeapScanDesc hscan = (HeapScanDesc) scan; OffsetNumber targoffset; Page\t\tpage; ItemId\t\tl...","count":3},{"name":"api-example","value":"static bool hk_breadth_search(BipartiteMatchState *state) { int\t\t\tusize = state->u_size; short\t   *queue = state->queue; short\t   *distance = state->distance; int\t\t\tqhead = 0;\t\t/* we never enqueue any...","count":3},{"name":"api-example","value":"static bool interpret_ident_response(const char *ident_response, char *ident_user) { const char *cursor = ident_response;\t/* Cursor into *ident_response */ * Ident's response, in the telnet tradition,...","count":3},{"name":"api-example","value":"static bool inzone(char **fields, int nfields) { ptrdiff_t\ti; if (nfields < ZONE_MINFIELDS || nfields > ZONE_MAXFIELDS) { error(_(\"wrong number of fields on Zone line\")); return false; } if (lcltime !...","count":3},{"name":"api-example","value":"static bool isSimpleNode(Node *node, Node *parentNode, int prettyFlags) { if (!node) return false; switch (nodeTag(node)) { case T_Var: case T_Const: case T_Param: case T_CoerceToDomainValue: case T_S...","count":3},{"name":"api-example","value":"static bool is_next_separator(FormatNode *n) { if (n->type == NODE_TYPE_END) return false; if (n->type == NODE_TYPE_ACTION && S_THth(n->suffix)) return true; * Next node */ n++; if (n->type == NODE_TY...","count":3},{"name":"api-example","value":"static bool itsdir(char const *name) { struct stat st; int\t\t\tres = stat(name, &st); #ifdef S_ISDIR if (res == 0) return S_ISDIR(st.st_mode) != 0; #endif if (res == 0 || errno == EOVERFLOW) { size_t\t\tn...","count":3},{"name":"api-example","value":"static bool jsonb_path_ops__add_path_item(JsonPathGinPath *path, JsonPathItem *jsp) { switch (jsp->type) { case jpiRoot: path->hash = 0;\t\t/* reset path hash */ return true; case jpiKey: { JsonbValue\tj...","count":3},{"name":"api-example","value":"static bool leafRepackItems(disassembledLeaf *leaf, ItemPointer remaining) { int\t\t\tpgused = 0; bool\t\tneedsplit = false; dlist_iter\titer; int\t\t\tsegsize; leafSegmentInfo *nextseg; int\t\t\tnpacked; bool\t\tm...","count":3},{"name":"api-example","value":"static bool libpqrcv_startstreaming(WalReceiverConn *conn, const WalRcvStreamOptions *options) { StringInfoData cmd; PGresult   *res; Assert(options->logical == conn->logical); Assert(options->slotnam...","count":3},{"name":"api-example","value":"static bool line_interpt_line(Point *result, LINE *l1, LINE *l2) { float8\t\tx, y; if (!FPzero(l1->B)) { if (FPeq(l2->A, float8_mul(l1->A, float8_div(l2->B, l1->B)))) return false; x = float8_div(float8...","count":3},{"name":"api-example","value":"static bool logfile_rotate_dest(bool time_based_rotation, int size_rotation_for, pg_time_t fntime, int target_dest, char **last_file_name, FILE **logFile) { char\t   *logFileExt = NULL; char\t   *filena...","count":3},{"name":"api-example","value":"static bool ltsReadFillBuffer(LogicalTape *lt) { lt->pos = 0; lt->nbytes = 0; do { char\t   *thisbuf = lt->buffer + lt->nbytes; int64\t\tdatablocknum = lt->nextBlockNumber; if (datablocknum == -1L) break...","count":3},{"name":"api-example","value":"static bool mark_file_as_archived(StreamCtl *stream, const char *fname) { Walfile    *f; static char tmppath[MAXPGPATH]; snprintf(tmppath, sizeof(tmppath), \"archive_status/%s.done\", fname); f = stream...","count":3},{"name":"api-example","value":"static bool match_prosrc_to_literal(const char *prosrc, const char *literal, int cursorpos, int *newcursorpos) { int\t\t\tnewcp = cursorpos; int\t\t\tchlen; * This implementation handles backslashes and dou...","count":3},{"name":"api-example","value":"static bool max_parallel_hazard_checker(Oid func_id, void *context) { return max_parallel_hazard_test(func_parallel(func_id), (max_parallel_hazard_context *) context); }","count":3},{"name":"api-example","value":"static bool moveRightIfItNeeded(GinBtreeData *btree, GinBtreeStack *stack, Snapshot snapshot) { Page\t\tpage = BufferGetPage(stack->buffer); if (stack->off > PageGetMaxOffsetNumber(page)) { * We scanned...","count":3},{"name":"api-example","value":"static bool owningrel_does_not_exist_skipping(List *object, const char **msg, char **name) { List\t   *parent_object; RangeVar   *parent_rel; parent_object = list_copy_head(object, list_length(object) ...","count":3},{"name":"api-example","value":"static bool pa_can_start(void) { if (!am_leader_apply_worker()) return false; * It is good to check for any change in the subscription parameter to * avoid the case where for a very long time the chan...","count":3},{"name":"api-example","value":"static bool pg_input_is_valid_common(FunctionCallInfo fcinfo, text *txt, text *typname, ErrorSaveContext *escontext) { char\t   *str = text_to_cstring(txt); ValidIOData *my_extra; Datum\t\tconverted; * W...","count":3},{"name":"api-example","value":"static bool pgwin32_IsInstalled(SC_HANDLE hSCM) { SC_HANDLE\thService = OpenService(hSCM, register_servicename, SERVICE_QUERY_CONFIG); bool\t\tbResult = (hService != NULL); if (bResult) CloseServiceHandl...","count":3},{"name":"api-example","value":"static bool predicate_implied_by_simple_clause(Expr *predicate, Node *clause, bool weak) { CHECK_FOR_INTERRUPTS(); * A simple and general rule is that a clause implies itself, hence we * check if they...","count":3},{"name":"api-example","value":"static bool range_bounds_overlaps(TypeCacheEntry *typcache, RangeBound *lower1, RangeBound *upper1, RangeBound *lower2, RangeBound *upper2) { if (range_cmp_bounds(typcache, lower1, lower2) >= 0 && ran...","count":3},{"name":"api-example","value":"static bool read_backup_label(XLogRecPtr *checkPointLoc, TimeLineID *backupLabelTLI, bool *backupEndRequired, bool *backupFromStandby) { char\t\tstartxlogfilename[MAXFNAMELEN]; TimeLineID\ttli_from_walse...","count":3},{"name":"api-example","value":"static bool reconsider_full_join_clause(PlannerInfo *root, OuterJoinClauseInfo *ojcinfo) { RestrictInfo *rinfo = ojcinfo->rinfo; SpecialJoinInfo *sjinfo = ojcinfo->sjinfo; Relids\t\tfjrelids = bms_make_...","count":3},{"name":"api-example","value":"static bool record_fields_have_compare(TypeCacheEntry *typentry) { if (!(typentry->flags & TCFLAGS_CHECKED_FIELD_PROPERTIES)) cache_record_field_properties(typentry); return (typentry->flags & TCFLAGS...","count":3},{"name":"api-example","value":"static bool runShellCommand(Variables *variables, char *variable, char **argv, int argc) { char\t\tcommand[SHELL_COMMAND_SIZE]; int\t\t\ti, len = 0; FILE\t   *fp; char\t\tres[64]; char\t   *endptr; int\t\t\tretva...","count":3},{"name":"api-example","value":"static bool schema_does_not_exist_skipping(List *object, const char **msg, char **name) { RangeVar   *rel; rel = makeRangeVarFromNameList(object); if (rel->schemaname != NULL && !OidIsValid(LookupName...","count":3},{"name":"api-example","value":"static bool scram_channel_bound(void *opaq) { fe_scram_state *state = (fe_scram_state *) opaq; if (state == NULL) return false; if (state->state != FE_SCRAM_FINISHED) return false; if (strcmp(state->s...","count":3},{"name":"api-example","value":"static bool search_directory(const char *directory, const char *fname) { int\t\t\tfd = -1; DIR\t\t   *xldir; if (fname != NULL) fd = open_file_in_directory(directory, fname); * A valid file name is not pas...","count":3},{"name":"api-example","value":"static bool sendFeedback(PGconn *conn, TimestampTz now, bool force, bool replyRequested) { static XLogRecPtr last_written_lsn = InvalidXLogRecPtr; static XLogRecPtr last_fsync_lsn = InvalidXLogRecPtr;...","count":3},{"name":"api-example","value":"static bool set_var_from_str(const char *str, const char *cp, NumericVar *dest, const char **endptr, Node *escontext) { bool\t\thave_dp = false; int\t\t\ti; unsigned char *decdigits; int\t\t\tsign = NUMERIC_P...","count":3},{"name":"api-example","value":"static bool splitTzLine(const char *filename, int lineno, char *line, tzEntry *tzentry) { char\t   *abbrev; char\t   *offset; char\t   *offset_endptr; char\t   *remain; char\t   *is_dst; tzentry->lineno = ...","count":3},{"name":"api-example","value":"static bool statext_is_compatible_clause_internal(PlannerInfo *root, Node *clause, Index relid, Bitmapset **attnums, List **exprs, bool *leakproof) { if (IsA(clause, RelabelType)) clause = (Node *) ((...","count":3},{"name":"api-example","value":"static bool touched_lseg_inside_poly(Point *a, Point *b, LSEG *s, POLYGON *poly, int start) { LSEG\t\tt; t.p[0] = *a; t.p[1] = *b; if (point_eq_point(a, s->p)) { if (lseg_contain_point(&t, s->p + 1)) re...","count":3},{"name":"api-example","value":"static bool use_physical_tlist(PlannerInfo *root, Path *path, int flags) { RelOptInfo *rel = path->parent; int\t\t\ti; ListCell   *lc; * Forget it if either exact tlist or small tlist is demanded. */ if ...","count":3},{"name":"api-example","value":"static bool validOperatorName(const char *name) { size_t\t\tlen = strlen(name); if (len == 0 || len >= NAMEDATALEN) return false; if (strspn(name, \"~!@#^&|`?+-*/%<>=\") != len) return false; if (strstr(n...","count":3},{"name":"api-example","value":"static bool verify_page_checksum(Page page, XLogRecPtr start_lsn, BlockNumber blkno, uint16 *expected_checksum) { PageHeader\tphdr; uint16\t\tchecksum; * Only check pages which have not been modified sin...","count":3},{"name":"api-example","value":"static bool wait_for_postmaster_stop(void) { int\t\t\tcnt; for (cnt = 0; cnt < wait_seconds * WAITS_PER_SEC; cnt++) { pid_t\t\tpid; if ((pid = get_pgpid(false)) == 0) return true;\t\t/* pid file is gone */ i...","count":3},{"name":"api-example","value":"static char * AppendSeconds(char *cp, int sec, fsec_t fsec, int precision, bool fillzeros) { Assert(precision >= 0); if (fillzeros) cp = pg_ultostr_zeropad(cp, abs(sec), 2); else cp = pg_ultostr(cp, a...","count":3},{"name":"api-example","value":"static char * ChooseIndexName(const char *tabname, Oid namespaceId, const List *colnames, const List *exclusionOpNames, bool primary, bool isconstraint) { char\t   *indexname; if (primary) { indexname ...","count":3},{"name":"api-example","value":"static char * EncodeTimezone(char *str, int tz, int style) { int\t\t\thour, min, sec; sec = abs(tz); min = sec / SECS_PER_MINUTE; sec -= min * SECS_PER_MINUTE; hour = min / MINS_PER_HOUR; min -= hour * M...","count":3},{"name":"api-example","value":"static char * ExecGetJsonValueItemString(JsonbValue *item, bool *resnull) { *resnull = false; switch (item->type) { case jbvNull: *resnull = true; return NULL; case jbvString: { char\t   *str = palloc(...","count":3},{"name":"api-example","value":"static char * ExecSerializePlan(Plan *plan, EState *estate) { PlannedStmt *pstmt; ListCell   *lc; plan = copyObject(plan); * The worker will start its own copy of the executor, and that copy will * in...","count":3},{"name":"api-example","value":"static char * NUM_processor(FormatNode *node, NUMDesc *Num, char *inout, char *number, int input_len, int to_char_out_pre_spaces, int sign, bool is_to_char, Oid collid) { FormatNode *n; NUMProc\t\t_Np, ...","count":3},{"name":"api-example","value":"static char * _yconv(int a, int b, bool convert_top, bool convert_yy, char *pt, const char *ptlim) { int\t\t\tlead; int\t\t\ttrail; #define DIVISOR\t100 trail = a % DIVISOR + b % DIVISOR; lead = a / DIVISOR ...","count":3},{"name":"api-example","value":"static char * getVariable(Variables *variables, char *name) { Variable   *var; char\t\tstringform[64]; var = lookupVariable(variables, name); if (var == NULL) return NULL;\t\t\t/* not found */ if (var->sva...","count":3},{"name":"api-example","value":"static char * get_base_conninfo(const char *conninfo, char **dbname) { PQExpBuffer buf; PQconninfoOption *conn_opts; PQconninfoOption *conn_opt; char\t   *errmsg = NULL; char\t   *ret; conn_opts = PQcon...","count":3},{"name":"api-example","value":"static char * get_errno_symbol(int errnum) { switch (errnum) { case E2BIG: return \"E2BIG\"; case EACCES: return \"EACCES\"; case EADDRINUSE: return \"EADDRINUSE\"; case EADDRNOTAVAIL: return \"EADDRNOTAVAIL...","count":3},{"name":"api-example","value":"static char * identify_target_directory(char *directory, char *fname) { char\t\tfpath[MAXPGPATH]; if (directory != NULL) { if (search_directory(directory, fname)) return pg_strdup(directory); snprintf(f...","count":3},{"name":"api-example","value":"static char * int_to_roman(int number) { int\t\t\tlen, num; char\t   *p, *result, numstr[12]; result = (char *) palloc(16); *result = '\\0'; if (number > 3999 || number < 1) { fill_str(result, '#', 15); re...","count":3},{"name":"api-example","value":"static char * jsonPathToCstring(StringInfo out, JsonPath *in, int estimated_len) { StringInfoData buf; JsonPathItem v; if (!out) { out = &buf; initStringInfo(out); } enlargeStringInfo(out, estimated_l...","count":3},{"name":"api-example","value":"static char * libpqrcv_create_slot(WalReceiverConn *conn, const char *slotname, bool temporary, bool two_phase, bool failover, CRSSnapshotAction snapshot_action, XLogRecPtr *lsn) { PGresult   *res; St...","count":3},{"name":"api-example","value":"static char * read_attr_value(char **input, char attr) { char\t   *begin = *input; char\t   *end; if (*begin != attr) ereport(ERROR, (errcode(ERRCODE_PROTOCOL_VIOLATION), errmsg(\"malformed SCRAM message...","count":3},{"name":"api-example","value":"static char * read_attr_value(char **input, char attr, PQExpBuffer errorMessage) { char\t   *begin = *input; char\t   *end; if (*begin != attr) { libpq_append_error(errorMessage, \"malformed SCRAM messag...","count":3},{"name":"api-example","value":"static char * read_extension_script_file(const ExtensionControlFile *control, const char *filename) { int\t\t\tsrc_encoding; char\t   *src_str; char\t   *dest_str; int\t\t\tlen; src_str = read_whole_file(file...","count":3},{"name":"api-example","value":"static char * skip_drive(const char *path) { if (IS_DIR_SEP(path[0]) && IS_DIR_SEP(path[1])) { path += 2; while (*path && !IS_DIR_SEP(*path)) path++; } else if (isalpha((unsigned char) path[0]) && pat...","count":3},{"name":"api-example","value":"static char * stringlist_to_identifierstr(PGconn *conn, List *strings) { ListCell   *lc; StringInfoData res; bool\t\tfirst = true; initStringInfo(&res); foreach(lc, strings) { char\t   *val = strVal(lfir...","count":3},{"name":"api-example","value":"static char ** NormalizeSubWord(IspellDict *Conf, char *word, int flag) { AffixNodeData *suffix = NULL, *prefix = NULL; int\t\t\tslevel = 0, plevel = 0; int\t\t\twrdlen = strlen(word), swrdlen; char\t  **for...","count":3},{"name":"api-example","value":"static char GetAttributeCompression(Oid atttypid, const char *compression) { char\t\tcmethod; if (compression == NULL || strcmp(compression, \"default\") == 0) return InvalidCompressionMethod; * To specif...","count":3},{"name":"api-example","value":"static const char * get_name_for_var_field(Var *var, int fieldno, int levelsup, deparse_context *context) { RangeTblEntry *rte; AttrNumber\tattnum; int\t\t\tnetlevelsup; deparse_namespace *dpns; int\t\t\tvar...","count":3},{"name":"api-example","value":"static const char * get_th(char *num, int type) { int\t\t\tlen = strlen(num), last; last = *(num + (len - 1)); if (!isdigit((unsigned char) last)) ereport(ERROR, (errcode(ERRCODE_INVALID_TEXT_REPRESENTAT...","count":3},{"name":"api-example","value":"static const char * identify_system_timezone(void) { int\t\t\ti; char\t\ttzname[128]; char\t\tlocaltzname[256]; time_t\t\tt = time(NULL); struct tm  *tm = localtime(&t); HKEY\t\trootKey; int\t\t\tidx; if (!tm) { #i...","count":3},{"name":"api-example","value":"static const char * map_sql_table_to_xmlschema(TupleDesc tupdesc, Oid relid, bool nulls, bool tableforest, const char *targetns) { int\t\t\ti; char\t   *xmltn; char\t   *tabletypename; char\t   *rowtypename...","count":3},{"name":"api-example","value":"static const char * read_quoted_string(FilterStateData *fstate, const char *str, PQExpBuffer pattern) { appendPQExpBufferChar(pattern, '\"'); str++; while (1) { * We can ignore \\r or \\n chars because t...","count":3},{"name":"api-example","value":"static const char * skip_white_space(const char *query) { int\t\t\tcnestlevel = 0; /* slash-star comment nest level */ while (*query) { int\t\t\tmblen = PQmblenBounded(query, pset.encoding); * Note: we assu...","count":3},{"name":"api-example","value":"static double approx_tuple_count(PlannerInfo *root, JoinPath *path, List *quals) { double\t\ttuples; double\t\touter_tuples = path->outerjoinpath->rows; double\t\tinner_tuples = path->innerjoinpath->rows; S...","count":3},{"name":"api-example","value":"static double get_windowclause_startup_tuples(PlannerInfo *root, WindowClause *wc, double input_tuples) { int\t\t\tframeOptions = wc->frameOptions; double\t\tpartition_tuples; double\t\treturn_tuples; double...","count":3},{"name":"api-example","value":"static dsa_area * create_internal(void *place, size_t size, int tranche_id, dsm_handle control_handle, dsm_segment *control_segment, size_t init_segment_size, size_t max_segment_size) { dsa_area_contr...","count":3},{"name":"api-example","value":"static enum ARRAY_TYPE ecpg_is_type_an_array(int type, const struct statement *stmt, const struct variable *var) { char\t   *array_query; enum ARRAY_TYPE isarray = ECPG_ARRAY_NOT_SET; PGresult   *query...","count":3},{"name":"api-example","value":"static float8 box_closept_point(Point *result, BOX *box, Point *pt) { float8\t\tdist, d; Point\t\tpoint, closept; LSEG\t\tlseg; if (box_contain_point(box, pt)) { if (result != NULL) *result = *pt; return 0....","count":3},{"name":"api-example","value":"static float8 dist_ppoly_internal(Point *pt, POLYGON *poly) { float8\t\tresult; float8\t\td; int\t\t\ti; LSEG\t\tseg; if (point_inside(pt, poly->npts, poly->p) != 0) return 0.0; seg.p[0].x = poly->p[0].x; seg....","count":3},{"name":"api-example","value":"static inline Cash cash_mi_cash(Cash c1, Cash c2) { Cash\t\tres; if (unlikely(pg_sub_s64_overflow(c1, c2, &res))) ereport(ERROR, (errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE), errmsg(\"money out of range\"...","count":3},{"name":"api-example","value":"static inline Cash cash_mul_int64(Cash c, int64 i) { Cash\t\tres; if (unlikely(pg_mul_s64_overflow(c, i, &res))) ereport(ERROR, (errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE), errmsg(\"money out of range\")...","count":3},{"name":"api-example","value":"static inline Cash cash_pl_cash(Cash c1, Cash c2) { Cash\t\tres; if (unlikely(pg_add_s64_overflow(c1, c2, &res))) ereport(ERROR, (errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE), errmsg(\"money out of range\"...","count":3},{"name":"api-example","value":"static inline FullTransactionId AdjustToFullTransactionId(TransactionId xid) { Assert(TransactionIdIsValid(xid)); return FullTransactionIdFromAllowableAt(ReadNextFullTransactionId(), xid); }","count":3},{"name":"api-example","value":"static inline JsonParseErrorType json_lex_string(JsonLexContext *lex) { const char *s; const char *const end = lex->input + lex->input_length; int\t\t\thi_surrogate = -1; #define FAIL_OR_INCOMPLETE_AT_CH...","count":3},{"name":"api-example","value":"static inline TransactionId NormalTransactionIdOlder(TransactionId a, TransactionId b) { Assert(TransactionIdIsNormal(a)); Assert(TransactionIdIsNormal(b)); if (NormalTransactionIdPrecedes(a, b)) retu...","count":3},{"name":"api-example","value":"static inline TupleHashEntry LookupTupleHashEntry_internal(TupleHashTable hashtable, TupleTableSlot *slot, bool *isnew, uint32 hash) { TupleHashEntryData *entry; bool\t\tfound; MinimalTuple key; key = N...","count":3},{"name":"api-example","value":"static inline bool FPeq(double A, double B) { return A == B || fabs(A - B) <= EPSILON; }","count":3},{"name":"api-example","value":"static inline floating_decimal_32 f2d(const uint32 ieeeMantissa, const uint32 ieeeExponent) { int32\t\te2; uint32\t\tm2; if (ieeeExponent == 0) { e2 = 1 - FLOAT_BIAS - FLOAT_MANTISSA_BITS - 2; m2 = ieeeMa...","count":3},{"name":"api-example","value":"static inline int MXOffsetToMemberOffset(MultiXactOffset offset) { int\t\t\tmember_in_group = offset % MULTIXACT_MEMBERS_PER_MEMBERGROUP; return MXOffsetToFlagsOffset(offset) + MULTIXACT_FLAGBYTES_PER_GR...","count":3},{"name":"api-example","value":"static inline int _bt_blk_cmp(const void *arg1, const void *arg2) { BlockNumber b1 = *((BlockNumber *) arg1); BlockNumber b2 = *((BlockNumber *) arg2); return pg_cmp_u32(b1, b2); }","count":3},{"name":"api-example","value":"static inline int bcTruelen(BpChar *arg) { return bpchartruelen(VARDATA_ANY(arg), VARSIZE_ANY_EXHDR(arg)); }","count":3},{"name":"api-example","value":"static inline int decimalLength64(const uint64 v) { int\t\t\tt; static const uint64 PowersOfTen[] = { UINT64CONST(1), UINT64CONST(10), UINT64CONST(100), UINT64CONST(1000), UINT64CONST(10000), UINT64CONST...","count":3},{"name":"api-example","value":"static inline int pg_euc_dsplen(const unsigned char *s) { int\t\t\tlen; if (*s == SS2) len = 2; else if (*s == SS3) len = 2; else if (IS_HIGHBIT_SET(*s)) len = 2; else len = pg_ascii_dsplen(s); return le...","count":3},{"name":"api-example","value":"static inline int64 MXOffsetToMemberPage(MultiXactOffset offset) { return offset / MULTIXACT_MEMBERS_PER_PAGE; }","count":3},{"name":"api-example","value":"static inline int64 MXOffsetToMemberSegment(MultiXactOffset offset) { return MXOffsetToMemberPage(offset) / SLRU_PAGES_PER_SEGMENT; }","count":3},{"name":"api-example","value":"static inline int64 MultiXactIdToOffsetPage(MultiXactId multi) { return multi / MULTIXACT_OFFSETS_PER_PAGE; }","count":3},{"name":"api-example","value":"static inline void * AllocSetAllocChunkFromBlock(MemoryContext context, AllocBlock block, Size size, Size chunk_size, int fidx) { MemoryChunk *chunk; chunk = (MemoryChunk *) (block->freeptr); VALGRIND...","count":3},{"name":"api-example","value":"static inline void CopyMultiInsertBufferCleanup(CopyMultiInsertInfo *miinfo, CopyMultiInsertBuffer *buffer) { ResultRelInfo *resultRelInfo = buffer->resultRelInfo; int\t\t\ti; Assert(buffer->nused == 0);...","count":3},{"name":"api-example","value":"static inline void ReorderBufferSaveTXNSnapshot(ReorderBuffer *rb, ReorderBufferTXN *txn, Snapshot snapshot_now, CommandId command_id) { txn->command_id = command_id; if (snapshot_now->copied) txn->sn...","count":3},{"name":"api-example","value":"static inline void ResourceOwnerForgetTupleDesc(ResourceOwner owner, TupleDesc tupdesc) { ResourceOwnerForget(owner, PointerGetDatum(tupdesc), &tupdesc_resowner_desc); }","count":3},{"name":"api-example","value":"static inline void ResourceOwnerRememberTupleDesc(ResourceOwner owner, TupleDesc tupdesc) { ResourceOwnerRemember(owner, PointerGetDatum(tupdesc), &tupdesc_resowner_desc); }","count":3},{"name":"api-example","value":"static inline void SvREFCNT_dec_current(SV *sv) { dTHX; SvREFCNT_dec(sv); }","count":3},{"name":"api-example","value":"static inline void XLogFileName(char *fname, TimeLineID tli, XLogSegNo logSegNo, int wal_segsz_bytes) { snprintf(fname, MAXFNAMELEN, \"%08X%08X%08X\", tli, (uint32) (logSegNo / XLogSegmentsPerXLogId(wal...","count":3},{"name":"api-example","value":"static inline void XLogPrefetcherCompleteFilters(XLogPrefetcher *prefetcher, XLogRecPtr replaying_lsn) { while (unlikely(!dlist_is_empty(&prefetcher->filter_queue))) { XLogPrefetcherFilter *filter = d...","count":3},{"name":"api-example","value":"static inline void fasthash_accum(fasthash_state *hs, const char *k, size_t len) { uint32\t\tlower_four; Assert(len <= FH_SIZEOF_ACCUM); hs->accum = 0; * For consistency, bytewise loads must match the p...","count":3},{"name":"api-example","value":"static inline void g_box_consider_split(ConsiderSplitContext *context, int dimNum, float8 rightLower, int minLeftCount, float8 leftUpper, int maxLeftCount) { int\t\t\tleftCount, rightCount; float4\t\tratio...","count":3},{"name":"api-example","value":"static inline void pg_atomic_init_u32(volatile pg_atomic_uint32 *ptr, uint32 val) { AssertPointerAlignment(ptr, 4); pg_atomic_init_u32_impl(ptr, val); }","count":3},{"name":"api-example","value":"static inline void pg_time_now_lazy(pg_time_usec_t *now) { if ((*now) == 0) (*now) = pg_time_now(); }","count":3},{"name":"api-example","value":"static inline void tbm_advance_schunkbit(PagetableEntry *chunk, int *schunkbitp) { int\t\t\tschunkbit = *schunkbitp; while (schunkbit < PAGES_PER_CHUNK) { int\t\t\twordnum = WORDNUM(schunkbit); int\t\t\tbitnum...","count":3},{"name":"api-example","value":"static inline void validate_relation_kind(Relation r) { if (r->rd_rel->relkind != RELKIND_SEQUENCE) ereport(ERROR, (errcode(ERRCODE_WRONG_OBJECT_TYPE), errmsg(\"cannot open relation \\\"%s\\\"\", RelationGe...","count":3},{"name":"api-example","value":"static int\t\t\t\t\t\t/* predicate:  constraint satisfied? */ lacon(struct vars *v, struct cnfa *pcnfa,\t\t/* parent cnfa */ chr *cp, color co)\t\t\t\t\t/* \"color\" of the lookaround constraint */ { int\t\t\tn; struct...","count":3},{"name":"api-example","value":"static int\t\t\t\t\t\t/* regexec return code */ ccondissect(struct vars *v, struct subre *t, chr *begin,\t\t\t/* beginning of relevant substring */ chr *end)\t\t\t/* end of same */ { struct subre *left = t->child...","count":3},{"name":"api-example","value":"static int CompareTSQ(TSQuery a, TSQuery b) { if (a->size != b->size) { return (a->size < b->size) ? -1 : 1; } else if (VARSIZE(a) != VARSIZE(b)) { return (VARSIZE(a) < VARSIZE(b)) ? -1 : 1; } else if...","count":3},{"name":"api-example","value":"static int DCH_datetime_type(FormatNode *node) { FormatNode *n; int\t\t\tflags = 0; for (n = node; n->type != NODE_TYPE_END; n++) { if (n->type != NODE_TYPE_ACTION) continue; switch (n->key->id) { case D...","count":3},{"name":"api-example","value":"static int DetermineSleepTime(void) { TimestampTz next_wakeup = 0; * Normal case: either there are no background workers at all, or we're in * a shutdown sequence (during which we ignore bgworkers alt...","count":3},{"name":"api-example","value":"static int FindWord(IspellDict *Conf, const char *word, const char *affixflag, int flag) { SPNode\t   *node = Conf->Dictionary; SPNodeData *StopLow, *StopHigh, *StopMiddle; const uint8 *ptr = (const ui...","count":3},{"name":"api-example","value":"static int HashStmt(const char *ecpgQuery) { int\t\t\tstmtIx, bucketNo, hashLeng, stmtLeng; uint64\t\thashVal, rotVal; stmtLeng = strlen(ecpgQuery); hashLeng = 50;\t\t\t\t/* use 1st 50 characters of statement ...","count":3},{"name":"api-example","value":"static int LruInsert(File file) { Vfd\t\t   *vfdP; Assert(file != 0); DO_DB(elog(LOG, \"LruInsert %d (%s)\", file, VfdCache[file].fileName)); vfdP = &VfdCache[file]; if (FileIsNotOpen(file)) { ReleaseLruF...","count":3},{"name":"api-example","value":"static int MatchText(const char *t, int tlen, const char *p, int plen, pg_locale_t locale, bool locale_is_c) { if (plen == 1 && *p == '%') return LIKE_TRUE; check_stack_depth(); * In this loop, we adv...","count":3},{"name":"api-example","value":"static int SlruSelectLRUPage(SlruCtl ctl, int64 pageno) { SlruShared\tshared = ctl->shared; for (;;) { int\t\t\tcur_count; int\t\t\tbestvalidslot = 0;\t/* keep compiler quiet */ int\t\t\tbest_valid_delta = -1; i...","count":3},{"name":"api-example","value":"static int TupleHashTableMatch(struct tuplehash_hash *tb, const MinimalTuple tuple1, const MinimalTuple tuple2) { TupleTableSlot *slot1; TupleTableSlot *slot2; TupleHashTable hashtable = (TupleHashTab...","count":3},{"name":"api-example","value":"static int ZeroCLOGPage(int64 pageno, bool writeXlog) { int\t\t\tslotno; slotno = SimpleLruZeroPage(XactCtl, pageno); if (writeXlog) WriteZeroPageXlogRec(pageno); return slotno; }","count":3},{"name":"api-example","value":"static int _SPI_execute_plan(SPIPlanPtr plan, const SPIExecuteOptions *options, Snapshot snapshot, Snapshot crosscheck_snapshot, bool fire_triggers) { int\t\t\tmy_res = 0; uint64\t\tmy_processed = 0; SPITu...","count":3},{"name":"api-example","value":"static int _bt_binsrch_array_skey(FmgrInfo *orderproc, bool cur_elem_trig, ScanDirection dir, Datum tupdatum, bool tupnull, BTArrayKeyInfo *array, ScanKey cur, int32 *set_elem_result) { int\t\t\tlow_elem...","count":3},{"name":"api-example","value":"static int _discoverArchiveFormat(ArchiveHandle *AH) { FILE\t   *fh; char\t\tsig[6];\t\t\t/* More than enough */ size_t\t\tcnt; int\t\t\twantClose = 0; pg_log_debug(\"attempting to ascertain archive format\"); fre...","count":3},{"name":"api-example","value":"static int acquire_inherited_sample_rows(Relation onerel, int elevel, HeapTuple *rows, int targrows, double *totalrows, double *totaldeadrows) { List\t   *tableOIDs; Relation   *rels; AcquireSampleRows...","count":3},{"name":"api-example","value":"static int addToResult(char **forms, char **cur, char *word) { if (cur - forms >= MAX_NORM - 1) return 0; if (forms == cur || strcmp(word, *(cur - 1)) != 0) { *cur = pstrdup(word); *(cur + 1) = NULL; ...","count":3},{"name":"api-example","value":"static int analyze_mcv_list(int *mcv_counts, int num_mcv, double stadistinct, double stanullfrac, int samplerows, double totalrows) { double\t\tndistinct_table; double\t\tsumcount; int\t\t\ti; * If the entir...","count":3},{"name":"api-example","value":"static int auth_peer(hbaPort *port) { uid_t\t\tuid; gid_t\t\tgid; #ifndef WIN32 struct passwd *pw; int\t\t\tret; #endif if (getpeereid(port->sock, &uid, &gid) != 0) { if (errno == ENOSYS) ereport(LOG, (errco...","count":3},{"name":"api-example","value":"static int build_startup_packet(const PGconn *conn, char *packet, const PQEnvironmentOption *options) { int\t\t\tpacket_len = 0; const PQEnvironmentOption *next_eo; const char *val; if (packet) { Protoco...","count":3},{"name":"api-example","value":"static int calculatePagesPerBuffer(GISTBuildState *buildstate, int levelStep) { double\t\tpagesPerBuffer; double\t\tavgIndexTuplesPerPage; double\t\titupAvgSize; Size\t\tpageFreeSpace; pageFreeSpace = BLCKSZ ...","count":3},{"name":"api-example","value":"static int checkSplitConditions(Relation index, SpGistState *state, SPPageDesc *current, int *nToSplit) { int\t\t\ti, n = 0, totalSize = 0; if (SpGistBlockIsRoot(current->blkno)) { *nToSplit = BLCKSZ; re...","count":3},{"name":"api-example","value":"static int check_agg_arguments(ParseState *pstate, List *directargs, List *args, Expr *filter) { int\t\t\tagglevel; check_agg_arguments_context context; context.pstate = pstate; context.min_varlevel = -1...","count":3},{"name":"api-example","value":"static int check_replace_text_has_escape(const text *replace_text) { int\t\t\tresult = 0; const char *p = VARDATA_ANY(replace_text); const char *p_end = p + VARSIZE_ANY_EXHDR(replace_text); while (p < p_...","count":3},{"name":"api-example","value":"static int cmpTimestampToTimestampTz(Timestamp ts1, TimestampTz tstz2, bool useTz) { checkTimezoneIsUsedForCast(useTz, \"timestamp\", \"timestamptz\"); return timestamp_cmp_timestamptz_internal(ts1, tstz2...","count":3},{"name":"api-example","value":"static int cmp_numerics(Numeric num1, Numeric num2) { int\t\t\tresult; * We consider all NANs to be equal and larger than any non-NAN (including * Infinity).  This is somewhat arbitrary; the important th...","count":3},{"name":"api-example","value":"static int cmpaffix(const void *s1, const void *s2) { const AFFIX *a1 = (const AFFIX *) s1; const AFFIX *a2 = (const AFFIX *) s2; if (a1->type < a2->type) return -1; if (a1->type > a2->type) return 1;...","count":3},{"name":"api-example","value":"static int cnt_length(TSVector t) { WordEntry  *ptr = ARRPTR(t), *end = (WordEntry *) STRPTR(t); int\t\t\tlen = 0; while (ptr < end) { int\t\t\tclen = POSDATALEN(t, ptr); if (clen == 0) len += 1; else len +...","count":3},{"name":"api-example","value":"static int combine(struct nfa *nfa, struct arc *con, struct arc *a) { #define  CA(ct,at)\t (((ct)<<CHAR_BIT) | (at)) switch (CA(con->type, a->type)) { case CA('^', PLAIN):\t/* newlines are handled separ...","count":3},{"name":"api-example","value":"static int compareDocR(const void *va, const void *vb) { const DocRepresentation *a = (const DocRepresentation *) va; const DocRepresentation *b = (const DocRepresentation *) vb; if (WEP_GETPOS(a->pos...","count":3},{"name":"api-example","value":"static int compareWORD(const void *a, const void *b) { int\t\t\tres; res = tsCompareString(((const ParsedWord *) a)->word, ((const ParsedWord *) a)->len, ((const ParsedWord *) b)->word, ((const ParsedWor...","count":3},{"name":"api-example","value":"static int dttofmtasc_replace(timestamp * ts, date dDate, int dow, struct tm *tm, char *output, int *pstr_len, const char *fmtstr) { union un_fmt_comb replace_val; int\t\t\treplace_type; int\t\t\ti; const c...","count":3},{"name":"api-example","value":"static int dumpTableData_copy(Archive *fout, const void *dcontext) { TableDataInfo *tdinfo = (TableDataInfo *) dcontext; TableInfo  *tbinfo = tdinfo->tdtable; const char *classname = tbinfo->dobj.name...","count":3},{"name":"api-example","value":"static int exec_stmt_case(PLpgSQL_execstate *estate, PLpgSQL_stmt_case *stmt) { PLpgSQL_var *t_var = NULL; bool\t\tisnull; ListCell   *l; if (stmt->t_expr != NULL) { Datum\t\tt_val; Oid\t\t\tt_typoid; int32\t...","count":3},{"name":"api-example","value":"static int exec_stmt_getdiag(PLpgSQL_execstate *estate, PLpgSQL_stmt_getdiag *stmt) { ListCell   *lc; * GET STACKED DIAGNOSTICS is only valid inside an exception handler. * * Note: we trust the gramma...","count":3},{"name":"api-example","value":"static int exec_stmt_if(PLpgSQL_execstate *estate, PLpgSQL_stmt_if *stmt) { bool\t\tvalue; bool\t\tisnull; ListCell   *lc; value = exec_eval_boolean(estate, stmt->cond, &isnull); exec_eval_cleanup(estate)...","count":3},{"name":"api-example","value":"static int exec_stmt_loop(PLpgSQL_execstate *estate, PLpgSQL_stmt_loop *stmt) { int\t\t\trc = PLPGSQL_RC_OK; for (;;) { rc = exec_stmts(estate, stmt->body); LOOP_RC_PROCESSING(stmt->label, break); } retu...","count":3},{"name":"api-example","value":"static int exec_stmt_raise(PLpgSQL_execstate *estate, PLpgSQL_stmt_raise *stmt) { int\t\t\terr_code = 0; char\t   *condname = NULL; char\t   *err_message = NULL; char\t   *err_detail = NULL; char\t   *err_hi...","count":3},{"name":"api-example","value":"static int exec_stmt_return(PLpgSQL_execstate *estate, PLpgSQL_stmt_return *stmt) { * If processing a set-returning PL/pgSQL function, the final RETURN * indicates that the function is finished produc...","count":3},{"name":"api-example","value":"static int exec_stmt_return_next(PLpgSQL_execstate *estate, PLpgSQL_stmt_return_next *stmt) { TupleDesc\ttupdesc; int\t\t\tnatts; HeapTuple\ttuple; MemoryContext oldcontext; if (!estate->retisset) ereport(...","count":3},{"name":"api-example","value":"static int exec_stmt_return_query(PLpgSQL_execstate *estate, PLpgSQL_stmt_return_query *stmt) { int64\t\ttcount; DestReceiver *treceiver; int\t\t\trc; uint64\t\tprocessed; MemoryContext stmt_mcontext = get_s...","count":3},{"name":"api-example","value":"static int extractRemainingColumns(ParseState *pstate, ParseNamespaceColumn *src_nscolumns, List *src_colnames, List **src_colnos, List **res_colnames, List **res_colvars, ParseNamespaceColumn *res_ns...","count":3},{"name":"api-example","value":"static int freev(struct vars *v, int err) { if (v->re != NULL) rfree(v->re); if (v->subs != v->sub10) FREE(v->subs); if (v->nfa != NULL) freenfa(v->nfa); if (v->tree != NULL) freesubre(v, v->tree); if...","count":3},{"name":"api-example","value":"static int from_char_parse_int(int *dest, const char **src, FormatNode *node, Node *escontext) { return from_char_parse_int_len(dest, src, node->key->len, node, escontext); }","count":3},{"name":"api-example","value":"static int getaddrinfo_unix(const char *path, const struct addrinfo *hintsp, struct addrinfo **result) { struct addrinfo hints = {0}; struct addrinfo *aip; struct sockaddr_un *unp; *result = NULL; if ...","count":3},{"name":"api-example","value":"static int gimme_edge(PlannerInfo *root, Gene gene1, Gene gene2, Edge *edge_table) { int\t\t\ti; int\t\t\tedges; int\t\t\tcity1 = (int) gene1; int\t\t\tcity2 = (int) gene2; edges = edge_table[city1].total_edges; ...","count":3},{"name":"api-example","value":"static int hasconstraintout(struct state *s) { struct arc *a; for (a = s->outs; a != NULL; a = a->outchain) { if (isconstraintarc(a)) return 1; } return 0; }","count":3},{"name":"api-example","value":"static int hash_choose_num_partitions(double input_groups, double hashentrysize, int used_bits, int *log2_npartitions) { Size\t\thash_mem_limit = get_hash_memory_limit(); double\t\tpartition_limit; double...","count":3},{"name":"api-example","value":"static int hemdist(SignTSVector *a, SignTSVector *b) { int\t\t\tsiglena = GETSIGLEN(a); int\t\t\tsiglenb = GETSIGLEN(b); if (ISALLTRUE(a)) { if (ISALLTRUE(b)) return 0; else return SIGLENBIT(siglenb) - size...","count":3},{"name":"api-example","value":"static int inet_cidr_pton_ipv4(const char *src, u_char *dst, size_t size) { static const char xdigits[] = \"0123456789abcdef\"; static const char digits[] = \"0123456789\"; int\t\t\tn, ch, tmp = 0, dirty, bi...","count":3},{"name":"api-example","value":"static int interactive_getc(void) { int\t\t\tc; * This will not process catchup interrupts or notifications while * reading. But those can't really be relevant for a standalone backend * anyway. To prope...","count":3},{"name":"api-example","value":"static int interval_cmp_lower(const void *i1, const void *i2) { float8\t\tlower1 = ((const SplitInterval *) i1)->lower, lower2 = ((const SplitInterval *) i2)->lower; return float8_cmp_internal(lower1, l...","count":3},{"name":"api-example","value":"static int lexescape(struct vars *v) { chr\t\t\tc; static const chr alert[] = { CHR('a'), CHR('l'), CHR('e'), CHR('r'), CHR('t') }; static const chr esc[] = { CHR('E'), CHR('S'), CHR('C') }; const chr  *...","count":3},{"name":"api-example","value":"static int libpqrcv_receive(WalReceiverConn *conn, char **buffer, pgsocket *wait_fd) { int\t\t\trawlen; PQfreemem(conn->recvBuf); conn->recvBuf = NULL; rawlen = PQgetCopyData(conn->streamConn, &conn->rec...","count":3},{"name":"api-example","value":"static int libpqrcv_server_version(WalReceiverConn *conn) { return PQserverVersion(conn->streamConn); }","count":3},{"name":"api-example","value":"static int match_prosrc_to_query(const char *prosrc, const char *queryText, int cursorpos) { * Rather than fully parsing the original command, we just scan the * command looking for $prosrc$ or 'prosr...","count":3},{"name":"api-example","value":"static int p_isascii(TParser *prs) { return (prs->state->charlen == 1 && isascii((unsigned char) *(prs->str + prs->state->posbyte))) ? 1 : 0; }","count":3},{"name":"api-example","value":"static int p_ishost(TParser *prs) { TParser    *tmpprs = TParserCopyInit(prs); int\t\t\tres = 0; tmpprs->wanthost = true; * Check stack depth before recursing.  (Since TParserGet() doesn't * normally rec...","count":3},{"name":"api-example","value":"static int parse_ooaffentry(char *str, char *type, char *flag, char *find, char *repl, char *mask) { int\t\t\tstate = PAE_WAIT_TYPE; int\t\t\tfields_read = 0; bool\t\tvalid = false; *type = *flag = *find = *r...","count":3},{"name":"api-example","value":"static int pg_eucjp_verifychar(const unsigned char *s, int len) { int\t\t\tl; unsigned char c1, c2; c1 = *s++; switch (c1) { case SS2:\t\t\t\t/* JIS X 0201 */ l = 2; if (l > len) return -1; c2 = *s++; if (c2...","count":3},{"name":"api-example","value":"static int pg_utf8_verifystr(const unsigned char *s, int len) { const unsigned char *start = s; const int\torig_len = len; uint32\t\tstate = BGN; * With a stride of two vector widths, gcc will unroll the...","count":3},{"name":"api-example","value":"static int pg_wc_isalnum(pg_wchar c) { switch (pg_regex_strategy) { case PG_REGEX_LOCALE_C: return (c <= (pg_wchar) 127 && (pg_char_properties[c] & PG_ISALNUM)); case PG_REGEX_BUILTIN: return pg_u_isa...","count":3},{"name":"api-example","value":"static int pg_wc_isdigit(pg_wchar c) { switch (pg_regex_strategy) { case PG_REGEX_LOCALE_C: return (c <= (pg_wchar) 127 && (pg_char_properties[c] & PG_ISDIGIT)); case PG_REGEX_BUILTIN: return pg_u_isd...","count":3},{"name":"api-example","value":"static int pg_wc_isgraph(pg_wchar c) { switch (pg_regex_strategy) { case PG_REGEX_LOCALE_C: return (c <= (pg_wchar) 127 && (pg_char_properties[c] & PG_ISGRAPH)); case PG_REGEX_BUILTIN: return pg_u_isg...","count":3},{"name":"api-example","value":"static int pg_wc_isspace(pg_wchar c) { switch (pg_regex_strategy) { case PG_REGEX_LOCALE_C: return (c <= (pg_wchar) 127 && (pg_char_properties[c] & PG_ISSPACE)); case PG_REGEX_BUILTIN: return pg_u_iss...","count":3},{"name":"api-example","value":"static int pg_wc_isupper(pg_wchar c) { switch (pg_regex_strategy) { case PG_REGEX_LOCALE_C: return (c <= (pg_wchar) 127 && (pg_char_properties[c] & PG_ISUPPER)); case PG_REGEX_BUILTIN: return pg_u_isu...","count":3},{"name":"api-example","value":"static int point_inside(Point *p, int npts, Point *plist) { float8\t\tx0, y0; float8\t\tprev_x, prev_y; int\t\t\ti = 0; float8\t\tx, y; int\t\t\tcross, total_cross = 0; Assert(npts > 0); x0 = float8_mi(plist[0].x...","count":3},{"name":"api-example","value":"static int pq_recvbuf(void) { if (PqRecvPointer > 0) { if (PqRecvLength > PqRecvPointer) { memmove(PqRecvBuffer, PqRecvBuffer + PqRecvPointer, PqRecvLength - PqRecvPointer); PqRecvLength -= PqRecvPoin...","count":3},{"name":"api-example","value":"static int process_outer_partition(PartitionMap *outer_map, PartitionMap *inner_map, bool outer_has_default, bool inner_has_default, int outer_index, int inner_default, JoinType jointype, int *next_in...","count":3},{"name":"api-example","value":"static int pull(struct nfa *nfa, struct arc *con, struct state **intermediates) { struct state *from = con->from; struct state *to = con->to; struct arc *a; struct arc *nexta; struct state *s; assert(...","count":3},{"name":"api-example","value":"static int push(struct nfa *nfa, struct arc *con, struct state **intermediates) { struct state *from = con->from; struct state *to = con->to; struct arc *a; struct arc *nexta; struct state *s; assert(...","count":3},{"name":"api-example","value":"static int r_Checks1(struct SN_env * z) { int among_var; z->bra = z->c; if (z->c + 3 >= z->l || (z->p[z->c + 3] != 132 && z->p[z->c + 3] != 167)) return 0; among_var = find_among(z, a_3, 4); if (!(amo...","count":3},{"name":"api-example","value":"static int r_KER(struct SN_env * z) { if (out_grouping(z, g_vowel, 97, 117, 0)) return 0; if (!(eq_s(z, 2, s_0))) return 0; return 1; }","count":3},{"name":"api-example","value":"static int r_Normalize_pre(struct SN_env * z) { int among_var; {   int c1 = z->c; while(1) { int c2 = z->c; {   int c3 = z->c; z->bra = z->c; among_var = find_among(z, a_0, 144); if (!(among_var)) got...","count":3},{"name":"api-example","value":"static int r_Step_1b(struct SN_env * z) { int among_var; z->ket = z->c; if (z->c - 1 <= z->lb || z->p[z->c - 1] >> 5 != 3 || !((33554576 >> (z->p[z->c - 1] & 0x1f)) & 1)) return 0; among_var = find_am...","count":3},{"name":"api-example","value":"static int r_cleaning(struct SN_env * z) { int among_var; while(1) { int c1 = z->c; z->bra = z->c; among_var = find_among(z, a_0, 13); if (!(among_var)) goto lab0; z->ket = z->c; switch (among_var) { ...","count":3},{"name":"api-example","value":"static int r_mark_sU(struct SN_env * z) { {   int ret = r_check_vowel_harmony(z); if (ret <= 0) return ret; } if (in_grouping_b_U(z, g_U, 105, 305, 0)) return 0; {   int ret = r_mark_suffix_with_optio...","count":3},{"name":"api-example","value":"static int r_mark_yU(struct SN_env * z) { {   int ret = r_check_vowel_harmony(z); if (ret <= 0) return ret; } if (in_grouping_b_U(z, g_U, 105, 305, 0)) return 0; {   int ret = r_mark_suffix_with_optio...","count":3},{"name":"api-example","value":"static int r_other_suffix(struct SN_env * z) { int among_var; {   int m1 = z->l - z->c; (void)m1; z->ket = z->c; if (!(eq_s_b(z, 2, s_0))) goto lab0; z->bra = z->c; if (!(eq_s_b(z, 2, s_1))) goto lab0...","count":3},{"name":"api-example","value":"static int read_local_xlog_page_guts(XLogReaderState *state, XLogRecPtr targetPagePtr, int reqLen, XLogRecPtr targetRecPtr, char *cur_page, bool wait_for_wal) { XLogRecPtr\tread_upto, loc; TimeLineID\tt...","count":3},{"name":"api-example","value":"static int restore_toc_entry(ArchiveHandle *AH, TocEntry *te, bool is_parallel) { RestoreOptions *ropt = AH->public.ropt; int\t\t\tstatus = WORKER_OK; int\t\t\treqs; bool\t\tdefnDumped; AH->currentTE = te; if...","count":3},{"name":"api-example","value":"static int socket_putmessage(char msgtype, const char *s, size_t len) { uint32\t\tn32; Assert(msgtype != 0); if (PqCommBusy) return 0; PqCommBusy = true; if (internal_putbytes(&msgtype, 1)) goto fail; n...","count":3},{"name":"api-example","value":"static int stringzone(char *result, struct zone const *zpfirst, ptrdiff_t zonecount) { const struct zone *zp; struct rule *rp; struct rule *stdrp; struct rule *dstrp; ptrdiff_t\ti; const char *abbrvar;...","count":3},{"name":"api-example","value":"static int tar_close(Walfile *f, WalCloseMethod method) { ssize_t\t\tfilesize; int\t\t\tpadding; TarMethodData *tar_data = (TarMethodData *) f->wwmethod; TarMethodFile *tf = (TarMethodFile *) f; Assert(f !...","count":3},{"name":"api-example","value":"static int varstrfastcmp_c(Datum x, Datum y, SortSupport ssup) { VarString  *arg1 = DatumGetVarStringPP(x); VarString  *arg2 = DatumGetVarStringPP(y); char\t   *a1p, *a2p; int\t\t\tlen1, len2, result; a1p...","count":3},{"name":"api-example","value":"static int16 getQuadrant(Point *centroid, Point *tst) { if ((SPTEST(point_above, tst, centroid) || SPTEST(point_horiz, tst, centroid)) && (SPTEST(point_right, tst, centroid) || SPTEST(point_vert, tst,...","count":3},{"name":"api-example","value":"static int32 anytime_typmodin(bool istz, ArrayType *ta) { int32\t   *tl; int\t\t\tn; tl = ArrayGetIntegerTypmods(ta, &n); * we're not too tense about good error message here because grammar * shouldn't al...","count":3},{"name":"api-example","value":"static int32 writeListPage(Relation index, Buffer buffer, IndexTuple *tuples, int32 ntuples, BlockNumber rightlink) { Page\t\tpage = BufferGetPage(buffer); int32\t\ti, freesize, size = 0; OffsetNumber l, ...","count":3},{"name":"api-example","value":"static int64 scan_directory(const char *basedir, const char *subdir, bool sizeonly) { int64\t\tdirsize = 0; char\t\tpath[MAXPGPATH]; DIR\t\t   *dir; struct dirent *de; snprintf(path, sizeof(path), \"%s/%s\", ...","count":3},{"name":"api-example","value":"static long sqlda_compat_empty_size(const PGresult *res) { long\t\toffset; int\t\t\ti; int\t\t\tsqld = PQnfields(res); offset = sizeof(struct sqlda_compat) + sqld * sizeof(struct sqlvar_compat); for (i = 0; i...","count":3},{"name":"api-example","value":"static manifest_data * parse_manifest_file(char *manifest_path) { int\t\t\tfd; struct stat statbuf; off_t\t\testimate; uint32\t\tinitial_size; manifest_files_hash *ht; char\t   *buffer; int\t\t\trc; JsonManifest...","count":3},{"name":"api-example","value":"static nullingrel_info * get_nullingrels(Query *parse) { nullingrel_info *result = palloc_object(nullingrel_info); result->rtlength = list_length(parse->rtable); result->nullingrels = palloc0_array(Re...","count":3},{"name":"api-example","value":"static pg_attribute_always_inline Buffer PinBufferForBlock(Relation rel, SMgrRelation smgr, char smgr_persistence, ForkNumber forkNum, BlockNumber blockNum, BufferAccessStrategy strategy, bool *foundP...","count":3},{"name":"api-example","value":"static pg_attribute_always_inline void ReserveXLogInsertLocation(int size, XLogRecPtr *StartPos, XLogRecPtr *EndPos, XLogRecPtr *PrevPtr) { XLogCtlInsert *Insert = &XLogCtl->Insert; uint64\t\tstartbytep...","count":3},{"name":"api-example","value":"static pg_tz * pg_load_tz(const char *name) { static pg_tz tz; if (strlen(name) > TZ_STRLEN_MAX) return NULL;\t\t\t/* not going to fit */ * \"GMT\" is always sent to tzparse(); see comments for pg_tzset()....","count":3},{"name":"api-example","value":"static pid_t start_postmaster(void) { char\t   *cmd; #ifndef WIN32 pid_t\t\tpm_pid; fflush(NULL); #ifdef EXEC_BACKEND pg_disable_aslr(); #endif pm_pid = fork(); if (pm_pid < 0) { write_stderr(_(\"%s: coul...","count":3},{"name":"api-example","value":"static pltcl_proc_desc * compile_pltcl_function(Oid fn_oid, Oid tgreloid, bool is_event_trigger, bool pltrusted) { HeapTuple\tprocTup; Form_pg_proc procStruct; pltcl_proc_key proc_key; pltcl_proc_ptr *...","count":3},{"name":"api-example","value":"static relopt_bool * init_bool_reloption(bits32 kinds, const char *name, const char *desc, bool default_val, LOCKMODE lockmode) { relopt_bool *newoption; newoption = (relopt_bool *) allocate_reloption...","count":3},{"name":"api-example","value":"static relopt_value * parseLocalRelOptions(local_relopts *relopts, Datum options, bool validate) { int\t\t\tnopts = list_length(relopts->options); relopt_value *values = palloc(sizeof(*values) * nopts); ...","count":3},{"name":"api-example","value":"static struct cvec * cclasscvec(struct vars *v,\t\t/* context */ enum char_classes cclasscode,\t/* class to build a cvec for */ int cases)\t\t\t/* case-independent? */ { struct cvec *cv = NULL; * Remap lowe...","count":3},{"name":"api-example","value":"static struct dfa * getsubdfa(struct vars *v, struct subre *t) { struct dfa *d = v->subdfas[t->id]; if (d == NULL) { d = newdfa(v, &t->cnfa, &v->g->cmap, DOMALLOC); if (d == NULL) return NULL; if (t->...","count":3},{"name":"api-example","value":"static struct dfa * newdfa(struct vars *v, struct cnfa *cnfa, struct colormap *cm, struct smalldfa *sml)\t/* preallocated space, may be NULL */ { struct dfa *d; size_t\t\tnss = cnfa->nstates * 2; int\t\t\tw...","count":3},{"name":"api-example","value":"static struct nfa *\t\t\t\t/* the NFA, or NULL */ newnfa(struct vars *v, struct colormap *cm, struct nfa *parent)\t\t/* NULL if primary NFA */ { struct nfa *nfa; nfa = (struct nfa *) MALLOC(sizeof(struct nf...","count":3},{"name":"api-example","value":"static struct pg_tm * timesub(const pg_time_t *timep, int32 offset, const struct state *sp, struct pg_tm *tmp) { const struct lsinfo *lp; pg_time_t\ttdays; int\t\t\tidays;\t\t\t/* unsigned would be so 2003 *...","count":3},{"name":"api-example","value":"static struct state *\t\t\t/* NULL on error */ newstate(struct nfa *nfa) { struct state *s; * This is a handy place to check for operation cancel during regex * compilation, since no code path will go ve...","count":3},{"name":"api-example","value":"static struct subre * parsebranch(struct vars *v, int stopper,\t\t/* EOS or ')' */ int type,\t\t\t/* LACON (lookaround subRE) or PLAIN */ struct state *left, /* leftmost state */ struct state *right,\t/* ri...","count":3},{"name":"api-example","value":"static uint32 ieee_float32_to_uint32(float f) { * * IEEE 754 floating point format * ------------------------------ * * IEEE 754 floating point numbers have this format: * *   exponent (8 bits) *   | ...","count":3},{"name":"api-example","value":"static uint32 missing_hash(const void *key, Size keysize) { const missing_cache_key *entry = (missing_cache_key *) key; return hash_bytes((const unsigned char *) entry->value, entry->len); }","count":3},{"name":"api-example","value":"static uint32 predicatelock_hash(const void *key, Size keysize) { const PREDICATELOCKTAG *predicatelocktag = (const PREDICATELOCKTAG *) key; uint32\t\ttargethash; Assert(keysize == sizeof(PREDICATELOCKT...","count":3},{"name":"api-example","value":"static uint32 proclock_hash(const void *key, Size keysize) { const PROCLOCKTAG *proclocktag = (const PROCLOCKTAG *) key; uint32\t\tlockhash; Datum\t\tprocptr; Assert(keysize == sizeof(PROCLOCKTAG)); lockh...","count":3},{"name":"api-example","value":"static void * AllocSetAllocFromNewBlock(MemoryContext context, Size size, int flags, int fidx) { AllocSet\tset = (AllocSet) context; AllocBlock\tblock; Size\t\tavailspace; Size\t\tblksize; Size\t\trequired_si...","count":3},{"name":"api-example","value":"static void * AllocSetAllocLarge(MemoryContext context, Size size, int flags) { AllocSet\tset = (AllocSet) context; AllocBlock\tblock; MemoryChunk *chunk; Size\t\tchunk_size; Size\t\tblksize; MemoryContextC...","count":3},{"name":"api-example","value":"static void * stringToNodeInternal(const char *str, bool restore_loc_fields) { void\t   *retval; const char *save_strtok; #ifdef WRITE_READ_PARSE_PLAN_TREES bool\t\tsave_restore_location_fields; #endif *...","count":3},{"name":"api-example","value":"static void ATCheckPartitionsNotInUse(Relation rel, LOCKMODE lockmode) { if (rel->rd_rel->relkind == RELKIND_PARTITIONED_TABLE) { List\t   *inh; ListCell   *cell; inh = find_all_inheritors(RelationGetR...","count":3},{"name":"api-example","value":"static void ATExecCmd(List **wqueue, AlteredTableInfo *tab, AlterTableCmd *cmd, LOCKMODE lockmode, AlterTablePass cur_pass, AlterTableUtilityContext *context) { ObjectAddress address = InvalidObjectAd...","count":3},{"name":"api-example","value":"static void ATRewriteTables(AlterTableStmt *parsetree, List **wqueue, LOCKMODE lockmode, AlterTableUtilityContext *context) { ListCell   *ltab; foreach(ltab, *wqueue) { AlteredTableInfo *tab = (Altere...","count":3},{"name":"api-example","value":"static void AcquireExecutorLocks(List *stmt_list, bool acquire) { ListCell   *lc1; foreach(lc1, stmt_list) { PlannedStmt *plannedstmt = lfirst_node(PlannedStmt, lc1); ListCell   *lc2; if (plannedstmt-...","count":3},{"name":"api-example","value":"static void AddCatcacheInvalidationMessage(InvalidationMsgsGroup *group, int id, uint32 hashValue, Oid dbId) { SharedInvalidationMessage msg; Assert(id < CHAR_MAX); msg.cc.id = (int8) id; msg.cc.dbId ...","count":3},{"name":"api-example","value":"static void AddRelcacheInvalidationMessage(InvalidationMsgsGroup *group, Oid dbId, Oid relId) { SharedInvalidationMessage msg; * Don't add a duplicate item. We assume dbId need not be checked because ...","count":3},{"name":"api-example","value":"static void AdjustFractDays(double frac, struct /* pg_ */ tm *tm, fsec_t *fsec, int scale) { int\t\t\textra_days; if (frac == 0) return; frac *= scale; extra_days = (int) frac; tm->tm_mday += extra_days;...","count":3},{"name":"api-example","value":"static void AfterTriggerFreeQuery(AfterTriggersQueryData *qs) { Tuplestorestate *ts; List\t   *tables; ListCell   *lc; afterTriggerFreeEventList(&qs->events); ts = qs->fdw_tuplestore; qs->fdw_tuplestor...","count":3},{"name":"api-example","value":"static void AlterForeignServerOwner_internal(Relation rel, HeapTuple tup, Oid newOwnerId) { Form_pg_foreign_server form; Datum\t\trepl_val[Natts_pg_foreign_server]; bool\t\trepl_null[Natts_pg_foreign_serv...","count":3},{"name":"api-example","value":"static void AlterPublicationTables(AlterPublicationStmt *stmt, HeapTuple tup, List *tables, const char *queryString, bool publish_schema) { List\t   *rels = NIL; Form_pg_publication pubform = (Form_pg_...","count":3},{"name":"api-example","value":"static void AtStart_ResourceOwner(void) { TransactionState s = CurrentTransactionState; * We shouldn't have a transaction resource owner already. */ Assert(TopTransactionResourceOwner == NULL); * Crea...","count":3},{"name":"api-example","value":"static void BufFileLoadBuffer(BufFile *file) { File\t\tthisfile; instr_time\tio_start; instr_time\tio_time; * Advance to next component file if necessary and possible. */ if (file->curOffset >= MAX_PHYSIC...","count":3},{"name":"api-example","value":"static void CalculateCheckpointSegments(void) { double\t\ttarget; * Calculate the distance at which to trigger a checkpoint, to avoid * exceeding max_wal_size_mb. This is based on two assumptions: * * a...","count":3},{"name":"api-example","value":"static void CatCacheRemoveCList(CatCache *cache, CatCList *cl) { int\t\t\ti; Assert(cl->refcount == 0); Assert(cl->my_cache == cache); for (i = cl->n_members; --i >= 0;) { CatCTup    *ct = cl->members[i]...","count":3},{"name":"api-example","value":"static void CheckRequiredParameterValues(void) { * For archive recovery, the WAL must be generated with at least 'replica' * wal_level. */ if (ArchiveRecoveryRequested && ControlFile->wal_level == WAL...","count":3},{"name":"api-example","value":"static void ClearOrSaveAllResults(void) { PGresult   *result; while ((result = PQgetResult(pset.db)) != NULL) ClearOrSaveResult(result); }","count":3},{"name":"api-example","value":"static void CloneFkReferenced(Relation parentRel, Relation partitionRel) { Relation\tpg_constraint; AttrMap    *attmap; ListCell   *cell; SysScanDesc scan; ScanKeyData key[2]; HeapTuple\ttuple; List\t   ...","count":3},{"name":"api-example","value":"static void ComputePartitionAttrs(ParseState *pstate, Relation rel, List *partParams, AttrNumber *partattrs, List **partexprs, Oid *partopclass, Oid *partcollation, PartitionStrategy strategy) { int\t\t...","count":3},{"name":"api-example","value":"static void ComputeXidHorizons(ComputeXidHorizonsResult *h) { ProcArrayStruct *arrayP = procArray; TransactionId kaxmin; bool\t\tin_recovery = RecoveryInProgress(); TransactionId *other_xids = ProcGloba...","count":3},{"name":"api-example","value":"static void CopyConversionError(CopyFromState cstate) { Assert(cstate->raw_buf_len > 0); Assert(cstate->input_reached_error); if (!cstate->need_transcoding) { * Everything up to input_buf_len was succ...","count":3},{"name":"api-example","value":"static void CopyConvertBuf(CopyFromState cstate) { * If the file and server encoding are the same, no encoding conversion is * required.  However, we still need to verify that the input is valid for *...","count":3},{"name":"api-example","value":"static void CreateDatabaseUsingWalLog(Oid src_dboid, Oid dst_dboid, Oid src_tsid, Oid dst_tsid) { char\t   *srcpath; char\t   *dstpath; List\t   *rlocatorlist = NULL; ListCell   *cell; LockRelId\tsrcrelid...","count":3},{"name":"api-example","value":"static void DecodeCommit(LogicalDecodingContext *ctx, XLogRecordBuffer *buf, xl_xact_parsed_commit *parsed, TransactionId xid, bool two_phase) { XLogRecPtr\torigin_lsn = InvalidXLogRecPtr; TimestampTz ...","count":3},{"name":"api-example","value":"static void Delete(File file) { Vfd\t\t   *vfdP; Assert(file != 0); DO_DB(elog(LOG, \"Delete %d (%s)\", file, VfdCache[file].fileName)); DO_DB(_dump_lru()); vfdP = &VfdCache[file]; VfdCache[vfdP->lruLessR...","count":3},{"name":"api-example","value":"static void DeleteChildTargetLocks(const PREDICATELOCKTARGETTAG *newtargettag) { SERIALIZABLEXACT *sxact; PREDICATELOCK *predlock; dlist_mutable_iter iter; LWLockAcquire(SerializablePredicateListLock,...","count":3},{"name":"api-example","value":"static void EA_flatten_into(ExpandedObjectHeader *eohptr, void *result, Size allocated_size) { ExpandedArrayHeader *eah = (ExpandedArrayHeader *) eohptr; ArrayType  *aresult = (ArrayType *) result; in...","count":3},{"name":"api-example","value":"static void EstablishVariableSpace(void) { pset.vars = CreateVariableSpace(); SetVariableHooks(pset.vars, \"AUTOCOMMIT\", bool_substitute_hook, autocommit_hook); SetVariableHooks(pset.vars, \"ON_ERROR_ST...","count":3},{"name":"api-example","value":"static void ExecEndPlan(PlanState *planstate, EState *estate) { ListCell   *l; * shut down the node-type-specific query processing */ ExecEndNode(planstate); * for subplans too */ foreach(l, estate->e...","count":3},{"name":"api-example","value":"static void ExecEvalRowNullInt(ExprState *state, ExprEvalStep *op, ExprContext *econtext, bool checkisnull) { Datum\t\tvalue = *op->resvalue; bool\t\tisnull = *op->resnull; HeapTupleHeader tuple; Oid\t\t\ttu...","count":3},{"name":"api-example","value":"static void ExecGrant_Parameter(InternalGrant *istmt) { Relation\trelation; ListCell   *cell; if (istmt->all_privs && istmt->privileges == ACL_NO_RIGHTS) istmt->privileges = ACL_ALL_RIGHTS_PARAMETER_AC...","count":3},{"name":"api-example","value":"static void ExecGrant_Type_check(InternalGrant *istmt, HeapTuple tuple) { Form_pg_type pg_type_tuple; pg_type_tuple = (Form_pg_type) GETSTRUCT(tuple); if (IsTrueArrayType(pg_type_tuple)) ereport(ERROR...","count":3},{"name":"api-example","value":"static void ExecInitWholeRowVar(ExprEvalStep *scratch, Var *variable, ExprState *state) { PlanState  *parent = state->parent; scratch->opcode = EEOP_WHOLEROW; scratch->d.wholerow.var = variable; scrat...","count":3},{"name":"api-example","value":"static void ExecParallelHashIncreaseNumBatches(HashJoinTable hashtable) { ParallelHashJoinState *pstate = hashtable->parallel_state; Assert(BarrierPhase(&pstate->build_barrier) == PHJ_BUILD_HASH_INNER...","count":3},{"name":"api-example","value":"static void ExecParallelHashIncreaseNumBuckets(HashJoinTable hashtable) { ParallelHashJoinState *pstate = hashtable->parallel_state; int\t\t\ti; HashMemoryChunk chunk; dsa_pointer chunk_s; Assert(Barrier...","count":3},{"name":"api-example","value":"static void ExecParallelHashJoinSetUpBatches(HashJoinTable hashtable, int nbatch) { ParallelHashJoinState *pstate = hashtable->parallel_state; ParallelHashJoinBatch *batches; MemoryContext oldcxt; int...","count":3},{"name":"api-example","value":"static void ExecParallelHashRepartitionRest(HashJoinTable hashtable) { ParallelHashJoinState *pstate = hashtable->parallel_state; int\t\t\told_nbatch = pstate->old_nbatch; SharedTuplestoreAccessor **old_...","count":3},{"name":"api-example","value":"static void ExecPostprocessPlan(EState *estate) { ListCell   *lc; * Make sure nodes run forward. */ estate->es_direction = ForwardScanDirection; * Run any secondary ModifyTable nodes to completion, in...","count":3},{"name":"api-example","value":"static void ExecPushExprSetupSteps(ExprState *state, ExprSetupInfo *info) { ExprEvalStep scratch = {0}; ListCell   *lc; scratch.resvalue = NULL; scratch.resnull = NULL; * Add steps deforming the ExprS...","count":3},{"name":"api-example","value":"static void ExecuteSimpleCommands(ArchiveHandle *AH, const char *buf, size_t bufLen) { const char *qry = buf; const char *eos = buf + bufLen; if (AH->sqlparse.curCmd == NULL) AH->sqlparse.curCmd = cre...","count":3},{"name":"api-example","value":"static void ExplainPrintSerialize(ExplainState *es, SerializeMetrics *metrics) { const char *format; if (es->serialize == EXPLAIN_SERIALIZE_TEXT) format = \"text\"; else { Assert(es->serialize == EXPLAI...","count":3},{"name":"api-example","value":"static void FlagSxactUnsafe(SERIALIZABLEXACT *sxact) { dlist_mutable_iter iter; Assert(SxactIsReadOnly(sxact)); Assert(!SxactIsROSafe(sxact)); sxact->flags |= SXACT_FLAG_RO_UNSAFE; * We know this isn'...","count":3},{"name":"api-example","value":"static void FreePageBtreeRemove(FreePageManager *fpm, FreePageBtree *btp, Size index) { Assert(btp->hdr.magic == FREE_PAGE_LEAF_MAGIC); Assert(index < btp->hdr.nused); if (btp->hdr.nused == 1) { FreeP...","count":3},{"name":"api-example","value":"static void FreePageBtreeSearch(FreePageManager *fpm, Size first_page, FreePageBtreeSearchResult *result) { char\t   *base = fpm_segment_base(fpm); FreePageBtree *btp = relptr_access(base, fpm->btree_r...","count":3},{"name":"api-example","value":"static void GetForeignKeyCheckTriggers(Relation trigrel, Oid conoid, Oid confrelid, Oid conrelid, Oid *insertTriggerOid, Oid *updateTriggerOid) { ScanKeyData key; SysScanDesc scan; HeapTuple\ttrigtup; ...","count":3},{"name":"api-example","value":"static void HandleChildCrash(int pid, int exitstatus, const char *procname) { dlist_mutable_iter iter; slist_iter\tsiter; Backend    *bp; bool\t\ttake_action; * We only log messages and send signals if t...","count":3},{"name":"api-example","value":"static void IndexCheckExclusion(Relation heapRelation, Relation indexRelation, IndexInfo *indexInfo) { TableScanDesc scan; Datum\t\tvalues[INDEX_MAX_KEYS]; bool\t\tisnull[INDEX_MAX_KEYS]; ExprState  *pred...","count":3},{"name":"api-example","value":"static void InitializeAttoptCache(void) { HASHCTL\t\tctl; ctl.keysize = sizeof(AttoptCacheKey); ctl.entrysize = sizeof(AttoptCacheEntry); AttoptCacheHash = hash_create(\"Attopt cache\", 256, &ctl, HASH_EL...","count":3},{"name":"api-example","value":"static void IpcSemaphoreInitialize(IpcSemaphoreId semId, int semNum, int value) { union semun semun; semun.val = value; if (semctl(semId, semNum, SETVAL, semun) < 0) { int\t\t\tsaved_errno = errno; erepo...","count":3},{"name":"api-example","value":"static void JsonItemFromDatum(Datum val, Oid typid, int32 typmod, JsonbValue *res) { switch (typid) { case BOOLOID: res->type = jbvBool; res->val.boolean = DatumGetBool(val); break; case NUMERICOID: J...","count":3},{"name":"api-example","value":"static void JsonTableResetRowPattern(JsonTablePlanState *planstate, Datum item) { JsonTablePathScan *scan = castNode(JsonTablePathScan, planstate->plan); MemoryContext oldcxt; JsonPathExecResult res; ...","count":3},{"name":"api-example","value":"static void LWLockWaitListLock(LWLock *lock) { uint32\t\told_state; #ifdef LWLOCK_STATS lwlock_stats *lwstats; uint32\t\tdelays = 0; lwstats = get_lwlock_stats_entry(lock); #endif while (true) { old_state...","count":3},{"name":"api-example","value":"static void LockViewRecurse(Oid reloid, LOCKMODE lockmode, bool nowait, List *ancestor_views) { LockViewRecurse_context context; Relation\tview; Query\t   *viewquery; view = table_open(reloid, NoLock); ...","count":3},{"name":"api-example","value":"static void LogCheckpointEnd(bool restartpoint) { long\t\twrite_msecs, sync_msecs, total_msecs, longest_msecs, average_msecs; uint64\t\taverage_sync_time; CheckpointStats.ckpt_end_t = GetCurrentTimestamp(...","count":3},{"name":"api-example","value":"static void MaintainLatestCompletedXid(TransactionId latestXid) { FullTransactionId cur_latest = TransamVariables->latestCompletedXid; Assert(FullTransactionIdIsValid(cur_latest)); Assert(!RecoveryInP...","count":3},{"name":"api-example","value":"static void PLy_get_error_data(PyObject *exc, int *sqlerrcode, char **detail, char **hint, char **schema_name, char **table_name, char **column_name, char **datatype_name, char **constraint_name) { PL...","count":3},{"name":"api-example","value":"static void ParallelWorkerShutdown(int code, Datum arg) { SendProcSignal(ParallelLeaderPid, PROCSIG_PARALLEL_MESSAGE, ParallelLeaderProcNumber); dsm_detach((dsm_segment *) DatumGetPointer(arg)); }","count":3},{"name":"api-example","value":"static void PerformMembersTruncation(MultiXactOffset oldestOffset, MultiXactOffset newOldestOffset) { const int64 maxsegment = MXOffsetToMemberSegment(MaxMultiXactOffset); int64\t\tstartsegment = MXOffs...","count":3},{"name":"api-example","value":"static void PrintQueryStatus(PGresult *result, FILE *printQueryFout) { char\t\tbuf[16]; const char *cmdstatus = PQcmdStatus(result); FILE\t   *fout = printQueryFout ? printQueryFout : pset.queryFout; if ...","count":3},{"name":"api-example","value":"static void ProcessInvalidationMessagesMulti(InvalidationMsgsGroup *group, void (*func) (const SharedInvalidationMessage *msgs, int n)) { ProcessMessageSubGroupMulti(group, CatCacheMsgs, func(msgs, n)...","count":3},{"name":"api-example","value":"static void QueuePartitionConstraintValidation(List **wqueue, Relation scanrel, List *partConstraint, bool validate_default) { * Based on the table's existing constraints, determine whether or not we ...","count":3},{"name":"api-example","value":"static void ReadDataFromArchiveNone(ArchiveHandle *AH, CompressorState *cs) { size_t\t\tcnt; char\t   *buf; size_t\t\tbuflen; buflen = DEFAULT_IO_BUFFER_SIZE; buf = pg_malloc(buflen); while ((cnt = cs->rea...","count":3},{"name":"api-example","value":"static void ReceiveArchiveStreamChunk(size_t r, char *copybuf, void *callback_data) { ArchiveStreamState *state = callback_data; size_t\t\tcursor = 0; switch (GetCopyDataByte(r, copybuf, &cursor)) { cas...","count":3},{"name":"api-example","value":"static void RecreateTwoPhaseFile(TransactionId xid, void *content, int len) { char\t\tpath[MAXPGPATH]; pg_crc32c\tstatefile_crc; int\t\t\tfd; INIT_CRC32C(statefile_crc); COMP_CRC32C(statefile_crc, content, ...","count":3},{"name":"api-example","value":"static void RelationClearRelation(Relation relation, bool rebuild) { * As per notes above, a rel to be rebuilt MUST have refcnt > 0; while of * course it would be an equally bad idea to blow away one ...","count":3},{"name":"api-example","value":"static void RelationCloseCleanup(Relation relation) { * If the relation is no longer open in this session, we can clean up any * stale partition descriptors it has.  This is unlikely, so check to see ...","count":3},{"name":"api-example","value":"static void RemoveGUCFromLists(struct config_generic *gconf) { if (gconf->source != PGC_S_DEFAULT) dlist_delete(&gconf->nondef_link); if (gconf->stack != NULL) slist_delete(&guc_stack_list, &gconf->st...","count":3},{"name":"api-example","value":"static void RemoveLocalLock(LOCALLOCK *locallock) { int\t\t\ti; for (i = locallock->numLockOwners - 1; i >= 0; i--) { if (locallock->lockOwners[i].owner != NULL) ResourceOwnerForgetLock(locallock->lockOw...","count":3},{"name":"api-example","value":"static void RemoveOldXlogFiles(XLogSegNo segno, XLogRecPtr lastredoptr, XLogRecPtr endptr, TimeLineID insertTLI) { DIR\t\t   *xldir; struct dirent *xlde; char\t\tlastoff[MAXFNAMELEN]; XLogSegNo\tendlogSegN...","count":3},{"name":"api-example","value":"static void RemoveTempRelationsCallback(int code, Datum arg) { if (OidIsValid(myTempNamespace))\t/* should always be true */ { AbortOutOfAnyTransaction(); StartTransactionCommand(); PushActiveSnapshot(...","count":3},{"name":"api-example","value":"static void RemoveXlogFile(const struct dirent *segment_de, XLogSegNo recycleSegNo, XLogSegNo *endlogSegNo, TimeLineID insertTLI) { char\t\tpath[MAXPGPATH]; #ifdef WIN32 char\t\tnewpath[MAXPGPATH]; #endif...","count":3},{"name":"api-example","value":"static void ReorderBufferChangeMemoryUpdate(ReorderBuffer *rb, ReorderBufferChange *change, ReorderBufferTXN *txn, bool addition, Size sz) { ReorderBufferTXN *toptxn; Assert(txn || change); * Ignore t...","count":3},{"name":"api-example","value":"static void ReorderBufferCleanupSerializedTXNs(const char *slotname) { DIR\t\t   *spill_dir; struct dirent *spill_de; struct stat statbuf; char\t\tpath[MAXPGPATH * 2 + 12]; sprintf(path, \"pg_replslot/%s\",...","count":3},{"name":"api-example","value":"static void ReorderBufferSerializeChange(ReorderBuffer *rb, ReorderBufferTXN *txn, int fd, ReorderBufferChange *change) { ReorderBufferDiskChange *ondisk; Size\t\tsz = sizeof(ReorderBufferDiskChange); R...","count":3},{"name":"api-example","value":"static void ReorderBufferTransferSnapToParent(ReorderBufferTXN *txn, ReorderBufferTXN *subtxn) { Assert(subtxn->toplevel_xid == txn->xid); if (subtxn->base_snapshot != NULL) { if (txn->base_snapshot =...","count":3},{"name":"api-example","value":"static void ReservePrivateRefCountEntry(void) { if (ReservedRefCountEntry != NULL) return; * First search for a free entry the array, that'll be sufficient in the * majority of cases. */ { int\t\t\ti; fo...","count":3},{"name":"api-example","value":"static void SHA512_Last(pg_sha512_ctx *context) { unsigned int usedspace; usedspace = (context->bitcount[0] >> 3) % PG_SHA512_BLOCK_LENGTH; #ifndef WORDS_BIGENDIAN REVERSE64(context->bitcount[0], cont...","count":3},{"name":"api-example","value":"static void SerialAdd(TransactionId xid, SerCommitSeqNo minConflictCommitSeqNo) { TransactionId tailXid; int64\t\ttargetPage; int\t\t\tslotno; int64\t\tfirstZeroPage; bool\t\tisNewPage; LWLock\t   *lock; Assert...","count":3},{"name":"api-example","value":"static void SetReindexProcessing(Oid heapOid, Oid indexOid) { Assert(OidIsValid(heapOid) && OidIsValid(indexOid)); if (OidIsValid(currentlyReindexedHeap)) elog(ERROR, \"cannot reindex while reindexing\"...","count":3},{"name":"api-example","value":"static void SetTriggerFlags(TriggerDesc *trigdesc, Trigger *trigger) { int16\t\ttgtype = trigger->tgtype; trigdesc->trig_insert_before_row |= TRIGGER_TYPE_MATCHES(tgtype, TRIGGER_TYPE_ROW, TRIGGER_TYPE_...","count":3},{"name":"api-example","value":"static void ShutdownWorkersHard(ParallelState *pstate) { int\t\t\ti; * Close our write end of the sockets so that any workers waiting for * commands know they can exit.  (Note: some of the pipeWrite fiel...","count":3},{"name":"api-example","value":"static void SimpleLruWaitIO(SlruCtl ctl, int slotno) { SlruShared\tshared = ctl->shared; int\t\t\tbankno = SlotGetBankNumber(slotno); Assert(shared->page_status[slotno] != SLRU_PAGE_EMPTY); LWLockRelease(...","count":3},{"name":"api-example","value":"static void StandbyReleaseXidEntryLocks(RecoveryLockXidEntry *xidentry) { RecoveryLockEntry *entry; RecoveryLockEntry *next; for (entry = xidentry->head; entry != NULL; entry = next) { LOCKTAG\t\tlockta...","count":3},{"name":"api-example","value":"static void StreamLogicalLog(void) { PGresult   *res; char\t   *copybuf = NULL; TimestampTz last_status = -1; int\t\t\ti; PQExpBuffer query; XLogRecPtr\tcur_record_lsn; output_written_lsn = InvalidXLogRecP...","count":3},{"name":"api-example","value":"static void StrictNamesCheck(RestoreOptions *ropt) { const char *missing_name; Assert(ropt->strict_names); if (ropt->schemaNames.head != NULL) { missing_name = simple_string_list_not_touched(&ropt->sc...","count":3},{"name":"api-example","value":"static void TidExprListCreate(TidScanState *tidstate) { TidScan    *node = (TidScan *) tidstate->ss.ps.plan; ListCell   *l; tidstate->tss_tidexprs = NIL; tidstate->tss_isCurrentOf = false; foreach(l, ...","count":3},{"name":"api-example","value":"static void TransactionIdSetPageStatusInternal(TransactionId xid, int nsubxids, TransactionId *subxids, XidStatus status, XLogRecPtr lsn, int64 pageno) { int\t\t\tslotno; int\t\t\ti; Assert(status == TRANSA...","count":3},{"name":"api-example","value":"static void TransitionTableAddTuple(EState *estate, TransitionCaptureState *transition_capture, ResultRelInfo *relinfo, TupleTableSlot *slot, TupleTableSlot *original_insert_tuple, Tuplestorestate *tu...","count":3},{"name":"api-example","value":"static void UnpinBufferNoOwner(BufferDesc *buf) { PrivateRefCountEntry *ref; Buffer\t\tb = BufferDescriptorGetBuffer(buf); Assert(!BufferIsLocal(b)); ref = GetPrivateRefCountEntry(b, false); Assert(ref ...","count":3},{"name":"api-example","value":"static void UpdateControlFile(void) { update_controlfile(DataDir, ControlFile, true); }","count":3},{"name":"api-example","value":"static void UpdateIndexRelation(Oid indexoid, Oid heapoid, Oid parentIndexId, const IndexInfo *indexInfo, const Oid *collationOids, const Oid *opclassOids, const int16 *coloptions, bool primary, bool ...","count":3},{"name":"api-example","value":"static void WALInsertLockAcquire(void) { bool\t\timmed; * It doesn't matter which of the WAL insertion locks we acquire, so try * the one we used last time.  If the system isn't particularly busy, it's ...","count":3},{"name":"api-example","value":"static void WINAPI pgwin32_ServiceHandler(DWORD request) { switch (request) { case SERVICE_CONTROL_STOP: case SERVICE_CONTROL_SHUTDOWN: * We only need a short wait hint here as it just needs to wait *...","count":3},{"name":"api-example","value":"static void WINAPI pgwin32_ServiceMain(DWORD argc, LPTSTR *argv) { PROCESS_INFORMATION pi; DWORD\t\tret; status.dwWin32ExitCode = S_OK; status.dwCheckPoint = 0; status.dwWaitHint = 60000; status.dwServi...","count":3},{"name":"api-example","value":"static void WalSndUpdateProgress(LogicalDecodingContext *ctx, XLogRecPtr lsn, TransactionId xid, bool skipped_xact) { static TimestampTz sendTime = 0; TimestampTz now = GetCurrentTimestamp(); bool\t\tpe...","count":3},{"name":"api-example","value":"static void WriteTempFileBlock(BufFile *file, long blknum, const void *ptr) { if (BufFileSeekBlock(file, blknum) != 0) elog(ERROR, \"could not seek to block %ld in temporary file\", blknum); BufFileWrit...","count":3},{"name":"api-example","value":"static void WriteTruncateXlogRec(int64 pageno, TransactionId oldestXact, Oid oldestXactDb) { XLogRecPtr\trecptr; xl_clog_truncate xlrec; xlrec.pageno = pageno; xlrec.oldestXact = oldestXact; xlrec.olde...","count":3},{"name":"api-example","value":"static void _CloseArchive(ArchiveHandle *AH) { lclContext *ctx = (lclContext *) AH->formatData; TAR_MEMBER *th; RestoreOptions *ropt; RestoreOptions *savRopt; DumpOptions *savDopt; int\t\t\tsavVerbose, i...","count":3},{"name":"api-example","value":"static void _WriteData(ArchiveHandle *AH, const void *data, size_t dLen) { lclTocEntry *tctx = (lclTocEntry *) AH->currToc->formatData; if (tarWrite(data, dLen, tctx->TH) != dLen) WRITE_ERROR_EXIT; }","count":3},{"name":"api-example","value":"static void _brin_end_parallel(BrinLeader *brinleader, BrinBuildState *state) { int\t\t\ti; WaitForParallelWorkersToFinish(brinleader->pcxt); * Next, accumulate WAL usage.  (This must wait for the worker...","count":3},{"name":"api-example","value":"static void _bt_buildadd(BTWriteState *wstate, BTPageState *state, IndexTuple itup, Size truncextra) { BulkWriteBuffer nbuf; Page\t\tnpage; BlockNumber nblkno; OffsetNumber last_off; Size\t\tlast_truncext...","count":3},{"name":"api-example","value":"static void _bt_insert_parent(Relation rel, Relation heaprel, Buffer buf, Buffer rbuf, BTStack stack, bool isroot, bool isonly) { Assert(heaprel != NULL); * Here we have to do something Lehman and Yao...","count":3},{"name":"api-example","value":"static void _bt_load(BTWriteState *wstate, BTSpool *btspool, BTSpool *btspool2) { BTPageState *state = NULL; bool\t\tmerge = (btspool2 != NULL); IndexTuple\titup, itup2 = NULL; bool\t\tload1; TupleDesc\ttup...","count":3},{"name":"api-example","value":"static void _bt_preprocess_array_keys_final(IndexScanDesc scan, int *keyDataMap) { BTScanOpaque so = (BTScanOpaque) scan->opaque; Relation\trel = scan->indexRelation; int\t\t\tarrayidx = 0; int\t\t\tlast_equ...","count":3},{"name":"api-example","value":"static void _bt_rewind_nonrequired_arrays(IndexScanDesc scan, ScanDirection dir) { BTScanOpaque so = (BTScanOpaque) scan->opaque; int\t\t\tarrayidx = 0; for (int ikey = 0; ikey < so->numberOfKeys; ikey++...","count":3},{"name":"api-example","value":"static void _bt_slideleft(Page rightmostpage) { OffsetNumber off; OffsetNumber maxoff; ItemId\t\tprevii; maxoff = PageGetMaxOffsetNumber(rightmostpage); Assert(maxoff >= P_FIRSTKEY); previi = PageGetIte...","count":3},{"name":"api-example","value":"static void _bt_stepright(Relation rel, Relation heaprel, BTInsertState insertstate, BTStack stack) { Page\t\tpage; BTPageOpaque opaque; Buffer\t\trbuf; BlockNumber rblkno; Assert(heaprel != NULL); page =...","count":3},{"name":"api-example","value":"static void _check_database_version(ArchiveHandle *AH) { const char *remoteversion_str; int\t\t\tremoteversion; PGresult   *res; remoteversion_str = PQparameterStatus(AH->connection, \"server_version\"); r...","count":3},{"name":"api-example","value":"static void _doSetSessionAuth(ArchiveHandle *AH, const char *user) { PQExpBuffer cmd = createPQExpBuffer(); appendPQExpBufferStr(cmd, \"SET SESSION AUTHORIZATION \"); * SQL requires a string literal her...","count":3},{"name":"api-example","value":"static void _outBoolExpr(StringInfo str, const BoolExpr *node) { char\t   *opstr = NULL; WRITE_NODE_TYPE(\"BOOLEXPR\"); switch (node->boolop) { case AND_EXPR: opstr = \"and\"; break; case OR_EXPR: opstr = ...","count":3},{"name":"api-example","value":"static void _outForeignKeyOptInfo(StringInfo str, const ForeignKeyOptInfo *node) { int\t\t\ti; WRITE_NODE_TYPE(\"FOREIGNKEYOPTINFO\"); WRITE_UINT_FIELD(con_relid); WRITE_UINT_FIELD(ref_relid); WRITE_INT_FI...","count":3},{"name":"api-example","value":"static void abstime2tm(AbsoluteTime _time, int *tzp, struct tm *tm, char **tzn) { time_t\t\ttime = (time_t) _time; struct tm  *tx; errno = 0; if (tzp != NULL) tx = localtime((time_t *) &time); else tx =...","count":3},{"name":"api-example","value":"static void addFkRecurseReferencing(List **wqueue, Constraint *fkconstraint, Relation rel, Relation pkrel, Oid indexOid, Oid parentConstr, int numfks, int16 *pkattnum, int16 *fkattnum, Oid *pfeqoperat...","count":3},{"name":"api-example","value":"static void add_reloption(relopt_gen *newoption) { static int\tmax_custom_options = 0; if (num_custom_options >= max_custom_options) { MemoryContext oldcxt; oldcxt = MemoryContextSwitchTo(TopMemoryCont...","count":3},{"name":"api-example","value":"static void add_stringlist_item(_stringlist **listhead, const char *str) { _stringlist *newentry = pg_malloc(sizeof(_stringlist)); _stringlist *oldentry; newentry->str = pg_strdup(str); newentry->next...","count":3},{"name":"api-example","value":"static void adjust_paths_for_srfs(PlannerInfo *root, RelOptInfo *rel, List *targets, List *targets_contain_srfs) { ListCell   *lc; Assert(list_length(targets) == list_length(targets_contain_srfs)); As...","count":3},{"name":"api-example","value":"static void appendConnStrItem(PQExpBuffer buf, const char *keyword, const char *val) { if (buf->len > 0) appendPQExpBufferChar(buf, ' '); appendPQExpBufferStr(buf, keyword); appendPQExpBufferChar(buf,...","count":3},{"name":"api-example","value":"static void appendToBuffer(StringInfo buffer, const char *data, int len) { int\t\t\toffset; offset = reserveFromBuffer(buffer, len); copyToBuffer(buffer, offset, data, len); }","count":3},{"name":"api-example","value":"static void apply_handle_begin(StringInfo s) { LogicalRepBeginData begin_data; Assert(!TransactionIdIsValid(stream_xid)); logicalrep_read_begin(s, &begin_data); set_apply_error_context_xact(begin_data...","count":3},{"name":"api-example","value":"static void apply_handle_begin_prepare(StringInfo s) { LogicalRepPreparedTxnData begin_data; if (am_tablesync_worker()) ereport(ERROR, (errcode(ERRCODE_PROTOCOL_VIOLATION), errmsg_internal(\"tablesync ...","count":3},{"name":"api-example","value":"static void apply_handle_commit_internal(LogicalRepCommitData *commit_data) { if (is_skipping_changes()) { stop_skipping_changes(); * Start a new transaction to clear the subskiplsn, if not started * ...","count":3},{"name":"api-example","value":"static void apply_handle_insert_internal(ApplyExecutionData *edata, ResultRelInfo *relinfo, TupleTableSlot *remoteslot) { EState\t   *estate = edata->estate; Assert(relinfo->ri_IndexRelationDescs != NU...","count":3},{"name":"api-example","value":"static void apply_handle_relation(StringInfo s) { LogicalRepRelation *rel; if (handle_streamed_transaction(LOGICAL_REP_MSG_RELATION, s)) return; rel = logicalrep_read_rel(s); logicalrep_relmap_update(...","count":3},{"name":"api-example","value":"static void archive_close_connection(int code, void *arg) { ShutdownInformation *si = (ShutdownInformation *) arg; if (si->pstate) { ParallelSlot *slot = GetMyPSlot(si->pstate); if (!slot) { * We're t...","count":3},{"name":"api-example","value":"static void array_dim_to_json(StringInfo result, int dim, int ndims, int *dims, Datum *vals, bool *nulls, int *valcount, JsonTypeCategory tcategory, Oid outfuncoid, bool use_line_feeds) { int\t\t\ti; con...","count":3},{"name":"api-example","value":"static void array_dim_to_jsonb(JsonbInState *result, int dim, int ndims, int *dims, const Datum *vals, const bool *nulls, int *valcount, JsonTypeCategory tcategory, Oid outfuncoid) { int\t\t\ti; Assert(d...","count":3},{"name":"api-example","value":"static void array_extract_slice(ArrayType *newarray, int ndim, int *dim, int *lb, char *arraydataptr, bits8 *arraynullsptr, int *st, int *endp, int typlen, bool typbyval, char typalign) { char\t   *des...","count":3},{"name":"api-example","value":"static void auth_failed(Port *port, int status, const char *logdetail) { const char *errstr; char\t   *cdetail; int\t\t\terrcode_return = ERRCODE_INVALID_AUTHORIZATION_SPECIFICATION; * If we failed due to...","count":3},{"name":"api-example","value":"static void bbsink_progress_begin_backup(bbsink *sink) { const int\tindex[] = { PROGRESS_BASEBACKUP_PHASE, PROGRESS_BASEBACKUP_BACKUP_TOTAL, PROGRESS_BASEBACKUP_TBLSPC_TOTAL }; int64\t\tval[3]; * Report ...","count":3},{"name":"api-example","value":"static void bbstreamer_recovery_injector_finalize(bbstreamer *streamer) { bbstreamer_finalize(streamer->bbs_next); }","count":3},{"name":"api-example","value":"static void bbstreamer_recovery_injector_free(bbstreamer *streamer) { bbstreamer_free(streamer->bbs_next); pfree(streamer); }","count":3},{"name":"api-example","value":"static void bernoulli_samplescangetsamplesize(PlannerInfo *root, RelOptInfo *baserel, List *paramexprs, BlockNumber *pages, double *tuples) { Node\t   *pctnode; float4\t\tsamplefract; pctnode = (Node *) ...","count":3},{"name":"api-example","value":"static void binary_upgrade_extension_member(PQExpBuffer upgrade_buffer, const DumpableObject *dobj, const char *objtype, const char *objname, const char *objnamespace) { DumpableObject *extobj = NULL;...","count":3},{"name":"api-example","value":"static void binary_upgrade_set_type_oids_by_rel(Archive *fout, PQExpBuffer upgrade_buffer, const TableInfo *tbinfo) { Oid\t\t\tpg_type_oid = tbinfo->reltype; if (OidIsValid(pg_type_oid)) binary_upgrade_s...","count":3},{"name":"api-example","value":"static void brin_vacuum_scan(Relation idxrel, BufferAccessStrategy strategy) { BlockNumber nblocks; BlockNumber blkno; * Scan the index in physical order, and clean up any possible mess in * each page...","count":3},{"name":"api-example","value":"static void brin_xlog_revmap_extend(XLogReaderState *record) { XLogRecPtr\tlsn = record->EndRecPtr; xl_brin_revmap_extend *xlrec; Buffer\t\tmetabuf; Buffer\t\tbuf; Page\t\tpage; BlockNumber targetBlk; XLogRe...","count":3},{"name":"api-example","value":"static void brinbuildCallbackParallel(Relation index, ItemPointer tid, Datum *values, bool *isnull, bool tupleIsAlive, void *brstate) { BrinBuildState *state = (BrinBuildState *) brstate; BlockNumber ...","count":3},{"name":"api-example","value":"static void buildMatViewRefreshDependencies(Archive *fout) { PQExpBuffer query; PGresult   *res; int\t\t\tntups, i; int\t\t\ti_classid, i_objid, i_refobjid; if (fout->remoteVersion < 90300) return; query = ...","count":3},{"name":"api-example","value":"static void build_hash_tables(AggState *aggstate) { int\t\t\tsetno; for (setno = 0; setno < aggstate->num_hashes; ++setno) { AggStatePerHash perhash = &aggstate->perhash[setno]; long\t\tnbuckets; Size\t\tmem...","count":3},{"name":"api-example","value":"static void build_pertrans_for_aggref(AggStatePerTrans pertrans, AggState *aggstate, EState *estate, Aggref *aggref, Oid transfn_oid, Oid aggtranstype, Oid aggserialfn, Oid aggdeserialfn, Datum initVa...","count":3},{"name":"api-example","value":"static void calc_inet_union_params(GISTENTRY *ent, int m, int n, int *minfamily_p, int *maxfamily_p, int *minbits_p, int *commonbits_p) { int\t\t\tminfamily, maxfamily, minbits, commonbits; unsigned char...","count":3},{"name":"api-example","value":"static void charclass(struct vars *v, enum char_classes cls, struct state *lp, struct state *rp) { struct cvec *cv; NOTE(REG_ULOCALE); cv = cclasscvec(v, cls, (v->cflags & REG_ICASE)); NOERR(); subcol...","count":3},{"name":"api-example","value":"static void checkWellFormedRecursion(CteState *cstate) { int\t\t\ti; for (i = 0; i < cstate->numitems; i++) { CommonTableExpr *cte = cstate->items[i].cte; SelectStmt *stmt = (SelectStmt *) cte->ctequery;...","count":3},{"name":"api-example","value":"static void check_agglevels_and_constraints(ParseState *pstate, Node *expr) { List\t   *directargs = NIL; List\t   *args = NIL; Expr\t   *filter = NULL; int\t\t\tmin_varlevel; int\t\t\tlocation = -1; Index\t   ...","count":3},{"name":"api-example","value":"static void check_bin_dir(ClusterInfo *cluster, bool check_versions) { struct stat statBuf; if (stat(cluster->bindir, &statBuf) != 0) report_status(PG_FATAL, \"check for \\\"%s\\\" failed: %m\", cluster->bi...","count":3},{"name":"api-example","value":"static void check_data_dir(ClusterInfo *cluster) { const char *pg_data = cluster->pgdata; cluster->major_version = get_major_server_version(cluster); check_single_dir(pg_data, \"\"); check_single_dir(pg...","count":3},{"name":"api-example","value":"static void check_hba(hbaPort *port) { Oid\t\t\troleid; ListCell   *line; HbaLine    *hba; roleid = get_role_oid(port->user_name, true); foreach(line, parsed_hba_lines) { hba = (HbaLine *) lfirst(line); ...","count":3},{"name":"api-example","value":"static void check_publications_origin(WalReceiverConn *wrconn, List *publications, bool copydata, char *origin, Oid *subrel_local_oids, int subrel_count, char *subname) { WalRcvExecResult *res; String...","count":3},{"name":"api-example","value":"static void check_unicode_value(pg_wchar c) { if (!is_valid_unicode_codepoint(c)) ereport(ERROR, (errcode(ERRCODE_SYNTAX_ERROR), errmsg(\"invalid Unicode escape value\"))); }","count":3},{"name":"api-example","value":"static void classify_matching_subplans(AppendState *node) { Bitmapset  *valid_asyncplans; Assert(node->as_valid_subplans_identified); Assert(node->as_valid_asyncplans == NULL); if (bms_is_empty(node->...","count":3},{"name":"api-example","value":"static void compile_database_list(PGconn *conn, SimplePtrList *databases, const char *initial_dbname) { PGresult   *res; PQExpBufferData sql; int\t\t\tntups; int\t\t\ti; bool\t\tfatal; if (initial_dbname) { D...","count":3},{"name":"api-example","value":"static void compute_scalar_stats(VacAttrStatsP stats, AnalyzeAttrFetchFunc fetchfunc, int samplerows, double totalrows) { int\t\t\ti; int\t\t\tnull_cnt = 0; int\t\t\tnonnull_cnt = 0; int\t\t\ttoowide_cnt = 0; dou...","count":3},{"name":"api-example","value":"static void compute_trivial_stats(VacAttrStatsP stats, AnalyzeAttrFetchFunc fetchfunc, int samplerows, double totalrows) { int\t\t\ti; int\t\t\tnull_cnt = 0; int\t\t\tnonnull_cnt = 0; double\t\ttotal_width = 0; ...","count":3},{"name":"api-example","value":"static void compute_tsvector_stats(VacAttrStats *stats, AnalyzeAttrFetchFunc fetchfunc, int samplerows, double totalrows) { int\t\t\tnum_mcelem; int\t\t\tnull_cnt = 0; double\t\ttotal_width = 0; HTAB\t   *lexe...","count":3},{"name":"api-example","value":"static void connectFailureMessage(PGconn *conn, int errorno) { char\t\tsebuf[PG_STRERROR_R_BUFLEN]; appendPQExpBuffer(&conn->errorMessage, \"%s\\n\", SOCK_STRERROR(errorno, sebuf, sizeof(sebuf))); if (conn...","count":3},{"name":"api-example","value":"static void consider_index_join_outer_rels(PlannerInfo *root, RelOptInfo *rel, IndexOptInfo *index, IndexClauseSet *rclauseset, IndexClauseSet *jclauseset, IndexClauseSet *eclauseset, List **bitindexp...","count":3},{"name":"api-example","value":"static void convertJsonbArray(StringInfo buffer, JEntry *header, JsonbValue *val, int level) { int\t\t\tbase_offset; int\t\t\tjentry_offset; int\t\t\ti; int\t\t\ttotallen; uint32\t\tcontainerhead; int\t\t\tnElems = va...","count":3},{"name":"api-example","value":"static void cost_tuplesort(Cost *startup_cost, Cost *run_cost, double tuples, int width, Cost comparison_cost, int sort_mem, double limit_tuples) { double\t\tinput_bytes = relation_byte_size(tuples, wid...","count":3},{"name":"api-example","value":"static void create_one_window_path(PlannerInfo *root, RelOptInfo *window_rel, Path *path, PathTarget *input_target, PathTarget *output_target, WindowFuncLists *wflists, List *activeWindows) { PathTarg...","count":3},{"name":"api-example","value":"static void create_plain_partial_paths(PlannerInfo *root, RelOptInfo *rel) { int\t\t\tparallel_workers; parallel_workers = compute_parallel_worker(rel, rel->pages, -1, max_parallel_workers_per_gather); i...","count":3},{"name":"api-example","value":"static void create_tablespace_directories(const char *location, const Oid tablespaceoid) { char\t   *linkloc; char\t   *location_with_version_dir; struct stat st; bool\t\tin_place; linkloc = psprintf(\"pg_...","count":3},{"name":"api-example","value":"static void createarc(struct nfa *nfa, int t, color co, struct state *from, struct state *to) { struct arc *a; a = allocarc(nfa); if (NISERR()) return; assert(a != NULL); a->type = t; a->co = co; a->t...","count":3},{"name":"api-example","value":"static void dataExecPlaceToPageInternal(GinBtree btree, Buffer buf, GinBtreeStack *stack, void *insertdata, BlockNumber updateblkno, void *ptp_workspace) { Page\t\tpage = BufferGetPage(buf); OffsetNumbe...","count":3},{"name":"api-example","value":"static void dataSplitPageInternal(GinBtree btree, Buffer origbuf, GinBtreeStack *stack, void *insertdata, BlockNumber updateblkno, Page *newlpage, Page *newrpage) { Page\t\toldpage = BufferGetPage(origb...","count":3},{"name":"api-example","value":"static void datum_to_json_internal(Datum val, bool is_null, StringInfo result, JsonTypeCategory tcategory, Oid outfuncoid, bool key_scalar) { char\t   *outputstr; text\t   *jsontext; check_stack_depth()...","count":3},{"name":"api-example","value":"static void deconstruct_distribute(PlannerInfo *root, JoinTreeItem *jtitem) { Node\t   *jtnode = jtitem->jtnode; if (IsA(jtnode, RangeTblRef)) { int\t\t\tvarno = ((RangeTblRef *) jtnode)->rtindex; if (roo...","count":3},{"name":"api-example","value":"static void deconstruct_distribute_oj_quals(PlannerInfo *root, List *jtitems, JoinTreeItem *jtitem) { SpecialJoinInfo *sjinfo = jtitem->sjinfo; Relids\t\tqualscope, ojscope, nonnullable_rels; qualscope ...","count":3},{"name":"api-example","value":"static void div_var(const NumericVar *var1, const NumericVar *var2, NumericVar *result, int rscale, bool round) { int\t\t\tdiv_ndigits; int\t\t\tres_ndigits; int\t\t\tres_sign; int\t\t\tres_weight; int\t\t\tcarry; i...","count":3},{"name":"api-example","value":"static void doDeletion(const ObjectAddress *object, int flags) { switch (object->classId) { case RelationRelationId: { char\t\trelKind = get_rel_relkind(object->objectId); if (relKind == RELKIND_INDEX |...","count":3},{"name":"api-example","value":"static void doLog(TState *thread, CState *st, StatsData *agg, bool skipped, double latency, double lag) { FILE\t   *logfile = thread->logfile; pg_time_usec_t now = pg_time_now() + epoch_shift; Assert(u...","count":3},{"name":"api-example","value":"static void do_autovacuum(void) { Relation\tclassRel; HeapTuple\ttuple; TableScanDesc relScan; Form_pg_database dbForm; List\t   *table_oids = NIL; List\t   *orphan_oids = NIL; HASHCTL\t\tctl; HTAB\t   *tabl...","count":3},{"name":"api-example","value":"static void do_numeric_accum(NumericAggState *state, Numeric newval) { NumericVar\tX; NumericVar\tX2; MemoryContext old_context; if (NUMERIC_IS_SPECIAL(newval)) { if (NUMERIC_IS_PINF(newval)) state->pIn...","count":3},{"name":"api-example","value":"static void does_not_exist_skipping(ObjectType objtype, Node *object) { const char *msg = NULL; char\t   *name = NULL; char\t   *args = NULL; switch (objtype) { case OBJECT_ACCESS_METHOD: msg = gettext_...","count":3},{"name":"api-example","value":"static void dropstate(struct nfa *nfa, struct state *s) { struct arc *a; while ((a = s->ins) != NULL) freearc(nfa, a); while ((a = s->outs) != NULL) freearc(nfa, a); freestate(nfa, s); }","count":3},{"name":"api-example","value":"static void dumpBaseType(Archive *fout, const TypeInfo *tyinfo) { DumpOptions *dopt = fout->dopt; PQExpBuffer q = createPQExpBuffer(); PQExpBuffer delq = createPQExpBuffer(); PQExpBuffer query = creat...","count":3},{"name":"api-example","value":"static void dumpCompositeType(Archive *fout, const TypeInfo *tyinfo) { DumpOptions *dopt = fout->dopt; PQExpBuffer q = createPQExpBuffer(); PQExpBuffer dropped = createPQExpBuffer(); PQExpBuffer delq ...","count":3},{"name":"api-example","value":"static void dumpNamespace(Archive *fout, const NamespaceInfo *nspinfo) { DumpOptions *dopt = fout->dopt; PQExpBuffer q; PQExpBuffer delq; char\t   *qnspname; if (dopt->dataOnly) return; q = createPQExp...","count":3},{"name":"api-example","value":"static void dumpProcLang(Archive *fout, const ProcLangInfo *plang) { DumpOptions *dopt = fout->dopt; PQExpBuffer defqry; PQExpBuffer delqry; bool\t\tuseParams; char\t   *qlanname; FuncInfo   *funcInfo; F...","count":3},{"name":"api-example","value":"static void dumpRangeType(Archive *fout, const TypeInfo *tyinfo) { DumpOptions *dopt = fout->dopt; PQExpBuffer q = createPQExpBuffer(); PQExpBuffer delq = createPQExpBuffer(); PQExpBuffer query = crea...","count":3},{"name":"api-example","value":"static void dumpTSParser(Archive *fout, const TSParserInfo *prsinfo) { DumpOptions *dopt = fout->dopt; PQExpBuffer q; PQExpBuffer delq; char\t   *qprsname; if (dopt->dataOnly) return; q = createPQExpBu...","count":3},{"name":"api-example","value":"static void dump_assign(PLpgSQL_stmt_assign *stmt) { dump_ind(); printf(\"ASSIGN var %d := \", stmt->varno); dump_expr(stmt->expr); printf(\"\\n\"); }","count":3},{"name":"api-example","value":"static void dump_lo_buf(ArchiveHandle *AH) { if (AH->connection) { int\t\t\tres; res = lo_write(AH->connection, AH->loFd, AH->lo_buf, AH->lo_buf_used); pg_log_debug(ngettext(\"wrote %zu byte of large obje...","count":3},{"name":"api-example","value":"static void eat(char const *name, lineno_t num) { eats(name, num, NULL, -1); }","count":3},{"name":"api-example","value":"static void enlarge_list(List *list, int min_size) { int\t\t\tnew_max_len; Assert(min_size > list->max_length);\t/* else we shouldn't be here */ #ifndef DEBUG_LIST_MEMORY_USAGE * As above, we prefer power...","count":3},{"name":"api-example","value":"static void ensure_last_message(FileSet *stream_fileset, TransactionId xid, int fileno, off_t offset) { char\t\tpath[MAXPGPATH]; BufFile    *fd; int\t\t\tlast_fileno; off_t\t\tlast_offset; Assert(!IsTransact...","count":3},{"name":"api-example","value":"static void entryGetItem(GinState *ginstate, GinScanEntry entry, ItemPointerData advancePast) { Assert(!entry->isFinished); Assert(!ItemPointerIsValid(&entry->curItem) || ginCompareItemPointers(&entry...","count":3},{"name":"api-example","value":"static void entryPreparePage(GinBtree btree, Page page, OffsetNumber off, GinBtreeEntryInsertData *insertData, BlockNumber updateblkno) { Assert(insertData->entry); Assert(!GinPageIsData(page)); if (i...","count":3},{"name":"api-example","value":"static void exec_assign_value(PLpgSQL_execstate *estate, PLpgSQL_datum *target, Datum value, bool isNull, Oid valtype, int32 valtypmod) { switch (target->dtype) { case PLPGSQL_DTYPE_VAR: case PLPGSQL_...","count":3},{"name":"api-example","value":"static void exec_move_row(PLpgSQL_execstate *estate, PLpgSQL_variable *target, HeapTuple tup, TupleDesc tupdesc) { ExpandedRecordHeader *newerh = NULL; * If target is RECORD, we may be able to avoid f...","count":3},{"name":"api-example","value":"static void execute_sql_string(const char *sql) { List\t   *raw_parsetree_list; DestReceiver *dest; ListCell   *lc1; * Parse the SQL string into a list of raw parse trees. */ raw_parsetree_list = pg_pa...","count":3},{"name":"api-example","value":"static void expand_all_col_privileges(Oid table_oid, Form_pg_class classForm, AclMode this_privileges, AclMode *col_privileges, int num_col_privileges) { AttrNumber\tcurr_att; Assert(classForm->relnatt...","count":3},{"name":"api-example","value":"static void expand_schema_name_patterns(Archive *fout, SimpleStringList *patterns, SimpleOidList *oids, bool strict_names) { PQExpBuffer query; PGresult   *res; SimpleStringListCell *cell; int\t\t\ti; if...","count":3},{"name":"api-example","value":"static void fallbackSplit(GistEntryVector *entryvec, GIST_SPLITVEC *v) { OffsetNumber i, maxoff; BOX\t\t   *unionL = NULL, *unionR = NULL; int\t\t\tnbytes; maxoff = entryvec->n - 1; nbytes = (maxoff + 2) *...","count":3},{"name":"api-example","value":"static void fillRelOptions(void *rdopts, Size basesize, relopt_value *options, int numoptions, bool validate, const relopt_parse_elt *elems, int numelems) { int\t\t\ti; int\t\t\toffset = basesize; for (i = ...","count":3},{"name":"api-example","value":"static void fill_ident_line(Tuplestorestate *tuple_store, TupleDesc tupdesc, int map_number, char *filename, int lineno, IdentLine *ident, const char *err_msg) { Datum\t\tvalues[NUM_PG_IDENT_FILE_MAPPIN...","count":3},{"name":"api-example","value":"static void find_hash_columns(AggState *aggstate) { Bitmapset  *base_colnos; Bitmapset  *aggregated_colnos; TupleDesc\tscanDesc = aggstate->ss.ss_ScanTupleSlot->tts_tupleDescriptor; List\t   *outerTlist...","count":3},{"name":"api-example","value":"static void fix_expr_common(PlannerInfo *root, Node *node) { if (IsA(node, Aggref)) { record_plan_function_dependency(root, ((Aggref *) node)->aggfnoid); } else if (IsA(node, WindowFunc)) { record_pla...","count":3},{"name":"api-example","value":"static void flagInhAttrs(Archive *fout, TableInfo *tblinfo, int numTables) { DumpOptions *dopt = fout->dopt; int\t\t\ti, j, k; * We scan the tables in OID order, since that's how tblinfo[] is sorted. * H...","count":3},{"name":"api-example","value":"static void fmtstr(const char *value, int leftjust, int minlen, int maxwidth, int pointflag, PrintfTarget *target) { int\t\t\tpadlen, vallen;\t\t\t/* amount to pad */ * If a maxwidth (precision) is specifie...","count":3},{"name":"api-example","value":"static void free_assign(PLpgSQL_stmt_assign *stmt) { free_expr(stmt->expr); }","count":3},{"name":"api-example","value":"static void free_auth_token(AuthToken *token) { if (token_has_regexp(token)) pg_regfree(token->regex); }","count":3},{"name":"api-example","value":"static void free_block(PLpgSQL_stmt_block *block) { free_stmts(block->body); if (block->exceptions) { ListCell   *e; foreach(e, block->exceptions->exc_list) { PLpgSQL_exception *exc = (PLpgSQL_excepti...","count":3},{"name":"api-example","value":"static void freetree(NODE *node) { check_stack_depth(); if (!node) return; if (node->left) freetree(node->left); if (node->right) freetree(node->right); pfree(node); }","count":3},{"name":"api-example","value":"static void gather_merge_setup(GatherMergeState *gm_state) { GatherMerge *gm = castNode(GatherMerge, gm_state->ps.plan); int\t\t\tnreaders = gm->num_workers; int\t\t\ti; * Allocate gm_slots for the number o...","count":3},{"name":"api-example","value":"static void gen_partprune_steps(RelOptInfo *rel, List *clauses, PartClauseTarget target, GeneratePruningStepsContext *context) { memset(context, 0, sizeof(GeneratePruningStepsContext)); context->rel =...","count":3},{"name":"api-example","value":"static void getNextFlagFromString(IspellDict *Conf, char **sflagset, char *sflag) { int32\t\ts; char\t   *next, *sbuf = *sflagset; int\t\t\tmaxstep; bool\t\tstop = false; bool\t\tmet_comma = false; maxstep = (C...","count":3},{"name":"api-example","value":"static void get_const_expr(Const *constval, deparse_context *context, int showtype) { StringInfo\tbuf = context->buf; Oid\t\t\ttypoutput; bool\t\ttypIsVarlena; char\t   *extval; bool\t\tneedlabel = false; if (...","count":3},{"name":"api-example","value":"static void get_db_infos(ClusterInfo *cluster) { PGconn\t   *conn = connectToServer(cluster, \"template1\"); PGresult   *res; int\t\t\tntups; int\t\t\ttupnum; DbInfo\t   *dbinfos; int\t\t\ti_datname, i_oid, i_spcl...","count":3},{"name":"api-example","value":"static void get_from_clause_item(Node *jtnode, Query *query, deparse_context *context) { StringInfo\tbuf = context->buf; deparse_namespace *dpns = (deparse_namespace *) linitial(context->namespaces); i...","count":3},{"name":"api-example","value":"static void get_insert_query_def(Query *query, deparse_context *context) { StringInfo\tbuf = context->buf; RangeTblEntry *select_rte = NULL; RangeTblEntry *values_rte = NULL; RangeTblEntry *rte; char\t ...","count":3},{"name":"api-example","value":"static void get_matching_part_pairs(PlannerInfo *root, RelOptInfo *joinrel, RelOptInfo *rel1, RelOptInfo *rel2, List **parts1, List **parts2) { bool\t\trel1_is_simple = IS_SIMPLE_REL(rel1); bool\t\trel2_i...","count":3},{"name":"api-example","value":"static void get_publications_str(List *publications, StringInfo dest, bool quote_literal) { ListCell   *lc; bool\t\tfirst = true; Assert(publications != NIL); foreach(lc, publications) { char\t   *pubnam...","count":3},{"name":"api-example","value":"static void get_select_query_def(Query *query, deparse_context *context) { StringInfo\tbuf = context->buf; bool\t\tforce_colno; ListCell   *l; get_with_clause(query, context); context->targetList = query...","count":3},{"name":"api-example","value":"static void ginDeletePage(GinVacuumState *gvs, BlockNumber deleteBlkno, BlockNumber leftBlkno, BlockNumber parentBlkno, OffsetNumber myoff, bool isParentRoot) { Buffer\t\tdBuffer; Buffer\t\tlBuffer; Buffe...","count":3},{"name":"api-example","value":"static void ginInsertBAEntry(BuildAccumulator *accum, ItemPointer heapptr, OffsetNumber attnum, Datum key, GinNullCategory category) { GinEntryAccumulator eatmp; GinEntryAccumulator *ea; bool\t\tisNew; ...","count":3},{"name":"api-example","value":"static void ginRedoInsertEntry(Buffer buffer, bool isLeaf, BlockNumber rightblkno, void *rdata) { Page\t\tpage = BufferGetPage(buffer); ginxlogInsertEntry *data = (ginxlogInsertEntry *) rdata; OffsetNum...","count":3},{"name":"api-example","value":"static void ginVacuumPostingTree(GinVacuumState *gvs, BlockNumber rootBlkno) { if (ginVacuumPostingTreeLeaves(gvs, rootBlkno)) { * There is at least one empty page.  So we have to rescan the tree * de...","count":3},{"name":"api-example","value":"static void gistBuildCallback(Relation index, ItemPointer tid, Datum *values, bool *isnull, bool tupleIsAlive, void *state) { GISTBuildState *buildstate = (GISTBuildState *) state; IndexTuple\titup; Me...","count":3},{"name":"api-example","value":"static void gistScanPage(IndexScanDesc scan, GISTSearchItem *pageItem, IndexOrderByDistance *myDistances, TIDBitmap *tbm, int64 *ntids) { GISTScanOpaque so = (GISTScanOpaque) scan->opaque; GISTSTATE  ...","count":3},{"name":"api-example","value":"static void hash_agg_check_limits(AggState *aggstate) { uint64\t\tngroups = aggstate->hash_ngroups_current; Size\t\tmeta_mem = MemoryContextMemAllocated(aggstate->hash_metacxt, true); Size\t\thashkey_mem = ...","count":3},{"name":"api-example","value":"static void hash_inner_and_outer(PlannerInfo *root, RelOptInfo *joinrel, RelOptInfo *outerrel, RelOptInfo *innerrel, JoinType jointype, JoinPathExtraData *extra) { JoinType\tsave_jointype = jointype; b...","count":3},{"name":"api-example","value":"static void hash_xlog_add_ovfl_page(XLogReaderState *record) { XLogRecPtr\tlsn = record->EndRecPtr; xl_hash_add_ovfl_page *xlrec = (xl_hash_add_ovfl_page *) XLogRecGetData(record); Buffer\t\tleftbuf; Buf...","count":3},{"name":"api-example","value":"static void hash_xlog_split_allocate_page(XLogReaderState *record) { XLogRecPtr\tlsn = record->EndRecPtr; xl_hash_split_allocate_page *xlrec = (xl_hash_split_allocate_page *) XLogRecGetData(record); Bu...","count":3},{"name":"api-example","value":"static void hashagg_spill_finish(AggState *aggstate, HashAggSpill *spill, int setno) { int\t\t\ti; int\t\t\tused_bits = 32 - spill->shift; if (spill->npartitions == 0) return;\t\t\t\t\t/* didn't spill */ for (i ...","count":3},{"name":"api-example","value":"static void hashagg_spill_init(HashAggSpill *spill, LogicalTapeSet *tapeset, int used_bits, double input_groups, double hashentrysize) { int\t\t\tnpartitions; int\t\t\tpartition_bits; npartitions = hash_cho...","count":3},{"name":"api-example","value":"static void heap_xlog_prune_freeze(XLogReaderState *record) { XLogRecPtr\tlsn = record->EndRecPtr; char\t   *maindataptr = XLogRecGetData(record); xl_heap_prune xlrec; Buffer\t\tbuffer; RelFileLocator rlo...","count":3},{"name":"api-example","value":"static void heap_xlog_update(XLogReaderState *record, bool hot_update) { XLogRecPtr\tlsn = record->EndRecPtr; xl_heap_update *xlrec = (xl_heap_update *) XLogRecGetData(record); RelFileLocator rlocator;...","count":3},{"name":"api-example","value":"static void infile(const char *name) { FILE\t   *fp; char\t  **fields; char\t   *cp; const struct lookup *lp; int\t\t\tnfields; bool\t\twantcont; lineno_t\tnum; char\t\tbuf[BUFSIZ]; if (strcmp(name, \"-\") == 0) {...","count":3},{"name":"api-example","value":"static void initDropTables(PGconn *con) { fprintf(stderr, \"dropping old tables...\\n\"); * We drop all the tables in one command, so that whether there are * foreign key dependencies or not doesn't matt...","count":3},{"name":"api-example","value":"static void initRandomState(pg_prng_state *state) { pg_prng_seed(state, pg_prng_uint64(&base_random_sequence)); }","count":3},{"name":"api-example","value":"static void init_libpq_conn(PGconn *conn) { PGresult   *res; char\t   *str; run_simple_command(conn, \"SET statement_timeout = 0\"); run_simple_command(conn, \"SET lock_timeout = 0\"); run_simple_command(c...","count":3},{"name":"api-example","value":"static void init_sexpr(Oid foid, Oid input_collation, Expr *node, SetExprState *sexpr, PlanState *parent, MemoryContext sexprCxt, bool allowSRF, bool needDescForSRF) { AclResult\taclresult; size_t\t\tnum...","count":3},{"name":"api-example","value":"static void initialize_aggregates(AggState *aggstate, AggStatePerGroup *pergroups, int numReset) { int\t\t\ttransno; int\t\t\tnumGroupingSets = Max(aggstate->phase->numsets, 1); int\t\t\tsetno = 0; int\t\t\tnumTr...","count":3},{"name":"api-example","value":"static void initialize_phase(AggState *aggstate, int newphase) { Assert(newphase <= 1 || newphase == aggstate->current_phase + 1); * Whatever the previous state, we're now done with whatever input * t...","count":3},{"name":"api-example","value":"static void inrule(char **fields, int nfields) { static struct rule r; if (nfields != RULE_FIELDS) { error(_(\"wrong number of fields on Rule line\")); return; } switch (*fields[RF_NAME]) { case '\\0': c...","count":3},{"name":"api-example","value":"static void lazy_scan_heap(LVRelState *vacrel) { BlockNumber rel_pages = vacrel->rel_pages, blkno, next_fsm_block_to_vacuum = 0; bool\t\tall_visible_according_to_vm; Buffer\t\tvmbuffer = InvalidBuffer; co...","count":3},{"name":"api-example","value":"static void lexstart(struct vars *v) { prefixes(v);\t\t\t\t/* may turn on new type bits etc. */ NOERR(); if (v->cflags & REG_QUOTE) { assert(!(v->cflags & (REG_ADVANCED | REG_EXPANDED | REG_NEWLINE))); IN...","count":3},{"name":"api-example","value":"static void libpq_queue_fetch_file(rewind_source *source, const char *path, size_t len) { * Truncate the target file immediately, and queue a request to fetch it * from the source. If the file is smal...","count":3},{"name":"api-example","value":"static void libpqrcv_processTuples(PGresult *pgres, WalRcvExecResult *walres, const int nRetTypes, const Oid *retTypes) { int\t\t\ttupn; int\t\t\tcoln; int\t\t\tnfields = PQnfields(pgres); HeapTuple\ttuple; Att...","count":3},{"name":"api-example","value":"static void libpqrcv_readtimelinehistoryfile(WalReceiverConn *conn, TimeLineID tli, char **filename, char **content, int *len) { PGresult   *res; char\t\tcmd[64]; Assert(!conn->logical); * Request the p...","count":3},{"name":"api-example","value":"static void libpqrcv_send(WalReceiverConn *conn, const char *buffer, int nbytes) { if (PQputCopyData(conn->streamConn, buffer, nbytes) <= 0 || PQflush(conn->streamConn)) ereport(ERROR, (errcode(ERRCOD...","count":3},{"name":"api-example","value":"static void llvm_session_initialize(void) { MemoryContext oldcontext; char\t   *error = NULL; char\t   *cpu = NULL; char\t   *features = NULL; LLVMTargetMachineRef opt0_tm; LLVMTargetMachineRef opt3_tm; ...","count":3},{"name":"api-example","value":"static void lockTableForWorker(ArchiveHandle *AH, TocEntry *te) { const char *qualId; PQExpBuffer query; PGresult   *res; if (strcmp(te->desc, \"BLOBS\") == 0) return; query = createPQExpBuffer(); qualI...","count":3},{"name":"api-example","value":"static void logicalrep_relmap_init(void) { HASHCTL\t\tctl; if (!LogicalRepRelMapContext) LogicalRepRelMapContext = AllocSetContextCreate(CacheMemoryContext, \"LogicalRepRelMapContext\", ALLOCSET_DEFAULT_S...","count":3},{"name":"api-example","value":"static void logicalrep_relmap_invalidate_cb(Datum arg, Oid reloid) { LogicalRepRelMapEntry *entry; if (LogicalRepRelMap == NULL) return; if (reloid != InvalidOid) { HASH_SEQ_STATUS status; hash_seq_in...","count":3},{"name":"api-example","value":"static void lookup_hash_entries(AggState *aggstate) { AggStatePerGroup *pergroup = aggstate->hash_pergroup; TupleTableSlot *outerslot = aggstate->tmpcontext->ecxt_outertuple; int\t\t\tsetno; for (setno =...","count":3},{"name":"api-example","value":"static void makesearch(struct vars *v, struct nfa *nfa) { struct arc *a; struct arc *b; struct state *pre = nfa->pre; struct state *s; struct state *s2; struct state *slist; for (a = pre->outs; a != N...","count":3},{"name":"api-example","value":"static void makesign(BITVECP sign, SignTSVector *a, int siglen) { int32\t\tk, len = ARRNELEM(a); int32\t   *ptr = GETARR(a); MemSet(sign, 0, siglen); for (k = 0; k < len; k++) HASH(sign, ptr[k], siglen);...","count":3},{"name":"api-example","value":"static void markRTEForSelectPriv(ParseState *pstate, int rtindex, AttrNumber col) { RangeTblEntry *rte = rt_fetch(rtindex, pstate->p_rtable); if (rte->rtekind == RTE_RELATION) { RTEPermissionInfo *per...","count":3},{"name":"api-example","value":"static void mark_hl_fragments(HeadlineParsedText *prs, TSQuery query, List *locations, bool highlightall, int shortword, int min_words, int max_words, int max_fragments) { int32\t\tposlen, curlen, i, f,...","count":3},{"name":"api-example","value":"static void md5_pad(pg_md5_ctx *ctx) { unsigned int gap; gap = MD5_BUFLEN - ctx->md5_i; if (gap > 8) { memmove(ctx->md5_buf + ctx->md5_i, md5_paddat, gap - sizeof(ctx->md5_n)); } else { memmove(ctx->m...","count":3},{"name":"api-example","value":"static void minmax_qp_callback(PlannerInfo *root, void *extra) { root->group_pathkeys = NIL; root->window_pathkeys = NIL; root->distinct_pathkeys = NIL; root->sort_pathkeys = make_pathkeys_for_sortcla...","count":3},{"name":"api-example","value":"static void moveins(struct nfa *nfa, struct state *oldState, struct state *newState) { assert(oldState != newState); if (newState->nins == 0) { struct arc *a; while ((a = oldState->ins) != NULL) { cre...","count":3},{"name":"api-example","value":"static void newarc(struct nfa *nfa, int t, color co, struct state *from, struct state *to) { struct arc *a; assert(from != NULL && to != NULL); * This is a handy place to check for operation cancel du...","count":3},{"name":"api-example","value":"static void nonword(struct vars *v, int dir,\t\t\t\t/* AHEAD or BEHIND */ struct state *lp, struct state *rp) { int\t\t\tanchor = (dir == AHEAD) ? '$' : '^'; assert(dir == AHEAD || dir == BEHIND); newarc(v->...","count":3},{"name":"api-example","value":"static void outChar(StringInfo str, char c) { char\t\tin[2]; if (c == '\\0') { appendStringInfoString(str, \"<>\"); return; } in[0] = c; in[1] = '\\0'; outToken(str, in); }","count":3},{"name":"api-example","value":"static void outzone(const struct zone *zpfirst, ptrdiff_t zonecount) { const struct zone *zp; struct rule *rp; ptrdiff_t\ti, j; bool\t\tusestart, useuntil; zic_t\t\tstarttime, untiltime; zic_t\t\tstdoff; zic...","count":3},{"name":"api-example","value":"static void parallel_vacuum_process_safe_indexes(ParallelVacuumState *pvs) { * Increment the active worker count if we are able to launch any worker. */ if (VacuumActiveNWorkers) pg_atomic_add_fetch_u...","count":3},{"name":"api-example","value":"static void parseWorkerCommand(ArchiveHandle *AH, TocEntry **te, T_Action *act, const char *msg) { DumpId\t\tdumpId; int\t\t\tnBytes; if (messageStartsWith(msg, \"DUMP \")) { *act = ACT_DUMP; sscanf(msg, \"DU...","count":3},{"name":"api-example","value":"static void parse_basebackup_options(List *options, basebackup_options *opt) { ListCell   *lopt; bool\t\to_label = false; bool\t\to_progress = false; bool\t\to_checkpoint = false; bool\t\to_nowait = false; bo...","count":3},{"name":"api-example","value":"static void perform_pullup_replace_vars(PlannerInfo *root, pullup_replace_vars_context *rvcontext, AppendRelInfo *containing_appendrel) { Query\t   *parse = root->parse; ListCell   *lc; * If we are con...","count":3},{"name":"api-example","value":"static void pg_GSS_error_int(char *s, size_t len, OM_uint32 stat, int type) { gss_buffer_desc gmsg; size_t\t\ti = 0; OM_uint32\tlmin_s, msg_ctx = 0; do { if (gss_display_status(&lmin_s, stat, type, GSS_C...","count":3},{"name":"api-example","value":"static void pg_attribute_noreturn() finish_sync_worker(void) { * Commit any outstanding transaction. This is the usual case, unless * there was nothing to do for the table. */ if (IsTransactionState()...","count":3},{"name":"api-example","value":"static void plan_elem_desc(StringInfo buf, void *plan, void *data) { xlhp_freeze_plan *new_plan = (xlhp_freeze_plan *) plan; OffsetNumber **offsets = data; appendStringInfo(buf, \"{ xmax: %u, infomask:...","count":3},{"name":"api-example","value":"static void plperl_fini(int code, Datum arg) { HASH_SEQ_STATUS hash_seq; plperl_interp_desc *interp_desc; elog(DEBUG3, \"plperl_fini\"); * Indicate that perl is terminating. Disables use of spi_* functi...","count":3},{"name":"api-example","value":"static void plperl_trusted_init(void) { dTHX; HV\t\t   *stash; SV\t\t   *sv; char\t   *key; I32\t\t\tklen; PL_ppaddr[OP_REQUIRE] = pp_require_orig; PL_ppaddr[OP_DOFILE] = pp_require_orig; eval_pv(PLC_TRUSTED,...","count":3},{"name":"api-example","value":"static void plpgsql_fulfill_promise(PLpgSQL_execstate *estate, PLpgSQL_var *var) { MemoryContext oldcontext; if (var->promise == PLPGSQL_PROMISE_NONE) return;\t\t\t\t\t/* nothing to do */ * This will typic...","count":3},{"name":"api-example","value":"static void pltcl_construct_errorCode(Tcl_Interp *interp, ErrorData *edata) { Tcl_Obj    *obj = Tcl_NewObj(); Tcl_ListObjAppendElement(interp, obj, Tcl_NewStringObj(\"POSTGRES\", -1)); Tcl_ListObjAppend...","count":3},{"name":"api-example","value":"static void pltcl_init_interp(pltcl_interp_desc *interp_desc, Oid prolang, bool pltrusted) { Tcl_Interp *interp; char\t\tinterpname[32]; * Create the Tcl interpreter subsidiary to pltcl_hold_interp. * N...","count":3},{"name":"api-example","value":"static void populate_typ_list(void) { Relation\trel; TableScanDesc scan; HeapTuple\ttup; MemoryContext old; Assert(Typ == NIL); rel = table_open(TypeRelationId, NoLock); scan = table_beginscan_catalog(r...","count":3},{"name":"api-example","value":"static void pqSaveWriteError(PGconn *conn) { * If write_err_msg is null because of previous strdup failure, do what we * can.  (It's likely our machinations here will get OOM failures as well, * but m...","count":3},{"name":"api-example","value":"static void pqTraceOutput_Bind(FILE *f, const char *message, int *cursor) { int\t\t\tnparams; fprintf(f, \"Bind\\t\"); pqTraceOutputString(f, message, cursor, false); pqTraceOutputString(f, message, cursor,...","count":3},{"name":"api-example","value":"static void pqTraceOutput_Close(FILE *f, const char *message, int *cursor) { fprintf(f, \"Close\\t\"); pqTraceOutputByte1(f, message, cursor); pqTraceOutputString(f, message, cursor, false); }","count":3},{"name":"api-example","value":"static void prepareCommand(CState *st, int command_num) { Command    *command = sql_script[st->use_file].commands[command_num]; if (command->type != SQL_COMMAND) return; if (!st->prepared) allocCState...","count":3},{"name":"api-example","value":"static void prepareCommandsInPipeline(CState *st) { int\t\t\tj; Command   **commands = sql_script[st->use_file].commands; Assert(commands[st->command]->type == META_COMMAND && commands[st->command]->meta...","count":3},{"name":"api-example","value":"static void prepare_heap_command(PQExpBuffer sql, RelationInfo *rel, PGconn *conn) { resetPQExpBuffer(sql); appendPQExpBuffer(sql, \"SELECT v.blkno, v.offnum, v.attnum, v.msg \" \"FROM pg_catalog.pg_clas...","count":3},{"name":"api-example","value":"static void preprocess_rowmarks(PlannerInfo *root) { Query\t   *parse = root->parse; Bitmapset  *rels; List\t   *prowmarks; ListCell   *l; int\t\t\ti; if (parse->rowMarks) { * We've got trouble if FOR [KEY...","count":3},{"name":"api-example","value":"static void printVersion(PGconn *con) { int\t\t\tserver_ver = PQserverVersion(con); int\t\t\tclient_ver = PG_VERSION_NUM; if (server_ver != client_ver) { const char *server_version; char\t\tsverbuf[32]; serve...","count":3},{"name":"api-example","value":"static void print_aligned_text(const printTableContent *cont, FILE *fout, bool is_pager) { bool\t\topt_tuples_only = cont->opt->tuples_only; int\t\t\tencoding = cont->opt->encoding; unsigned short opt_bord...","count":3},{"name":"api-example","value":"static void print_latex_text(const printTableContent *cont, FILE *fout) { bool\t\topt_tuples_only = cont->opt->tuples_only; unsigned short opt_border = cont->opt->border; unsigned int i; const char *con...","count":3},{"name":"api-example","value":"static void print_troff_ms_text(const printTableContent *cont, FILE *fout) { bool\t\topt_tuples_only = cont->opt->tuples_only; unsigned short opt_border = cont->opt->border; unsigned int i; const char *...","count":3},{"name":"api-example","value":"static void printtup_prepare_info(DR_printtup *myState, TupleDesc typeinfo, int numAttrs) { int16\t   *formats = myState->portal->formats; int\t\t\ti; if (myState->myinfo) pfree(myState->myinfo); myState-...","count":3},{"name":"api-example","value":"static void processEncodingEntry(ArchiveHandle *AH, TocEntry *te) { char\t   *defn = pg_strdup(te->defn); char\t   *ptr1; char\t   *ptr2 = NULL; int\t\t\tencoding; ptr1 = strchr(defn, '\\''); if (ptr1) ptr2 ...","count":3},{"name":"api-example","value":"static void process_function_rte_ref(RangeTblEntry *rte, AttrNumber attnum, find_expr_references_context *context) { int\t\t\tatts_done = 0; ListCell   *lc; * Identify which RangeTblFunction produces thi...","count":3},{"name":"api-example","value":"static void process_owned_by(Relation seqrel, List *owned_by, bool for_identity) { DependencyType deptype; int\t\t\tnnames; Relation\ttablerel; AttrNumber\tattnum; deptype = for_identity ? DEPENDENCY_INTER...","count":3},{"name":"api-example","value":"static void process_pm_pmsignal(void) { pending_pm_pmsignal = false; ereport(DEBUG2, (errmsg_internal(\"postmaster received pmsignal signal\"))); * RECOVERY_STARTED and BEGIN_HOT_STANDBY signals are ign...","count":3},{"name":"api-example","value":"static void process_pm_shutdown_request(void) { int\t\t\tmode; ereport(DEBUG2, (errmsg_internal(\"postmaster received shutdown request signal\"))); pending_pm_shutdown_request = false; * If more than one s...","count":3},{"name":"api-example","value":"static void process_queued_fetch_requests(libpq_source *src) { const char *params[3]; PGresult   *res; int\t\t\tchunkno; if (src->num_requests == 0) return; pg_log_debug(\"getting %d file chunks\", src->nu...","count":3},{"name":"api-example","value":"static void progress_report(int tablespacenum, bool force, bool finished) { int\t\t\tpercent; char\t\ttotaldone_str[32]; char\t\ttotalsize_str[32]; pg_time_t\tnow; if (!showprogress) return; now = time(NULL);...","count":3},{"name":"api-example","value":"static void progress_report(uint64 relations_total, uint64 relations_checked, uint64 relpages_total, uint64 relpages_checked, const char *datname, bool force, bool finished) { int\t\t\tpercent_rel = 0; i...","count":3},{"name":"api-example","value":"static void pullback(struct nfa *nfa, FILE *f)\t\t\t\t/* for debug output; NULL none */ { struct state *s; struct state *nexts; struct arc *a; struct arc *nexta; struct state *intermediates; int\t\t\tprogres...","count":3},{"name":"api-example","value":"static void push_old_value(struct config_generic *gconf, GucAction action) { GucStack   *stack; if (GUCNestLevel == 0) return; stack = gconf->stack; if (stack && stack->nest_level >= GUCNestLevel) { A...","count":3},{"name":"api-example","value":"static void puttzcode(const int32 val, FILE *const fp) { char\t\tbuf[4]; convert(val, buf); fwrite(buf, sizeof buf, 1, fp); }","count":3},{"name":"api-example","value":"static void read_dump_filters(const char *filename, DumpOptions *dopt) { FilterStateData fstate; char\t   *objname; FilterCommandType comtype; FilterObjectType objtype; filter_init(&fstate, filename, e...","count":3},{"name":"api-example","value":"static void rebuild_database_list(Oid newdb) { List\t   *dblist; ListCell   *cell; MemoryContext newcxt; MemoryContext oldcxt; MemoryContext tmpcxt; HASHCTL\t\thctl; int\t\t\tscore; int\t\t\tnelems; HTAB\t   *d...","count":3},{"name":"api-example","value":"static void refresh_by_heap_swap(Oid matviewOid, Oid OIDNewHeap, char relpersistence) { finish_heap_swap(matviewOid, OIDNewHeap, false, false, true, true, RecentXmin, ReadNextMultiXactId(), relpersist...","count":3},{"name":"api-example","value":"static void repairTypeFuncLoop(DumpableObject *typeobj, DumpableObject *funcobj) { TypeInfo   *typeInfo = (TypeInfo *) typeobj; removeObjectDependency(funcobj, typeobj->dumpId); if (typeInfo->shellTyp...","count":3},{"name":"api-example","value":"static void repeat(struct vars *v, struct state *lp, struct state *rp, int m, int n) { #define  SOME\t 2 #define  INF\t 3 #define  PAIR(x, y)  ((x)*4 + (y)) #define  REDUCE(x)\t ( ((x) == DUPINF) ? INF :...","count":3},{"name":"api-example","value":"static void report_triggers(ResultRelInfo *rInfo, bool show_relname, ExplainState *es) { int\t\t\tnt; if (!rInfo->ri_TrigDesc || !rInfo->ri_TrigInstrument) return; for (nt = 0; nt < rInfo->ri_TrigDesc->n...","count":3},{"name":"api-example","value":"static void resolve_anyarray_from_others(polymorphic_actuals *actuals) { if (!OidIsValid(actuals->anyelement_type)) resolve_anyelement_from_others(actuals); if (OidIsValid(actuals->anyelement_type)) {...","count":3},{"name":"api-example","value":"static void saveNodeLink(Relation index, SPPageDesc *parent, BlockNumber blkno, OffsetNumber offnum) { SpGistInnerTuple innerTuple; innerTuple = (SpGistInnerTuple) PageGetItem(parent->page, PageGetIte...","count":3},{"name":"api-example","value":"static void scanPostingTree(Relation index, GinScanEntry scanEntry, BlockNumber rootPostingTree) { GinBtreeData btree; GinBtreeStack *stack; Buffer\t\tbuffer; Page\t\tpage; stack = ginScanBeginPostingTree...","count":3},{"name":"api-example","value":"static void send_message_to_frontend(ErrorData *edata) { StringInfoData msgbuf; * We no longer support pre-3.0 FE/BE protocol, except here.  If a client * tries to connect using an older protocol vers...","count":3},{"name":"api-example","value":"static void serialize_variable(char **destptr, Size *maxbytes, struct config_generic *gconf) { if (can_skip_gucvar(gconf)) return; do_serialize(destptr, maxbytes, \"%s\", gconf->name); switch (gconf->va...","count":3},{"name":"api-example","value":"static void setNamespaceForMergeWhen(ParseState *pstate, MergeWhenClause *mergeWhenClause, Index targetRTI, Index sourceRTI) { RangeTblEntry *targetRelRTE, *sourceRelRTE; targetRelRTE = rt_fetch(targe...","count":3},{"name":"api-example","value":"static void set_append_rel_pathlist(PlannerInfo *root, RelOptInfo *rel, Index rti, RangeTblEntry *rte) { int\t\t\tparentRTindex = rti; List\t   *live_childrels = NIL; ListCell   *l; * Generate access path...","count":3},{"name":"api-example","value":"static void set_extra_field(struct config_generic *gconf, void **field, void *newval) { void\t   *oldval = *field; *field = newval; if (oldval && !extra_field_used(gconf, oldval)) guc_free(oldval); }","count":3},{"name":"api-example","value":"static void set_interp_require(bool trusted) { if (trusted) { PL_ppaddr[OP_REQUIRE] = pp_require_safe; PL_ppaddr[OP_DOFILE] = pp_require_safe; } else { PL_ppaddr[OP_REQUIRE] = pp_require_orig; PL_ppad...","count":3},{"name":"api-example","value":"static void set_mode(char *modeopt) { if (strcmp(modeopt, \"s\") == 0 || strcmp(modeopt, \"smart\") == 0) { shutdown_mode = SMART_MODE; sig = SIGTERM; } else if (strcmp(modeopt, \"f\") == 0 || strcmp(modeop...","count":3},{"name":"api-example","value":"static void set_plain_rel_pathlist(PlannerInfo *root, RelOptInfo *rel, RangeTblEntry *rte) { Relids\t\trequired_outer; * We don't support pushing join clauses into the quals of a seqscan, but * it could...","count":3},{"name":"api-example","value":"static void set_plain_rel_size(PlannerInfo *root, RelOptInfo *rel, RangeTblEntry *rte) { * Test any partial indexes of rel for applicability.  We must do this * first since partial unique indexes can ...","count":3},{"name":"api-example","value":"static void set_rel_consider_parallel(PlannerInfo *root, RelOptInfo *rel, RangeTblEntry *rte) { * The flag has previously been initialized to false, so we can just * return if it becomes clear that we...","count":3},{"name":"api-example","value":"static void set_rel_size(PlannerInfo *root, RelOptInfo *rel, Index rti, RangeTblEntry *rte) { if (rel->reloptkind == RELOPT_BASEREL && relation_excluded_by_constraints(root, rel, rte)) { * We proved w...","count":3},{"name":"api-example","value":"static void set_tablesample_rel_pathlist(PlannerInfo *root, RelOptInfo *rel, RangeTblEntry *rte) { Relids\t\trequired_outer; Path\t   *path; * We don't support pushing join clauses into the quals of a sa...","count":3},{"name":"api-example","value":"static void set_upper_references(PlannerInfo *root, Plan *plan, int rtoffset) { Plan\t   *subplan = plan->lefttree; indexed_tlist *subplan_itlist; List\t   *output_targetlist; ListCell   *l; subplan_itl...","count":3},{"name":"api-example","value":"static void setup_schema(FILE *cmdfd) { setup_run_file(cmdfd, info_schema_file); PG_CMD_PRINTF(\"UPDATE information_schema.sql_implementation_info \" \"  SET character_value = '%s' \" \"  WHERE implementat...","count":3},{"name":"api-example","value":"static void shdepChangeDep(Relation sdepRel, Oid classid, Oid objid, int32 objsubid, Oid refclassid, Oid refobjid, SharedDependencyType deptype) { Oid\t\t\tdbid = classIdGetDbId(classid); HeapTuple\toldtu...","count":3},{"name":"api-example","value":"static void shdepReassignOwned_Owner(Form_pg_shdepend sdepForm, Oid newrole) { switch (sdepForm->classid) { case TypeRelationId: AlterTypeOwner_oid(sdepForm->objid, newrole, true); break; case Namespa...","count":3},{"name":"api-example","value":"static void show_grouping_set_keys(PlanState *planstate, Agg *aggnode, Sort *sortnode, List *context, bool useprefix, List *ancestors, ExplainState *es) { Plan\t   *plan = planstate->plan; char\t   *exp...","count":3},{"name":"api-example","value":"static void show_sort_info(SortState *sortstate, ExplainState *es) { if (!es->analyze) return; if (sortstate->sort_Done && sortstate->tuplesortstate != NULL) { Tuplesortstate *state = (Tuplesortstate ...","count":3},{"name":"api-example","value":"static void show_sort_keys(SortState *sortstate, List *ancestors, ExplainState *es) { Sort\t   *plan = (Sort *) sortstate->ss.ps.plan; show_sort_group_keys((PlanState *) sortstate, \"Sort Key\", plan->nu...","count":3},{"name":"api-example","value":"static void slotsync_worker_onexit(int code, Datum arg) { * We need to do slots cleanup here just like WalSndErrorCleanup() does. * * The startup process during promotion invokes ShutDownSlotSync() wh...","count":3},{"name":"api-example","value":"static void spgRedoAddLeaf(XLogReaderState *record) { XLogRecPtr\tlsn = record->EndRecPtr; char\t   *ptr = XLogRecGetData(record); spgxlogAddLeaf *xldata = (spgxlogAddLeaf *) ptr; char\t   *leafTuple; Sp...","count":3},{"name":"api-example","value":"static void spgvacuumscan(spgBulkDeleteState *bds) { Relation\tindex = bds->info->index; bool\t\tneedLock; BlockNumber num_pages, blkno; initSpGistState(&bds->spgstate, index); bds->pendingList = NULL; b...","count":3},{"name":"api-example","value":"static void standard_qp_callback(PlannerInfo *root, void *extra) { Query\t   *parse = root->parse; standard_qp_extra *qp_extra = (standard_qp_extra *) extra; List\t   *tlist = root->processed_tlist; Lis...","count":3},{"name":"api-example","value":"static void start_xact_command(void) { if (!xact_started) { StartTransactionCommand(); xact_started = true; } * Start statement timeout if necessary.  Note that this'll intentionally * not reset the c...","count":3},{"name":"api-example","value":"static void sts_flush_chunk(SharedTuplestoreAccessor *accessor) { size_t\t\tsize; size = STS_CHUNK_PAGES * BLCKSZ; BufFileWrite(accessor->write_file, accessor->write_chunk, size); memset(accessor->write...","count":3},{"name":"api-example","value":"static void subcoloronechr(struct vars *v, chr ch, struct state *lp, struct state *rp, color *lastsubcolor) { struct colormap *cm = v->cm; colormaprange *newranges; int\t\t\tnumnewranges; colormaprange *...","count":3},{"name":"api-example","value":"static void subquery_push_qual(Query *subquery, RangeTblEntry *rte, Index rti, Node *qual) { if (subquery->setOperations != NULL) { recurse_push_qual(subquery->setOperations, subquery, rte, rti, qual)...","count":3},{"name":"api-example","value":"static void summarize_range(IndexInfo *indexInfo, BrinBuildState *state, Relation heapRel, BlockNumber heapBlk, BlockNumber heapNumBlks) { Buffer\t\tphbuf; BrinTuple  *phtup; Size\t\tphsz; OffsetNumber of...","count":3},{"name":"api-example","value":"static void test_open_syncs(void) { printf(_(\"\\nCompare open_sync with different write sizes:\\n\")); printf(_(\"(This is designed to compare the cost of writing 16kB in different write\\n\" \"open_sync siz...","count":3},{"name":"api-example","value":"static void text_format_string_conversion(StringInfo buf, char conversion, FmgrInfo *typOutputInfo, Datum value, bool isNull, int flags, int width) { char\t   *str; if (isNull) { if (conversion == 's')...","count":3},{"name":"api-example","value":"static void thesaurusRead(const char *filename, DictThesaurus *d) { tsearch_readline_state trst; uint32\t\tidsubst = 0; bool\t\tuseasis = false; char\t   *line; filename = get_tsearch_config_filename(filen...","count":3},{"name":"api-example","value":"static void throttle(bbsink_throttle *sink, size_t increment) { TimeOffset\telapsed_min; Assert(sink->throttling_counter >= 0); sink->throttling_counter += increment; if (sink->throttling_counter < sin...","count":3},{"name":"api-example","value":"static void transformLockingClause(ParseState *pstate, Query *qry, LockingClause *lc, bool pushedDown) { List\t   *lockedRels = lc->lockedRels; ListCell   *l; ListCell   *rt; Index\t\ti; LockingClause *a...","count":3},{"name":"api-example","value":"static void trapsig(SIGNAL_ARGS) { pqsignal(postgres_signal_arg, trapsig); caught_signal = true; }","count":3},{"name":"api-example","value":"static void try_nestloop_path(PlannerInfo *root, RelOptInfo *joinrel, Path *outer_path, Path *inner_path, List *pathkeys, JoinType jointype, JoinPathExtraData *extra) { Relids\t\trequired_outer; JoinCos...","count":3},{"name":"api-example","value":"static void try_partitionwise_join(PlannerInfo *root, RelOptInfo *rel1, RelOptInfo *rel2, RelOptInfo *joinrel, SpecialJoinInfo *parent_sjinfo, List *parent_restrictlist) { bool\t\trel1_is_simple = IS_SI...","count":3},{"name":"api-example","value":"static void tstoreStartupReceiver(DestReceiver *self, int operation, TupleDesc typeinfo) { TStoreState *myState = (TStoreState *) self; bool\t\tneedtoast = false; int\t\t\tnatts = typeinfo->natts; int\t\t\ti;...","count":3},{"name":"api-example","value":"static void tts_minimal_clear(TupleTableSlot *slot) { MinimalTupleTableSlot *mslot = (MinimalTupleTableSlot *) slot; if (TTS_SHOULDFREE(slot)) { heap_free_minimal_tuple(mslot->mintuple); slot->tts_fla...","count":3},{"name":"api-example","value":"static void tts_minimal_materialize(TupleTableSlot *slot) { MinimalTupleTableSlot *mslot = (MinimalTupleTableSlot *) slot; MemoryContext oldContext; Assert(!TTS_EMPTY(slot)); if (TTS_SHOULDFREE(slot))...","count":3},{"name":"api-example","value":"static void tts_virtual_materialize(TupleTableSlot *slot) { VirtualTupleTableSlot *vslot = (VirtualTupleTableSlot *) slot; TupleDesc\tdesc = slot->tts_tupleDescriptor; Size\t\tsz = 0; char\t   *data; if (...","count":3},{"name":"api-example","value":"static void union_tuples(BrinDesc *bdesc, BrinMemTuple *a, BrinTuple *b) { int\t\t\tkeyno; BrinMemTuple *db; MemoryContext cxt; MemoryContext oldcxt; cxt = AllocSetContextCreate(CurrentMemoryContext, \"br...","count":3},{"name":"api-example","value":"static void update_attstats(Oid relid, bool inh, int natts, VacAttrStats **vacattrstats) { Relation\tsd; int\t\t\tattno; CatalogIndexState indstate = NULL; if (natts <= 0) return;\t\t\t\t\t/* nothing to do */ ...","count":3},{"name":"api-example","value":"static void update_frameheadpos(WindowAggState *winstate) { WindowAgg  *node = (WindowAgg *) winstate->ss.ps.plan; int\t\t\tframeOptions = winstate->frameOptions; MemoryContext oldcontext; if (winstate->...","count":3},{"name":"api-example","value":"static void update_progress_txn_cb_wrapper(ReorderBuffer *cache, ReorderBufferTXN *txn, XLogRecPtr lsn) { LogicalDecodingContext *ctx = cache->private_data; LogicalErrorCallbackState state; ErrorConte...","count":3},{"name":"api-example","value":"static void usage(FILE *stream, int status) { fprintf(stream, _(\"%s: usage is %s [ --version ] [ --help ] [ -v ] [ -P ] \\\\\\n\" \"\\t[ -b {slim|fat} ] [ -d directory ] [ -l localtime ]\" \" [ -L leapseconds...","count":3},{"name":"api-example","value":"static void validateRecoveryParameters(void) { if (!ArchiveRecoveryRequested) return; * Check for compulsory parameters */ if (StandbyModeRequested) { if ((PrimaryConnInfo == NULL || strcmp(PrimaryCon...","count":3},{"name":"api-example","value":"static void verify_backup_directory(verifier_context *context, char *relpath, char *fullpath) { DIR\t\t   *dir; struct dirent *dirent; dir = opendir(fullpath); if (dir == NULL) { * If even the toplevel ...","count":3},{"name":"api-example","value":"static void writeNodeArray(StringInfo str, const Node *const *arr, int len) { if (arr != NULL) { appendStringInfoChar(str, '('); for (int i = 0; i < len; i++) { appendStringInfoChar(str, ' '); outNode...","count":3},{"name":"api-example","value":"static void write_console(const char *line, int len) { int\t\t\trc; #ifdef WIN32 * Try to convert the message to UTF16 and write it with WriteConsoleW(). * Fall back on write() if anything fails. * * In ...","count":3},{"name":"api-example","value":"static void write_multirange_data(MultirangeType *multirange, TypeCacheEntry *rangetyp, int32 range_count, RangeType **ranges) { uint32\t   *items; uint32\t\tprev_offset = 0; uint8\t   *flags; int32\t\ti; P...","count":3},{"name":"api-example","value":"static void write_relcache_init_file(bool shared) { FILE\t   *fp; char\t\ttempfilename[MAXPGPATH]; char\t\tfinalfilename[MAXPGPATH]; int\t\t\tmagic; HASH_SEQ_STATUS status; RelIdCacheEnt *idhentry; int\t\t\ti; *...","count":3},{"name":"api-example","value":"static void writetup_heap(Tuplesortstate *state, LogicalTape *tape, SortTuple *stup) { TuplesortPublic *base = TuplesortstateGetPublic(state); MinimalTuple tuple = (MinimalTuple) stup->tuple; char\t   ...","count":3},{"name":"api-example","value":"static void xact_desc_abort(StringInfo buf, uint8 info, xl_xact_abort *xlrec, RepOriginId origin_id) { xl_xact_parsed_abort parsed; ParseAbortRecord(info, xlrec, &parsed); if (TransactionIdIsValid(par...","count":3},{"name":"api-example","value":"static void zaptreesubs(struct vars *v, struct subre *t) { int\t\t\tn = t->capno; struct subre *t2; if (n > 0) { if ((size_t) n < v->nmatch) { v->pmatch[n].rm_so = -1; v->pmatch[n].rm_eo = -1; } } for (t...","count":3},{"name":"api-example","value":"static zic_t gethms(char const *string, char const *errstring) { int\t\t\thh; int\t\t\tsign, mm = 0, ss = 0; char\t\thhx, mmx, ssx, xr = '0', xs; int\t\t\ttenths = 0; bool\t\tok = true; if (string == NULL || *stri...","count":3},{"name":"api-example","value":"static zic_t rpytime(const struct rule *rp, zic_t wantedy) { int\t\t\tm, i; zic_t\t\tdayoff;\t\t\t/* with a nod to Margaret O. */ zic_t\t\tt, y; if (wantedy == ZIC_MIN) return min_time; if (wantedy == ZIC_MAX) ...","count":3},{"name":"api-example","value":"struct config_generic * find_option(const char *name, bool create_placeholders, bool skip_errors, int elevel) { GUCHashEntry *hentry; int\t\t\ti; Assert(name); hentry = (GUCHashEntry *) hash_search(guc_h...","count":3},{"name":"api-example","value":"struct descriptor * lookup_descriptor(char *name, char *connection) { struct descriptor *i; if (name[0] != '\"') return NULL; for (i = descriptors; i; i = i->next) { if (strcmp(name, i->name) == 0) { i...","count":3},{"name":"api-example","value":"struct dirent * ReadDirExtended(DIR *dir, const char *dirname, int elevel) { struct dirent *dent; if (dir == NULL) { ereport(elevel, (errcode_for_file_access(), errmsg(\"could not open directory \\\"%s\\\"...","count":3},{"name":"api-example","value":"struct lconv * PGLC_localeconv(void) { static struct lconv CurrentLocaleConv; static bool CurrentLocaleConvAllocated = false; struct lconv *extlconv; struct lconv worklconv; char\t   *save_lc_monetary;...","count":3},{"name":"api-example","value":"struct varlena * pglz_compress_datum(const struct varlena *value) { int32\t\tvalsize, len; struct varlena *tmp = NULL; valsize = VARSIZE_ANY_EXHDR(value); * No point in wasting a palloc cycle if value s...","count":3},{"name":"api-example","value":"uint32 BufTableHashCode(BufferTag *tagPtr) { return get_hash_value(SharedBufHash, (void *) tagPtr); }","count":3},{"name":"api-example","value":"uint32 LockBufHdr(BufferDesc *desc) { SpinDelayStatus delayStatus; uint32\t\told_buf_state; Assert(!BufferIsLocal(BufferDescriptorGetBuffer(desc))); init_local_spin_delay(&delayStatus); while (true) { o...","count":3},{"name":"api-example","value":"uint32 WaitEventExtensionNew(const char *wait_event_name) { return WaitEventCustomNew(PG_WAIT_EXTENSION, wait_event_name); }","count":3},{"name":"api-example","value":"uint32 _hash_spareindex(uint32 num_bucket) { uint32\t\tsplitpoint_group; uint32\t\tsplitpoint_phases; splitpoint_group = pg_ceil_log2_32(num_bucket); if (splitpoint_group < HASH_SPLITPOINT_GROUPS_WITH_ONE...","count":3},{"name":"api-example","value":"uint32 getJsonbLength(const JsonbContainer *jc, int index) { uint32\t\toff; uint32\t\tlen; * If the length is stored directly in the JEntry, just return it. * Otherwise, get the begin offset of the entry,...","count":3},{"name":"api-example","value":"uint32 getJsonbOffset(const JsonbContainer *jc, int index) { uint32\t\toffset = 0; int\t\t\ti; * Start offset of this entry is equal to the end offset of the previous * entry.  Walk backwards to the most r...","count":3},{"name":"api-example","value":"uint32 hashRowType(TupleDesc desc) { uint32\t\ts; int\t\t\ti; s = hash_combine(0, hash_uint32(desc->natts)); s = hash_combine(s, hash_uint32(desc->tdtypeid)); for (i = 0; i < desc->natts; ++i) s = hash_com...","count":3},{"name":"api-example","value":"uint32 hash_bytes(const unsigned char *k, int keylen) { uint32\t\ta, b, c, len; len = keylen; a = b = c = 0x9e3779b9 + len + 3923095; if (((uintptr_t) k & UINT32_ALIGN_MASK) == 0) { const uint32 *ka = (...","count":3},{"name":"api-example","value":"uint64 pg_prng_uint64(pg_prng_state *state) { return xoroshiro128ss(state); }","count":3},{"name":"api-example","value":"void * ShmemInitStruct(const char *name, Size size, bool *foundPtr) { ShmemIndexEnt *result; void\t   *structPtr; LWLockAcquire(ShmemIndexLock, LW_EXCLUSIVE); if (!ShmemIndex) { PGShmemHeader *shmemseg...","count":3},{"name":"api-example","value":"void * hash_search_with_hash_value(HTAB *hashp, const void *keyPtr, uint32 hashvalue, HASHACTION action, bool *foundPtr) { HASHHDR    *hctl = hashp->hctl; int\t\t\tfreelist_idx = FREELIST_IDX(hctl, hashv...","count":3},{"name":"api-example","value":"void * nodeRead(const char *token, int tok_len) { Node\t   *result; NodeTag\t\ttype; if (token == NULL)\t\t\t/* need to read a token? */ { token = pg_strtok(&tok_len); if (token == NULL)\t\t/* end of input */...","count":3},{"name":"api-example","value":"void * pg_malloc(size_t size) { return pg_malloc_internal(size, 0); }","count":3},{"name":"api-example","value":"void AlterTable(AlterTableStmt *stmt, LOCKMODE lockmode, AlterTableUtilityContext *context) { Relation\trel; rel = relation_open(context->relid, NoLock); CheckAlterTableIsSafe(rel); ATController(stmt, ...","count":3},{"name":"api-example","value":"void AppendIncrementalManifestData(IncrementalBackupInfo *ib, const char *data, int len) { MemoryContext oldcontext; oldcontext = MemoryContextSwitchTo(ib->mcxt); if (ib->buf.len > MIN_CHUNK && ib->bu...","count":3},{"name":"api-example","value":"void AssignDumpId(DumpableObject *dobj) { dobj->dumpId = ++lastDumpId; dobj->name = NULL;\t\t\t/* must be set later */ dobj->namespace = NULL;\t\t/* may be set later */ dobj->dump = DUMP_COMPONENT_ALL;\t/* ...","count":3},{"name":"api-example","value":"void AtEOSubXact_SPI(bool isCommit, SubTransactionId mySubid) { bool\t\tfound = false; while (_SPI_connected >= 0) { _SPI_connection *connection = &(_SPI_stack[_SPI_connected]); if (connection->connectS...","count":3},{"name":"api-example","value":"void AtPrepare_MultiXact(void) { MultiXactId myOldestMember = OldestMemberMXactId[MyProcNumber]; if (MultiXactIdIsValid(myOldestMember)) RegisterTwoPhaseRecord(TWOPHASE_RM_MULTIXACT_ID, 0, &myOldestMe...","count":3},{"name":"api-example","value":"void AttachSession(dsm_handle handle) { dsm_segment *seg; shm_toc    *toc; void\t   *dsa_space; void\t   *typmod_registry_space; dsa_area   *dsa; MemoryContext old_context; old_context = MemoryContextSw...","count":3},{"name":"api-example","value":"void AuxiliaryProcessMainCommon(void) { Assert(IsUnderPostmaster); if (PostmasterContext) { MemoryContextDelete(PostmasterContext); PostmasterContext = NULL; } init_ps_display(NULL); SetProcessingMode...","count":3},{"name":"api-example","value":"void BTreeShmemInit(void) { bool\t\tfound; btvacinfo = (BTVacInfo *) ShmemInitStruct(\"BTree Vacuum State\", BTreeShmemSize(), &found); if (!IsUnderPostmaster) { Assert(!found); * It doesn't really matter...","count":3},{"name":"api-example","value":"void BackgroundWorkerStateChange(bool allow_new_workers) { int\t\t\tslotno; * The total number of slots stored in shared memory should match our * notion of max_worker_processes.  If it does not, somethi...","count":3},{"name":"api-example","value":"void BackgroundWriterMain(char *startup_data, size_t startup_data_len) { sigjmp_buf\tlocal_sigjmp_buf; MemoryContext bgwriter_context; bool\t\tprev_hibernate; WritebackContext wb_context; Assert(startup_...","count":3},{"name":"api-example","value":"void BootStrapCLOG(void) { int\t\t\tslotno; LWLock\t   *lock = SimpleLruGetBankLock(XactCtl, 0); LWLockAcquire(lock, LW_EXCLUSIVE); slotno = ZeroCLOGPage(0, false); SimpleLruWritePage(XactCtl, slotno); As...","count":3},{"name":"api-example","value":"void CacheInvalidateHeapTuple(Relation relation, HeapTuple tuple, HeapTuple newtuple) { Oid\t\t\ttupleRelId; Oid\t\t\tdatabaseId; Oid\t\t\trelationId; if (IsBootstrapProcessingMode()) return; * We only need to...","count":3},{"name":"api-example","value":"void CatCacheInvalidate(CatCache *cache, uint32 hashValue) { Index\t\thashIndex; dlist_mutable_iter iter; CACHE_elog(DEBUG2, \"CatCacheInvalidate: called\"); * We don't bother to check whether the cache h...","count":3},{"name":"api-example","value":"void CatalogCloseIndexes(CatalogIndexState indstate) { ExecCloseIndices(indstate); pfree(indstate); }","count":3},{"name":"api-example","value":"void CatalogTupleInsert(Relation heapRel, HeapTuple tup) { CatalogIndexState indstate; CatalogTupleCheckConstraints(heapRel, tup); indstate = CatalogOpenIndexes(heapRel); simple_heap_insert(heapRel, t...","count":3},{"name":"api-example","value":"void ChangeToDataDir(void) { Assert(DataDir); if (chdir(DataDir) < 0) ereport(FATAL, (errcode_for_file_access(), errmsg(\"could not change directory to \\\"%s\\\": %m\", DataDir))); }","count":3},{"name":"api-example","value":"void CheckCmdReplicaIdentity(Relation rel, CmdType cmd) { PublicationDesc pubdesc; * Skip checking the replica identity for partitioned tables, because the * operations are actually performed on the l...","count":3},{"name":"api-example","value":"void CheckForSerializableConflictOut(Relation relation, TransactionId xid, Snapshot snapshot) { SERIALIZABLEXIDTAG sxidtag; SERIALIZABLEXID *sxid; SERIALIZABLEXACT *sxact; if (!SerializationNeededForR...","count":3},{"name":"api-example","value":"void CheckPointCLOG(void) { * Write dirty CLOG pages to disk.  This may result in sync requests * queued for later handling by ProcessSyncRequests(), as part of the * checkpoint. */ TRACE_POSTGRESQL_C...","count":3},{"name":"api-example","value":"void CloseArchive(Archive *AHX) { ArchiveHandle *AH = (ArchiveHandle *) AHX; AH->ClosePtr(AH); errno = 0; if (!EndCompressFileHandle(AH->OF)) pg_fatal(\"could not close output file: %m\"); }","count":3},{"name":"api-example","value":"void CompleteCachedPlan(CachedPlanSource *plansource, List *querytree_list, MemoryContext querytree_context, Oid *param_types, int num_params, ParserSetupHook parserSetup, void *parserSetupArg, int cu...","count":3},{"name":"api-example","value":"void ConditionVariableSignal(ConditionVariable *cv) { PGPROC\t   *proc = NULL; SpinLockAcquire(&cv->mutex); if (!proclist_is_empty(&cv->wakeup)) proc = proclist_pop_head_node(&cv->wakeup, cvWaitLink); ...","count":3},{"name":"api-example","value":"void DebugFileOpen(void) { int\t\t\tfd, istty; if (OutputFileName[0]) { * A debug-output file name was given. * * Make sure we can write the file, and find out if it's a tty. */ if ((fd = open(OutputFile...","count":3},{"name":"api-example","value":"void DecodingContextFindStartpoint(LogicalDecodingContext *ctx) { ReplicationSlot *slot = ctx->slot; XLogBeginRead(ctx->reader, slot->data.restart_lsn); elog(DEBUG1, \"searching for logical decoding st...","count":3},{"name":"api-example","value":"void DisconnectDatabase(Archive *AHX) { ArchiveHandle *AH = (ArchiveHandle *) AHX; char\t\terrbuf[1]; if (!AH->connection) return; if (AH->connCancel) { * If we have an active query, send a cancel befor...","count":3},{"name":"api-example","value":"void DropSubscription(DropSubscriptionStmt *stmt, bool isTopLevel) { Relation\trel; ObjectAddress myself; HeapTuple\ttup; Oid\t\t\tsubid; Oid\t\t\tsubowner; Datum\t\tdatum; bool\t\tisnull; char\t   *subname; char\t...","count":3},{"name":"api-example","value":"void ECPG_informix_reset_sqlca(void) { struct sqlca_t *sqlca = ECPGget_sqlca(); if (sqlca == NULL) return; memcpy((char *) sqlca, (char *) &sqlca_init, sizeof(struct sqlca_t)); }","count":3},{"name":"api-example","value":"void EncodeDateTime(struct tm *tm, fsec_t fsec, bool print_tz, int tz, const char *tzn, int style, char *str, bool EuroDates) { int\t\t\tday, hour, min; * Negative tm_isdst means we have no valid time zo...","count":3},{"name":"api-example","value":"void EncodeTimeOnly(struct pg_tm *tm, fsec_t fsec, bool print_tz, int tz, int style, char *str) { str = pg_ultostr_zeropad(str, tm->tm_hour, 2); *str++ = ':'; str = pg_ultostr_zeropad(str, tm->tm_min,...","count":3},{"name":"api-example","value":"void EndRestoreLO(ArchiveHandle *AH, Oid oid) { if (AH->lo_buf_used > 0) { dump_lo_buf(AH); } AH->writingLO = false; if (AH->connection) { lo_close(AH->connection, AH->loFd); AH->loFd = -1; } else { a...","count":3},{"name":"api-example","value":"void EvalPlanQualSetPlan(EPQState *epqstate, Plan *subplan, List *auxrowmarks) { EvalPlanQualEnd(epqstate); epqstate->plan = subplan; epqstate->arowMarks = auxrowmarks; }","count":3},{"name":"api-example","value":"void EventTriggerSQLDrop(Node *parsetree) { List\t   *runlist; EventTriggerData trigdata; * See EventTriggerDDLCommandStart for a discussion about why event * triggers are disabled in single user mode ...","count":3},{"name":"api-example","value":"void EventTriggerSQLDropAddObject(const ObjectAddress *object, bool original, bool normal) { SQLDropObject *obj; MemoryContext oldcxt; if (!currentEventTriggerState) return; Assert(EventTriggerSupport...","count":3},{"name":"api-example","value":"void ExecASInsertTriggers(EState *estate, ResultRelInfo *relinfo, TransitionCaptureState *transition_capture) { TriggerDesc *trigdesc = relinfo->ri_TrigDesc; if (trigdesc && trigdesc->trig_insert_afte...","count":3},{"name":"api-example","value":"void ExecAlterDefaultPrivilegesStmt(ParseState *pstate, AlterDefaultPrivilegesStmt *stmt) { GrantStmt  *action = stmt->action; InternalDefaultACL iacls; ListCell   *cell; List\t   *rolespecs = NIL; Lis...","count":3},{"name":"api-example","value":"void ExecAsyncRequest(AsyncRequest *areq) { if (areq->requestee->chgParam != NULL)\t/* something changed? */ ExecReScan(areq->requestee);\t/* let ReScan handle this */ if (areq->requestee->instrument) I...","count":3},{"name":"api-example","value":"void ExecBSDeleteTriggers(EState *estate, ResultRelInfo *relinfo) { TriggerDesc *trigdesc; int\t\t\ti; TriggerData LocTriggerData = {0}; trigdesc = relinfo->ri_TrigDesc; if (trigdesc == NULL) return; if ...","count":3},{"name":"api-example","value":"void ExecConditionalAssignProjectionInfo(PlanState *planstate, TupleDesc inputDesc, int varno) { if (tlist_matches_tupdesc(planstate, planstate->plan->targetlist, varno, inputDesc)) { planstate->ps_Pr...","count":3},{"name":"api-example","value":"void ExecCreateScanSlotFromOuterPlan(EState *estate, ScanState *scanstate, const TupleTableSlotOps *tts_ops) { PlanState  *outerPlan; TupleDesc\ttupDesc; outerPlan = outerPlanState(scanstate); tupDesc ...","count":3},{"name":"api-example","value":"void ExecEvalAggOrderedTransTuple(ExprState *state, ExprEvalStep *op, ExprContext *econtext) { AggStatePerTrans pertrans = op->d.agg_trans.pertrans; int\t\t\tsetno = op->d.agg_trans.setno; ExecClearTuple...","count":3},{"name":"api-example","value":"void ExecEvalFieldSelect(ExprState *state, ExprEvalStep *op, ExprContext *econtext) { AttrNumber\tfieldnum = op->d.fieldselect.fieldnum; Datum\t\ttupDatum; HeapTupleHeader tuple; Oid\t\t\ttupType; int32\t\ttu...","count":3},{"name":"api-example","value":"void ExecEvalWholeRowVar(ExprState *state, ExprEvalStep *op, ExprContext *econtext) { Var\t\t   *variable = op->d.wholerow.var; TupleTableSlot *slot; TupleDesc\toutput_tupdesc; MemoryContext oldcontext; ...","count":3},{"name":"api-example","value":"void ExecEvalXmlExpr(ExprState *state, ExprEvalStep *op) { XmlExpr    *xexpr = op->d.xmlexpr.xexpr; Datum\t\tvalue; *op->resnull = true;\t\t/* until we get a result */ *op->resvalue = (Datum) 0; switch (x...","count":3},{"name":"api-example","value":"void ExecHashTableInsert(HashJoinTable hashtable, TupleTableSlot *slot, uint32 hashvalue) { bool\t\tshouldFree; MinimalTuple tuple = ExecFetchSlotMinimalTuple(slot, &shouldFree); int\t\t\tbucketno; int\t\t\tb...","count":3},{"name":"api-example","value":"void ExecInitResultSlot(PlanState *planstate, const TupleTableSlotOps *tts_ops) { TupleTableSlot *slot; slot = ExecAllocTableSlot(&planstate->state->es_tupleTable, planstate->ps_ResultTupleDesc, tts_o...","count":3},{"name":"api-example","value":"void ExecInitResultTupleSlotTL(PlanState *planstate, const TupleTableSlotOps *tts_ops) { ExecInitResultTypeTL(planstate); ExecInitResultSlot(planstate, tts_ops); }","count":3},{"name":"api-example","value":"void ExecInitResultTypeTL(PlanState *planstate) { TupleDesc\ttupDesc = ExecTypeFromTL(planstate->plan->targetlist); planstate->ps_ResultTupleDesc = tupDesc; }","count":3},{"name":"api-example","value":"void ExecReScanBitmapHeapScan(BitmapHeapScanState *node) { PlanState  *outerPlan = outerPlanState(node); if (node->ss.ss_currentScanDesc) table_rescan(node->ss.ss_currentScanDesc, NULL); if (node->tbm...","count":3},{"name":"api-example","value":"void ExecReScanMemoize(MemoizeState *node) { PlanState  *outerPlan = outerPlanState(node); node->mstatus = MEMO_CACHE_LOOKUP; node->entry = NULL; node->last_tuple = NULL; * if chgParam of subnode is n...","count":3},{"name":"api-example","value":"void ExecReScanSort(SortState *node) { PlanState  *outerPlan = outerPlanState(node); * If we haven't sorted yet, just return. If outerplan's chgParam is not * NULL then it will be re-scanned by ExecPr...","count":3},{"name":"api-example","value":"void ExecReindex(ParseState *pstate, const ReindexStmt *stmt, bool isTopLevel) { ReindexParams params = {0}; ListCell   *lc; bool\t\tconcurrently = false; bool\t\tverbose = false; char\t   *tablespacename ...","count":3},{"name":"api-example","value":"void ExecSimpleRelationUpdate(ResultRelInfo *resultRelInfo, EState *estate, EPQState *epqstate, TupleTableSlot *searchslot, TupleTableSlot *slot) { bool\t\tskip_tuple = false; Relation\trel = resultRelIn...","count":3},{"name":"api-example","value":"void ExecutorStart(QueryDesc *queryDesc, int eflags) { * In some cases (e.g. an EXECUTE statement or an execute message with the * extended query protocol) the query_id won't be reported, so do it now...","count":3},{"name":"api-example","value":"void ExplainExecuteQuery(ExecuteStmt *execstmt, IntoClause *into, ExplainState *es, const char *queryString, ParamListInfo params, QueryEnvironment *queryEnv) { PreparedStatement *entry; const char *q...","count":3},{"name":"api-example","value":"void ExplainOpenGroup(const char *objtype, const char *labelname, bool labeled, ExplainState *es) { switch (es->format) { case EXPLAIN_FORMAT_TEXT: break; case EXPLAIN_FORMAT_XML: ExplainXMLTag(objtyp...","count":3},{"name":"api-example","value":"void ExplainPropertyText(const char *qlabel, const char *value, ExplainState *es) { ExplainProperty(qlabel, NULL, value, false, es); }","count":3},{"name":"api-example","value":"void FileWriteback(File file, off_t offset, off_t nbytes, uint32 wait_event_info) { int\t\t\treturnCode; Assert(FileIsValid(file)); DO_DB(elog(LOG, \"FileWriteback: %d (%s) \" INT64_FORMAT \" \" INT64_FORMAT...","count":3},{"name":"api-example","value":"void FinishPreparedTransaction(const char *gid, bool isCommit) { GlobalTransaction gxact; PGPROC\t   *proc; TransactionId xid; bool\t\tondisk; char\t   *buf; char\t   *bufptr; TwoPhaseFileHeader *hdr; Tran...","count":3},{"name":"api-example","value":"void GinDataPageAddPostingItem(Page page, PostingItem *data, OffsetNumber offset) { OffsetNumber maxoff = GinPageGetOpaque(page)->maxoff; char\t   *ptr; Assert(PostingItemGetBlockNumber(data) != Invali...","count":3},{"name":"api-example","value":"void GinInitBuffer(Buffer b, uint32 f) { GinInitPage(BufferGetPage(b), f, BufferGetPageSize(b)); }","count":3},{"name":"api-example","value":"void HandleFunctionRequest(StringInfo msgBuf) { LOCAL_FCINFO(fcinfo, FUNC_MAX_ARGS); Oid\t\t\tfid; AclResult\taclresult; int16\t\trformat; Datum\t\tretval; struct fp_info my_fp; struct fp_info *fip; bool\t\tcal...","count":3},{"name":"api-example","value":"void HandleParallelMessageInterrupt(void) { InterruptPending = true; ParallelMessagePending = true; SetLatch(MyLatch); }","count":3},{"name":"api-example","value":"void HeapTupleSetHintBits(HeapTupleHeader tuple, Buffer buffer, uint16 infomask, TransactionId xid) { SetHintBits(tuple, buffer, infomask, xid); }","count":3},{"name":"api-example","value":"void IncrTupleDescRefCount(TupleDesc tupdesc) { Assert(tupdesc->tdrefcount >= 0); ResourceOwnerEnlarge(CurrentResourceOwner); tupdesc->tdrefcount++; ResourceOwnerRememberTupleDesc(CurrentResourceOwner...","count":3},{"name":"api-example","value":"void InitArchiveFmt_Custom(ArchiveHandle *AH) { lclContext *ctx; AH->ArchiveEntryPtr = _ArchiveEntry; AH->StartDataPtr = _StartData; AH->WriteDataPtr = _WriteData; AH->EndDataPtr = _EndData; AH->Write...","count":3},{"name":"api-example","value":"void InitArchiveFmt_Directory(ArchiveHandle *AH) { lclContext *ctx; AH->ArchiveEntryPtr = _ArchiveEntry; AH->StartDataPtr = _StartData; AH->WriteDataPtr = _WriteData; AH->EndDataPtr = _EndData; AH->Wr...","count":3},{"name":"api-example","value":"void InitCatCachePhase2(CatCache *cache, bool touch_index) { if (cache->cc_tupdesc == NULL) CatalogCacheInitializeCache(cache); if (touch_index && cache->id != AMOID && cache->id != AMNAME) { Relation...","count":3},{"name":"api-example","value":"void InitProcessGlobals(void) { MyStartTimestamp = GetCurrentTimestamp(); MyStartTime = timestamptz_to_time_t(MyStartTimestamp); * Set a different global seed in every process.  We want something * un...","count":3},{"name":"api-example","value":"void InitializeSearchPath(void) { if (IsBootstrapProcessingMode()) { * In bootstrap mode, the search path must be 'pg_catalog' so that * tables are created in the proper namespace; ignore the GUC sett...","count":3},{"name":"api-example","value":"void InvalidateCatalogSnapshot(void) { if (CatalogSnapshot) { pairingheap_remove(&RegisteredSnapshots, &CatalogSnapshot->ph_node); CatalogSnapshot = NULL; SnapshotResetXmin(); } }","count":3},{"name":"api-example","value":"void LWLockInitialize(LWLock *lock, int tranche_id) { pg_atomic_init_u32(&lock->state, LW_FLAG_RELEASE_OK); #ifdef LOCK_DEBUG pg_atomic_init_u32(&lock->nwaiters, 0); #endif lock->tranche = tranche_id;...","count":3},{"name":"api-example","value":"void LockDatabaseObject(Oid classid, Oid objid, uint16 objsubid, LOCKMODE lockmode) { LOCKTAG\t\ttag; SET_LOCKTAG_OBJECT(tag, MyDatabaseId, classid, objid, objsubid); (void) LockAcquire(&tag, lockmode, ...","count":3},{"name":"api-example","value":"void LockReleaseAll(LOCKMETHODID lockmethodid, bool allLocks) { HASH_SEQ_STATUS status; LockMethod\tlockMethodTable; int\t\t\ti, numLockModes; LOCALLOCK  *locallock; LOCK\t   *lock; int\t\t\tpartition; bool\t\t...","count":3},{"name":"api-example","value":"void LogicalConfirmReceivedLocation(XLogRecPtr lsn) { Assert(lsn != InvalidXLogRecPtr); if (MyReplicationSlot->candidate_xmin_lsn != InvalidXLogRecPtr || MyReplicationSlot->candidate_restart_valid != ...","count":3},{"name":"api-example","value":"void LogicalDecodingProcessRecord(LogicalDecodingContext *ctx, XLogReaderState *record) { XLogRecordBuffer buf; TransactionId txid; RmgrData\trmgr; buf.origptr = ctx->reader->ReadRecPtr; buf.endptr = c...","count":3},{"name":"api-example","value":"void LogicalIncreaseXminForSlot(XLogRecPtr current_lsn, TransactionId xmin) { bool\t\tupdated_xmin = false; ReplicationSlot *slot; bool\t\tgot_new_xmin = false; slot = MyReplicationSlot; Assert(slot != NU...","count":3},{"name":"api-example","value":"void LogicalTapeWrite(LogicalTape *lt, const void *ptr, size_t size) { LogicalTapeSet *lts = lt->tapeSet; size_t\t\tnthistime; Assert(lt->writing); Assert(lt->offsetBlockNumber == 0L); if (lt->buffer ==...","count":3},{"name":"api-example","value":"void NIImportDictionary(IspellDict *Conf, const char *filename) { tsearch_readline_state trst; char\t   *line; if (!tsearch_readline_begin(&trst, filename)) ereport(ERROR, (errcode(ERRCODE_CONFIG_FILE_...","count":3},{"name":"api-example","value":"void OperatorUpd(Oid baseId, Oid commId, Oid negId, bool isDelete) { Relation\tpg_operator_desc; HeapTuple\ttup; * If we're making an operator into its own commutator, then we need a * command-counter i...","count":3},{"name":"api-example","value":"void PLy_exception_set_with_details(PyObject *excclass, ErrorData *edata) { PyObject   *args = NULL; PyObject   *error = NULL; args = Py_BuildValue(\"(s)\", edata->message); if (!args) goto failure; err...","count":3},{"name":"api-example","value":"void ParallelApplyWorkerMain(Datum main_arg) { ParallelApplyWorkerShared *shared; dsm_handle\thandle; dsm_segment *seg; shm_toc    *toc; shm_mq\t   *mq; shm_mq_handle *mqh; shm_mq_handle *error_mqh; Rep...","count":3},{"name":"api-example","value":"void ParallelQueryMain(dsm_segment *seg, shm_toc *toc) { FixedParallelExecutorState *fpes; BufferUsage *buffer_usage; WalUsage   *wal_usage; DestReceiver *receiver; QueryDesc  *queryDesc; SharedExecut...","count":3},{"name":"api-example","value":"void PerformPortalClose(const char *name) { Portal\t\tportal; if (name == NULL) { PortalHashTableDeleteAll(); return; } * Disallow empty-string cursor name (conflicts with protocol-level * unnamed porta...","count":3},{"name":"api-example","value":"void PerformWalRecovery(void) { XLogRecord *record; bool\t\treachedRecoveryTarget = false; TimeLineID\treplayTLI; * Initialize shared variables for tracking progress of WAL replay, as if * we had just re...","count":3},{"name":"api-example","value":"void PostgresMain(const char *dbname, const char *username) { sigjmp_buf\tlocal_sigjmp_buf; volatile bool send_ready_for_query = true; volatile bool idle_in_transaction_timeout_enabled = false; volatil...","count":3},{"name":"api-example","value":"void PredicateLockRelation(Relation relation, Snapshot snapshot) { PREDICATELOCKTARGETTAG tag; if (!SerializationNeededForRead(relation, snapshot)) return; SET_PREDICATELOCKTARGETTAG_RELATION(tag, rel...","count":3},{"name":"api-example","value":"void PreventInTransactionBlock(bool isTopLevel, const char *stmtType) { * xact block already started? */ if (IsTransactionBlock()) ereport(ERROR, (errcode(ERRCODE_ACTIVE_SQL_TRANSACTION), errmsg(\"%s c...","count":3},{"name":"api-example","value":"void PrintTOCSummary(Archive *AHX) { ArchiveHandle *AH = (ArchiveHandle *) AHX; RestoreOptions *ropt = AH->public.ropt; TocEntry   *te; pg_compress_specification out_compression_spec = {0}; teSection\t...","count":3},{"name":"api-example","value":"void ProcessNotifyInterrupt(bool flush) { if (IsTransactionOrTransactionBlock()) return;\t\t\t\t\t/* not really idle */ while (notifyInterruptPending) ProcessIncomingNotify(flush); }","count":3},{"name":"api-example","value":"void ReadToc(ArchiveHandle *AH) { int\t\t\ti; char\t   *tmp; DumpId\t   *deps; int\t\t\tdepIdx; int\t\t\tdepSize; TocEntry   *te; bool\t\tis_supported; AH->tocCount = ReadInt(AH); AH->maxDumpId = 0; for (i = 0; i ...","count":3},{"name":"api-example","value":"void ReceiveCopyBinaryHeader(CopyFromState cstate) { char\t\treadSig[11]; int32\t\ttmp; if (CopyReadBinaryData(cstate, readSig, 11) != 11 || memcmp(readSig, BinarySignature, 11) != 0) ereport(ERROR, (errc...","count":3},{"name":"api-example","value":"void RegisterCustomRmgr(RmgrId rmid, const RmgrData *rmgr) { if (rmgr->rm_name == NULL || strlen(rmgr->rm_name) == 0) ereport(ERROR, (errmsg(\"custom resource manager name is invalid\"), errhint(\"Provid...","count":3},{"name":"api-example","value":"void RelationBuildTriggers(Relation relation) { TriggerDesc *trigdesc; int\t\t\tnumtrigs; int\t\t\tmaxtrigs; Trigger    *triggers; Relation\ttgrel; ScanKeyData skey; SysScanDesc tgscan; HeapTuple\thtup; Memor...","count":3},{"name":"api-example","value":"void RelationCacheInitializePhase2(void) { MemoryContext oldcxt; * relation mapper needs initialized too */ RelationMapInitializePhase2(); * In bootstrap mode, the shared catalogs aren't there yet any...","count":3},{"name":"api-example","value":"void RelationCacheInitializePhase3(void) { HASH_SEQ_STATUS status; RelIdCacheEnt *idhentry; MemoryContext oldcxt; bool\t\tneedNewCacheFile = !criticalSharedRelcachesBuilt; * relation mapper needs initia...","count":3},{"name":"api-example","value":"void RelationDropStorage(Relation rel) { PendingRelDelete *pending; pending = (PendingRelDelete *) MemoryContextAlloc(TopMemoryContext, sizeof(PendingRelDelete)); pending->rlocator = rel->rd_locator; ...","count":3},{"name":"api-example","value":"void RelationInitIndexAccessInfo(Relation relation) { HeapTuple\ttuple; Form_pg_am\taform; Datum\t\tindcollDatum; Datum\t\tindclassDatum; Datum\t\tindoptionDatum; bool\t\tisnull; oidvector  *indcoll; oidvector ...","count":3},{"name":"api-example","value":"void RelationMapCopy(Oid dbid, Oid tsid, char *srcdbpath, char *dstdbpath) { RelMapFile\tmap; * Read the relmap file from the source database. */ read_relmap_file(&map, srcdbpath, false, ERROR); * Writ...","count":3},{"name":"api-example","value":"void ReleasePredicateLocks(bool isCommit, bool isReadOnlySafe) { bool\t\tpartiallyReleasing = false; bool\t\tneedToClear; SERIALIZABLEXACT *roXact; dlist_mutable_iter iter; * We can't trust XactReadOnly h...","count":3},{"name":"api-example","value":"void RemoveObjects(DropStmt *stmt) { ObjectAddresses *objects; ListCell   *cell1; objects = new_object_addresses(); foreach(cell1, stmt->objects) { ObjectAddress address; Node\t   *object = lfirst(cell...","count":3},{"name":"api-example","value":"void RenameTypeInternal(Oid typeOid, const char *newTypeName, Oid typeNamespace) { Relation\tpg_type_desc; HeapTuple\ttuple; Form_pg_type typ; Oid\t\t\tarrayOid; Oid\t\t\toldTypeOid; pg_type_desc = table_open...","count":3},{"name":"api-example","value":"void ReorderBufferQueueMessage(ReorderBuffer *rb, TransactionId xid, Snapshot snap, XLogRecPtr lsn, bool transactional, const char *prefix, Size message_size, const char *message) { if (transactional)...","count":3},{"name":"api-example","value":"void ReplaceRoleInInitPriv(Oid oldroleid, Oid newroleid, Oid classid, Oid objid, int32 objsubid) { Relation\trel; ScanKeyData key[3]; SysScanDesc scan; HeapTuple\toldtuple; Datum\t\toldAclDatum; bool\t\tisN...","count":3},{"name":"api-example","value":"void ReportBackgroundWorkerExit(slist_mutable_iter *cur) { RegisteredBgWorker *rw; BackgroundWorkerSlot *slot; int\t\t\tnotify_pid; rw = slist_container(RegisteredBgWorker, rw_lnode, cur->cur); Assert(rw...","count":3},{"name":"api-example","value":"void RequestCheckpoint(int flags) { int\t\t\tntries; int\t\t\told_failed, old_started; * If in a standalone backend, just do it ourselves. */ if (!IsPostmasterEnvironment) { * There's no point in doing slow...","count":3},{"name":"api-example","value":"void ReserveExternalFD(void) { * Release VFDs if needed to stay safe.  Because we do this before * incrementing numExternalFDs, the final state will be as desired, i.e., * nfile + numAllocatedDescs + ...","count":3},{"name":"api-example","value":"void SS_finalize_plan(PlannerInfo *root, Plan *plan) { (void) finalize_plan(root, plan, -1, root->outer_params, NULL); }","count":3},{"name":"api-example","value":"void SaveCachedPlan(CachedPlanSource *plansource) { Assert(plansource->magic == CACHEDPLANSOURCE_MAGIC); Assert(plansource->is_complete); Assert(!plansource->is_saved); if (plansource->is_oneshot) elo...","count":3},{"name":"api-example","value":"void SignalHandlerForCrashExit(SIGNAL_ARGS) { * We DO NOT want to run proc_exit() or atexit() callbacks -- we're here * because shared memory may be corrupted, so we don't want to try to * clean up ou...","count":3},{"name":"api-example","value":"void SimpleLruInit(SlruCtl ctl, const char *name, int nslots, int nlsns, const char *subdir, int buffer_tranche_id, int bank_tranche_id, SyncRequestHandler sync_handler, bool long_segment_names) { Slr...","count":3},{"name":"api-example","value":"void SimpleLruWritePage(SlruCtl ctl, int slotno) { Assert(ctl->shared->page_status[slotno] != SLRU_PAGE_EMPTY); SlruInternalWritePage(ctl, slotno, NULL); }","count":3},{"name":"api-example","value":"void SnapBuildCommitTxn(SnapBuild *builder, XLogRecPtr lsn, TransactionId xid, int nsubxacts, TransactionId *subxacts, uint32 xinfo) { int\t\t\tnxact; bool\t\tneeds_snapshot = false; bool\t\tneeds_timetravel...","count":3},{"name":"api-example","value":"void StandbyAcquireAccessExclusiveLock(TransactionId xid, Oid dbOid, Oid relOid) { RecoveryLockXidEntry *xidentry; RecoveryLockEntry *lockentry; xl_standby_lock key; LOCKTAG\t\tlocktag; bool\t\tfound; if ...","count":3},{"name":"api-example","value":"void StartPrepare(GlobalTransaction gxact) { PGPROC\t   *proc = GetPGProcByNumber(gxact->pgprocno); TransactionId xid = gxact->xid; TwoPhaseFileHeader hdr; TransactionId *children; RelFileLocator *comm...","count":3},{"name":"api-example","value":"void StoreAttrMissingVal(Relation rel, AttrNumber attnum, Datum missingval) { Datum\t\tvaluesAtt[Natts_pg_attribute] = {0}; bool\t\tnullsAtt[Natts_pg_attribute] = {0}; bool\t\treplacesAtt[Natts_pg_attribute...","count":3},{"name":"api-example","value":"void StorePartitionBound(Relation rel, Relation parent, PartitionBoundSpec *bound) { Relation\tclassRel; HeapTuple\ttuple, newtuple; Datum\t\tnew_val[Natts_pg_class]; bool\t\tnew_null[Natts_pg_class], new_r...","count":3},{"name":"api-example","value":"void SyncPostCheckpoint(void) { int\t\t\tabsorb_counter; ListCell   *lc; absorb_counter = UNLINKS_PER_ABSORB; foreach(lc, pendingUnlinks) { PendingUnlinkEntry *entry = (PendingUnlinkEntry *) lfirst(lc); ...","count":3},{"name":"api-example","value":"void TidStoreLockExclusive(TidStore *ts) { if (TidStoreIsShared(ts)) shared_ts_lock_exclusive(ts->tree.shared); }","count":3},{"name":"api-example","value":"void TransactionTreeSetCommitTsData(TransactionId xid, int nsubxids, TransactionId *subxids, TimestampTz timestamp, RepOriginId nodeid) { int\t\t\ti; TransactionId headxid; TransactionId newestXact; * No...","count":3},{"name":"api-example","value":"void TrimMultiXact(void) { MultiXactId nextMXact; MultiXactOffset offset; MultiXactId oldestMXact; Oid\t\t\toldestMXactDB; int64\t\tpageno; int\t\t\tentryno; int\t\t\tflagsoff; LWLockAcquire(MultiXactGenLock, LW...","count":3},{"name":"api-example","value":"void TupleDescInitEntry(TupleDesc desc, AttrNumber attributeNumber, const char *attributeName, Oid oidtypeid, int32 typmod, int attdim) { HeapTuple\ttuple; Form_pg_type typeForm; Form_pg_attribute att;...","count":3},{"name":"api-example","value":"void WalSummarizerMain(char *startup_data, size_t startup_data_len) { sigjmp_buf\tlocal_sigjmp_buf; MemoryContext context; * Within this function, 'current_lsn' and 'current_tli' refer to the * point f...","count":3},{"name":"api-example","value":"void WriteBlockRefTable(BlockRefTable *brtab, io_callback_fn write_callback, void *write_callback_arg) { BlockRefTableSerializedEntry *sdata = NULL; BlockRefTableBuffer buffer; uint32\t\tmagic = BLOCKRE...","count":3},{"name":"api-example","value":"void WriteToc(ArchiveHandle *AH) { TocEntry   *te; char\t\tworkbuf[32]; int\t\t\ttocCount; int\t\t\ti; tocCount = 0; for (te = AH->toc->next; te != AH->toc; te = te->next) { if ((te->reqs & (REQ_SCHEMA | REQ_...","count":3},{"name":"api-example","value":"void XLogArchiveNotify(const char *xlog) { char\t\tarchiveStatusPath[MAXPGPATH]; FILE\t   *fd; StatusFilePath(archiveStatusPath, xlog, \".ready\"); fd = AllocateFile(archiveStatusPath, \"w\"); if (fd == NULL...","count":3},{"name":"api-example","value":"void XLogDropDatabase(Oid dbid) { * This is unnecessarily heavy-handed, as it will close SMgrRelation * objects for other databases as well. DROP DATABASE occurs seldom enough * that it's not worth in...","count":3},{"name":"api-example","value":"void XLogEnsureRecordSpace(int max_block_id, int ndatas) { int\t\t\tnbuffers; * This must be called before entering a critical section, because * allocating memory inside a critical section can fail. rep...","count":3},{"name":"api-example","value":"void _PG_init(void) { * Be sure we do initialization only once. * * If initialization fails due to, e.g., plperl_init_interp() throwing an * exception, then we'll return here on the next usage and the...","count":3},{"name":"api-example","value":"void _bt_parallel_done(IndexScanDesc scan) { BTScanOpaque so = (BTScanOpaque) scan->opaque; ParallelIndexScanDesc parallel_scan = scan->parallel_scan; BTParallelScanDesc btscan; bool\t\tstatus_changed =...","count":3},{"name":"api-example","value":"void _hash_finish_split(Relation rel, Buffer metabuf, Buffer obuf, Bucket obucket, uint32 maxbucket, uint32 highmask, uint32 lowmask) { HASHCTL\t\thash_ctl; HTAB\t   *tidhtab; Buffer\t\tbucket_nbuf = Inval...","count":3},{"name":"api-example","value":"void _hash_init_metabuffer(Buffer buf, double num_tuples, RegProcedure procid, uint16 ffactor, bool initpage) { HashMetaPage metap; HashPageOpaque pageopaque; Page\t\tpage; double\t\tdnumbuckets; uint32\t\t...","count":3},{"name":"api-example","value":"void aclcheck_error_type(AclResult aclerr, Oid typeOid) { Oid\t\t\telement_type = get_element_type(typeOid); aclcheck_error(aclerr, OBJECT_TYPE, format_type_be(element_type ? element_type : typeOid)); }","count":3},{"name":"api-example","value":"void add_base_rels_to_query(PlannerInfo *root, Node *jtnode) { if (jtnode == NULL) return; if (IsA(jtnode, RangeTblRef)) { int\t\t\tvarno = ((RangeTblRef *) jtnode)->rtindex; (void) build_simple_rel(root...","count":3},{"name":"api-example","value":"void add_bool_reloption(bits32 kinds, const char *name, const char *desc, bool default_val, LOCKMODE lockmode) { relopt_bool *newoption = init_bool_reloption(kinds, name, desc, default_val, lockmode);...","count":3},{"name":"api-example","value":"void add_child_rel_equivalences(PlannerInfo *root, AppendRelInfo *appinfo, RelOptInfo *parent_rel, RelOptInfo *child_rel) { Relids\t\ttop_parent_relids = child_rel->top_parent_relids; Relids\t\tchild_reli...","count":3},{"name":"api-example","value":"void add_local_bool_reloption(local_relopts *relopts, const char *name, const char *desc, bool default_val, int offset) { relopt_bool *newoption = init_bool_reloption(RELOPT_KIND_LOCAL, name, desc, de...","count":3},{"name":"api-example","value":"void add_path(RelOptInfo *parent_rel, Path *new_path) { bool\t\taccept_new = true;\t/* unless we find a superior old path */ int\t\t\tinsert_at = 0;\t/* where to insert new item */ List\t   *new_path_pathkeys...","count":3},{"name":"api-example","value":"void ahwrite(const void *ptr, size_t size, size_t nmemb, ArchiveHandle *AH) { int\t\t\tbytes_written = 0; if (AH->writingLO) { size_t\t\tremaining = size * nmemb; while (AH->lo_buf_used + remaining > AH->l...","count":3},{"name":"api-example","value":"void appendQualifiedRelation(PQExpBuffer buf, const char *spec, PGconn *conn, bool echo) { char\t   *table; const char *columns; PQExpBufferData sql; PGresult   *res; int\t\t\tntups; splitTableColumnsSpec...","count":3},{"name":"api-example","value":"void apply_error_callback(void *arg) { ApplyErrorCallbackArg *errarg = &apply_error_callback_arg; if (apply_error_callback_arg.command == 0) return; Assert(errarg->origin_name); if (errarg->rel == NUL...","count":3},{"name":"api-example","value":"void apply_spooled_messages(FileSet *stream_fileset, TransactionId xid, XLogRecPtr lsn) { int\t\t\tnchanges; char\t\tpath[MAXPGPATH]; char\t   *buffer = NULL; MemoryContext oldcxt; ResourceOwner oldowner; i...","count":3},{"name":"api-example","value":"void assign_expr_collations(ParseState *pstate, Node *expr) { assign_collations_context context; context.pstate = pstate; context.collation = InvalidOid; context.strength = COLLATE_NONE; context.locat...","count":3},{"name":"api-example","value":"void assign_recovery_target(const char *newval, void *extra) { if (recoveryTarget != RECOVERY_TARGET_UNSET && recoveryTarget != RECOVERY_TARGET_IMMEDIATE) error_multiple_recovery_targets(); if (newval...","count":3},{"name":"api-example","value":"void brin_page_init(Page page, uint16 type) { PageInit(page, BLCKSZ, sizeof(BrinSpecialSpace)); BrinPageType(page) = type; }","count":3},{"name":"api-example","value":"void brinrescan(IndexScanDesc scan, ScanKey scankey, int nscankeys, ScanKey orderbys, int norderbys) { * Other index AMs preprocess the scan keys at this point, or sometime * early during the scan; th...","count":3},{"name":"api-example","value":"void btcostestimate(PlannerInfo *root, IndexPath *path, double loop_count, Cost *indexStartupCost, Cost *indexTotalCost, Selectivity *indexSelectivity, double *indexCorrelation, double *indexPages) { ...","count":3},{"name":"api-example","value":"void btrescan(IndexScanDesc scan, ScanKey scankey, int nscankeys, ScanKey orderbys, int norderbys) { BTScanOpaque so = (BTScanOpaque) scan->opaque; if (BTScanPosIsValid(so->currPos)) { if (so->numKill...","count":3},{"name":"api-example","value":"void build_indices(void) { for (; ILHead != NULL; ILHead = ILHead->il_next) { Relation\theap; Relation\tind; heap = table_open(ILHead->il_heap, NoLock); ind = index_open(ILHead->il_ind, NoLock); index_b...","count":3},{"name":"api-example","value":"void canonicalize_path_enc(char *path, int encoding) { char\t   *p, *to_p; char\t   *spath; char\t   *parsed; char\t   *unparse; bool\t\twas_sep = false; canonicalize_state state; int\t\t\tpathdepth = 0;\t/* co...","count":3},{"name":"api-example","value":"void changeDependencyOnOwner(Oid classId, Oid objectId, Oid newOwnerId) { Relation\tsdepRel; sdepRel = table_open(SharedDependRelationId, RowExclusiveLock); shdepChangeDep(sdepRel, classId, objectId, 0...","count":3},{"name":"api-example","value":"void check_and_dump_old_cluster(bool live_check) { if (!live_check) start_postmaster(&old_cluster, true); * Extract a list of databases, tables, and logical replication slots from * the old cluster. *...","count":3},{"name":"api-example","value":"void check_index_predicates(PlannerInfo *root, RelOptInfo *rel) { List\t   *clauselist; bool\t\thave_partial; bool\t\tis_target_rel; Relids\t\totherrels; ListCell   *lc; Assert(IS_SIMPLE_REL(rel)); * Initial...","count":3},{"name":"api-example","value":"void check_pghost_envvar(void) { PQconninfoOption *option; PQconninfoOption *start; start = PQconndefaults(); if (!start) pg_fatal(\"out of memory\"); for (option = start; option->keyword != NULL; optio...","count":3},{"name":"api-example","value":"void cluster(ParseState *pstate, ClusterStmt *stmt, bool isTopLevel) { ListCell   *lc; ClusterParams params = {0}; bool\t\tverbose = false; Relation\trel = NULL; Oid\t\t\tindexOid = InvalidOid; MemoryContex...","count":3},{"name":"api-example","value":"void cost_append(AppendPath *apath) { ListCell   *l; apath->path.startup_cost = 0; apath->path.total_cost = 0; apath->path.rows = 0; if (apath->subpaths == NIL) return; if (!apath->path.parallel_aware...","count":3},{"name":"api-example","value":"void cost_bitmap_and_node(BitmapAndPath *path, PlannerInfo *root) { Cost\t\ttotalCost; Selectivity selec; ListCell   *l; * We estimate AND selectivity on the assumption that the inputs are * independent...","count":3},{"name":"api-example","value":"void cost_functionscan(Path *path, PlannerInfo *root, RelOptInfo *baserel, ParamPathInfo *param_info) { Cost\t\tstartup_cost = 0; Cost\t\trun_cost = 0; QualCost\tqpqual_cost; Cost\t\tcpu_per_tuple; RangeTblE...","count":3},{"name":"api-example","value":"void cost_gather_merge(GatherMergePath *path, PlannerInfo *root, RelOptInfo *rel, ParamPathInfo *param_info, Cost input_startup_cost, Cost input_total_cost, double *rows) { Cost\t\tstartup_cost = 0; Cos...","count":3},{"name":"api-example","value":"void cost_qual_eval(QualCost *cost, List *quals, PlannerInfo *root) { cost_qual_eval_context context; ListCell   *l; context.root = root; context.total.startup = 0; context.total.per_tuple = 0; foreac...","count":3},{"name":"api-example","value":"void cost_tidrangescan(Path *path, PlannerInfo *root, RelOptInfo *baserel, List *tidrangequals, ParamPathInfo *param_info) { Selectivity selectivity; double\t\tpages; Cost\t\tstartup_cost = 0; Cost\t\trun_c...","count":3},{"name":"api-example","value":"void cost_tidscan(Path *path, PlannerInfo *root, RelOptInfo *baserel, List *tidquals, ParamPathInfo *param_info) { Cost\t\tstartup_cost = 0; Cost\t\trun_cost = 0; bool\t\tisCurrentOf = false; QualCost\tqpqua...","count":3},{"name":"api-example","value":"void cost_windowagg(Path *path, PlannerInfo *root, List *windowFuncs, WindowClause *winclause, Cost input_startup_cost, Cost input_total_cost, double input_tuples) { Cost\t\tstartup_cost; Cost\t\ttotal_co...","count":3},{"name":"api-example","value":"void create_script_for_old_cluster_deletion(char **deletion_script_file_name) { FILE\t   *script = NULL; int\t\t\ttblnum; char\t\told_cluster_pgdata[MAXPGPATH], new_cluster_pgdata[MAXPGPATH]; *deletion_scri...","count":3},{"name":"api-example","value":"void dsa_dump(dsa_area *area) { size_t\t\ti, j; * Note: This gives an inconsistent snapshot as it acquires and releases * individual locks as it goes... */ LWLockAcquire(DSA_AREA_LOCK(area), LW_EXCLUSIV...","count":3},{"name":"api-example","value":"void dsa_free(dsa_area *area, dsa_pointer dp) { dsa_segment_map *segment_map; int\t\t\tpageno; dsa_pointer span_pointer; dsa_area_span *span; char\t   *superblock; char\t   *object; size_t\t\tsize; int\t\t\tsiz...","count":3},{"name":"api-example","value":"void dshash_destroy(dshash_table *hash_table) { size_t\t\tsize; size_t\t\ti; Assert(hash_table->control->magic == DSHASH_MAGIC); ensure_valid_bucket_pointers(hash_table); size = NUM_BUCKETS(hash_table->si...","count":3},{"name":"api-example","value":"void dshash_detach(dshash_table *hash_table) { ASSERT_NO_PARTITION_LOCKS_HELD_BY_ME(hash_table); pfree(hash_table); }","count":3},{"name":"api-example","value":"void dshash_dump(dshash_table *hash_table) { size_t\t\ti; size_t\t\tj; Assert(hash_table->control->magic == DSHASH_MAGIC); ASSERT_NO_PARTITION_LOCKS_HELD_BY_ME(hash_table); for (i = 0; i < DSHASH_NUM_PART...","count":3},{"name":"api-example","value":"void dsm_cleanup_using_control_segment(dsm_handle old_control_handle) { void\t   *mapped_address = NULL; void\t   *junk_mapped_address = NULL; void\t   *impl_private = NULL; void\t   *junk_impl_private = ...","count":3},{"name":"api-example","value":"void dsm_postmaster_startup(PGShmemHeader *shim) { void\t   *dsm_control_address = NULL; uint32\t\tmaxitems; Size\t\tsegsize; Assert(!IsUnderPostmaster); * If we're using the mmap implementations, clean up...","count":3},{"name":"api-example","value":"void dump_line(void) {\t\t\t\t/* dump_line is the routine that actually * effects the printing of the new source. It * prints the label section, followed by the * code section with the appropriate nesting...","count":3},{"name":"api-example","value":"void ecpg_raise(int line, int code, const char *sqlstate, const char *str) { struct sqlca_t *sqlca = ECPGget_sqlca(); if (sqlca == NULL) { ecpg_log(\"out of memory\"); ECPGfree_auto_mem(); return; } sql...","count":3},{"name":"api-example","value":"void end_progress_output(void) { * For output to a tty, erase prior contents of progress line. When either * tty or verbose, indent so that report_status() output will align * nicely. */ if (log_opts....","count":3},{"name":"api-example","value":"void errfinish(const char *filename, int lineno, const char *funcname) { ErrorData  *edata = &errordata[errordata_stack_depth]; int\t\t\televel; MemoryContext oldcontext; ErrorContextCallback *econtext; ...","count":3},{"name":"api-example","value":"void execTuplesHashPrepare(int numCols, const Oid *eqOperators, Oid **eqFuncOids, FmgrInfo **hashFunctions) { int\t\t\ti; *eqFuncOids = (Oid *) palloc(numCols * sizeof(Oid)); *hashFunctions = (FmgrInfo *...","count":3},{"name":"api-example","value":"void expanded_record_set_fields(ExpandedRecordHeader *erh, const Datum *newValues, const bool *isnulls, bool expand_external) { TupleDesc\ttupdesc; Datum\t   *dvalues; bool\t   *dnulls; int\t\t\tfnumber; Me...","count":3},{"name":"api-example","value":"void exprSetCollation(Node *expr, Oid collation) { switch (nodeTag(expr)) { case T_Var: ((Var *) expr)->varcollid = collation; break; case T_Const: ((Const *) expr)->constcollid = collation; break; ca...","count":3},{"name":"api-example","value":"void finish_heap_swap(Oid OIDOldHeap, Oid OIDNewHeap, bool is_system_catalog, bool swap_toast_by_content, bool check_constraints, bool is_internal, TransactionId frozenXid, MultiXactId cutoffMulti, ch...","count":3},{"name":"api-example","value":"void get_share_path(const char *my_exec_path, char *ret_path) { make_relative_path(ret_path, PGSHAREDIR, PGBINDIR, my_exec_path); }","count":3},{"name":"api-example","value":"void ginInsertItemPointers(Relation index, BlockNumber rootBlkno, ItemPointerData *items, uint32 nitem, GinStatsData *buildStats) { GinBtreeData btree; GinBtreeDataLeafInsertData insertdata; GinBtreeS...","count":3},{"name":"api-example","value":"void gistFreeBuildBuffers(GISTBuildBuffers *gfbb) { BufFileClose(gfbb->pfile); }","count":3},{"name":"api-example","value":"void gistbuildempty(Relation index) { Buffer\t\tbuffer; buffer = ExtendBufferedRel(BMR_REL(index), INIT_FORKNUM, NULL, EB_SKIP_EXTENSION_LOCK | EB_LOCK_FIRST); START_CRIT_SECTION(); GISTInitBuffer(buffe...","count":3},{"name":"api-example","value":"void gistcheckpage(Relation rel, Buffer buf) { Page\t\tpage = BufferGetPage(buf); * ReadBuffer verifies that every newly-read page passes * PageHeaderIsValid, which means it either contains a reasonably...","count":3},{"name":"api-example","value":"void hashrescan(IndexScanDesc scan, ScanKey scankey, int nscankeys, ScanKey orderbys, int norderbys) { HashScanOpaque so = (HashScanOpaque) scan->opaque; Relation\trel = scan->indexRelation; if (HashSc...","count":3},{"name":"api-example","value":"void heap2_decode(LogicalDecodingContext *ctx, XLogRecordBuffer *buf) { uint8\t\tinfo = XLogRecGetInfo(buf->record) & XLOG_HEAP_OPMASK; TransactionId xid = XLogRecGetXid(buf->record); SnapBuild  *builde...","count":3},{"name":"api-example","value":"void heap_desc(StringInfo buf, XLogReaderState *record) { char\t   *rec = XLogRecGetData(record); uint8\t\tinfo = XLogRecGetInfo(record) & ~XLR_INFO_MASK; info &= XLOG_HEAP_OPMASK; if (info == XLOG_HEAP_...","count":3},{"name":"api-example","value":"void heap_endscan(TableScanDesc sscan) { HeapScanDesc scan = (HeapScanDesc) sscan; * unpin scan buffers */ if (BufferIsValid(scan->rs_cbuf)) ReleaseBuffer(scan->rs_cbuf); if (BufferIsValid(scan->rs_vm...","count":3},{"name":"api-example","value":"void heap_set_tidrange(TableScanDesc sscan, ItemPointer mintid, ItemPointer maxtid) { HeapScanDesc scan = (HeapScanDesc) sscan; BlockNumber startBlk; BlockNumber numBlks; ItemPointerData highestItem; ...","count":3},{"name":"api-example","value":"void index_concurrently_set_dead(Oid heapId, Oid indexId) { Relation\tuserHeapRelation; Relation\tuserIndexRelation; * No more predicate locks will be acquired on this index, and we're about * to stop d...","count":3},{"name":"api-example","value":"void init_parallel_dump_utils(void) { #ifdef WIN32 if (!parallel_init_done) { WSADATA\t\twsaData; int\t\t\terr; tls_index = TlsAlloc(); mainThreadId = GetCurrentThreadId(); err = WSAStartup(MAKEWORD(2, 2),...","count":3},{"name":"api-example","value":"void iterate_jsonb_values(Jsonb *jb, uint32 flags, void *state, JsonIterateStringValuesAction action) { JsonbIterator *it; JsonbValue\tv; JsonbIteratorToken type; it = JsonbIteratorInit(&jb->root); * J...","count":3},{"name":"api-example","value":"void json_parse_manifest_incremental_chunk(JsonManifestParseIncrementalState *incstate, const char *chunk, size_t size, bool is_last) { JsonParseErrorType res, expected; JsonManifestParseState *parse ...","count":3},{"name":"api-example","value":"void jspInitByBuffer(JsonPathItem *v, char *base, int32 pos) { v->base = base + pos; read_byte(v->type, base, pos); pos = INTALIGN((uintptr_t) (base + pos)) - (uintptr_t) base; read_int32(v->nextPos, ...","count":3},{"name":"api-example","value":"void log_status_format(StringInfo buf, const char *format, ErrorData *edata) { static long log_line_number = 0; static int\tlog_my_pid = 0; int\t\t\tpadding; const char *p; * This is one of the few places...","count":3},{"name":"api-example","value":"void logicalmsg_decode(LogicalDecodingContext *ctx, XLogRecordBuffer *buf) { SnapBuild  *builder = ctx->snapshot_builder; XLogReaderState *r = buf->record; TransactionId xid = XLogRecGetXid(r); uint8\t...","count":3},{"name":"api-example","value":"void logicalrep_worker_stop(Oid subid, Oid relid) { LogicalRepWorker *worker; LWLockAcquire(LogicalRepWorkerLock, LW_SHARED); worker = logicalrep_worker_find(subid, relid, false); if (worker) { Assert...","count":3},{"name":"api-example","value":"void logicalrep_write_truncate(StringInfo out, TransactionId xid, int nrelids, Oid relids[], bool cascade, bool restart_seqs) { int\t\t\ti; uint8\t\tflags = 0; pq_sendbyte(out, LOGICAL_REP_MSG_TRUNCATE); i...","count":3},{"name":"api-example","value":"void mask_page_hint_bits(Page page) { PageHeader\tphdr = (PageHeader) page; phdr->pd_prune_xid = MASK_MARKER; PageClearFull(page); PageClearHasFreeLinePointers(page); * During replay, if the page LSN h...","count":3},{"name":"api-example","value":"void mdextend(SMgrRelation reln, ForkNumber forknum, BlockNumber blocknum, const void *buffer, bool skipFsync) { off_t\t\tseekpos; int\t\t\tnbytes; MdfdVec    *v; if (PG_O_DIRECT != 0 && PG_IO_ALIGN_SIZE <...","count":3},{"name":"api-example","value":"void multixact_redo(XLogReaderState *record) { uint8\t\tinfo = XLogRecGetInfo(record) & ~XLR_INFO_MASK; Assert(!XLogRecHasAnyBlockRefs(record)); if (info == XLOG_MULTIXACT_ZERO_OFF_PAGE) { int64\t\tpageno...","count":3},{"name":"api-example","value":"void outDatum(StringInfo str, Datum value, int typlen, bool typbyval) { Size\t\tlength, i; char\t   *s; length = datumGetSize(value, typbyval, typlen); if (typbyval) { s = (char *) (&value); appendString...","count":3},{"name":"api-example","value":"void output_get_descr_header(char *desc_name) { struct assignment *results; fprintf(base_yyout, \"{ ECPGget_desc_header(__LINE__, %s, &(\", desc_name); for (results = assignments; results != NULL; resul...","count":3},{"name":"api-example","value":"void output_set_descr(char *desc_name, char *index) { struct assignment *results; fprintf(base_yyout, \"{ ECPGset_desc(__LINE__, %s, %s,\", desc_name, index); for (results = assignments; results != NULL...","count":3},{"name":"api-example","value":"void output_simple_statement(char *stmt, int whenever_mode) { output_escaped_str(stmt, false); if (whenever_mode) whenever_action(whenever_mode); output_line_number(); free(stmt); }","count":3},{"name":"api-example","value":"void pa_xact_finish(ParallelApplyWorkerInfo *winfo, XLogRecPtr remote_lsn) { Assert(am_leader_apply_worker()); * Unlock the shared object lock so that parallel apply worker can * continue to receive a...","count":3},{"name":"api-example","value":"void parseCommandLine(int argc, char *argv[]) { static struct option long_options[] = { {\"old-datadir\", required_argument, NULL, 'd'}, {\"new-datadir\", required_argument, NULL, 'D'}, {\"old-bindir\", req...","count":3},{"name":"api-example","value":"void parse_backup_label(char *filename, StringInfo buf, TimeLineID *start_tli, XLogRecPtr *start_lsn, TimeLineID *previous_tli, XLogRecPtr *previous_lsn) { int\t\t\tfound = 0; *start_tli = 0; *start_lsn ...","count":3},{"name":"api-example","value":"void pgstat_archiver_reset_all_cb(TimestampTz ts) { PgStatShared_Archiver *stats_shmem = &pgStatLocal.shmem->archiver; LWLockAcquire(&stats_shmem->lock, LW_EXCLUSIVE); pgstat_copy_changecounted_stats(...","count":3},{"name":"api-example","value":"void pgstat_checkpointer_snapshot_cb(void) { PgStatShared_Checkpointer *stats_shmem = &pgStatLocal.shmem->checkpointer; PgStat_CheckpointerStats *reset_offset = &stats_shmem->reset_offset; PgStat_Chec...","count":3},{"name":"api-example","value":"void pgstat_count_slru_page_zeroed(int slru_idx) { get_slru_entry(slru_idx)->blocks_zeroed += 1; }","count":3},{"name":"api-example","value":"void pgstat_drop_relation(Relation rel) { int\t\t\tnest_level = GetCurrentTransactionNestLevel(); PgStat_TableStatus *pgstat_info; pgstat_drop_transactional(PGSTAT_KIND_RELATION, rel->rd_rel->relisshared...","count":3},{"name":"api-example","value":"void pgstat_drop_replslot(ReplicationSlot *slot) { Assert(LWLockHeldByMeInMode(ReplicationSlotAllocationLock, LW_EXCLUSIVE)); if (!pgstat_drop_entry(PGSTAT_KIND_REPLSLOT, InvalidOid, ReplicationSlotIn...","count":3},{"name":"api-example","value":"void pgstat_init_function_usage(FunctionCallInfo fcinfo, PgStat_FunctionCallUsage *fcu) { PgStat_EntryRef *entry_ref; PgStat_FunctionCounts *pending; bool\t\tcreated_entry; if (pgstat_track_functions <=...","count":3},{"name":"api-example","value":"void pgstat_report_autovac(Oid dboid) { PgStat_EntryRef *entry_ref; PgStatShared_Database *dbentry; Assert(IsUnderPostmaster); * End-of-vacuum is reported instantly. Report the start the same way for ...","count":3},{"name":"api-example","value":"void pgstat_report_checkpointer(void) { static const PgStat_CheckpointerStats all_zeroes; PgStatShared_Checkpointer *stats_shmem = &pgStatLocal.shmem->checkpointer; Assert(!pgStatLocal.shmem->is_shutd...","count":3},{"name":"api-example","value":"void pgstat_report_recovery_conflict(int reason) { PgStat_StatDBEntry *dbentry; Assert(IsUnderPostmaster); if (!pgstat_track_counts) return; dbentry = pgstat_prep_database_pending(MyDatabaseId); switc...","count":3},{"name":"api-example","value":"void pgstat_report_replslot(ReplicationSlot *slot, const PgStat_StatReplSlotEntry *repSlotStat) { PgStat_EntryRef *entry_ref; PgStatShared_ReplSlot *shstatent; PgStat_StatReplSlotEntry *statent; entry...","count":3},{"name":"api-example","value":"void pgstat_reset(PgStat_Kind kind, Oid dboid, Oid objoid) { const PgStat_KindInfo *kind_info = pgstat_get_kind_info(kind); TimestampTz ts = GetCurrentTimestamp(); Assert(!pgstat_get_kind_info(kind)->...","count":3},{"name":"api-example","value":"void pgstat_snapshot_fixed(PgStat_Kind kind) { Assert(pgstat_is_kind_valid(kind)); Assert(pgstat_get_kind_info(kind)->fixed_amount); if (force_stats_snapshot_clear) pgstat_clear_snapshot(); if (pgstat...","count":3},{"name":"api-example","value":"void pqDropConnection(PGconn *conn, bool flushInput) { pqsecure_close(conn); if (conn->sock != PGINVALID_SOCKET) closesocket(conn->sock); conn->sock = PGINVALID_SOCKET; if (flushInput) conn->inStart =...","count":3},{"name":"api-example","value":"void pqParseInput3(PGconn *conn) { char\t\tid; int\t\t\tmsgLength; int\t\t\tavail; * Loop to parse successive complete messages available in the buffer. */ for (;;) { * Try to read a message.  First get the t...","count":3},{"name":"api-example","value":"void pq_redirect_to_shm_mq(dsm_segment *seg, shm_mq_handle *mqh) { PqCommMethods = &PqCommMqMethods; pq_mq_handle = mqh; whereToSendOutput = DestRemote; FrontendProtocol = PG_PROTOCOL_LATEST; on_dsm_d...","count":3},{"name":"api-example","value":"void print_expr(const Node *expr, const List *rtable) { if (expr == NULL) { printf(\"<>\"); return; } if (IsA(expr, Var)) { const Var  *var = (const Var *) expr; char\t   *relname, *attname; switch (var-...","count":3},{"name":"api-example","value":"void processCancelRequest(int backendPID, int32 cancelAuthCode) { Backend    *bp; #ifndef EXEC_BACKEND dlist_iter\titer; #else int\t\t\ti; #endif * See if we have a matching backend.  In the EXEC_BACKEND ...","count":3},{"name":"api-example","value":"void pull_up_sublinks(PlannerInfo *root) { Node\t   *jtnode; Relids\t\trelids; jtnode = pull_up_sublinks_jointree_recurse(root, (Node *) root->parse->jointree, &relids); * root->parse->jointree must alwa...","count":3},{"name":"api-example","value":"void pull_up_subqueries(PlannerInfo *root) { Assert(IsA(root->parse->jointree, FromExpr)); root->parse->jointree = (FromExpr *) pull_up_subqueries_recurse(root, (Node *) root->parse->jointree, NULL, N...","count":3},{"name":"api-example","value":"void push_assignment(char *var, enum ECPGdtype value) { struct assignment *new = (struct assignment *) mm_alloc(sizeof(struct assignment)); new->next = assignments; new->variable = mm_alloc(strlen(var...","count":3},{"name":"api-example","value":"void recordDependencyOnCurrentExtension(const ObjectAddress *object, bool isReplace) { Assert(object->objectSubId == 0); if (creating_extension) { ObjectAddress extension; if (isReplace) { Oid\t\t\toldex...","count":3},{"name":"api-example","value":"void recordDependencyOnExpr(const ObjectAddress *depender, Node *expr, List *rtable, DependencyType behavior) { find_expr_references_context context; context.addrs = new_object_addresses(); context.rt...","count":3},{"name":"api-example","value":"void recordDependencyOnOwner(Oid classId, Oid objectId, Oid owner) { ObjectAddress myself, referenced; myself.classId = classId; myself.objectId = objectId; myself.objectSubId = 0; referenced.classId ...","count":3},{"name":"api-example","value":"void recordDependencyOnSingleRelExpr(const ObjectAddress *depender, Node *expr, Oid relId, DependencyType behavior, DependencyType self_behavior, bool reverse_self) { find_expr_references_context cont...","count":3},{"name":"api-example","value":"void recordExtObjInitPriv(Oid objoid, Oid classoid) { * pg_class / pg_attribute * * If this is a relation then we need to see if there are any sub-objects * (eg: columns) for it and, if so, be sure to...","count":3},{"name":"api-example","value":"void recordMultipleDependencies(const ObjectAddress *depender, const ObjectAddress *referenced, int nreferenced, DependencyType behavior) { Relation\tdependDesc; CatalogIndexState indstate; TupleTableS...","count":3},{"name":"api-example","value":"void register_reloptions_validator(local_relopts *relopts, relopts_validator validator) { relopts->validators = lappend(relopts->validators, validator); }","count":3},{"name":"api-example","value":"void report_invalid_encoding(int encoding, const char *mbstr, int len) { int\t\t\tl = pg_encoding_mblen_or_incomplete(encoding, mbstr, len); char\t\tbuf[8 * 5 + 1]; char\t   *p = buf; int\t\t\tj, jlimit; jlimi...","count":3},{"name":"api-example","value":"void rewrite_heap_tuple(RewriteState state, HeapTuple old_tuple, HeapTuple new_tuple) { MemoryContext old_cxt; ItemPointerData old_tid; TidHashKey\thashkey; bool\t\tfound; bool\t\tfree_new; old_cxt = Memor...","count":3},{"name":"api-example","value":"void set_defaults(void) { struct pro *p; * Because ps.case_indent is a float, we can't initialize it from the * table: */ ps.case_indent = 0.0;\t/* -cli0.0 */ for (p = pro; p->p_name; p++) if (p->p_typ...","count":3},{"name":"api-example","value":"void shdepDropOwned(List *roleids, DropBehavior behavior) { Relation\tsdepRel; ListCell   *cell; ObjectAddresses *deleteobjs; deleteobjs = new_object_addresses(); * We don't need this strong a lock her...","count":3},{"name":"api-example","value":"void simple_table_tuple_insert(Relation rel, TupleTableSlot *slot) { table_tuple_insert(rel, slot, GetCurrentCommandId(true), 0, NULL); }","count":3},{"name":"api-example","value":"void spgUpdateNodeLink(SpGistInnerTuple tup, int nodeN, BlockNumber blkno, OffsetNumber offset) { int\t\t\ti; SpGistNodeTuple node; SGITITERATE(tup, i, node) { if (i == nodeN) { ItemPointerSet(&node->t_t...","count":3},{"name":"api-example","value":"void ss_report_location(Relation rel, BlockNumber location) { #ifdef TRACE_SYNCSCAN if (trace_syncscan) { if ((location % 1024) == 0) elog(LOG, \"SYNC_SCAN: scanning \\\"%s\\\" at %u\", RelationGetRelationN...","count":3},{"name":"api-example","value":"void standard_ExecutorStart(QueryDesc *queryDesc, int eflags) { EState\t   *estate; MemoryContext oldcontext; Assert(queryDesc != NULL); Assert(queryDesc->estate == NULL); Assert(GetActiveSnapshot() ==...","count":3},{"name":"api-example","value":"void table_block_parallelscan_reinitialize(Relation rel, ParallelTableScanDesc pscan) { ParallelBlockTableScanDesc bpscan = (ParallelBlockTableScanDesc) pscan; pg_atomic_write_u64(&bpscan->phs_nalloca...","count":3},{"name":"api-example","value":"void table_block_relation_estimate_size(Relation rel, int32 *attr_widths, BlockNumber *pages, double *tuples, double *allvisfrac, Size overhead_bytes_per_tuple, Size usable_bytes_per_page) { BlockNumb...","count":3},{"name":"api-example","value":"void tbm_union(TIDBitmap *a, const TIDBitmap *b) { Assert(!a->iterating); if (b->nentries == 0) return; if (b->status == TBM_ONE_PAGE) tbm_union_page(a, &b->entry1); else { pagetable_iterator i; Paget...","count":3},{"name":"api-example","value":"void tokenize_auth_file(const char *filename, FILE *file, List **tok_lines, int elevel, int depth) { int\t\t\tline_number = 1; StringInfoData buf; MemoryContext linecxt; MemoryContext funccxt;\t\t/* contex...","count":3},{"name":"api-example","value":"void transform_MERGE_to_join(Query *parse) { RangeTblEntry *joinrte; JoinExpr   *joinexpr; bool\t\thave_action[NUM_MERGE_MATCH_KINDS]; JoinType\tjointype; int\t\t\tjoinrti; List\t   *vars; RangeTblRef *rtr; ...","count":3},{"name":"api-example","value":"void tuplesort_puttupleslot(Tuplesortstate *state, TupleTableSlot *slot) { TuplesortPublic *base = TuplesortstateGetPublic(state); MemoryContext oldcontext = MemoryContextSwitchTo(base->tuplecontext);...","count":3},{"name":"api-example","value":"void vacuum(List *relations, VacuumParams *params, BufferAccessStrategy bstrategy, MemoryContext vac_context, bool isTopLevel) { static bool in_vacuum = false; const char *stmttype; volatile bool in_o...","count":3},{"name":"api-example","value":"void write_jsonlog(ErrorData *edata) { StringInfoData buf; char\t   *start_time; char\t   *log_time; static long log_line_number = 0; static int\tlog_my_pid = 0; * This is one of the few places where we'...","count":3},{"name":"api-example","value":"void xact_decode(LogicalDecodingContext *ctx, XLogRecordBuffer *buf) { SnapBuild  *builder = ctx->snapshot_builder; ReorderBuffer *reorder = ctx->reorder; XLogReaderState *r = buf->record; uint8\t\tinfo...","count":3},{"name":"arch-sublayer","value":"freespace-map","count":3},{"name":"arch-sublayer","value":"storage-manager","count":3},{"name":"Feature","value":"\"jsonlog\" logging format","count":2},{"name":"Feature","value":"CREATE STATISTICS - \"OR\" and \"IN/ANY\" statistics","count":2},{"name":"Feature","value":"Client-specified requirements for authentication","count":2},{"name":"Feature","value":"Distributed checkpointing","count":2},{"name":"Feature","value":"Loadable plugin infrastructure for monitoring the planner","count":2},{"name":"Feature","value":"Parallel bitmap heap scans","count":2},{"name":"Feature","value":"SYSTEM_USER","count":2},{"name":"Feature","value":"Sun Studio compiler on Linux","count":2},{"name":"Feature","value":"Table Partitioning","count":2},{"name":"Feature","value":"Type modifier support","count":2},{"name":"Feature","value":"WAL Buffer auto-tuning","count":2},{"name":"Feature","value":"WHEN clause for CREATE TRIGGER","count":2},{"name":"Feature","value":"min_wal_size / max_wal_size","count":2},{"name":"Feature","value":"sslinfo","count":2},{"name":"Feature","value":"tcn","count":2},{"name":"Feature","value":"unnest/array_agg","count":2},{"name":"arch-sublayer","value":"wal-receiver","count":2},{"name":"Feature","value":"CREATE PROCEDURE syntax for SQL stored procedures","count":1},{"name":"Feature","value":"Non-superuser language creation","count":1},{"name":"Feature","value":"ON COMMIT clause for CREATE TEMPORARY TABLE","count":1},{"name":"Feature","value":"Parallel FULL and RIGHT joins","count":1},{"name":"Feature","value":"Per user/database server configuration settings","count":1},{"name":"Feature","value":"SIMD support for ARM","count":1},{"name":"Feature","value":"SQL/JSON path expressions","count":1},{"name":"Feature","value":"SQL/JSON query functions","count":1},{"name":"Feature","value":"Tablespaces","count":1},{"name":"Feature","value":"Test Feature","count":1},{"name":"Feature","value":"dblink","count":1},{"name":"Feature","value":"lz4 and Zstandard (zstd) compression for WAL full page writes","count":1},{"name":"Feature","value":"pageinspect","count":1},{"name":"Feature","value":"smallserial type","count":1},{"name":"arch-sublayer","value":"wal-sender","count":1}]}