{
  "methods": [
    {
      "method_name": "brinhandler",
      "file_path": "backend/access/brin/brin.c",
      "line_number": 246,
      "comment": "/*\n * BRIN handler function: return IndexAmRoutine with access method parameters\n * and callbacks.\n */",
      "description": "BRIN handler function: return IndexAmRoutine with access method parameters    and callbacks."
    },
    {
      "method_name": "initialize_brin_insertstate",
      "file_path": "backend/access/brin/brin.c",
      "line_number": 305,
      "comment": "/*\n * Initialize a BrinInsertState to maintain state to be used across multiple\n * tuple inserts, within the same command.\n */",
      "description": "Initialize a BrinInsertState to maintain state to be used across multiple    tuple inserts, within the same command."
    },
    {
      "method_name": "brininsert",
      "file_path": "backend/access/brin/brin.c",
      "line_number": 334,
      "comment": "/*\n * A tuple in the heap is being inserted.  To keep a brin index up to date,\n * we need to obtain the relevant index tuple and compare its stored values\n * with those of the new tuple.  If the tuple values are not consistent with\n * the summary tuple, we need to update the index tuple.\n *\n * If autosummarization is enabled, check if we need to summarize the previous\n * page range.\n *\n * If the range is not currently summarized (i.e. the revmap returns NULL for\n * it), there's nothing to do for this tuple.\n */",
      "description": "A tuple in the heap is being inserted."
    },
    {
      "method_name": "brininsertcleanup",
      "file_path": "backend/access/brin/brin.c",
      "line_number": 502,
      "comment": "/*\n * Callback to clean up the BrinInsertState once all tuple inserts are done.\n */",
      "description": "Callback to clean up the BrinInsertState once all tuple inserts are done."
    },
    {
      "method_name": "brinbeginscan",
      "file_path": "backend/access/brin/brin.c",
      "line_number": 529,
      "comment": "/*\n * Initialize state for a BRIN index scan.\n *\n * We read the metapage here to determine the pages-per-range number that this\n * index was built with.  Note that since this cannot be changed while we're\n * holding lock on index, it's not necessary to recompute it during brinrescan.\n */",
      "description": "Initialize state for a BRIN index scan."
    },
    {
      "method_name": "bringetbitmap",
      "file_path": "backend/access/brin/brin.c",
      "line_number": 557,
      "comment": "/*\n * Execute the index scan.\n *\n * This works by reading index TIDs from the revmap, and obtaining the index\n * tuples pointed to by them; the summary values in the index tuples are\n * compared to the scan keys.  We return into the TID bitmap all the pages in\n * ranges corresponding to index tuples that match the scan keys.\n *\n * If a TID from the revmap is read as InvalidTID, we know that range is\n * unsummarized.  Pages in those ranges need to be returned regardless of scan\n * keys.\n */",
      "description": "Execute the index scan."
    },
    {
      "method_name": "brinrescan",
      "file_path": "backend/access/brin/brin.c",
      "line_number": 947,
      "comment": "/*\n * Re-initialize state for a BRIN index scan\n */",
      "description": "Re-initialize state for a BRIN index scan"
    },
    {
      "method_name": "brinendscan",
      "file_path": "backend/access/brin/brin.c",
      "line_number": 967,
      "comment": "/*\n * Close down a BRIN index scan\n */",
      "description": "Close down a BRIN index scan"
    },
    {
      "method_name": "brinbuildCallback",
      "file_path": "backend/access/brin/brin.c",
      "line_number": 984,
      "comment": "/*\n * Per-heap-tuple callback for table_index_build_scan.\n *\n * Note we don't worry about the page range at the end of the table here; it is\n * present in the build state struct after we're called the last time, but not\n * inserted into the index.  Caller must ensure to do so, if appropriate.\n */",
      "description": "Per-heap-tuple callback for table_index_build_scan."
    },
    {
      "method_name": "brinbuildCallbackParallel",
      "file_path": "backend/access/brin/brin.c",
      "line_number": 1035,
      "comment": "/*\n * Per-heap-tuple callback for table_index_build_scan with parallelism.\n *\n * A version of the callback used by parallel index builds. The main difference\n * is that instead of writing the BRIN tuples into the index, we write them\n * into a shared tuplesort, and leave the insertion up to the leader (which may\n * reorder them a bit etc.). The callback also does not generate empty ranges,\n * those will be added by the leader when merging results from workers.\n */",
      "description": "Per-heap-tuple callback for table_index_build_scan with parallelism."
    },
    {
      "method_name": "brinbuild",
      "file_path": "backend/access/brin/brin.c",
      "line_number": 1094,
      "comment": "/*\n * brinbuild() -- build a new BRIN index.\n */",
      "description": "brinbuild() -- build a new BRIN index."
    },
    {
      "method_name": "brin_minmax_multi_distance_date",
      "file_path": "backend/access/brin/brin_minmax_multi.c",
      "line_number": 2079,
      "comment": "/*\n * Compute the approximate distance between two dates.\n */",
      "description": "Compute the approximate distance between two dates."
    },
    {
      "method_name": "brin_minmax_multi_distance_time",
      "file_path": "backend/access/brin/brin_minmax_multi.c",
      "line_number": 2098,
      "comment": "/*\n * Compute the approximate distance between two time (without tz) values.\n *\n * TimeADT is just an int64, so we simply subtract the values directly.\n */",
      "description": "Compute the approximate distance between two time (without tz) values.       TimeADT is just an int64, so we simply subtract the values directly."
    },
    {
      "method_name": "brin_minmax_multi_distance_timetz",
      "file_path": "backend/access/brin/brin_minmax_multi.c",
      "line_number": 2118,
      "comment": "/*\n * Compute the approximate distance between two timetz values.\n *\n * Simply subtracts the TimeADT (int64) values embedded in TimeTzADT.\n */",
      "description": "Compute the approximate distance between two timetz values.       Simply subtracts the TimeADT (int64) values embedded in TimeTzADT."
    },
    {
      "method_name": "brin_minmax_multi_distance_timestamp",
      "file_path": "backend/access/brin/brin_minmax_multi.c",
      "line_number": 2136,
      "comment": "/*\n * Compute the distance between two timestamp values.\n */",
      "description": "Compute the distance between two timestamp values."
    },
    {
      "method_name": "brin_minmax_multi_distance_interval",
      "file_path": "backend/access/brin/brin_minmax_multi.c",
      "line_number": 2154,
      "comment": "/*\n * Compute the distance between two interval values.\n */",
      "description": "Compute the distance between two interval values."
    },
    {
      "method_name": "brin_minmax_multi_distance_pg_lsn",
      "file_path": "backend/access/brin/brin_minmax_multi.c",
      "line_number": 2190,
      "comment": "/*\n * Compute the distance between two pg_lsn values.\n *\n * LSN is just an int64 encoding position in the stream, so just subtract\n * those int64 values directly.\n */",
      "description": "Compute the distance between two pg_lsn values.       LSN is just an int64 encoding position in the stream, so just subtract    those int64 values directly."
    },
    {
      "method_name": "brin_minmax_multi_distance_macaddr",
      "file_path": "backend/access/brin/brin_minmax_multi.c",
      "line_number": 2211,
      "comment": "/*\n * Compute the distance between two macaddr values.\n *\n * mac addresses are treated as 6 unsigned chars, so do the same thing we\n * already do for UUID values.\n */",
      "description": "Compute the distance between two macaddr values.       mac addresses are treated as 6 unsigned chars, so do the same thing we    already do for UUID values."
    },
    {
      "method_name": "brin_minmax_multi_distance_macaddr8",
      "file_path": "backend/access/brin/brin_minmax_multi.c",
      "line_number": 2248,
      "comment": "/*\n * Compute the distance between two macaddr8 values.\n *\n * macaddr8 addresses are 8 unsigned chars, so do the same thing we\n * already do for UUID values.\n */",
      "description": "Compute the distance between two macaddr8 values.       macaddr8 addresses are 8 unsigned chars, so do the same thing we    already do for UUID values."
    },
    {
      "method_name": "brin_minmax_multi_distance_inet",
      "file_path": "backend/access/brin/brin_minmax_multi.c",
      "line_number": 2296,
      "comment": "/*\n * Compute the distance between two inet values.\n *\n * The distance is defined as the difference between 32-bit/128-bit values,\n * depending on the IP version. The distance is computed by subtracting\n * the bytes and normalizing it to [0,1] range for each IP family.\n * Addresses from different families are considered to be in maximum\n * distance, which is 1.0.\n *\n * XXX Does this need to consider the mask (bits)?  For now, it's ignored.\n */",
      "description": "Compute the distance between two inet values."
    },
    {
      "method_name": "brin_minmax_multi_add_value",
      "file_path": "backend/access/brin/brin_minmax_multi.c",
      "line_number": 2411,
      "comment": "/*\n * Examine the given index tuple (which contains the partial status of a\n * certain page range) by comparing it to the given value that comes from\n * another heap tuple.  If the new value is outside the min/max range\n * specified by the existing tuple values, update the index tuple and return\n * true.  Otherwise, return false and do not modify in this case.\n */",
      "description": "Examine the given index tuple (which contains the partial status of a    certain page range) by comparing it to the given value that comes from    another heap tuple."
    },
    {
      "method_name": "brin_minmax_multi_consistent",
      "file_path": "backend/access/brin/brin_minmax_multi.c",
      "line_number": 2548,
      "comment": "/*\n * Given an index tuple corresponding to a certain page range and a scan key,\n * return whether the scan key is consistent with the index tuple's min/max\n * values.  Return true if so, false otherwise.\n */",
      "description": "Given an index tuple corresponding to a certain page range and a scan key,    return whether the scan key is consistent with the index tuple's min/max    values.  Return true if so, false otherwise."
    },
    {
      "method_name": "brin_minmax_multi_union",
      "file_path": "backend/access/brin/brin_minmax_multi.c",
      "line_number": 2734,
      "comment": "/*\n * Given two BrinValues, update the first of them as a union of the summary\n * values contained in both.  The second one is untouched.\n */",
      "description": "Given two BrinValues, update the first of them as a union of the summary    values contained in both.  The second one is untouched."
    },
    {
      "method_name": "minmax_multi_get_procinfo",
      "file_path": "backend/access/brin/brin_minmax_multi.c",
      "line_number": 2862,
      "comment": "/*\n * Cache and return minmax multi opclass support procedure\n *\n * Return the procedure corresponding to the given function support number\n * or null if it does not exist.\n */",
      "description": "Cache and return minmax multi opclass support procedure       Return the procedure corresponding to the given function support number    or null if it does not exist."
    },
    {
      "method_name": "minmax_multi_get_strategy_procinfo",
      "file_path": "backend/access/brin/brin_minmax_multi.c",
      "line_number": 2898,
      "comment": "/*\n * Cache and return the procedure for the given strategy.\n *\n * Note: this function mirrors minmax_multi_get_strategy_procinfo; see notes\n * there.  If changes are made here, see that function too.\n */",
      "description": "Cache and return the procedure for the given strategy.       Note: this function mirrors minmax_multi_get_strategy_procinfo; see notes    there.  If changes are made here, see that function too."
    },
    {
      "method_name": "brin_minmax_multi_summary_in",
      "file_path": "backend/access/brin/brin_minmax_multi.c",
      "line_number": 2975,
      "comment": "/*\n * brin_minmax_multi_summary_in\n *\t\t- input routine for type brin_minmax_multi_summary.\n *\n * brin_minmax_multi_summary is only used internally to represent summaries\n * in BRIN minmax-multi indexes, so it has no operations of its own, and we\n * disallow input too.\n */",
      "description": "brin_minmax_multi_summary_in   \t\t- input routine for type brin_minmax_multi_summary."
    },
    {
      "method_name": "brin_minmax_multi_summary_out",
      "file_path": "backend/access/brin/brin_minmax_multi.c",
      "line_number": 2997,
      "comment": "/*\n * brin_minmax_multi_summary_out\n *\t\t- output routine for type brin_minmax_multi_summary.\n *\n * BRIN minmax-multi summaries are serialized into a bytea value, but we\n * want to output something nicer humans can understand.\n */",
      "description": "brin_minmax_multi_summary_out   \t\t- output routine for type brin_minmax_multi_summary."
    },
    {
      "method_name": "brin_minmax_multi_summary_recv",
      "file_path": "backend/access/brin/brin_minmax_multi.c",
      "line_number": 3116,
      "comment": "/*\n * brin_minmax_multi_summary_recv\n *\t\t- binary input routine for type brin_minmax_multi_summary.\n */",
      "description": "brin_minmax_multi_summary_recv   \t\t- binary input routine for type brin_minmax_multi_summary."
    },
    {
      "method_name": "brin_minmax_multi_summary_send",
      "file_path": "backend/access/brin/brin_minmax_multi.c",
      "line_number": 3133,
      "comment": "/*\n * brin_minmax_multi_summary_send\n *\t\t- binary output routine for type brin_minmax_multi_summary.\n *\n * BRIN minmax-multi summaries are serialized in a bytea value (although\n * the type is named differently), so let's just send that.\n */",
      "description": "brin_minmax_multi_summary_send   \t\t- binary output routine for type brin_minmax_multi_summary."
    },
    {
      "method_name": "brin_doupdate",
      "file_path": "backend/access/brin/brin_pageops.c",
      "line_number": 52,
      "comment": "/*\n * Update tuple origtup (size origsz), located in offset oldoff of buffer\n * oldbuf, to newtup (size newsz) as summary tuple for the page range starting\n * at heapBlk.  oldbuf must not be locked on entry, and is not locked at exit.\n *\n * If samepage is true, attempt to put the new tuple in the same page, but if\n * there's no room, use some other one.\n *\n * If the update is successful, return true; the revmap is updated to point to\n * the new tuple.  If the update is not done for whatever reason, return false.\n * Caller may retry the update if this happens.\n */",
      "description": "Update tuple origtup (size origsz), located in offset oldoff of buffer    oldbuf, to newtup (size newsz) as summary tuple for the page range starting    at heapBlk."
    },
    {
      "method_name": "brin_can_do_samepage_update",
      "file_path": "backend/access/brin/brin_pageops.c",
      "line_number": 322,
      "comment": "/*\n * Return whether brin_doupdate can do a samepage update.\n */",
      "description": "Return whether brin_doupdate can do a samepage update."
    },
    {
      "method_name": "brin_doinsert",
      "file_path": "backend/access/brin/brin_pageops.c",
      "line_number": 341,
      "comment": "/*\n * Insert an index tuple into the index relation.  The revmap is updated to\n * mark the range containing the given page as pointing to the inserted entry.\n * A WAL record is written.\n *\n * The buffer, if valid, is first checked for free space to insert the new\n * entry; if there isn't enough, a new buffer is obtained and pinned.  No\n * buffer lock must be held on entry, no buffer lock is held on exit.\n *\n * Return value is the offset number where the tuple was inserted.\n */",
      "description": "Insert an index tuple into the index relation."
    },
    {
      "method_name": "brin_page_init",
      "file_path": "backend/access/brin/brin_pageops.c",
      "line_number": 474,
      "comment": "/*\n * Initialize a page with the given type.\n *\n * Caller is responsible for marking it dirty, as appropriate.\n */",
      "description": "Initialize a page with the given type.       Caller is responsible for marking it dirty, as appropriate."
    },
    {
      "method_name": "brin_metapage_init",
      "file_path": "backend/access/brin/brin_pageops.c",
      "line_number": 485,
      "comment": "/*\n * Initialize a new BRIN index's metapage.\n */",
      "description": "Initialize a new BRIN index's metapage."
    },
    {
      "method_name": "brin_start_evacuating_page",
      "file_path": "backend/access/brin/brin_pageops.c",
      "line_number": 523,
      "comment": "/*\n * Initiate page evacuation protocol.\n *\n * The page must be locked in exclusive mode by the caller.\n *\n * If the page is not yet initialized or empty, return false without doing\n * anything; it can be used for revmap without any further changes.  If it\n * contains tuples, mark it for evacuation and return true.\n */",
      "description": "Initiate page evacuation protocol."
    },
    {
      "method_name": "brin_evacuate_page",
      "file_path": "backend/access/brin/brin_pageops.c",
      "line_number": 563,
      "comment": "/*\n * Move all tuples out of a page.\n *\n * The caller must hold lock on the page. The lock and pin are released.\n */",
      "description": "Move all tuples out of a page.       The caller must hold lock on the page. The lock and pin are released."
    },
    {
      "method_name": "brin_page_cleanup",
      "file_path": "backend/access/brin/brin_pageops.c",
      "line_number": 623,
      "comment": "/*\n * Given a BRIN index page, initialize it if necessary, and record its\n * current free space in the FSM.\n *\n * The main use for this is when, during vacuuming, an uninitialized page is\n * found, which could be the result of relation extension followed by a crash\n * before the page can be used.\n *\n * Here, we don't bother to update upper FSM pages, instead expecting that our\n * caller (brin_vacuum_scan) will fix them at the end of the scan.  Elsewhere\n * in this file, it's generally a good idea to propagate additions of free\n * space into the upper FSM pages immediately.\n */",
      "description": "Given a BRIN index page, initialize it if necessary, and record its    current free space in the FSM."
    },
    {
      "method_name": "brin_getinsertbuffer",
      "file_path": "backend/access/brin/brin_pageops.c",
      "line_number": 689,
      "comment": "/*\n * Return a pinned and exclusively locked buffer which can be used to insert an\n * index item of size itemsz (caller must ensure not to request sizes\n * impossible to fulfill).  If oldbuf is a valid buffer, it is also locked (in\n * an order determined to avoid deadlocks).\n *\n * If we find that the old page is no longer a regular index page (because\n * of a revmap extension), the old buffer is unlocked and we return\n * InvalidBuffer.\n *\n * If there's no existing page with enough free space to accommodate the new\n * item, the relation is extended.  If this happens, *extended is set to true,\n * and it is the caller's responsibility to initialize the page (and WAL-log\n * that fact) prior to use.  The caller should also update the FSM with the\n * page's remaining free space after the insertion.\n *\n * Note that the caller is not expected to update FSM unless *extended is set\n * true.  This policy means that we'll update FSM when a page is created, and\n * when it's found to have too little space for a desired tuple insertion,\n * but not every single time we add a tuple to the page.\n *\n * Note that in some corner cases it is possible for this routine to extend\n * the relation and then not return the new page.  It is this routine's\n * responsibility to WAL-log the page initialization and to record the page in\n * FSM if that happens, since the caller certainly can't do it.\n */",
      "description": "Return a pinned and exclusively locked buffer which can be used to insert an    index item of size itemsz (caller must ensure not to request sizes    impossible to fulfill)."
    },
    {
      "method_name": "brin_initialize_empty_new_buffer",
      "file_path": "backend/access/brin/brin_pageops.c",
      "line_number": 883,
      "comment": "/*\n * Initialize a page as an empty regular BRIN page, WAL-log this, and record\n * the page in FSM.\n *\n * There are several corner situations in which we extend the relation to\n * obtain a new page and later find that we cannot use it immediately.  When\n * that happens, we don't want to leave the page go unrecorded in FSM, because\n * there is no mechanism to get the space back and the index would bloat.\n * Also, because we would not WAL-log the action that would initialize the\n * page, the page would go uninitialized in a standby (or after recovery).\n *\n * While we record the page in FSM here, caller is responsible for doing FSM\n * upper-page update if that seems appropriate.\n */",
      "description": "Initialize a page as an empty regular BRIN page, WAL-log this, and record    the page in FSM."
    },
    {
      "method_name": "br_page_get_freespace",
      "file_path": "backend/access/brin/brin_pageops.c",
      "line_number": 915,
      "comment": "/*\n * Return the amount of free space on a regular BRIN index page.\n *\n * If the page is not a regular page, or has been marked with the\n * BRIN_EVACUATE_PAGE flag, returns 0.\n */",
      "description": "Return the amount of free space on a regular BRIN index page.       If the page is not a regular page, or has been marked with the    BRIN_EVACUATE_PAGE flag, returns 0."
    },
    {
      "method_name": "brinRevmapInitialize",
      "file_path": "backend/access/brin/brin_revmap.c",
      "line_number": 69,
      "comment": "/*\n * Initialize an access object for a range map.  This must be freed by\n * brinRevmapTerminate when caller is done with it.\n */",
      "description": "Initialize an access object for a range map.  This must be freed by    brinRevmapTerminate when caller is done with it."
    },
    {
      "method_name": "brinRevmapTerminate",
      "file_path": "backend/access/brin/brin_revmap.c",
      "line_number": 99,
      "comment": "/*\n * Release resources associated with a revmap access object.\n */",
      "description": "Release resources associated with a revmap access object."
    },
    {
      "method_name": "brinRevmapExtend",
      "file_path": "backend/access/brin/brin_revmap.c",
      "line_number": 111,
      "comment": "/*\n * Extend the revmap to cover the given heap block number.\n */",
      "description": "Extend the revmap to cover the given heap block number."
    },
    {
      "method_name": "brinLockRevmapPageForUpdate",
      "file_path": "backend/access/brin/brin_revmap.c",
      "line_number": 133,
      "comment": "/*\n * Prepare to insert an entry into the revmap; the revmap buffer in which the\n * entry is to reside is locked and returned.  Most callers should call\n * brinRevmapExtend beforehand, as this routine does not extend the revmap if\n * it's not long enough.\n *\n * The returned buffer is also recorded in the revmap struct; finishing that\n * releases the buffer, therefore the caller needn't do it explicitly.\n */",
      "description": "Prepare to insert an entry into the revmap; the revmap buffer in which the    entry is to reside is locked and returned."
    },
    {
      "method_name": "brinSetHeapBlockItemptr",
      "file_path": "backend/access/brin/brin_revmap.c",
      "line_number": 154,
      "comment": "/*\n * In the given revmap buffer (locked appropriately by caller), which is used\n * in a BRIN index of pagesPerRange pages per range, set the element\n * corresponding to heap block number heapBlk to the given TID.\n *\n * Once the operation is complete, the caller must update the LSN on the\n * returned buffer.\n *\n * This is used both in regular operation and during WAL replay.\n */",
      "description": "In the given revmap buffer (locked appropriately by caller), which is used    in a BRIN index of pagesPerRange pages per range, set the element    corresponding to heap block number heapBlk to the given TID."
    },
    {
      "method_name": "brinGetTupleForHeapBlock",
      "file_path": "backend/access/brin/brin_revmap.c",
      "line_number": 193,
      "comment": "/*\n * Fetch the BrinTuple for a given heap block.\n *\n * The buffer containing the tuple is locked, and returned in *buf.  The\n * returned tuple points to the shared buffer and must not be freed; if caller\n * wants to use it after releasing the buffer lock, it must create its own\n * palloc'ed copy.  As an optimization, the caller can pass a pinned buffer\n * *buf on entry, which will avoid a pin-unpin cycle when the next tuple is on\n * the same page as a previous one.\n *\n * If no tuple is found for the given heap range, returns NULL. In that case,\n * *buf might still be updated (and pin must be released by caller), but it's\n * not locked.\n *\n * The output tuple offset within the buffer is returned in *off, and its size\n * is returned in *size.\n */",
      "description": "Fetch the BrinTuple for a given heap block."
    },
    {
      "method_name": "brinRevmapDesummarizeRange",
      "file_path": "backend/access/brin/brin_revmap.c",
      "line_number": 322,
      "comment": "/*\n * Delete an index tuple, marking a page range as unsummarized.\n *\n * Index must be locked in ShareUpdateExclusiveLock mode.\n *\n * Return false if caller should retry.\n */",
      "description": "Delete an index tuple, marking a page range as unsummarized.       Index must be locked in ShareUpdateExclusiveLock mode.       Return false if caller should retry."
    },
    {
      "method_name": "revmap_get_blkno",
      "file_path": "backend/access/brin/brin_revmap.c",
      "line_number": 441,
      "comment": "/*\n * Given a heap block number, find the corresponding physical revmap block\n * number and return it.  If the revmap page hasn't been allocated yet, return\n * InvalidBlockNumber.\n */",
      "description": "Given a heap block number, find the corresponding physical revmap block    number and return it.  If the revmap page hasn't been allocated yet, return    InvalidBlockNumber."
    },
    {
      "method_name": "revmap_get_buffer",
      "file_path": "backend/access/brin/brin_revmap.c",
      "line_number": 462,
      "comment": "/*\n * Obtain and return a buffer containing the revmap page for the given heap\n * page.  The revmap must have been previously extended to cover that page.\n * The returned buffer is also recorded in the revmap struct; finishing that\n * releases the buffer, therefore the caller needn't do it explicitly.\n */",
      "description": "Obtain and return a buffer containing the revmap page for the given heap    page."
    },
    {
      "method_name": "revmap_extend_and_get_blkno",
      "file_path": "backend/access/brin/brin_revmap.c",
      "line_number": 499,
      "comment": "/*\n * Given a heap block number, find the corresponding physical revmap block\n * number and return it. If the revmap page hasn't been allocated yet, extend\n * the revmap until it is.\n */",
      "description": "Given a heap block number, find the corresponding physical revmap block    number and return it. If the revmap page hasn't been allocated yet, extend    the revmap until it is."
    },
    {
      "method_name": "revmap_physical_extend",
      "file_path": "backend/access/brin/brin_revmap.c",
      "line_number": 521,
      "comment": "/*\n * Try to extend the revmap by one page.  This might not happen for a number of\n * reasons; caller is expected to retry until the expected outcome is obtained.\n */",
      "description": "Try to extend the revmap by one page.  This might not happen for a number of    reasons; caller is expected to retry until the expected outcome is obtained."
    },
    {
      "method_name": "brtuple_disk_tupdesc",
      "file_path": "backend/access/brin/brin_tuple.c",
      "line_number": 60,
      "comment": "/*\n * Return a tuple descriptor used for on-disk storage of BRIN tuples.\n */",
      "description": "Return a tuple descriptor used for on-disk storage of BRIN tuples."
    },
    {
      "method_name": "brin_form_tuple",
      "file_path": "backend/access/brin/brin_tuple.c",
      "line_number": 98,
      "comment": "/*\n * Generate a new on-disk tuple to be inserted in a BRIN index.\n *\n * See brin_form_placeholder_tuple if you touch this.\n */",
      "description": "Generate a new on-disk tuple to be inserted in a BRIN index.       See brin_form_placeholder_tuple if you touch this."
    },
    {
      "method_name": "brin_form_placeholder_tuple",
      "file_path": "backend/access/brin/brin_tuple.c",
      "line_number": 387,
      "comment": "/*\n * Generate a new on-disk tuple with no data values, marked as placeholder.\n *\n * This is a cut-down version of brin_form_tuple.\n */",
      "description": "Generate a new on-disk tuple with no data values, marked as placeholder.       This is a cut-down version of brin_form_tuple."
    },
    {
      "method_name": "brin_free_tuple",
      "file_path": "backend/access/brin/brin_tuple.c",
      "line_number": 432,
      "comment": "/*\n * Free a tuple created by brin_form_tuple\n */",
      "description": "Free a tuple created by brin_form_tuple"
    },
    {
      "method_name": "brin_copy_tuple",
      "file_path": "backend/access/brin/brin_tuple.c",
      "line_number": 445,
      "comment": "/*\n * Given a brin tuple of size len, create a copy of it.  If 'dest' is not\n * NULL, its size is destsz, and can be used as output buffer; if the tuple\n * to be copied does not fit, it is enlarged by repalloc, and the size is\n * updated to match.  This avoids palloc/free cycles when many brin tuples\n * are being processed in loops.\n */",
      "description": "Given a brin tuple of size len, create a copy of it."
    },
    {
      "method_name": "brin_tuples_equal",
      "file_path": "backend/access/brin/brin_tuple.c",
      "line_number": 464,
      "comment": "/*\n * Return whether two BrinTuples are bitwise identical.\n */",
      "description": "Return whether two BrinTuples are bitwise identical."
    },
    {
      "method_name": "brin_new_memtuple",
      "file_path": "backend/access/brin/brin_tuple.c",
      "line_number": 481,
      "comment": "/*\n * Create a new BrinMemTuple from scratch, and initialize it to an empty\n * state.\n *\n * Note: we don't provide any means to free a deformed tuple, so make sure to\n * use a temporary memory context.\n */",
      "description": "Create a new BrinMemTuple from scratch, and initialize it to an empty    state.       Note: we don't provide any means to free a deformed tuple, so make sure to    use a temporary memory context."
    },
    {
      "method_name": "brin_memtuple_initialize",
      "file_path": "backend/access/brin/brin_tuple.c",
      "line_number": 510,
      "comment": "/*\n * Reset a BrinMemTuple to initial state.  We return the same tuple, for\n * notational convenience.\n */",
      "description": "Reset a BrinMemTuple to initial state.  We return the same tuple, for    notational convenience."
    },
    {
      "method_name": "heap_copy_minimal_tuple",
      "file_path": "backend/access/common/heaptuple.c",
      "line_number": 1534,
      "comment": "/*\n * heap_copy_minimal_tuple\n *\t\tcopy a MinimalTuple\n *\n * The result is allocated in the current memory context.\n */",
      "description": "heap_copy_minimal_tuple   \t\tcopy a MinimalTuple       The result is allocated in the current memory context."
    },
    {
      "method_name": "heap_tuple_from_minimal_tuple",
      "file_path": "backend/access/common/heaptuple.c",
      "line_number": 1553,
      "comment": "/*\n * heap_tuple_from_minimal_tuple\n *\t\tcreate a HeapTuple by copying from a MinimalTuple;\n *\t\tsystem columns are filled with zeroes\n *\n * The result is allocated in the current memory context.\n * The HeapTuple struct, tuple header, and tuple data are all allocated\n * as a single palloc() block.\n */",
      "description": "heap_tuple_from_minimal_tuple   \t\tcreate a HeapTuple by copying from a MinimalTuple;   \t\tsystem columns are filled with zeroes       The result is allocated in the current memory context."
    },
    {
      "method_name": "minimal_tuple_from_heap_tuple",
      "file_path": "backend/access/common/heaptuple.c",
      "line_number": 1575,
      "comment": "/*\n * minimal_tuple_from_heap_tuple\n *\t\tcreate a MinimalTuple by copying from a HeapTuple\n *\n * The result is allocated in the current memory context.\n */",
      "description": "minimal_tuple_from_heap_tuple   \t\tcreate a MinimalTuple by copying from a HeapTuple       The result is allocated in the current memory context."
    },
    {
      "method_name": "varsize_any",
      "file_path": "backend/access/common/heaptuple.c",
      "line_number": 1593,
      "comment": "/*\n * This mainly exists so JIT can inline the definition, but it's also\n * sometimes useful in debugging sessions.\n */",
      "description": "This mainly exists so JIT can inline the definition, but it's also    sometimes useful in debugging sessions."
    },
    {
      "method_name": "index_form_tuple",
      "file_path": "backend/access/common/indextuple.c",
      "line_number": 43,
      "comment": "/* ----------------\n  *\t\tindex_form_tuple\n  *\n  *\t\tAs index_form_tuple_context, but allocates the returned tuple in the\n  *\t\tCurrentMemoryContext.\n  * ----------------\n  */",
      "description": "----------------    \t\tindex_form_tuple        \t\tAs index_form_tuple_context, but allocates the returned tuple in the    \t\tCurrentMemoryContext.     ----------------"
    },
    {
      "method_name": "index_form_tuple_context",
      "file_path": "backend/access/common/indextuple.c",
      "line_number": 64,
      "comment": "/* ----------------\n *\t\tindex_form_tuple_context\n *\n *\t\tThis shouldn't leak any memory; otherwise, callers such as\n *\t\ttuplesort_putindextuplevalues() will be very unhappy.\n *\n *\t\tThis shouldn't perform external table access provided caller\n *\t\tdoes not pass values that are stored EXTERNAL.\n *\n *\t\tAllocates returned tuple in provided 'context'.\n * ----------------\n */",
      "description": "----------------   \t\tindex_form_tuple_context      \t\tThis shouldn't leak any memory; otherwise, callers such as   \t\ttuplesort_putindextuplevalues() will be very unhappy."
    },
    {
      "method_name": "nocache_index_getattr",
      "file_path": "backend/access/common/indextuple.c",
      "line_number": 240,
      "comment": "/* ----------------\n *\t\tnocache_index_getattr\n *\n *\t\tThis gets called from index_getattr() macro, and only in cases\n *\t\twhere we can't use cacheoffset and the value is not null.\n *\n *\t\tThis caches attribute offsets in the attribute descriptor.\n *\n *\t\tAn alternative way to speed things up would be to cache offsets\n *\t\twith the tuple, but that seems more difficult unless you take\n *\t\tthe storage hit of actually putting those offsets into the\n *\t\ttuple you send to disk.  Yuck.\n *\n *\t\tThis scheme will be slightly slower than that, but should\n *\t\tperform well for queries which hit large #'s of tuples.  After\n *\t\tyou cache the offsets once, examining all the other tuples using\n *\t\tthe same attribute descriptor will go much quicker. -cim 5/4/91\n * ----------------\n */",
      "description": "----------------   \t\tnocache_index_getattr      \t\tThis gets called from index_getattr() macro, and only in cases   \t\twhere we can't use cacheoffset and the value is not null."
    },
    {
      "method_name": "index_deform_tuple",
      "file_path": "backend/access/common/indextuple.c",
      "line_number": 455,
      "comment": "/*\n * Convert an index tuple into Datum/isnull arrays.\n *\n * The caller must allocate sufficient storage for the output arrays.\n * (INDEX_MAX_KEYS entries should be enough.)\n *\n * This is nearly the same as heap_deform_tuple(), but for IndexTuples.\n * One difference is that the tuple should never have any missing columns.\n */",
      "description": "Convert an index tuple into Datum/isnull arrays."
    },
    {
      "method_name": "index_deform_tuple_internal",
      "file_path": "backend/access/common/indextuple.c",
      "line_number": 478,
      "comment": "/*\n * Convert an index tuple into Datum/isnull arrays,\n * without assuming any specific layout of the index tuple header.\n *\n * Caller must supply pointer to data area, pointer to nulls bitmap\n * (which can be NULL if !hasnulls), and hasnulls flag.\n */",
      "description": "Convert an index tuple into Datum/isnull arrays,    without assuming any specific layout of the index tuple header."
    },
    {
      "method_name": "CopyIndexTuple",
      "file_path": "backend/access/common/indextuple.c",
      "line_number": 546,
      "comment": "/*\n * Create a palloc'd copy of an index tuple.\n */",
      "description": "Create a palloc'd copy of an index tuple."
    },
    {
      "method_name": "index_truncate_tuple",
      "file_path": "backend/access/common/indextuple.c",
      "line_number": 575,
      "comment": "/*\n * Create a palloc'd copy of an index tuple, leaving only the first\n * leavenatts attributes remaining.\n *\n * Truncation is guaranteed to result in an index tuple that is no\n * larger than the original.  It is safe to use the IndexTuple with\n * the original tuple descriptor, but caller must avoid actually\n * accessing truncated attributes from returned tuple!  In practice\n * this means that index_getattr() must be called with special care,\n * and that the truncated tuple should only ever be accessed by code\n * under caller's direct control.\n *\n * It's safe to call this function with a buffer lock held, since it\n * never performs external table access.  If it ever became possible\n * for index tuples to contain EXTERNAL TOAST values, then this would\n * have to be revisited.\n */",
      "description": "Create a palloc'd copy of an index tuple, leaving only the first    leavenatts attributes remaining."
    },
    {
      "method_name": "printsimple_startup",
      "file_path": "backend/access/common/printsimple.c",
      "line_number": 30,
      "comment": "/*\n * At startup time, send a RowDescription message.\n */",
      "description": "At startup time, send a RowDescription message."
    },
    {
      "method_name": "printsimple",
      "file_path": "backend/access/common/printsimple.c",
      "line_number": 58,
      "comment": "/*\n * For each tuple, send a DataRow message.\n */",
      "description": "For each tuple, send a DataRow message."
    },
    {
      "method_name": "printtup_create_DR",
      "file_path": "backend/access/common/printtup.c",
      "line_number": 70,
      "comment": "/* ----------------\n *\t\tInitialize: create a DestReceiver for printtup\n * ----------------\n */",
      "description": "----------------   \t\tInitialize: create a DestReceiver for printtup    ----------------"
    },
    {
      "method_name": "SetRemoteDestReceiverParams",
      "file_path": "backend/access/common/printtup.c",
      "line_number": 99,
      "comment": "/*\n * Set parameters for a DestRemote (or DestRemoteExecute) receiver\n */",
      "description": "Set parameters for a DestRemote (or DestRemoteExecute) receiver"
    },
    {
      "method_name": "printtup_startup",
      "file_path": "backend/access/common/printtup.c",
      "line_number": 110,
      "comment": "/*\n * Set parameters for a DestRemote (or DestRemoteExecute) receiver\n */",
      "description": "Set parameters for a DestRemote (or DestRemoteExecute) receiver"
    },
    {
      "method_name": "SendRowDescriptionMessage",
      "file_path": "backend/access/common/printtup.c",
      "line_number": 165,
      "comment": "/*\n * SendRowDescriptionMessage --- send a RowDescription message to the frontend\n *\n * Notes: the TupleDesc has typically been manufactured by ExecTypeFromTL()\n * or some similar function; it does not contain a full set of fields.\n * The targetlist will be NIL when executing a utility function that does\n * not have a plan.  If the targetlist isn't NIL then it is a Query node's\n * targetlist; it is up to us to ignore resjunk columns in it.  The formats[]\n * array pointer might be NULL (if we are doing Describe on a prepared stmt);\n * send zeroes for the format codes in that case.\n */",
      "description": "SendRowDescriptionMessage --- send a RowDescription message to the frontend       Notes: the TupleDesc has typically been manufactured by ExecTypeFromTL()    or some similar function; it does not contain a full set of fields."
    },
    {
      "method_name": "printtup_prepare_info",
      "file_path": "backend/access/common/printtup.c",
      "line_number": 249,
      "comment": "/*\n * Get the lookup info that printtup() needs\n */",
      "description": "Get the lookup info that printtup() needs"
    },
    {
      "method_name": "printtup",
      "file_path": "backend/access/common/printtup.c",
      "line_number": 303,
      "comment": "/* ----------------\n *\t\tprinttup --- send a tuple to the client\n *\n * Note: if you change this function, see also serializeAnalyzeReceive\n * in explain.c, which is meant to replicate the computations done here.\n * ----------------\n */",
      "description": "----------------   \t\tprinttup --- send a tuple to the client       Note: if you change this function, see also serializeAnalyzeReceive    in explain.c, which is meant to replicate the computations done here."
    },
    {
      "method_name": "printtup_shutdown",
      "file_path": "backend/access/common/printtup.c",
      "line_number": 388,
      "comment": "/* ----------------\n *\t\tprinttup_shutdown\n * ----------------\n */",
      "description": "----------------   \t\tprinttup_shutdown    ----------------"
    },
    {
      "method_name": "printtup_destroy",
      "file_path": "backend/access/common/printtup.c",
      "line_number": 412,
      "comment": "/* ----------------\n *\t\tprinttup_destroy\n * ----------------\n */",
      "description": "----------------   \t\tprinttup_destroy    ----------------"
    },
    {
      "method_name": "printatt",
      "file_path": "backend/access/common/printtup.c",
      "line_number": 422,
      "comment": "/* ----------------\n *\t\tprintatt\n * ----------------\n */",
      "description": "----------------   \t\tprintatt    ----------------"
    },
    {
      "method_name": "debugStartup",
      "file_path": "backend/access/common/printtup.c",
      "line_number": 443,
      "comment": "/* ----------------\n *\t\tdebugStartup - prepare to print tuples for an interactive backend\n * ----------------\n */",
      "description": "----------------   \t\tdebugStartup - prepare to print tuples for an interactive backend    ----------------"
    },
    {
      "method_name": "debugtup",
      "file_path": "backend/access/common/printtup.c",
      "line_number": 461,
      "comment": "/* ----------------\n *\t\tdebugtup - print one tuple for an interactive backend\n * ----------------\n */",
      "description": "----------------   \t\tdebugtup - print one tuple for an interactive backend    ----------------"
    },
    {
      "method_name": "tidstore_iter_extract_tids",
      "file_path": "backend/access/common/tidstore.c",
      "line_number": 579,
      "comment": "/* Extract TIDs from the given key-value pair */",
      "description": "Extract TIDs from the given key-value pair"
    },
    {
      "method_name": "pglz_compress_datum",
      "file_path": "backend/access/common/toast_compression.c",
      "line_number": 39,
      "comment": "/*\n * Compress a varlena using PGLZ.\n *\n * Returns the compressed varlena, or NULL if compression fails.\n */",
      "description": "Compress a varlena using PGLZ.       Returns the compressed varlena, or NULL if compression fails."
    },
    {
      "method_name": "pglz_decompress_datum",
      "file_path": "backend/access/common/toast_compression.c",
      "line_number": 81,
      "comment": "/*\n * Decompress a varlena that was compressed using PGLZ.\n */",
      "description": "Decompress a varlena that was compressed using PGLZ."
    },
    {
      "method_name": "pglz_decompress_datum_slice",
      "file_path": "backend/access/common/toast_compression.c",
      "line_number": 108,
      "comment": "/*\n * Decompress part of a varlena that was compressed using PGLZ.\n */",
      "description": "Decompress part of a varlena that was compressed using PGLZ."
    },
    {
      "method_name": "lz4_compress_datum",
      "file_path": "backend/access/common/toast_compression.c",
      "line_number": 138,
      "comment": "/*\n * Compress a varlena using LZ4.\n *\n * Returns the compressed varlena, or NULL if compression fails.\n */",
      "description": "Compress a varlena using LZ4.       Returns the compressed varlena, or NULL if compression fails."
    },
    {
      "method_name": "lz4_decompress_datum",
      "file_path": "backend/access/common/toast_compression.c",
      "line_number": 181,
      "comment": "/*\n * Decompress a varlena that was compressed using LZ4.\n */",
      "description": "Decompress a varlena that was compressed using LZ4."
    },
    {
      "method_name": "lz4_decompress_datum_slice",
      "file_path": "backend/access/common/toast_compression.c",
      "line_number": 214,
      "comment": "/*\n * Decompress part of a varlena that was compressed using LZ4.\n */",
      "description": "Decompress part of a varlena that was compressed using LZ4."
    },
    {
      "method_name": "toast_get_compression_id",
      "file_path": "backend/access/common/toast_compression.c",
      "line_number": 253,
      "comment": "/*\n * Extract compression ID from a varlena.\n *\n * Returns TOAST_INVALID_COMPRESSION_ID if the varlena is not compressed.\n */",
      "description": "Extract compression ID from a varlena.       Returns TOAST_INVALID_COMPRESSION_ID if the varlena is not compressed."
    },
    {
      "method_name": "CompressionNameToMethod",
      "file_path": "backend/access/common/toast_compression.c",
      "line_number": 284,
      "comment": "/*\n * CompressionNameToMethod - Get compression method from compression name\n *\n * Search in the available built-in methods.  If the compression not found\n * in the built-in methods then return InvalidCompressionMethod.\n */",
      "description": "CompressionNameToMethod - Get compression method from compression name       Search in the available built-in methods."
    },
    {
      "method_name": "GetCompressionMethodName",
      "file_path": "backend/access/common/toast_compression.c",
      "line_number": 303,
      "comment": "/*\n * GetCompressionMethodName - Get compression method name\n */",
      "description": "GetCompressionMethodName - Get compression method name"
    },
    {
      "method_name": "toast_compress_datum",
      "file_path": "backend/access/common/toast_internals.c",
      "line_number": 45,
      "comment": "/* ----------\n * toast_compress_datum -\n *\n *\tCreate a compressed version of a varlena datum\n *\n *\tIf we fail (ie, compressed result is actually bigger than original)\n *\tthen return NULL.  We must not use compressed data if it'd expand\n *\tthe tuple!\n *\n *\tWe use VAR{SIZE,DATA}_ANY so we can handle short varlenas here without\n *\tcopying them.  But we can't handle external or compressed datums.\n * ----------\n */",
      "description": "----------    toast_compress_datum -      \tCreate a compressed version of a varlena datum      \tIf we fail (ie, compressed result is actually bigger than original)   \tthen return NULL."
    },
    {
      "method_name": "toast_save_datum",
      "file_path": "backend/access/common/toast_internals.c",
      "line_number": 118,
      "comment": "/* ----------\n * toast_save_datum -\n *\n *\tSave one single datum into the secondary relation and return\n *\ta Datum reference for it.\n *\n * rel: the main relation we're working with (not the toast rel!)\n * value: datum to be pushed to toast storage\n * oldexternal: if not NULL, toast pointer previously representing the datum\n * options: options to be passed to heap_insert() for toast rows\n * ----------\n */",
      "description": "----------    toast_save_datum -      \tSave one single datum into the secondary relation and return   \ta Datum reference for it."
    },
    {
      "method_name": "toast_delete_datum",
      "file_path": "backend/access/common/toast_internals.c",
      "line_number": 384,
      "comment": "/* ----------\n * toast_delete_datum -\n *\n *\tDelete a single external stored value.\n * ----------\n */",
      "description": "----------    toast_delete_datum -      \tDelete a single external stored value.    ----------"
    },
    {
      "method_name": "toastrel_valueid_exists",
      "file_path": "backend/access/common/toast_internals.c",
      "line_number": 460,
      "comment": "/* ----------\n * toastrel_valueid_exists -\n *\n *\tTest whether a toast value with the given ID exists in the toast relation.\n *\tFor safety, we consider a value to exist if there are either live or dead\n *\ttoast rows with that ID; see notes for GetNewOidWithIndex().\n * ----------\n */",
      "description": "----------    toastrel_valueid_exists -      \tTest whether a toast value with the given ID exists in the toast relation."
    },
    {
      "method_name": "toastid_valueid_exists",
      "file_path": "backend/access/common/toast_internals.c",
      "line_number": 508,
      "comment": "/* ----------\n * toastid_valueid_exists -\n *\n *\tAs above, but work from toast rel's OID not an open relation\n * ----------\n */",
      "description": "----------    toastid_valueid_exists -      \tAs above, but work from toast rel's OID not an open relation    ----------"
    },
    {
      "method_name": "toast_get_valid_index",
      "file_path": "backend/access/common/toast_internals.c",
      "line_number": 529,
      "comment": "/* ----------\n * toast_get_valid_index\n *\n *\tGet OID of valid index associated to given toast relation. A toast\n *\trelation can have only one valid index at the same time.\n */",
      "description": "----------    toast_get_valid_index      \tGet OID of valid index associated to given toast relation. A toast   \trelation can have only one valid index at the same time."
    },
    {
      "method_name": "toast_open_indexes",
      "file_path": "backend/access/common/toast_internals.c",
      "line_number": 563,
      "comment": "/* ----------\n * toast_open_indexes\n *\n *\tGet an array of the indexes associated to the given toast relation\n *\tand return as well the position of the valid index used by the toast\n *\trelation in this array. It is the responsibility of the caller of this\n *\tfunction to close the indexes as well as free them.\n */",
      "description": "----------    toast_open_indexes      \tGet an array of the indexes associated to the given toast relation   \tand return as well the position of the valid index used by the toast   \trelation in this array."
    },
    {
      "method_name": "toast_close_indexes",
      "file_path": "backend/access/common/toast_internals.c",
      "line_number": 622,
      "comment": "/* ----------\n * toast_close_indexes\n *\n *\tClose an array of indexes for a toast relation and free it. This should\n *\tbe called for a set of indexes opened previously with toast_open_indexes.\n */",
      "description": "----------    toast_close_indexes      \tClose an array of indexes for a toast relation and free it. This should   \tbe called for a set of indexes opened previously with toast_open_indexes."
    },
    {
      "method_name": "init_toast_snapshot",
      "file_path": "backend/access/common/toast_internals.c",
      "line_number": 640,
      "comment": "/* ----------\n * init_toast_snapshot\n *\n *\tInitialize an appropriate TOAST snapshot.  We must use an MVCC snapshot\n *\tto initialize the TOAST snapshot; since we don't know which one to use,\n *\tjust use the oldest one.\n */",
      "description": "----------    init_toast_snapshot      \tInitialize an appropriate TOAST snapshot."
    },
    {
      "method_name": "convert_tuples_by_position",
      "file_path": "backend/access/common/tupconvert.c",
      "line_number": 58,
      "comment": "/*\n * Set up for tuple conversion, matching input and output columns by\n * position.  (Dropped columns are ignored in both input and output.)\n */",
      "description": "Set up for tuple conversion, matching input and output columns by    position.  (Dropped columns are ignored in both input and output.)"
    },
    {
      "method_name": "convert_tuples_by_name",
      "file_path": "backend/access/common/tupconvert.c",
      "line_number": 101,
      "comment": "/*\n * Set up for tuple conversion, matching input and output columns by name.\n * (Dropped columns are ignored in both input and output.)\tThis is intended\n * for use when the rowtypes are related by inheritance, so we expect an exact\n * match of both type and typmod.  The error messages will be a bit unhelpful\n * unless both rowtypes are named composite types.\n */",
      "description": "Set up for tuple conversion, matching input and output columns by name."
    },
    {
      "method_name": "convert_tuples_by_name_attrmap",
      "file_path": "backend/access/common/tupconvert.c",
      "line_number": 123,
      "comment": "/*\n * Set up tuple conversion for input and output TupleDescs using the given\n * AttrMap.\n */",
      "description": "Set up tuple conversion for input and output TupleDescs using the given    AttrMap."
    },
    {
      "method_name": "execute_attr_map_tuple",
      "file_path": "backend/access/common/tupconvert.c",
      "line_number": 153,
      "comment": "/*\n * Perform conversion of a tuple according to the map.\n */",
      "description": "Perform conversion of a tuple according to the map."
    },
    {
      "method_name": "execute_attr_map_slot",
      "file_path": "backend/access/common/tupconvert.c",
      "line_number": 191,
      "comment": "/*\n * Perform conversion of a tuple slot according to the map.\n */",
      "description": "Perform conversion of a tuple slot according to the map."
    },
    {
      "method_name": "execute_attr_map_cols",
      "file_path": "backend/access/common/tupconvert.c",
      "line_number": 251,
      "comment": "/*\n * Perform conversion of bitmap of columns according to the map.\n *\n * The input and output bitmaps are offset by\n * FirstLowInvalidHeapAttributeNumber to accommodate system cols, like the\n * column-bitmaps in RangeTblEntry.\n */",
      "description": "Perform conversion of bitmap of columns according to the map."
    },
    {
      "method_name": "free_conversion_map",
      "file_path": "backend/access/common/tupconvert.c",
      "line_number": 298,
      "comment": "/*\n * Free a TupleConversionMap structure.\n */",
      "description": "Free a TupleConversionMap structure."
    },
    {
      "method_name": "ResourceOwnerRememberTupleDesc",
      "file_path": "backend/access/common/tupdesc.c",
      "line_number": 47,
      "comment": "/* Convenience wrappers over ResourceOwnerRemember/Forget */",
      "description": "Convenience wrappers over ResourceOwnerRemember/Forget"
    },
    {
      "method_name": "ResourceOwnerForgetTupleDesc",
      "file_path": "backend/access/common/tupdesc.c",
      "line_number": 53,
      "comment": "/* Convenience wrappers over ResourceOwnerRemember/Forget */",
      "description": "Convenience wrappers over ResourceOwnerRemember/Forget"
    },
    {
      "method_name": "CreateTemplateTupleDesc",
      "file_path": "backend/access/common/tupdesc.c",
      "line_number": 66,
      "comment": "/*\n * CreateTemplateTupleDesc\n *\t\tThis function allocates an empty tuple descriptor structure.\n *\n * Tuple type ID information is initially set for an anonymous record type;\n * caller can overwrite this if needed.\n */",
      "description": "CreateTemplateTupleDesc   \t\tThis function allocates an empty tuple descriptor structure."
    },
    {
      "method_name": "CreateTupleDesc",
      "file_path": "backend/access/common/tupdesc.c",
      "line_number": 111,
      "comment": "/*\n * CreateTupleDesc\n *\t\tThis function allocates a new TupleDesc by copying a given\n *\t\tForm_pg_attribute array.\n *\n * Tuple type ID information is initially set for an anonymous record type;\n * caller can overwrite this if needed.\n */",
      "description": "CreateTupleDesc   \t\tThis function allocates a new TupleDesc by copying a given   \t\tForm_pg_attribute array."
    },
    {
      "method_name": "CreateTupleDescCopy",
      "file_path": "backend/access/common/tupdesc.c",
      "line_number": 132,
      "comment": "/*\n * CreateTupleDescCopy\n *\t\tThis function creates a new TupleDesc by copying from an existing\n *\t\tTupleDesc.\n *\n * !!! Constraints and defaults are not copied !!!\n */",
      "description": "CreateTupleDescCopy   \t\tThis function creates a new TupleDesc by copying from an existing   \t\tTupleDesc.       !!! Constraints and defaults are not copied !!!"
    },
    {
      "method_name": "CreateTupleDescCopyConstr",
      "file_path": "backend/access/common/tupdesc.c",
      "line_number": 172,
      "comment": "/*\n * CreateTupleDescCopyConstr\n *\t\tThis function creates a new TupleDesc by copying from an existing\n *\t\tTupleDesc (including its constraints and defaults).\n */",
      "description": "CreateTupleDescCopyConstr   \t\tThis function creates a new TupleDesc by copying from an existing   \t\tTupleDesc (including its constraints and defaults)."
    },
    {
      "method_name": "TupleDescCopy",
      "file_path": "backend/access/common/tupdesc.c",
      "line_number": 250,
      "comment": "/*\n * TupleDescCopy\n *\t\tCopy a tuple descriptor into caller-supplied memory.\n *\t\tThe memory may be shared memory mapped at any address, and must\n *\t\tbe sufficient to hold TupleDescSize(src) bytes.\n *\n * !!! Constraints and defaults are not copied !!!\n */",
      "description": "TupleDescCopy   \t\tCopy a tuple descriptor into caller-supplied memory."
    },
    {
      "method_name": "TupleDescCopyEntry",
      "file_path": "backend/access/common/tupdesc.c",
      "line_number": 288,
      "comment": "/*\n * TupleDescCopyEntry\n *\t\tThis function copies a single attribute structure from one tuple\n *\t\tdescriptor to another.\n *\n * !!! Constraints and defaults are not copied !!!\n */",
      "description": "TupleDescCopyEntry   \t\tThis function copies a single attribute structure from one tuple   \t\tdescriptor to another.       !!! Constraints and defaults are not copied !!!"
    },
    {
      "method_name": "FreeTupleDesc",
      "file_path": "backend/access/common/tupdesc.c",
      "line_number": 330,
      "comment": "/*\n * Free a TupleDesc including all substructure\n */",
      "description": "Free a TupleDesc including all substructure"
    },
    {
      "method_name": "IncrTupleDescRefCount",
      "file_path": "backend/access/common/tupdesc.c",
      "line_number": 387,
      "comment": "/*\n * Increment the reference count of a tupdesc, and log the reference in\n * CurrentResourceOwner.\n *\n * Do not apply this to tupdescs that are not being refcounted.  (Use the\n * macro PinTupleDesc for tupdescs of uncertain status.)\n */",
      "description": "Increment the reference count of a tupdesc, and log the reference in    CurrentResourceOwner."
    },
    {
      "method_name": "DecrTupleDescRefCount",
      "file_path": "backend/access/common/tupdesc.c",
      "line_number": 405,
      "comment": "/*\n * Decrement the reference count of a tupdesc, remove the corresponding\n * reference from CurrentResourceOwner, and free the tupdesc if no more\n * references remain.\n *\n * Do not apply this to tupdescs that are not being refcounted.  (Use the\n * macro ReleaseTupleDesc for tupdescs of uncertain status.)\n */",
      "description": "Decrement the reference count of a tupdesc, remove the corresponding    reference from CurrentResourceOwner, and free the tupdesc if no more    references remain."
    },
    {
      "method_name": "equalTupleDescs",
      "file_path": "backend/access/common/tupdesc.c",
      "line_number": 418,
      "comment": "/*\n * Compare two TupleDesc structures for logical equality\n */",
      "description": "Compare two TupleDesc structures for logical equality"
    },
    {
      "method_name": "equalRowTypes",
      "file_path": "backend/access/common/tupdesc.c",
      "line_number": 585,
      "comment": "/*\n * equalRowTypes\n *\n * This determines whether two tuple descriptors have equal row types.  This\n * only checks those fields in pg_attribute that are applicable for row types,\n * while ignoring those fields that define the physical row storage or those\n * that define table column metadata.\n *\n * Specifically, this checks:\n *\n * - same number of attributes\n * - same composite type ID (but could both be zero)\n * - corresponding attributes (in order) have same the name, type, typmod,\n *   collation\n *\n * This is used to check whether two record types are compatible, whether\n * function return row types are the same, and other similar situations.\n *\n * (XXX There was some discussion whether attndims should be checked here, but\n * for now it has been decided not to.)\n *\n * Note: We deliberately do not check the tdtypmod field.  This allows\n * typcache.c to use this routine to see if a cached record type matches a\n * requested type.\n */",
      "description": "equalRowTypes       This determines whether two tuple descriptors have equal row types."
    },
    {
      "method_name": "hashRowType",
      "file_path": "backend/access/common/tupdesc.c",
      "line_number": 621,
      "comment": "/*\n * hashRowType\n *\n * If two tuple descriptors would be considered equal by equalRowTypes()\n * then their hash value will be equal according to this function.\n */",
      "description": "hashRowType       If two tuple descriptors would be considered equal by equalRowTypes()    then their hash value will be equal according to this function."
    },
    {
      "method_name": "TupleDescInitEntry",
      "file_path": "backend/access/common/tupdesc.c",
      "line_number": 650,
      "comment": "/*\n * TupleDescInitEntry\n *\t\tThis function initializes a single attribute structure in\n *\t\ta previously allocated tuple descriptor.\n *\n * If attributeName is NULL, the attname field is set to an empty string\n * (this is for cases where we don't know or need a name for the field).\n * Also, some callers use this function to change the datatype-related fields\n * in an existing tupdesc; they pass attributeName = NameStr(att->attname)\n * to indicate that the attname field shouldn't be modified.\n *\n * Note that attcollation is set to the default for the specified datatype.\n * If a nondefault collation is needed, insert it afterwards using\n * TupleDescInitEntryCollation.\n */",
      "description": "TupleDescInitEntry   \t\tThis function initializes a single attribute structure in   \t\ta previously allocated tuple descriptor."
    },
    {
      "method_name": "TupleDescInitBuiltinEntry",
      "file_path": "backend/access/common/tupdesc.c",
      "line_number": 725,
      "comment": "/*\n * TupleDescInitBuiltinEntry\n *\t\tInitialize a tuple descriptor without catalog access.  Only\n *\t\ta limited range of builtin types are supported.\n */",
      "description": "TupleDescInitBuiltinEntry   \t\tInitialize a tuple descriptor without catalog access.  Only   \t\ta limited range of builtin types are supported."
    },
    {
      "method_name": "TupleDescInitEntryCollation",
      "file_path": "backend/access/common/tupdesc.c",
      "line_number": 832,
      "comment": "/*\n * TupleDescInitEntryCollation\n *\n * Assign a nondefault collation to a previously initialized tuple descriptor\n * entry.\n */",
      "description": "TupleDescInitEntryCollation       Assign a nondefault collation to a previously initialized tuple descriptor    entry."
    },
    {
      "method_name": "BuildDescFromLists",
      "file_path": "backend/access/common/tupdesc.c",
      "line_number": 857,
      "comment": "/*\n * BuildDescFromLists\n *\n * Build a TupleDesc given lists of column names (as String nodes),\n * column type OIDs, typmods, and collation OIDs.\n *\n * No constraints are generated.\n *\n * This is for use with functions returning RECORD.\n */",
      "description": "BuildDescFromLists       Build a TupleDesc given lists of column names (as String nodes),    column type OIDs, typmods, and collation OIDs."
    },
    {
      "method_name": "TupleDescGetDefault",
      "file_path": "backend/access/common/tupdesc.c",
      "line_number": 898,
      "comment": "/*\n * Get default expression (or NULL if none) for the given attribute number.\n */",
      "description": "Get default expression (or NULL if none) for the given attribute number."
    },
    {
      "method_name": "ResOwnerReleaseTupleDesc",
      "file_path": "backend/access/common/tupdesc.c",
      "line_number": 922,
      "comment": "/* ResourceOwner callbacks */",
      "description": "ResourceOwner callbacks"
    },
    {
      "method_name": "ResOwnerPrintTupleDesc",
      "file_path": "backend/access/common/tupdesc.c",
      "line_number": 933,
      "comment": "/* ResourceOwner callbacks */",
      "description": "ResourceOwner callbacks"
    },
    {
      "method_name": "ginarrayextract",
      "file_path": "backend/access/gin/ginarrayproc.c",
      "line_number": 32,
      "comment": "/*\n * extractValue support function\n */",
      "description": "extractValue support function"
    },
    {
      "method_name": "ginarrayextract_2args",
      "file_path": "backend/access/gin/ginarrayproc.c",
      "line_number": 67,
      "comment": "/*\n * Formerly, ginarrayextract had only two arguments.  Now it has three,\n * but we still need a pg_proc entry with two args to support reloading\n * pre-9.1 contrib/intarray opclass declarations.  This compatibility\n * function should go away eventually.\n */",
      "description": "Formerly, ginarrayextract had only two arguments."
    },
    {
      "method_name": "ginqueryarrayextract",
      "file_path": "backend/access/gin/ginarrayproc.c",
      "line_number": 78,
      "comment": "/*\n * extractQuery support function\n */",
      "description": "extractQuery support function"
    },
    {
      "method_name": "ginarrayconsistent",
      "file_path": "backend/access/gin/ginarrayproc.c",
      "line_number": 141,
      "comment": "/*\n * consistent support function\n */",
      "description": "consistent support function"
    },
    {
      "method_name": "ginarraytriconsistent",
      "file_path": "backend/access/gin/ginarrayproc.c",
      "line_number": 225,
      "comment": "/*\n * triconsistent support function\n */",
      "description": "triconsistent support function"
    },
    {
      "method_name": "ginTraverseLock",
      "file_path": "backend/access/gin/ginbtree.c",
      "line_number": 38,
      "comment": "/*\n * Lock buffer by needed method for search.\n */",
      "description": "Lock buffer by needed method for search."
    },
    {
      "method_name": "ginFindLeafPage",
      "file_path": "backend/access/gin/ginbtree.c",
      "line_number": 82,
      "comment": "/*\n * Descend the tree to the leaf page that contains or would contain the key\n * we're searching for. The key should already be filled in 'btree', in\n * tree-type specific manner. If btree->fullScan is true, descends to the\n * leftmost leaf page.\n *\n * If 'searchmode' is false, on return stack->buffer is exclusively locked,\n * and the stack represents the full path to the root. Otherwise stack->buffer\n * is share-locked, and stack->parent is NULL.\n *\n * If 'rootConflictCheck' is true, tree root is checked for serialization\n * conflict.\n */",
      "description": "Descend the tree to the leaf page that contains or would contain the key    we're searching for."
    },
    {
      "method_name": "ginStepRight",
      "file_path": "backend/access/gin/ginbtree.c",
      "line_number": 176,
      "comment": "/*\n * Step right from current page.\n *\n * The next page is locked first, before releasing the current page. This is\n * crucial to prevent concurrent VACUUM from deleting a page that we are about\n * to step to. (The lock-coupling isn't strictly necessary when we are\n * traversing the tree to find an insert location, because page deletion grabs\n * a cleanup lock on the root to prevent any concurrent inserts. See Page\n * deletion section in the README. But there's no harm in doing it always.)\n */",
      "description": "Step right from current page."
    },
    {
      "method_name": "freeGinBtreeStack",
      "file_path": "backend/access/gin/ginbtree.c",
      "line_number": 197,
      "comment": "/*\n * Step right from current page.\n *\n * The next page is locked first, before releasing the current page. This is\n * crucial to prevent concurrent VACUUM from deleting a page that we are about\n * to step to. (The lock-coupling isn't strictly necessary when we are\n * traversing the tree to find an insert location, because page deletion grabs\n * a cleanup lock on the root to prevent any concurrent inserts. See Page\n * deletion section in the README. But there's no harm in doing it always.)\n */",
      "description": "Step right from current page."
    },
    {
      "method_name": "ginFindParents",
      "file_path": "backend/access/gin/ginbtree.c",
      "line_number": 217,
      "comment": "/*\n * Try to find parent for current stack position. Returns correct parent and\n * child's offset in stack->parent. The root page is never released, to\n * prevent conflict with vacuum process.\n */",
      "description": "Try to find parent for current stack position. Returns correct parent and    child's offset in stack->parent. The root page is never released, to    prevent conflict with vacuum process."
    },
    {
      "method_name": "ginPlaceToPage",
      "file_path": "backend/access/gin/ginbtree.c",
      "line_number": 336,
      "comment": "/*\n * Insert a new item to a page.\n *\n * Returns true if the insertion was finished. On false, the page was split and\n * the parent needs to be updated. (A root split returns true as it doesn't\n * need any further action by the caller to complete.)\n *\n * When inserting a downlink to an internal page, 'childbuf' contains the\n * child page that was split. Its GIN_INCOMPLETE_SPLIT flag will be cleared\n * atomically with the insert. Also, the existing item at offset stack->off\n * in the target page is updated to point to updateblkno.\n *\n * stack->buffer is locked on entry, and is kept locked.\n * Likewise for childbuf, if given.\n */",
      "description": "Insert a new item to a page."
    },
    {
      "method_name": "ginFinishSplit",
      "file_path": "backend/access/gin/ginbtree.c",
      "line_number": 671,
      "comment": "/*\n * Finish a split by inserting the downlink for the new page to parent.\n *\n * On entry, stack->buffer is exclusively locked.\n *\n * If freestack is true, all the buffers are released and unlocked as we\n * crawl up the tree, and 'stack' is freed. Otherwise stack->buffer is kept\n * locked, and stack is unmodified, except for possibly moving right to find\n * the correct parent of page.\n */",
      "description": "Finish a split by inserting the downlink for the new page to parent."
    },
    {
      "method_name": "ginFinishOldSplit",
      "file_path": "backend/access/gin/ginbtree.c",
      "line_number": 778,
      "comment": "/*\n * An entry point to ginFinishSplit() that is used when we stumble upon an\n * existing incompletely split page in the tree, as opposed to completing a\n * split that we just made ourselves. The difference is that stack->buffer may\n * be merely share-locked on entry, and will be upgraded to exclusive mode.\n *\n * Note: Upgrading the lock momentarily releases it. Doing that in a scan\n * would not be OK, because a concurrent VACUUM might delete the page while\n * we're not holding the lock. It's OK in an insert, though, because VACUUM\n * has a different mechanism that prevents it from running concurrently with\n * inserts. (Namely, it holds a cleanup lock on the root.)\n */",
      "description": "An entry point to ginFinishSplit() that is used when we stumble upon an    existing incompletely split page in the tree, as opposed to completing a    split that we just made ourselves."
    },
    {
      "method_name": "ginInsertValue",
      "file_path": "backend/access/gin/ginbtree.c",
      "line_number": 815,
      "comment": "/*\n * Insert a value to tree described by stack.\n *\n * The value to be inserted is given in 'insertdata'. Its format depends\n * on whether this is an entry or data tree, ginInsertValue just passes it\n * through to the tree-specific callback function.\n *\n * During an index build, buildStats is non-null and the counters it contains\n * are incremented as needed.\n *\n * NB: the passed-in stack is freed, as though by freeGinBtreeStack.\n */",
      "description": "Insert a value to tree described by stack."
    },
    {
      "method_name": "ginCombineData",
      "file_path": "backend/access/gin/ginbulk.c",
      "line_number": 29,
      "comment": "/* Combiner function for rbtree.c */",
      "description": "Combiner function for rbtree.c"
    },
    {
      "method_name": "cmpEntryAccumulator",
      "file_path": "backend/access/gin/ginbulk.c",
      "line_number": 71,
      "comment": "/* Comparator function for rbtree.c */",
      "description": "Comparator function for rbtree.c"
    },
    {
      "method_name": "ginAllocEntryAccumulator",
      "file_path": "backend/access/gin/ginbulk.c",
      "line_number": 84,
      "comment": "/* Allocator function for rbtree.c */",
      "description": "Allocator function for rbtree.c"
    },
    {
      "method_name": "ginInitBA",
      "file_path": "backend/access/gin/ginbulk.c",
      "line_number": 108,
      "comment": "/* accum->ginstate is intentionally not set here */",
      "description": "accum->ginstate is intentionally not set here"
    },
    {
      "method_name": "getDatumCopy",
      "file_path": "backend/access/gin/ginbulk.c",
      "line_number": 127,
      "comment": "/*\n * This is basically the same as datumCopy(), but extended to count\n * palloc'd space in accum->allocatedMemory.\n */",
      "description": "This is basically the same as datumCopy(), but extended to count    palloc'd space in accum->allocatedMemory."
    },
    {
      "method_name": "ginInsertBAEntry",
      "file_path": "backend/access/gin/ginbulk.c",
      "line_number": 147,
      "comment": "/*\n * Find/store one entry from indexed value.\n */",
      "description": "Find/store one entry from indexed value."
    },
    {
      "method_name": "ginInsertBAEntries",
      "file_path": "backend/access/gin/ginbulk.c",
      "line_number": 209,
      "comment": "/*\n * Insert the entries for one heap pointer.\n *\n * Since the entries are being inserted into a balanced binary tree, you\n * might think that the order of insertion wouldn't be critical, but it turns\n * out that inserting the entries in sorted order results in a lot of\n * rebalancing operations and is slow.  To prevent this, we attempt to insert\n * the nodes in an order that will produce a nearly-balanced tree if the input\n * is in fact sorted.\n *\n * We do this as follows.  First, we imagine that we have an array whose size\n * is the smallest power of two greater than or equal to the actual array\n * size.  Second, we insert the middle entry of our virtual array into the\n * tree; then, we insert the middles of each half of our virtual array, then\n * middles of quarters, etc.\n */",
      "description": "Insert the entries for one heap pointer."
    },
    {
      "method_name": "ginBeginBAScan",
      "file_path": "backend/access/gin/ginbulk.c",
      "line_number": 256,
      "comment": "/* Prepare to read out the rbtree contents using ginGetBAEntry */",
      "description": "Prepare to read out the rbtree contents using ginGetBAEntry"
    },
    {
      "method_name": "ginGetBAEntry",
      "file_path": "backend/access/gin/ginbulk.c",
      "line_number": 267,
      "comment": "/*\n * Get the next entry in sequence from the BuildAccumulator's rbtree.\n * This consists of a single key datum and a list (array) of one or more\n * heap TIDs in which that key is found.  The list is guaranteed sorted.\n */",
      "description": "Get the next entry in sequence from the BuildAccumulator's rbtree."
    },
    {
      "method_name": "GinDataLeafPageGetItems",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 134,
      "comment": "/*\n * Read TIDs from leaf data page to single uncompressed array. The TIDs are\n * returned in ascending order.\n *\n * advancePast is a hint, indicating that the caller is only interested in\n * TIDs > advancePast. To return all items, use ItemPointerSetMin.\n *\n * Note: This function can still return items smaller than advancePast that\n * are in the same posting list as the items of interest, so the caller must\n * still check all the returned items. But passing it allows this function to\n * skip whole posting lists.\n */",
      "description": "Read TIDs from leaf data page to single uncompressed array."
    },
    {
      "method_name": "GinDataLeafPageGetItemsToTbm",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 181,
      "comment": "/*\n * Places all TIDs from leaf data page to bitmap.\n */",
      "description": "Places all TIDs from leaf data page to bitmap."
    },
    {
      "method_name": "dataLeafPageGetUncompressed",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 210,
      "comment": "/*\n * Get pointer to the uncompressed array of items on a pre-9.4 format\n * uncompressed leaf page. The number of items in the array is returned in\n * *nitems.\n */",
      "description": "Get pointer to the uncompressed array of items on a pre-9.4 format    uncompressed leaf page. The number of items in the array is returned in     nitems."
    },
    {
      "method_name": "dataIsMoveRight",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 233,
      "comment": "/*\n * Check if we should follow the right link to find the item we're searching\n * for.\n *\n * Compares inserting item pointer with the right bound of the current page.\n */",
      "description": "Check if we should follow the right link to find the item we're searching    for.       Compares inserting item pointer with the right bound of the current page."
    },
    {
      "method_name": "dataLocateItem",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 251,
      "comment": "/*\n * Find correct PostingItem in non-leaf page. It is assumed that this is\n * the correct page, and the searched value SHOULD be on the page.\n */",
      "description": "Find correct PostingItem in non-leaf page. It is assumed that this is    the correct page, and the searched value SHOULD be on the page."
    },
    {
      "method_name": "dataFindChildPtr",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 318,
      "comment": "/*\n * Find link to blkno on non-leaf page, returns offset of PostingItem\n */",
      "description": "Find link to blkno on non-leaf page, returns offset of PostingItem"
    },
    {
      "method_name": "dataGetLeftMostPage",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 363,
      "comment": "/*\n * Return blkno of leftmost child\n */",
      "description": "Return blkno of leftmost child"
    },
    {
      "method_name": "GinDataPageAddPostingItem",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 379,
      "comment": "/*\n * Add PostingItem to a non-leaf page.\n */",
      "description": "Add PostingItem to a non-leaf page."
    },
    {
      "method_name": "GinPageDeletePostingItem",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 416,
      "comment": "/*\n * Delete posting item from non-leaf page\n */",
      "description": "Delete posting item from non-leaf page"
    },
    {
      "method_name": "dataBeginPlaceToPageLeaf",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 447,
      "comment": "/*\n * Prepare to insert data on a leaf data page.\n *\n * If it will fit, return GPTP_INSERT after doing whatever setup is needed\n * before we enter the insertion critical section.  *ptp_workspace can be\n * set to pass information along to the execPlaceToPage function.\n *\n * If it won't fit, perform a page split and return two temporary page\n * images into *newlpage and *newrpage, with result GPTP_SPLIT.\n *\n * In neither case should the given page buffer be modified here.\n */",
      "description": "Prepare to insert data on a leaf data page."
    },
    {
      "method_name": "dataExecPlaceToPageLeaf",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 715,
      "comment": "/*\n * Perform data insertion after beginPlaceToPage has decided it will fit.\n *\n * This is invoked within a critical section, and XLOG record creation (if\n * needed) is already started.  The target buffer is registered in slot 0.\n */",
      "description": "Perform data insertion after beginPlaceToPage has decided it will fit."
    },
    {
      "method_name": "ginVacuumPostingTreeLeaf",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 737,
      "comment": "/*\n * Vacuum a posting tree leaf page.\n */",
      "description": "Vacuum a posting tree leaf page."
    },
    {
      "method_name": "computeLeafRecompressWALData",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 871,
      "comment": "/*\n * Construct a ginxlogRecompressDataLeaf record representing the changes\n * in *leaf.  (Because this requires a palloc, we have to do it before\n * we enter the critical section that actually updates the page.)\n */",
      "description": "Construct a ginxlogRecompressDataLeaf record representing the changes    in  leaf."
    },
    {
      "method_name": "dataPlaceToPageLeafRecompress",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 977,
      "comment": "/*\n * Assemble a disassembled posting tree leaf page back to a buffer.\n *\n * This just updates the target buffer; WAL stuff is caller's responsibility.\n *\n * NOTE: The segment pointers must not point directly to the same buffer,\n * except for segments that have not been modified and whose preceding\n * segments have not been modified either.\n */",
      "description": "Assemble a disassembled posting tree leaf page back to a buffer."
    },
    {
      "method_name": "dataPlaceToPageLeafSplit",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 1033,
      "comment": "/*\n * Like dataPlaceToPageLeafRecompress, but writes the disassembled leaf\n * segments to two pages instead of one.\n *\n * This is different from the non-split cases in that this does not modify\n * the original page directly, but writes to temporary in-memory copies of\n * the new left and right pages.\n */",
      "description": "Like dataPlaceToPageLeafRecompress, but writes the disassembled leaf    segments to two pages instead of one."
    },
    {
      "method_name": "dataBeginPlaceToPageInternal",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 1118,
      "comment": "/*\n * Prepare to insert data on an internal data page.\n *\n * If it will fit, return GPTP_INSERT after doing whatever setup is needed\n * before we enter the insertion critical section.  *ptp_workspace can be\n * set to pass information along to the execPlaceToPage function.\n *\n * If it won't fit, perform a page split and return two temporary page\n * images into *newlpage and *newrpage, with result GPTP_SPLIT.\n *\n * In neither case should the given page buffer be modified here.\n *\n * Note: on insertion to an internal node, in addition to inserting the given\n * item, the downlink of the existing item at stack->off will be updated to\n * point to updateblkno.\n */",
      "description": "Prepare to insert data on an internal data page."
    },
    {
      "method_name": "dataExecPlaceToPageInternal",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 1144,
      "comment": "/*\n * Perform data insertion after beginPlaceToPage has decided it will fit.\n *\n * This is invoked within a critical section, and XLOG record creation (if\n * needed) is already started.  The target buffer is registered in slot 0.\n */",
      "description": "Perform data insertion after beginPlaceToPage has decided it will fit."
    },
    {
      "method_name": "dataBeginPlaceToPage",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 1200,
      "comment": "/*\n * Prepare to insert data on a posting-tree data page.\n *\n * If it will fit, return GPTP_INSERT after doing whatever setup is needed\n * before we enter the insertion critical section.  *ptp_workspace can be\n * set to pass information along to the execPlaceToPage function.\n *\n * If it won't fit, perform a page split and return two temporary page\n * images into *newlpage and *newrpage, with result GPTP_SPLIT.\n *\n * In neither case should the given page buffer be modified here.\n *\n * Note: on insertion to an internal node, in addition to inserting the given\n * item, the downlink of the existing item at stack->off will be updated to\n * point to updateblkno.\n *\n * Calls relevant function for internal or leaf page because they are handled\n * very differently.\n */",
      "description": "Prepare to insert data on a posting-tree data page."
    },
    {
      "method_name": "dataExecPlaceToPage",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 1230,
      "comment": "/*\n * Perform data insertion after beginPlaceToPage has decided it will fit.\n *\n * This is invoked within a critical section, and XLOG record creation (if\n * needed) is already started.  The target buffer is registered in slot 0.\n *\n * Calls relevant function for internal or leaf page because they are handled\n * very differently.\n */",
      "description": "Perform data insertion after beginPlaceToPage has decided it will fit."
    },
    {
      "method_name": "dataSplitPageInternal",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 1251,
      "comment": "/*\n * Split internal page and insert new data.\n *\n * Returns new temp pages to *newlpage and *newrpage.\n * The original buffer is left untouched.\n */",
      "description": "Split internal page and insert new data.       Returns new temp pages to  newlpage and  newrpage.    The original buffer is left untouched."
    },
    {
      "method_name": "dataPrepareDownlink",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 1332,
      "comment": "/*\n * Construct insertion payload for inserting the downlink for given buffer.\n */",
      "description": "Construct insertion payload for inserting the downlink for given buffer."
    },
    {
      "method_name": "ginDataFillRoot",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 1348,
      "comment": "/*\n * Fills new root by right bound values from child.\n * Also called from ginxlog, should not use btree\n */",
      "description": "Fills new root by right bound values from child.    Also called from ginxlog, should not use btree"
    },
    {
      "method_name": "disassembleLeaf",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 1369,
      "comment": "/*\n * Disassemble page into a disassembledLeaf struct.\n */",
      "description": "Disassemble page into a disassembledLeaf struct."
    },
    {
      "method_name": "addItemsToLeaf",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 1443,
      "comment": "/*\n * Distribute newItems to the segments.\n *\n * Any segments that acquire new items are decoded, and the new items are\n * merged with the old items.\n *\n * Returns true if any new items were added. False means they were all\n * duplicates of existing items on the page.\n */",
      "description": "Distribute newItems to the segments."
    },
    {
      "method_name": "leafRepackItems",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 1570,
      "comment": "/*\n * Recompresses all segments that have been modified.\n *\n * If not all the items fit on two pages (ie. after split), we store as\n * many items as fit, and set *remaining to the first item that didn't fit.\n * If all items fit, *remaining is set to invalid.\n *\n * Returns true if the page has to be split.\n */",
      "description": "Recompresses all segments that have been modified."
    },
    {
      "method_name": "createPostingTree",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 1774,
      "comment": "/*\n * Creates new posting tree containing the given TIDs. Returns the page\n * number of the root of the new posting tree.\n *\n * items[] must be in sorted order with no duplicates.\n */",
      "description": "Creates new posting tree containing the given TIDs. Returns the page    number of the root of the new posting tree.       items[] must be in sorted order with no duplicates."
    },
    {
      "method_name": "ginInsertItemPointers",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 1907,
      "comment": "/*\n * Inserts array of item pointers, may execute several tree scan (very rare)\n */",
      "description": "Inserts array of item pointers, may execute several tree scan (very rare)"
    },
    {
      "method_name": "ginScanBeginPostingTree",
      "file_path": "backend/access/gin/gindatapage.c",
      "line_number": 1935,
      "comment": "/*\n * Starts a new scan on a posting tree.\n */",
      "description": "Starts a new scan on a posting tree."
    },
    {
      "method_name": "GinFormTuple",
      "file_path": "backend/access/gin/ginentrypage.c",
      "line_number": 43,
      "comment": "/*\n * Form a tuple for entry tree.\n *\n * If the tuple would be too big to be stored, function throws a suitable\n * error if errorTooBig is true, or returns NULL if errorTooBig is false.\n *\n * See src/backend/access/gin/README for a description of the index tuple\n * format that is being built here.  We build on the assumption that we\n * are making a leaf-level key entry containing a posting list of nipd items.\n * If the caller is actually trying to make a posting-tree entry, non-leaf\n * entry, or pending-list entry, it should pass dataSize = 0 and then overwrite\n * the t_tid fields as necessary.  In any case, 'data' can be NULL to skip\n * filling in the posting list; the caller is responsible for filling it\n * afterwards if data = NULL and nipd > 0.\n */",
      "description": "Form a tuple for entry tree."
    },
    {
      "method_name": "ginReadTuple",
      "file_path": "backend/access/gin/ginentrypage.c",
      "line_number": 161,
      "comment": "/*\n * Read item pointers from leaf entry tuple.\n *\n * Returns a palloc'd array of ItemPointers. The number of items is returned\n * in *nitems.\n */",
      "description": "Read item pointers from leaf entry tuple.       Returns a palloc'd array of ItemPointers. The number of items is returned    in  nitems."
    },
    {
      "method_name": "GinFormInteriorTuple",
      "file_path": "backend/access/gin/ginentrypage.c",
      "line_number": 200,
      "comment": "/*\n * Form a non-leaf entry tuple by copying the key data from the given tuple,\n * which can be either a leaf or non-leaf entry tuple.\n *\n * Any posting list in the source tuple is not copied.  The specified child\n * block number is inserted into t_tid.\n */",
      "description": "Form a non-leaf entry tuple by copying the key data from the given tuple,    which can be either a leaf or non-leaf entry tuple."
    }
  ],
  "stats": {
    "total_method_docs": 184,
    "total_documentation_entries": 184,
    "batches_processed": 5,
    "final_offset": 500
  }
}